# 1 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
# 1 "/doner/binutils/binutils-515f23e/bfd//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
# 21 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
# 1 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 1
# 29 "/doner/binutils/binutils-515f23e/bfd/sysdep.h"
# 1 "/doner/binutils/binutils-515f23e/bfd/config.h" 1
# 30 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 873 "/usr/include/stdio.h" 3 4

# 31 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2


# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 34 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2


# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 272 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 273 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1014 "/usr/include/stdlib.h" 2 3 4
# 1023 "/usr/include/stdlib.h" 3 4

# 37 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;
# 38 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 104 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 115 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 266 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 360 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 499 "/usr/include/string.h" 3 4

# 39 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2


# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 870 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 991 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1003 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1014 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1024 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1035 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1056 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1079 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1089 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1107 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1124 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1161 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;
# 1170 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));
# 1171 "/usr/include/unistd.h" 2 3 4


# 42 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4




# 45 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4




extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 46 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2


# 1 "/usr/include/x86_64-linux-gnu/sys/resource.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/resource.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,





  __RLIMIT_RTTIME = 15,


  __RLIMIT_NLIMITS = 16,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
# 131 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1



  ,

  RUSAGE_THREAD = 1




};


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 3 4
struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    __extension__ union
      {
 long int ru_maxrss;
 __syscall_slong_t __ru_maxrss_word;
      };


    __extension__ union
      {
 long int ru_ixrss;
 __syscall_slong_t __ru_ixrss_word;
      };

    __extension__ union
      {
 long int ru_idrss;
 __syscall_slong_t __ru_idrss_word;
      };

    __extension__ union
      {
 long int ru_isrss;
  __syscall_slong_t __ru_isrss_word;
      };


    __extension__ union
      {
 long int ru_minflt;
 __syscall_slong_t __ru_minflt_word;
      };

    __extension__ union
      {
 long int ru_majflt;
 __syscall_slong_t __ru_majflt_word;
      };

    __extension__ union
      {
 long int ru_nswap;
 __syscall_slong_t __ru_nswap_word;
      };


    __extension__ union
      {
 long int ru_inblock;
 __syscall_slong_t __ru_inblock_word;
      };

    __extension__ union
      {
 long int ru_oublock;
 __syscall_slong_t __ru_oublock_word;
      };

    __extension__ union
      {
 long int ru_msgsnd;
 __syscall_slong_t __ru_msgsnd_word;
      };

    __extension__ union
      {
 long int ru_msgrcv;
 __syscall_slong_t __ru_msgrcv_word;
      };

    __extension__ union
      {
 long int ru_nsignals;
 __syscall_slong_t __ru_nsignals_word;
      };



    __extension__ union
      {
 long int ru_nvcsw;
 __syscall_slong_t __ru_nvcsw_word;
      };


    __extension__ union
      {
 long int ru_nivcsw;
 __syscall_slong_t __ru_nivcsw_word;
      };
  };
# 180 "/usr/include/x86_64-linux-gnu/bits/resource.h" 2 3 4







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};







extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
      const struct rlimit *__new_limit,
      struct rlimit *__old_limit) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
        const struct rlimit64 *__new_limit,
        struct rlimit64 *__old_limit) __attribute__ ((__nothrow__ , __leaf__));




# 25 "/usr/include/x86_64-linux-gnu/sys/resource.h" 2 3 4













typedef enum __rlimit_resource __rlimit_resource_t;
typedef enum __rusage_who __rusage_who_t;
typedef enum __priority_which __priority_which_t;
# 50 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) __attribute__ ((__nothrow__ , __leaf__));
# 61 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) __attribute__ ((__nothrow__ , __leaf__));






extern int setrlimit (__rlimit_resource_t __resource,
        const struct rlimit *__rlimits) __attribute__ ((__nothrow__ , __leaf__));
# 81 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
   const struct rlimit64 *__rlimits) __attribute__ ((__nothrow__ , __leaf__));




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __attribute__ ((__nothrow__ , __leaf__));





extern int getpriority (__priority_which_t __which, id_t __who) __attribute__ ((__nothrow__ , __leaf__));



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));


# 49 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2





# 1 "./../include/fopen-same.h" 1
# 55 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2



# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 353 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 392 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 447 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 79 "/usr/include/fcntl.h" 2 3 4
# 148 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 168 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 178 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 293 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 304 "/usr/include/fcntl.h" 3 4

# 59 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2
# 89 "/doner/binutils/binutils-515f23e/bfd/sysdep.h"
# 1 "./../include/filenames.h" 1
# 29 "./../include/filenames.h"
# 1 "./../include/hashtab.h" 1
# 39 "./../include/hashtab.h"
# 1 "./../include/ansidecl.h" 1
# 40 "./../include/hashtab.h" 2



# 42 "./../include/hashtab.h"
typedef unsigned int hashval_t;




typedef hashval_t (*htab_hash) (const void *);






typedef int (*htab_eq) (const void *, const void *);



typedef void (*htab_del) (void *);





typedef int (*htab_trav) (void **, void *);





typedef void *(*htab_alloc) (size_t, size_t);


typedef void (*htab_free) (void *);



typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);
typedef void (*htab_free_with_arg) (void *, void *);
# 95 "./../include/hashtab.h"
struct htab {

  htab_hash hash_f;


  htab_eq eq_f;


  htab_del del_f;


  void **entries;


  size_t size;


  size_t n_elements;


  size_t n_deleted;



  unsigned int searches;



  unsigned int collisions;


  htab_alloc alloc_f;
  htab_free free_f;


  void *alloc_arg;
  htab_alloc_with_arg alloc_with_arg_f;
  htab_free_with_arg free_with_arg_f;



  unsigned int size_prime_index;
};

typedef struct htab *htab_t;


enum insert_option {NO_INSERT, INSERT};



extern htab_t htab_create_alloc (size_t, htab_hash,
                                    htab_eq, htab_del,
                                    htab_alloc, htab_free);

extern htab_t htab_create_alloc_ex (size_t, htab_hash,
                                      htab_eq, htab_del,
                                      void *, htab_alloc_with_arg,
                                      htab_free_with_arg);

extern htab_t htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,
     htab_alloc, htab_alloc, htab_free);


extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);
extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);

extern void htab_set_functions_ex (htab_t, htab_hash,
                                       htab_eq, htab_del,
                                       void *, htab_alloc_with_arg,
                                       htab_free_with_arg);

extern void htab_delete (htab_t);
extern void htab_empty (htab_t);

extern void * htab_find (htab_t, const void *);
extern void ** htab_find_slot (htab_t, const void *, enum insert_option);
extern void * htab_find_with_hash (htab_t, const void *, hashval_t);
extern void ** htab_find_slot_with_hash (htab_t, const void *,
       hashval_t, enum insert_option);
extern void htab_clear_slot (htab_t, void **);
extern void htab_remove_elt (htab_t, const void *);
extern void htab_remove_elt_with_hash (htab_t, const void *, hashval_t);

extern void htab_traverse (htab_t, htab_trav, void *);
extern void htab_traverse_noresize (htab_t, htab_trav, void *);

extern size_t htab_size (htab_t);
extern size_t htab_elements (htab_t);
extern double htab_collisions (htab_t);


extern htab_hash htab_hash_pointer;


extern htab_eq htab_eq_pointer;


extern hashval_t htab_hash_string (const void *);


extern int htab_eq_string (const void *, const void *);


extern hashval_t iterative_hash (const void *, size_t, hashval_t);
# 30 "./../include/filenames.h" 2
# 84 "./../include/filenames.h"
extern int filename_cmp (const char *s1, const char *s2);


extern int filename_ncmp (const char *s1, const char *s2,
     size_t n);

extern hashval_t filename_hash (const void *s);

extern int filename_eq (const void *s1, const void *s2);

extern int canonical_filename_eq (const char *a, const char *b);
# 90 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2
# 138 "/doner/binutils/binutils-515f23e/bfd/sysdep.h"
# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4


# 51 "/usr/include/locale.h" 3 4

# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) __attribute__ ((__nothrow__ , __leaf__));
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));



extern void freelocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));






extern locale_t uselocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));








# 139 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2


# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4





extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/libintl.h" 3 4

# 142 "/doner/binutils/binutils-515f23e/bfd/sysdep.h" 2
# 22 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2
# 1 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 1
# 43 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
# 1 "./../include/ansidecl.h" 1
# 44 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 2
# 1 "./../include/symcat.h" 1
# 45 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 2 3 4
# 46 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdbool.h" 1 3 4
# 47 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 2
# 1 "./../include/diagnostics.h" 1
# 48 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 49 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));


# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4



int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 5)));


# 39 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 447 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 534 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 51 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 2
# 80 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
# 1 "/usr/include/inttypes.h" 1 3 4
# 34 "/usr/include/inttypes.h" 3 4
typedef int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 432 "/usr/include/inttypes.h" 3 4

# 81 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 2
# 91 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
        
# 110 "/doner/binutils/binutils-515f23e/bfd/bfd.h"

# 110 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
typedef uint64_t bfd_vma;





typedef int64_t bfd_signed_vma;

typedef uint64_t bfd_size_type;
typedef uint64_t symvalue;
# 135 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
typedef int64_t file_ptr;
typedef uint64_t ufile_ptr;

typedef uint32_t flagword;
typedef uint8_t bfd_byte;


typedef struct bfd bfd;
struct bfd_link_info;
struct bfd_link_hash_entry;
typedef struct bfd_section *sec_ptr;
typedef struct reloc_cache_entry arelent;
struct orl;
# 163 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
static inline 
# 163 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 164 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
startswith (const char *str, const char *prefix)
{
  return strncmp (str, prefix, strlen (prefix)) == 0;
}


void *bfd_alloc (bfd *abfd, bfd_size_type wanted);

void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);

void bfd_release (bfd *, void *);
# 205 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_vma bfd_getb24 (const void *p);
bfd_vma bfd_getl24 (const void *p);
# 302 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
uint64_t bfd_getb64 (const void *);
uint64_t bfd_getl64 (const void *);
int64_t bfd_getb_signed_64 (const void *);
int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (uint64_t, void *);
void bfd_putl64 (uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb24 (bfd_vma, void *);
void bfd_putl24 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);
uint64_t bfd_get_bits (const void *, int, 
# 322 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                         _Bool
# 322 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                             );
void bfd_put_bits (uint64_t, void *, int, 
# 323 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                         _Bool
# 323 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                             );





struct bfd_hash_entry
{

  struct bfd_hash_entry *next;

  const char *string;


  unsigned long hash;
};



struct bfd_hash_table
{

  struct bfd_hash_entry **table;







  struct bfd_hash_entry *(*newfunc)
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


  void *memory;

  unsigned int size;

  unsigned int count;

  unsigned int entsize;

  unsigned int frozen:1;
};


# 368 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 368 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_hash_table_init_n
   (struct bfd_hash_table *,
    struct bfd_hash_entry *(* )
       (struct bfd_hash_entry *, struct bfd_hash_table *, const char *),
    unsigned int , unsigned int );


# 374 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 374 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_hash_table_init
   (struct bfd_hash_table *,
    struct bfd_hash_entry *(* )
       (struct bfd_hash_entry *, struct bfd_hash_table *, const char *),
    unsigned int );

void bfd_hash_table_free (struct bfd_hash_table *);

struct bfd_hash_entry *bfd_hash_lookup
   (struct bfd_hash_table *, const char *,
    
# 384 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
   _Bool 
# 384 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                  , 
# 384 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                    _Bool 
# 384 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                 );

struct bfd_hash_entry *bfd_hash_insert
   (struct bfd_hash_table *,
    const char *,
    unsigned long );

void bfd_hash_rename (struct bfd_hash_table *,
    const char *,
    struct bfd_hash_entry *);

void bfd_hash_replace (struct bfd_hash_table *,
    struct bfd_hash_entry * ,
    struct bfd_hash_entry * );

void *bfd_hash_allocate (struct bfd_hash_table *,
    unsigned int );

struct bfd_hash_entry *bfd_hash_newfunc
   (struct bfd_hash_entry *,
    struct bfd_hash_table *,
    const char *);

void bfd_hash_traverse
   (struct bfd_hash_table *,
    
# 409 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
   _Bool 
# 409 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
        (*) (struct bfd_hash_entry *, void *),
    void *);

unsigned int bfd_hash_set_default_size (unsigned int);



typedef struct lineno_cache_entry
{
  unsigned int line_number;
  union
  {
    struct bfd_symbol *sym;
    bfd_vma offset;
  } u;
}
alent;

typedef struct bfd_section
{


  const char *name;


  struct bfd_section *next;


  struct bfd_section *prev;


  unsigned int id;



  unsigned int section_id;


  unsigned int index;




  flagword flags;
# 653 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  unsigned int user_set_vma : 1;


  unsigned int linker_mark : 1;



  unsigned int linker_has_input : 1;


  unsigned int gc_mark : 1;


  unsigned int compress_status : 2;
# 675 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  unsigned int segment_mark : 1;


  unsigned int sec_info_type:3;
# 689 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  unsigned int use_rela_p:1;




  unsigned int sec_flg0:1;
  unsigned int sec_flg1:1;
  unsigned int sec_flg2:1;
  unsigned int sec_flg3:1;
  unsigned int sec_flg4:1;
  unsigned int sec_flg5:1;
# 709 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_vma vma;




  bfd_vma lma;




  bfd_size_type size;
# 729 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_size_type rawsize;


  bfd_size_type compressed_size;
# 741 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_vma output_offset;


  struct bfd_section *output_section;



  struct reloc_cache_entry *relocation;



  struct reloc_cache_entry **orelocation;


  unsigned reloc_count;



  unsigned int alignment_power;





  file_ptr filepos;


  file_ptr rel_filepos;


  file_ptr line_filepos;


  void *userdata;



  bfd_byte *contents;


  alent *lineno;


  unsigned int lineno_count;


  unsigned int entsize;



  struct bfd_section *kept_section;



  file_ptr moving_line_filepos;


  int target_index;

  void *used_by_bfd;



  struct relent_chain *constructor_chain;


  bfd *owner;


  struct bfd_symbol *symbol;
  struct bfd_symbol **symbol_ptr_ptr;






  union {
    struct bfd_link_order *link_order;
    struct bfd_section *s;
    const char *linked_to_symbol_name;
  } map_head, map_tail;




  struct bfd_section *already_assigned;


  unsigned int type;

} asection;

static inline const char *
bfd_section_name (const asection *sec)
{
  return sec->name;
}

static inline bfd_size_type
bfd_section_size (const asection *sec)
{
  return sec->size;
}

static inline bfd_vma
bfd_section_vma (const asection *sec)
{
  return sec->vma;
}

static inline bfd_vma
bfd_section_lma (const asection *sec)
{
  return sec->lma;
}

static inline unsigned int
bfd_section_alignment (const asection *sec)
{
  return sec->alignment_power;
}

static inline flagword
bfd_section_flags (const asection *sec)
{
  return sec->flags;
}

static inline void *
bfd_section_userdata (const asection *sec)
{
  return sec->userdata;
}
static inline 
# 875 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 876 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_is_com_section (const asection *sec)
{
  return (sec->flags & 0x1000) != 0;
}





static inline 
# 885 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 886 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_set_section_userdata (asection *sec, void *val)
{
  sec->userdata = val;
  return 
# 889 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
        1
# 889 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
            ;
}

static inline 
# 892 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 893 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_set_section_vma (asection *sec, bfd_vma val)
{
  sec->vma = sec->lma = val;
  sec->user_set_vma = 
# 896 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                     1
# 896 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                         ;
  return 
# 897 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
        1
# 897 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
            ;
}

static inline 
# 900 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 901 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_set_section_lma (asection *sec, bfd_vma val)
{
  sec->lma = val;
  return 
# 904 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
        1
# 904 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
            ;
}

static inline 
# 907 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 908 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_set_section_alignment (asection *sec, unsigned int val)
{
  if (val >= sizeof (bfd_vma) * 8 - 1)
    return 
# 911 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
          0
# 911 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
               ;
  sec->alignment_power = val;
  return 
# 913 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
        1
# 913 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
            ;
}




extern asection _bfd_std_section[4];
# 935 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
static inline 
# 935 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 936 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_is_und_section (const asection *sec)
{
  return sec == (&_bfd_std_section[1]);
}

static inline 
# 941 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 942 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_is_abs_section (const asection *sec)
{
  return sec == (&_bfd_std_section[2]);
}

static inline 
# 947 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 948 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_is_ind_section (const asection *sec)
{
  return sec == (&_bfd_std_section[3]);
}

static inline 
# 953 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 954 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_is_const_section (const asection *sec)
{
  return (sec >= _bfd_std_section
   && sec < _bfd_std_section + (sizeof (_bfd_std_section)
           / sizeof (_bfd_std_section[0])));
}


static inline 
# 962 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 963 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
discarded_section (const asection *sec)
{
  return (!bfd_is_abs_section (sec)
   && bfd_is_abs_section (sec->output_section)
   && sec->sec_info_type != 2
   && sec->sec_info_type != 4);
}
# 1022 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
void bfd_section_list_clear (bfd *);

asection *bfd_get_section_by_name (bfd *abfd, const char *name);

asection *bfd_get_next_section_by_name (bfd *ibfd, asection *sec);

asection *bfd_get_linker_section (bfd *abfd, const char *name);

asection *bfd_get_section_by_name_if
   (bfd *abfd,
    const char *name,
    
# 1033 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
   _Bool 
# 1033 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
        (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

char *bfd_get_unique_section_name
   (bfd *abfd, const char *templat, int *count);

asection *bfd_make_section_old_way (bfd *abfd, const char *name);

asection *bfd_make_section_anyway_with_flags
   (bfd *abfd, const char *name, flagword flags);

asection *bfd_make_section_anyway (bfd *abfd, const char *name);

asection *bfd_make_section_with_flags
   (bfd *, const char *name, flagword flags);

asection *bfd_make_section (bfd *, const char *name);


# 1051 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1051 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_section_flags (asection *sec, flagword flags);

void bfd_rename_section
   (asection *sec, const char *newname);

void bfd_map_over_sections
   (bfd *abfd,
    void (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

asection *bfd_sections_find_if
   (bfd *abfd,
    
# 1063 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
   _Bool 
# 1063 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
        (*operation) (bfd *abfd, asection *sect, void *obj),
    void *obj);


# 1066 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1066 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_section_size (asection *sec, bfd_size_type val);


# 1068 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1068 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_section_contents
   (bfd *abfd, asection *section, const void *data,
    file_ptr offset, bfd_size_type count);


# 1072 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1072 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_get_section_contents
   (bfd *abfd, asection *section, void *location, file_ptr offset,
    bfd_size_type count);


# 1076 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1076 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_malloc_and_get_section
   (bfd *abfd, asection *section, bfd_byte **buf);


# 1079 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1079 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_copy_private_section_data
   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);





# 1085 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1085 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_generic_is_group_section (bfd *, const asection *sec);

const char *bfd_generic_group_name (bfd *, const asection *sec);


# 1089 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1089 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_generic_discard_group (bfd *abfd, asection *group);


typedef struct bfd_symbol
{
# 1103 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  struct bfd *the_bfd;



  const char *name;




  symvalue value;
# 1221 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  flagword flags;




  struct bfd_section *section;


  union
    {
      void *p;
      bfd_vma i;
    }
  udata;
}
asymbol;

typedef enum bfd_print_symbol
{
  bfd_print_symbol_name,
  bfd_print_symbol_more,
  bfd_print_symbol_all
} bfd_print_symbol_type;



typedef struct _symbol_info
{
  symvalue value;
  char type;
  const char *name;
  unsigned char stab_type;
  char stab_other;
  short stab_desc;
  const char *stab_name;
} symbol_info;





# 1261 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1261 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_is_local_label (bfd *abfd, asymbol *sym);


# 1263 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1263 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_is_local_label_name (bfd *abfd, const char *name);





# 1268 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1268 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);








# 1276 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1276 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_symtab
   (bfd *abfd, asymbol **location, unsigned int count);

void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);




asymbol *_bfd_generic_make_empty_symbol (bfd *);




int bfd_decode_symclass (asymbol *symbol);


# 1291 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1291 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_is_undefined_symclass (int symclass);

void bfd_symbol_info (asymbol *symbol, symbol_info *ret);


# 1295 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1295 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_copy_private_symbol_data
   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
# 1305 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
typedef struct carsym
{
  const char *name;
  file_ptr file_offset;
}
carsym;


 typedef unsigned long symindex;


symindex bfd_get_next_mapent
   (bfd *abfd, symindex previous, carsym **sym);


# 1319 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1319 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_archive_head (bfd *output, bfd *new_head);

bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);


enum bfd_architecture
{
  bfd_arch_unknown,
  bfd_arch_obscure,
  bfd_arch_m68k,
# 1360 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_vax,

  bfd_arch_or1k,



  bfd_arch_sparc,
# 1404 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_spu,

  bfd_arch_mips,
# 1456 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_i386,
# 1465 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_iamcu,



  bfd_arch_romp,
  bfd_arch_convex,
  bfd_arch_m98k,
  bfd_arch_pyramid,
  bfd_arch_h8300,







  bfd_arch_pdp11,
  bfd_arch_powerpc,
# 1509 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_rs6000,




  bfd_arch_hppa,




  bfd_arch_d10v,



  bfd_arch_d30v,
  bfd_arch_dlx,
  bfd_arch_m68hc11,
  bfd_arch_m68hc12,



  bfd_arch_m9s12x,
  bfd_arch_m9s12xg,
  bfd_arch_s12z,

  bfd_arch_z8k,


  bfd_arch_sh,
# 1558 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_alpha,



  bfd_arch_arm,
# 1592 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_nds32,





  bfd_arch_ns32k,
  bfd_arch_tic30,
  bfd_arch_tic4x,


  bfd_arch_tic54x,
  bfd_arch_tic6x,
  bfd_arch_v850,
  bfd_arch_v850_rh850,






  bfd_arch_arc,






 bfd_arch_m32c,


  bfd_arch_m32r,



  bfd_arch_mn10200,
  bfd_arch_mn10300,



  bfd_arch_fr30,

  bfd_arch_frv,
# 1643 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_moxie,

  bfd_arch_ft32,


  bfd_arch_mcore,
  bfd_arch_mep,



  bfd_arch_metag,

  bfd_arch_ia64,


  bfd_arch_ip2k,


 bfd_arch_iq2000,


  bfd_arch_bpf,


  bfd_arch_epiphany,


  bfd_arch_mt,



  bfd_arch_pj,
  bfd_arch_avr,
# 1694 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_bfin,

  bfd_arch_cr16,

  bfd_arch_crx,

  bfd_arch_cris,



  bfd_arch_riscv,


  bfd_arch_rl78,

  bfd_arch_rx,



  bfd_arch_s390,


  bfd_arch_score,


  bfd_arch_mmix,
  bfd_arch_xstormy16,

  bfd_arch_msp430,
# 1747 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_xgate,

  bfd_arch_xtensa,

  bfd_arch_z80,
# 1771 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_lm32,

  bfd_arch_microblaze,
  bfd_arch_tilepro,
  bfd_arch_tilegx,



  bfd_arch_aarch64,




  bfd_arch_nios2,



  bfd_arch_visium,

  bfd_arch_wasm32,

  bfd_arch_pru,

  bfd_arch_nfp,


  bfd_arch_csky,
# 1807 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_loongarch,


  bfd_arch_amdgcn,
# 1823 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_arch_last
  };

typedef struct bfd_arch_info
{
  int bits_per_word;
  int bits_per_address;
  int bits_per_byte;
  enum bfd_architecture arch;
  unsigned long mach;
  const char *arch_name;
  const char *printable_name;
  unsigned int section_align_power;



  
# 1839 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 1839 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      the_default;
  const struct bfd_arch_info * (*compatible) (const struct bfd_arch_info *,
           const struct bfd_arch_info *);

  
# 1843 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 1843 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*scan) (const struct bfd_arch_info *, const char *);




  void *(*fill) (bfd_size_type count, 
# 1848 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                     _Bool 
# 1848 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                          is_bigendian, 
# 1848 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                                        _Bool 
# 1848 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                                             code);

  const struct bfd_arch_info *next;
# 1860 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  signed int max_reloc_offset_into_insn;
}
bfd_arch_info_type;

const char *bfd_printable_name (bfd *abfd);

const bfd_arch_info_type *bfd_scan_arch (const char *string);

const char **bfd_arch_list (void);

const bfd_arch_info_type *bfd_arch_get_compatible
   (const bfd *abfd, const bfd *bbfd, 
# 1871 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                     _Bool 
# 1871 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                          accept_unknowns);

void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);


# 1875 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 1875 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_default_set_arch_mach
   (bfd *abfd, enum bfd_architecture arch, unsigned long mach);

enum bfd_architecture bfd_get_arch (const bfd *abfd);

unsigned long bfd_get_mach (const bfd *abfd);

unsigned int bfd_arch_bits_per_byte (const bfd *abfd);

unsigned int bfd_arch_bits_per_address (const bfd *abfd);

const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);

const bfd_arch_info_type *bfd_lookup_arch
   (enum bfd_architecture arch, unsigned long machine);

const char *bfd_printable_arch_mach
   (enum bfd_architecture arch, unsigned long machine);

unsigned int bfd_octets_per_byte (const bfd *abfd,
    const asection *sec);

unsigned int bfd_arch_mach_octets_per_byte
   (enum bfd_architecture arch, unsigned long machine);


typedef enum bfd_format
  {
    bfd_unknown = 0,
    bfd_object,
    bfd_archive,
    bfd_core,
    bfd_type_end
  }
bfd_format;

enum bfd_direction
  {
    no_direction = 0,
    read_direction = 1,
    write_direction = 2,
    both_direction = 3
  };

enum bfd_plugin_format
  {
    bfd_plugin_unknown = 0,
    bfd_plugin_yes = 1,
    bfd_plugin_no = 2
  };

struct bfd_build_id
  {
    bfd_size_type size;
    bfd_byte data[1];
  };

struct bfd
{

  const char *filename;


  const struct bfd_target *xvec;



  void *iostream;
  const struct bfd_iovec *iovec;



  struct bfd *lru_prev, *lru_next;




  ufile_ptr where;


  long mtime;


  unsigned int id;


  flagword flags;
# 2066 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  __extension__ enum bfd_format format : 3;


  __extension__ enum bfd_direction direction : 2;



  unsigned int cacheable : 1;




  unsigned int target_defaulted : 1;


  unsigned int opened_once : 1;



  unsigned int mtime_set : 1;


  unsigned int no_export : 1;



  unsigned int output_has_begun : 1;


  unsigned int has_armap : 1;


  unsigned int is_thin_archive : 1;


  unsigned int no_element_cache : 1;



  unsigned int selective_search : 1;


  unsigned int is_linker_output : 1;


  unsigned int is_linker_input : 1;


  __extension__ enum bfd_plugin_format plugin_format : 2;


  unsigned int lto_output : 1;


  unsigned int lto_slim_object : 1;



  unsigned int read_only : 1;



  bfd *plugin_dummy_bfd;



  ufile_ptr origin;






  ufile_ptr proxy_origin;


  struct bfd_hash_table section_htab;


  struct bfd_section *sections;


  struct bfd_section *section_last;


  unsigned int section_count;


  int archive_plugin_fd;


  unsigned int archive_plugin_fd_open_count;



  int archive_pass;


  bfd_size_type alloc_size;



  bfd_vma start_address;



  struct bfd_symbol **outsymbols;


  unsigned int symcount;


  unsigned int dynsymcount;


  const struct bfd_arch_info *arch_info;




  ufile_ptr size;


  void *arelt_data;
  struct bfd *my_archive;
  struct bfd *archive_next;
  struct bfd *archive_head;
  struct bfd *nested_archives;


  union {

    struct bfd *next;

    struct bfd_link_hash_table *hash;
  } link;


  union
    {
      struct aout_data_struct *aout_data;
      struct artdata *aout_ar_data;
      struct coff_tdata *coff_obj_data;
      struct pe_tdata *pe_obj_data;
      struct xcoff_tdata *xcoff_obj_data;
      struct ecoff_tdata *ecoff_obj_data;
      struct srec_data_struct *srec_data;
      struct verilog_data_struct *verilog_data;
      struct ihex_data_struct *ihex_data;
      struct tekhex_data_struct *tekhex_data;
      struct elf_obj_tdata *elf_obj_data;
      struct mmo_data_struct *mmo_data;
      struct trad_core_struct *trad_core_data;
      struct som_data_struct *som_data;
      struct hpux_core_struct *hpux_core_data;
      struct hppabsd_core_struct *hppabsd_core_data;
      struct sgi_core_struct *sgi_core_data;
      struct lynx_core_struct *lynx_core_data;
      struct osf_core_struct *osf_core_data;
      struct cisco_core_struct *cisco_core_data;
      struct netbsd_core_struct *netbsd_core_data;
      struct mach_o_data_struct *mach_o_data;
      struct mach_o_fat_data_struct *mach_o_fat_data;
      struct plugin_data_struct *plugin_data;
      struct bfd_pef_data_struct *pef_data;
      struct bfd_pef_xlib_data_struct *pef_xlib_data;
      struct bfd_sym_data_struct *sym_data;
      void *any;
    }
  tdata;


  void *usrdata;




  void *memory;


  const struct bfd_build_id *build_id;
};

static inline const char *
bfd_get_filename (const bfd *abfd)
{
  return abfd->filename;
}

static inline 
# 2255 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 2256 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_get_cacheable (const bfd *abfd)
{
  return abfd->cacheable;
}

static inline enum bfd_format
bfd_get_format (const bfd *abfd)
{
  return abfd->format;
}

static inline flagword
bfd_get_file_flags (const bfd *abfd)
{
  return abfd->flags;
}

static inline bfd_vma
bfd_get_start_address (const bfd *abfd)
{
  return abfd->start_address;
}

static inline unsigned int
bfd_get_symcount (const bfd *abfd)
{
  return abfd->symcount;
}

static inline unsigned int
bfd_get_dynamic_symcount (const bfd *abfd)
{
  return abfd->dynsymcount;
}

static inline struct bfd_symbol **
bfd_get_outsymbols (const bfd *abfd)
{
  return abfd->outsymbols;
}

static inline unsigned int
bfd_count_sections (const bfd *abfd)
{
  return abfd->section_count;
}

static inline 
# 2303 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 2304 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_has_map (const bfd *abfd)
{
  return abfd->has_armap;
}

static inline 
# 2309 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 2310 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_is_thin_archive (const bfd *abfd)
{
  return abfd->is_thin_archive;
}

static inline void *
bfd_usrdata (const bfd *abfd)
{
  return abfd->usrdata;
}


static inline 
# 2322 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 2323 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_set_cacheable (bfd * abfd, 
# 2323 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                              _Bool 
# 2323 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                   val)
{
  abfd->cacheable = val;
  return 
# 2326 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
        1
# 2326 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
            ;
}

static inline void
bfd_set_thin_archive (bfd *abfd, 
# 2330 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                _Bool 
# 2330 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                     val)
{
  abfd->is_thin_archive = val;
}

static inline void
bfd_set_usrdata (bfd *abfd, void *val)
{
  abfd->usrdata = val;
}

static inline asection *
bfd_asymbol_section (const asymbol *sy)
{
  return sy->section;
}

static inline bfd_vma
bfd_asymbol_value (const asymbol *sy)
{
  return sy->section->vma + sy->value;
}

static inline const char *
bfd_asymbol_name (const asymbol *sy)
{
  return sy->name;
}

static inline struct bfd *
bfd_asymbol_bfd (const asymbol *sy)
{
  return sy->the_bfd;
}

static inline void
bfd_set_asymbol_name (asymbol *sy, const char *name)
{
  sy->name = name;
}



static inline bfd_size_type
bfd_get_section_limit_octets (const bfd *abfd, const asection *sec)
{
  if (abfd->direction != write_direction && sec->rawsize != 0)
    return sec->rawsize;
  return sec->size;
}


static inline bfd_size_type
bfd_get_section_limit (const bfd *abfd, const asection *sec)
{
  return (bfd_get_section_limit_octets (abfd, sec)
   / bfd_octets_per_byte (abfd, sec));
}




static inline bfd_size_type
bfd_get_section_alloc_size (const bfd *abfd, const asection *sec)
{
  if (abfd->direction != write_direction && sec->rawsize > sec->size)
    return sec->rawsize;
  return sec->size;
}




static inline void
bfd_section_list_remove (bfd *abfd, asection *s)
{
  asection *next = s->next;
  asection *prev = s->prev;
  if (prev)
    prev->next = next;
  else
    abfd->sections = next;
  if (next)
    next->prev = prev;
  else
    abfd->section_last = prev;
}

static inline void
bfd_section_list_append (bfd *abfd, asection *s)
{
  s->next = 0;
  if (abfd->section_last)
    {
      s->prev = abfd->section_last;
      abfd->section_last->next = s;
    }
  else
    {
      s->prev = 0;
      abfd->sections = s;
    }
  abfd->section_last = s;
}

static inline void
bfd_section_list_prepend (bfd *abfd, asection *s)
{
  s->prev = 0;
  if (abfd->sections)
    {
      s->next = abfd->sections;
      abfd->sections->prev = s;
    }
  else
    {
      s->next = 0;
      abfd->section_last = s;
    }
  abfd->sections = s;
}

static inline void
bfd_section_list_insert_after (bfd *abfd, asection *a, asection *s)
{
  asection *next = a->next;
  s->next = next;
  s->prev = a;
  a->next = s;
  if (next)
    next->prev = s;
  else
    abfd->section_last = s;
}

static inline void
bfd_section_list_insert_before (bfd *abfd, asection *b, asection *s)
{
  asection *prev = b->prev;
  s->prev = prev;
  s->next = b;
  b->prev = s;
  if (prev)
    prev->next = s;
  else
    abfd->sections = s;
}

static inline 
# 2478 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 2479 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_section_removed_from_list (const bfd *abfd, const asection *s)
{
  return s->next ? s->next->prev != s : abfd->section_last != s;
}

typedef enum bfd_error
{
  bfd_error_no_error = 0,
  bfd_error_system_call,
  bfd_error_invalid_target,
  bfd_error_wrong_format,
  bfd_error_wrong_object_format,
  bfd_error_invalid_operation,
  bfd_error_no_memory,
  bfd_error_no_symbols,
  bfd_error_no_armap,
  bfd_error_no_more_archived_files,
  bfd_error_malformed_archive,
  bfd_error_missing_dso,
  bfd_error_file_not_recognized,
  bfd_error_file_ambiguously_recognized,
  bfd_error_no_contents,
  bfd_error_nonrepresentable_section,
  bfd_error_no_debug_section,
  bfd_error_bad_value,
  bfd_error_file_truncated,
  bfd_error_file_too_big,
  bfd_error_sorry,
  bfd_error_on_input,
  bfd_error_invalid_error_code
}
bfd_error_type;

bfd_error_type bfd_get_error (void);

void bfd_set_error (bfd_error_type error_tag);

void bfd_set_input_error (bfd *input, bfd_error_type error_tag);

const char *bfd_errmsg (bfd_error_type error_tag);

void bfd_perror (const char *message);

typedef void (*bfd_error_handler_type) (const char *, va_list);

void _bfd_error_handler (const char *fmt, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));

bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);

void bfd_set_error_program_name (const char *);

typedef void (*bfd_assert_handler_type) (const char *bfd_formatmsg,
      const char *bfd_version,
      const char *bfd_file,
      int bfd_line);

bfd_assert_handler_type bfd_set_assert_handler (bfd_assert_handler_type);

unsigned int bfd_init (void);




long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);

long bfd_canonicalize_reloc
   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);

void bfd_set_reloc
   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);




# 2552 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2552 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_file_flags (bfd *abfd, flagword flags);

int bfd_get_arch_size (bfd *abfd);

int bfd_get_sign_extend_vma (bfd *abfd);


# 2558 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2558 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_start_address (bfd *abfd, bfd_vma vma);

unsigned int bfd_get_gp_size (bfd *abfd);

void bfd_set_gp_size (bfd *abfd, unsigned int i);

void bfd_set_gp_value (bfd *abfd, bfd_vma v);

bfd_vma bfd_scan_vma (const char *string, const char **end, int base);


# 2568 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2568 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);





# 2573 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2573 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);





# 2578 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2578 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_private_flags (bfd *abfd, flagword flags);
# 2681 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_byte *bfd_get_relocated_section_contents
   (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
    
# 2683 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
   _Bool
# 2683 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
       , asymbol **);


# 2685 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2685 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_record_phdr
   (bfd *, unsigned long, 
# 2686 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                         _Bool
# 2686 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                             , flagword, 
# 2686 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                         _Bool
# 2686 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                             , bfd_vma,
    
# 2687 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
   _Bool
# 2687 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
       , 
# 2687 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
         _Bool
# 2687 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
             , unsigned int, struct bfd_section **);

void bfd_sprintf_vma (bfd *, char *, bfd_vma);
void bfd_fprintf_vma (bfd *, void *, bfd_vma);




# 2694 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2694 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_alt_mach_code (bfd *abfd, int alternative);

bfd_vma bfd_emul_get_maxpagesize (const char *);

bfd_vma bfd_emul_get_commonpagesize (const char *);

char *bfd_demangle (bfd *, const char *, int);


bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);

bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);

file_ptr bfd_tell (bfd *);

int bfd_flush (bfd *);

int bfd_stat (bfd *, struct stat *);

int bfd_seek (bfd *, file_ptr, int);

long bfd_get_mtime (bfd *abfd);

ufile_ptr bfd_get_size (bfd *abfd);

ufile_ptr bfd_get_file_size (bfd *abfd);

void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
    int prot, int flags, file_ptr offset,
    void **map_addr, bfd_size_type *map_len);


struct _bfd_window_internal;

typedef struct _bfd_window
{

  void *data;
  bfd_size_type size;






  struct _bfd_window_internal *i;
}
bfd_window;

void bfd_init_window (bfd_window *);

void bfd_free_window (bfd_window *);


# 2747 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2747 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_get_file_window
   (bfd *, file_ptr, bfd_size_type, bfd_window *, 
# 2748 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                                 _Bool 
# 2748 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                                                  );



# 2751 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2751 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_cache_close (bfd *abfd);


# 2753 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2753 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_cache_close_all (void);



enum compressed_debug_section_type
{
  COMPRESS_DEBUG_NONE = 0,
  COMPRESS_DEBUG_GNU_ZLIB = 1 << 1,
  COMPRESS_DEBUG_GABI_ZLIB = 1 << 2,
  COMPRESS_DEBUG_ZSTD = 1 << 3,
  COMPRESS_UNKNOWN = 1 << 4
};


struct compressed_type_tuple
{
  enum compressed_debug_section_type type;
  const char *name;
};


enum compression_type
{
  ch_none = 0,
  ch_compress_zlib = 1 ,
  ch_compress_zstd = 2
};

static inline char *
bfd_debug_name_to_zdebug (bfd *abfd, const char *name)
{
  size_t len = strlen (name);
  char *new_name = (char *) bfd_alloc (abfd, len + 2);
  if (new_name == 
# 2786 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                 ((void *)0)
# 2786 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                     )
    return 
# 2787 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
          ((void *)0)
# 2787 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
              ;
  new_name[0] = '.';
  new_name[1] = 'z';
  memcpy (new_name + 2, name + 1, len);
  return new_name;
}

static inline char *
bfd_zdebug_name_to_debug (bfd *abfd, const char *name)
{
  size_t len = strlen (name);
  char *new_name = (char *) bfd_alloc (abfd, len);
  if (new_name == 
# 2799 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                 ((void *)0)
# 2799 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                     )
    return 
# 2800 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
          ((void *)0)
# 2800 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
              ;
  new_name[0] = '.';
  memcpy (new_name + 1, name + 2, len - 1);
  return new_name;
}

enum compressed_debug_section_type
bfd_get_compression_algorithm (const char *name);

const char *bfd_get_compression_algorithm_name
   (enum compressed_debug_section_type type);

void bfd_update_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec);

int bfd_get_compression_header_size (bfd *abfd, asection *sec);


# 2817 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2817 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_convert_section_setup
   (bfd *ibfd, asection *isec, bfd *obfd,
    const char **new_name, bfd_size_type *new_size);


# 2821 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2821 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_convert_section_contents
   (bfd *ibfd, asection *isec, bfd *obfd,
    bfd_byte **ptr, bfd_size_type *ptr_size);


# 2825 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2825 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_get_full_section_contents
   (bfd *abfd, asection *section, bfd_byte **ptr);


# 2828 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2828 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_is_section_compressed_info
   (bfd *abfd, asection *section,
    int *compression_header_size_p,
    bfd_size_type *uncompressed_size_p,
    unsigned int *uncompressed_alignment_power_p,
    enum compression_type *ch_type);


# 2835 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2835 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_is_section_compressed
   (bfd *abfd, asection *section);


# 2838 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2838 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_init_section_decompress_status
   (bfd *abfd, asection *section);


# 2841 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2841 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_init_section_compress_status
   (bfd *abfd, asection *section);


# 2844 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2844 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_compress_section
   (bfd *abfd, asection *section, bfd_byte *uncompressed_buffer);


const char *bfd_core_file_failing_command (bfd *abfd);

int bfd_core_file_failing_signal (bfd *abfd);

int bfd_core_file_pid (bfd *abfd);


# 2854 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2854 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);


# 2857 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2857 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    generic_core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);



# 2861 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2861 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_check_format (bfd *abfd, bfd_format format);


# 2863 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2863 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_check_format_matches
   (bfd *abfd, bfd_format format, char ***matching);


# 2866 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2866 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_format (bfd *abfd, bfd_format format);

const char *bfd_format_string (bfd_format format);
# 2882 "/doner/binutils/binutils-515f23e/bfd/bfd.h"

# 2882 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2882 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_link_split_section (bfd *abfd, asection *sec);





# 2887 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2887 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_section_already_linked (bfd *abfd,
    asection *sec,
    struct bfd_link_info *info);





# 2894 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2894 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_generic_define_common_symbol
   (bfd *output_bfd, struct bfd_link_info *info,
    struct bfd_link_hash_entry *h);




void _bfd_generic_link_hide_symbol
   (bfd *output_bfd, struct bfd_link_info *info,
    struct bfd_link_hash_entry *h);




struct bfd_link_hash_entry *bfd_generic_define_start_stop
   (struct bfd_link_info *info,
    const char *symbol, asection *sec);




struct bfd_elf_version_tree * bfd_find_version_for_sym
   (struct bfd_elf_version_tree *verdefs,
    const char *sym_name, 
# 2917 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                         _Bool 
# 2917 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                              *hide);


# 2919 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2919 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_hide_sym_by_version
   (struct bfd_elf_version_tree *verdefs, const char *sym_name);


# 2922 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2922 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);


# 2925 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2925 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    _bfd_generic_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);


# 2928 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2928 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_merge_private_bfd_data
   (bfd *ibfd, struct bfd_link_info *info);







extern unsigned int bfd_use_reserved_id;

bfd *bfd_fopen (const char *filename, const char *target,
    const char *mode, int fd);

bfd *bfd_openr (const char *filename, const char *target);

bfd *bfd_fdopenr (const char *filename, const char *target, int fd);

bfd *bfd_fdopenw (const char *filename, const char *target, int fd);

bfd *bfd_openstreamr (const char * filename, const char * target,
    void * stream);

bfd *bfd_openr_iovec (const char *filename, const char *target,
    void *(*open_func) (struct bfd *nbfd,
 void *open_closure),
    void *open_closure,
    file_ptr (*pread_func) (struct bfd *nbfd,
 void *stream,
 void *buf,
 file_ptr nbytes,
 file_ptr offset),
    int (*close_func) (struct bfd *nbfd,
 void *stream),
    int (*stat_func) (struct bfd *abfd,
 void *stream,
 struct stat *sb));

bfd *bfd_openw (const char *filename, const char *target);

bfd *bfd_elf_bfd_from_remote_memory
   (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
    int (*target_read_memory)
       (bfd_vma vma, bfd_byte *myaddr, bfd_size_type len));


# 2973 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2973 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_close (bfd *abfd);


# 2975 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2975 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_close_all_done (bfd *);

bfd *bfd_create (const char *filename, bfd *templ);


# 2979 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2979 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_make_writable (bfd *abfd);


# 2981 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2981 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_make_readable (bfd *abfd);

uint32_t bfd_calc_gnu_debuglink_crc32
   (uint32_t crc, const bfd_byte *buf, bfd_size_type len);

char *bfd_get_debug_link_info (bfd *abfd, uint32_t *crc32_out);

char *bfd_get_alt_debug_link_info (bfd * abfd,
    bfd_size_type *buildid_len,
    bfd_byte **buildid_out);

char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

char *bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir);

struct bfd_section *bfd_create_gnu_debuglink_section
   (bfd *abfd, const char *filename);


# 2999 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 2999 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_fill_in_gnu_debuglink_section
   (bfd *abfd, struct bfd_section *sect, const char *filename);

char *bfd_follow_build_id_debuglink (bfd *abfd, const char *dir);

const char *bfd_set_filename (bfd *abfd, const char *filename);


typedef enum bfd_reloc_status
{


  bfd_reloc_ok = 2,


  bfd_reloc_overflow,


  bfd_reloc_outofrange,


  bfd_reloc_continue,


  bfd_reloc_notsupported,


  bfd_reloc_other,


  bfd_reloc_undefined,




  bfd_reloc_dangerous
 }
 bfd_reloc_status_type;

typedef const struct reloc_howto_struct reloc_howto_type;

struct reloc_cache_entry
{

  struct bfd_symbol **sym_ptr_ptr;


  bfd_size_type address;


  bfd_vma addend;


  reloc_howto_type *howto;

};

enum complain_overflow
{

  complain_overflow_dont,




  complain_overflow_bitfield,



  complain_overflow_signed,



  complain_overflow_unsigned
};

struct reloc_howto_struct
{



  unsigned int type;


  unsigned int size:4;



  unsigned int bitsize:7;



  unsigned int rightshift:6;



  unsigned int bitpos:6;



  __extension__ enum complain_overflow complain_on_overflow:2;


  unsigned int negate:1;


  unsigned int pc_relative:1;
# 3122 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  unsigned int partial_inplace:1;







  unsigned int pcrel_offset:1;




  unsigned int install_addend:1;
# 3145 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  bfd_vma src_mask;



  bfd_vma dst_mask;




  bfd_reloc_status_type (*special_function)
    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
     bfd *, char **);


  const char *name;
};
# 3173 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
static inline unsigned int
bfd_get_reloc_size (reloc_howto_type *howto)
{
  return howto->size;
}

typedef struct relent_chain
{
  arelent relent;
  struct relent_chain *next;
}
arelent_chain;

bfd_reloc_status_type bfd_check_overflow
   (enum complain_overflow how,
    unsigned int bitsize,
    unsigned int rightshift,
    unsigned int addrsize,
    bfd_vma relocation);


# 3193 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 3193 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_reloc_offset_in_range
   (reloc_howto_type *howto,
    bfd *abfd,
    asection *section,
    bfd_size_type offset);

bfd_reloc_status_type bfd_perform_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data,
    asection *input_section,
    bfd *output_bfd,
    char **error_message);

bfd_reloc_status_type bfd_install_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data, bfd_vma data_start,
    asection *input_section,
    char **error_message);

enum bfd_reloc_code_real {
  _dummy_first_bfd_reloc_code_real,



  BFD_RELOC_64,
  BFD_RELOC_32,
  BFD_RELOC_26,
  BFD_RELOC_24,
  BFD_RELOC_16,
  BFD_RELOC_14,
  BFD_RELOC_8,




  BFD_RELOC_64_PCREL,
  BFD_RELOC_32_PCREL,
  BFD_RELOC_24_PCREL,
  BFD_RELOC_16_PCREL,
  BFD_RELOC_12_PCREL,
  BFD_RELOC_8_PCREL,


  BFD_RELOC_32_SECREL,
  BFD_RELOC_16_SECIDX,


  BFD_RELOC_32_GOT_PCREL,
  BFD_RELOC_16_GOT_PCREL,
  BFD_RELOC_8_GOT_PCREL,
  BFD_RELOC_32_GOTOFF,
  BFD_RELOC_16_GOTOFF,
  BFD_RELOC_LO16_GOTOFF,
  BFD_RELOC_HI16_GOTOFF,
  BFD_RELOC_HI16_S_GOTOFF,
  BFD_RELOC_8_GOTOFF,
  BFD_RELOC_64_PLT_PCREL,
  BFD_RELOC_32_PLT_PCREL,
  BFD_RELOC_24_PLT_PCREL,
  BFD_RELOC_16_PLT_PCREL,
  BFD_RELOC_8_PLT_PCREL,
  BFD_RELOC_64_PLTOFF,
  BFD_RELOC_32_PLTOFF,
  BFD_RELOC_16_PLTOFF,
  BFD_RELOC_LO16_PLTOFF,
  BFD_RELOC_HI16_PLTOFF,
  BFD_RELOC_HI16_S_PLTOFF,
  BFD_RELOC_8_PLTOFF,


  BFD_RELOC_SIZE32,
  BFD_RELOC_SIZE64,


  BFD_RELOC_68K_GLOB_DAT,
  BFD_RELOC_68K_JMP_SLOT,
  BFD_RELOC_68K_RELATIVE,
  BFD_RELOC_68K_TLS_GD32,
  BFD_RELOC_68K_TLS_GD16,
  BFD_RELOC_68K_TLS_GD8,
  BFD_RELOC_68K_TLS_LDM32,
  BFD_RELOC_68K_TLS_LDM16,
  BFD_RELOC_68K_TLS_LDM8,
  BFD_RELOC_68K_TLS_LDO32,
  BFD_RELOC_68K_TLS_LDO16,
  BFD_RELOC_68K_TLS_LDO8,
  BFD_RELOC_68K_TLS_IE32,
  BFD_RELOC_68K_TLS_IE16,
  BFD_RELOC_68K_TLS_IE8,
  BFD_RELOC_68K_TLS_LE32,
  BFD_RELOC_68K_TLS_LE16,
  BFD_RELOC_68K_TLS_LE8,


  BFD_RELOC_32_BASEREL,
  BFD_RELOC_16_BASEREL,
  BFD_RELOC_LO16_BASEREL,
  BFD_RELOC_HI16_BASEREL,
  BFD_RELOC_HI16_S_BASEREL,
  BFD_RELOC_8_BASEREL,
  BFD_RELOC_RVA,


  BFD_RELOC_8_FFnn,







  BFD_RELOC_32_PCREL_S2,
  BFD_RELOC_16_PCREL_S2,
  BFD_RELOC_23_PCREL_S2,



  BFD_RELOC_HI22,
  BFD_RELOC_LO10,





  BFD_RELOC_GPREL16,
  BFD_RELOC_GPREL32,



  BFD_RELOC_NONE,
  BFD_RELOC_SPARC_WDISP22,
  BFD_RELOC_SPARC22,
  BFD_RELOC_SPARC13,
  BFD_RELOC_SPARC_GOT10,
  BFD_RELOC_SPARC_GOT13,
  BFD_RELOC_SPARC_GOT22,
  BFD_RELOC_SPARC_PC10,
  BFD_RELOC_SPARC_PC22,
  BFD_RELOC_SPARC_WPLT30,
  BFD_RELOC_SPARC_COPY,
  BFD_RELOC_SPARC_GLOB_DAT,
  BFD_RELOC_SPARC_JMP_SLOT,
  BFD_RELOC_SPARC_RELATIVE,
  BFD_RELOC_SPARC_UA16,
  BFD_RELOC_SPARC_UA32,
  BFD_RELOC_SPARC_UA64,
  BFD_RELOC_SPARC_GOTDATA_HIX22,
  BFD_RELOC_SPARC_GOTDATA_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP_HIX22,
  BFD_RELOC_SPARC_GOTDATA_OP_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP,
  BFD_RELOC_SPARC_JMP_IREL,
  BFD_RELOC_SPARC_IRELATIVE,


  BFD_RELOC_SPARC_BASE13,
  BFD_RELOC_SPARC_BASE22,



  BFD_RELOC_SPARC_10,
  BFD_RELOC_SPARC_11,
  BFD_RELOC_SPARC_OLO10,
  BFD_RELOC_SPARC_HH22,
  BFD_RELOC_SPARC_HM10,
  BFD_RELOC_SPARC_LM22,
  BFD_RELOC_SPARC_PC_HH22,
  BFD_RELOC_SPARC_PC_HM10,
  BFD_RELOC_SPARC_PC_LM22,
  BFD_RELOC_SPARC_WDISP16,
  BFD_RELOC_SPARC_WDISP19,
  BFD_RELOC_SPARC_7,
  BFD_RELOC_SPARC_6,
  BFD_RELOC_SPARC_5,

  BFD_RELOC_SPARC_PLT32,
  BFD_RELOC_SPARC_PLT64,
  BFD_RELOC_SPARC_HIX22,
  BFD_RELOC_SPARC_LOX10,
  BFD_RELOC_SPARC_H44,
  BFD_RELOC_SPARC_M44,
  BFD_RELOC_SPARC_L44,
  BFD_RELOC_SPARC_REGISTER,
  BFD_RELOC_SPARC_H34,
  BFD_RELOC_SPARC_SIZE32,
  BFD_RELOC_SPARC_SIZE64,
  BFD_RELOC_SPARC_WDISP10,


  BFD_RELOC_SPARC_REV32,


  BFD_RELOC_SPARC_TLS_GD_HI22,
  BFD_RELOC_SPARC_TLS_GD_LO10,
  BFD_RELOC_SPARC_TLS_GD_ADD,
  BFD_RELOC_SPARC_TLS_GD_CALL,
  BFD_RELOC_SPARC_TLS_LDM_HI22,
  BFD_RELOC_SPARC_TLS_LDM_LO10,
  BFD_RELOC_SPARC_TLS_LDM_ADD,
  BFD_RELOC_SPARC_TLS_LDM_CALL,
  BFD_RELOC_SPARC_TLS_LDO_HIX22,
  BFD_RELOC_SPARC_TLS_LDO_LOX10,
  BFD_RELOC_SPARC_TLS_LDO_ADD,
  BFD_RELOC_SPARC_TLS_IE_HI22,
  BFD_RELOC_SPARC_TLS_IE_LO10,
  BFD_RELOC_SPARC_TLS_IE_LD,
  BFD_RELOC_SPARC_TLS_IE_LDX,
  BFD_RELOC_SPARC_TLS_IE_ADD,
  BFD_RELOC_SPARC_TLS_LE_HIX22,
  BFD_RELOC_SPARC_TLS_LE_LOX10,
  BFD_RELOC_SPARC_TLS_DTPMOD32,
  BFD_RELOC_SPARC_TLS_DTPMOD64,
  BFD_RELOC_SPARC_TLS_DTPOFF32,
  BFD_RELOC_SPARC_TLS_DTPOFF64,
  BFD_RELOC_SPARC_TLS_TPOFF32,
  BFD_RELOC_SPARC_TLS_TPOFF64,


  BFD_RELOC_SPU_IMM7,
  BFD_RELOC_SPU_IMM8,
  BFD_RELOC_SPU_IMM10,
  BFD_RELOC_SPU_IMM10W,
  BFD_RELOC_SPU_IMM16,
  BFD_RELOC_SPU_IMM16W,
  BFD_RELOC_SPU_IMM18,
  BFD_RELOC_SPU_PCREL9a,
  BFD_RELOC_SPU_PCREL9b,
  BFD_RELOC_SPU_PCREL16,
  BFD_RELOC_SPU_LO16,
  BFD_RELOC_SPU_HI16,
  BFD_RELOC_SPU_PPU32,
  BFD_RELOC_SPU_PPU64,
  BFD_RELOC_SPU_ADD_PIC,







  BFD_RELOC_ALPHA_GPDISP_HI16,





  BFD_RELOC_ALPHA_GPDISP_LO16,




  BFD_RELOC_ALPHA_GPDISP,
# 3471 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  BFD_RELOC_ALPHA_LITERAL,
  BFD_RELOC_ALPHA_ELF_LITERAL,
  BFD_RELOC_ALPHA_LITUSE,




  BFD_RELOC_ALPHA_HINT,



  BFD_RELOC_ALPHA_LINKAGE,



  BFD_RELOC_ALPHA_CODEADDR,



  BFD_RELOC_ALPHA_GPREL_HI16,
  BFD_RELOC_ALPHA_GPREL_LO16,




  BFD_RELOC_ALPHA_BRSGP,



  BFD_RELOC_ALPHA_NOP,



  BFD_RELOC_ALPHA_BSR,



  BFD_RELOC_ALPHA_LDA,



  BFD_RELOC_ALPHA_BOH,


  BFD_RELOC_ALPHA_TLSGD,
  BFD_RELOC_ALPHA_TLSLDM,
  BFD_RELOC_ALPHA_DTPMOD64,
  BFD_RELOC_ALPHA_GOTDTPREL16,
  BFD_RELOC_ALPHA_DTPREL64,
  BFD_RELOC_ALPHA_DTPREL_HI16,
  BFD_RELOC_ALPHA_DTPREL_LO16,
  BFD_RELOC_ALPHA_DTPREL16,
  BFD_RELOC_ALPHA_GOTTPREL16,
  BFD_RELOC_ALPHA_TPREL64,
  BFD_RELOC_ALPHA_TPREL_HI16,
  BFD_RELOC_ALPHA_TPREL_LO16,
  BFD_RELOC_ALPHA_TPREL16,


  BFD_RELOC_MIPS_JMP,
  BFD_RELOC_MICROMIPS_JMP,


  BFD_RELOC_MIPS16_JMP,


  BFD_RELOC_MIPS16_GPREL,


  BFD_RELOC_HI16,





  BFD_RELOC_HI16_S,


  BFD_RELOC_LO16,


  BFD_RELOC_HI16_PCREL,


  BFD_RELOC_HI16_S_PCREL,


  BFD_RELOC_LO16_PCREL,



  BFD_RELOC_MIPS16_GOT16,
  BFD_RELOC_MIPS16_CALL16,


  BFD_RELOC_MIPS16_HI16,





  BFD_RELOC_MIPS16_HI16_S,


  BFD_RELOC_MIPS16_LO16,


  BFD_RELOC_MIPS16_TLS_GD,
  BFD_RELOC_MIPS16_TLS_LDM,
  BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS16_TLS_GOTTPREL,
  BFD_RELOC_MIPS16_TLS_TPREL_HI16,
  BFD_RELOC_MIPS16_TLS_TPREL_LO16,


  BFD_RELOC_MIPS_LITERAL,
  BFD_RELOC_MICROMIPS_LITERAL,


  BFD_RELOC_MICROMIPS_7_PCREL_S1,
  BFD_RELOC_MICROMIPS_10_PCREL_S1,
  BFD_RELOC_MICROMIPS_16_PCREL_S1,


  BFD_RELOC_MIPS16_16_PCREL_S1,


  BFD_RELOC_MIPS_21_PCREL_S2,
  BFD_RELOC_MIPS_26_PCREL_S2,
  BFD_RELOC_MIPS_18_PCREL_S3,
  BFD_RELOC_MIPS_19_PCREL_S2,


  BFD_RELOC_MICROMIPS_GPREL16,
  BFD_RELOC_MICROMIPS_HI16,
  BFD_RELOC_MICROMIPS_HI16_S,
  BFD_RELOC_MICROMIPS_LO16,


  BFD_RELOC_MIPS_GOT16,
  BFD_RELOC_MICROMIPS_GOT16,
  BFD_RELOC_MIPS_CALL16,
  BFD_RELOC_MICROMIPS_CALL16,
  BFD_RELOC_MIPS_GOT_HI16,
  BFD_RELOC_MICROMIPS_GOT_HI16,
  BFD_RELOC_MIPS_GOT_LO16,
  BFD_RELOC_MICROMIPS_GOT_LO16,
  BFD_RELOC_MIPS_CALL_HI16,
  BFD_RELOC_MICROMIPS_CALL_HI16,
  BFD_RELOC_MIPS_CALL_LO16,
  BFD_RELOC_MICROMIPS_CALL_LO16,
  BFD_RELOC_MIPS_SUB,
  BFD_RELOC_MICROMIPS_SUB,
  BFD_RELOC_MIPS_GOT_PAGE,
  BFD_RELOC_MICROMIPS_GOT_PAGE,
  BFD_RELOC_MIPS_GOT_OFST,
  BFD_RELOC_MICROMIPS_GOT_OFST,
  BFD_RELOC_MIPS_GOT_DISP,
  BFD_RELOC_MICROMIPS_GOT_DISP,
  BFD_RELOC_MIPS_SHIFT5,
  BFD_RELOC_MIPS_SHIFT6,
  BFD_RELOC_MIPS_INSERT_A,
  BFD_RELOC_MIPS_INSERT_B,
  BFD_RELOC_MIPS_DELETE,
  BFD_RELOC_MIPS_HIGHEST,
  BFD_RELOC_MICROMIPS_HIGHEST,
  BFD_RELOC_MIPS_HIGHER,
  BFD_RELOC_MICROMIPS_HIGHER,
  BFD_RELOC_MIPS_SCN_DISP,
  BFD_RELOC_MICROMIPS_SCN_DISP,
  BFD_RELOC_MIPS_16,
  BFD_RELOC_MIPS_RELGOT,
  BFD_RELOC_MIPS_JALR,
  BFD_RELOC_MICROMIPS_JALR,
  BFD_RELOC_MIPS_TLS_DTPMOD32,
  BFD_RELOC_MIPS_TLS_DTPREL32,
  BFD_RELOC_MIPS_TLS_DTPMOD64,
  BFD_RELOC_MIPS_TLS_DTPREL64,
  BFD_RELOC_MIPS_TLS_GD,
  BFD_RELOC_MICROMIPS_TLS_GD,
  BFD_RELOC_MIPS_TLS_LDM,
  BFD_RELOC_MICROMIPS_TLS_LDM,
  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS_TLS_GOTTPREL,
  BFD_RELOC_MICROMIPS_TLS_GOTTPREL,
  BFD_RELOC_MIPS_TLS_TPREL32,
  BFD_RELOC_MIPS_TLS_TPREL64,
  BFD_RELOC_MIPS_TLS_TPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_HI16,
  BFD_RELOC_MIPS_TLS_TPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_LO16,
  BFD_RELOC_MIPS_EH,



  BFD_RELOC_MIPS_COPY,
  BFD_RELOC_MIPS_JUMP_SLOT,



  BFD_RELOC_MOXIE_10_PCREL,



  BFD_RELOC_FT32_10,
  BFD_RELOC_FT32_20,
  BFD_RELOC_FT32_17,
  BFD_RELOC_FT32_18,
  BFD_RELOC_FT32_RELAX,
  BFD_RELOC_FT32_SC0,
  BFD_RELOC_FT32_SC1,
  BFD_RELOC_FT32_15,
  BFD_RELOC_FT32_DIFF32,



  BFD_RELOC_FRV_LABEL16,
  BFD_RELOC_FRV_LABEL24,
  BFD_RELOC_FRV_LO16,
  BFD_RELOC_FRV_HI16,
  BFD_RELOC_FRV_GPREL12,
  BFD_RELOC_FRV_GPRELU12,
  BFD_RELOC_FRV_GPREL32,
  BFD_RELOC_FRV_GPRELHI,
  BFD_RELOC_FRV_GPRELLO,
  BFD_RELOC_FRV_GOT12,
  BFD_RELOC_FRV_GOTHI,
  BFD_RELOC_FRV_GOTLO,
  BFD_RELOC_FRV_FUNCDESC,
  BFD_RELOC_FRV_FUNCDESC_GOT12,
  BFD_RELOC_FRV_FUNCDESC_GOTHI,
  BFD_RELOC_FRV_FUNCDESC_GOTLO,
  BFD_RELOC_FRV_FUNCDESC_VALUE,
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
  BFD_RELOC_FRV_GOTOFF12,
  BFD_RELOC_FRV_GOTOFFHI,
  BFD_RELOC_FRV_GOTOFFLO,
  BFD_RELOC_FRV_GETTLSOFF,
  BFD_RELOC_FRV_TLSDESC_VALUE,
  BFD_RELOC_FRV_GOTTLSDESC12,
  BFD_RELOC_FRV_GOTTLSDESCHI,
  BFD_RELOC_FRV_GOTTLSDESCLO,
  BFD_RELOC_FRV_TLSMOFF12,
  BFD_RELOC_FRV_TLSMOFFHI,
  BFD_RELOC_FRV_TLSMOFFLO,
  BFD_RELOC_FRV_GOTTLSOFF12,
  BFD_RELOC_FRV_GOTTLSOFFHI,
  BFD_RELOC_FRV_GOTTLSOFFLO,
  BFD_RELOC_FRV_TLSOFF,
  BFD_RELOC_FRV_TLSDESC_RELAX,
  BFD_RELOC_FRV_GETTLSOFF_RELAX,
  BFD_RELOC_FRV_TLSOFF_RELAX,
  BFD_RELOC_FRV_TLSMOFF,



  BFD_RELOC_MN10300_GOTOFF24,



  BFD_RELOC_MN10300_GOT32,



  BFD_RELOC_MN10300_GOT24,



  BFD_RELOC_MN10300_GOT16,


  BFD_RELOC_MN10300_COPY,


  BFD_RELOC_MN10300_GLOB_DAT,


  BFD_RELOC_MN10300_JMP_SLOT,


  BFD_RELOC_MN10300_RELATIVE,




  BFD_RELOC_MN10300_SYM_DIFF,




  BFD_RELOC_MN10300_ALIGN,


  BFD_RELOC_MN10300_TLS_GD,
  BFD_RELOC_MN10300_TLS_LD,
  BFD_RELOC_MN10300_TLS_LDO,
  BFD_RELOC_MN10300_TLS_GOTIE,
  BFD_RELOC_MN10300_TLS_IE,
  BFD_RELOC_MN10300_TLS_LE,
  BFD_RELOC_MN10300_TLS_DTPMOD,
  BFD_RELOC_MN10300_TLS_DTPOFF,
  BFD_RELOC_MN10300_TLS_TPOFF,



  BFD_RELOC_MN10300_32_PCREL,



  BFD_RELOC_MN10300_16_PCREL,



  BFD_RELOC_386_GOT32,
  BFD_RELOC_386_PLT32,
  BFD_RELOC_386_COPY,
  BFD_RELOC_386_GLOB_DAT,
  BFD_RELOC_386_JUMP_SLOT,
  BFD_RELOC_386_RELATIVE,
  BFD_RELOC_386_GOTOFF,
  BFD_RELOC_386_GOTPC,
  BFD_RELOC_386_TLS_TPOFF,
  BFD_RELOC_386_TLS_IE,
  BFD_RELOC_386_TLS_GOTIE,
  BFD_RELOC_386_TLS_LE,
  BFD_RELOC_386_TLS_GD,
  BFD_RELOC_386_TLS_LDM,
  BFD_RELOC_386_TLS_LDO_32,
  BFD_RELOC_386_TLS_IE_32,
  BFD_RELOC_386_TLS_LE_32,
  BFD_RELOC_386_TLS_DTPMOD32,
  BFD_RELOC_386_TLS_DTPOFF32,
  BFD_RELOC_386_TLS_TPOFF32,
  BFD_RELOC_386_TLS_GOTDESC,
  BFD_RELOC_386_TLS_DESC_CALL,
  BFD_RELOC_386_TLS_DESC,
  BFD_RELOC_386_IRELATIVE,
  BFD_RELOC_386_GOT32X,


  BFD_RELOC_X86_64_GOT32,
  BFD_RELOC_X86_64_PLT32,
  BFD_RELOC_X86_64_COPY,
  BFD_RELOC_X86_64_GLOB_DAT,
  BFD_RELOC_X86_64_JUMP_SLOT,
  BFD_RELOC_X86_64_RELATIVE,
  BFD_RELOC_X86_64_GOTPCREL,
  BFD_RELOC_X86_64_32S,
  BFD_RELOC_X86_64_DTPMOD64,
  BFD_RELOC_X86_64_DTPOFF64,
  BFD_RELOC_X86_64_TPOFF64,
  BFD_RELOC_X86_64_TLSGD,
  BFD_RELOC_X86_64_TLSLD,
  BFD_RELOC_X86_64_DTPOFF32,
  BFD_RELOC_X86_64_GOTTPOFF,
  BFD_RELOC_X86_64_TPOFF32,
  BFD_RELOC_X86_64_GOTOFF64,
  BFD_RELOC_X86_64_GOTPC32,
  BFD_RELOC_X86_64_GOT64,
  BFD_RELOC_X86_64_GOTPCREL64,
  BFD_RELOC_X86_64_GOTPC64,
  BFD_RELOC_X86_64_GOTPLT64,
  BFD_RELOC_X86_64_PLTOFF64,
  BFD_RELOC_X86_64_GOTPC32_TLSDESC,
  BFD_RELOC_X86_64_TLSDESC_CALL,
  BFD_RELOC_X86_64_TLSDESC,
  BFD_RELOC_X86_64_IRELATIVE,
  BFD_RELOC_X86_64_PC32_BND,
  BFD_RELOC_X86_64_PLT32_BND,
  BFD_RELOC_X86_64_GOTPCRELX,
  BFD_RELOC_X86_64_REX_GOTPCRELX,


  BFD_RELOC_NS32K_IMM_8,
  BFD_RELOC_NS32K_IMM_16,
  BFD_RELOC_NS32K_IMM_32,
  BFD_RELOC_NS32K_IMM_8_PCREL,
  BFD_RELOC_NS32K_IMM_16_PCREL,
  BFD_RELOC_NS32K_IMM_32_PCREL,
  BFD_RELOC_NS32K_DISP_8,
  BFD_RELOC_NS32K_DISP_16,
  BFD_RELOC_NS32K_DISP_32,
  BFD_RELOC_NS32K_DISP_8_PCREL,
  BFD_RELOC_NS32K_DISP_16_PCREL,
  BFD_RELOC_NS32K_DISP_32_PCREL,


  BFD_RELOC_PDP11_DISP_8_PCREL,
  BFD_RELOC_PDP11_DISP_6_PCREL,


  BFD_RELOC_PJ_CODE_HI16,
  BFD_RELOC_PJ_CODE_LO16,
  BFD_RELOC_PJ_CODE_DIR16,
  BFD_RELOC_PJ_CODE_DIR32,
  BFD_RELOC_PJ_CODE_REL16,
  BFD_RELOC_PJ_CODE_REL32,


  BFD_RELOC_PPC_B26,
  BFD_RELOC_PPC_BA26,
  BFD_RELOC_PPC_TOC16,
  BFD_RELOC_PPC_TOC16_LO,
  BFD_RELOC_PPC_TOC16_HI,
  BFD_RELOC_PPC_B16,
  BFD_RELOC_PPC_B16_BRTAKEN,
  BFD_RELOC_PPC_B16_BRNTAKEN,
  BFD_RELOC_PPC_BA16,
  BFD_RELOC_PPC_BA16_BRTAKEN,
  BFD_RELOC_PPC_BA16_BRNTAKEN,
  BFD_RELOC_PPC_COPY,
  BFD_RELOC_PPC_GLOB_DAT,
  BFD_RELOC_PPC_JMP_SLOT,
  BFD_RELOC_PPC_RELATIVE,
  BFD_RELOC_PPC_LOCAL24PC,
  BFD_RELOC_PPC_EMB_NADDR32,
  BFD_RELOC_PPC_EMB_NADDR16,
  BFD_RELOC_PPC_EMB_NADDR16_LO,
  BFD_RELOC_PPC_EMB_NADDR16_HI,
  BFD_RELOC_PPC_EMB_NADDR16_HA,
  BFD_RELOC_PPC_EMB_SDAI16,
  BFD_RELOC_PPC_EMB_SDA2I16,
  BFD_RELOC_PPC_EMB_SDA2REL,
  BFD_RELOC_PPC_EMB_SDA21,
  BFD_RELOC_PPC_EMB_MRKREF,
  BFD_RELOC_PPC_EMB_RELSEC16,
  BFD_RELOC_PPC_EMB_RELST_LO,
  BFD_RELOC_PPC_EMB_RELST_HI,
  BFD_RELOC_PPC_EMB_RELST_HA,
  BFD_RELOC_PPC_EMB_BIT_FLD,
  BFD_RELOC_PPC_EMB_RELSDA,
  BFD_RELOC_PPC_VLE_REL8,
  BFD_RELOC_PPC_VLE_REL15,
  BFD_RELOC_PPC_VLE_REL24,
  BFD_RELOC_PPC_VLE_LO16A,
  BFD_RELOC_PPC_VLE_LO16D,
  BFD_RELOC_PPC_VLE_HI16A,
  BFD_RELOC_PPC_VLE_HI16D,
  BFD_RELOC_PPC_VLE_HA16A,
  BFD_RELOC_PPC_VLE_HA16D,
  BFD_RELOC_PPC_VLE_SDA21,
  BFD_RELOC_PPC_VLE_SDA21_LO,
  BFD_RELOC_PPC_VLE_SDAREL_LO16A,
  BFD_RELOC_PPC_VLE_SDAREL_LO16D,
  BFD_RELOC_PPC_VLE_SDAREL_HI16A,
  BFD_RELOC_PPC_VLE_SDAREL_HI16D,
  BFD_RELOC_PPC_VLE_SDAREL_HA16A,
  BFD_RELOC_PPC_VLE_SDAREL_HA16D,
  BFD_RELOC_PPC_16DX_HA,
  BFD_RELOC_PPC_REL16DX_HA,
  BFD_RELOC_PPC_NEG,
  BFD_RELOC_PPC64_HIGHER,
  BFD_RELOC_PPC64_HIGHER_S,
  BFD_RELOC_PPC64_HIGHEST,
  BFD_RELOC_PPC64_HIGHEST_S,
  BFD_RELOC_PPC64_TOC16_LO,
  BFD_RELOC_PPC64_TOC16_HI,
  BFD_RELOC_PPC64_TOC16_HA,
  BFD_RELOC_PPC64_TOC,
  BFD_RELOC_PPC64_PLTGOT16,
  BFD_RELOC_PPC64_PLTGOT16_LO,
  BFD_RELOC_PPC64_PLTGOT16_HI,
  BFD_RELOC_PPC64_PLTGOT16_HA,
  BFD_RELOC_PPC64_ADDR16_DS,
  BFD_RELOC_PPC64_ADDR16_LO_DS,
  BFD_RELOC_PPC64_GOT16_DS,
  BFD_RELOC_PPC64_GOT16_LO_DS,
  BFD_RELOC_PPC64_PLT16_LO_DS,
  BFD_RELOC_PPC64_SECTOFF_DS,
  BFD_RELOC_PPC64_SECTOFF_LO_DS,
  BFD_RELOC_PPC64_TOC16_DS,
  BFD_RELOC_PPC64_TOC16_LO_DS,
  BFD_RELOC_PPC64_PLTGOT16_DS,
  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
  BFD_RELOC_PPC64_ADDR16_HIGH,
  BFD_RELOC_PPC64_ADDR16_HIGHA,
  BFD_RELOC_PPC64_REL16_HIGH,
  BFD_RELOC_PPC64_REL16_HIGHA,
  BFD_RELOC_PPC64_REL16_HIGHER,
  BFD_RELOC_PPC64_REL16_HIGHERA,
  BFD_RELOC_PPC64_REL16_HIGHEST,
  BFD_RELOC_PPC64_REL16_HIGHESTA,
  BFD_RELOC_PPC64_ADDR64_LOCAL,
  BFD_RELOC_PPC64_ENTRY,
  BFD_RELOC_PPC64_REL24_NOTOC,
  BFD_RELOC_PPC64_REL24_P9NOTOC,
  BFD_RELOC_PPC64_D34,
  BFD_RELOC_PPC64_D34_LO,
  BFD_RELOC_PPC64_D34_HI30,
  BFD_RELOC_PPC64_D34_HA30,
  BFD_RELOC_PPC64_PCREL34,
  BFD_RELOC_PPC64_GOT_PCREL34,
  BFD_RELOC_PPC64_PLT_PCREL34,
  BFD_RELOC_PPC64_ADDR16_HIGHER34,
  BFD_RELOC_PPC64_ADDR16_HIGHERA34,
  BFD_RELOC_PPC64_ADDR16_HIGHEST34,
  BFD_RELOC_PPC64_ADDR16_HIGHESTA34,
  BFD_RELOC_PPC64_REL16_HIGHER34,
  BFD_RELOC_PPC64_REL16_HIGHERA34,
  BFD_RELOC_PPC64_REL16_HIGHEST34,
  BFD_RELOC_PPC64_REL16_HIGHESTA34,
  BFD_RELOC_PPC64_D28,
  BFD_RELOC_PPC64_PCREL28,


  BFD_RELOC_PPC_TLS,
  BFD_RELOC_PPC_TLSGD,
  BFD_RELOC_PPC_TLSLD,
  BFD_RELOC_PPC_TLSLE,
  BFD_RELOC_PPC_TLSIE,
  BFD_RELOC_PPC_TLSM,
  BFD_RELOC_PPC_TLSML,
  BFD_RELOC_PPC_DTPMOD,
  BFD_RELOC_PPC_TPREL16,
  BFD_RELOC_PPC_TPREL16_LO,
  BFD_RELOC_PPC_TPREL16_HI,
  BFD_RELOC_PPC_TPREL16_HA,
  BFD_RELOC_PPC_TPREL,
  BFD_RELOC_PPC_DTPREL16,
  BFD_RELOC_PPC_DTPREL16_LO,
  BFD_RELOC_PPC_DTPREL16_HI,
  BFD_RELOC_PPC_DTPREL16_HA,
  BFD_RELOC_PPC_DTPREL,
  BFD_RELOC_PPC_GOT_TLSGD16,
  BFD_RELOC_PPC_GOT_TLSGD16_LO,
  BFD_RELOC_PPC_GOT_TLSGD16_HI,
  BFD_RELOC_PPC_GOT_TLSGD16_HA,
  BFD_RELOC_PPC_GOT_TLSLD16,
  BFD_RELOC_PPC_GOT_TLSLD16_LO,
  BFD_RELOC_PPC_GOT_TLSLD16_HI,
  BFD_RELOC_PPC_GOT_TLSLD16_HA,
  BFD_RELOC_PPC_GOT_TPREL16,
  BFD_RELOC_PPC_GOT_TPREL16_LO,
  BFD_RELOC_PPC_GOT_TPREL16_HI,
  BFD_RELOC_PPC_GOT_TPREL16_HA,
  BFD_RELOC_PPC_GOT_DTPREL16,
  BFD_RELOC_PPC_GOT_DTPREL16_LO,
  BFD_RELOC_PPC_GOT_DTPREL16_HI,
  BFD_RELOC_PPC_GOT_DTPREL16_HA,
  BFD_RELOC_PPC64_TLSGD,
  BFD_RELOC_PPC64_TLSLD,
  BFD_RELOC_PPC64_TLSLE,
  BFD_RELOC_PPC64_TLSIE,
  BFD_RELOC_PPC64_TLSM,
  BFD_RELOC_PPC64_TLSML,
  BFD_RELOC_PPC64_TPREL16_DS,
  BFD_RELOC_PPC64_TPREL16_LO_DS,
  BFD_RELOC_PPC64_TPREL16_HIGH,
  BFD_RELOC_PPC64_TPREL16_HIGHA,
  BFD_RELOC_PPC64_TPREL16_HIGHER,
  BFD_RELOC_PPC64_TPREL16_HIGHERA,
  BFD_RELOC_PPC64_TPREL16_HIGHEST,
  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
  BFD_RELOC_PPC64_DTPREL16_DS,
  BFD_RELOC_PPC64_DTPREL16_LO_DS,
  BFD_RELOC_PPC64_DTPREL16_HIGH,
  BFD_RELOC_PPC64_DTPREL16_HIGHA,
  BFD_RELOC_PPC64_DTPREL16_HIGHER,
  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
  BFD_RELOC_PPC64_TPREL34,
  BFD_RELOC_PPC64_DTPREL34,
  BFD_RELOC_PPC64_GOT_TLSGD_PCREL34,
  BFD_RELOC_PPC64_GOT_TLSLD_PCREL34,
  BFD_RELOC_PPC64_GOT_TPREL_PCREL34,
  BFD_RELOC_PPC64_GOT_DTPREL_PCREL34,
  BFD_RELOC_PPC64_TLS_PCREL,


  BFD_RELOC_I370_D12,




  BFD_RELOC_CTOR,



  BFD_RELOC_ARM_PCREL_BRANCH,




  BFD_RELOC_ARM_PCREL_BLX,




  BFD_RELOC_THUMB_PCREL_BLX,


  BFD_RELOC_ARM_PCREL_CALL,


  BFD_RELOC_ARM_PCREL_JUMP,


  BFD_RELOC_THUMB_PCREL_BRANCH5,


  BFD_RELOC_THUMB_PCREL_BFCSEL,


  BFD_RELOC_ARM_THUMB_BF17,


  BFD_RELOC_ARM_THUMB_BF13,


  BFD_RELOC_ARM_THUMB_BF19,


  BFD_RELOC_ARM_THUMB_LOOP12,






  BFD_RELOC_THUMB_PCREL_BRANCH7,
  BFD_RELOC_THUMB_PCREL_BRANCH9,
  BFD_RELOC_THUMB_PCREL_BRANCH12,
  BFD_RELOC_THUMB_PCREL_BRANCH20,
  BFD_RELOC_THUMB_PCREL_BRANCH23,
  BFD_RELOC_THUMB_PCREL_BRANCH25,


  BFD_RELOC_ARM_OFFSET_IMM,


  BFD_RELOC_ARM_THUMB_OFFSET,



  BFD_RELOC_ARM_TARGET1,


  BFD_RELOC_ARM_ROSEGREL32,


  BFD_RELOC_ARM_SBREL32,




  BFD_RELOC_ARM_TARGET2,


  BFD_RELOC_ARM_PREL31,


  BFD_RELOC_ARM_MOVW,
  BFD_RELOC_ARM_MOVT,
  BFD_RELOC_ARM_MOVW_PCREL,
  BFD_RELOC_ARM_MOVT_PCREL,
  BFD_RELOC_ARM_THUMB_MOVW,
  BFD_RELOC_ARM_THUMB_MOVT,
  BFD_RELOC_ARM_THUMB_MOVW_PCREL,
  BFD_RELOC_ARM_THUMB_MOVT_PCREL,


  BFD_RELOC_ARM_GOTFUNCDESC,
  BFD_RELOC_ARM_GOTOFFFUNCDESC,
  BFD_RELOC_ARM_FUNCDESC,
  BFD_RELOC_ARM_FUNCDESC_VALUE,
  BFD_RELOC_ARM_TLS_GD32_FDPIC,
  BFD_RELOC_ARM_TLS_LDM32_FDPIC,
  BFD_RELOC_ARM_TLS_IE32_FDPIC,


  BFD_RELOC_ARM_JUMP_SLOT,
  BFD_RELOC_ARM_GLOB_DAT,
  BFD_RELOC_ARM_GOT32,
  BFD_RELOC_ARM_PLT32,
  BFD_RELOC_ARM_RELATIVE,
  BFD_RELOC_ARM_GOTOFF,
  BFD_RELOC_ARM_GOTPC,
  BFD_RELOC_ARM_GOT_PREL,


  BFD_RELOC_ARM_TLS_GD32,
  BFD_RELOC_ARM_TLS_LDO32,
  BFD_RELOC_ARM_TLS_LDM32,
  BFD_RELOC_ARM_TLS_DTPOFF32,
  BFD_RELOC_ARM_TLS_DTPMOD32,
  BFD_RELOC_ARM_TLS_TPOFF32,
  BFD_RELOC_ARM_TLS_IE32,
  BFD_RELOC_ARM_TLS_LE32,
  BFD_RELOC_ARM_TLS_GOTDESC,
  BFD_RELOC_ARM_TLS_CALL,
  BFD_RELOC_ARM_THM_TLS_CALL,
  BFD_RELOC_ARM_TLS_DESCSEQ,
  BFD_RELOC_ARM_THM_TLS_DESCSEQ,
  BFD_RELOC_ARM_TLS_DESC,


  BFD_RELOC_ARM_ALU_PC_G0_NC,
  BFD_RELOC_ARM_ALU_PC_G0,
  BFD_RELOC_ARM_ALU_PC_G1_NC,
  BFD_RELOC_ARM_ALU_PC_G1,
  BFD_RELOC_ARM_ALU_PC_G2,
  BFD_RELOC_ARM_LDR_PC_G0,
  BFD_RELOC_ARM_LDR_PC_G1,
  BFD_RELOC_ARM_LDR_PC_G2,
  BFD_RELOC_ARM_LDRS_PC_G0,
  BFD_RELOC_ARM_LDRS_PC_G1,
  BFD_RELOC_ARM_LDRS_PC_G2,
  BFD_RELOC_ARM_LDC_PC_G0,
  BFD_RELOC_ARM_LDC_PC_G1,
  BFD_RELOC_ARM_LDC_PC_G2,
  BFD_RELOC_ARM_ALU_SB_G0_NC,
  BFD_RELOC_ARM_ALU_SB_G0,
  BFD_RELOC_ARM_ALU_SB_G1_NC,
  BFD_RELOC_ARM_ALU_SB_G1,
  BFD_RELOC_ARM_ALU_SB_G2,
  BFD_RELOC_ARM_LDR_SB_G0,
  BFD_RELOC_ARM_LDR_SB_G1,
  BFD_RELOC_ARM_LDR_SB_G2,
  BFD_RELOC_ARM_LDRS_SB_G0,
  BFD_RELOC_ARM_LDRS_SB_G1,
  BFD_RELOC_ARM_LDRS_SB_G2,
  BFD_RELOC_ARM_LDC_SB_G0,
  BFD_RELOC_ARM_LDC_SB_G1,
  BFD_RELOC_ARM_LDC_SB_G2,


  BFD_RELOC_ARM_V4BX,


  BFD_RELOC_ARM_IRELATIVE,


  BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC,



  BFD_RELOC_ARM_IMMEDIATE,
  BFD_RELOC_ARM_ADRL_IMMEDIATE,
  BFD_RELOC_ARM_T32_IMMEDIATE,
  BFD_RELOC_ARM_T32_ADD_IMM,
  BFD_RELOC_ARM_T32_IMM12,
  BFD_RELOC_ARM_T32_ADD_PC12,
  BFD_RELOC_ARM_SHIFT_IMM,
  BFD_RELOC_ARM_SMC,
  BFD_RELOC_ARM_HVC,
  BFD_RELOC_ARM_SWI,
  BFD_RELOC_ARM_MULTI,
  BFD_RELOC_ARM_CP_OFF_IMM,
  BFD_RELOC_ARM_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_T32_CP_OFF_IMM,
  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_T32_VLDR_VSTR_OFF_IMM,
  BFD_RELOC_ARM_ADR_IMM,
  BFD_RELOC_ARM_LDR_IMM,
  BFD_RELOC_ARM_LITERAL,
  BFD_RELOC_ARM_IN_POOL,
  BFD_RELOC_ARM_OFFSET_IMM8,
  BFD_RELOC_ARM_T32_OFFSET_U8,
  BFD_RELOC_ARM_T32_OFFSET_IMM,
  BFD_RELOC_ARM_HWLITERAL,
  BFD_RELOC_ARM_THUMB_ADD,
  BFD_RELOC_ARM_THUMB_IMM,
  BFD_RELOC_ARM_THUMB_SHIFT,


  BFD_RELOC_SH_PCDISP8BY2,
  BFD_RELOC_SH_PCDISP12BY2,
  BFD_RELOC_SH_IMM3,
  BFD_RELOC_SH_IMM3U,
  BFD_RELOC_SH_DISP12,
  BFD_RELOC_SH_DISP12BY2,
  BFD_RELOC_SH_DISP12BY4,
  BFD_RELOC_SH_DISP12BY8,
  BFD_RELOC_SH_DISP20,
  BFD_RELOC_SH_DISP20BY8,
  BFD_RELOC_SH_IMM4,
  BFD_RELOC_SH_IMM4BY2,
  BFD_RELOC_SH_IMM4BY4,
  BFD_RELOC_SH_IMM8,
  BFD_RELOC_SH_IMM8BY2,
  BFD_RELOC_SH_IMM8BY4,
  BFD_RELOC_SH_PCRELIMM8BY2,
  BFD_RELOC_SH_PCRELIMM8BY4,
  BFD_RELOC_SH_SWITCH16,
  BFD_RELOC_SH_SWITCH32,
  BFD_RELOC_SH_USES,
  BFD_RELOC_SH_COUNT,
  BFD_RELOC_SH_ALIGN,
  BFD_RELOC_SH_CODE,
  BFD_RELOC_SH_DATA,
  BFD_RELOC_SH_LABEL,
  BFD_RELOC_SH_LOOP_START,
  BFD_RELOC_SH_LOOP_END,
  BFD_RELOC_SH_COPY,
  BFD_RELOC_SH_GLOB_DAT,
  BFD_RELOC_SH_JMP_SLOT,
  BFD_RELOC_SH_RELATIVE,
  BFD_RELOC_SH_GOTPC,
  BFD_RELOC_SH_GOT_LOW16,
  BFD_RELOC_SH_GOT_MEDLOW16,
  BFD_RELOC_SH_GOT_MEDHI16,
  BFD_RELOC_SH_GOT_HI16,
  BFD_RELOC_SH_GOTPLT_LOW16,
  BFD_RELOC_SH_GOTPLT_MEDLOW16,
  BFD_RELOC_SH_GOTPLT_MEDHI16,
  BFD_RELOC_SH_GOTPLT_HI16,
  BFD_RELOC_SH_PLT_LOW16,
  BFD_RELOC_SH_PLT_MEDLOW16,
  BFD_RELOC_SH_PLT_MEDHI16,
  BFD_RELOC_SH_PLT_HI16,
  BFD_RELOC_SH_GOTOFF_LOW16,
  BFD_RELOC_SH_GOTOFF_MEDLOW16,
  BFD_RELOC_SH_GOTOFF_MEDHI16,
  BFD_RELOC_SH_GOTOFF_HI16,
  BFD_RELOC_SH_GOTPC_LOW16,
  BFD_RELOC_SH_GOTPC_MEDLOW16,
  BFD_RELOC_SH_GOTPC_MEDHI16,
  BFD_RELOC_SH_GOTPC_HI16,
  BFD_RELOC_SH_COPY64,
  BFD_RELOC_SH_GLOB_DAT64,
  BFD_RELOC_SH_JMP_SLOT64,
  BFD_RELOC_SH_RELATIVE64,
  BFD_RELOC_SH_GOT10BY4,
  BFD_RELOC_SH_GOT10BY8,
  BFD_RELOC_SH_GOTPLT10BY4,
  BFD_RELOC_SH_GOTPLT10BY8,
  BFD_RELOC_SH_GOTPLT32,
  BFD_RELOC_SH_SHMEDIA_CODE,
  BFD_RELOC_SH_IMMU5,
  BFD_RELOC_SH_IMMS6,
  BFD_RELOC_SH_IMMS6BY32,
  BFD_RELOC_SH_IMMU6,
  BFD_RELOC_SH_IMMS10,
  BFD_RELOC_SH_IMMS10BY2,
  BFD_RELOC_SH_IMMS10BY4,
  BFD_RELOC_SH_IMMS10BY8,
  BFD_RELOC_SH_IMMS16,
  BFD_RELOC_SH_IMMU16,
  BFD_RELOC_SH_IMM_LOW16,
  BFD_RELOC_SH_IMM_LOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDLOW16,
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDHI16,
  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
  BFD_RELOC_SH_IMM_HI16,
  BFD_RELOC_SH_IMM_HI16_PCREL,
  BFD_RELOC_SH_PT_16,
  BFD_RELOC_SH_TLS_GD_32,
  BFD_RELOC_SH_TLS_LD_32,
  BFD_RELOC_SH_TLS_LDO_32,
  BFD_RELOC_SH_TLS_IE_32,
  BFD_RELOC_SH_TLS_LE_32,
  BFD_RELOC_SH_TLS_DTPMOD32,
  BFD_RELOC_SH_TLS_DTPOFF32,
  BFD_RELOC_SH_TLS_TPOFF32,
  BFD_RELOC_SH_GOT20,
  BFD_RELOC_SH_GOTOFF20,
  BFD_RELOC_SH_GOTFUNCDESC,
  BFD_RELOC_SH_GOTFUNCDESC20,
  BFD_RELOC_SH_GOTOFFFUNCDESC,
  BFD_RELOC_SH_GOTOFFFUNCDESC20,
  BFD_RELOC_SH_FUNCDESC,


  BFD_RELOC_ARC_NONE,
  BFD_RELOC_ARC_8,
  BFD_RELOC_ARC_16,
  BFD_RELOC_ARC_24,
  BFD_RELOC_ARC_32,
  BFD_RELOC_ARC_N8,
  BFD_RELOC_ARC_N16,
  BFD_RELOC_ARC_N24,
  BFD_RELOC_ARC_N32,
  BFD_RELOC_ARC_SDA,
  BFD_RELOC_ARC_SECTOFF,
  BFD_RELOC_ARC_S21H_PCREL,
  BFD_RELOC_ARC_S21W_PCREL,
  BFD_RELOC_ARC_S25H_PCREL,
  BFD_RELOC_ARC_S25W_PCREL,
  BFD_RELOC_ARC_SDA32,
  BFD_RELOC_ARC_SDA_LDST,
  BFD_RELOC_ARC_SDA_LDST1,
  BFD_RELOC_ARC_SDA_LDST2,
  BFD_RELOC_ARC_SDA16_LD,
  BFD_RELOC_ARC_SDA16_LD1,
  BFD_RELOC_ARC_SDA16_LD2,
  BFD_RELOC_ARC_S13_PCREL,
  BFD_RELOC_ARC_W,
  BFD_RELOC_ARC_32_ME,
  BFD_RELOC_ARC_32_ME_S,
  BFD_RELOC_ARC_N32_ME,
  BFD_RELOC_ARC_SECTOFF_ME,
  BFD_RELOC_ARC_SDA32_ME,
  BFD_RELOC_ARC_W_ME,
  BFD_RELOC_AC_SECTOFF_U8,
  BFD_RELOC_AC_SECTOFF_U8_1,
  BFD_RELOC_AC_SECTOFF_U8_2,
  BFD_RELOC_AC_SECTOFF_S9,
  BFD_RELOC_AC_SECTOFF_S9_1,
  BFD_RELOC_AC_SECTOFF_S9_2,
  BFD_RELOC_ARC_SECTOFF_ME_1,
  BFD_RELOC_ARC_SECTOFF_ME_2,
  BFD_RELOC_ARC_SECTOFF_1,
  BFD_RELOC_ARC_SECTOFF_2,
  BFD_RELOC_ARC_SDA_12,
  BFD_RELOC_ARC_SDA16_ST2,
  BFD_RELOC_ARC_32_PCREL,
  BFD_RELOC_ARC_PC32,
  BFD_RELOC_ARC_GOT32,
  BFD_RELOC_ARC_GOTPC32,
  BFD_RELOC_ARC_PLT32,
  BFD_RELOC_ARC_COPY,
  BFD_RELOC_ARC_GLOB_DAT,
  BFD_RELOC_ARC_JMP_SLOT,
  BFD_RELOC_ARC_RELATIVE,
  BFD_RELOC_ARC_GOTOFF,
  BFD_RELOC_ARC_GOTPC,
  BFD_RELOC_ARC_S21W_PCREL_PLT,
  BFD_RELOC_ARC_S25H_PCREL_PLT,
  BFD_RELOC_ARC_TLS_DTPMOD,
  BFD_RELOC_ARC_TLS_TPOFF,
  BFD_RELOC_ARC_TLS_GD_GOT,
  BFD_RELOC_ARC_TLS_GD_LD,
  BFD_RELOC_ARC_TLS_GD_CALL,
  BFD_RELOC_ARC_TLS_IE_GOT,
  BFD_RELOC_ARC_TLS_DTPOFF,
  BFD_RELOC_ARC_TLS_DTPOFF_S9,
  BFD_RELOC_ARC_TLS_LE_S9,
  BFD_RELOC_ARC_TLS_LE_32,
  BFD_RELOC_ARC_S25W_PCREL_PLT,
  BFD_RELOC_ARC_S21H_PCREL_PLT,
  BFD_RELOC_ARC_NPS_CMEM16,
  BFD_RELOC_ARC_JLI_SECTOFF,


  BFD_RELOC_BFIN_16_IMM,


  BFD_RELOC_BFIN_16_HIGH,


  BFD_RELOC_BFIN_4_PCREL,


  BFD_RELOC_BFIN_5_PCREL,


  BFD_RELOC_BFIN_16_LOW,


  BFD_RELOC_BFIN_10_PCREL,


  BFD_RELOC_BFIN_11_PCREL,


  BFD_RELOC_BFIN_12_PCREL_JUMP,


  BFD_RELOC_BFIN_12_PCREL_JUMP_S,


  BFD_RELOC_BFIN_24_PCREL_CALL_X,


  BFD_RELOC_BFIN_24_PCREL_JUMP_L,


  BFD_RELOC_BFIN_GOT17M4,
  BFD_RELOC_BFIN_GOTHI,
  BFD_RELOC_BFIN_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC,
  BFD_RELOC_BFIN_FUNCDESC_GOT17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC_VALUE,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO,
  BFD_RELOC_BFIN_GOTOFF17M4,
  BFD_RELOC_BFIN_GOTOFFHI,
  BFD_RELOC_BFIN_GOTOFFLO,


  BFD_RELOC_BFIN_GOT,


  BFD_RELOC_BFIN_PLTPC,


  BFD_ARELOC_BFIN_PUSH,


  BFD_ARELOC_BFIN_CONST,


  BFD_ARELOC_BFIN_ADD,


  BFD_ARELOC_BFIN_SUB,


  BFD_ARELOC_BFIN_MULT,


  BFD_ARELOC_BFIN_DIV,


  BFD_ARELOC_BFIN_MOD,


  BFD_ARELOC_BFIN_LSHIFT,


  BFD_ARELOC_BFIN_RSHIFT,


  BFD_ARELOC_BFIN_AND,


  BFD_ARELOC_BFIN_OR,


  BFD_ARELOC_BFIN_XOR,


  BFD_ARELOC_BFIN_LAND,


  BFD_ARELOC_BFIN_LOR,


  BFD_ARELOC_BFIN_LEN,


  BFD_ARELOC_BFIN_NEG,


  BFD_ARELOC_BFIN_COMP,


  BFD_ARELOC_BFIN_PAGE,


  BFD_ARELOC_BFIN_HWPAGE,


  BFD_ARELOC_BFIN_ADDR,




  BFD_RELOC_D10V_10_PCREL_R,






  BFD_RELOC_D10V_10_PCREL_L,



  BFD_RELOC_D10V_18,



  BFD_RELOC_D10V_18_PCREL,



  BFD_RELOC_D30V_6,



  BFD_RELOC_D30V_9_PCREL,





  BFD_RELOC_D30V_9_PCREL_R,



  BFD_RELOC_D30V_15,



  BFD_RELOC_D30V_15_PCREL,





  BFD_RELOC_D30V_15_PCREL_R,



  BFD_RELOC_D30V_21,



  BFD_RELOC_D30V_21_PCREL,





  BFD_RELOC_D30V_21_PCREL_R,


  BFD_RELOC_D30V_32,


  BFD_RELOC_D30V_32_PCREL,


  BFD_RELOC_DLX_HI16_S,


  BFD_RELOC_DLX_LO16,


  BFD_RELOC_DLX_JMP26,


  BFD_RELOC_M32C_HI8,
  BFD_RELOC_M32C_RL_JUMP,
  BFD_RELOC_M32C_RL_1ADDR,
  BFD_RELOC_M32C_RL_2ADDR,



  BFD_RELOC_M32R_24,


  BFD_RELOC_M32R_10_PCREL,


  BFD_RELOC_M32R_18_PCREL,


  BFD_RELOC_M32R_26_PCREL,



  BFD_RELOC_M32R_HI16_ULO,



  BFD_RELOC_M32R_HI16_SLO,


  BFD_RELOC_M32R_LO16,



  BFD_RELOC_M32R_SDA16,


  BFD_RELOC_M32R_GOT24,
  BFD_RELOC_M32R_26_PLTREL,
  BFD_RELOC_M32R_COPY,
  BFD_RELOC_M32R_GLOB_DAT,
  BFD_RELOC_M32R_JMP_SLOT,
  BFD_RELOC_M32R_RELATIVE,
  BFD_RELOC_M32R_GOTOFF,
  BFD_RELOC_M32R_GOTOFF_HI_ULO,
  BFD_RELOC_M32R_GOTOFF_HI_SLO,
  BFD_RELOC_M32R_GOTOFF_LO,
  BFD_RELOC_M32R_GOTPC24,
  BFD_RELOC_M32R_GOT16_HI_ULO,
  BFD_RELOC_M32R_GOT16_HI_SLO,
  BFD_RELOC_M32R_GOT16_LO,
  BFD_RELOC_M32R_GOTPC_HI_ULO,
  BFD_RELOC_M32R_GOTPC_HI_SLO,
  BFD_RELOC_M32R_GOTPC_LO,



  BFD_RELOC_NDS32_20,


  BFD_RELOC_NDS32_9_PCREL,


  BFD_RELOC_NDS32_WORD_9_PCREL,


  BFD_RELOC_NDS32_15_PCREL,


  BFD_RELOC_NDS32_17_PCREL,


  BFD_RELOC_NDS32_25_PCREL,



  BFD_RELOC_NDS32_HI20,



  BFD_RELOC_NDS32_LO12S3,



  BFD_RELOC_NDS32_LO12S2,



  BFD_RELOC_NDS32_LO12S1,



  BFD_RELOC_NDS32_LO12S0,



  BFD_RELOC_NDS32_LO12S0_ORI,



  BFD_RELOC_NDS32_SDA15S3,



  BFD_RELOC_NDS32_SDA15S2,



  BFD_RELOC_NDS32_SDA15S1,



  BFD_RELOC_NDS32_SDA15S0,



  BFD_RELOC_NDS32_SDA16S3,



  BFD_RELOC_NDS32_SDA17S2,



  BFD_RELOC_NDS32_SDA18S1,



  BFD_RELOC_NDS32_SDA19S0,


  BFD_RELOC_NDS32_GOT20,
  BFD_RELOC_NDS32_9_PLTREL,
  BFD_RELOC_NDS32_25_PLTREL,
  BFD_RELOC_NDS32_COPY,
  BFD_RELOC_NDS32_GLOB_DAT,
  BFD_RELOC_NDS32_JMP_SLOT,
  BFD_RELOC_NDS32_RELATIVE,
  BFD_RELOC_NDS32_GOTOFF,
  BFD_RELOC_NDS32_GOTOFF_HI20,
  BFD_RELOC_NDS32_GOTOFF_LO12,
  BFD_RELOC_NDS32_GOTPC20,
  BFD_RELOC_NDS32_GOT_HI20,
  BFD_RELOC_NDS32_GOT_LO12,
  BFD_RELOC_NDS32_GOTPC_HI20,
  BFD_RELOC_NDS32_GOTPC_LO12,


  BFD_RELOC_NDS32_INSN16,
  BFD_RELOC_NDS32_LABEL,
  BFD_RELOC_NDS32_LONGCALL1,
  BFD_RELOC_NDS32_LONGCALL2,
  BFD_RELOC_NDS32_LONGCALL3,
  BFD_RELOC_NDS32_LONGJUMP1,
  BFD_RELOC_NDS32_LONGJUMP2,
  BFD_RELOC_NDS32_LONGJUMP3,
  BFD_RELOC_NDS32_LOADSTORE,
  BFD_RELOC_NDS32_9_FIXED,
  BFD_RELOC_NDS32_15_FIXED,
  BFD_RELOC_NDS32_17_FIXED,
  BFD_RELOC_NDS32_25_FIXED,
  BFD_RELOC_NDS32_LONGCALL4,
  BFD_RELOC_NDS32_LONGCALL5,
  BFD_RELOC_NDS32_LONGCALL6,
  BFD_RELOC_NDS32_LONGJUMP4,
  BFD_RELOC_NDS32_LONGJUMP5,
  BFD_RELOC_NDS32_LONGJUMP6,
  BFD_RELOC_NDS32_LONGJUMP7,


  BFD_RELOC_NDS32_PLTREL_HI20,
  BFD_RELOC_NDS32_PLTREL_LO12,
  BFD_RELOC_NDS32_PLT_GOTREL_HI20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO12,


  BFD_RELOC_NDS32_SDA12S2_DP,
  BFD_RELOC_NDS32_SDA12S2_SP,
  BFD_RELOC_NDS32_LO12S2_DP,
  BFD_RELOC_NDS32_LO12S2_SP,


  BFD_RELOC_NDS32_DWARF2_OP1,
  BFD_RELOC_NDS32_DWARF2_OP2,
  BFD_RELOC_NDS32_DWARF2_LEB,


  BFD_RELOC_NDS32_UPDATE_TA,


  BFD_RELOC_NDS32_PLT_GOTREL_LO20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO15,
  BFD_RELOC_NDS32_PLT_GOTREL_LO19,
  BFD_RELOC_NDS32_GOT_LO15,
  BFD_RELOC_NDS32_GOT_LO19,
  BFD_RELOC_NDS32_GOTOFF_LO15,
  BFD_RELOC_NDS32_GOTOFF_LO19,
  BFD_RELOC_NDS32_GOT15S2,
  BFD_RELOC_NDS32_GOT17S2,



  BFD_RELOC_NDS32_5,


  BFD_RELOC_NDS32_10_UPCREL,


  BFD_RELOC_NDS32_SDA_FP7U2_RELA,


  BFD_RELOC_NDS32_RELAX_ENTRY,
  BFD_RELOC_NDS32_GOT_SUFF,
  BFD_RELOC_NDS32_GOTOFF_SUFF,
  BFD_RELOC_NDS32_PLT_GOT_SUFF,
  BFD_RELOC_NDS32_MULCALL_SUFF,
  BFD_RELOC_NDS32_PTR,
  BFD_RELOC_NDS32_PTR_COUNT,
  BFD_RELOC_NDS32_PTR_RESOLVED,
  BFD_RELOC_NDS32_PLTBLOCK,
  BFD_RELOC_NDS32_RELAX_REGION_BEGIN,
  BFD_RELOC_NDS32_RELAX_REGION_END,
  BFD_RELOC_NDS32_MINUEND,
  BFD_RELOC_NDS32_SUBTRAHEND,
  BFD_RELOC_NDS32_DIFF8,
  BFD_RELOC_NDS32_DIFF16,
  BFD_RELOC_NDS32_DIFF32,
  BFD_RELOC_NDS32_DIFF_ULEB128,
  BFD_RELOC_NDS32_EMPTY,


  BFD_RELOC_NDS32_25_ABS,


  BFD_RELOC_NDS32_DATA,
  BFD_RELOC_NDS32_TRAN,
  BFD_RELOC_NDS32_17IFC_PCREL,
  BFD_RELOC_NDS32_10IFCU_PCREL,


  BFD_RELOC_NDS32_TPOFF,
  BFD_RELOC_NDS32_GOTTPOFF,
  BFD_RELOC_NDS32_TLS_LE_HI20,
  BFD_RELOC_NDS32_TLS_LE_LO12,
  BFD_RELOC_NDS32_TLS_LE_20,
  BFD_RELOC_NDS32_TLS_LE_15S0,
  BFD_RELOC_NDS32_TLS_LE_15S1,
  BFD_RELOC_NDS32_TLS_LE_15S2,
  BFD_RELOC_NDS32_TLS_LE_ADD,
  BFD_RELOC_NDS32_TLS_LE_LS,
  BFD_RELOC_NDS32_TLS_IE_HI20,
  BFD_RELOC_NDS32_TLS_IE_LO12,
  BFD_RELOC_NDS32_TLS_IE_LO12S2,
  BFD_RELOC_NDS32_TLS_IEGP_HI20,
  BFD_RELOC_NDS32_TLS_IEGP_LO12,
  BFD_RELOC_NDS32_TLS_IEGP_LO12S2,
  BFD_RELOC_NDS32_TLS_IEGP_LW,
  BFD_RELOC_NDS32_TLS_DESC,
  BFD_RELOC_NDS32_TLS_DESC_HI20,
  BFD_RELOC_NDS32_TLS_DESC_LO12,
  BFD_RELOC_NDS32_TLS_DESC_20,
  BFD_RELOC_NDS32_TLS_DESC_SDA17S2,
  BFD_RELOC_NDS32_TLS_DESC_ADD,
  BFD_RELOC_NDS32_TLS_DESC_FUNC,
  BFD_RELOC_NDS32_TLS_DESC_CALL,
  BFD_RELOC_NDS32_TLS_DESC_MEM,
  BFD_RELOC_NDS32_REMOVE,
  BFD_RELOC_NDS32_GROUP,


  BFD_RELOC_NDS32_LSI,


  BFD_RELOC_V850_9_PCREL,


  BFD_RELOC_V850_22_PCREL,


  BFD_RELOC_V850_SDA_16_16_OFFSET,



  BFD_RELOC_V850_SDA_15_16_OFFSET,


  BFD_RELOC_V850_ZDA_16_16_OFFSET,



  BFD_RELOC_V850_ZDA_15_16_OFFSET,



  BFD_RELOC_V850_TDA_6_8_OFFSET,



  BFD_RELOC_V850_TDA_7_8_OFFSET,


  BFD_RELOC_V850_TDA_7_7_OFFSET,


  BFD_RELOC_V850_TDA_16_16_OFFSET,



  BFD_RELOC_V850_TDA_4_5_OFFSET,


  BFD_RELOC_V850_TDA_4_4_OFFSET,



  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,



  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,


  BFD_RELOC_V850_CALLT_6_7_OFFSET,


  BFD_RELOC_V850_CALLT_16_16_OFFSET,


  BFD_RELOC_V850_LONGCALL,


  BFD_RELOC_V850_LONGJUMP,


  BFD_RELOC_V850_ALIGN,



  BFD_RELOC_V850_LO16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_PCREL,


  BFD_RELOC_V850_17_PCREL,


  BFD_RELOC_V850_23,


  BFD_RELOC_V850_32_PCREL,


  BFD_RELOC_V850_32_ABS,


  BFD_RELOC_V850_16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_S1,


  BFD_RELOC_V850_LO16_S1,


  BFD_RELOC_V850_CALLT_15_16_OFFSET,


  BFD_RELOC_V850_32_GOTPCREL,


  BFD_RELOC_V850_16_GOT,


  BFD_RELOC_V850_32_GOT,


  BFD_RELOC_V850_22_PLT_PCREL,


  BFD_RELOC_V850_32_PLT_PCREL,


  BFD_RELOC_V850_COPY,


  BFD_RELOC_V850_GLOB_DAT,


  BFD_RELOC_V850_JMP_SLOT,


  BFD_RELOC_V850_RELATIVE,


  BFD_RELOC_V850_16_GOTOFF,


  BFD_RELOC_V850_32_GOTOFF,


  BFD_RELOC_V850_CODE,


  BFD_RELOC_V850_DATA,




  BFD_RELOC_TIC30_LDP,




  BFD_RELOC_TIC54X_PARTLS7,




  BFD_RELOC_TIC54X_PARTMS9,


  BFD_RELOC_TIC54X_23,




  BFD_RELOC_TIC54X_16_OF_23,




  BFD_RELOC_TIC54X_MS7_OF_23,


  BFD_RELOC_C6000_PCR_S21,
  BFD_RELOC_C6000_PCR_S12,
  BFD_RELOC_C6000_PCR_S10,
  BFD_RELOC_C6000_PCR_S7,
  BFD_RELOC_C6000_ABS_S16,
  BFD_RELOC_C6000_ABS_L16,
  BFD_RELOC_C6000_ABS_H16,
  BFD_RELOC_C6000_SBR_U15_B,
  BFD_RELOC_C6000_SBR_U15_H,
  BFD_RELOC_C6000_SBR_U15_W,
  BFD_RELOC_C6000_SBR_S16,
  BFD_RELOC_C6000_SBR_L16_B,
  BFD_RELOC_C6000_SBR_L16_H,
  BFD_RELOC_C6000_SBR_L16_W,
  BFD_RELOC_C6000_SBR_H16_B,
  BFD_RELOC_C6000_SBR_H16_H,
  BFD_RELOC_C6000_SBR_H16_W,
  BFD_RELOC_C6000_SBR_GOT_U15_W,
  BFD_RELOC_C6000_SBR_GOT_L16_W,
  BFD_RELOC_C6000_SBR_GOT_H16_W,
  BFD_RELOC_C6000_DSBT_INDEX,
  BFD_RELOC_C6000_PREL31,
  BFD_RELOC_C6000_COPY,
  BFD_RELOC_C6000_JUMP_SLOT,
  BFD_RELOC_C6000_EHTYPE,
  BFD_RELOC_C6000_PCR_H16,
  BFD_RELOC_C6000_PCR_L16,
  BFD_RELOC_C6000_ALIGN,
  BFD_RELOC_C6000_FPHEAD,
  BFD_RELOC_C6000_NOCMP,


  BFD_RELOC_FR30_48,



  BFD_RELOC_FR30_20,



  BFD_RELOC_FR30_6_IN_4,



  BFD_RELOC_FR30_8_IN_8,



  BFD_RELOC_FR30_9_IN_8,



  BFD_RELOC_FR30_10_IN_8,



  BFD_RELOC_FR30_9_PCREL,



  BFD_RELOC_FR30_12_PCREL,


  BFD_RELOC_MCORE_PCREL_IMM8BY4,
  BFD_RELOC_MCORE_PCREL_IMM11BY2,
  BFD_RELOC_MCORE_PCREL_IMM4BY2,
  BFD_RELOC_MCORE_PCREL_32,
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_MCORE_RVA,


  BFD_RELOC_MEP_8,
  BFD_RELOC_MEP_16,
  BFD_RELOC_MEP_32,
  BFD_RELOC_MEP_PCREL8A2,
  BFD_RELOC_MEP_PCREL12A2,
  BFD_RELOC_MEP_PCREL17A2,
  BFD_RELOC_MEP_PCREL24A2,
  BFD_RELOC_MEP_PCABS24A2,
  BFD_RELOC_MEP_LOW16,
  BFD_RELOC_MEP_HI16U,
  BFD_RELOC_MEP_HI16S,
  BFD_RELOC_MEP_GPREL,
  BFD_RELOC_MEP_TPREL,
  BFD_RELOC_MEP_TPREL7,
  BFD_RELOC_MEP_TPREL7A2,
  BFD_RELOC_MEP_TPREL7A4,
  BFD_RELOC_MEP_UIMM24,
  BFD_RELOC_MEP_ADDR24A4,
  BFD_RELOC_MEP_GNU_VTINHERIT,
  BFD_RELOC_MEP_GNU_VTENTRY,



  BFD_RELOC_METAG_HIADDR16,
  BFD_RELOC_METAG_LOADDR16,
  BFD_RELOC_METAG_RELBRANCH,
  BFD_RELOC_METAG_GETSETOFF,
  BFD_RELOC_METAG_HIOG,
  BFD_RELOC_METAG_LOOG,
  BFD_RELOC_METAG_REL8,
  BFD_RELOC_METAG_REL16,
  BFD_RELOC_METAG_HI16_GOTOFF,
  BFD_RELOC_METAG_LO16_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOT,
  BFD_RELOC_METAG_HI16_GOTPC,
  BFD_RELOC_METAG_LO16_GOTPC,
  BFD_RELOC_METAG_HI16_PLT,
  BFD_RELOC_METAG_LO16_PLT,
  BFD_RELOC_METAG_RELBRANCH_PLT,
  BFD_RELOC_METAG_GOTOFF,
  BFD_RELOC_METAG_PLT,
  BFD_RELOC_METAG_COPY,
  BFD_RELOC_METAG_JMP_SLOT,
  BFD_RELOC_METAG_RELATIVE,
  BFD_RELOC_METAG_GLOB_DAT,
  BFD_RELOC_METAG_TLS_GD,
  BFD_RELOC_METAG_TLS_LDM,
  BFD_RELOC_METAG_TLS_LDO_HI16,
  BFD_RELOC_METAG_TLS_LDO_LO16,
  BFD_RELOC_METAG_TLS_LDO,
  BFD_RELOC_METAG_TLS_IE,
  BFD_RELOC_METAG_TLS_IENONPIC,
  BFD_RELOC_METAG_TLS_IENONPIC_HI16,
  BFD_RELOC_METAG_TLS_IENONPIC_LO16,
  BFD_RELOC_METAG_TLS_TPOFF,
  BFD_RELOC_METAG_TLS_DTPMOD,
  BFD_RELOC_METAG_TLS_DTPOFF,
  BFD_RELOC_METAG_TLS_LE,
  BFD_RELOC_METAG_TLS_LE_HI16,
  BFD_RELOC_METAG_TLS_LE_LO16,


  BFD_RELOC_MMIX_GETA,
  BFD_RELOC_MMIX_GETA_1,
  BFD_RELOC_MMIX_GETA_2,
  BFD_RELOC_MMIX_GETA_3,


  BFD_RELOC_MMIX_CBRANCH,
  BFD_RELOC_MMIX_CBRANCH_J,
  BFD_RELOC_MMIX_CBRANCH_1,
  BFD_RELOC_MMIX_CBRANCH_2,
  BFD_RELOC_MMIX_CBRANCH_3,


  BFD_RELOC_MMIX_PUSHJ,
  BFD_RELOC_MMIX_PUSHJ_1,
  BFD_RELOC_MMIX_PUSHJ_2,
  BFD_RELOC_MMIX_PUSHJ_3,
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,


  BFD_RELOC_MMIX_JMP,
  BFD_RELOC_MMIX_JMP_1,
  BFD_RELOC_MMIX_JMP_2,
  BFD_RELOC_MMIX_JMP_3,



  BFD_RELOC_MMIX_ADDR19,


  BFD_RELOC_MMIX_ADDR27,



  BFD_RELOC_MMIX_REG_OR_BYTE,



  BFD_RELOC_MMIX_REG,



  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,



  BFD_RELOC_MMIX_LOCAL,



  BFD_RELOC_AVR_7_PCREL,



  BFD_RELOC_AVR_13_PCREL,



  BFD_RELOC_AVR_16_PM,



  BFD_RELOC_AVR_LO8_LDI,



  BFD_RELOC_AVR_HI8_LDI,



  BFD_RELOC_AVR_HH8_LDI,



  BFD_RELOC_AVR_MS8_LDI,



  BFD_RELOC_AVR_LO8_LDI_NEG,




  BFD_RELOC_AVR_HI8_LDI_NEG,




  BFD_RELOC_AVR_HH8_LDI_NEG,



  BFD_RELOC_AVR_MS8_LDI_NEG,



  BFD_RELOC_AVR_LO8_LDI_PM,





  BFD_RELOC_AVR_LO8_LDI_GS,



  BFD_RELOC_AVR_HI8_LDI_PM,





  BFD_RELOC_AVR_HI8_LDI_GS,



  BFD_RELOC_AVR_HH8_LDI_PM,



  BFD_RELOC_AVR_LO8_LDI_PM_NEG,




  BFD_RELOC_AVR_HI8_LDI_PM_NEG,




  BFD_RELOC_AVR_HH8_LDI_PM_NEG,



  BFD_RELOC_AVR_CALL,



  BFD_RELOC_AVR_LDI,



  BFD_RELOC_AVR_6,



  BFD_RELOC_AVR_6_ADIW,



  BFD_RELOC_AVR_8_LO,



  BFD_RELOC_AVR_8_HI,



  BFD_RELOC_AVR_8_HLO,







  BFD_RELOC_AVR_DIFF8,
  BFD_RELOC_AVR_DIFF16,
  BFD_RELOC_AVR_DIFF32,



  BFD_RELOC_AVR_LDS_STS_16,



  BFD_RELOC_AVR_PORT6,



  BFD_RELOC_AVR_PORT5,


  BFD_RELOC_RISCV_HI20,
  BFD_RELOC_RISCV_PCREL_HI20,
  BFD_RELOC_RISCV_PCREL_LO12_I,
  BFD_RELOC_RISCV_PCREL_LO12_S,
  BFD_RELOC_RISCV_LO12_I,
  BFD_RELOC_RISCV_LO12_S,
  BFD_RELOC_RISCV_GPREL12_I,
  BFD_RELOC_RISCV_GPREL12_S,
  BFD_RELOC_RISCV_TPREL_HI20,
  BFD_RELOC_RISCV_TPREL_LO12_I,
  BFD_RELOC_RISCV_TPREL_LO12_S,
  BFD_RELOC_RISCV_TPREL_ADD,
  BFD_RELOC_RISCV_CALL,
  BFD_RELOC_RISCV_CALL_PLT,
  BFD_RELOC_RISCV_ADD8,
  BFD_RELOC_RISCV_ADD16,
  BFD_RELOC_RISCV_ADD32,
  BFD_RELOC_RISCV_ADD64,
  BFD_RELOC_RISCV_SUB8,
  BFD_RELOC_RISCV_SUB16,
  BFD_RELOC_RISCV_SUB32,
  BFD_RELOC_RISCV_SUB64,
  BFD_RELOC_RISCV_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GD_HI20,
  BFD_RELOC_RISCV_JMP,
  BFD_RELOC_RISCV_TLS_DTPMOD32,
  BFD_RELOC_RISCV_TLS_DTPREL32,
  BFD_RELOC_RISCV_TLS_DTPMOD64,
  BFD_RELOC_RISCV_TLS_DTPREL64,
  BFD_RELOC_RISCV_TLS_TPREL32,
  BFD_RELOC_RISCV_TLS_TPREL64,
  BFD_RELOC_RISCV_ALIGN,
  BFD_RELOC_RISCV_RVC_BRANCH,
  BFD_RELOC_RISCV_RVC_JUMP,
  BFD_RELOC_RISCV_RVC_LUI,
  BFD_RELOC_RISCV_GPREL_I,
  BFD_RELOC_RISCV_GPREL_S,
  BFD_RELOC_RISCV_TPREL_I,
  BFD_RELOC_RISCV_TPREL_S,
  BFD_RELOC_RISCV_RELAX,
  BFD_RELOC_RISCV_CFA,
  BFD_RELOC_RISCV_SUB6,
  BFD_RELOC_RISCV_SET6,
  BFD_RELOC_RISCV_SET8,
  BFD_RELOC_RISCV_SET16,
  BFD_RELOC_RISCV_SET32,
  BFD_RELOC_RISCV_32_PCREL,
  BFD_RELOC_RISCV_SET_ULEB128,
  BFD_RELOC_RISCV_SUB_ULEB128,


  BFD_RELOC_RL78_NEG8,
  BFD_RELOC_RL78_NEG16,
  BFD_RELOC_RL78_NEG24,
  BFD_RELOC_RL78_NEG32,
  BFD_RELOC_RL78_16_OP,
  BFD_RELOC_RL78_24_OP,
  BFD_RELOC_RL78_32_OP,
  BFD_RELOC_RL78_8U,
  BFD_RELOC_RL78_16U,
  BFD_RELOC_RL78_24U,
  BFD_RELOC_RL78_DIR3U_PCREL,
  BFD_RELOC_RL78_DIFF,
  BFD_RELOC_RL78_GPRELB,
  BFD_RELOC_RL78_GPRELW,
  BFD_RELOC_RL78_GPRELL,
  BFD_RELOC_RL78_SYM,
  BFD_RELOC_RL78_OP_SUBTRACT,
  BFD_RELOC_RL78_OP_NEG,
  BFD_RELOC_RL78_OP_AND,
  BFD_RELOC_RL78_OP_SHRA,
  BFD_RELOC_RL78_ABS8,
  BFD_RELOC_RL78_ABS16,
  BFD_RELOC_RL78_ABS16_REV,
  BFD_RELOC_RL78_ABS32,
  BFD_RELOC_RL78_ABS32_REV,
  BFD_RELOC_RL78_ABS16U,
  BFD_RELOC_RL78_ABS16UW,
  BFD_RELOC_RL78_ABS16UL,
  BFD_RELOC_RL78_RELAX,
  BFD_RELOC_RL78_HI16,
  BFD_RELOC_RL78_HI8,
  BFD_RELOC_RL78_LO16,
  BFD_RELOC_RL78_CODE,
  BFD_RELOC_RL78_SADDR,


  BFD_RELOC_RX_NEG8,
  BFD_RELOC_RX_NEG16,
  BFD_RELOC_RX_NEG24,
  BFD_RELOC_RX_NEG32,
  BFD_RELOC_RX_16_OP,
  BFD_RELOC_RX_24_OP,
  BFD_RELOC_RX_32_OP,
  BFD_RELOC_RX_8U,
  BFD_RELOC_RX_16U,
  BFD_RELOC_RX_24U,
  BFD_RELOC_RX_DIR3U_PCREL,
  BFD_RELOC_RX_DIFF,
  BFD_RELOC_RX_GPRELB,
  BFD_RELOC_RX_GPRELW,
  BFD_RELOC_RX_GPRELL,
  BFD_RELOC_RX_SYM,
  BFD_RELOC_RX_OP_SUBTRACT,
  BFD_RELOC_RX_OP_NEG,
  BFD_RELOC_RX_ABS8,
  BFD_RELOC_RX_ABS16,
  BFD_RELOC_RX_ABS16_REV,
  BFD_RELOC_RX_ABS32,
  BFD_RELOC_RX_ABS32_REV,
  BFD_RELOC_RX_ABS16U,
  BFD_RELOC_RX_ABS16UW,
  BFD_RELOC_RX_ABS16UL,
  BFD_RELOC_RX_RELAX,


  BFD_RELOC_390_12,


  BFD_RELOC_390_GOT12,


  BFD_RELOC_390_PLT32,


  BFD_RELOC_390_COPY,


  BFD_RELOC_390_GLOB_DAT,


  BFD_RELOC_390_JMP_SLOT,


  BFD_RELOC_390_RELATIVE,


  BFD_RELOC_390_GOTPC,


  BFD_RELOC_390_GOT16,


  BFD_RELOC_390_PC12DBL,


  BFD_RELOC_390_PLT12DBL,


  BFD_RELOC_390_PC16DBL,


  BFD_RELOC_390_PLT16DBL,


  BFD_RELOC_390_PC24DBL,


  BFD_RELOC_390_PLT24DBL,


  BFD_RELOC_390_PC32DBL,


  BFD_RELOC_390_PLT32DBL,


  BFD_RELOC_390_GOTPCDBL,


  BFD_RELOC_390_GOT64,


  BFD_RELOC_390_PLT64,


  BFD_RELOC_390_GOTENT,


  BFD_RELOC_390_GOTOFF64,


  BFD_RELOC_390_GOTPLT12,


  BFD_RELOC_390_GOTPLT16,


  BFD_RELOC_390_GOTPLT32,


  BFD_RELOC_390_GOTPLT64,


  BFD_RELOC_390_GOTPLTENT,


  BFD_RELOC_390_PLTOFF16,


  BFD_RELOC_390_PLTOFF32,


  BFD_RELOC_390_PLTOFF64,


  BFD_RELOC_390_TLS_LOAD,
  BFD_RELOC_390_TLS_GDCALL,
  BFD_RELOC_390_TLS_LDCALL,
  BFD_RELOC_390_TLS_GD32,
  BFD_RELOC_390_TLS_GD64,
  BFD_RELOC_390_TLS_GOTIE12,
  BFD_RELOC_390_TLS_GOTIE32,
  BFD_RELOC_390_TLS_GOTIE64,
  BFD_RELOC_390_TLS_LDM32,
  BFD_RELOC_390_TLS_LDM64,
  BFD_RELOC_390_TLS_IE32,
  BFD_RELOC_390_TLS_IE64,
  BFD_RELOC_390_TLS_IEENT,
  BFD_RELOC_390_TLS_LE32,
  BFD_RELOC_390_TLS_LE64,
  BFD_RELOC_390_TLS_LDO32,
  BFD_RELOC_390_TLS_LDO64,
  BFD_RELOC_390_TLS_DTPMOD,
  BFD_RELOC_390_TLS_DTPOFF,
  BFD_RELOC_390_TLS_TPOFF,


  BFD_RELOC_390_20,
  BFD_RELOC_390_GOT20,
  BFD_RELOC_390_GOTPLT20,
  BFD_RELOC_390_TLS_GOTIE20,


  BFD_RELOC_390_IRELATIVE,



  BFD_RELOC_SCORE_GPREL15,


  BFD_RELOC_SCORE_DUMMY2,
  BFD_RELOC_SCORE_JMP,


  BFD_RELOC_SCORE_BRANCH,


  BFD_RELOC_SCORE_IMM30,


  BFD_RELOC_SCORE_IMM32,


  BFD_RELOC_SCORE16_JMP,


  BFD_RELOC_SCORE16_BRANCH,


  BFD_RELOC_SCORE_BCMP,


  BFD_RELOC_SCORE_GOT15,
  BFD_RELOC_SCORE_GOT_LO16,
  BFD_RELOC_SCORE_CALL15,
  BFD_RELOC_SCORE_DUMMY_HI16,


  BFD_RELOC_IP2K_FR9,


  BFD_RELOC_IP2K_BANK,


  BFD_RELOC_IP2K_ADDR16CJP,


  BFD_RELOC_IP2K_PAGE3,


  BFD_RELOC_IP2K_LO8DATA,
  BFD_RELOC_IP2K_HI8DATA,
  BFD_RELOC_IP2K_EX8DATA,


  BFD_RELOC_IP2K_LO8INSN,
  BFD_RELOC_IP2K_HI8INSN,


  BFD_RELOC_IP2K_PC_SKIP,


  BFD_RELOC_IP2K_TEXT,


  BFD_RELOC_IP2K_FR_OFFSET,


  BFD_RELOC_VPE4KMATH_DATA,
  BFD_RELOC_VPE4KMATH_INSN,
# 5677 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  BFD_RELOC_VTABLE_INHERIT,
  BFD_RELOC_VTABLE_ENTRY,


  BFD_RELOC_IA64_IMM14,
  BFD_RELOC_IA64_IMM22,
  BFD_RELOC_IA64_IMM64,
  BFD_RELOC_IA64_DIR32MSB,
  BFD_RELOC_IA64_DIR32LSB,
  BFD_RELOC_IA64_DIR64MSB,
  BFD_RELOC_IA64_DIR64LSB,
  BFD_RELOC_IA64_GPREL22,
  BFD_RELOC_IA64_GPREL64I,
  BFD_RELOC_IA64_GPREL32MSB,
  BFD_RELOC_IA64_GPREL32LSB,
  BFD_RELOC_IA64_GPREL64MSB,
  BFD_RELOC_IA64_GPREL64LSB,
  BFD_RELOC_IA64_LTOFF22,
  BFD_RELOC_IA64_LTOFF64I,
  BFD_RELOC_IA64_PLTOFF22,
  BFD_RELOC_IA64_PLTOFF64I,
  BFD_RELOC_IA64_PLTOFF64MSB,
  BFD_RELOC_IA64_PLTOFF64LSB,
  BFD_RELOC_IA64_FPTR64I,
  BFD_RELOC_IA64_FPTR32MSB,
  BFD_RELOC_IA64_FPTR32LSB,
  BFD_RELOC_IA64_FPTR64MSB,
  BFD_RELOC_IA64_FPTR64LSB,
  BFD_RELOC_IA64_PCREL21B,
  BFD_RELOC_IA64_PCREL21BI,
  BFD_RELOC_IA64_PCREL21M,
  BFD_RELOC_IA64_PCREL21F,
  BFD_RELOC_IA64_PCREL22,
  BFD_RELOC_IA64_PCREL60B,
  BFD_RELOC_IA64_PCREL64I,
  BFD_RELOC_IA64_PCREL32MSB,
  BFD_RELOC_IA64_PCREL32LSB,
  BFD_RELOC_IA64_PCREL64MSB,
  BFD_RELOC_IA64_PCREL64LSB,
  BFD_RELOC_IA64_LTOFF_FPTR22,
  BFD_RELOC_IA64_LTOFF_FPTR64I,
  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
  BFD_RELOC_IA64_SEGREL32MSB,
  BFD_RELOC_IA64_SEGREL32LSB,
  BFD_RELOC_IA64_SEGREL64MSB,
  BFD_RELOC_IA64_SEGREL64LSB,
  BFD_RELOC_IA64_SECREL32MSB,
  BFD_RELOC_IA64_SECREL32LSB,
  BFD_RELOC_IA64_SECREL64MSB,
  BFD_RELOC_IA64_SECREL64LSB,
  BFD_RELOC_IA64_REL32MSB,
  BFD_RELOC_IA64_REL32LSB,
  BFD_RELOC_IA64_REL64MSB,
  BFD_RELOC_IA64_REL64LSB,
  BFD_RELOC_IA64_LTV32MSB,
  BFD_RELOC_IA64_LTV32LSB,
  BFD_RELOC_IA64_LTV64MSB,
  BFD_RELOC_IA64_LTV64LSB,
  BFD_RELOC_IA64_IPLTMSB,
  BFD_RELOC_IA64_IPLTLSB,
  BFD_RELOC_IA64_COPY,
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,
  BFD_RELOC_IA64_TPREL14,
  BFD_RELOC_IA64_TPREL22,
  BFD_RELOC_IA64_TPREL64I,
  BFD_RELOC_IA64_TPREL64MSB,
  BFD_RELOC_IA64_TPREL64LSB,
  BFD_RELOC_IA64_LTOFF_TPREL22,
  BFD_RELOC_IA64_DTPMOD64MSB,
  BFD_RELOC_IA64_DTPMOD64LSB,
  BFD_RELOC_IA64_LTOFF_DTPMOD22,
  BFD_RELOC_IA64_DTPREL14,
  BFD_RELOC_IA64_DTPREL22,
  BFD_RELOC_IA64_DTPREL64I,
  BFD_RELOC_IA64_DTPREL32MSB,
  BFD_RELOC_IA64_DTPREL32LSB,
  BFD_RELOC_IA64_DTPREL64MSB,
  BFD_RELOC_IA64_DTPREL64LSB,
  BFD_RELOC_IA64_LTOFF_DTPREL22,



  BFD_RELOC_M68HC11_HI8,



  BFD_RELOC_M68HC11_LO8,



  BFD_RELOC_M68HC11_3B,






  BFD_RELOC_M68HC11_RL_JUMP,





  BFD_RELOC_M68HC11_RL_GROUP,





  BFD_RELOC_M68HC11_LO16,





  BFD_RELOC_M68HC11_PAGE,





  BFD_RELOC_M68HC11_24,



  BFD_RELOC_M68HC12_5B,



  BFD_RELOC_XGATE_RL_JUMP,





  BFD_RELOC_XGATE_RL_GROUP,




  BFD_RELOC_XGATE_LO16,


  BFD_RELOC_XGATE_GPAGE,


  BFD_RELOC_XGATE_24,



  BFD_RELOC_XGATE_PCREL_9,



  BFD_RELOC_XGATE_PCREL_10,




  BFD_RELOC_XGATE_IMM8_LO,




  BFD_RELOC_XGATE_IMM8_HI,



  BFD_RELOC_XGATE_IMM3,



  BFD_RELOC_XGATE_IMM4,



  BFD_RELOC_XGATE_IMM5,



  BFD_RELOC_M68HC12_9B,



  BFD_RELOC_M68HC12_16B,



  BFD_RELOC_M68HC12_9_PCREL,



  BFD_RELOC_M68HC12_10_PCREL,




  BFD_RELOC_M68HC12_LO8XG,




  BFD_RELOC_M68HC12_HI8XG,




  BFD_RELOC_S12Z_15_PCREL,


  BFD_RELOC_CR16_NUM8,
  BFD_RELOC_CR16_NUM16,
  BFD_RELOC_CR16_NUM32,
  BFD_RELOC_CR16_NUM32a,
  BFD_RELOC_CR16_REGREL0,
  BFD_RELOC_CR16_REGREL4,
  BFD_RELOC_CR16_REGREL4a,
  BFD_RELOC_CR16_REGREL14,
  BFD_RELOC_CR16_REGREL14a,
  BFD_RELOC_CR16_REGREL16,
  BFD_RELOC_CR16_REGREL20,
  BFD_RELOC_CR16_REGREL20a,
  BFD_RELOC_CR16_ABS20,
  BFD_RELOC_CR16_ABS24,
  BFD_RELOC_CR16_IMM4,
  BFD_RELOC_CR16_IMM8,
  BFD_RELOC_CR16_IMM16,
  BFD_RELOC_CR16_IMM20,
  BFD_RELOC_CR16_IMM24,
  BFD_RELOC_CR16_IMM32,
  BFD_RELOC_CR16_IMM32a,
  BFD_RELOC_CR16_DISP4,
  BFD_RELOC_CR16_DISP8,
  BFD_RELOC_CR16_DISP16,
  BFD_RELOC_CR16_DISP20,
  BFD_RELOC_CR16_DISP24,
  BFD_RELOC_CR16_DISP24a,
  BFD_RELOC_CR16_SWITCH8,
  BFD_RELOC_CR16_SWITCH16,
  BFD_RELOC_CR16_SWITCH32,
  BFD_RELOC_CR16_GOT_REGREL20,
  BFD_RELOC_CR16_GOTC_REGREL20,
  BFD_RELOC_CR16_GLOB_DAT,


  BFD_RELOC_CRX_REL4,
  BFD_RELOC_CRX_REL8,
  BFD_RELOC_CRX_REL8_CMP,
  BFD_RELOC_CRX_REL16,
  BFD_RELOC_CRX_REL24,
  BFD_RELOC_CRX_REL32,
  BFD_RELOC_CRX_REGREL12,
  BFD_RELOC_CRX_REGREL22,
  BFD_RELOC_CRX_REGREL28,
  BFD_RELOC_CRX_REGREL32,
  BFD_RELOC_CRX_ABS16,
  BFD_RELOC_CRX_ABS32,
  BFD_RELOC_CRX_NUM8,
  BFD_RELOC_CRX_NUM16,
  BFD_RELOC_CRX_NUM32,
  BFD_RELOC_CRX_IMM16,
  BFD_RELOC_CRX_IMM32,
  BFD_RELOC_CRX_SWITCH8,
  BFD_RELOC_CRX_SWITCH16,
  BFD_RELOC_CRX_SWITCH32,



  BFD_RELOC_CRIS_BDISP8,
  BFD_RELOC_CRIS_UNSIGNED_5,
  BFD_RELOC_CRIS_SIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_6,
  BFD_RELOC_CRIS_SIGNED_8,
  BFD_RELOC_CRIS_UNSIGNED_8,
  BFD_RELOC_CRIS_SIGNED_16,
  BFD_RELOC_CRIS_UNSIGNED_16,
  BFD_RELOC_CRIS_LAPCQ_OFFSET,
  BFD_RELOC_CRIS_UNSIGNED_4,


  BFD_RELOC_CRIS_COPY,
  BFD_RELOC_CRIS_GLOB_DAT,
  BFD_RELOC_CRIS_JUMP_SLOT,
  BFD_RELOC_CRIS_RELATIVE,


  BFD_RELOC_CRIS_32_GOT,


  BFD_RELOC_CRIS_16_GOT,


  BFD_RELOC_CRIS_32_GOTPLT,


  BFD_RELOC_CRIS_16_GOTPLT,


  BFD_RELOC_CRIS_32_GOTREL,


  BFD_RELOC_CRIS_32_PLT_GOTREL,


  BFD_RELOC_CRIS_32_PLT_PCREL,


  BFD_RELOC_CRIS_32_GOT_GD,
  BFD_RELOC_CRIS_16_GOT_GD,
  BFD_RELOC_CRIS_32_GD,
  BFD_RELOC_CRIS_DTP,
  BFD_RELOC_CRIS_32_DTPREL,
  BFD_RELOC_CRIS_16_DTPREL,
  BFD_RELOC_CRIS_32_GOT_TPREL,
  BFD_RELOC_CRIS_16_GOT_TPREL,
  BFD_RELOC_CRIS_32_TPREL,
  BFD_RELOC_CRIS_16_TPREL,
  BFD_RELOC_CRIS_DTPMOD,
  BFD_RELOC_CRIS_32_IE,


  BFD_RELOC_OR1K_REL_26,
  BFD_RELOC_OR1K_SLO16,
  BFD_RELOC_OR1K_PCREL_PG21,
  BFD_RELOC_OR1K_LO13,
  BFD_RELOC_OR1K_SLO13,
  BFD_RELOC_OR1K_GOTPC_HI16,
  BFD_RELOC_OR1K_GOTPC_LO16,
  BFD_RELOC_OR1K_GOT_AHI16,
  BFD_RELOC_OR1K_GOT16,
  BFD_RELOC_OR1K_GOT_PG21,
  BFD_RELOC_OR1K_GOT_LO13,
  BFD_RELOC_OR1K_PLT26,
  BFD_RELOC_OR1K_PLTA26,
  BFD_RELOC_OR1K_GOTOFF_SLO16,
  BFD_RELOC_OR1K_COPY,
  BFD_RELOC_OR1K_GLOB_DAT,
  BFD_RELOC_OR1K_JMP_SLOT,
  BFD_RELOC_OR1K_RELATIVE,
  BFD_RELOC_OR1K_TLS_GD_HI16,
  BFD_RELOC_OR1K_TLS_GD_LO16,
  BFD_RELOC_OR1K_TLS_GD_PG21,
  BFD_RELOC_OR1K_TLS_GD_LO13,
  BFD_RELOC_OR1K_TLS_LDM_HI16,
  BFD_RELOC_OR1K_TLS_LDM_LO16,
  BFD_RELOC_OR1K_TLS_LDM_PG21,
  BFD_RELOC_OR1K_TLS_LDM_LO13,
  BFD_RELOC_OR1K_TLS_LDO_HI16,
  BFD_RELOC_OR1K_TLS_LDO_LO16,
  BFD_RELOC_OR1K_TLS_IE_HI16,
  BFD_RELOC_OR1K_TLS_IE_AHI16,
  BFD_RELOC_OR1K_TLS_IE_LO16,
  BFD_RELOC_OR1K_TLS_IE_PG21,
  BFD_RELOC_OR1K_TLS_IE_LO13,
  BFD_RELOC_OR1K_TLS_LE_HI16,
  BFD_RELOC_OR1K_TLS_LE_AHI16,
  BFD_RELOC_OR1K_TLS_LE_LO16,
  BFD_RELOC_OR1K_TLS_LE_SLO16,
  BFD_RELOC_OR1K_TLS_TPOFF,
  BFD_RELOC_OR1K_TLS_DTPOFF,
  BFD_RELOC_OR1K_TLS_DTPMOD,


  BFD_RELOC_H8_DIR16A8,
  BFD_RELOC_H8_DIR16R8,
  BFD_RELOC_H8_DIR24A8,
  BFD_RELOC_H8_DIR24R8,
  BFD_RELOC_H8_DIR32A16,
  BFD_RELOC_H8_DISP32A16,


  BFD_RELOC_XSTORMY16_REL_12,
  BFD_RELOC_XSTORMY16_12,
  BFD_RELOC_XSTORMY16_24,
  BFD_RELOC_XSTORMY16_FPTR16,


  BFD_RELOC_RELC,



  BFD_RELOC_VAX_GLOB_DAT,
  BFD_RELOC_VAX_JMP_SLOT,
  BFD_RELOC_VAX_RELATIVE,


  BFD_RELOC_MT_PC16,


  BFD_RELOC_MT_HI16,


  BFD_RELOC_MT_LO16,


  BFD_RELOC_MT_GNU_VTINHERIT,


  BFD_RELOC_MT_GNU_VTENTRY,


  BFD_RELOC_MT_PCINSN8,


  BFD_RELOC_MSP430_10_PCREL,
  BFD_RELOC_MSP430_16_PCREL,
  BFD_RELOC_MSP430_16,
  BFD_RELOC_MSP430_16_PCREL_BYTE,
  BFD_RELOC_MSP430_16_BYTE,
  BFD_RELOC_MSP430_2X_PCREL,
  BFD_RELOC_MSP430_RL_PCREL,
  BFD_RELOC_MSP430_ABS8,
  BFD_RELOC_MSP430X_PCR20_EXT_SRC,
  BFD_RELOC_MSP430X_PCR20_EXT_DST,
  BFD_RELOC_MSP430X_PCR20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_EXT_SRC,
  BFD_RELOC_MSP430X_ABS20_EXT_DST,
  BFD_RELOC_MSP430X_ABS20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_ADR_SRC,
  BFD_RELOC_MSP430X_ABS20_ADR_DST,
  BFD_RELOC_MSP430X_PCR16,
  BFD_RELOC_MSP430X_PCR20_CALL,
  BFD_RELOC_MSP430X_ABS16,
  BFD_RELOC_MSP430_ABS_HI16,
  BFD_RELOC_MSP430_PREL31,
  BFD_RELOC_MSP430_SYM_DIFF,
  BFD_RELOC_MSP430_SET_ULEB128,
  BFD_RELOC_MSP430_SUB_ULEB128,


  BFD_RELOC_NIOS2_S16,
  BFD_RELOC_NIOS2_U16,
  BFD_RELOC_NIOS2_CALL26,
  BFD_RELOC_NIOS2_IMM5,
  BFD_RELOC_NIOS2_CACHE_OPX,
  BFD_RELOC_NIOS2_IMM6,
  BFD_RELOC_NIOS2_IMM8,
  BFD_RELOC_NIOS2_HI16,
  BFD_RELOC_NIOS2_LO16,
  BFD_RELOC_NIOS2_HIADJ16,
  BFD_RELOC_NIOS2_GPREL,
  BFD_RELOC_NIOS2_UJMP,
  BFD_RELOC_NIOS2_CJMP,
  BFD_RELOC_NIOS2_CALLR,
  BFD_RELOC_NIOS2_ALIGN,
  BFD_RELOC_NIOS2_GOT16,
  BFD_RELOC_NIOS2_CALL16,
  BFD_RELOC_NIOS2_GOTOFF_LO,
  BFD_RELOC_NIOS2_GOTOFF_HA,
  BFD_RELOC_NIOS2_PCREL_LO,
  BFD_RELOC_NIOS2_PCREL_HA,
  BFD_RELOC_NIOS2_TLS_GD16,
  BFD_RELOC_NIOS2_TLS_LDM16,
  BFD_RELOC_NIOS2_TLS_LDO16,
  BFD_RELOC_NIOS2_TLS_IE16,
  BFD_RELOC_NIOS2_TLS_LE16,
  BFD_RELOC_NIOS2_TLS_DTPMOD,
  BFD_RELOC_NIOS2_TLS_DTPREL,
  BFD_RELOC_NIOS2_TLS_TPREL,
  BFD_RELOC_NIOS2_COPY,
  BFD_RELOC_NIOS2_GLOB_DAT,
  BFD_RELOC_NIOS2_JUMP_SLOT,
  BFD_RELOC_NIOS2_RELATIVE,
  BFD_RELOC_NIOS2_GOTOFF,
  BFD_RELOC_NIOS2_CALL26_NOAT,
  BFD_RELOC_NIOS2_GOT_LO,
  BFD_RELOC_NIOS2_GOT_HA,
  BFD_RELOC_NIOS2_CALL_LO,
  BFD_RELOC_NIOS2_CALL_HA,
  BFD_RELOC_NIOS2_R2_S12,
  BFD_RELOC_NIOS2_R2_I10_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_2,
  BFD_RELOC_NIOS2_R2_T2I4,
  BFD_RELOC_NIOS2_R2_T2I4_1,
  BFD_RELOC_NIOS2_R2_T2I4_2,
  BFD_RELOC_NIOS2_R2_X1I7_2,
  BFD_RELOC_NIOS2_R2_X2L5,
  BFD_RELOC_NIOS2_R2_F1I5_2,
  BFD_RELOC_NIOS2_R2_L5I4X1,
  BFD_RELOC_NIOS2_R2_T1X1I6,
  BFD_RELOC_NIOS2_R2_T1X1I6_2,


  BFD_RELOC_PRU_U16,


  BFD_RELOC_PRU_U16_PMEMIMM,




  BFD_RELOC_PRU_LDI32,


  BFD_RELOC_PRU_S10_PCREL,


  BFD_RELOC_PRU_U8_PCREL,



  BFD_RELOC_PRU_32_PMEM,
  BFD_RELOC_PRU_16_PMEM,
# 6193 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  BFD_RELOC_PRU_GNU_DIFF8,
  BFD_RELOC_PRU_GNU_DIFF16,
  BFD_RELOC_PRU_GNU_DIFF32,
  BFD_RELOC_PRU_GNU_DIFF16_PMEM,
  BFD_RELOC_PRU_GNU_DIFF32_PMEM,


  BFD_RELOC_IQ2000_OFFSET_16,
  BFD_RELOC_IQ2000_OFFSET_21,
  BFD_RELOC_IQ2000_UHI16,




  BFD_RELOC_XTENSA_RTLD,


  BFD_RELOC_XTENSA_GLOB_DAT,
  BFD_RELOC_XTENSA_JMP_SLOT,
  BFD_RELOC_XTENSA_RELATIVE,



  BFD_RELOC_XTENSA_PLT,
# 6226 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  BFD_RELOC_XTENSA_DIFF8,
  BFD_RELOC_XTENSA_DIFF16,
  BFD_RELOC_XTENSA_DIFF32,





  BFD_RELOC_XTENSA_SLOT0_OP,
  BFD_RELOC_XTENSA_SLOT1_OP,
  BFD_RELOC_XTENSA_SLOT2_OP,
  BFD_RELOC_XTENSA_SLOT3_OP,
  BFD_RELOC_XTENSA_SLOT4_OP,
  BFD_RELOC_XTENSA_SLOT5_OP,
  BFD_RELOC_XTENSA_SLOT6_OP,
  BFD_RELOC_XTENSA_SLOT7_OP,
  BFD_RELOC_XTENSA_SLOT8_OP,
  BFD_RELOC_XTENSA_SLOT9_OP,
  BFD_RELOC_XTENSA_SLOT10_OP,
  BFD_RELOC_XTENSA_SLOT11_OP,
  BFD_RELOC_XTENSA_SLOT12_OP,
  BFD_RELOC_XTENSA_SLOT13_OP,
  BFD_RELOC_XTENSA_SLOT14_OP,



  BFD_RELOC_XTENSA_SLOT0_ALT,
  BFD_RELOC_XTENSA_SLOT1_ALT,
  BFD_RELOC_XTENSA_SLOT2_ALT,
  BFD_RELOC_XTENSA_SLOT3_ALT,
  BFD_RELOC_XTENSA_SLOT4_ALT,
  BFD_RELOC_XTENSA_SLOT5_ALT,
  BFD_RELOC_XTENSA_SLOT6_ALT,
  BFD_RELOC_XTENSA_SLOT7_ALT,
  BFD_RELOC_XTENSA_SLOT8_ALT,
  BFD_RELOC_XTENSA_SLOT9_ALT,
  BFD_RELOC_XTENSA_SLOT10_ALT,
  BFD_RELOC_XTENSA_SLOT11_ALT,
  BFD_RELOC_XTENSA_SLOT12_ALT,
  BFD_RELOC_XTENSA_SLOT13_ALT,
  BFD_RELOC_XTENSA_SLOT14_ALT,



  BFD_RELOC_XTENSA_OP0,
  BFD_RELOC_XTENSA_OP1,
  BFD_RELOC_XTENSA_OP2,




  BFD_RELOC_XTENSA_ASM_EXPAND,





  BFD_RELOC_XTENSA_ASM_SIMPLIFY,


  BFD_RELOC_XTENSA_TLSDESC_FN,
  BFD_RELOC_XTENSA_TLSDESC_ARG,
  BFD_RELOC_XTENSA_TLS_DTPOFF,
  BFD_RELOC_XTENSA_TLS_TPOFF,
  BFD_RELOC_XTENSA_TLS_FUNC,
  BFD_RELOC_XTENSA_TLS_ARG,
  BFD_RELOC_XTENSA_TLS_CALL,
# 6303 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  BFD_RELOC_XTENSA_PDIFF8,
  BFD_RELOC_XTENSA_PDIFF16,
  BFD_RELOC_XTENSA_PDIFF32,
  BFD_RELOC_XTENSA_NDIFF8,
  BFD_RELOC_XTENSA_NDIFF16,
  BFD_RELOC_XTENSA_NDIFF32,


  BFD_RELOC_Z80_DISP8,


  BFD_RELOC_Z80_BYTE0,


  BFD_RELOC_Z80_BYTE1,


  BFD_RELOC_Z80_BYTE2,


  BFD_RELOC_Z80_BYTE3,


  BFD_RELOC_Z80_WORD0,


  BFD_RELOC_Z80_WORD1,


  BFD_RELOC_Z80_16_BE,


  BFD_RELOC_Z8K_DISP7,


  BFD_RELOC_Z8K_CALLR,


  BFD_RELOC_Z8K_IMM4L,


  BFD_RELOC_LM32_CALL,
  BFD_RELOC_LM32_BRANCH,
  BFD_RELOC_LM32_16_GOT,
  BFD_RELOC_LM32_GOTOFF_HI16,
  BFD_RELOC_LM32_GOTOFF_LO16,
  BFD_RELOC_LM32_COPY,
  BFD_RELOC_LM32_GLOB_DAT,
  BFD_RELOC_LM32_JMP_SLOT,
  BFD_RELOC_LM32_RELATIVE,



  BFD_RELOC_MACH_O_SECTDIFF,


  BFD_RELOC_MACH_O_LOCAL_SECTDIFF,


  BFD_RELOC_MACH_O_PAIR,


  BFD_RELOC_MACH_O_SUBTRACTOR32,


  BFD_RELOC_MACH_O_SUBTRACTOR64,



  BFD_RELOC_MACH_O_X86_64_BRANCH32,
  BFD_RELOC_MACH_O_X86_64_BRANCH8,


  BFD_RELOC_MACH_O_X86_64_GOT,



  BFD_RELOC_MACH_O_X86_64_GOT_LOAD,


  BFD_RELOC_MACH_O_X86_64_PCREL32_1,


  BFD_RELOC_MACH_O_X86_64_PCREL32_2,


  BFD_RELOC_MACH_O_X86_64_PCREL32_4,


  BFD_RELOC_MACH_O_X86_64_TLV,


  BFD_RELOC_MACH_O_ARM64_ADDEND,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12,


  BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT,



  BFD_RELOC_MICROBLAZE_32_LO,



  BFD_RELOC_MICROBLAZE_32_LO_PCREL,



  BFD_RELOC_MICROBLAZE_32_ROSDA,



  BFD_RELOC_MICROBLAZE_32_RWSDA,



  BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM,




  BFD_RELOC_MICROBLAZE_64_NONE,




  BFD_RELOC_MICROBLAZE_64_GOTPC,




  BFD_RELOC_MICROBLAZE_64_GOT,




  BFD_RELOC_MICROBLAZE_64_PLT,




  BFD_RELOC_MICROBLAZE_64_GOTOFF,



  BFD_RELOC_MICROBLAZE_32_GOTOFF,



  BFD_RELOC_MICROBLAZE_COPY,


  BFD_RELOC_MICROBLAZE_64_TLS,




  BFD_RELOC_MICROBLAZE_64_TLSGD,




  BFD_RELOC_MICROBLAZE_64_TLSLD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPMOD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSTPREL,




  BFD_RELOC_MICROBLAZE_64_TEXTPCREL,




  BFD_RELOC_MICROBLAZE_64_TEXTREL,





  BFD_RELOC_AARCH64_RELOC_START,


  BFD_RELOC_AARCH64_NULL,


  BFD_RELOC_AARCH64_NONE,




  BFD_RELOC_AARCH64_64,
  BFD_RELOC_AARCH64_32,
  BFD_RELOC_AARCH64_16,



  BFD_RELOC_AARCH64_64_PCREL,
  BFD_RELOC_AARCH64_32_PCREL,
  BFD_RELOC_AARCH64_16_PCREL,



  BFD_RELOC_AARCH64_MOVW_G0,



  BFD_RELOC_AARCH64_MOVW_G0_NC,



  BFD_RELOC_AARCH64_MOVW_G1,



  BFD_RELOC_AARCH64_MOVW_G1_NC,



  BFD_RELOC_AARCH64_MOVW_G2,



  BFD_RELOC_AARCH64_MOVW_G2_NC,



  BFD_RELOC_AARCH64_MOVW_G3,




  BFD_RELOC_AARCH64_MOVW_G0_S,




  BFD_RELOC_AARCH64_MOVW_G1_S,




  BFD_RELOC_AARCH64_MOVW_G2_S,




  BFD_RELOC_AARCH64_MOVW_PREL_G0,




  BFD_RELOC_AARCH64_MOVW_PREL_G0_NC,



  BFD_RELOC_AARCH64_MOVW_PREL_G1,



  BFD_RELOC_AARCH64_MOVW_PREL_G1_NC,



  BFD_RELOC_AARCH64_MOVW_PREL_G2,



  BFD_RELOC_AARCH64_MOVW_PREL_G2_NC,



  BFD_RELOC_AARCH64_MOVW_PREL_G3,




  BFD_RELOC_AARCH64_LD_LO19_PCREL,


  BFD_RELOC_AARCH64_ADR_LO21_PCREL,



  BFD_RELOC_AARCH64_ADR_HI21_PCREL,




  BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL,



  BFD_RELOC_AARCH64_ADD_LO12,



  BFD_RELOC_AARCH64_LDST8_LO12,




  BFD_RELOC_AARCH64_TSTBR14,




  BFD_RELOC_AARCH64_BRANCH19,




  BFD_RELOC_AARCH64_JUMP26,




  BFD_RELOC_AARCH64_CALL26,



  BFD_RELOC_AARCH64_LDST16_LO12,



  BFD_RELOC_AARCH64_LDST32_LO12,



  BFD_RELOC_AARCH64_LDST64_LO12,



  BFD_RELOC_AARCH64_LDST128_LO12,






  BFD_RELOC_AARCH64_GOT_LD_PREL19,




  BFD_RELOC_AARCH64_ADR_GOT_PAGE,




  BFD_RELOC_AARCH64_LD64_GOT_LO12_NC,




  BFD_RELOC_AARCH64_LD32_GOT_LO12_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G1,



  BFD_RELOC_AARCH64_LD64_GOTOFF_LO15,


  BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14,


  BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15,





  BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSGD_ADR_PREL21,




  BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G1,


  BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21,


  BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC,




  BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSLD_ADR_PREL21,



  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_LD_PREL19,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSDESC_LD64_LO12,


  BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_ADD_LO12,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G1,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC,


  BFD_RELOC_AARCH64_TLSDESC_LDR,


  BFD_RELOC_AARCH64_TLSDESC_ADD,


  BFD_RELOC_AARCH64_TLSDESC_CALL,


  BFD_RELOC_AARCH64_COPY,


  BFD_RELOC_AARCH64_GLOB_DAT,


  BFD_RELOC_AARCH64_JUMP_SLOT,


  BFD_RELOC_AARCH64_RELATIVE,


  BFD_RELOC_AARCH64_TLS_DTPMOD,


  BFD_RELOC_AARCH64_TLS_DTPREL,


  BFD_RELOC_AARCH64_TLS_TPREL,


  BFD_RELOC_AARCH64_TLSDESC,


  BFD_RELOC_AARCH64_IRELATIVE,






  BFD_RELOC_AARCH64_RELOC_END,



  BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP,



  BFD_RELOC_AARCH64_LDST_LO12,




  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC,




  BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_LD_GOT_LO12_NC,



  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC,


  BFD_RELOC_TILEPRO_COPY,
  BFD_RELOC_TILEPRO_GLOB_DAT,
  BFD_RELOC_TILEPRO_JMP_SLOT,
  BFD_RELOC_TILEPRO_RELATIVE,
  BFD_RELOC_TILEPRO_BROFF_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT,
  BFD_RELOC_TILEPRO_IMM8_X0,
  BFD_RELOC_TILEPRO_IMM8_Y0,
  BFD_RELOC_TILEPRO_IMM8_X1,
  BFD_RELOC_TILEPRO_IMM8_Y1,
  BFD_RELOC_TILEPRO_DEST_IMM8_X1,
  BFD_RELOC_TILEPRO_MT_IMM15_X1,
  BFD_RELOC_TILEPRO_MF_IMM15_X1,
  BFD_RELOC_TILEPRO_IMM16_X0,
  BFD_RELOC_TILEPRO_IMM16_X1,
  BFD_RELOC_TILEPRO_IMM16_X0_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA,
  BFD_RELOC_TILEPRO_MMSTART_X0,
  BFD_RELOC_TILEPRO_MMEND_X0,
  BFD_RELOC_TILEPRO_MMSTART_X1,
  BFD_RELOC_TILEPRO_MMEND_X1,
  BFD_RELOC_TILEPRO_SHAMT_X0,
  BFD_RELOC_TILEPRO_SHAMT_X1,
  BFD_RELOC_TILEPRO_SHAMT_Y0,
  BFD_RELOC_TILEPRO_SHAMT_Y1,
  BFD_RELOC_TILEPRO_TLS_GD_CALL,
  BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_TLS_IE_LOAD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA,
  BFD_RELOC_TILEPRO_TLS_DTPMOD32,
  BFD_RELOC_TILEPRO_TLS_DTPOFF32,
  BFD_RELOC_TILEPRO_TLS_TPOFF32,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA,


  BFD_RELOC_TILEGX_HW0,
  BFD_RELOC_TILEGX_HW1,
  BFD_RELOC_TILEGX_HW2,
  BFD_RELOC_TILEGX_HW3,
  BFD_RELOC_TILEGX_HW0_LAST,
  BFD_RELOC_TILEGX_HW1_LAST,
  BFD_RELOC_TILEGX_HW2_LAST,
  BFD_RELOC_TILEGX_COPY,
  BFD_RELOC_TILEGX_GLOB_DAT,
  BFD_RELOC_TILEGX_JMP_SLOT,
  BFD_RELOC_TILEGX_RELATIVE,
  BFD_RELOC_TILEGX_BROFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1_PLT,
  BFD_RELOC_TILEGX_IMM8_X0,
  BFD_RELOC_TILEGX_IMM8_Y0,
  BFD_RELOC_TILEGX_IMM8_X1,
  BFD_RELOC_TILEGX_IMM8_Y1,
  BFD_RELOC_TILEGX_DEST_IMM8_X1,
  BFD_RELOC_TILEGX_MT_IMM14_X1,
  BFD_RELOC_TILEGX_MF_IMM14_X1,
  BFD_RELOC_TILEGX_MMSTART_X0,
  BFD_RELOC_TILEGX_MMEND_X0,
  BFD_RELOC_TILEGX_SHAMT_X0,
  BFD_RELOC_TILEGX_SHAMT_X1,
  BFD_RELOC_TILEGX_SHAMT_Y0,
  BFD_RELOC_TILEGX_SHAMT_Y1,
  BFD_RELOC_TILEGX_IMM16_X0_HW0,
  BFD_RELOC_TILEGX_IMM16_X1_HW0,
  BFD_RELOC_TILEGX_IMM16_X0_HW1,
  BFD_RELOC_TILEGX_IMM16_X1_HW1,
  BFD_RELOC_TILEGX_IMM16_X0_HW2,
  BFD_RELOC_TILEGX_IMM16_X1_HW2,
  BFD_RELOC_TILEGX_IMM16_X0_HW3,
  BFD_RELOC_TILEGX_IMM16_X1_HW3,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_TLS_DTPMOD64,
  BFD_RELOC_TILEGX_TLS_DTPOFF64,
  BFD_RELOC_TILEGX_TLS_TPOFF64,
  BFD_RELOC_TILEGX_TLS_DTPMOD32,
  BFD_RELOC_TILEGX_TLS_DTPOFF32,
  BFD_RELOC_TILEGX_TLS_TPOFF32,
  BFD_RELOC_TILEGX_TLS_GD_CALL,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_TLS_IE_LOAD,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD,


  BFD_RELOC_BPF_64,
  BFD_RELOC_BPF_DISP32,
  BFD_RELOC_BPF_DISPCALL32,
  BFD_RELOC_BPF_DISP16,


  BFD_RELOC_EPIPHANY_SIMM8,


  BFD_RELOC_EPIPHANY_SIMM24,


  BFD_RELOC_EPIPHANY_HIGH,


  BFD_RELOC_EPIPHANY_LOW,


  BFD_RELOC_EPIPHANY_SIMM11,


  BFD_RELOC_EPIPHANY_IMM11,


  BFD_RELOC_EPIPHANY_IMM8,


  BFD_RELOC_VISIUM_HI16,
  BFD_RELOC_VISIUM_LO16,
  BFD_RELOC_VISIUM_IM16,
  BFD_RELOC_VISIUM_REL16,
  BFD_RELOC_VISIUM_HI16_PCREL,
  BFD_RELOC_VISIUM_LO16_PCREL,
  BFD_RELOC_VISIUM_IM16_PCREL,


  BFD_RELOC_WASM32_LEB128,
  BFD_RELOC_WASM32_LEB128_GOT,
  BFD_RELOC_WASM32_LEB128_GOT_CODE,
  BFD_RELOC_WASM32_LEB128_PLT,
  BFD_RELOC_WASM32_PLT_INDEX,
  BFD_RELOC_WASM32_ABS32_CODE,
  BFD_RELOC_WASM32_COPY,
  BFD_RELOC_WASM32_CODE_POINTER,
  BFD_RELOC_WASM32_INDEX,
  BFD_RELOC_WASM32_PLT_SIG,


  BFD_RELOC_CKCORE_NONE,
  BFD_RELOC_CKCORE_ADDR32,
  BFD_RELOC_CKCORE_PCREL_IMM8BY4,
  BFD_RELOC_CKCORE_PCREL_IMM11BY2,
  BFD_RELOC_CKCORE_PCREL_IMM4BY2,
  BFD_RELOC_CKCORE_PCREL32,
  BFD_RELOC_CKCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_CKCORE_GNU_VTINHERIT,
  BFD_RELOC_CKCORE_GNU_VTENTRY,
  BFD_RELOC_CKCORE_RELATIVE,
  BFD_RELOC_CKCORE_COPY,
  BFD_RELOC_CKCORE_GLOB_DAT,
  BFD_RELOC_CKCORE_JUMP_SLOT,
  BFD_RELOC_CKCORE_GOTOFF,
  BFD_RELOC_CKCORE_GOTPC,
  BFD_RELOC_CKCORE_GOT32,
  BFD_RELOC_CKCORE_PLT32,
  BFD_RELOC_CKCORE_ADDRGOT,
  BFD_RELOC_CKCORE_ADDRPLT,
  BFD_RELOC_CKCORE_PCREL_IMM26BY2,
  BFD_RELOC_CKCORE_PCREL_IMM16BY2,
  BFD_RELOC_CKCORE_PCREL_IMM16BY4,
  BFD_RELOC_CKCORE_PCREL_IMM10BY2,
  BFD_RELOC_CKCORE_PCREL_IMM10BY4,
  BFD_RELOC_CKCORE_ADDR_HI16,
  BFD_RELOC_CKCORE_ADDR_LO16,
  BFD_RELOC_CKCORE_GOTPC_HI16,
  BFD_RELOC_CKCORE_GOTPC_LO16,
  BFD_RELOC_CKCORE_GOTOFF_HI16,
  BFD_RELOC_CKCORE_GOTOFF_LO16,
  BFD_RELOC_CKCORE_GOT12,
  BFD_RELOC_CKCORE_GOT_HI16,
  BFD_RELOC_CKCORE_GOT_LO16,
  BFD_RELOC_CKCORE_PLT12,
  BFD_RELOC_CKCORE_PLT_HI16,
  BFD_RELOC_CKCORE_PLT_LO16,
  BFD_RELOC_CKCORE_ADDRGOT_HI16,
  BFD_RELOC_CKCORE_ADDRGOT_LO16,
  BFD_RELOC_CKCORE_ADDRPLT_HI16,
  BFD_RELOC_CKCORE_ADDRPLT_LO16,
  BFD_RELOC_CKCORE_PCREL_JSR_IMM26BY2,
  BFD_RELOC_CKCORE_TOFFSET_LO16,
  BFD_RELOC_CKCORE_DOFFSET_LO16,
  BFD_RELOC_CKCORE_PCREL_IMM18BY2,
  BFD_RELOC_CKCORE_DOFFSET_IMM18,
  BFD_RELOC_CKCORE_DOFFSET_IMM18BY2,
  BFD_RELOC_CKCORE_DOFFSET_IMM18BY4,
  BFD_RELOC_CKCORE_GOTOFF_IMM18,
  BFD_RELOC_CKCORE_GOT_IMM18BY4,
  BFD_RELOC_CKCORE_PLT_IMM18BY4,
  BFD_RELOC_CKCORE_PCREL_IMM7BY4,
  BFD_RELOC_CKCORE_TLS_LE32,
  BFD_RELOC_CKCORE_TLS_IE32,
  BFD_RELOC_CKCORE_TLS_GD32,
  BFD_RELOC_CKCORE_TLS_LDM32,
  BFD_RELOC_CKCORE_TLS_LDO32,
  BFD_RELOC_CKCORE_TLS_DTPMOD32,
  BFD_RELOC_CKCORE_TLS_DTPOFF32,
  BFD_RELOC_CKCORE_TLS_TPOFF32,
  BFD_RELOC_CKCORE_PCREL_FLRW_IMM8BY4,
  BFD_RELOC_CKCORE_NOJSRI,
  BFD_RELOC_CKCORE_CALLGRAPH,
  BFD_RELOC_CKCORE_IRELATIVE,
  BFD_RELOC_CKCORE_PCREL_BLOOP_IMM4BY4,
  BFD_RELOC_CKCORE_PCREL_BLOOP_IMM12BY4,


  BFD_RELOC_S12Z_OPR,


  BFD_RELOC_LARCH_TLS_DTPMOD32,
  BFD_RELOC_LARCH_TLS_DTPREL32,
  BFD_RELOC_LARCH_TLS_DTPMOD64,
  BFD_RELOC_LARCH_TLS_DTPREL64,
  BFD_RELOC_LARCH_TLS_TPREL32,
  BFD_RELOC_LARCH_TLS_TPREL64,
  BFD_RELOC_LARCH_MARK_LA,
  BFD_RELOC_LARCH_MARK_PCREL,
  BFD_RELOC_LARCH_SOP_PUSH_PCREL,
  BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE,
  BFD_RELOC_LARCH_SOP_PUSH_DUP,
  BFD_RELOC_LARCH_SOP_PUSH_GPREL,
  BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL,
  BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT,
  BFD_RELOC_LARCH_SOP_PUSH_TLS_GD,
  BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL,
  BFD_RELOC_LARCH_SOP_ASSERT,
  BFD_RELOC_LARCH_SOP_NOT,
  BFD_RELOC_LARCH_SOP_SUB,
  BFD_RELOC_LARCH_SOP_SL,
  BFD_RELOC_LARCH_SOP_SR,
  BFD_RELOC_LARCH_SOP_ADD,
  BFD_RELOC_LARCH_SOP_AND,
  BFD_RELOC_LARCH_SOP_IF_ELSE,
  BFD_RELOC_LARCH_SOP_POP_32_S_10_5,
  BFD_RELOC_LARCH_SOP_POP_32_U_10_12,
  BFD_RELOC_LARCH_SOP_POP_32_S_10_12,
  BFD_RELOC_LARCH_SOP_POP_32_S_10_16,
  BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2,
  BFD_RELOC_LARCH_SOP_POP_32_S_5_20,
  BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2,
  BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2,
  BFD_RELOC_LARCH_SOP_POP_32_U,
  BFD_RELOC_LARCH_ADD8,
  BFD_RELOC_LARCH_ADD16,
  BFD_RELOC_LARCH_ADD24,
  BFD_RELOC_LARCH_ADD32,
  BFD_RELOC_LARCH_ADD64,
  BFD_RELOC_LARCH_SUB8,
  BFD_RELOC_LARCH_SUB16,
  BFD_RELOC_LARCH_SUB24,
  BFD_RELOC_LARCH_SUB32,
  BFD_RELOC_LARCH_SUB64,
  BFD_RELOC_LARCH_B16,
  BFD_RELOC_LARCH_B21,
  BFD_RELOC_LARCH_B26,
  BFD_RELOC_LARCH_ABS_HI20,
  BFD_RELOC_LARCH_ABS_LO12,
  BFD_RELOC_LARCH_ABS64_LO20,
  BFD_RELOC_LARCH_ABS64_HI12,
  BFD_RELOC_LARCH_PCALA_HI20,
  BFD_RELOC_LARCH_PCALA_LO12,
  BFD_RELOC_LARCH_PCALA64_LO20,
  BFD_RELOC_LARCH_PCALA64_HI12,
  BFD_RELOC_LARCH_GOT_PC_HI20,
  BFD_RELOC_LARCH_GOT_PC_LO12,
  BFD_RELOC_LARCH_GOT64_PC_LO20,
  BFD_RELOC_LARCH_GOT64_PC_HI12,
  BFD_RELOC_LARCH_GOT_HI20,
  BFD_RELOC_LARCH_GOT_LO12,
  BFD_RELOC_LARCH_GOT64_LO20,
  BFD_RELOC_LARCH_GOT64_HI12,
  BFD_RELOC_LARCH_TLS_LE_HI20,
  BFD_RELOC_LARCH_TLS_LE_LO12,
  BFD_RELOC_LARCH_TLS_LE64_LO20,
  BFD_RELOC_LARCH_TLS_LE64_HI12,
  BFD_RELOC_LARCH_TLS_IE_PC_HI20,
  BFD_RELOC_LARCH_TLS_IE_PC_LO12,
  BFD_RELOC_LARCH_TLS_IE64_PC_LO20,
  BFD_RELOC_LARCH_TLS_IE64_PC_HI12,
  BFD_RELOC_LARCH_TLS_IE_HI20,
  BFD_RELOC_LARCH_TLS_IE_LO12,
  BFD_RELOC_LARCH_TLS_IE64_LO20,
  BFD_RELOC_LARCH_TLS_IE64_HI12,
  BFD_RELOC_LARCH_TLS_LD_PC_HI20,
  BFD_RELOC_LARCH_TLS_LD_HI20,
  BFD_RELOC_LARCH_TLS_GD_PC_HI20,
  BFD_RELOC_LARCH_TLS_GD_HI20,
  BFD_RELOC_LARCH_32_PCREL,
  BFD_RELOC_LARCH_RELAX,
  BFD_RELOC_LARCH_DELETE,
  BFD_RELOC_LARCH_ALIGN,
  BFD_RELOC_LARCH_PCREL20_S2,
  BFD_RELOC_LARCH_CFA,
  BFD_RELOC_LARCH_ADD6,
  BFD_RELOC_LARCH_SUB6,
  BFD_RELOC_LARCH_ADD_ULEB128,
  BFD_RELOC_LARCH_SUB_ULEB128,
  BFD_RELOC_LARCH_64_PCREL,
  BFD_RELOC_UNUSED };
typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;

reloc_howto_type *bfd_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code);
reloc_howto_type *bfd_reloc_name_lookup
   (bfd *abfd, const char *reloc_name);

const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);


bfd_byte *bfd_simple_get_relocated_section_contents
   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);


const char *bfd_get_stab_name (int);





struct stab_info
{

  struct bfd_strtab_hash *strings;

  struct bfd_hash_table includes;

  struct bfd_section *stabstr;
};
# 7414 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
enum bfd_flavour
{

  bfd_target_unknown_flavour,
  bfd_target_aout_flavour,
  bfd_target_coff_flavour,
  bfd_target_ecoff_flavour,
  bfd_target_xcoff_flavour,
  bfd_target_elf_flavour,
  bfd_target_tekhex_flavour,
  bfd_target_srec_flavour,
  bfd_target_verilog_flavour,
  bfd_target_ihex_flavour,
  bfd_target_som_flavour,
  bfd_target_msdos_flavour,
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
};

enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };


struct flag_info;
typedef void (*bfd_cleanup) (bfd *);

typedef struct bfd_target
{

  const char *name;



  enum bfd_flavour flavour;


  enum bfd_endian byteorder;


  enum bfd_endian header_byteorder;



  flagword object_flags;



  flagword section_flags;



  char symbol_leading_char;


  char ar_pad_char;


  unsigned char ar_max_namelen;



  unsigned char match_priority;


  
# 7481 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7481 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      keep_unused_section_symbols;




  uint64_t (*bfd_getx64) (const void *);
  int64_t (*bfd_getx_signed_64) (const void *);
  void (*bfd_putx64) (uint64_t, void *);
  bfd_vma (*bfd_getx32) (const void *);
  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
  void (*bfd_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_getx16) (const void *);
  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
  void (*bfd_putx16) (bfd_vma, void *);


  uint64_t (*bfd_h_getx64) (const void *);
  int64_t (*bfd_h_getx_signed_64) (const void *);
  void (*bfd_h_putx64) (uint64_t, void *);
  bfd_vma (*bfd_h_getx32) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
  void (*bfd_h_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_h_getx16) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
  void (*bfd_h_putx16) (bfd_vma, void *);






  bfd_cleanup (*_bfd_check_format[bfd_type_end]) (bfd *);


  
# 7515 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7515 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_set_format[bfd_type_end]) (bfd *);


  
# 7518 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7518 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_write_contents[bfd_type_end]) (bfd *);
# 7529 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  
# 7529 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7529 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_close_and_cleanup) (bfd *);

  
# 7531 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7531 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_free_cached_info) (bfd *);

  
# 7533 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7533 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_new_section_hook) (bfd *, sec_ptr);

  
# 7535 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7535 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_get_section_contents) (bfd *, sec_ptr, void *, file_ptr,
         bfd_size_type);
  
# 7537 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7537 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_get_section_contents_in_window) (bfd *, sec_ptr, bfd_window *,
            file_ptr, bfd_size_type);
# 7553 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  
# 7553 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7553 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_copy_private_bfd_data) (bfd *, bfd *);


  
# 7556 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7556 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_merge_private_bfd_data) (bfd *, struct bfd_link_info *);





  
# 7562 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7562 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_init_private_section_data) (bfd *, sec_ptr, bfd *, sec_ptr,
       struct bfd_link_info *);


  
# 7566 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7566 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_copy_private_section_data) (bfd *, sec_ptr, bfd *, sec_ptr);


  
# 7569 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7569 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_copy_private_symbol_data) (bfd *, asymbol *,
      bfd *, asymbol *);


  
# 7573 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7573 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_copy_private_header_data) (bfd *, bfd *);

  
# 7575 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7575 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_set_private_flags) (bfd *, flagword);


  
# 7578 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7578 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_print_private_bfd_data) (bfd *, void *);
# 7587 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  char *(*_core_file_failing_command) (bfd *);
  int (*_core_file_failing_signal) (bfd *);
  
# 7589 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7589 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
       (*_core_file_matches_executable_p) (bfd *, bfd *);
  int (*_core_file_pid) (bfd *);
# 7606 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  
# 7606 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7606 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_slurp_armap) (bfd *);
  
# 7607 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7607 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_slurp_extended_name_table) (bfd *);
  
# 7608 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7608 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_construct_extended_name_table) (bfd *, char **,
           bfd_size_type *,
           const char **);
  void (*_bfd_truncate_arname) (bfd *, const char *, char *);
  
# 7612 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7612 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*write_armap) (bfd *, unsigned, struct orl *, unsigned, int);
  void *(*_bfd_read_ar_hdr_fn) (bfd *);
  
# 7614 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7614 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);
  bfd *(*openr_next_archived_file) (bfd *, bfd *);


  bfd *(*_bfd_get_elt_at_index) (bfd *, symindex);
  int (*_bfd_stat_arch_elt) (bfd *, struct stat *);
  
# 7620 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7620 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_update_armap_timestamp) (bfd *);
# 7641 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  long (*_bfd_get_symtab_upper_bound) (bfd *);
  long (*_bfd_canonicalize_symtab) (bfd *, struct bfd_symbol **);
  struct bfd_symbol *
       (*_bfd_make_empty_symbol) (bfd *);
  void (*_bfd_print_symbol) (bfd *, void *, struct bfd_symbol *,
        bfd_print_symbol_type);


  void (*_bfd_get_symbol_info) (bfd *, struct bfd_symbol *, symbol_info *);


  const char *
       (*_bfd_get_symbol_version_string) (bfd *, struct bfd_symbol *,
       
# 7654 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
      _Bool
# 7654 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
          , 
# 7654 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
            _Bool 
# 7654 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                 *);


  
# 7657 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7657 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_is_local_label_name) (bfd *, const char *);
  
# 7658 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7658 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
  alent *
       (*_get_lineno) (bfd *, struct bfd_symbol *);
  
# 7661 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7661 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_find_nearest_line) (bfd *, struct bfd_symbol **,
      struct bfd_section *, bfd_vma,
      const char **, const char **,
      unsigned int *, unsigned int *);
  
# 7665 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7665 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_find_nearest_line_with_alt) (bfd *, const char *,
        struct bfd_symbol **,
        struct bfd_section *, bfd_vma,
        const char **, const char **,
        unsigned int *, unsigned int *);
  
# 7670 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7670 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_find_line) (bfd *, struct bfd_symbol **,
     struct bfd_symbol *, const char **,
     unsigned int *);
  
# 7673 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7673 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_find_inliner_info)
    (bfd *, const char **, const char **, unsigned int *);



  asymbol *
       (*_bfd_make_debug_symbol) (bfd *);


  long (*_read_minisymbols) (bfd *, 
# 7682 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                   _Bool
# 7682 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                       , void **, unsigned int *);


  asymbol *
       (*_minisymbol_to_symbol) (bfd *, 
# 7686 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                       _Bool
# 7686 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                           , const void *, asymbol *);
# 7696 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  long (*_get_reloc_upper_bound) (bfd *, sec_ptr);
  long (*_bfd_canonicalize_reloc) (bfd *, sec_ptr, arelent **,
       struct bfd_symbol **);
  void (*_bfd_set_reloc) (bfd *, sec_ptr, arelent **, unsigned int);

  reloc_howto_type *
       (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
  reloc_howto_type *
       (*reloc_name_lookup) (bfd *, const char *);






  
# 7711 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7711 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_set_arch_mach) (bfd *, enum bfd_architecture,
         unsigned long);
  
# 7713 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7713 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_set_section_contents) (bfd *, sec_ptr, const void *,
         file_ptr, bfd_size_type);
# 7739 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  int (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
  bfd_byte *
       (*_bfd_get_relocated_section_contents) (bfd *,
            struct bfd_link_info *,
            struct bfd_link_order *,
            bfd_byte *, 
# 7744 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                       _Bool
# 7744 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                           ,
            struct bfd_symbol **);

  
# 7747 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7747 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_relax_section) (bfd *, struct bfd_section *,
         struct bfd_link_info *, 
# 7748 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
                                _Bool 
# 7748 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
                                     *);



  struct bfd_link_hash_table *
       (*_bfd_link_hash_table_create) (bfd *);


  
# 7756 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7756 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);


  void (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);





  void (*_bfd_copy_link_hash_symbol_type) (bfd *,
        struct bfd_link_hash_entry *,
        struct bfd_link_hash_entry *);



  
# 7771 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7771 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_final_link) (bfd *, struct bfd_link_info *);


  
# 7774 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7774 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_link_split_section) (bfd *, struct bfd_section *);


  
# 7777 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7777 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (* _bfd_link_check_relocs)(bfd *, struct bfd_link_info *);


  
# 7780 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7780 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);


  
# 7783 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7783 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_lookup_section_flags) (struct bfd_link_info *,
         struct flag_info *, asection *);


  
# 7787 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7787 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);


  
# 7790 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7790 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_is_group_section) (bfd *, const struct bfd_section *);


  const char *(*_bfd_group_name) (bfd *, const struct bfd_section *);


  
# 7796 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7796 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_discard_group) (bfd *, struct bfd_section *);



  
# 7800 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7800 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_section_already_linked) (bfd *, asection *,
       struct bfd_link_info *);


  
# 7804 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
 _Bool 
# 7804 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
      (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,
         struct bfd_link_hash_entry *);


  void (*_bfd_link_hide_symbol) (bfd *, struct bfd_link_info *,
     struct bfd_link_hash_entry *);


  struct bfd_link_hash_entry *
       (*_bfd_define_start_stop) (struct bfd_link_info *, const char *,
      asection *);
# 7825 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
  long (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_symtab) (bfd *, struct bfd_symbol **);

  long (*_bfd_get_synthetic_symtab) (bfd *, long, struct bfd_symbol **,
         long, struct bfd_symbol **,
         struct bfd_symbol **);

  long (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_reloc) (bfd *, arelent **,
        struct bfd_symbol **);


  const struct bfd_target *alternative_target;



  const void *backend_data;

} bfd_target;

static inline const char *
bfd_get_target (const bfd *abfd)
{
  return abfd->xvec->name;
}

static inline enum bfd_flavour
bfd_get_flavour (const bfd *abfd)
{
  return abfd->xvec->flavour;
}

static inline flagword
bfd_applicable_file_flags (const bfd *abfd)
{
  return abfd->xvec->object_flags;
}

static inline 
# 7865 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 7866 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_family_coff (const bfd *abfd)
{
  return (bfd_get_flavour (abfd) == bfd_target_coff_flavour
   || bfd_get_flavour (abfd) == bfd_target_xcoff_flavour);
}

static inline 
# 7872 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 7873 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_big_endian (const bfd *abfd)
{
  return abfd->xvec->byteorder == BFD_ENDIAN_BIG;
}
static inline 
# 7877 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 7878 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_little_endian (const bfd *abfd)
{
  return abfd->xvec->byteorder == BFD_ENDIAN_LITTLE;
}

static inline 
# 7883 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 7884 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_header_big_endian (const bfd *abfd)
{
  return abfd->xvec->header_byteorder == BFD_ENDIAN_BIG;
}

static inline 
# 7889 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 7890 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_header_little_endian (const bfd *abfd)
{
  return abfd->xvec->header_byteorder == BFD_ENDIAN_LITTLE;
}

static inline flagword
bfd_applicable_section_flags (const bfd *abfd)
{
  return abfd->xvec->section_flags;
}

static inline char
bfd_get_symbol_leading_char (const bfd *abfd)
{
  return abfd->xvec->symbol_leading_char;
}

static inline enum bfd_flavour
bfd_asymbol_flavour (const asymbol *sy)
{
  if ((sy->flags & (1 << 21)) != 0)
    return bfd_target_unknown_flavour;
  return sy->the_bfd->xvec->flavour;
}

static inline 
# 7915 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
             _Bool

# 7916 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
bfd_keep_unused_section_symbols (const bfd *abfd)
{
  return abfd->xvec->keep_unused_section_symbols;
}


# 7921 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
_Bool 
# 7921 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
    bfd_set_default_target (const char *name);

const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);

const bfd_target *bfd_get_target_info (const char *target_name,
    bfd *abfd,
    
# 7927 "/doner/binutils/binutils-515f23e/bfd/bfd.h" 3 4
   _Bool 
# 7927 "/doner/binutils/binutils-515f23e/bfd/bfd.h"
        *is_bigendian,
    int *underscoring,
    const char **def_target_arch);

const char ** bfd_target_list (void);

const bfd_target *bfd_iterate_over_targets
   (int (*func) (const bfd_target *, void *),
    void *data);

const char *bfd_flavour_name (enum bfd_flavour flavour);
# 23 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2
# 1 "./../include/bfdlink.h" 1
# 26 "./../include/bfdlink.h"
enum bfd_link_strip
{
  strip_none,
  strip_debugger,
  strip_some,
  strip_all
};



enum bfd_link_discard
{
  discard_sec_merge,

  discard_none,
  discard_l,
  discard_all
};

enum notice_asneeded_action {
  notice_as_needed,
  notice_not_needed,
  notice_needed
};



enum bfd_link_elf_stt_common
{
  unchanged,
  elf_stt_common,
  no_elf_stt_common
};




enum bfd_link_hash_table_type
  {
    bfd_link_generic_hash_table,
    bfd_link_elf_hash_table
  };




enum bfd_link_hash_type
{
  bfd_link_hash_new,
  bfd_link_hash_undefined,
  bfd_link_hash_undefweak,
  bfd_link_hash_defined,
  bfd_link_hash_defweak,
  bfd_link_hash_common,
  bfd_link_hash_indirect,
  bfd_link_hash_warning
};

enum bfd_link_common_skip_ar_symbols
{
  bfd_link_common_skip_none,
  bfd_link_common_skip_text,
  bfd_link_common_skip_data,
  bfd_link_common_skip_all
};

struct bfd_link_hash_common_entry
  {
    unsigned int alignment_power;
    asection *section;
  };




struct bfd_link_hash_entry
{

  struct bfd_hash_entry root;


  __extension__ enum bfd_link_hash_type type : 8;



  unsigned int non_ir_ref_regular : 1;



  unsigned int non_ir_ref_dynamic : 1;


  unsigned int ref_real : 1;



  unsigned int linker_def : 1;


  unsigned int ldscript_def : 1;




  unsigned int rel_from_abs : 1;


  union
    {


      struct
 {
# 158 "./../include/bfdlink.h"
   struct bfd_link_hash_entry *next;

   bfd *abfd;
 } undef;

      struct
 {
   struct bfd_link_hash_entry *next;

   asection *section;

   bfd_vma value;
 } def;

      struct
 {
   struct bfd_link_hash_entry *next;

   struct bfd_link_hash_entry *link;

   const char *warning;
 } i;

      struct
 {
   struct bfd_link_hash_entry *next;
# 193 "./../include/bfdlink.h"
   struct bfd_link_hash_common_entry *p;

   bfd_size_type size;
 } c;
    } u;
};




struct bfd_link_hash_table
{

  struct bfd_hash_table table;


  struct bfd_link_hash_entry *undefs;

  struct bfd_link_hash_entry *undefs_tail;

  void (*hash_table_free) (bfd *);

  enum bfd_link_hash_table_type type;
};




extern struct bfd_link_hash_entry *bfd_link_hash_lookup
  (struct bfd_link_hash_table *, const char *, 
# 222 "./../include/bfdlink.h" 3 4
                                              _Bool 
# 222 "./../include/bfdlink.h"
                                                   create,
   
# 223 "./../include/bfdlink.h" 3 4
  _Bool 
# 223 "./../include/bfdlink.h"
       copy, 
# 223 "./../include/bfdlink.h" 3 4
             _Bool 
# 223 "./../include/bfdlink.h"
                  follow);





extern struct bfd_link_hash_entry *bfd_wrapped_link_hash_lookup
  (bfd *, struct bfd_link_info *, const char *, 
# 230 "./../include/bfdlink.h" 3 4
                                               _Bool
# 230 "./../include/bfdlink.h"
                                                   , 
# 230 "./../include/bfdlink.h" 3 4
                                                     _Bool
# 230 "./../include/bfdlink.h"
                                                         , 
# 230 "./../include/bfdlink.h" 3 4
                                                           _Bool
# 230 "./../include/bfdlink.h"
                                                               );




extern struct bfd_link_hash_entry *unwrap_hash_lookup
  (struct bfd_link_info *, bfd *, struct bfd_link_hash_entry *);


extern void bfd_link_hash_traverse
  (struct bfd_link_hash_table *,
    
# 241 "./../include/bfdlink.h" 3 4
   _Bool 
# 241 "./../include/bfdlink.h"
        (*) (struct bfd_link_hash_entry *, void *),
    void *);


extern void bfd_link_add_undef
  (struct bfd_link_hash_table *, struct bfd_link_hash_entry *);


extern void bfd_link_repair_undef_list
  (struct bfd_link_hash_table *table);


extern 
# 253 "./../include/bfdlink.h" 3 4
      _Bool 
# 253 "./../include/bfdlink.h"
           bfd_generic_link_read_symbols (bfd *);




extern 
# 258 "./../include/bfdlink.h" 3 4
      _Bool 
# 258 "./../include/bfdlink.h"
           bfd_link_check_relocs (bfd *,struct bfd_link_info *);

struct bfd_sym_chain
{
  struct bfd_sym_chain *next;
  const char *name;
};



enum report_method
{



  RM_NOT_YET_SET = 0,
  RM_IGNORE,
  RM_DIAGNOSE,
};



enum textrel_check_method
{
  textrel_check_none,
  textrel_check_warning,
  textrel_check_error
};




typedef enum {with_flags, without_flags} flag_type;


struct flag_info_list
{
  flag_type with;
  const char *name;
  
# 297 "./../include/bfdlink.h" 3 4
 _Bool 
# 297 "./../include/bfdlink.h"
      valid;
  struct flag_info_list *next;
};


struct flag_info
{
  flagword only_with_flags;
  flagword not_with_flags;
  struct flag_info_list *flag_list;
  
# 307 "./../include/bfdlink.h" 3 4
 _Bool 
# 307 "./../include/bfdlink.h"
      flags_initialized;
};

struct bfd_elf_dynamic_list;
struct bfd_elf_version_tree;



enum output_type
{
  type_pde,
  type_pie,
  type_relocatable,
  type_dll,
};
# 333 "./../include/bfdlink.h"
struct bfd_link_info
{

  __extension__ enum output_type type : 2;


  unsigned int symbolic: 1;



  unsigned int export_dynamic: 1;



  unsigned int create_default_symver: 1;


  unsigned int gc_sections: 1;


  unsigned int gc_keep_exported: 1;



  unsigned int notice_all: 1;


  unsigned int lto_plugin_active: 1;


  unsigned int lto_all_symbols_read : 1;


  unsigned int strip_discarded: 1;


  unsigned int dynamic_data: 1;


  unsigned int resolve_section_groups: 1;



  unsigned int big_endian : 1;


  __extension__ enum bfd_link_strip strip : 2;


  __extension__ enum bfd_link_discard discard : 2;


  __extension__ enum bfd_link_elf_stt_common elf_stt_common : 2;



  __extension__ enum bfd_link_common_skip_ar_symbols common_skip_ar_symbols : 2;






  __extension__ enum report_method unresolved_syms_in_objects : 2;



  __extension__ enum report_method unresolved_syms_in_shared_libs : 2;


  unsigned int warn_unresolved_syms: 1;


  unsigned int static_link: 1;



  unsigned int keep_memory: 1;



  unsigned int emitrelocations: 1;


  unsigned int relro: 1;



  unsigned int enable_dt_relr: 1;


  unsigned int separate_code: 1;



  unsigned int eh_frame_hdr_type: 2;


  __extension__ enum textrel_check_method textrel_check: 2;


  unsigned int emit_hash: 1;


  unsigned int emit_gnu_hash: 1;




  unsigned int reduce_memory_overheads: 1;





  unsigned int traditional_format: 1;



  unsigned int combreloc: 1;



  unsigned int default_imported_symver: 1;


  unsigned int new_dtags: 1;



  unsigned int no_ld_generated_unwind_info: 1;




  unsigned int task_link: 1;


  unsigned int allow_multiple_definition: 1;



  unsigned int prohibit_multiple_definition_absolute: 1;


  unsigned int warn_multiple_definition: 1;


  unsigned int allow_undefined_version: 1;



  unsigned int dynamic: 1;



  unsigned int execstack: 1;



  unsigned int noexecstack: 1;





  unsigned int warn_execstack: 2;



  unsigned int no_warn_rwx_segments: 1;


  unsigned int user_warn_rwx_segments: 1;





  unsigned int default_execstack : 1;



  unsigned int optimize: 1;


  unsigned int print_gc_sections: 1;


  unsigned int warn_alternate_em: 1;


  unsigned int user_phdrs: 1;


  unsigned int load_phdrs: 1;



  unsigned int check_relocs_after_open_input: 1;


  unsigned int nointerp: 1;


  unsigned int inhibit_common_definition : 1;


  unsigned int has_map_file : 1;



  unsigned int non_contiguous_regions : 1;



  unsigned int non_contiguous_regions_warnings : 1;


  unsigned int unique_symbol : 1;


  unsigned int maxpagesize_is_set : 1;


  unsigned int commonpagesize_is_set : 1;




  char wrap_char;


  char path_separator;



  bfd_signed_vma stacksize;
# 588 "./../include/bfdlink.h"
  signed int disable_target_specific_optimizations;


  const struct bfd_link_callbacks *callbacks;


  struct bfd_link_hash_table *hash;



  struct bfd_hash_table *keep_hash;




  struct bfd_hash_table *notice_hash;



  struct bfd_hash_table *wrap_hash;



  struct bfd_hash_table *ignore_hash;


  bfd *output_bfd;


  bfd *out_implib_bfd;



  bfd *input_bfds;
  bfd **input_bfds_tail;






  asection *create_object_symbols_section;



  struct bfd_sym_chain *gc_sym_list;


  void *base_file;



  const char *init_function;



  const char *fini_function;





  int relax_pass;




  int relax_trip;




  int extern_protected_data;




  int dynamic_undefined_weak;




  int pei386_auto_import;




  int pei386_runtime_pseudo_reloc;


  unsigned int spare_dynamic_tags;







  int indirect_extern_access;







  int nocopyreloc;


  bfd_byte *needed_1_p;


  bfd_vma flags;


  bfd_vma flags_1;


  bfd_vma gnu_flags_1;



  int start_stop_gc;


  unsigned int start_stop_visibility;


  bfd_vma maxpagesize;


  bfd_vma commonpagesize;


  bfd_vma relro_start, relro_end;


  struct bfd_elf_dynamic_list *dynamic_list;


  struct bfd_elf_version_tree *version_info;


  bfd_size_type cache_size;



  bfd_size_type max_cache_size;
};



struct elf_strtab_hash;
struct elf_internal_sym;




struct bfd_link_callbacks
{







  
# 755 "./../include/bfdlink.h" 3 4
 _Bool 
# 755 "./../include/bfdlink.h"
      (*add_archive_element)
    (struct bfd_link_info *, bfd *abfd, const char *name, bfd **subsbfd);




  void (*multiple_definition)
    (struct bfd_link_info *, struct bfd_link_hash_entry *h,
     bfd *nbfd, asection *nsec, bfd_vma nval);






  void (*multiple_common)
    (struct bfd_link_info *, struct bfd_link_hash_entry *h,
     bfd *nbfd, enum bfd_link_hash_type ntype, bfd_vma nsize);






  void (*add_to_set)
    (struct bfd_link_info *, struct bfd_link_hash_entry *entry,
     bfd_reloc_code_real_type reloc, bfd *abfd, asection *sec, bfd_vma value);






  void (*constructor)
    (struct bfd_link_info *, 
# 789 "./../include/bfdlink.h" 3 4
                            _Bool 
# 789 "./../include/bfdlink.h"
                                 constructor, const char *name,
     bfd *abfd, asection *sec, bfd_vma value);







  void (*warning)
    (struct bfd_link_info *, const char *warning, const char *symbol,
     bfd *abfd, asection *section, bfd_vma address);





  void (*undefined_symbol)
    (struct bfd_link_info *, const char *name, bfd *abfd,
     asection *section, bfd_vma address, 
# 808 "./../include/bfdlink.h" 3 4
                                        _Bool 
# 808 "./../include/bfdlink.h"
                                             is_fatal);
# 817 "./../include/bfdlink.h"
  void (*reloc_overflow)
    (struct bfd_link_info *, struct bfd_link_hash_entry *entry,
     const char *name, const char *reloc_name, bfd_vma addend,
     bfd *abfd, asection *section, bfd_vma address);






  void (*reloc_dangerous)
    (struct bfd_link_info *, const char *message,
     bfd *abfd, asection *section, bfd_vma address);






  void (*unattached_reloc)
    (struct bfd_link_info *, const char *name,
     bfd *abfd, asection *section, bfd_vma address);





  
# 844 "./../include/bfdlink.h" 3 4
 _Bool 
# 844 "./../include/bfdlink.h"
      (*notice)
    (struct bfd_link_info *, struct bfd_link_hash_entry *h,
     struct bfd_link_hash_entry *inh,
     bfd *abfd, asection *section, bfd_vma address, flagword flags);

  void (*einfo)
    (const char *fmt, ...);

  void (*info)
    (const char *fmt, ...);

  void (*minfo)
    (const char *fmt, ...);



  
# 860 "./../include/bfdlink.h" 3 4
 _Bool 
# 860 "./../include/bfdlink.h"
      (*override_segment_assignment)
    (struct bfd_link_info *, bfd * abfd,
     asection * current_section, asection * previous_section,
     
# 863 "./../include/bfdlink.h" 3 4
    _Bool 
# 863 "./../include/bfdlink.h"
         new_segment);


  void (*examine_strtab)
    (struct elf_strtab_hash *symstrtab);



  void (*ctf_new_symbol)
    (int symidx, struct elf_internal_sym *sym);

  void (*ctf_new_dynsym)
    (int symidx, struct elf_internal_sym *sym);


  void (*emit_ctf)
    (void);
};






enum bfd_link_order_type
{
  bfd_undefined_link_order,
  bfd_indirect_link_order,
  bfd_data_link_order,
  bfd_section_reloc_link_order,
  bfd_symbol_reloc_link_order
};




struct bfd_link_order
{

  struct bfd_link_order *next;

  enum bfd_link_order_type type;

  bfd_vma offset;

  bfd_size_type size;

  union
    {
      struct
 {






   asection *section;
 } indirect;
      struct
 {




   unsigned int size;

   bfd_byte *contents;
 } data;
      struct
 {



   struct bfd_link_order_reloc *p;
 } reloc;
    } u;
};
# 954 "./../include/bfdlink.h"
struct bfd_link_order_reloc
{

  bfd_reloc_code_real_type reloc;

  union
    {



      asection *section;


      const char *name;
    } u;






  bfd_vma addend;
};


extern struct bfd_link_order *bfd_new_link_order (bfd *, asection *);

struct bfd_section_already_linked;

extern 
# 983 "./../include/bfdlink.h" 3 4
      _Bool 
# 983 "./../include/bfdlink.h"
           bfd_section_already_linked_table_init (void);
extern void bfd_section_already_linked_table_free (void);
extern 
# 985 "./../include/bfdlink.h" 3 4
      _Bool 
# 985 "./../include/bfdlink.h"
           _bfd_handle_already_linked
  (struct bfd_section *, struct bfd_section_already_linked *,
   struct bfd_link_info *);

extern struct bfd_section *_bfd_nearby_section
  (bfd *, struct bfd_section *, bfd_vma);

extern void _bfd_fix_excluded_sec_syms
  (bfd *, struct bfd_link_info *);
# 1002 "./../include/bfdlink.h"
struct bfd_elf_version_expr
{

  struct bfd_elf_version_expr *next;

  const char *pattern;

  unsigned int literal : 1;

  unsigned int symver : 1;

  unsigned int script : 1;




  unsigned int mask : 3;
};

struct bfd_elf_version_expr_head
{

  struct bfd_elf_version_expr *list;

  void *htab;

  struct bfd_elf_version_expr *remaining;

  unsigned int mask;
};



struct bfd_elf_version_deps
{

  struct bfd_elf_version_deps *next;

  struct bfd_elf_version_tree *version_needed;
};



struct bfd_elf_version_tree
{

  struct bfd_elf_version_tree *next;

  const char *name;

  unsigned int vernum;

  struct bfd_elf_version_expr_head globals;

  struct bfd_elf_version_expr_head locals;

  struct bfd_elf_version_deps *deps;

  unsigned int name_indx;

  int used;

  struct bfd_elf_version_expr *(*match)
    (struct bfd_elf_version_expr_head *head,
     struct bfd_elf_version_expr *prev, const char *sym);
};

struct bfd_elf_dynamic_list
{
  struct bfd_elf_version_expr_head head;
  struct bfd_elf_version_expr *(*match)
    (struct bfd_elf_version_expr_head *head,
     struct bfd_elf_version_expr *prev, const char *sym);
};
# 24 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2
# 1 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 1
# 42 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
# 1 "./../include/hashtab.h" 1
# 43 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 2
# 59 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
struct bfd_in_memory
{

  bfd_size_type size;

  bfd_byte *buffer;
};

struct section_hash_entry
{
  struct bfd_hash_entry root;
  asection section;
};


extern unsigned int _bfd_section_id __attribute__ ((__visibility__ ("hidden")));




struct artdata
{
  ufile_ptr first_file_filepos;

  htab_t cache;
  carsym *symdefs;
  symindex symdef_count;
  char *extended_names;
  bfd_size_type extended_names_size;

  long armap_timestamp;





  file_ptr armap_datepos;

  void *tdata;
};




struct areltdata
{
  char * arch_header;
  bfd_size_type parsed_size;
  bfd_size_type extra_size;
  char *filename;
  file_ptr origin;
  void *parent_cache;
  file_ptr key;
};



extern void *bfd_malloc
  (bfd_size_type) __attribute__ ((__visibility__ ("hidden")));

static inline char *
bfd_strdup (const char *str)
{
  size_t len = strlen (str) + 1;
  char *buf = bfd_malloc (len);
  if (buf != 
# 124 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
            ((void *)0)
# 124 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                )
    memcpy (buf, str, len);
  return buf;
}

extern bfd * _bfd_create_empty_archive_element_shell
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern bfd * _bfd_look_for_bfd_in_cache
  (bfd *, file_ptr) __attribute__ ((__visibility__ ("hidden")));
extern 
# 133 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 133 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_add_bfd_to_archive_cache
  (bfd *, file_ptr, bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 135 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 135 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_mkarchive
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern char *_bfd_append_relative_path
  (bfd *, char *) __attribute__ ((__visibility__ ("hidden")));
extern bfd_cleanup bfd_generic_archive_p
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 141 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 141 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           bfd_slurp_armap
  (bfd *) __attribute__ ((__visibility__ ("hidden")));


extern 
# 145 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 145 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_archive_64_bit_slurp_armap
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 147 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 147 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_archive_64_bit_write_armap
  (bfd *, unsigned int, struct orl *, unsigned int, int) __attribute__ ((__visibility__ ("hidden")));
# 167 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern 
# 167 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 167 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_slurp_extended_name_table
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 169 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 169 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_construct_extended_name_table
  (bfd *, 
# 170 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
         _Bool
# 170 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
             , char **, bfd_size_type *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 171 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 171 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_write_archive_contents
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 173 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 173 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_compute_and_write_armap
  (bfd *, unsigned int) __attribute__ ((__visibility__ ("hidden")));
extern bfd *_bfd_get_elt_at_filepos
  (bfd *, file_ptr, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));
extern bfd *_bfd_generic_get_elt_at_index
  (bfd *, symindex) __attribute__ ((__visibility__ ("hidden")));

extern 
# 180 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 180 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_false
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 182 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 182 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_asymbol_false
  (bfd *, asymbol *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 184 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 184 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_false_error
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 186 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 186 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_link_false_error
  (bfd *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 188 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 188 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_true
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 190 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 190 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_link_true
  (bfd *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 192 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 192 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_bfd_true
  (bfd *, bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 194 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 194 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_uint_true
  (bfd *, unsigned int) __attribute__ ((__visibility__ ("hidden")));
extern 
# 196 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 196 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_asection_bfd_asection_true
  (bfd *, asection *, bfd *, asection *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 198 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 198 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_asymbol_bfd_asymbol_true
  (bfd *, asymbol *, bfd *, asymbol *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 200 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 200 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bool_bfd_ptr_true
  (bfd *, void *) __attribute__ ((__visibility__ ("hidden")));
extern void *_bfd_ptr_bfd_null_error
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern int _bfd_int_bfd_0
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern unsigned int _bfd_uint_bfd_0
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern long _bfd_long_bfd_0
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern long _bfd_long_bfd_n1_error
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_void_bfd
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_void_bfd_link
  (bfd *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_void_bfd_asection
  (bfd *, asection *) __attribute__ ((__visibility__ ("hidden")));

extern bfd_cleanup _bfd_dummy_target
  (bfd *) __attribute__ ((__visibility__ ("hidden")));


extern void bfd_dont_truncate_arname
  (bfd *, const char *, char *) __attribute__ ((__visibility__ ("hidden")));
extern void bfd_bsd_truncate_arname
  (bfd *, const char *, char *) __attribute__ ((__visibility__ ("hidden")));
extern void bfd_gnu_truncate_arname
  (bfd *, const char *, char *) __attribute__ ((__visibility__ ("hidden")));

extern 
# 230 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 230 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bsd_write_armap
  (bfd *, unsigned int, struct orl *, unsigned int, int) __attribute__ ((__visibility__ ("hidden")));

extern 
# 233 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 233 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_coff_write_armap
  (bfd *, unsigned int, struct orl *, unsigned int, int) __attribute__ ((__visibility__ ("hidden")));

extern void *_bfd_generic_read_ar_hdr
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_ar_spacepad
  (char *, size_t, const char *, long) __attribute__ ((__visibility__ ("hidden")));
extern 
# 240 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 240 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_ar_sizepad
  (char *, size_t, bfd_size_type) __attribute__ ((__visibility__ ("hidden")));

extern void *_bfd_generic_read_ar_hdr_mag
  (bfd *, const char *) __attribute__ ((__visibility__ ("hidden")));

extern 
# 246 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 246 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_write_ar_hdr
  (bfd *, bfd *) __attribute__ ((__visibility__ ("hidden")));

extern 
# 249 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 249 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_bsd44_write_ar_hdr
  (bfd *, bfd *) __attribute__ ((__visibility__ ("hidden")));

extern bfd * bfd_generic_openr_next_archived_file
  (bfd *, bfd *) __attribute__ ((__visibility__ ("hidden")));

extern int bfd_generic_stat_arch_elt
  (bfd *, struct stat *) __attribute__ ((__visibility__ ("hidden")));
# 267 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern 
# 267 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 267 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_archive_close_and_cleanup
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_unlink_from_archive_parent (bfd *) __attribute__ ((__visibility__ ("hidden")));

extern 
# 271 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 271 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_new_section_hook
  (bfd *, asection *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 273 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 273 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_get_section_contents
  (bfd *, asection *, void *, file_ptr, bfd_size_type) __attribute__ ((__visibility__ ("hidden")));
extern 
# 275 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 275 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_get_section_contents_in_window
  (bfd *, asection *, bfd_window *, file_ptr, bfd_size_type) __attribute__ ((__visibility__ ("hidden")));
# 292 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern 
# 292 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 292 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_init_private_section_data
  (bfd *, asection *, bfd *, asection *, struct bfd_link_info *)
  __attribute__ ((__visibility__ ("hidden")));




extern char *_bfd_nocore_core_file_failing_command
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern int _bfd_nocore_core_file_failing_signal
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 303 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 303 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nocore_core_file_matches_executable_p
  (bfd *, bfd *) __attribute__ ((__visibility__ ("hidden")));
extern int _bfd_nocore_core_file_pid
  (bfd *) __attribute__ ((__visibility__ ("hidden")));






extern 
# 313 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 313 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_noarchive_construct_extended_name_table
  (bfd *, char **, bfd_size_type *, const char **) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_noarchive_truncate_arname
  (bfd *, const char *, char *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 317 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 317 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_noarchive_write_armap
  (bfd *, unsigned int, struct orl *, unsigned int, int) __attribute__ ((__visibility__ ("hidden")));

extern 
# 320 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 320 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_noarchive_write_ar_hdr
  (bfd *, bfd *) __attribute__ ((__visibility__ ("hidden")));
extern bfd *
_bfd_noarchive_openr_next_archived_file
  (bfd *, bfd *) __attribute__ ((__visibility__ ("hidden")));
extern bfd * _bfd_noarchive_get_elt_at_index
  (bfd *, symindex) __attribute__ ((__visibility__ ("hidden")));
# 336 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern 
# 336 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 336 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_archive_bsd_construct_extended_name_table
  (bfd *, char **, bfd_size_type *, const char **) __attribute__ ((__visibility__ ("hidden")));
# 347 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern 
# 347 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 347 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_archive_bsd_update_armap_timestamp
  (bfd *) __attribute__ ((__visibility__ ("hidden")));







extern 
# 356 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 356 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_archive_coff_construct_extended_name_table
  (bfd *, char **, bfd_size_type *, const char **) __attribute__ ((__visibility__ ("hidden")));
# 375 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern 
# 375 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 375 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_archive_bsd44_construct_extended_name_table
  (bfd *, char **, bfd_size_type *, const char **) __attribute__ ((__visibility__ ("hidden")));
# 393 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern 
# 393 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 393 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_vms_lib_write_archive_contents
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
# 404 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern bfd *_bfd_vms_lib_openr_next_archived_file
  (bfd *, bfd *) __attribute__ ((__visibility__ ("hidden")));
extern bfd *_bfd_vms_lib_get_elt_at_index
  (bfd *, symindex) __attribute__ ((__visibility__ ("hidden")));
extern int _bfd_vms_lib_generic_stat_arch_elt
  (bfd *, struct stat *) __attribute__ ((__visibility__ ("hidden")));




extern symindex _bfd_vms_lib_find_symbol
  (bfd *, const char *) __attribute__ ((__visibility__ ("hidden")));
extern bfd *_bfd_vms_lib_get_imagelib_file
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern bfd_cleanup _bfd_vms_lib_alpha_archive_p
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern bfd_cleanup _bfd_vms_lib_ia64_archive_p
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 422 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 422 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_vms_lib_alpha_mkarchive
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 424 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 424 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_vms_lib_ia64_mkarchive
  (bfd *) __attribute__ ((__visibility__ ("hidden")));





extern long _bfd_nosymbols_canonicalize_symtab
  (bfd *, asymbol **) __attribute__ ((__visibility__ ("hidden")));

extern void _bfd_nosymbols_print_symbol
  (bfd *, void *, asymbol *, bfd_print_symbol_type) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_nosymbols_get_symbol_info
  (bfd *, asymbol *, symbol_info *) __attribute__ ((__visibility__ ("hidden")));
extern const char * _bfd_nosymbols_get_symbol_version_string
  (bfd *, asymbol *, 
# 439 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
                    _Bool
# 439 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                        , 
# 439 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
                          _Bool 
# 439 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                               *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 440 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 440 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nosymbols_bfd_is_local_label_name
  (bfd *, const char *) __attribute__ ((__visibility__ ("hidden")));

extern alent *_bfd_nosymbols_get_lineno
  (bfd *, asymbol *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 445 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 445 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nosymbols_find_nearest_line
  (bfd *, asymbol **, asection *, bfd_vma,
   const char **, const char **, unsigned int *, unsigned int *)
  __attribute__ ((__visibility__ ("hidden")));
extern 
# 449 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 449 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nosymbols_find_nearest_line_with_alt
  (bfd *, const char *, asymbol **, asection *, bfd_vma,
   const char **, const char **, unsigned int *, unsigned int *)
  __attribute__ ((__visibility__ ("hidden")));
extern 
# 453 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 453 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nosymbols_find_line
  (bfd *, asymbol **, asymbol *, const char **, unsigned int *)
  __attribute__ ((__visibility__ ("hidden")));
extern 
# 456 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 456 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nosymbols_find_inliner_info
  (bfd *, const char **, const char **, unsigned int *) __attribute__ ((__visibility__ ("hidden")));
extern asymbol *_bfd_nosymbols_bfd_make_debug_symbol
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern long _bfd_nosymbols_read_minisymbols
  (bfd *, 
# 461 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
         _Bool
# 461 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
             , void **, unsigned int *) __attribute__ ((__visibility__ ("hidden")));
extern asymbol *_bfd_nosymbols_minisymbol_to_symbol
  (bfd *, 
# 463 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
         _Bool
# 463 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
             , const void *, asymbol *) __attribute__ ((__visibility__ ("hidden")));




extern long _bfd_norelocs_get_reloc_upper_bound
  (bfd *, asection *) __attribute__ ((__visibility__ ("hidden")));
extern long _bfd_norelocs_canonicalize_reloc
  (bfd *, asection *, arelent **, asymbol **) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_norelocs_set_reloc
  (bfd *, asection *, arelent **, unsigned int) __attribute__ ((__visibility__ ("hidden")));
extern reloc_howto_type *_bfd_norelocs_bfd_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type) __attribute__ ((__visibility__ ("hidden")));
extern reloc_howto_type *_bfd_norelocs_bfd_reloc_name_lookup
  (bfd *, const char *) __attribute__ ((__visibility__ ("hidden")));




extern 
# 482 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 482 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nowrite_set_arch_mach
  (bfd *, enum bfd_architecture, unsigned long) __attribute__ ((__visibility__ ("hidden")));
extern 
# 484 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 484 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nowrite_set_section_contents
  (bfd *, asection *, const void *, file_ptr, bfd_size_type) __attribute__ ((__visibility__ ("hidden")));





extern 
# 491 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 491 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_set_section_contents
  (bfd *, asection *, const void *, file_ptr, bfd_size_type) __attribute__ ((__visibility__ ("hidden")));




extern int _bfd_nolink_sizeof_headers
  (bfd *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));
extern bfd_byte *_bfd_nolink_bfd_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *,
   bfd_byte *, 
# 501 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
              _Bool
# 501 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                  , asymbol **) __attribute__ ((__visibility__ ("hidden")));
extern 
# 502 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 502 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nolink_bfd_relax_section
  (bfd *, asection *, struct bfd_link_info *, 
# 503 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
                                             _Bool 
# 503 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                                                  *) __attribute__ ((__visibility__ ("hidden")));

extern 
# 505 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 505 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nolink_bfd_lookup_section_flags
  (struct bfd_link_info *, struct flag_info *, asection *) __attribute__ ((__visibility__ ("hidden")));

extern 
# 508 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 508 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nolink_bfd_is_group_section
  (bfd *, const asection *) __attribute__ ((__visibility__ ("hidden")));
extern const char *_bfd_nolink_bfd_group_name
  (bfd *, const asection *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 512 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 512 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nolink_bfd_discard_group
  (bfd *, asection *) __attribute__ ((__visibility__ ("hidden")));
extern struct bfd_link_hash_table *_bfd_nolink_bfd_link_hash_table_create
  (bfd *) __attribute__ ((__visibility__ ("hidden")));

extern void _bfd_nolink_bfd_link_just_syms
  (asection *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_nolink_bfd_copy_link_hash_symbol_type
  (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *)
  __attribute__ ((__visibility__ ("hidden")));

extern 
# 523 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 523 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nolink_bfd_link_split_section
  (bfd *, struct bfd_section *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 525 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 525 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nolink_section_already_linked
  (bfd *, asection *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 527 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 527 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_nolink_bfd_define_common_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *)
  __attribute__ ((__visibility__ ("hidden")));


extern struct bfd_link_hash_entry *_bfd_nolink_bfd_define_start_stop
  (struct bfd_link_info *, const char *, asection *) __attribute__ ((__visibility__ ("hidden")));
# 544 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern long _bfd_nodynamic_get_synthetic_symtab
  (bfd *, long, asymbol **, long, asymbol **, asymbol **) __attribute__ ((__visibility__ ("hidden")));

extern long _bfd_nodynamic_canonicalize_dynamic_reloc
  (bfd *, arelent **, asymbol **) __attribute__ ((__visibility__ ("hidden")));



extern 
# 552 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 552 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           bfd_generic_is_local_label_name
  (bfd *, const char *) __attribute__ ((__visibility__ ("hidden")));


extern long _bfd_generic_read_minisymbols
  (bfd *, 
# 557 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
         _Bool
# 557 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
             , void **, unsigned int *) __attribute__ ((__visibility__ ("hidden")));
extern asymbol *_bfd_generic_minisymbol_to_symbol
  (bfd *, 
# 559 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
         _Bool
# 559 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
             , const void *, asymbol *) __attribute__ ((__visibility__ ("hidden")));


extern 
# 562 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 562 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_stab_section_find_nearest_line
  (bfd *, asymbol **, asection *, bfd_vma, 
# 563 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
                                          _Bool 
# 563 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                                               *,
   const char **, const char **, unsigned int *, void **) __attribute__ ((__visibility__ ("hidden")));


extern 
# 567 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 567 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_dwarf1_find_nearest_line
  (bfd *, asymbol **, asection *, bfd_vma,
   const char **, const char **, unsigned int *) __attribute__ ((__visibility__ ("hidden")));


extern void _bfd_dwarf1_cleanup_debug_info
  (bfd *, void **) __attribute__ ((__visibility__ ("hidden")));

struct dwarf_debug_section
{
  const char * uncompressed_name;
  const char * compressed_name;
};




extern const struct dwarf_debug_section dwarf_debug_sections[] __attribute__ ((__visibility__ ("hidden")));


extern int _bfd_dwarf2_find_nearest_line
  (bfd *, asymbol **, asymbol *, asection *, bfd_vma,
   const char **, const char **, unsigned int *, unsigned int *,
   const struct dwarf_debug_section *, void **) __attribute__ ((__visibility__ ("hidden")));



extern int _bfd_dwarf2_find_nearest_line_with_alt
  (bfd *, const char *, asymbol **, asymbol *, asection *, bfd_vma,
   const char **, const char **, unsigned int *, unsigned int *,
   const struct dwarf_debug_section *, void **) __attribute__ ((__visibility__ ("hidden")));


extern bfd_signed_vma _bfd_dwarf2_find_symbol_bias
  (asymbol **, void **) __attribute__ ((__visibility__ ("hidden")));


extern 
# 604 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 604 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_dwarf2_find_inliner_info
  (bfd *, const char **, const char **, unsigned int *, void **)
  __attribute__ ((__visibility__ ("hidden")));


extern 
# 609 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 609 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_dwarf2_slurp_debug_info
  (bfd *, bfd *, const struct dwarf_debug_section *, asymbol **, void **,
   
# 611 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
  _Bool
# 611 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
      ) __attribute__ ((__visibility__ ("hidden")));


extern void _bfd_dwarf2_cleanup_debug_info
  (bfd *, void **) __attribute__ ((__visibility__ ("hidden")));

extern void _bfd_stab_cleanup
  (bfd *, void **) __attribute__ ((__visibility__ ("hidden")));


extern struct bfd_hash_entry *bfd_section_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *)
  __attribute__ ((__visibility__ ("hidden")));


extern struct bfd_hash_entry *_bfd_link_hash_newfunc
  (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
   const char *string) __attribute__ ((__visibility__ ("hidden")));


extern 
# 631 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 631 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_link_hash_table_init
  (struct bfd_link_hash_table *, bfd *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int) __attribute__ ((__visibility__ ("hidden")));


extern struct bfd_link_hash_table *_bfd_generic_link_hash_table_create
  (bfd *) __attribute__ ((__visibility__ ("hidden")));


extern void _bfd_generic_link_hash_table_free
  (bfd *) __attribute__ ((__visibility__ ("hidden")));


extern 
# 647 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 647 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_link_add_symbols
  (bfd *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));


extern 
# 651 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 651 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_link_add_archive_symbols
  (bfd *, struct bfd_link_info *,
   
# 653 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
  _Bool 
# 653 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
       (*) (bfd *, struct bfd_link_info *,
      struct bfd_link_hash_entry *, const char *,
      
# 655 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
     _Bool 
# 655 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
          *)) __attribute__ ((__visibility__ ("hidden")));


typedef struct bfd_link_hash_entry _bfd_link_hash_entry;


extern 
# 661 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 661 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_link_add_one_symbol
  (struct bfd_link_info *, bfd *, const char *name, flagword,
   asection *, bfd_vma, const char *, 
# 663 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
                                     _Bool 
# 663 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                                          copy,
   
# 664 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
  _Bool 
# 664 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
       constructor, struct bfd_link_hash_entry **) __attribute__ ((__visibility__ ("hidden")));


extern void _bfd_generic_link_just_syms
  (asection *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));


extern void _bfd_generic_copy_link_hash_symbol_type
  (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *)
  __attribute__ ((__visibility__ ("hidden")));


extern 
# 676 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 676 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_final_link
  (bfd *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));

extern 
# 679 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 679 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_link_split_section
  (bfd *, struct bfd_section *) __attribute__ ((__visibility__ ("hidden")));

extern 
# 682 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 682 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_section_already_linked
  (bfd *, asection *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));


extern 
# 686 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 686 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_generic_reloc_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *)
  __attribute__ ((__visibility__ ("hidden")));


extern 
# 691 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 691 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_default_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *)
  __attribute__ ((__visibility__ ("hidden")));


extern unsigned int _bfd_count_link_order_relocs
  (struct bfd_link_order *) __attribute__ ((__visibility__ ("hidden")));


extern bfd_reloc_status_type _bfd_final_link_relocate
  (reloc_howto_type *, bfd *, asection *, bfd_byte *,
   bfd_vma, bfd_vma, bfd_vma) __attribute__ ((__visibility__ ("hidden")));


extern bfd_reloc_status_type _bfd_relocate_contents
  (reloc_howto_type *, bfd *, bfd_vma, bfd_byte *) __attribute__ ((__visibility__ ("hidden")));


extern bfd_reloc_status_type _bfd_clear_contents
  (reloc_howto_type *, bfd *, asection *, bfd_byte *, bfd_vma) __attribute__ ((__visibility__ ("hidden")));



extern 
# 714 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 714 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_add_merge_section
  (bfd *, void **, asection *, void **) __attribute__ ((__visibility__ ("hidden")));



extern 
# 719 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 719 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_merge_sections
  (bfd *, struct bfd_link_info *, void *, void (*) (bfd *, asection *))
  __attribute__ ((__visibility__ ("hidden")));



extern 
# 725 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 725 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_write_merged_section
  (bfd *, asection *, void *) __attribute__ ((__visibility__ ("hidden")));



extern bfd_vma _bfd_merged_section_offset
  (bfd *, asection **, void *, bfd_vma) __attribute__ ((__visibility__ ("hidden")));



extern void _bfd_merge_sections_free (void *) __attribute__ ((__visibility__ ("hidden")));
# 751 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern void bfd_assert
  (const char*,int) __attribute__ ((__visibility__ ("hidden")));







extern void _bfd_abort
  (const char *, int, const char *) __attribute__ ((__noreturn__)) __attribute__ ((__visibility__ ("hidden")));
# 773 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
extern file_ptr _bfd_real_ftell
  (FILE *) __attribute__ ((__visibility__ ("hidden")));
extern int _bfd_real_fseek
  (FILE *, file_ptr, int) __attribute__ ((__visibility__ ("hidden")));
extern FILE *_bfd_real_fopen
  (const char *, const char *) __attribute__ ((__visibility__ ("hidden")));



extern const bfd_target *const *const bfd_target_vector __attribute__ ((__visibility__ ("hidden")));
extern const bfd_target *bfd_default_vector[] __attribute__ ((__visibility__ ("hidden")));


extern const bfd_target *const *const bfd_associated_vector __attribute__ ((__visibility__ ("hidden")));




struct ecoff_debug_info;
struct ecoff_debug_swap;
struct ecoff_extr;
struct ecoff_find_line;

extern void _bfd_ecoff_free_ecoff_debug_info
  (struct ecoff_debug_info *debug);
extern 
# 798 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 798 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_ecoff_locate_line
  (bfd *, asection *, bfd_vma, struct ecoff_debug_info * const,
   const struct ecoff_debug_swap * const, struct ecoff_find_line *,
   const char **, const char **, unsigned int *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 802 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 802 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_ecoff_get_accumulated_pdr
  (void *, bfd_byte *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 804 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 804 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_ecoff_get_accumulated_sym
  (void *, bfd_byte *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 806 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 806 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_ecoff_get_accumulated_ss
  (void *, bfd_byte *) __attribute__ ((__visibility__ ("hidden")));

extern bfd_vma _bfd_get_gp_value
  (bfd *) __attribute__ ((__visibility__ ("hidden")));
extern void _bfd_set_gp_value
  (bfd *, bfd_vma) __attribute__ ((__visibility__ ("hidden")));





extern 
# 818 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 818 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_sh_align_load_span
  (bfd *, asection *, bfd_byte *,
   
# 820 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
  _Bool 
# 820 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
       (*) (bfd *, asection *, void *, bfd_byte *, bfd_vma),
   void *, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, 
# 821 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
                                                   _Bool 
# 821 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                                                        *) __attribute__ ((__visibility__ ("hidden")));






struct bfd_section_already_linked_hash_entry
{
  struct bfd_hash_entry root;
  struct bfd_section_already_linked *entry;
};

struct bfd_section_already_linked
{
  struct bfd_section_already_linked *next;
  asection *sec;
};

extern struct bfd_section_already_linked_hash_entry *
  bfd_section_already_linked_table_lookup (const char *) __attribute__ ((__visibility__ ("hidden")));
extern 
# 842 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 842 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           bfd_section_already_linked_table_insert
  (struct bfd_section_already_linked_hash_entry *, asection *)
  __attribute__ ((__visibility__ ("hidden")));
extern void bfd_section_already_linked_table_traverse
  (
# 846 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
  _Bool 
# 846 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
       (*) (struct bfd_section_already_linked_hash_entry *,
      void *), void *) __attribute__ ((__visibility__ ("hidden")));

extern bfd_vma _bfd_read_unsigned_leb128
  (bfd *, bfd_byte *, unsigned int *) __attribute__ ((__visibility__ ("hidden")));
extern bfd_signed_vma _bfd_read_signed_leb128
  (bfd *, bfd_byte *, unsigned int *) __attribute__ ((__visibility__ ("hidden")));
extern bfd_vma _bfd_safe_read_leb128
  (bfd *, bfd_byte **, 
# 854 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
                      _Bool
# 854 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                          , const bfd_byte * const) __attribute__ ((__visibility__ ("hidden")));
extern bfd_byte * _bfd_write_unsigned_leb128
  (bfd_byte *, bfd_byte *, bfd_vma) __attribute__ ((__visibility__ ("hidden")));

extern struct bfd_link_info *_bfd_get_link_info (bfd *);

extern 
# 860 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
      _Bool 
# 860 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
           _bfd_link_keep_memory (struct bfd_link_info *)
  __attribute__ ((__visibility__ ("hidden")));
# 877 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
static inline void *
_bfd_alloc_and_read (bfd *abfd, bfd_size_type asize, bfd_size_type rsize)
{
  void *mem;
  if (!__builtin_constant_p (rsize))
    {
      ufile_ptr filesize = bfd_get_file_size (abfd);
      if (filesize != 0 && rsize > filesize)
 {
   bfd_set_error (bfd_error_file_truncated);
   return 
# 887 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
         ((void *)0)
# 887 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
             ;
 }
    }
  mem = bfd_alloc (abfd, asize);
  if (mem != 
# 891 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
            ((void *)0)
# 891 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                )
    {
      if (bfd_bread (mem, rsize, abfd) == rsize)
 return mem;
      bfd_release (abfd, mem);
    }
  return 
# 897 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
        ((void *)0)
# 897 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
            ;
}

static inline void *
_bfd_malloc_and_read (bfd *abfd, bfd_size_type asize, bfd_size_type rsize)
{
  void *mem;
  if (!__builtin_constant_p (rsize))
    {
      ufile_ptr filesize = bfd_get_file_size (abfd);
      if (filesize != 0 && rsize > filesize)
 {
   bfd_set_error (bfd_error_file_truncated);
   return 
# 910 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
         ((void *)0)
# 910 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
             ;
 }
    }
  mem = bfd_malloc (asize);
  if (mem != 
# 914 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
            ((void *)0)
# 914 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                )
    {
      if (bfd_bread (mem, rsize, abfd) == rsize)
 return mem;
      free (mem);
    }
  return 
# 920 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
        ((void *)0)
# 920 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
            ;
}

void *bfd_malloc (bfd_size_type ) __attribute__ ((__visibility__ ("hidden")));

void *bfd_realloc (void * , bfd_size_type ) __attribute__ ((__visibility__ ("hidden")));

void *bfd_realloc_or_free (void * , bfd_size_type ) __attribute__ ((__visibility__ ("hidden")));

void *bfd_zmalloc (bfd_size_type ) __attribute__ ((__visibility__ ("hidden")));


# 931 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 931 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    bfd_write_bigendian_4byte_int (bfd *, unsigned int) __attribute__ ((__visibility__ ("hidden")));

unsigned int bfd_log2 (bfd_vma x) __attribute__ ((__visibility__ ("hidden")));



extern char *_bfd_error_buf;

char *bfd_asprintf (const char *fmt, ...) __attribute__ ((__visibility__ ("hidden")));

bfd_error_handler_type _bfd_set_error_handler_caching (bfd *) __attribute__ ((__visibility__ ("hidden")));

const char *_bfd_get_error_program_name (void) __attribute__ ((__visibility__ ("hidden")));


struct bfd_iovec
{






  file_ptr (*bread) (struct bfd *abfd, void *ptr, file_ptr nbytes);
  file_ptr (*bwrite) (struct bfd *abfd, const void *ptr,
        file_ptr nbytes);


  file_ptr (*btell) (struct bfd *abfd);


  int (*bseek) (struct bfd *abfd, file_ptr offset, int whence);
  int (*bclose) (struct bfd *abfd);
  int (*bflush) (struct bfd *abfd);
  int (*bstat) (struct bfd *abfd, struct stat *sb);






  void *(*bmmap) (struct bfd *abfd, void *addr, bfd_size_type len,
    int prot, int flags, file_ptr offset,
    void **map_addr, bfd_size_type *map_len);
};
extern const struct bfd_iovec _bfd_memory_iovec;



struct orl
{
  char **name;
  union
  {
    file_ptr pos;
    bfd *abfd;
  } u;
  int namidx;
};


extern const bfd_arch_info_type bfd_default_arch_struct;

const bfd_arch_info_type *bfd_default_compatible
   (const bfd_arch_info_type *a, const bfd_arch_info_type *b) __attribute__ ((__visibility__ ("hidden")));


# 997 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 997 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    bfd_default_scan
   (const struct bfd_arch_info *info, const char *string) __attribute__ ((__visibility__ ("hidden")));

void *bfd_arch_default_fill (bfd_size_type count,
    
# 1001 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
   _Bool 
# 1001 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
        is_bigendian,
    
# 1002 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
   _Bool 
# 1002 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
        code) __attribute__ ((__visibility__ ("hidden")));


typedef struct _bfd_window_internal
{
  struct _bfd_window_internal *next;
  void *data;
  bfd_size_type size;
  int refcount : 31;
  unsigned mapped : 1;
}
bfd_window_internal;



# 1016 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 1016 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    bfd_cache_init (bfd *abfd) __attribute__ ((__visibility__ ("hidden")));

FILE* bfd_open_file (bfd *abfd) __attribute__ ((__visibility__ ("hidden")));


struct bfd_strtab_hash *_bfd_stringtab_init (void) __attribute__ ((__visibility__ ("hidden")));

struct bfd_strtab_hash *_bfd_xcoff_stringtab_init
   (
# 1024 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
   _Bool 
# 1024 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                     ) __attribute__ ((__visibility__ ("hidden")));

void _bfd_stringtab_free (struct bfd_strtab_hash *) __attribute__ ((__visibility__ ("hidden")));

bfd_size_type _bfd_stringtab_add
   (struct bfd_strtab_hash *, const char *,
    
# 1030 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
   _Bool 
# 1030 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                , 
# 1030 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
                  _Bool 
# 1030 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                               ) __attribute__ ((__visibility__ ("hidden")));

bfd_size_type _bfd_stringtab_size (struct bfd_strtab_hash *) __attribute__ ((__visibility__ ("hidden")));


# 1034 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 1034 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    _bfd_stringtab_emit (bfd *, struct bfd_strtab_hash *) __attribute__ ((__visibility__ ("hidden")));



# 1037 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 1037 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    _bfd_generic_verify_endian_match
   (bfd *ibfd, struct bfd_link_info *info) __attribute__ ((__visibility__ ("hidden")));


bfd *_bfd_new_bfd (void) __attribute__ ((__visibility__ ("hidden")));

bfd *_bfd_new_bfd_contained_in (bfd *) __attribute__ ((__visibility__ ("hidden")));


# 1045 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 1045 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    _bfd_free_cached_info (bfd *) __attribute__ ((__visibility__ ("hidden")));
# 3534 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
reloc_howto_type *bfd_default_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code) __attribute__ ((__visibility__ ("hidden")));


# 3537 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3537 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    bfd_generic_relax_section
   (bfd *abfd,
    asection *section,
    struct bfd_link_info *,
    
# 3541 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
   _Bool 
# 3541 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
        *) __attribute__ ((__visibility__ ("hidden")));


# 3543 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3543 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    bfd_generic_gc_sections
   (bfd *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));


# 3546 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3546 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    bfd_generic_lookup_section_flags
   (struct bfd_link_info *, struct flag_info *, asection *) __attribute__ ((__visibility__ ("hidden")));


# 3549 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3549 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    bfd_generic_merge_sections
   (bfd *, struct bfd_link_info *) __attribute__ ((__visibility__ ("hidden")));

bfd_byte *bfd_generic_get_relocated_section_contents
   (bfd *abfd,
    struct bfd_link_info *link_info,
    struct bfd_link_order *link_order,
    bfd_byte *data,
    
# 3557 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
   _Bool 
# 3557 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
        relocatable,
    asymbol **symbols) __attribute__ ((__visibility__ ("hidden")));

void _bfd_generic_set_reloc
   (bfd *abfd,
    sec_ptr section,
    arelent **relptr,
    unsigned int count) __attribute__ ((__visibility__ ("hidden")));


# 3566 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3566 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    _bfd_unrecognized_reloc
   (bfd * abfd,
    sec_ptr section,
    unsigned int r_type) __attribute__ ((__visibility__ ("hidden")));



# 3572 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3572 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    _bfd_section_size_insane (bfd *abfd, asection *sec) __attribute__ ((__visibility__ ("hidden")));



# 3575 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3575 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    _bfd_link_section_stabs
   (bfd *, struct stab_info *, asection *, asection *, void **,
    bfd_size_type *) __attribute__ ((__visibility__ ("hidden")));


# 3579 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3579 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    _bfd_discard_section_stabs
   (bfd *, asection *, void *, 
# 3580 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
                              _Bool 
# 3580 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
                                   (*) (bfd_vma, void *), void *) __attribute__ ((__visibility__ ("hidden")));


# 3582 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3582 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    _bfd_write_section_stabs
   (bfd *, struct stab_info *, asection *, void **, bfd_byte *) __attribute__ ((__visibility__ ("hidden")));


# 3585 "/doner/binutils/binutils-515f23e/bfd/libbfd.h" 3 4
_Bool 
# 3585 "/doner/binutils/binutils-515f23e/bfd/libbfd.h"
    _bfd_write_stab_strings (bfd *, struct stab_info *) __attribute__ ((__visibility__ ("hidden")));

bfd_vma _bfd_stab_section_offset (asection *, void *, bfd_vma) __attribute__ ((__visibility__ ("hidden")));



struct per_xvec_message
{
  struct per_xvec_message *next;
  char message[];
};

struct per_xvec_message **_bfd_per_xvec_warn (const bfd_target *, size_t) __attribute__ ((__visibility__ ("hidden")));
# 25 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2

# 1 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 1
# 27 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
# 1 "./../include/elf/common.h" 1
# 28 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 2
# 1 "./../include/elf/external.h" 1
# 52 "./../include/elf/external.h"
typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[4];
  unsigned char e_phoff[4];
  unsigned char e_shoff[4];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf32_External_Ehdr;

typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[8];
  unsigned char e_phoff[8];
  unsigned char e_shoff[8];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf64_External_Ehdr;



typedef struct {
  unsigned char p_type[4];
  unsigned char p_offset[4];
  unsigned char p_vaddr[4];
  unsigned char p_paddr[4];
  unsigned char p_filesz[4];
  unsigned char p_memsz[4];
  unsigned char p_flags[4];
  unsigned char p_align[4];
} Elf32_External_Phdr;

typedef struct {
  unsigned char p_type[4];
  unsigned char p_flags[4];
  unsigned char p_offset[8];
  unsigned char p_vaddr[8];
  unsigned char p_paddr[8];
  unsigned char p_filesz[8];
  unsigned char p_memsz[8];
  unsigned char p_align[8];
} Elf64_External_Phdr;



typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[4];
  unsigned char sh_addr[4];
  unsigned char sh_offset[4];
  unsigned char sh_size[4];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[4];
  unsigned char sh_entsize[4];
} Elf32_External_Shdr;

typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[8];
  unsigned char sh_addr[8];
  unsigned char sh_offset[8];
  unsigned char sh_size[8];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[8];
  unsigned char sh_entsize[8];
} Elf64_External_Shdr;



typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_size[4];
  unsigned char ch_addralign[4];
} Elf32_External_Chdr;

typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_reserved[4];
  unsigned char ch_size[8];
  unsigned char ch_addralign[8];
} Elf64_External_Chdr;



typedef struct {
  unsigned char st_name[4];
  unsigned char st_value[4];
  unsigned char st_size[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
} Elf32_External_Sym;

typedef struct {
  unsigned char st_name[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
  unsigned char st_value[8];
  unsigned char st_size[8];
} Elf64_External_Sym;

typedef struct {
  unsigned char est_shndx[4];
} Elf_External_Sym_Shndx;



typedef struct {
  unsigned char namesz[4];
  unsigned char descsz[4];
  unsigned char type[4];
  char name[1];
} Elf_External_Note;
# 203 "./../include/elf/external.h"
typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
} Elf32_External_Rel;

typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
  unsigned char r_addend[4];
} Elf32_External_Rela;

typedef struct {
  unsigned char r_data[4];
} Elf32_External_Relr;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
} Elf64_External_Rel;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
  unsigned char r_addend[8];
} Elf64_External_Rela;

typedef struct {
  unsigned char r_data[8];
} Elf64_External_Relr;



typedef struct {
  unsigned char d_tag[4];
  union {
    unsigned char d_val[4];
    unsigned char d_ptr[4];
  } d_un;
} Elf32_External_Dyn;

typedef struct {
  unsigned char d_tag[8];
  union {
    unsigned char d_val[8];
    unsigned char d_ptr[8];
  } d_un;
} Elf64_External_Dyn;







typedef struct {
  unsigned char vd_version[2];
  unsigned char vd_flags[2];
  unsigned char vd_ndx[2];
  unsigned char vd_cnt[2];
  unsigned char vd_hash[4];
  unsigned char vd_aux[4];
  unsigned char vd_next[4];
} Elf_External_Verdef;



typedef struct {
  unsigned char vda_name[4];
  unsigned char vda_next[4];
} Elf_External_Verdaux;



typedef struct {
  unsigned char vn_version[2];
  unsigned char vn_cnt[2];
  unsigned char vn_file[4];
  unsigned char vn_aux[4];
  unsigned char vn_next[4];
} Elf_External_Verneed;



typedef struct {
  unsigned char vna_hash[4];
  unsigned char vna_flags[2];
  unsigned char vna_other[2];
  unsigned char vna_name[4];
  unsigned char vna_next[4];
} Elf_External_Vernaux;




typedef struct {
  unsigned char vs_vers[2];
} __attribute__ ((packed)) Elf_External_Versym;


typedef struct
{
  unsigned char si_boundto[2];
  unsigned char si_flags[2];
} Elf_External_Syminfo;



typedef struct
{
  unsigned char a_type[4];
  unsigned char a_val[4];
} Elf32_External_Auxv;

typedef struct
{
  unsigned char a_type[8];
  unsigned char a_val[8];
} Elf64_External_Auxv;
# 29 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 2
# 1 "./../include/elf/internal.h" 1
# 67 "./../include/elf/internal.h"
typedef struct elf_internal_ehdr {
  unsigned char e_ident[16];
  bfd_vma e_entry;
  bfd_size_type e_phoff;
  bfd_size_type e_shoff;
  unsigned long e_version;
  unsigned long e_flags;
  unsigned short e_type;
  unsigned short e_machine;
  unsigned int e_ehsize;
  unsigned int e_phentsize;
  unsigned int e_phnum;
  unsigned int e_shentsize;
  unsigned int e_shnum;
  unsigned int e_shstrndx;
} Elf_Internal_Ehdr;



struct elf_internal_phdr {
  unsigned long p_type;
  unsigned long p_flags;
  bfd_vma p_offset;
  bfd_vma p_vaddr;
  bfd_vma p_paddr;
  bfd_vma p_filesz;
  bfd_vma p_memsz;
  bfd_vma p_align;

};

typedef struct elf_internal_phdr Elf_Internal_Phdr;



typedef struct elf_internal_shdr {
  unsigned int sh_name;
  unsigned int sh_type;
  bfd_vma sh_flags;
  bfd_vma sh_addr;

  file_ptr sh_offset;
  bfd_size_type sh_size;
  unsigned int sh_link;
  unsigned int sh_info;
  bfd_vma sh_addralign;
  bfd_size_type sh_entsize;


  asection * bfd_section;
  unsigned char *contents;
} Elf_Internal_Shdr;



typedef struct elf_internal_chdr {
  unsigned int ch_type;
  bfd_size_type ch_size;
  bfd_vma ch_addralign;
} Elf_Internal_Chdr;



struct elf_internal_sym {
  bfd_vma st_value;
  bfd_vma st_size;
  unsigned long st_name;
  unsigned char st_info;
  unsigned char st_other;
  unsigned char st_target_internal;
  unsigned int st_shndx;
};

typedef struct elf_internal_sym Elf_Internal_Sym;



typedef struct elf_internal_note {
  unsigned long namesz;
  unsigned long descsz;
  unsigned long type;
  char * namedata;
  char * descdata;
  bfd_vma descpos;
} Elf_Internal_Note;



typedef struct elf_internal_rela {
  bfd_vma r_offset;
  bfd_vma r_info;
  bfd_vma r_addend;
} Elf_Internal_Rela;



typedef struct elf_internal_dyn {

  bfd_vma d_tag;
  union {

    bfd_vma d_val;
    bfd_vma d_ptr;
  } d_un;
} Elf_Internal_Dyn;



typedef struct elf_internal_verdef {
  unsigned short vd_version;
  unsigned short vd_flags;
  unsigned short vd_ndx;
  unsigned short vd_cnt;
  unsigned long vd_hash;
  unsigned long vd_aux;
  unsigned long vd_next;



  bfd *vd_bfd;
  const char *vd_nodename;
  struct elf_internal_verdef *vd_nextdef;
  struct elf_internal_verdaux *vd_auxptr;
  unsigned int vd_exp_refno;
} Elf_Internal_Verdef;



typedef struct elf_internal_verdaux {
  unsigned long vda_name;
  unsigned long vda_next;



  const char *vda_nodename;
  struct elf_internal_verdaux *vda_nextptr;
} Elf_Internal_Verdaux;



typedef struct elf_internal_verneed {
  unsigned short vn_version;
  unsigned short vn_cnt;
  unsigned long vn_file;
  unsigned long vn_aux;
  unsigned long vn_next;



  bfd *vn_bfd;
  const char *vn_filename;
  struct elf_internal_vernaux *vn_auxptr;
  struct elf_internal_verneed *vn_nextref;
} Elf_Internal_Verneed;



typedef struct elf_internal_vernaux {
  unsigned long vna_hash;
  unsigned short vna_flags;
  unsigned short vna_other;
  unsigned long vna_name;
  unsigned long vna_next;



  const char *vna_nodename;
  struct elf_internal_vernaux *vna_nextptr;
} Elf_Internal_Vernaux;




typedef struct elf_internal_versym {
  unsigned short vs_vers;
} Elf_Internal_Versym;


typedef struct
{
  unsigned short int si_boundto;
  unsigned short int si_flags;
} Elf_Internal_Syminfo;


typedef struct
{
  bfd_vma a_type;
  bfd_vma a_val;
} Elf_Internal_Auxv;





struct elf_segment_map
{

  struct elf_segment_map *next;

  unsigned long p_type;

  unsigned long p_flags;

  bfd_vma p_paddr;

  bfd_vma p_vaddr_offset;

  bfd_vma p_align;

  bfd_vma p_size;


  unsigned int p_flags_valid : 1;


  unsigned int p_paddr_valid : 1;


  unsigned int p_align_valid : 1;


  unsigned int p_size_valid : 1;

  unsigned int includes_filehdr : 1;

  unsigned int includes_phdrs : 1;




  unsigned int no_sort_lma : 1;

  unsigned int idx;

  unsigned int count;

  asection *sections[1];
};
# 30 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 2
# 70 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
typedef struct
{

  asymbol symbol;

  Elf_Internal_Sym internal_elf_sym;

  union
    {
      unsigned int hppa_arg_reloc;
      void *mips_extr;
      void *any;
    }
  tc_data;




  unsigned short version;

} elf_symbol_type;

struct elf_strtab_hash;
struct got_entry;
struct plt_entry;

union gotplt_union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
    struct got_entry *glist;
    struct plt_entry *plist;
  };

struct elf_link_virtual_table_entry
  {




    size_t size;
    
# 111 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
   _Bool 
# 111 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
        *used;


    struct elf_link_hash_entry *parent;
  };


enum elf_symbol_version
  {
    unknown = 0,
    unversioned,
    versioned,
    versioned_hidden
  };



struct elf_link_hash_entry
{
  struct bfd_link_hash_entry root;




  long indx;
# 149 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  long dynindx;
# 160 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  union gotplt_union got;


  union gotplt_union plt;



  bfd_size_type size;


  struct elf_dyn_relocs *dyn_relocs;


  unsigned int type : 8;


  unsigned int other : 8;


  unsigned int target_internal : 8;



  unsigned int ref_regular : 1;

  unsigned int def_regular : 1;

  unsigned int ref_dynamic : 1;

  unsigned int def_dynamic : 1;


  unsigned int ref_regular_nonweak : 1;

  unsigned int ref_ir_nonweak : 1;

  unsigned int dynamic_adjusted : 1;

  unsigned int needs_copy : 1;

  unsigned int needs_plt : 1;

  unsigned int non_elf : 1;

  __extension__ enum elf_symbol_version versioned : 2;

  unsigned int forced_local : 1;

  unsigned int dynamic : 1;

  unsigned int mark : 1;


  unsigned int non_got_ref : 1;



  unsigned int dynamic_def : 1;

  unsigned int ref_dynamic_nonweak : 1;


  unsigned int pointer_equality_needed : 1;

  unsigned int unique_global : 1;


  unsigned int protected_def : 1;


  unsigned int start_stop : 1;



  unsigned int is_weakalias : 1;


  unsigned long dynstr_index;

  union
  {

    struct elf_link_hash_entry *alias;




    unsigned long elf_hash_value;
  } u;


  union
  {



    Elf_Internal_Verdef *verdef;



    struct bfd_elf_version_tree *vertree;
  } verinfo;

  union
  {


    asection *start_stop_section;


    struct elf_link_virtual_table_entry *vtable;
  } u2;
};



static inline struct elf_link_hash_entry *
weakdef (struct elf_link_hash_entry *h)
{
  while (h->is_weakalias)
    h = h->u.alias;
  return h;
}
# 313 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
struct elf_link_local_dynamic_entry
{
  struct elf_link_local_dynamic_entry *next;


  bfd *input_bfd;


  long input_indx;


  long dynindx;


  Elf_Internal_Sym isym;
};

struct elf_link_loaded_list
{
  struct elf_link_loaded_list *next;
  bfd *abfd;
};


struct eh_cie_fde
{
  union {
    struct {
# 349 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      struct eh_cie_fde *cie_inf;
      struct eh_cie_fde *next_for_section;
    } fde;
    struct {
# 364 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      union {
 struct cie *full_cie;
 struct eh_cie_fde *merged_with;
 asection *sec;
      } u;



      unsigned int personality_offset : 8;




      unsigned int aug_str_len : 3;
      unsigned int aug_data_len : 5;


      unsigned int gc_mark : 1;



      unsigned int make_lsda_relative : 1;



      unsigned int make_per_encoding_relative : 1;




      unsigned int per_encoding_relative : 1;



      unsigned int per_encoding_aligned8 : 1;



      unsigned int add_fde_encoding : 1;


      unsigned int merged : 1;


      unsigned int pad1 : 9;
    } cie;
  } u;
  unsigned int reloc_index;
  unsigned int size;
  unsigned int offset;
  unsigned int new_offset;
  unsigned int fde_encoding : 8;
  unsigned int lsda_encoding : 8;
  unsigned int lsda_offset : 8;


  unsigned int cie : 1;


  unsigned int removed : 1;



  unsigned int add_augmentation_size : 1;




  unsigned int make_relative : 1;


  unsigned int pad1 : 4;

  unsigned int *set_loc;
};

struct eh_frame_sec_info
{
  unsigned int count;
  struct cie *cies;
  struct eh_cie_fde entry[1];
};

struct eh_frame_array_ent
{
  bfd_vma initial_loc;
  bfd_size_type range;
  bfd_vma fde;
};

struct htab;







struct dwarf_eh_frame_hdr_info
{
  struct htab *cies;
  unsigned int fde_count;



  
# 469 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 469 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      table;
  struct eh_frame_array_ent *array;
};

struct compact_eh_frame_hdr_info
{
  unsigned int allocated_entries;

  asection **entries;
};

struct eh_frame_hdr_info
{
  asection *hdr_sec;
  unsigned int array_count;
  
# 484 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 484 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      frame_hdr_is_compact;
  union
    {
      struct dwarf_eh_frame_hdr_info dwarf;
      struct compact_eh_frame_hdr_info compact;
    }
  u;
};


struct sframe_func_bfdinfo
{

  
# 497 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 497 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      func_deleted_p;

  unsigned int func_r_offset;

  unsigned int func_reloc_index;
};



struct sframe_dec_info
{

  struct sframe_decoder_ctx *sfd_ctx;

  unsigned int sfd_fde_count;

  struct sframe_func_bfdinfo *sfd_func_bfdinfo;
};




struct sframe_enc_info
{

  struct sframe_encoder_ctx *sfe_ctx;

  asection *sframe_section;
};






enum elf_target_id
{
  AARCH64_ELF_DATA = 1,
  ALPHA_ELF_DATA,
  AMDGCN_ELF_DATA,
  ARC_ELF_DATA,
  ARM_ELF_DATA,
  AVR_ELF_DATA,
  BFIN_ELF_DATA,
  CRIS_ELF_DATA,
  CSKY_ELF_DATA,
  FRV_ELF_DATA,
  HPPA32_ELF_DATA,
  HPPA64_ELF_DATA,
  I386_ELF_DATA,
  IA64_ELF_DATA,
  LM32_ELF_DATA,
  LARCH_ELF_DATA,
  M32R_ELF_DATA,
  M68HC11_ELF_DATA,
  M68K_ELF_DATA,
  METAG_ELF_DATA,
  MICROBLAZE_ELF_DATA,
  MIPS_ELF_DATA,
  MN10300_ELF_DATA,
  NDS32_ELF_DATA,
  NIOS2_ELF_DATA,
  OR1K_ELF_DATA,
  PPC32_ELF_DATA,
  PPC64_ELF_DATA,
  PRU_ELF_DATA,
  S390_ELF_DATA,
  SH_ELF_DATA,
  SPARC_ELF_DATA,
  SPU_ELF_DATA,
  TIC6X_ELF_DATA,
  X86_64_ELF_DATA,
  XTENSA_ELF_DATA,
  TILEGX_ELF_DATA,
  TILEPRO_ELF_DATA,
  RISCV_ELF_DATA,
  GENERIC_ELF_DATA
};

struct elf_sym_strtab
{
  Elf_Internal_Sym sym;
  unsigned long dest_index;
};

struct bfd_link_needed_list
{
  struct bfd_link_needed_list *next;
  bfd *by;
  const char *name;
};

enum elf_target_os
{
  is_normal,
  is_solaris,
  is_vxworks,
  is_nacl
};




struct sym_cache
{
  bfd *abfd;
  unsigned long indx[32];
  Elf_Internal_Sym sym[32];
};



struct elf_link_hash_table
{
  struct bfd_link_hash_table root;



  enum elf_target_id hash_table_id;



  
# 619 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 619 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      dynamic_sections_created;


  
# 622 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 622 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      dynamic_relocs;



  
# 626 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 626 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      is_relocatable_executable;


  
# 629 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 629 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      ifunc_resolvers;


  
# 632 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 632 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      dt_pltgot_required;


  
# 635 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 635 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      dt_jmprel_required;


  
# 638 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 638 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      handling_dt_needed;




  bfd *dynobj;





  union gotplt_union init_got_refcount;
  union gotplt_union init_plt_refcount;



  union gotplt_union init_got_offset;
  union gotplt_union init_plt_offset;



  bfd_size_type dynsymcount;
  bfd_size_type local_dynsymcount;



  struct elf_strtab_hash *dynstr;



  bfd_size_type strtabsize;


  struct elf_sym_strtab *strtab;



  bfd_size_type bucketcount;



  struct bfd_link_needed_list *needed;




  asection *text_index_section;
  asection *data_index_section;


  struct elf_link_hash_entry *hgot;


  struct elf_link_hash_entry *hplt;


  struct elf_link_hash_entry *hdynamic;


  void *merge_info;


  struct stab_info stab_info;


  struct eh_frame_hdr_info eh_info;


  struct sframe_enc_info sfe_info;


  struct elf_link_local_dynamic_entry *dynlocal;



  struct bfd_link_needed_list *runpath;


  asection *tls_sec;
  bfd_size_type tls_size;





  bfd_vma tlsdesc_plt;




  bfd_vma tlsdesc_got;


  enum elf_target_os target_os;


  struct elf_link_loaded_list *dyn_loaded;


  struct sym_cache sym_cache;


  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;
  asection *sdynrelro;
  asection *sreldynrelro;
  asection *igotplt;
  asection *iplt;
  asection *irelplt;
  asection *irelifunc;
  asection *dynsym;
  asection *srelrdyn;
};



static inline 
# 759 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
             _Bool

# 760 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
is_elf_hash_table (const struct bfd_link_hash_table *htab)
{
  return htab->type == bfd_link_elf_hash_table;
}



static inline struct elf_link_hash_entry *
elf_link_hash_lookup (struct elf_link_hash_table *table, const char *string,
        
# 769 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
       _Bool 
# 769 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
            create, 
# 769 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                    _Bool 
# 769 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                         copy, 
# 769 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                               _Bool 
# 769 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                    follow)
{
  if (1 && !is_elf_hash_table (&table->root))
    _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elf-bfd.h", 772, __PRETTY_FUNCTION__);
  return (struct elf_link_hash_entry *)
    bfd_link_hash_lookup (&table->root, string, create, copy, follow);
}



static inline void
elf_link_hash_traverse (struct elf_link_hash_table *table,
   
# 781 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
  _Bool 
# 781 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
       (*f) (struct elf_link_hash_entry *, void *),
   void *info)
{
  if (1 && !is_elf_hash_table (&table->root))
    _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elf-bfd.h", 785, __PRETTY_FUNCTION__);
  bfd_link_hash_traverse (&table->root,
     (
# 787 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
     _Bool 
# 787 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
          (*) (struct bfd_link_hash_entry *, void *)) f,
     info);
}



static inline struct elf_link_hash_table *
elf_hash_table (const struct bfd_link_info *info)
{
  return (struct elf_link_hash_table *) info->hash;
}

static inline enum elf_target_id
elf_hash_table_id (const struct elf_link_hash_table *table)
{
  return table->hash_table_id;
}



struct elf_size_info {
  unsigned char sizeof_ehdr, sizeof_phdr, sizeof_shdr;
  unsigned char sizeof_rel, sizeof_rela, sizeof_sym, sizeof_dyn, sizeof_note;


  unsigned char sizeof_hash_entry;



  unsigned char int_rels_per_ext_rel;




  unsigned char arch_size, log_file_align;
  unsigned char elfclass, ev_current;
  int (*write_out_phdrs)
    (bfd *, const Elf_Internal_Phdr *, unsigned int);
  
# 825 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 825 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*write_shdrs_and_ehdr) (bfd *);
  
# 826 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 826 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*checksum_contents)
    (bfd * , void (*) (const void *, size_t, void *), void *);
  void (*write_relocs)
    (bfd *, asection *, void *);
  
# 830 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 830 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*swap_symbol_in)
    (bfd *, const void *, const void *, Elf_Internal_Sym *);
  void (*swap_symbol_out)
    (bfd *, const Elf_Internal_Sym *, void *, void *);
  
# 834 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 834 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*slurp_reloc_table)
    (bfd *, asection *, asymbol **, 
# 835 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                   _Bool
# 835 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                       );
  long (*slurp_symbol_table)
    (bfd *, asymbol **, 
# 837 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                       _Bool
# 837 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                           );
  void (*swap_dyn_in)
    (bfd *, const void *, Elf_Internal_Dyn *);
  void (*swap_dyn_out)
    (bfd *, const Elf_Internal_Dyn *, void *);




  void (*swap_reloc_in)
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);


  void (*swap_reloc_out)
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);




  void (*swap_reloca_in)
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);


  void (*swap_reloca_out)
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);
};
# 872 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
enum elf_reloc_type_class {
  reloc_class_normal,
  reloc_class_relative,
  reloc_class_copy,
  reloc_class_ifunc,
  reloc_class_plt
};

struct elf_reloc_cookie
{
  Elf_Internal_Rela *rels, *rel, *relend;
  Elf_Internal_Sym *locsyms;
  bfd *abfd;
  size_t locsymcount;
  size_t extsymoff;
  struct elf_link_hash_entry **sym_hashes;
  int r_sym_shift;
  
# 889 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 889 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      bad_symtab;
};



typedef enum {
  ict_none,
  ict_irix5,
  ict_irix6
} irix_compat_t;


struct bfd_elf_special_section
{
  const char *prefix;
  unsigned int prefix_length;






  signed int suffix_length;
  unsigned int type;
  bfd_vma attr;
};

enum action_discarded
  {
    COMPLAIN = 1,
    PRETEND = 2
  };

typedef asection * (*elf_gc_mark_hook_fn)
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

enum elf_property_kind
 {

    property_unknown = 0,

    property_ignored,

    property_corrupt,

    property_remove,

    property_number
 };

typedef struct elf_property
{
  unsigned int pr_type;
  unsigned int pr_datasz;
  union
    {

      bfd_vma number;

    } u;
  enum elf_property_kind pr_kind;
} elf_property;

typedef struct elf_property_list
{
  struct elf_property_list *next;
  struct elf_property property;
} elf_property_list;

struct bfd_elf_section_reloc_data;

struct elf_backend_data
{

  enum bfd_architecture arch;



  enum elf_target_id target_id;


  enum elf_target_os target_os;


  int elf_machine_code;


  int elf_osabi;


  bfd_vma maxpagesize;




  bfd_vma minpagesize;


  bfd_vma commonpagesize;



  bfd_vma p_align;


  flagword dynamic_sec_flags;



  const void *arch_data;



  
# 1003 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1003 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_info_to_howto)
    (bfd *, arelent *, Elf_Internal_Rela *);



  
# 1008 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1008 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_info_to_howto_rel)
    (bfd *, arelent *, Elf_Internal_Rela *);






  
# 1016 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1016 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_sym_is_global)
    (bfd *, asymbol *);
# 1028 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  
# 1028 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1028 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_object_p)
    (bfd *);




  void (*elf_backend_symbol_processing)
    (bfd *, asymbol *);



  
# 1039 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1039 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_symbol_table_processing)
    (bfd *, elf_symbol_type *, unsigned int);



  int (*elf_backend_get_symbol_type)
    (Elf_Internal_Sym *, int);



  struct bfd_link_hash_entry * (*elf_backend_archive_symbol_lookup)
    (bfd *, struct bfd_link_info *, const char *);



  
# 1054 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1054 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_name_local_section_symbols)
    (bfd *);





  
# 1061 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1061 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_section_processing)
    (bfd *, Elf_Internal_Shdr *);



  
# 1066 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1066 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_section_from_shdr)
    (bfd *, Elf_Internal_Shdr *, const char *, int);



  
# 1071 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1071 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_section_flags)
    (const Elf_Internal_Shdr *);



  const struct bfd_elf_special_section * (*get_sec_type_attr)
    (bfd *, asection *);



  
# 1081 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1081 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_section_from_phdr)
    (bfd *, Elf_Internal_Phdr *, int, const char *);




  
# 1087 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1087 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_fake_sections)
    (bfd *, Elf_Internal_Shdr *, asection *);





  
# 1094 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1094 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_section_from_bfd_section)
    (bfd *, asection *, int *retval);
# 1105 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  
# 1105 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1105 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_add_symbol_hook)
    (bfd *abfd, struct bfd_link_info *info, Elf_Internal_Sym *,
     const char **name, flagword *flags, asection **sec, bfd_vma *value);





  int (*elf_backend_link_output_symbol_hook)
    (struct bfd_link_info *info, const char *, Elf_Internal_Sym *,
     asection *, struct elf_link_hash_entry *);
# 1125 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  
# 1125 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1125 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_create_dynamic_sections)
    (bfd *abfd, struct bfd_link_info *info);



  
# 1130 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1130 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_omit_section_dynsym)
    (bfd *output_bfd, struct bfd_link_info *info, asection *osec);



  
# 1135 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1135 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*relocs_compatible) (const bfd_target *, const bfd_target *);
# 1145 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  
# 1145 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1145 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*check_relocs)
    (bfd *abfd, struct bfd_link_info *info, asection *o,
     const Elf_Internal_Rela *relocs);



  
# 1151 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1151 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*size_relative_relocs)
    (struct bfd_link_info *info, 
# 1152 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                _Bool 
# 1152 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                     *need_layout);



  
# 1156 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1156 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*finish_relative_relocs)
    (struct bfd_link_info *info);





  
# 1163 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1163 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*check_directives)
    (bfd *abfd, struct bfd_link_info *info);





  
# 1170 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1170 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*notice_as_needed)
    (bfd *abfd, struct bfd_link_info *info, enum notice_asneeded_action act);
# 1185 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  
# 1185 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1185 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_adjust_dynamic_symbol)
    (struct bfd_link_info *info, struct elf_link_hash_entry *h);





  
# 1192 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1192 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_always_size_sections)
    (bfd *output_bfd, struct bfd_link_info *info);
# 1205 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  
# 1205 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1205 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_size_dynamic_sections)
    (bfd *output_bfd, struct bfd_link_info *info);




  
# 1211 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1211 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_strip_zero_sized_dynamic_sections)
    (struct bfd_link_info *info);



  void (*elf_backend_init_index_section)
    (bfd *output_bfd, struct bfd_link_info *info);
# 1250 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  int (*elf_backend_relocate_section)
    (bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd,
     asection *input_section, bfd_byte *contents, Elf_Internal_Rela *relocs,
     Elf_Internal_Sym *local_syms, asection **local_sections);
# 1262 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  
# 1262 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1262 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_finish_dynamic_symbol)
    (bfd *output_bfd, struct bfd_link_info *info,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *sym);





  
# 1270 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1270 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_finish_dynamic_sections)
    (bfd *output_bfd, struct bfd_link_info *info);



  void (*elf_backend_begin_write_processing)
    (bfd *, struct bfd_link_info *);



  
# 1280 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1280 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_final_write_processing)
    (bfd *);




  int (*elf_backend_additional_program_headers)
    (bfd *, struct bfd_link_info *);



  
# 1291 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1291 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_modify_segment_map)
    (bfd *, struct bfd_link_info *);



  
# 1296 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1296 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_modify_headers)
    (bfd *, struct bfd_link_info *);



  
# 1301 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1301 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_allow_non_load_phdr)
    (bfd *, const Elf_Internal_Phdr *, unsigned);



  void (*gc_keep)
    (struct bfd_link_info *);



  
# 1311 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1311 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*gc_mark_dynamic_ref)
    (struct elf_link_hash_entry *, void *);



  elf_gc_mark_hook_fn gc_mark_hook;



  
# 1320 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1320 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*gc_mark_extra_sections)
    (struct bfd_link_info *, elf_gc_mark_hook_fn);



  
# 1325 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1325 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_init_file_header)
    (bfd *, struct bfd_link_info *);




  const char *(*elf_backend_print_symbol_all)
    (bfd *, void *, asymbol *);





  
# 1338 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1338 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_output_arch_local_syms)
    (bfd *, struct bfd_link_info *, void *,
     int (*) (void *, const char *, Elf_Internal_Sym *, asection *,
       struct elf_link_hash_entry *));




  
# 1346 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1346 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_output_arch_syms)
    (bfd *, struct bfd_link_info *, void *,
     int (*) (void *, const char *, Elf_Internal_Sym *, asection *,
       struct elf_link_hash_entry *));



  unsigned int (*elf_backend_filter_implib_symbols)
    (bfd *, struct bfd_link_info *, asymbol **, long);






  void (*elf_backend_copy_indirect_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *,
     struct elf_link_hash_entry *);



  void (*elf_backend_hide_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *, 
# 1368 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                                          _Bool
# 1368 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                              );



  
# 1372 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1372 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_fixup_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *);


  void (*elf_backend_merge_symbol_attribute)
    (struct elf_link_hash_entry *, unsigned int, 
# 1377 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                                _Bool
# 1377 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                    , 
# 1377 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                                      _Bool
# 1377 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                          );



  char *(*elf_backend_get_target_dtag)
    (bfd_vma);



  
# 1386 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1386 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_ignore_undef_symbol)
    (struct elf_link_hash_entry *);



  
# 1391 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1391 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_emit_relocs)
    (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *,
     struct elf_link_hash_entry **);



  void (*elf_backend_update_relocs)
    (asection *, struct bfd_elf_section_reloc_data *);



  unsigned int (*elf_backend_count_relocs)
    (struct bfd_link_info *, asection *);



  unsigned int (*elf_backend_count_additional_relocs)
    (asection *);



  
# 1412 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1412 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*sort_relocs_p)
    (asection *);



  
# 1417 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1417 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_grok_prstatus)
    (bfd *, Elf_Internal_Note *);



  
# 1422 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1422 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_grok_psinfo)
    (bfd *, Elf_Internal_Note *);



  
# 1427 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1427 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_grok_freebsd_prstatus)
    (bfd *, Elf_Internal_Note *);


  char *(*elf_backend_write_core_note)
    (bfd *abfd, char *buf, int *bufsiz, int note_type, ...);



  flagword (*elf_backend_lookup_section_flags_hook)
    (char *);


  enum elf_reloc_type_class (*elf_backend_reloc_type_class)
  (const struct bfd_link_info *, const asection *, const Elf_Internal_Rela *);



  
# 1445 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1445 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_discard_info)
    (bfd *, struct elf_reloc_cookie *, struct bfd_link_info *);



  
# 1450 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1450 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_ignore_discarded_relocs)
    (asection *);



  unsigned int (*action_discarded)
    (asection *);




  unsigned int (*elf_backend_eh_frame_address_size)
    (bfd *, const asection *);




  
# 1467 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1467 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_can_make_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);
  
# 1469 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1469 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_can_make_lsda_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);


  
# 1473 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1473 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      elf_backend_can_make_multiple_eh_frame;





  bfd_byte (*elf_backend_encode_eh_address)
     (bfd *abfd, struct bfd_link_info *info,
      asection *osec, bfd_vma offset,
      asection *loc_sec, bfd_vma loc_offset,
      bfd_vma *encoded);



  
# 1487 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1487 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_write_section)
    (bfd *, struct bfd_link_info *, asection *, bfd_byte *);






  
# 1495 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1495 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_elfsym_local_is_section)
    (bfd *);



  irix_compat_t (*elf_backend_mips_irix_compat)
    (bfd *);

  reloc_howto_type *(*elf_backend_mips_rtype_to_howto)
    (bfd *, unsigned int, 
# 1504 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                         _Bool
# 1504 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                             );



  const struct ecoff_debug_swap *elf_backend_ecoff_debug_swap;



  bfd *(*elf_backend_bfd_from_remote_memory)
    (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
     int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr,
    bfd_size_type len));

  
# 1517 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1517 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_core_find_build_id) (bfd *, bfd_vma);



  bfd_vma (*plt_sym_val) (bfd_vma, const asection *, const arelent *);


  
# 1524 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1524 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*common_definition) (Elf_Internal_Sym *);


  unsigned int (*common_section_index) (asection *);


  asection *(*common_section) (asection *);


  
# 1533 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1533 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*merge_symbol) (struct elf_link_hash_entry *,
          const Elf_Internal_Sym *, asection **,
          
# 1535 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
         _Bool
# 1535 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
             , 
# 1535 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
               _Bool
# 1535 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                   ,
          bfd *, const asection *);


  
# 1539 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1539 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_hash_symbol) (struct elf_link_hash_entry *);





  void (*record_xhash_symbol)
    (struct elf_link_hash_entry *h, bfd_vma xlat_loc);


  
# 1549 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1549 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*is_function_type) (unsigned int type);




  bfd_size_type (*maybe_function_sym) (const asymbol *sym, asection *sec,
           bfd_vma *code_off);




  asection *(*get_reloc_section) (bfd *abfd, const char *name);







  
# 1568 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1568 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*elf_backend_copy_special_section_fields)
    (const bfd *ibfd, bfd *obfd, const Elf_Internal_Shdr *isection,
     Elf_Internal_Shdr *osection);


  void (*link_order_error_handler) (const char *, ...);


  const char *relplt_name;


  int elf_machine_alt1;
  int elf_machine_alt2;

  const struct elf_size_info *s;


  const struct bfd_elf_special_section *special_sections;



  bfd_vma got_header_size;



  bfd_vma (*got_elt_size) (bfd *, struct bfd_link_info *,
      struct elf_link_hash_entry *h,
      bfd *ibfd, unsigned long symndx);


  const char *obj_attrs_vendor;


  const char *obj_attrs_section;



  int (*obj_attrs_arg_type) (int);


  unsigned int obj_attrs_section_type;






  int (*obj_attrs_order) (int);



  
# 1619 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1619 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*obj_attrs_handle_unknown) (bfd *, int);



  enum elf_property_kind (*parse_gnu_properties) (bfd *, unsigned int,
        bfd_byte *,
        unsigned int);


  
# 1628 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1628 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*merge_gnu_properties) (struct bfd_link_info *, bfd *, bfd *,
           elf_property *, elf_property *);


  bfd *(*setup_gnu_properties) (struct bfd_link_info *);


  void (*fixup_gnu_properties) (struct bfd_link_info *,
    elf_property_list **);


  int (*compact_eh_encoding) (struct bfd_link_info *);


  int (*cant_unwind_opcode) (struct bfd_link_info *);





  unsigned int (*symbol_section_index) (bfd *, elf_symbol_type *);


  
# 1651 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1651 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*init_secondary_reloc_section) (bfd *, Elf_Internal_Shdr *,
     const char *, unsigned int);


  
# 1655 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1655 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*slurp_secondary_relocs) (bfd *, asection *, asymbol **, 
# 1655 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                                                _Bool
# 1655 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                                    );


  
# 1658 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1658 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*write_secondary_relocs) (bfd *, asection *);


  unsigned static_tls_alignment;


  unsigned stack_align;


  unsigned long elf_strtab_flags;





  unsigned collect : 1;





  unsigned type_change_ok : 1;




  unsigned may_use_rel_p : 1;




  unsigned may_use_rela_p : 1;






  unsigned default_use_rela_p : 1;


  unsigned rela_plts_and_copies_p : 1;




  unsigned rela_normal : 1;



  unsigned dtrel_excludes_plt : 1;



  unsigned sign_extend_vma : 1;

  unsigned want_got_plt : 1;
  unsigned plt_readonly : 1;
  unsigned want_plt_sym : 1;
  unsigned plt_not_loaded : 1;
  unsigned plt_alignment : 4;
  unsigned can_gc_sections : 1;
  unsigned can_refcount : 1;
  unsigned want_got_sym : 1;
  unsigned want_dynbss : 1;
  unsigned want_dynrelro : 1;




  unsigned want_p_paddr_set_to_zero : 1;



  unsigned no_page_alias : 1;





  unsigned default_execstack : 1;




  unsigned caches_rawsize : 1;



  unsigned extern_protected_data : 1;



  unsigned always_renumber_dynsyms : 1;



  unsigned linux_prpsinfo32_ugid16 : 1;



  unsigned linux_prpsinfo64_ugid16 : 1;
};



struct bfd_elf_section_reloc_data
{


  Elf_Internal_Shdr *hdr;

  unsigned int count;


  int idx;


  struct elf_link_hash_entry **hashes;
};




struct bfd_elf_section_data
{

  Elf_Internal_Shdr this_hdr;


  struct flag_info *section_flag_info;



  struct bfd_elf_section_reloc_data rel, rela;


  int this_idx;





  int dynindx;


  asection *linked_to;




  Elf_Internal_Rela *relocs;



  void *local_dynrel;


  asection *sreloc;

  union {

    const char *name;


    struct bfd_symbol *id;
  } group;



  asection *sec_group;



  asection *next_in_group;



  struct eh_cie_fde *fde_list;


  asection *eh_frame_entry;




  
# 1844 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1844 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      has_secondary_relocs;


  void *sec_info;
};
# 1882 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
typedef struct obj_attribute
{
# 1894 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  int type;
  unsigned int i;
  char *s;
} obj_attribute;

typedef struct obj_attribute_list
{
  struct obj_attribute_list *next;
  unsigned int tag;
  obj_attribute attr;
} obj_attribute_list;
# 1916 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
enum
{
  Tag_NULL = 0,
  Tag_File = 1,
  Tag_Section = 2,
  Tag_Symbol = 3,
  Tag_compatibility = 32
};



struct sdt_note
{
  struct sdt_note *next;
  bfd_size_type size;
  bfd_byte data[1];
};


struct core_elf_obj_tdata
{
  int signal;
  int pid;
  int lwpid;
  char* program;
  char* command;
};


struct output_elf_obj_tdata
{
  struct elf_segment_map *seg_map;
  struct elf_strtab_hash *strtab_ptr;


  asymbol **section_syms;


  struct
  {
    
# 1956 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
   _Bool 
# 1956 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
        (*after_write_object_contents) (bfd *);
    const char *style;
    asection *sec;
  } build_id;


  struct
  {
    
# 1964 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
   _Bool 
# 1964 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
        (*after_write_object_contents) (bfd *);
    const char *json;
    asection *sec;
  } package_metadata;


  bfd_size_type program_header_size;


  file_ptr next_file_pos;


  struct bfd_link_info *link_info;

  unsigned int num_section_syms;
  unsigned int shstrtab_section, strtab_section;


  unsigned int stack_flags;



  asection *sframe;


  
# 1989 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 1989 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      flags_init;
};




enum elf_gnu_osabi
{
  elf_gnu_osabi_mbind = 1 << 0,
  elf_gnu_osabi_ifunc = 1 << 1,
  elf_gnu_osabi_unique = 1 << 2,
  elf_gnu_osabi_retain = 1 << 3,
};

typedef struct elf_section_list
{
  Elf_Internal_Shdr hdr;
  unsigned int ndx;
  struct elf_section_list * next;
} elf_section_list;

enum dynamic_lib_link_class {
  DYN_NORMAL = 0,
  DYN_AS_NEEDED = 1,
  DYN_DT_NEEDED = 2,
  DYN_NO_ADD_NEEDED = 4,
  DYN_NO_NEEDED = 8
};




struct elf_obj_tdata
{
  Elf_Internal_Ehdr elf_header[1];
  Elf_Internal_Shdr **elf_sect_ptr;
  Elf_Internal_Phdr *phdr;
  Elf_Internal_Shdr symtab_hdr;
  Elf_Internal_Shdr shstrtab_hdr;
  Elf_Internal_Shdr strtab_hdr;
  Elf_Internal_Shdr dynsymtab_hdr;
  Elf_Internal_Shdr dynstrtab_hdr;
  Elf_Internal_Shdr dynversym_hdr;
  Elf_Internal_Shdr dynverref_hdr;
  Elf_Internal_Shdr dynverdef_hdr;
  Elf_Internal_Sym *dt_symtab;
  bfd_byte *dt_versym;
  bfd_byte *dt_verdef;
  bfd_byte *dt_verneed;
  size_t dt_symtab_count;
  size_t dt_verdef_count;
  size_t dt_verneed_count;
  char *dt_strtab;
  elf_section_list * symtab_shndx_list;
  bfd_vma gp;
  unsigned int gp_size;
  unsigned int num_elf_sections;
  unsigned char *being_created;




  struct elf_link_hash_entry **sym_hashes;




  union
    {
      bfd_signed_vma *refcounts;
      bfd_vma *offsets;
      struct got_entry **ents;
    } local_got;
# 2071 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
  const char *dt_name;



  const char *dt_audit;


  void *line_info;


  void *dwarf1_find_line_info;


  void *dwarf2_find_line_info;


  void *elf_find_function_cache;


  unsigned int cverdefs;


  unsigned int cverrefs;


  Elf_Internal_Verdef *verdef;


  Elf_Internal_Verneed *verref;


  asection *eh_frame_section;


  void *symbuf;



  elf_property_list *properties;

  obj_attribute known_obj_attributes[2][77];
  obj_attribute_list *other_obj_attributes[2];




  struct sdt_note *sdt_note_head;

  Elf_Internal_Shdr **group_sect_ptr;
  unsigned int num_group;



  unsigned int group_search_offset;

  unsigned int symtab_section, dynsymtab_section;
  unsigned int dynversym_section, dynverdef_section, dynverref_section;



  __extension__ enum elf_target_id object_id : 6;




  __extension__ enum dynamic_lib_link_class dyn_lib_class : 4;


  __extension__ enum elf_gnu_osabi has_gnu_osabi : 4;



  unsigned int has_no_copy_on_protected : 1;



  unsigned int has_indirect_extern_access : 1;






  unsigned int bad_symtab : 1;


  unsigned int is_pie : 1;


  struct core_elf_obj_tdata *core;


  struct output_elf_obj_tdata *o;
};
# 2218 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
extern void _bfd_elf_swap_verdef_in
  (bfd *, const Elf_External_Verdef *, Elf_Internal_Verdef *);
extern void _bfd_elf_swap_verdef_out
  (bfd *, const Elf_Internal_Verdef *, Elf_External_Verdef *);
extern void _bfd_elf_swap_verdaux_in
  (bfd *, const Elf_External_Verdaux *, Elf_Internal_Verdaux *);
extern void _bfd_elf_swap_verdaux_out
  (bfd *, const Elf_Internal_Verdaux *, Elf_External_Verdaux *);
extern void _bfd_elf_swap_verneed_in
  (bfd *, const Elf_External_Verneed *, Elf_Internal_Verneed *);
extern void _bfd_elf_swap_verneed_out
  (bfd *, const Elf_Internal_Verneed *, Elf_External_Verneed *);
extern void _bfd_elf_swap_vernaux_in
  (bfd *, const Elf_External_Vernaux *, Elf_Internal_Vernaux *);
extern void _bfd_elf_swap_vernaux_out
  (bfd *, const Elf_Internal_Vernaux *, Elf_External_Vernaux *);
extern void _bfd_elf_swap_versym_in
  (bfd *, const Elf_External_Versym *, Elf_Internal_Versym *);
extern void _bfd_elf_swap_versym_out
  (bfd *, const Elf_Internal_Versym *, Elf_External_Versym *);

extern unsigned int _bfd_elf_section_from_bfd_section
  (bfd *, asection *);
extern char *bfd_elf_string_from_elf_section
  (bfd *, unsigned, unsigned);
extern Elf_Internal_Sym *bfd_elf_get_elf_syms
  (bfd *, Elf_Internal_Shdr *, size_t, size_t, Elf_Internal_Sym *, void *,
   Elf_External_Sym_Shndx *);
extern char * bfd_elf_get_str_section (bfd *, unsigned int);
extern const char *bfd_elf_sym_name
  (bfd *, Elf_Internal_Shdr *, Elf_Internal_Sym *, asection *);

extern 
# 2250 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2250 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_copy_private_bfd_data
  (bfd *, bfd *);
extern 
# 2252 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2252 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_print_private_bfd_data
  (bfd *, void *);
const char * _bfd_elf_get_symbol_version_string
  (bfd *, asymbol *, 
# 2255 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                    _Bool
# 2255 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                        , 
# 2255 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                          _Bool 
# 2255 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                               *);
extern void bfd_elf_print_symbol
  (bfd *, void *, asymbol *, bfd_print_symbol_type);

extern unsigned int _bfd_elf_eh_frame_address_size
  (bfd *, const asection *);
extern bfd_byte _bfd_elf_encode_eh_address
  (bfd *abfd, struct bfd_link_info *info, asection *osec, bfd_vma offset,
   asection *loc_sec, bfd_vma loc_offset, bfd_vma *encoded);
extern 
# 2264 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2264 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_can_make_relative
  (bfd *input_bfd, struct bfd_link_info *info, asection *eh_frame_section);

extern enum elf_reloc_type_class _bfd_elf_reloc_type_class
  (const struct bfd_link_info *, const asection *,
   const Elf_Internal_Rela *);
extern bfd_vma _bfd_elf_rela_local_sym
  (bfd *, Elf_Internal_Sym *, asection **, Elf_Internal_Rela *);
extern bfd_vma _bfd_elf_rel_local_sym
  (bfd *, Elf_Internal_Sym *, asection **, bfd_vma);
extern bfd_vma _bfd_elf_section_offset
  (bfd *, struct bfd_link_info *, asection *, bfd_vma);

extern unsigned long bfd_elf_hash
  (const char *);
extern unsigned long bfd_elf_gnu_hash
  (const char *);

extern bfd_reloc_status_type bfd_elf_generic_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
extern 
# 2284 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2284 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_allocate_object
  (bfd *, size_t, enum elf_target_id);
extern 
# 2286 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2286 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_make_object
  (bfd *);
extern 
# 2288 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2288 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_mkcorefile
  (bfd *);
extern 
# 2290 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2290 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_make_section_from_shdr
  (bfd *, Elf_Internal_Shdr *, const char *, int);
extern 
# 2292 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2292 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_make_section_from_phdr
  (bfd *, Elf_Internal_Phdr *, int, const char *);
extern struct bfd_hash_entry *_bfd_elf_link_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
extern struct bfd_link_hash_table *_bfd_elf_link_hash_table_create
  (bfd *);
extern void _bfd_elf_link_hash_table_free
  (bfd *);
extern void _bfd_elf_link_hash_copy_indirect
  (struct bfd_link_info *, struct elf_link_hash_entry *,
   struct elf_link_hash_entry *);
extern void _bfd_elf_link_hash_hide_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *, 
# 2304 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                                        _Bool
# 2304 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                            );
extern void _bfd_elf_link_hide_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
extern 
# 2307 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2307 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_link_hash_fixup_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);
extern 
# 2309 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2309 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *, bfd *,
   struct bfd_hash_entry *(*)
     (struct bfd_hash_entry *, struct bfd_hash_table *, const char *),
   unsigned int, enum elf_target_id);
extern 
# 2314 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2314 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_slurp_version_tables
  (bfd *, 
# 2315 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
         _Bool
# 2315 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
             );
extern 
# 2316 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2316 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_merge_sections
  (bfd *, struct bfd_link_info *);
extern 
# 2318 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2318 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_match_sections_by_type
  (bfd *, const asection *, bfd *, const asection *);
extern 
# 2320 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2320 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_is_group_section
  (bfd *, const struct bfd_section *);
extern const char *bfd_elf_group_name
  (bfd *, const struct bfd_section *);
extern 
# 2324 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2324 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_section_already_linked
  (bfd *, asection *, struct bfd_link_info *);
extern void bfd_elf_set_group_contents
  (bfd *, asection *, void *);
extern unsigned int _bfd_elf_filter_global_symbols
  (bfd *, struct bfd_link_info *, asymbol **, long);
extern asection *_bfd_elf_check_kept_section
  (asection *, struct bfd_link_info *);

extern void _bfd_elf_copy_link_hash_symbol_type
  (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
extern 
# 2335 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2335 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_size_group_sections
  (struct bfd_link_info *);
extern 
# 2337 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2337 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_fixup_group_sections
(bfd *, asection *);
extern 
# 2339 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2339 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_copy_private_header_data
  (bfd *, bfd *);
extern 
# 2341 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2341 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_copy_private_symbol_data
  (bfd *, asymbol *, bfd *, asymbol *);


extern 
# 2345 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2345 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_init_private_section_data
  (bfd *, asection *, bfd *, asection *, struct bfd_link_info *);
extern 
# 2347 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2347 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_copy_private_section_data
  (bfd *, asection *, bfd *, asection *);
extern 
# 2349 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2349 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_write_object_contents
  (bfd *);
extern 
# 2351 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2351 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_write_corefile_contents
  (bfd *);
extern 
# 2353 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2353 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_set_section_contents
  (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
extern long _bfd_elf_get_symtab_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_symtab
  (bfd *, asymbol **);
extern long _bfd_elf_get_dynamic_symtab_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_dynamic_symtab
  (bfd *, asymbol **);
extern long _bfd_elf_get_synthetic_symtab
  (bfd *, long, asymbol **, long, asymbol **, asymbol **);
extern long _bfd_elf_get_reloc_upper_bound
  (bfd *, sec_ptr);
extern long _bfd_elf_canonicalize_reloc
  (bfd *, sec_ptr, arelent **, asymbol **);
extern asection * _bfd_elf_get_dynamic_reloc_section
  (bfd *, asection *, 
# 2370 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                     _Bool
# 2370 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                         );
extern asection * _bfd_elf_make_dynamic_reloc_section
  (asection *, bfd *, unsigned int, bfd *, 
# 2372 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                          _Bool
# 2372 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                              );
extern long _bfd_elf_get_dynamic_reloc_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_dynamic_reloc
  (bfd *, arelent **, asymbol **);
extern asymbol *_bfd_elf_make_empty_symbol
  (bfd *);
extern void _bfd_elf_get_symbol_info
  (bfd *, asymbol *, symbol_info *);
extern 
# 2381 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2381 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_is_local_label_name
  (bfd *, const char *);
extern alent *_bfd_elf_get_lineno
  (bfd *, asymbol *);
extern 
# 2385 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2385 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_set_arch_mach
  (bfd *, enum bfd_architecture, unsigned long);
extern 
# 2387 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2387 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_find_nearest_line
  (bfd *, asymbol **, asection *, bfd_vma,
   const char **, const char **, unsigned int *, unsigned int *);
extern 
# 2390 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2390 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_find_nearest_line_with_alt
  (bfd *, const char *, asymbol **, asection *, bfd_vma,
   const char **, const char **, unsigned int *, unsigned int *);
extern 
# 2393 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2393 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_find_line
  (bfd *, asymbol **, asymbol *, const char **, unsigned int *);
extern 
# 2395 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2395 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_find_inliner_info
  (bfd *, const char **, const char **, unsigned int *);
extern asymbol *_bfd_elf_find_function
  (bfd *, asymbol **, asection *, bfd_vma, const char **, const char **);


extern int _bfd_elf_sizeof_headers
  (bfd *, struct bfd_link_info *);
extern 
# 2403 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2403 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_new_section_hook
  (bfd *, asection *);
extern const struct bfd_elf_special_section *_bfd_elf_get_special_section
  (const char *, const struct bfd_elf_special_section *, unsigned int);
extern const struct bfd_elf_special_section *_bfd_elf_get_sec_type_attr
  (bfd *, asection *);

extern 
# 2410 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2410 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_link_hide_sym_by_version
  (struct bfd_link_info *, struct elf_link_hash_entry *);


extern 
# 2414 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2414 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_no_info_to_howto
  (bfd *, arelent *, Elf_Internal_Rela *);

extern 
# 2417 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2417 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_section_from_shdr
  (bfd *, unsigned int shindex);
extern 
# 2419 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2419 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_section_from_phdr
  (bfd *, Elf_Internal_Phdr *, int);

extern int _bfd_elf_symbol_from_bfd_symbol
  (bfd *, asymbol **);

extern Elf_Internal_Sym *bfd_sym_from_r_symndx
  (struct sym_cache *, bfd *, unsigned long);
extern asection *bfd_section_from_elf_index
  (bfd *, unsigned int);

extern struct elf_strtab_hash * _bfd_elf_strtab_init
  (void);
extern void _bfd_elf_strtab_free
  (struct elf_strtab_hash *);
extern size_t _bfd_elf_strtab_add
  (struct elf_strtab_hash *, const char *, 
# 2435 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                          _Bool
# 2435 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                              );
extern void _bfd_elf_strtab_addref
  (struct elf_strtab_hash *, size_t);
extern void _bfd_elf_strtab_delref
  (struct elf_strtab_hash *, size_t);
extern unsigned int _bfd_elf_strtab_refcount
  (struct elf_strtab_hash *, size_t);
extern void _bfd_elf_strtab_clear_all_refs
  (struct elf_strtab_hash *);
extern void *_bfd_elf_strtab_save
  (struct elf_strtab_hash *);
extern void _bfd_elf_strtab_restore
  (struct elf_strtab_hash *, void *);
extern bfd_size_type _bfd_elf_strtab_size
  (struct elf_strtab_hash *);
extern bfd_size_type _bfd_elf_strtab_len
  (struct elf_strtab_hash *);
extern bfd_size_type _bfd_elf_strtab_offset
  (struct elf_strtab_hash *, size_t);
extern const char * _bfd_elf_strtab_str
  (struct elf_strtab_hash *, size_t idx, bfd_size_type *offset);
extern 
# 2456 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2456 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_strtab_emit
  (bfd *, struct elf_strtab_hash *);
extern void _bfd_elf_strtab_finalize
  (struct elf_strtab_hash *);

extern 
# 2461 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2461 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_parse_eh_frame_entries
  (bfd *, struct bfd_link_info *);
extern 
# 2463 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2463 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_parse_eh_frame_entry
  (struct bfd_link_info *, asection *, struct elf_reloc_cookie *);
extern void _bfd_elf_parse_eh_frame
  (bfd *, struct bfd_link_info *, asection *, struct elf_reloc_cookie *);
extern 
# 2467 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2467 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_end_eh_frame_parsing
  (struct bfd_link_info *info);

extern 
# 2470 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2470 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_discard_section_eh_frame
  (bfd *, struct bfd_link_info *, asection *,
   
# 2472 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
  _Bool 
# 2472 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
       (*) (bfd_vma, void *), struct elf_reloc_cookie *);
extern 
# 2473 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2473 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_adjust_eh_frame_global_symbol
  (struct elf_link_hash_entry *, void *);
extern 
# 2475 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2475 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_discard_section_eh_frame_hdr
  (struct bfd_link_info *);
extern bfd_vma _bfd_elf_eh_frame_section_offset
  (bfd *, struct bfd_link_info *, asection *, bfd_vma);
extern 
# 2479 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2479 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_write_section_eh_frame
  (bfd *, struct bfd_link_info *, asection *, bfd_byte *);

# 2481 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
_Bool 
# 2481 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
    _bfd_elf_write_section_eh_frame_entry
  (bfd *, struct bfd_link_info *, asection *, bfd_byte *);
extern 
# 2483 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2483 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_fixup_eh_frame_hdr (struct bfd_link_info *);
extern 
# 2484 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2484 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_write_section_eh_frame_hdr
  (bfd *, struct bfd_link_info *);
extern 
# 2486 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2486 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_eh_frame_present
  (struct bfd_link_info *);
extern 
# 2488 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2488 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_eh_frame_entry_present
  (struct bfd_link_info *);
extern 
# 2490 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2490 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_maybe_strip_eh_frame_hdr
  (struct bfd_link_info *);

extern 
# 2493 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2493 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_sframe_present
  (struct bfd_link_info *);
extern 
# 2495 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2495 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_parse_sframe
  (bfd *, struct bfd_link_info *, asection *, struct elf_reloc_cookie *);
extern 
# 2497 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2497 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_discard_section_sframe
  (asection *, 
# 2498 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
              _Bool 
# 2498 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                   (*) (bfd_vma, void *), struct elf_reloc_cookie *);
extern 
# 2499 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2499 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_merge_section_sframe
  (bfd *, struct bfd_link_info *, asection *, bfd_byte *);
extern 
# 2501 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2501 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_write_section_sframe
  (bfd *, struct bfd_link_info *);
extern 
# 2503 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2503 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_set_section_sframe (bfd *, struct bfd_link_info *);

extern 
# 2505 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2505 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_hash_symbol (struct elf_link_hash_entry *);

extern long _bfd_elf_link_lookup_local_dynindx
  (struct bfd_link_info *, bfd *, long);
extern 
# 2509 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2509 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_compute_section_file_positions
  (bfd *, struct bfd_link_info *);
extern file_ptr _bfd_elf_assign_file_position_for_section
  (Elf_Internal_Shdr *, file_ptr, 
# 2512 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                 _Bool
# 2512 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                     );
extern 
# 2513 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2513 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_modify_headers
  (bfd *, struct bfd_link_info *);

extern 
# 2516 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2516 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_validate_reloc
  (bfd *, arelent *);

extern 
# 2519 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2519 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *, 
# 2520 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                               _Bool
# 2520 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                   ,
   
# 2521 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
  _Bool
# 2521 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      );
extern 
# 2522 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2522 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_stack_segment_size (bfd *, struct bfd_link_info *,
     const char *, bfd_vma);
extern 
# 2524 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2524 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_size_dynamic_sections
  (bfd *, const char *, const char *, const char *, const char *, const char *,
   const char * const *, struct bfd_link_info *, struct bfd_section **);
extern 
# 2527 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2527 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_size_dynsym_hash_dynstr
  (bfd *, struct bfd_link_info *);
extern 
# 2529 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2529 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_get_bfd_needed_list
  (bfd *, struct bfd_link_needed_list **);
extern struct bfd_link_needed_list *bfd_elf_get_needed_list
  (bfd *, struct bfd_link_info *);
extern void bfd_elf_set_dt_needed_name
  (bfd *, const char *);
extern const char *bfd_elf_get_dt_soname
  (bfd *);
extern void bfd_elf_set_dyn_lib_class
  (bfd *, enum dynamic_lib_link_class);
extern int bfd_elf_get_dyn_lib_class
  (bfd *);
extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
  (bfd *, struct bfd_link_info *);
extern int bfd_elf_discard_info
  (bfd *, struct bfd_link_info *);
extern unsigned int _bfd_elf_default_action_discarded
  (struct bfd_section *);
extern struct bfd_section *_bfd_elf_tls_setup
  (bfd *, struct bfd_link_info *);

extern 
# 2550 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2550 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_link_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern 
# 2552 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2552 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_omit_section_dynsym_default
  (bfd *, struct bfd_link_info *, asection *);
extern 
# 2554 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2554 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_omit_section_dynsym_all
  (bfd *, struct bfd_link_info *, asection *);
extern 
# 2556 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2556 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern 
# 2558 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2558 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_create_got_section
  (bfd *, struct bfd_link_info *);
extern asection *_bfd_elf_section_for_symbol
  (struct elf_reloc_cookie *, unsigned long, 
# 2561 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                            _Bool
# 2561 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                );
extern struct elf_link_hash_entry *_bfd_elf_define_linkage_sym
  (bfd *, struct bfd_link_info *, asection *, const char *);
extern void _bfd_elf_init_1_index_section
  (bfd *, struct bfd_link_info *);
extern void _bfd_elf_init_2_index_sections
  (bfd *, struct bfd_link_info *);

extern 
# 2569 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2569 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elfcore_make_pseudosection
  (bfd *, char *, size_t, ufile_ptr);
extern char *_bfd_elfcore_strndup
  (bfd *, char *, size_t);

extern Elf_Internal_Rela *_bfd_elf_link_read_relocs
  (bfd *, asection *, void *, Elf_Internal_Rela *, 
# 2575 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                                  _Bool
# 2575 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                      );
extern Elf_Internal_Rela *_bfd_elf_link_info_read_relocs
  (bfd *, struct bfd_link_info *, asection *, void *, Elf_Internal_Rela *,
   
# 2578 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
  _Bool
# 2578 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      );

extern 
# 2580 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2580 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_link_output_relocs
  (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *,
   struct elf_link_hash_entry **);

extern 
# 2584 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2584 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_adjust_dynamic_copy
  (struct bfd_link_info *, struct elf_link_hash_entry *, asection *);

extern 
# 2587 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2587 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_dynamic_symbol_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, 
# 2588 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                                        _Bool
# 2588 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                            );

extern 
# 2590 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2590 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_symbol_refs_local_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, 
# 2591 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                                        _Bool
# 2591 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                                            );

extern bfd_reloc_status_type bfd_elf_perform_complex_relocation
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, bfd_vma);

extern 
# 2596 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2596 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_setup_sections
  (bfd *);

extern 
# 2599 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2599 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_get_dynamic_symbols
  (bfd *, Elf_Internal_Phdr *, Elf_Internal_Phdr *, size_t,
   bfd_size_type);
extern asection *_bfd_elf_get_section_from_dynamic_symbol
  (bfd *, Elf_Internal_Sym *);

extern struct bfd_link_hash_entry *bfd_elf_define_start_stop
  (struct bfd_link_info *, const char *, asection *);

extern 
# 2608 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2608 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_init_file_header (bfd *, struct bfd_link_info *);

extern 
# 2610 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2610 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_final_write_processing (bfd *);

extern bfd_cleanup bfd_elf32_object_p
  (bfd *);
extern bfd_cleanup bfd_elf32_core_file_p
  (bfd *);
extern char *bfd_elf32_core_file_failing_command
  (bfd *);
extern int bfd_elf32_core_file_failing_signal
  (bfd *);
extern 
# 2620 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2620 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf32_core_file_matches_executable_p
  (bfd *, bfd *);
extern int bfd_elf32_core_file_pid
  (bfd *);
extern 
# 2624 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2624 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf32_core_find_build_id
  (bfd *, bfd_vma);

extern 
# 2627 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2627 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf32_swap_symbol_in
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
extern void bfd_elf32_swap_symbol_out
  (bfd *, const Elf_Internal_Sym *, void *, void *);
extern void bfd_elf32_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf32_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf32_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf32_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf32_swap_phdr_in
  (bfd *, const Elf32_External_Phdr *, Elf_Internal_Phdr *);
extern void bfd_elf32_swap_phdr_out
  (bfd *, const Elf_Internal_Phdr *, Elf32_External_Phdr *);
extern void bfd_elf32_swap_dyn_in
  (bfd *, const void *, Elf_Internal_Dyn *);
extern void bfd_elf32_swap_dyn_out
  (bfd *, const Elf_Internal_Dyn *, void *);
extern long bfd_elf32_slurp_symbol_table
  (bfd *, asymbol **, 
# 2648 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                     _Bool
# 2648 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                         );
extern 
# 2649 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2649 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf32_write_shdrs_and_ehdr
  (bfd *);
extern int bfd_elf32_write_out_phdrs
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
extern 
# 2653 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2653 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf32_checksum_contents
  (bfd * , void (*) (const void *, size_t, void *), void *);
extern void bfd_elf32_write_relocs
  (bfd *, asection *, void *);
extern 
# 2657 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2657 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf32_slurp_reloc_table
  (bfd *, asection *, asymbol **, 
# 2658 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                 _Bool
# 2658 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                     );

extern bfd_cleanup bfd_elf64_object_p
  (bfd *);
extern bfd_cleanup bfd_elf64_core_file_p
  (bfd *);
extern char *bfd_elf64_core_file_failing_command
  (bfd *);
extern int bfd_elf64_core_file_failing_signal
  (bfd *);
extern 
# 2668 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2668 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf64_core_file_matches_executable_p
  (bfd *, bfd *);
extern int bfd_elf64_core_file_pid
  (bfd *);
extern 
# 2672 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2672 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf64_core_find_build_id
  (bfd *, bfd_vma);

extern 
# 2675 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2675 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf64_swap_symbol_in
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
extern void bfd_elf64_swap_symbol_out
  (bfd *, const Elf_Internal_Sym *, void *, void *);
extern void bfd_elf64_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf64_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf64_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf64_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf64_swap_phdr_in
  (bfd *, const Elf64_External_Phdr *, Elf_Internal_Phdr *);
extern void bfd_elf64_swap_phdr_out
  (bfd *, const Elf_Internal_Phdr *, Elf64_External_Phdr *);
extern void bfd_elf64_swap_dyn_in
  (bfd *, const void *, Elf_Internal_Dyn *);
extern void bfd_elf64_swap_dyn_out
  (bfd *, const Elf_Internal_Dyn *, void *);
extern long bfd_elf64_slurp_symbol_table
  (bfd *, asymbol **, 
# 2696 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                     _Bool
# 2696 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                         );
extern 
# 2697 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2697 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf64_write_shdrs_and_ehdr
  (bfd *);
extern int bfd_elf64_write_out_phdrs
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
extern 
# 2701 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2701 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf64_checksum_contents
  (bfd * , void (*) (const void *, size_t, void *), void *);
extern void bfd_elf64_write_relocs
  (bfd *, asection *, void *);
extern 
# 2705 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2705 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf64_slurp_reloc_table
  (bfd *, asection *, asymbol **, 
# 2706 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                 _Bool
# 2706 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                     );

extern 
# 2708 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2708 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_default_relocs_compatible
  (const bfd_target *, const bfd_target *);

extern 
# 2711 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2711 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_relocs_compatible
  (const bfd_target *, const bfd_target *);
extern 
# 2713 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2713 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_notice_as_needed
  (bfd *, struct bfd_link_info *, enum notice_asneeded_action);

extern struct bfd_link_hash_entry *_bfd_elf_archive_symbol_lookup
  (bfd *, struct bfd_link_info *, const char *);
extern 
# 2718 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2718 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_link_add_symbols
  (bfd *, struct bfd_link_info *);
extern 
# 2720 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2720 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_add_dynamic_entry
  (struct bfd_link_info *, bfd_vma, bfd_vma);
extern 
# 2722 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2722 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_strip_zero_sized_dynamic_sections
  (struct bfd_link_info *);
extern int bfd_elf_add_dt_needed_tag
  (bfd *, struct bfd_link_info *);
extern 
# 2726 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2726 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_link_check_relocs
  (bfd *, struct bfd_link_info *);
extern 
# 2728 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2728 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_link_iterate_on_relocs
 (bfd *, struct bfd_link_info *,
  
# 2730 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
 _Bool 
# 2730 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
      (*) (bfd *, struct bfd_link_info *, asection *,
     const Elf_Internal_Rela *));

extern 
# 2733 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2733 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_link_record_dynamic_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);

extern int bfd_elf_link_record_local_dynamic_symbol
  (struct bfd_link_info *, bfd *, long);

extern 
# 2739 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2739 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_free_cached_info
  (bfd *);

extern 
# 2742 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2742 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_common_definition
  (Elf_Internal_Sym *);

extern unsigned int _bfd_elf_common_section_index
  (asection *);

extern asection *_bfd_elf_common_section
  (asection *);

extern bfd_vma _bfd_elf_default_got_elt_size
(bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, bfd *,
 unsigned long);

extern bfd_reloc_status_type _bfd_elf_rel_vtable_reloc_fn
  (bfd *, arelent *, struct bfd_symbol *, void *,
   asection *, bfd *, char **);

extern 
# 2759 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2759 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_final_link
  (bfd *, struct bfd_link_info *);

extern void _bfd_elf_gc_keep
  (struct bfd_link_info *info);

extern 
# 2765 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2765 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_gc_mark_dynamic_ref_symbol
  (struct elf_link_hash_entry *h, void *inf);

extern 
# 2768 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2768 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_gc_sections
  (bfd *, struct bfd_link_info *);

extern 
# 2771 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2771 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_gc_record_vtinherit
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);

extern 
# 2774 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2774 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_gc_record_vtentry
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);

extern asection *_bfd_elf_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

extern asection *_bfd_elf_gc_mark_rsec
  (struct bfd_link_info *, asection *, elf_gc_mark_hook_fn,
   struct elf_reloc_cookie *, 
# 2783 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                             _Bool 
# 2783 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                  *);

extern 
# 2785 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2785 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_gc_mark_reloc
  (struct bfd_link_info *, asection *, elf_gc_mark_hook_fn,
   struct elf_reloc_cookie *);

extern 
# 2789 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2789 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_gc_mark_fdes
  (struct bfd_link_info *, asection *, asection *, elf_gc_mark_hook_fn,
   struct elf_reloc_cookie *);

extern 
# 2793 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2793 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_gc_mark
  (struct bfd_link_info *, asection *, elf_gc_mark_hook_fn);

extern 
# 2796 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2796 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_gc_mark_extra_sections
  (struct bfd_link_info *, elf_gc_mark_hook_fn);

extern 
# 2799 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2799 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_gc_common_finalize_got_offsets
  (bfd *, struct bfd_link_info *);

extern 
# 2802 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2802 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_gc_common_final_link
  (bfd *, struct bfd_link_info *);

extern 
# 2805 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2805 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_reloc_symbol_deleted_p
  (bfd_vma, void *);

extern struct elf_segment_map * _bfd_elf_make_dynamic_segment
  (bfd *, asection *);

extern 
# 2811 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2811 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_map_sections_to_segments
  (bfd *, struct bfd_link_info *, 
# 2812 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                 _Bool 
# 2812 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                      *);

extern 
# 2814 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2814 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_is_function_type (unsigned int);

extern bfd_size_type _bfd_elf_maybe_function_sym (const asymbol *, asection *,
        bfd_vma *);

extern asection *_bfd_elf_plt_get_reloc_section (bfd *, const char *);

extern int bfd_elf_get_default_section_type (flagword);

extern 
# 2823 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2823 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           bfd_elf_lookup_section_flags
  (struct bfd_link_info *, struct flag_info *, asection *);

extern Elf_Internal_Phdr * _bfd_elf_find_segment_containing_section
  (bfd * abfd, asection * section);


extern unsigned int _bfd_elf_ppc_at_tls_transform
  (unsigned int, unsigned int);

extern unsigned int _bfd_elf_ppc_at_tprel_transform
  (unsigned int, unsigned int);

extern 
# 2836 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2836 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_ppc_set_arch (bfd *);

extern 
# 2838 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 2838 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_ppc_merge_fp_attributes
  (bfd *, struct bfd_link_info *);




extern long bfd_get_elf_phdr_upper_bound
  (bfd *abfd);
# 2854 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
extern int bfd_get_elf_phdrs
  (bfd *abfd, void *phdrs);


extern char *elfcore_write_note
  (bfd *, char *, int *, const char *, int, const void *, int);
extern char *elfcore_write_prpsinfo
  (bfd *, char *, int *, const char *, const char *);
extern char *elfcore_write_prstatus
  (bfd *, char *, int *, long, int, const void *);
extern char * elfcore_write_pstatus
  (bfd *, char *, int *, long, int, const void *);
extern char *elfcore_write_prfpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_prxfpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_xstatereg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_x86_segbases
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_vmx
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_vsx
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_tar
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_ppr
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_dscr
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_ebb
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_pmu
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_tm_cgpr
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_tm_cfpr
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_tm_cvmx
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_tm_cvsx
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_tm_spr
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_tm_ctar
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_tm_cppr
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_tm_cdscr
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_timer
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_todcmp
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_todpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_ctrs
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_prefix
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_last_break
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_system_call
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_tdb
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_vxrs_low
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_vxrs_high
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_gs_cb
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_gs_bc
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_arm_vfp
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_tls
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_hw_break
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_hw_watch
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_sve
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_pauth
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_mte
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_arc_v2
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_riscv_csr
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_gdb_tdesc
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_lwpstatus
  (bfd *, char *, int *, long, int, const void *);
extern char *elfcore_write_register_note
  (bfd *, char *, int *, const char *, const void *, int);
extern char *elfcore_write_file_note
  (bfd *, char *, int *, const void*, int);
extern char *elfcore_write_loongarch_cpucfg
  (bfd *, char *, int *, const void*, int);
extern char *elfcore_write_loongarch_lbt
  (bfd *, char *, int *, const void*, int);
extern char *elfcore_write_loongarch_lsx
  (bfd *, char *, int *, const void*, int);
extern char *elfcore_write_loongarch_lasx
  (bfd *, char *, int *, const void*, int);
# 2973 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
struct elf_internal_linux_prpsinfo
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    unsigned long pr_flag;
    unsigned int pr_uid;
    unsigned int pr_gid;
    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
    char pr_fname[16 + 1];
    char pr_psargs[80 + 1];
  };


extern char *elfcore_write_linux_prpsinfo32
  (bfd *, char *, int *, const struct elf_internal_linux_prpsinfo *);


extern char *elfcore_write_linux_prpsinfo64
  (bfd *, char *, int *, const struct elf_internal_linux_prpsinfo *);

extern bfd *_bfd_elf32_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type));
extern bfd *_bfd_elf64_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type));

extern bfd_vma bfd_elf_obj_attr_size (bfd *);
extern void bfd_elf_set_obj_attr_contents (bfd *, bfd_byte *, bfd_vma);
extern int bfd_elf_get_obj_attr_int (bfd *, int, unsigned int);
extern void bfd_elf_add_obj_attr_int (bfd *, int, unsigned int, unsigned int);


extern void bfd_elf_add_obj_attr_string (bfd *, int, unsigned int, const char *);


extern void bfd_elf_add_obj_attr_int_string (bfd *, int, unsigned int,
          unsigned int, const char *);




extern char *_bfd_elf_attr_strdup (bfd *, const char *);
extern void _bfd_elf_copy_obj_attributes (bfd *, bfd *);
extern int _bfd_elf_obj_attrs_arg_type (bfd *, int, unsigned int);
extern void _bfd_elf_parse_attributes (bfd *, Elf_Internal_Shdr *);
extern 
# 3021 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3021 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_merge_object_attributes
  (bfd *, struct bfd_link_info *);
extern 
# 3023 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3023 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_merge_unknown_attribute_low (bfd *, bfd *, int);
extern 
# 3024 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3024 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_merge_unknown_attribute_list (bfd *, bfd *);
extern Elf_Internal_Shdr *_bfd_elf_single_rel_hdr (asection *sec);
extern 
# 3026 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3026 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           elf_read_notes (bfd *, file_ptr, bfd_size_type, size_t);

extern 
# 3028 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3028 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_parse_gnu_properties
  (bfd *, Elf_Internal_Note *);
extern elf_property * _bfd_elf_get_property
  (bfd *, unsigned int, unsigned int);
extern bfd *_bfd_elf_link_setup_gnu_properties
  (struct bfd_link_info *);
extern bfd_size_type _bfd_elf_convert_gnu_property_size
  (bfd *, bfd *);
extern 
# 3036 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3036 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_convert_gnu_properties
  (bfd *, asection *, bfd *, bfd_byte **, bfd_size_type *);







struct elf_dyn_relocs
{
  struct elf_dyn_relocs *next;


  asection *sec;


  bfd_size_type count;


  bfd_size_type pc_count;
};

extern 
# 3059 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3059 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_create_ifunc_sections
  (bfd *, struct bfd_link_info *);
extern 
# 3061 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3061 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_allocate_ifunc_dyn_relocs
  (struct bfd_link_info *, struct elf_link_hash_entry *,
   struct elf_dyn_relocs **, unsigned int, unsigned int,
   unsigned int, 
# 3064 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                _Bool
# 3064 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                    );

extern void elf_append_rela (bfd *, asection *, Elf_Internal_Rela *);
extern void elf_append_rel (bfd *, asection *, Elf_Internal_Rela *);

extern bfd_vma elf64_r_info (bfd_vma, bfd_vma);
extern bfd_vma elf64_r_sym (bfd_vma);
extern bfd_vma elf32_r_info (bfd_vma, bfd_vma);
extern bfd_vma elf32_r_sym (bfd_vma);

extern 
# 3074 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3074 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           is_debuginfo_file (bfd *);


extern 
# 3077 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3077 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_init_secondary_reloc_section
  (bfd *, Elf_Internal_Shdr *, const char *, unsigned int);
extern 
# 3079 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3079 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_slurp_secondary_reloc_section
  (bfd *, asection *, asymbol **, 
# 3080 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                 _Bool
# 3080 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                     );
extern 
# 3081 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3081 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_copy_special_section_fields
  (const bfd *, bfd *, const Elf_Internal_Shdr *, Elf_Internal_Shdr *);
extern 
# 3083 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3083 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_write_secondary_reloc_section
  (bfd *, asection *);
extern unsigned int _bfd_elf_symbol_section_index
  (bfd *, elf_symbol_type *);

extern asection *_bfd_elf_readonly_dynrelocs
  (struct elf_link_hash_entry *);
extern 
# 3090 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3090 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_maybe_set_textrel
  (struct elf_link_hash_entry *, void *);

extern 
# 3093 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
      _Bool 
# 3093 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
           _bfd_elf_add_dynamic_tags
  (bfd *, struct bfd_link_info *, 
# 3094 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
                                 _Bool
# 3094 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
                                     );


extern asection _bfd_elf_large_com_section;
# 3240 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
static inline 
# 3240 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h" 3 4
             _Bool

# 3241 "/doner/binutils/binutils-515f23e/bfd/elf-bfd.h"
bfd_section_is_ctf (const asection *sec)
{
  const char *name = bfd_section_name (sec);
  return startswith (name, ".ctf") && (name[4] == 0 || name[4] == '.');
}
# 27 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2
# 1 "./../include/safe-ctype.h" 1
# 57 "./../include/safe-ctype.h"
enum {

  _sch_isblank = 0x0001,
  _sch_iscntrl = 0x0002,
  _sch_isdigit = 0x0004,
  _sch_islower = 0x0008,
  _sch_isprint = 0x0010,
  _sch_ispunct = 0x0020,
  _sch_isspace = 0x0040,
  _sch_isupper = 0x0080,
  _sch_isxdigit = 0x0100,


  _sch_isidst = 0x0200,
  _sch_isvsp = 0x0400,
  _sch_isnvsp = 0x0800,


  _sch_isalpha = _sch_isupper|_sch_islower,
  _sch_isalnum = _sch_isalpha|_sch_isdigit,
  _sch_isidnum = _sch_isidst|_sch_isdigit,
  _sch_isgraph = _sch_isalnum|_sch_ispunct,
  _sch_iscppsp = _sch_isvsp|_sch_isnvsp,
  _sch_isbasic = _sch_isprint|_sch_iscppsp

};


extern const unsigned short _sch_istable[256];
# 110 "./../include/safe-ctype.h"
extern const unsigned char _sch_toupper[256];
extern const unsigned char _sch_tolower[256];
# 122 "./../include/safe-ctype.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 123 "./../include/safe-ctype.h" 2
# 28 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2
# 1 "./../include/libiberty.h" 1
# 45 "./../include/libiberty.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 46 "./../include/libiberty.h" 2
# 55 "./../include/libiberty.h"

# 55 "./../include/libiberty.h"
extern void unlock_stream (FILE *);





extern void unlock_std_streams (void);





extern FILE *fopen_unlocked (const char *, const char *);
extern FILE *fdopen_unlocked (int, const char *);
extern FILE *freopen_unlocked (const char *, const char *, FILE *);




extern char **buildargv (const char *) __attribute__ ((__malloc__));



extern void freeargv (char **);




extern char **dupargv (char * const *) __attribute__ ((__malloc__));



extern void expandargv (int *, char ***);



extern int writeargv (char * const *, FILE *);



extern int countargv (char * const *);
# 123 "./../include/libiberty.h"
extern const char *lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));




extern const char *dos_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));





extern const char *unix_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));



extern char *lrealpath (const char *);



extern int is_valid_fd (int fd);





extern char *concat (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));
# 157 "./../include/libiberty.h"
extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));





extern unsigned long concat_length (const char *, ...) __attribute__ ((__sentinel__));






extern char *concat_copy (char *, const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__sentinel__));






extern char *concat_copy2 (const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));



extern char *libiberty_concat_ptr;
# 193 "./../include/libiberty.h"
extern int fdmatch (int fd1, int fd2);
# 205 "./../include/libiberty.h"
extern char * getpwd (void);
# 218 "./../include/libiberty.h"
extern long get_run_time (void);




extern char *make_relative_prefix (const char *, const char *,
                                   const char *) __attribute__ ((__malloc__));





extern char *make_relative_prefix_ignore_links (const char *, const char *,
      const char *) __attribute__ ((__malloc__));




extern const char *choose_tmpdir (void) __attribute__ ((__returns_nonnull__));



extern char *choose_temp_base (void) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *make_temp_file (const char *) __attribute__ ((__malloc__));




extern char *make_temp_file_with_prefix (const char *, const char *) __attribute__ ((__malloc__));



extern int unlink_if_ordinary (const char *);



extern const char *spaces (int count);




extern int errno_max (void);




extern const char *strerrno (int);



extern int strtoerrno (const char *);



extern char *xstrerror (int) __attribute__ ((__returns_nonnull__));




extern int signo_max (void);
# 292 "./../include/libiberty.h"
extern const char *strsigno (int);



extern int strtosigno (const char *);



extern int xatexit (void (*fn) (void));



extern void xexit (int status) __attribute__ ((__noreturn__));



extern void xmalloc_set_program_name (const char *);


extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));





extern void *xmalloc (size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (1))) __attribute__ ((warn_unused_result));





extern void *xrealloc (void *, size_t) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (2))) __attribute__ ((warn_unused_result));




extern void *xcalloc (size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (1, 2))) __attribute__ ((warn_unused_result));



extern char *xstrdup (const char *) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));



extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));



extern void *xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));


extern double physmem_total (void);
extern double physmem_available (void);


extern unsigned int xcrc32 (const unsigned char *, int, unsigned int);
# 391 "./../include/libiberty.h"
extern const unsigned char _hex_value[256];
extern void hex_init (void);
# 428 "./../include/libiberty.h"
extern struct pex_obj *pex_init (int flags, const char *pname,
     const char *tempbase) __attribute__ ((__returns_nonnull__));
# 528 "./../include/libiberty.h"
extern const char *pex_run (struct pex_obj *obj, int flags,
       const char *executable, char * const *argv,
       const char *outname, const char *errname,
       int *err);
# 543 "./../include/libiberty.h"
extern const char *pex_run_in_environment (struct pex_obj *obj, int flags,
                      const char *executable,
                                           char * const *argv,
                                           char * const *env,
                              const char *outname,
        const char *errname, int *err);





extern FILE *pex_input_file (struct pex_obj *obj, int flags,
                             const char *in_name);






extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);







extern FILE *pex_read_output (struct pex_obj *, int binary);







extern FILE *pex_read_err (struct pex_obj *, int binary);





extern int pex_get_status (struct pex_obj *, int count, int *vector);






struct pex_time
{
  unsigned long user_seconds;
  unsigned long user_microseconds;
  unsigned long system_seconds;
  unsigned long system_microseconds;
};

extern int pex_get_times (struct pex_obj *, int count,
     struct pex_time *vector);




extern void pex_free (struct pex_obj *);
# 618 "./../include/libiberty.h"
extern const char *pex_one (int flags, const char *executable,
       char * const *argv, const char *pname,
       const char *outname, const char *errname,
       int *status, int *err);
# 637 "./../include/libiberty.h"
extern int pexecute (const char *, char * const *, const char *,
                     const char *, char **, char **, int);



extern int pwait (int, int *, int);



extern void *bsearch_r (const void *, const void *,
   size_t, size_t,
   int (*)(const void *, const void *, void *),
   void *);
# 661 "./../include/libiberty.h"
extern char *xasprintf (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));
# 673 "./../include/libiberty.h"
extern char *xvasprintf (const char *, va_list) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));
# 717 "./../include/libiberty.h"
extern void setproctitle (const char *name, ...);


extern void stack_limit_increase (unsigned long);
# 730 "./../include/libiberty.h"
extern void *C_alloca (size_t) __attribute__ ((__malloc__));
# 29 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2
# 1 "./../include/objalloc.h" 1
# 44 "./../include/objalloc.h"
struct objalloc
{
  char *current_ptr;
  unsigned int current_space;
  void *chunks;
};



struct objalloc_align { char x; double d; };
# 67 "./../include/objalloc.h"
extern struct objalloc *objalloc_create (void);




extern void *_objalloc_alloc (struct objalloc *, unsigned long);
# 108 "./../include/objalloc.h"
extern void objalloc_free (struct objalloc *);




extern void objalloc_free_block (struct objalloc *, void *);
# 30 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2

# 1 "./../include/plugin-api.h" 1
# 102 "./../include/plugin-api.h"
enum ld_plugin_status
{
  LDPS_OK = 0,
  LDPS_NO_SYMS,
  LDPS_BAD_HANDLE,
  LDPS_ERR

};



enum ld_plugin_api_version
{
  LD_PLUGIN_API_VERSION = 1
};



enum ld_plugin_output_file_type
{
  LDPO_REL,
  LDPO_EXEC,
  LDPO_DYN,
  LDPO_PIE
};



struct ld_plugin_input_file
{
  const char *name;
  int fd;
  off_t offset;
  off_t filesize;
  void *handle;
};



struct ld_plugin_symbol
{
  char *name;
  char *version;
# 153 "./../include/plugin-api.h"
  char def;
  char symbol_type;
  char section_kind;
  char unused;
# 165 "./../include/plugin-api.h"
  int visibility;
  uint64_t size;
  char *comdat_key;
  int resolution;
};



struct ld_plugin_section
{
  const void* handle;
  unsigned int shndx;
};



enum ld_plugin_symbol_kind
{
  LDPK_DEF,
  LDPK_WEAKDEF,
  LDPK_UNDEF,
  LDPK_WEAKUNDEF,
  LDPK_COMMON
};



enum ld_plugin_symbol_visibility
{
  LDPV_DEFAULT,
  LDPV_PROTECTED,
  LDPV_INTERNAL,
  LDPV_HIDDEN
};



enum ld_plugin_symbol_type
{
  LDST_UNKNOWN,
  LDST_FUNCTION,
  LDST_VARIABLE
};

enum ld_plugin_symbol_section_kind
{
  LDSSK_DEFAULT,
  LDSSK_BSS
};



enum ld_plugin_symbol_resolution
{
  LDPR_UNKNOWN = 0,


  LDPR_UNDEF,



  LDPR_PREVAILING_DEF,




  LDPR_PREVAILING_DEF_IRONLY,



  LDPR_PREEMPTED_REG,


  LDPR_PREEMPTED_IR,


  LDPR_RESOLVED_IR,



  LDPR_RESOLVED_EXEC,


  LDPR_RESOLVED_DYN,





  LDPR_PREVAILING_DEF_IRONLY_EXP
};



typedef
enum ld_plugin_status
(*ld_plugin_claim_file_handler) (
  const struct ld_plugin_input_file *file, int *claimed);



typedef
enum ld_plugin_status
(*ld_plugin_claim_file_handler_v2) (
  const struct ld_plugin_input_file *file, int *claimed, int known_used);



typedef
enum ld_plugin_status
(*ld_plugin_all_symbols_read_handler) (void);



typedef
enum ld_plugin_status
(*ld_plugin_cleanup_handler) (void);



typedef
enum ld_plugin_status
(*ld_plugin_register_claim_file) (ld_plugin_claim_file_handler handler);




typedef
enum ld_plugin_status
(*ld_plugin_register_claim_file_v2) (ld_plugin_claim_file_handler_v2 handler);



typedef
enum ld_plugin_status
(*ld_plugin_register_all_symbols_read) (
  ld_plugin_all_symbols_read_handler handler);



typedef
enum ld_plugin_status
(*ld_plugin_register_cleanup) (ld_plugin_cleanup_handler handler);



typedef
enum ld_plugin_status
(*ld_plugin_add_symbols) (void *handle, int nsyms,
                          const struct ld_plugin_symbol *syms);




typedef
enum ld_plugin_status
(*ld_plugin_get_input_file) (const void *handle,
                             struct ld_plugin_input_file *file);

typedef
enum ld_plugin_status
(*ld_plugin_get_view) (const void *handle, const void **viewp);



typedef
enum ld_plugin_status
(*ld_plugin_release_input_file) (const void *handle);



typedef
enum ld_plugin_status
(*ld_plugin_get_symbols) (const void *handle, int nsyms,
                          struct ld_plugin_symbol *syms);



typedef
enum ld_plugin_status
(*ld_plugin_add_input_file) (const char *pathname);



typedef
enum ld_plugin_status
(*ld_plugin_add_input_library) (const char *libname);



typedef
enum ld_plugin_status
(*ld_plugin_set_extra_library_path) (const char *path);



typedef
enum ld_plugin_status
(*ld_plugin_message) (int level, const char *format, ...);






typedef
enum ld_plugin_status
(*ld_plugin_get_input_section_count) (const void* handle, unsigned int *count);





typedef
enum ld_plugin_status
(*ld_plugin_get_input_section_type) (const struct ld_plugin_section section,
                                     unsigned int *type);






typedef
enum ld_plugin_status
(*ld_plugin_get_input_section_name) (const struct ld_plugin_section section,
                                     char **section_name_ptr);







typedef
enum ld_plugin_status
(*ld_plugin_get_input_section_contents) (const struct ld_plugin_section section,
                                         const unsigned char **section_contents,
                                         size_t* len);







typedef
enum ld_plugin_status
(*ld_plugin_update_section_order) (const struct ld_plugin_section *section_list,
       unsigned int num_sections);





typedef
enum ld_plugin_status
(*ld_plugin_allow_section_ordering) (void);






typedef
enum ld_plugin_status
(*ld_plugin_allow_unique_segment_for_sections) (void);
# 442 "./../include/plugin-api.h"
typedef
enum ld_plugin_status
(*ld_plugin_unique_segment_for_sections) (
    const char* segment_name,
    uint64_t segment_flags,
    uint64_t segment_alignment,
    const struct ld_plugin_section * section_list,
    unsigned int num_sections);






typedef
enum ld_plugin_status
(*ld_plugin_get_input_section_alignment) (const struct ld_plugin_section section,
                                          unsigned int *addralign);






typedef
enum ld_plugin_status
(*ld_plugin_get_input_section_size) (const struct ld_plugin_section section,
                                     uint64_t *secsize);

typedef
enum ld_plugin_status
(*ld_plugin_new_input_handler) (const struct ld_plugin_input_file *file);






typedef
enum ld_plugin_status
(*ld_plugin_register_new_input) (ld_plugin_new_input_handler handler);





typedef
enum ld_plugin_status
(*ld_plugin_get_wrap_symbols) (uint64_t *num_symbols,
                               const char ***wrap_symbol_list);

enum ld_plugin_level
{
  LDPL_INFO,
  LDPL_WARNING,
  LDPL_ERROR,
  LDPL_FATAL
};



enum linker_api_version
{


   LAPI_V0,





   LAPI_V1
};
# 523 "./../include/plugin-api.h"
typedef
int
(*ld_plugin_get_api_version) (const char *plugin_identifier,
         const char *plugin_version,
         int minimal_api_supported,
         int maximal_api_supported,
         const char **linker_identifier,
         const char **linker_version);



enum ld_plugin_tag
{
  LDPT_NULL,
  LDPT_API_VERSION,
  LDPT_GOLD_VERSION,
  LDPT_LINKER_OUTPUT,
  LDPT_OPTION,
  LDPT_REGISTER_CLAIM_FILE_HOOK,
  LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK,
  LDPT_REGISTER_CLEANUP_HOOK,
  LDPT_ADD_SYMBOLS,
  LDPT_GET_SYMBOLS,
  LDPT_ADD_INPUT_FILE,
  LDPT_MESSAGE,
  LDPT_GET_INPUT_FILE,
  LDPT_RELEASE_INPUT_FILE,
  LDPT_ADD_INPUT_LIBRARY,
  LDPT_OUTPUT_NAME,
  LDPT_SET_EXTRA_LIBRARY_PATH,
  LDPT_GNU_LD_VERSION,
  LDPT_GET_VIEW,
  LDPT_GET_INPUT_SECTION_COUNT,
  LDPT_GET_INPUT_SECTION_TYPE,
  LDPT_GET_INPUT_SECTION_NAME,
  LDPT_GET_INPUT_SECTION_CONTENTS,
  LDPT_UPDATE_SECTION_ORDER,
  LDPT_ALLOW_SECTION_ORDERING,
  LDPT_GET_SYMBOLS_V2,
  LDPT_ALLOW_UNIQUE_SEGMENT_FOR_SECTIONS,
  LDPT_UNIQUE_SEGMENT_FOR_SECTIONS,
  LDPT_GET_SYMBOLS_V3,
  LDPT_GET_INPUT_SECTION_ALIGNMENT,
  LDPT_GET_INPUT_SECTION_SIZE,
  LDPT_REGISTER_NEW_INPUT_HOOK,
  LDPT_GET_WRAP_SYMBOLS,
  LDPT_ADD_SYMBOLS_V2,
  LDPT_GET_API_VERSION,
  LDPT_REGISTER_CLAIM_FILE_HOOK_V2
};



struct ld_plugin_tv
{
  enum ld_plugin_tag tv_tag;
  union
  {
    int tv_val;
    const char *tv_string;
    ld_plugin_register_claim_file tv_register_claim_file;
    ld_plugin_register_claim_file_v2 tv_register_claim_file_v2;
    ld_plugin_register_all_symbols_read tv_register_all_symbols_read;
    ld_plugin_register_cleanup tv_register_cleanup;
    ld_plugin_add_symbols tv_add_symbols;
    ld_plugin_get_symbols tv_get_symbols;
    ld_plugin_add_input_file tv_add_input_file;
    ld_plugin_message tv_message;
    ld_plugin_get_input_file tv_get_input_file;
    ld_plugin_get_view tv_get_view;
    ld_plugin_release_input_file tv_release_input_file;
    ld_plugin_add_input_library tv_add_input_library;
    ld_plugin_set_extra_library_path tv_set_extra_library_path;
    ld_plugin_get_input_section_count tv_get_input_section_count;
    ld_plugin_get_input_section_type tv_get_input_section_type;
    ld_plugin_get_input_section_name tv_get_input_section_name;
    ld_plugin_get_input_section_contents tv_get_input_section_contents;
    ld_plugin_update_section_order tv_update_section_order;
    ld_plugin_allow_section_ordering tv_allow_section_ordering;
    ld_plugin_allow_unique_segment_for_sections tv_allow_unique_segment_for_sections;
    ld_plugin_unique_segment_for_sections tv_unique_segment_for_sections;
    ld_plugin_get_input_section_alignment tv_get_input_section_alignment;
    ld_plugin_get_input_section_size tv_get_input_section_size;
    ld_plugin_register_new_input tv_register_new_input;
    ld_plugin_get_wrap_symbols tv_get_wrap_symbols;
    ld_plugin_get_api_version tv_get_api_version;
  } tv_u;
};



typedef
enum ld_plugin_status
(*ld_plugin_onload) (struct ld_plugin_tv *tv);
# 32 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2
# 1 "/doner/binutils/binutils-515f23e/bfd/plugin.h" 1
# 24 "/doner/binutils/binutils-515f23e/bfd/plugin.h"
void bfd_plugin_set_program_name (const char *);
int bfd_plugin_open_input (bfd *, struct ld_plugin_input_file *);
void bfd_plugin_set_plugin (const char *);

# 27 "/doner/binutils/binutils-515f23e/bfd/plugin.h" 3 4
_Bool 
# 27 "/doner/binutils/binutils-515f23e/bfd/plugin.h"
    bfd_plugin_target_p (const bfd_target *);

# 28 "/doner/binutils/binutils-515f23e/bfd/plugin.h" 3 4
_Bool 
# 28 "/doner/binutils/binutils-515f23e/bfd/plugin.h"
    bfd_plugin_specified_p (void);

# 29 "/doner/binutils/binutils-515f23e/bfd/plugin.h" 3 4
_Bool 
# 29 "/doner/binutils/binutils-515f23e/bfd/plugin.h"
    bfd_link_plugin_object_p (bfd *);
void register_ld_plugin_object_p (bfd_cleanup (*object_p) (bfd *, 
# 30 "/doner/binutils/binutils-515f23e/bfd/plugin.h" 3 4
                                                                 _Bool
# 30 "/doner/binutils/binutils-515f23e/bfd/plugin.h"
                                                                     ));
void bfd_plugin_close_file_descriptor (bfd *, int);

typedef struct plugin_data_struct
{
  int nsyms;
  const struct ld_plugin_symbol *syms;
}
plugin_data_struct;
# 33 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 36 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 2







struct elf_info_failed
{
  struct bfd_link_info *info;
  
# 46 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 46 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      failed;
};




struct elf_find_verdep_info
{

  struct bfd_link_info *info;

  unsigned int vers;

  
# 59 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 59 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      failed;
};

static 
# 62 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool 
# 62 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           _bfd_elf_fix_symbol_flags
  (struct elf_link_hash_entry *, struct elf_info_failed *);

asection *
_bfd_elf_section_for_symbol (struct elf_reloc_cookie *cookie,
        unsigned long r_symndx,
        
# 68 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       _Bool 
# 68 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            discard)
{
  if (r_symndx >= cookie->locsymcount
      || (((unsigned int)(cookie->locsyms[r_symndx].st_info)) >> 4) != 0)
    {
      struct elf_link_hash_entry *h;

      h = cookie->sym_hashes[r_symndx - cookie->extsymoff];

      while (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
 h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if ((h->root.type == bfd_link_hash_defined
    || h->root.type == bfd_link_hash_defweak)
    && discarded_section (h->root.u.def.section))
 return h->root.u.def.section;
      else
 return 
# 86 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       ((void *)0)
# 86 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
    }
  else
    {



      asection *isec;
      Elf_Internal_Sym *isym;


      isym = &cookie->locsyms[r_symndx];
      isec = bfd_section_from_elf_index (cookie->abfd, isym->st_shndx);
      if (isec != 
# 99 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
   
# 100 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && discard ? discarded_section (isec) : 1)
 return isec;
     }
  return 
# 103 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 103 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



struct elf_link_hash_entry *
_bfd_elf_define_linkage_sym (bfd *abfd,
        struct bfd_link_info *info,
        asection *sec,
        const char *name)
{
  struct elf_link_hash_entry *h;
  struct bfd_link_hash_entry *bh;
  const struct elf_backend_data *bed;

  h = elf_link_hash_lookup (elf_hash_table (info), name, 
# 118 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                        0
# 118 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                             , 
# 118 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                               0
# 118 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                    , 
# 118 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                                      0
# 118 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                           );
  if (h != 
# 119 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 119 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {




      h->root.type = bfd_link_hash_new;
      bh = &h->root;
    }
  else
    bh = 
# 129 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 129 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  if (!_bfd_generic_link_add_one_symbol (info, abfd, name, (1 << 1),
      sec, 0, 
# 133 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 133 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 , 
# 133 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   0
# 133 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        , bed->collect,
      &bh))
    return 
# 135 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 135 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  h = (struct elf_link_hash_entry *) bh;
  do { if (!(h != 
# 137 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 ((void *)0)
# 137 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
 )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",137); } while (0);
  h->def_regular = 1;
  h->non_elf = 0;
  h->root.linker_def = 1;
  h->type = 1;
  if (((h->other) & 0x3) != 1)
    h->other = (h->other & ~((-1) & 0x3)) | 2;

  (*bed->elf_backend_hide_symbol) (info, h, 
# 145 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           1
# 145 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               );
  return h;
}


# 149 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 150 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags;
  asection *s;
  struct elf_link_hash_entry *h;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  struct elf_link_hash_table *htab = elf_hash_table (info);


  if (htab->sgot != 
# 159 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 159 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
    return 
# 160 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 160 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  flags = bed->dynamic_sec_flags;

  s = bfd_make_section_anyway_with_flags (abfd,
       (bed->rela_plts_and_copies_p
        ? ".rela.got" : ".rel.got"),
       (bed->dynamic_sec_flags
        | 0x8));
  if (s == 
# 169 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 170 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !bfd_set_section_alignment (s, bed->s->log_file_align))
    return 
# 171 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 171 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  htab->srelgot = s;

  s = bfd_make_section_anyway_with_flags (abfd, ".got", flags);
  if (s == 
# 175 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 176 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !bfd_set_section_alignment (s, bed->s->log_file_align))
    return 
# 177 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 177 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  htab->sgot = s;

  if (bed->want_got_plt)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".got.plt", flags);
      if (s == 
# 183 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
   
# 184 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  || !bfd_set_section_alignment (s, bed->s->log_file_align))
 return 
# 185 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 185 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      htab->sgotplt = s;
    }


  s->size += bed->got_header_size;

  if (bed->want_got_sym)
    {




      h = _bfd_elf_define_linkage_sym (abfd, info, s,
           "_GLOBAL_OFFSET_TABLE_");
      elf_hash_table (info)->hgot = h;
      if (h == 
# 201 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 201 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 return 
# 202 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 202 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }

  return 
# 205 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 205 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}


static 
# 209 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 210 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_create_dynstrtab (bfd *abfd, struct bfd_link_info *info)
{
  struct elf_link_hash_table *hash_table;

  hash_table = elf_hash_table (info);
  if (hash_table->dynobj == 
# 215 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 215 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
    {




      if ((abfd->flags & (0x40 | 0x10000)) != 0)
 {
   bfd *ibfd;
   asection *s;
   for (ibfd = info->input_bfds; ibfd; ibfd = ibfd->link.next)
     if ((ibfd->flags
   & (0x40 | 0x1000 | 0x10000)) == 0
  && bfd_get_flavour (ibfd) == bfd_target_elf_flavour
  && (((ibfd) -> tdata.elf_obj_data) -> object_id) == elf_hash_table_id (hash_table)
  && !((s = ibfd->sections) != 
# 230 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
       
# 231 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && s->sec_info_type == 4))
       {
  abfd = ibfd;
  break;
       }
 }
      hash_table->dynobj = abfd;
    }

  if (hash_table->dynstr == 
# 240 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 240 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
    {
      hash_table->dynstr = _bfd_elf_strtab_init ();
      if (hash_table->dynstr == 
# 243 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 243 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   )
 return 
# 244 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 244 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }
  return 
# 246 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 246 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}
# 256 "/doner/binutils/binutils-515f23e/bfd/elflink.c"

# 256 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 257 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags;
  asection *s;
  const struct elf_backend_data *bed;
  struct elf_link_hash_entry *h;

  if (! is_elf_hash_table (info->hash))
    return 
# 265 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 265 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (elf_hash_table (info)->dynamic_sections_created)
    return 
# 268 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 268 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  if (!_bfd_elf_link_create_dynstrtab (abfd, info))
    return 
# 271 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 271 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  abfd = elf_hash_table (info)->dynobj;
  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  flags = bed->dynamic_sec_flags;



  if ((((info)->type == type_pde) || ((info)->type == type_pie)) && !info->nointerp)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".interp",
           flags | 0x8);
      if (s == 
# 284 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 284 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 return 
# 285 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 285 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }



  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version_d",
       flags | 0x8);
  if (s == 
# 292 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 293 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !bfd_set_section_alignment (s, bed->s->log_file_align))
    return 
# 294 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 294 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version",
       flags | 0x8);
  if (s == 
# 298 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 299 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !bfd_set_section_alignment (s, 1))
    return 
# 300 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 300 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  s = bfd_make_section_anyway_with_flags (abfd, ".gnu.version_r",
       flags | 0x8);
  if (s == 
# 304 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 305 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !bfd_set_section_alignment (s, bed->s->log_file_align))
    return 
# 306 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 306 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  s = bfd_make_section_anyway_with_flags (abfd, ".dynsym",
       flags | 0x8);
  if (s == 
# 310 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 311 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !bfd_set_section_alignment (s, bed->s->log_file_align))
    return 
# 312 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 312 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  elf_hash_table (info)->dynsym = s;

  s = bfd_make_section_anyway_with_flags (abfd, ".dynstr",
       flags | 0x8);
  if (s == 
# 317 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 317 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    return 
# 318 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 318 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  s = bfd_make_section_anyway_with_flags (abfd, ".dynamic", flags);
  if (s == 
# 321 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 322 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !bfd_set_section_alignment (s, bed->s->log_file_align))
    return 
# 323 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 323 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;







  h = _bfd_elf_define_linkage_sym (abfd, info, s, "_DYNAMIC");
  elf_hash_table (info)->hdynamic = h;
  if (h == 
# 333 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 333 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    return 
# 334 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 334 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (info->emit_hash)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".hash",
           flags | 0x8);
      if (s == 
# 340 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
   
# 341 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  || !bfd_set_section_alignment (s, bed->s->log_file_align))
 return 
# 342 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 342 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize = bed->s->sizeof_hash_entry;
    }

  if (info->emit_gnu_hash && bed->record_xhash_symbol == 
# 346 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                        ((void *)0)
# 346 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                            )
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".gnu.hash",
           flags | 0x8);
      if (s == 
# 350 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
   
# 351 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  || !bfd_set_section_alignment (s, bed->s->log_file_align))
 return 
# 352 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 352 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;



      if (bed->s->arch_size == 64)
 ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize = 0;
      else
 ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize = 4;
    }

  if (info->enable_dt_relr)
    {
      s = bfd_make_section_anyway_with_flags (abfd, ".relr.dyn",
           (bed->dynamic_sec_flags
            | 0x8));
      if (s == 
# 367 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
   
# 368 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  || !bfd_set_section_alignment (s, bed->s->log_file_align))
 return 
# 369 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 369 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      elf_hash_table (info)->srelrdyn = s;
    }




  if (bed->elf_backend_create_dynamic_sections == 
# 376 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                 ((void *)0)
      
# 377 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || ! (*bed->elf_backend_create_dynamic_sections) (abfd, info))
    return 
# 378 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 378 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  elf_hash_table (info)->dynamic_sections_created = 
# 380 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                   1
# 380 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                       ;

  return 
# 382 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 382 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




# 387 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 388 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  flagword flags, pltflags;
  struct elf_link_hash_entry *h;
  asection *s;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  struct elf_link_hash_table *htab = elf_hash_table (info);



  flags = bed->dynamic_sec_flags;

  pltflags = flags;
  if (bed->plt_not_loaded)



    pltflags &= ~ (0x10 | 0x2 | 0x100);
  else
    pltflags |= 0x1 | 0x10 | 0x2;
  if (bed->plt_readonly)
    pltflags |= 0x8;

  s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
  if (s == 
# 412 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 413 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !bfd_set_section_alignment (s, bed->plt_alignment))
    return 
# 414 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 414 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  htab->splt = s;



  if (bed->want_plt_sym)
    {
      h = _bfd_elf_define_linkage_sym (abfd, info, s,
           "_PROCEDURE_LINKAGE_TABLE_");
      elf_hash_table (info)->hplt = h;
      if (h == 
# 424 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 424 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 return 
# 425 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 425 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }

  s = bfd_make_section_anyway_with_flags (abfd,
       (bed->rela_plts_and_copies_p
        ? ".rela.plt" : ".rel.plt"),
       flags | 0x8);
  if (s == 
# 432 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 433 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !bfd_set_section_alignment (s, bed->s->log_file_align))
    return 
# 434 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 434 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  htab->srelplt = s;

  if (! _bfd_elf_create_got_section (abfd, info))
    return 
# 438 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 438 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (bed->want_dynbss)
    {






      s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
           0x1 | 0x100000);
      if (s == 
# 450 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 450 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 return 
# 451 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 451 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      htab->sdynbss = s;

      if (bed->want_dynrelro)
 {



   s = bfd_make_section_anyway_with_flags (abfd, ".data.rel.ro",
        flags);
   if (s == 
# 461 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 461 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               )
     return 
# 462 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 462 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   htab->sdynrelro = s;
 }
# 477 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      if ((((info)->type == type_pde) || ((info)->type == type_pie)))
 {
   s = bfd_make_section_anyway_with_flags (abfd,
        (bed->rela_plts_and_copies_p
         ? ".rela.bss" : ".rel.bss"),
        flags | 0x8);
   if (s == 
# 483 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
       
# 484 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      || !bfd_set_section_alignment (s, bed->s->log_file_align))
     return 
# 485 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 485 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   htab->srelbss = s;

   if (bed->want_dynrelro)
     {
       s = (bfd_make_section_anyway_with_flags
     (abfd, (bed->rela_plts_and_copies_p
      ? ".rela.data.rel.ro" : ".rel.data.rel.ro"),
      flags | 0x8));
       if (s == 
# 494 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
    
# 495 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   || !bfd_set_section_alignment (s, bed->s->log_file_align))
  return 
# 496 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 496 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
       htab->sreldynrelro = s;
     }
 }
    }

  return 
# 502 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 502 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}
# 513 "/doner/binutils/binutils-515f23e/bfd/elflink.c"

# 513 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 514 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_link_record_dynamic_symbol (struct bfd_link_info *info,
        struct elf_link_hash_entry *h)
{
  if (h->dynindx == -1)
    {
      struct elf_strtab_hash *dynstr;
      char *p;
      const char *name;
      size_t indx;

      if (h->root.type == bfd_link_hash_defined
   || h->root.type == bfd_link_hash_defweak)
 {

   if (h->root.u.def.section != 
# 528 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
       
# 529 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && h->root.u.def.section->owner != 
# 529 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                         ((void *)0)
       
# 530 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && (h->root.u.def.section->owner->flags & 0x10000) != 0)
     return 
# 531 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 531 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
 }





      switch (((h->other) & 0x3))
 {
 case 1:
 case 2:
   if (h->root.type != bfd_link_hash_undefined
       && h->root.type != bfd_link_hash_undefweak)
     {
       h->forced_local = 1;
       if (!elf_hash_table (info)->is_relocatable_executable
    || ((h->root.type == bfd_link_hash_defined
         || h->root.type == bfd_link_hash_defweak)
        && h->root.u.def.section->owner != 
# 549 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
        
# 550 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       && h->root.u.def.section->owner->no_export)
    || (h->root.type == bfd_link_hash_common
        && h->root.u.c.p->section->owner != 
# 552 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
        
# 553 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       && h->root.u.c.p->section->owner->no_export))
  return 
# 554 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 554 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
     }

 default:
   break;
 }

      h->dynindx = elf_hash_table (info)->dynsymcount;
      ++elf_hash_table (info)->dynsymcount;

      dynstr = elf_hash_table (info)->dynstr;
      if (dynstr == 
# 565 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 565 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
 {

   elf_hash_table (info)->dynstr = dynstr = _bfd_elf_strtab_init ();
   if (dynstr == 
# 569 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 569 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
     return 
# 570 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 570 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }



      name = h->root.root.string;
      p = strchr (name, '@');
      if (p != 
# 577 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 577 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )





 *p = 0;

      indx = _bfd_elf_strtab_add (dynstr, name, p != 
# 585 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                    ((void *)0)
# 585 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                        );

      if (p != 
# 587 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 587 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 *p = '@';

      if (indx == (size_t) -1)
 return 
# 591 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 591 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      h->dynstr_index = indx;
    }

  return 
# 595 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 595 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



static void
bfd_elf_link_mark_dynamic_symbol (struct bfd_link_info *info,
      struct elf_link_hash_entry *h,
      Elf_Internal_Sym *sym)
{
  struct bfd_elf_dynamic_list *d = info->dynamic_list;


  if(h->dynamic || ((info)->type == type_relocatable))
    return;

  if ((info->dynamic_data
       && (h->type == 1
    || h->type == 5
    || (sym != 
# 614 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
        
# 615 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       && (((sym->st_info) & 0xF) == 1
     || ((sym->st_info) & 0xF) == 5))))
      || (d != 
# 617 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
   
# 618 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && h->non_elf
   && (*d->match) (&d->head, 
# 619 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 619 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                , h->root.root.string)))
    {
      h->dynamic = 1;


      h->root.non_ir_ref_dynamic = 1;
    }
}





# 631 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 632 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_record_link_assignment (bfd *output_bfd,
    struct bfd_link_info *info,
    const char *name,
    
# 635 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
   _Bool 
# 635 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        provide,
    
# 636 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
   _Bool 
# 636 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        hidden)
{
  struct elf_link_hash_entry *h, *hv;
  struct elf_link_hash_table *htab;
  const struct elf_backend_data *bed;

  if (!is_elf_hash_table (info->hash))
    return 
# 643 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 643 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  htab = elf_hash_table (info);
  h = elf_link_hash_lookup (htab, name, !provide, 
# 646 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                 1
# 646 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                     , 
# 646 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                       0
# 646 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                            );
  if (h == 
# 647 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 647 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    return provide;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->versioned == unknown)
    {

      char *version = strrchr (name, '@');
      if (version)
 {
   if (version > name && version[-1] != '@')
     h->versioned = versioned_hidden;
   else
     h->versioned = versioned;
 }
    }



  if (h->non_elf)
    {
      bfd_elf_link_mark_dynamic_symbol (info, h, 
# 670 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                ((void *)0)
# 670 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                    );
      h->non_elf = 0;
    }

  switch (h->root.type)
    {
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
    case bfd_link_hash_common:
      break;
    case bfd_link_hash_undefweak:
    case bfd_link_hash_undefined:



      h->root.type = bfd_link_hash_new;
      if (h->root.u.undef.next != 
# 686 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 ((void *)0) 
# 686 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      || htab->root.undefs_tail == &h->root)
 bfd_link_repair_undef_list (&htab->root);
      break;
    case bfd_link_hash_new:
      break;
    case bfd_link_hash_indirect:


      bed = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);
      hv = h;
      while (hv->root.type == bfd_link_hash_indirect
      || hv->root.type == bfd_link_hash_warning)
 hv = (struct elf_link_hash_entry *) hv->root.u.i.link;


      h->root.type = bfd_link_hash_undefined;
      hv->root.type = bfd_link_hash_indirect;
      hv->root.u.i.link = (struct bfd_link_hash_entry *) h;
      (*bed->elf_backend_copy_indirect_symbol) (info, h, hv);
      break;
    default:
      do { bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",707); } while (0);
      return 
# 708 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 708 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }





  if (provide
      && h->def_dynamic
      && !h->def_regular)
    h->root.type = bfd_link_hash_undefined;





  if (h->def_dynamic && !h->def_regular)
    h->verinfo.verdef = 
# 725 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       ((void *)0)
# 725 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;


  h->mark = 1;

  h->def_regular = 1;

  if (hidden)
    {
      bed = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);
      if (((h->other) & 0x3) != 1)
 h->other = (h->other & ~((-1) & 0x3)) | 2;
      (*bed->elf_backend_hide_symbol) (info, h, 
# 737 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                               1
# 737 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                   );
    }



  if (!((info)->type == type_relocatable)
      && h->dynindx != -1
      && (((h->other) & 0x3) == 2
   || ((h->other) & 0x3) == 1))
    h->forced_local = 1;

  if ((h->def_dynamic
       || h->ref_dynamic
       || ((info)->type == type_dll)
       || elf_hash_table (info)->is_relocatable_executable)
      && !h->forced_local
      && h->dynindx == -1)
    {
      if (! bfd_elf_link_record_dynamic_symbol (info, h))
 return 
# 756 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 756 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;




      if (h->is_weakalias)
 {
   struct elf_link_hash_entry *def = weakdef (h);

   if (def->dynindx == -1
       && !bfd_elf_link_record_dynamic_symbol (info, def))
     return 
# 767 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 767 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
    }

  return 
# 771 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 771 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





int
bfd_elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,
       bfd *input_bfd,
       long input_indx)
{
  size_t amt;
  struct elf_link_local_dynamic_entry *entry;
  struct elf_link_hash_table *eht;
  struct elf_strtab_hash *dynstr;
  size_t dynstr_index;
  char *name;
  Elf_External_Sym_Shndx eshndx;
  char esym[sizeof (Elf64_External_Sym)];

  if (! is_elf_hash_table (info->hash))
    return 0;


  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)
    if (entry->input_bfd == input_bfd && entry->input_indx == input_indx)
      return 1;

  amt = sizeof (*entry);
  entry = (struct elf_link_local_dynamic_entry *) bfd_alloc (input_bfd, amt);
  if (entry == 
# 802 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 802 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    return 0;


  if (!bfd_elf_get_elf_syms (input_bfd, &((input_bfd) -> tdata.elf_obj_data)->symtab_hdr,
        1, input_indx, &entry->isym, esym, &eshndx))
    {
      bfd_release (input_bfd, entry);
      return 0;
    }

  if (entry->isym.st_shndx != 0
      && entry->isym.st_shndx < (-0x100u))
    {
      asection *s;

      s = bfd_section_from_elf_index (input_bfd, entry->isym.st_shndx);
      if (s == 
# 819 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 819 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   || bfd_is_abs_section (s->output_section))
 {


   bfd_release (input_bfd, entry);
   return 2;
 }
    }

  name = (bfd_elf_string_from_elf_section
   (input_bfd, ((input_bfd) -> tdata.elf_obj_data)->symtab_hdr.sh_link,
    entry->isym.st_name));

  dynstr = elf_hash_table (info)->dynstr;
  if (dynstr == 
# 833 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 833 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
    {

      elf_hash_table (info)->dynstr = dynstr = _bfd_elf_strtab_init ();
      if (dynstr == 
# 837 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 837 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
 return 0;
    }

  dynstr_index = _bfd_elf_strtab_add (dynstr, name, 
# 841 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                   0
# 841 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                        );
  if (dynstr_index == (size_t) -1)
    return 0;
  entry->isym.st_name = dynstr_index;

  eht = elf_hash_table (info);

  entry->next = eht->dynlocal;
  eht->dynlocal = entry;
  entry->input_bfd = input_bfd;
  entry->input_indx = input_indx;
  eht->dynsymcount++;


  entry->isym.st_info
    = (((0) << 4) + ((((entry->isym.st_info) & 0xF)) & 0xF));



  return 1;
}



long
_bfd_elf_link_lookup_local_dynindx (struct bfd_link_info *info,
        bfd *input_bfd,
        long input_indx)
{
  struct elf_link_local_dynamic_entry *e;

  for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)
    if (e->input_bfd == input_bfd && e->input_indx == input_indx)
      return e->dynindx;
  return -1;
}





static 
# 882 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 883 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_renumber_hash_table_dynsyms (struct elf_link_hash_entry *h,
          void *data)
{
  size_t *count = (size_t *) data;

  if (h->forced_local)
    return 
# 889 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 889 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  if (h->dynindx != -1)
    h->dynindx = ++(*count);

  return 
# 894 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 894 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





static 
# 901 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 902 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_renumber_local_hash_table_dynsyms (struct elf_link_hash_entry *h,
         void *data)
{
  size_t *count = (size_t *) data;

  if (!h->forced_local)
    return 
# 908 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 908 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  if (h->dynindx != -1)
    h->dynindx = ++(*count);

  return 
# 913 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 913 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




# 918 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 919 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_omit_section_dynsym_default (bfd *output_bfd __attribute__ ((__unused__)),
          struct bfd_link_info *info,
          asection *p)
{
  struct elf_link_hash_table *htab;
  asection *ip;

  switch (((struct bfd_elf_section_data*)(p)->used_by_bfd)->this_hdr.sh_type)
    {
    case 1:
    case 8:


    case 0:
      htab = elf_hash_table (info);
      if (htab->text_index_section != 
# 934 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 934 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         )
 return p != htab->text_index_section && p != htab->data_index_section;

      return (htab->dynobj != 
# 937 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
       
# 938 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && (ip = bfd_get_linker_section (htab->dynobj, p->name)) != 
# 938 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                                  ((void *)0)
       
# 939 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && ip->output_section == p);



    default:
      return 
# 944 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 944 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }
}


# 948 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 949 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_omit_section_dynsym_all
    (bfd *output_bfd __attribute__ ((__unused__)),
     struct bfd_link_info *info __attribute__ ((__unused__)),
     asection *p __attribute__ ((__unused__)))
{
  return 
# 954 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 954 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}
# 966 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
static unsigned long
_bfd_elf_link_renumber_dynsyms (bfd *output_bfd,
    struct bfd_link_info *info,
    unsigned long *section_sym_count)
{
  unsigned long dynsymcount = 0;
  
# 972 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 972 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      do_sec = section_sym_count != 
# 972 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                    ((void *)0)
# 972 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                        ;

  if ((((info)->type == type_dll) || ((info)->type == type_pie))
      || elf_hash_table (info)->is_relocatable_executable)
    {
      const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);
      asection *p;
      for (p = output_bfd->sections; p ; p = p->next)
 if ((p->flags & 0x8000) == 0
     && (p->flags & 0x1) != 0
     && elf_hash_table (info)->dynamic_relocs
     && !(*bed->elf_backend_omit_section_dynsym) (output_bfd, info, p))
   {
     ++dynsymcount;
     if (do_sec)
       ((struct bfd_elf_section_data*)(p)->used_by_bfd)->dynindx = dynsymcount;
   }
 else if (do_sec)
   ((struct bfd_elf_section_data*)(p)->used_by_bfd)->dynindx = 0;
    }
  if (do_sec)
    *section_sym_count = dynsymcount;

  elf_link_hash_traverse (elf_hash_table (info),
     elf_link_renumber_local_hash_table_dynsyms,
     &dynsymcount);

  if (elf_hash_table (info)->dynlocal)
    {
      struct elf_link_local_dynamic_entry *p;
      for (p = elf_hash_table (info)->dynlocal; p ; p = p->next)
 p->dynindx = ++dynsymcount;
    }
  elf_hash_table (info)->local_dynsymcount = dynsymcount;

  elf_link_hash_traverse (elf_hash_table (info),
     elf_link_renumber_hash_table_dynsyms,
     &dynsymcount);





  dynsymcount++;

  elf_hash_table (info)->dynsymcount = dynsymcount;
  return dynsymcount;
}



static void
elf_merge_st_other (bfd *abfd, struct elf_link_hash_entry *h,
      unsigned int st_other, asection *sec,
      
# 1026 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 1026 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          definition, 
# 1026 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      _Bool 
# 1026 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           dynamic)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);



  if (bed->elf_backend_merge_symbol_attribute)
    (*bed->elf_backend_merge_symbol_attribute) (h, st_other, definition,
      dynamic);

  if (!dynamic)
    {
      unsigned symvis = ((st_other) & 0x3);
      unsigned hvis = ((h->other) & 0x3);



      if (symvis - 1 < hvis - 1)
 h->other = symvis | (h->other & ~((-1) & 0x3));
    }
  else if (definition
    && ((st_other) & 0x3) != 0
    && (sec->flags & 0x8) == 0)
    h->protected_def = 1;
}
# 1065 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
static 
# 1065 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 1066 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_merge_symbol (bfd *abfd,
         struct bfd_link_info *info,
         const char *name,
         Elf_Internal_Sym *sym,
         asection **psec,
         bfd_vma *pvalue,
         struct elf_link_hash_entry **sym_hash,
         bfd **poldbfd,
         
# 1074 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool 
# 1074 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             *pold_weak,
         unsigned int *pold_alignment,
         
# 1076 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool 
# 1076 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             *skip,
         bfd **override,
         
# 1078 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool 
# 1078 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             *type_change_ok,
         
# 1079 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool 
# 1079 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             *size_change_ok,
         
# 1080 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool 
# 1080 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             *matched)
{
  asection *sec, *oldsec;
  struct elf_link_hash_entry *h;
  struct elf_link_hash_entry *hi;
  struct elf_link_hash_entry *flip;
  int bind;
  bfd *oldbfd;
  
# 1088 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 1088 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      newdyn, olddyn, olddef, newdef, newdyncommon, olddyncommon;
  
# 1089 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 1089 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      newweak, oldweak, newfunc, oldfunc;
  const struct elf_backend_data *bed;
  char *new_version;
  
# 1092 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 1092 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      default_sym = *matched;
  struct elf_link_hash_table *htab;

  *skip = 
# 1095 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 1095 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  *override = 
# 1096 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 1096 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;

  sec = *psec;
  bind = (((unsigned int)(sym->st_info)) >> 4);

  if (! bfd_is_und_section (sec))
    h = elf_link_hash_lookup (elf_hash_table (info), name, 
# 1102 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                          1
# 1102 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                              , 
# 1102 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                                0
# 1102 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                     , 
# 1102 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                                       0
# 1102 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                            );
  else
    h = ((struct elf_link_hash_entry *)
  bfd_wrapped_link_hash_lookup (abfd, info, name, 
# 1105 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                 1
# 1105 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                     , 
# 1105 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                       0
# 1105 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                            , 
# 1105 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                              0
# 1105 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                   ));
  if (h == 
# 1106 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 1106 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    return 
# 1107 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 1107 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  *sym_hash = h;

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);


  if (h->versioned != unversioned)
    {

      new_version = strrchr (name, '@');
      if (new_version)
 {
   if (h->versioned == unknown)
     {
       if (new_version > name && new_version[-1] != '@')
  h->versioned = versioned_hidden;
       else
  h->versioned = versioned;
     }
   new_version += 1;
   if (new_version[0] == '\0')
     new_version = 
# 1128 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 1128 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
 }
      else
 h->versioned = unversioned;
    }
  else
    new_version = 
# 1134 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 1134 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ;



  hi = h;
  while (h->root.type == bfd_link_hash_indirect
  || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (!*matched)
    {
      if (hi == h || h->root.type == bfd_link_hash_new)
 *matched = 
# 1146 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 1146 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
      else
 {




   
# 1153 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 1153 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       old_hidden = h->versioned == versioned_hidden;
   
# 1154 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 1154 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       new_hidden = hi->versioned == versioned_hidden;
   if (!old_hidden && !new_hidden)


     *matched = 
# 1158 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               1
# 1158 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
   else
     {


       char *old_version;

       if (h->versioned >= versioned)
  old_version = strrchr (h->root.root.string,
           '@') + 1;
       else
   old_version = 
# 1169 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 1169 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;



       *matched = (old_version == new_version
     || (old_version != 
# 1174 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       ((void *)0)
         
# 1175 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        && new_version != 
# 1175 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0)
         
# 1176 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        && strcmp (old_version, new_version) == 0));
     }
 }
    }




  oldbfd = 
# 1184 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 1184 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  oldsec = 
# 1185 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 1185 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  switch (h->root.type)
    {
    default:
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      oldbfd = h->root.u.undef.abfd;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      oldbfd = h->root.u.def.section->owner;
      oldsec = h->root.u.def.section;
      break;

    case bfd_link_hash_common:
      oldbfd = h->root.u.c.p->section->owner;
      oldsec = h->root.u.c.p->section;
      if (pold_alignment)
 *pold_alignment = h->root.u.c.p->alignment_power;
      break;
    }
  if (poldbfd && *poldbfd == 
# 1209 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 1209 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
    *poldbfd = oldbfd;


  newweak = bind == 2;
  oldweak = (h->root.type == bfd_link_hash_defweak
      || h->root.type == bfd_link_hash_undefweak);
  if (pold_weak)
    *pold_weak = oldweak;




  bfd_elf_link_mark_dynamic_symbol (info, h, sym);

  htab = elf_hash_table (info);




  newdyn = (abfd->flags & 0x40) != 0;
# 1238 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if (newdyn)
    {
      if (bfd_is_und_section (sec))
 {
   if (bind != 2)
     {
       h->ref_dynamic_nonweak = 1;
       hi->ref_dynamic_nonweak = 1;
     }
 }
      else
 {

   if (*matched)
     h->dynamic_def = 1;
   hi->dynamic_def = 1;
 }
    }





  if (h->root.type == bfd_link_hash_new)
    {
      h->non_elf = 0;
      return 
# 1264 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 1264 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }







  if (abfd == oldbfd
      && (newweak || oldweak)
      && ((abfd->flags & 0x40) == 0
   || !h->def_regular))
    return 
# 1277 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 1277 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  olddyn = 
# 1279 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 1279 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  if (oldbfd != 
# 1280 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 1280 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
    olddyn = (oldbfd->flags & 0x40) != 0;
  else if (oldsec != 
# 1282 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 1282 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        )
    {


      olddyn = (oldsec->symbol->flags & (1 << 15)) != 0;
    }


  if (!htab->handling_dt_needed
      && oldbfd != 
# 1291 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
      
# 1292 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && (oldbfd->flags & 0x10000) != (abfd->flags & 0x10000))
    {
      if (newdyn != olddyn)
 {



   h->root.non_ir_ref_dynamic = 
# 1299 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               1
# 1299 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   ;
   hi->root.non_ir_ref_dynamic = 
# 1300 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                1
# 1300 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    ;
 }
      else if ((oldbfd->flags & 0x10000) != 0
        && hi->root.type == bfd_link_hash_indirect)
 {

   hi->root.type = bfd_link_hash_undefined;
   hi->root.u.undef.abfd = oldbfd;
 }
    }




  newdef = !bfd_is_und_section (sec) && !bfd_is_com_section (sec);

  olddef = (h->root.type != bfd_link_hash_undefined
     && h->root.type != bfd_link_hash_undefweak
     && h->root.type != bfd_link_hash_common);




  newfunc = (((sym->st_info) & 0xF) != 0
      && bed->is_function_type (((sym->st_info) & 0xF)));

  oldfunc = (h->type != 0
      && bed->is_function_type (h->type));

  if (!(newfunc && oldfunc)
      && ((sym->st_info) & 0xF) != h->type
      && ((sym->st_info) & 0xF) != 0
      && h->type != 0
      && (newdef || bfd_is_com_section (sec))
      && (olddef || h->root.type == bfd_link_hash_common))
    {





      if (newdyn
   && !olddyn)
 {
   *skip = 
# 1344 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 1344 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
   return 
# 1345 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 1345 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }




      if (hi != h
   && !newdyn
   && olddyn)
 {
   h = hi;
   (*bed->elf_backend_hide_symbol) (info, h, 
# 1356 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                            1
# 1356 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                );
   h->forced_local = 0;
   h->ref_dynamic = 0;
   h->def_dynamic = 0;
   h->dynamic_def = 0;
   if (h->root.u.undef.next || info->hash->undefs_tail == &h->root)
     {
       h->root.type = bfd_link_hash_undefined;
       h->root.u.undef.abfd = abfd;
     }
   else
     {
       h->root.type = bfd_link_hash_new;
       h->root.u.undef.abfd = 
# 1369 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
# 1369 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 ;
     }
   return 
# 1371 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 1371 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }
    }




  if (oldbfd != 
# 1378 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
      
# 1379 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && (oldbfd->flags & 0x10000) == 0
      && (abfd->flags & 0x10000) == 0
      && ((sym->st_info) & 0xF) != h->type
      && (((sym->st_info) & 0xF) == 6 || h->type == 6))
    {
      bfd *ntbfd, *tbfd;
      
# 1385 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 1385 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          ntdef, tdef;
      asection *ntsec, *tsec;

      if (h->type == 6)
 {
   ntbfd = abfd;
   ntsec = sec;
   ntdef = newdef;
   tbfd = oldbfd;
   tsec = oldsec;
   tdef = olddef;
 }
      else
 {
   ntbfd = oldbfd;
   ntsec = oldsec;
   ntdef = olddef;
   tbfd = abfd;
   tsec = sec;
   tdef = newdef;
 }

      if (tdef && ntdef)
 _bfd_error_handler

   (dgettext ("bfd", "%s: TLS definition in %pB section %pA " "mismatches non-TLS definition in %pB section %pA")
                                                         ,
    h->root.root.string, tbfd, tsec, ntbfd, ntsec);
      else if (!tdef && !ntdef)
 _bfd_error_handler

   (dgettext ("bfd", "%s: TLS reference in %pB " "mismatches non-TLS reference in %pB")
                                            ,
    h->root.root.string, tbfd, ntbfd);
      else if (tdef)
 _bfd_error_handler

   (dgettext ("bfd", "%s: TLS definition in %pB section %pA " "mismatches non-TLS reference in %pB")
                                            ,
    h->root.root.string, tbfd, tsec, ntbfd);
      else
 _bfd_error_handler

   (dgettext ("bfd", "%s: TLS reference in %pB " "mismatches non-TLS definition in %pB section %pA")
                                                         ,
    h->root.root.string, tbfd, ntbfd, ntsec);

      bfd_set_error (bfd_error_bad_value);
      return 
# 1433 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 1433 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }



  if (newdyn
      && ((h->other) & 0x3) != 0
      && !bfd_is_und_section (sec))
    {
      *skip = 
# 1442 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             1
# 1442 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;

      h->ref_dynamic = 1;
      hi->ref_dynamic = 1;




      if (((h->other) & 0x3) == 3)
 return bfd_elf_link_record_dynamic_symbol (info, h);
      else
 return 
# 1453 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 1453 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
    }
  else if (!newdyn
    && ((sym->st_other) & 0x3) != 0
    && h->def_dynamic)
    {



      if (hi->root.type == bfd_link_hash_indirect)
 {




   if (h->ref_regular)
     {
       hi->root.type = h->root.type;
       h->root.type = bfd_link_hash_indirect;
       (*bed->elf_backend_copy_indirect_symbol) (info, hi, h);

       h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
       if (((sym->st_other) & 0x3) != 3)
  {


    (*bed->elf_backend_hide_symbol) (info, h, 
# 1479 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             1
# 1479 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                 );
    h->forced_local = 0;
    h->ref_dynamic = 0;
  }
       else
  h->ref_dynamic = 1;

       h->def_dynamic = 0;

       h->size = 0;
       h->type = 0;

       h = hi;
     }
   else
     h = hi;
 }
# 1504 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      if (h->root.u.undef.next || info->hash->undefs_tail == &h->root)
 {
   h->root.type = bfd_link_hash_undefined;
   h->root.u.undef.abfd = abfd;
 }
      else
 {
   h->root.type = bfd_link_hash_new;
   h->root.u.undef.abfd = 
# 1512 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 1512 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;
 }

      if (((sym->st_other) & 0x3) != 3)
 {


   (*bed->elf_backend_hide_symbol) (info, h, 
# 1519 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                            1
# 1519 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                );
   h->forced_local = 0;
   h->ref_dynamic = 0;
 }
      else
 h->ref_dynamic = 1;
      h->def_dynamic = 0;

      h->size = 0;
      h->type = 0;
      return 
# 1529 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 1529 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }
# 1548 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if (newdef && !newdyn && (olddyn || h->root.ldscript_def))
    newweak = 
# 1549 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 1549 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
  if (olddef && newdyn)
    oldweak = 
# 1551 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 1551 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;


  if (newfunc && oldfunc)
    *type_change_ok = 
# 1555 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     1
# 1555 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;





  if (oldweak
      || newweak
      || (newdef
   && h->root.type == bfd_link_hash_undefined))
    *type_change_ok = 
# 1565 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     1
# 1565 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;




  if (*type_change_ok
      || h->root.type == bfd_link_hash_undefined)
    *size_change_ok = 
# 1572 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     1
# 1572 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
# 1597 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if (newdyn
      && newdef
      && !newweak
      && (sec->flags & 0x1) != 0
      && (sec->flags & 0x2) == 0
      && sym->st_size > 0
      && !newfunc)
    newdyncommon = 
# 1604 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 1604 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
  else
    newdyncommon = 
# 1606 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  0
# 1606 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;

  if (olddyn
      && olddef
      && h->root.type == bfd_link_hash_defined
      && h->def_dynamic
      && (h->root.u.def.section->flags & 0x1) != 0
      && (h->root.u.def.section->flags & 0x2) == 0
      && h->size > 0
      && !oldfunc)
    olddyncommon = 
# 1616 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 1616 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
  else
    olddyncommon = 
# 1618 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  0
# 1618 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;



  if (bed->merge_symbol != 
# 1622 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0)
# 1622 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                              )
    {
      if (!bed->merge_symbol (h, sym, psec, newdef, olddef, oldbfd, oldsec))
 return 
# 1625 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 1625 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      sec = *psec;
    }



  if (olddef && !olddyn && !oldweak && newdef && !newdyn && !newweak
      && !default_sym && h->def_regular
      && !(oldbfd != 
# 1633 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
    
# 1634 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && (oldbfd->flags & 0x10000) != 0
    && (abfd->flags & 0x10000) == 0))
    {

      (*info->callbacks->multiple_definition) (info, &h->root,
            abfd, sec, *pvalue);
      *skip = 
# 1640 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             1
# 1640 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
      return 
# 1641 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 1641 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }





  if (olddyncommon
      && newdyncommon
      && sym->st_size != h->size)
    {






      (*info->callbacks->multiple_common) (info, &h->root, abfd,
        bfd_link_hash_common, sym->st_size);
      if (sym->st_size > h->size)
 h->size = sym->st_size;

      *size_change_ok = 
# 1663 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 1663 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
    }
# 1680 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if (newdyn
      && newdef
      && (olddef
   || (h->root.type == bfd_link_hash_common
       && (newweak || newfunc))))
    {
      *override = abfd;
      newdef = 
# 1687 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              0
# 1687 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
      newdyncommon = 
# 1688 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 1688 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;

      *psec = sec = (&_bfd_std_section[1]);
      *size_change_ok = 
# 1691 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 1691 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;







      if (h->root.type == bfd_link_hash_common)
 *type_change_ok = 
# 1700 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 1700 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
    }







  if (newdyncommon
      && h->root.type == bfd_link_hash_common)
    {
      *override = oldbfd;
      newdef = 
# 1713 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              0
# 1713 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
      newdyncommon = 
# 1714 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 1714 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
      *pvalue = sym->st_size;
      *psec = sec = bed->common_section (oldsec);
      *size_change_ok = 
# 1717 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 1717 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
    }


  if (newdef && olddef && newweak)
    {

      if (!(oldbfd != 
# 1724 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
     
# 1725 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
    && (oldbfd->flags & 0x10000) != 0
     && (abfd->flags & 0x10000) == 0))
 {
   newdef = 
# 1728 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 1728 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   *skip = 
# 1729 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 1729 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }




      elf_merge_st_other (abfd, h, sym->st_other, sec, newdef, newdyn);
      if (h->dynindx != -1)
 switch (((h->other) & 0x3))
   {
   case 1:
   case 2:
     (*bed->elf_backend_hide_symbol) (info, h, 
# 1741 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                              1
# 1741 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                  );
     break;
   }
    }
# 1756 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  flip = 
# 1756 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 1756 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
  if (!newdyn
      && (newdef
   || (bfd_is_com_section (sec)
       && (oldweak || oldfunc)))
      && olddyn
      && olddef
      && h->def_dynamic)
    {




      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;
      *size_change_ok = 
# 1771 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 1771 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;

      olddef = 
# 1773 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              0
# 1773 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
      olddyncommon = 
# 1774 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 1774 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;




      if (bfd_is_com_section (sec))
 {
   if (oldfunc)
     {



       h->def_dynamic = 0;
       h->type = 0;
     }
   *type_change_ok = 
# 1789 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    1
# 1789 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
 }

      if (hi->root.type == bfd_link_hash_indirect)
 flip = hi;
      else



 h->verinfo.vertree = 
# 1798 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 1798 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
    }







  if (! newdyn
      && bfd_is_com_section (sec)
      && olddyncommon)
    {



      (*info->callbacks->multiple_common) (info, &h->root, abfd,
        bfd_link_hash_common, sym->st_size);




      if (h->size > *pvalue)
 *pvalue = h->size;



      do { if (!(pold_alignment)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",1825); } while (0);
      *pold_alignment = h->root.u.def.section->alignment_power;

      olddef = 
# 1828 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              0
# 1828 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
      olddyncommon = 
# 1829 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 1829 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;

      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = h->root.u.def.section->owner;

      *size_change_ok = 
# 1834 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 1834 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
      *type_change_ok = 
# 1835 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 1835 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;

      if (hi->root.type == bfd_link_hash_indirect)
 flip = hi;
      else
 h->verinfo.vertree = 
# 1840 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 1840 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
    }

  if (flip != 
# 1843 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 1843 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
    {



      flip->root.type = h->root.type;
      flip->root.u.undef.abfd = h->root.u.undef.abfd;
      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) flip;
      (*bed->elf_backend_copy_indirect_symbol) (info, flip, h);
      if (h->def_dynamic)
 {
   h->def_dynamic = 0;
   flip->ref_dynamic = 1;
 }
    }

  return 
# 1860 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 1860 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






static 
# 1868 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 1869 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_add_default_symbol (bfd *abfd,
        struct bfd_link_info *info,
        struct elf_link_hash_entry *h,
        const char *name,
        Elf_Internal_Sym *sym,
        asection *sec,
        bfd_vma value,
        bfd **poldbfd,
        
# 1877 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       _Bool 
# 1877 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            *dynsym)
{
  
# 1879 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 1879 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      type_change_ok;
  
# 1880 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 1880 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      size_change_ok;
  
# 1881 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 1881 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      skip;
  char *shortname;
  struct elf_link_hash_entry *hi;
  struct bfd_link_hash_entry *bh;
  const struct elf_backend_data *bed;
  
# 1886 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 1886 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      collect;
  
# 1887 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 1887 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      dynamic;
  bfd *override;
  char *p;
  size_t len, shortlen;
  asection *tmp_sec;
  
# 1892 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 1892 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      matched;

  if (h->versioned == unversioned || h->versioned == versioned_hidden)
    return 
# 1895 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 1895 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;





  p = strchr (name, '@');
  if (h->versioned == unknown)
    {
      if (p == 
# 1904 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 1904 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 {
   h->versioned = unversioned;
   return 
# 1907 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 1907 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }
      else
 {
   if (p[1] != '@')
     {
       h->versioned = versioned_hidden;
       return 
# 1914 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             1
# 1914 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
     }
   else
     h->versioned = versioned;
 }
    }
  else
    {


      if (p == 
# 1924 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 1924 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 return 
# 1925 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 1925 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
    }

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  collect = bed->collect;
  dynamic = (abfd->flags & 0x40) != 0;

  shortlen = p - name;
  shortname = (char *) bfd_hash_allocate (&info->hash->table, shortlen + 1);
  if (shortname == 
# 1934 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 1934 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
    return 
# 1935 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 1935 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  memcpy (shortname, name, shortlen);
  shortname[shortlen] = '\0';





  type_change_ok = 
# 1943 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  0
# 1943 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
  size_change_ok = 
# 1944 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  0
# 1944 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
  matched = 
# 1945 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 1945 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  tmp_sec = sec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &tmp_sec, &value,
         &hi, poldbfd, 
# 1948 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 1948 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          , 
# 1948 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 1948 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                , &skip, &override,
         &type_change_ok, &size_change_ok, &matched))
    return 
# 1950 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 1950 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (skip)
    goto nondefault;

  if (hi->def_regular || (!(hi)->def_regular && !(hi)->def_dynamic && (hi)->root.type == bfd_link_hash_defined))
    {





      if (hi->verinfo.vertree == 
# 1962 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0) 
# 1962 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                     && info->version_info != 
# 1962 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                              ((void *)0)
# 1962 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                  )
 {
   
# 1964 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 1964 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       hide;

   hi->verinfo.vertree
     = bfd_find_version_for_sym (info->version_info,
     hi->root.root.string, &hide);
   if (hi->verinfo.vertree != 
# 1969 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0) 
# 1969 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                  && hide)
     {
       (*bed->elf_backend_hide_symbol) (info, hi, 
# 1971 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                 1
# 1971 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                     );
       goto nondefault;
     }
 }
      if (hi->verinfo.vertree != 
# 1975 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
   
# 1976 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && strcmp (p + 1 + (p[1] == '@'), hi->verinfo.vertree->name) != 0)
 goto nondefault;
    }

  if (! override)
    {

      if (! ((info)->type == type_relocatable))
 {
   bh = &hi->root;
   if (bh->type == bfd_link_hash_defined
       && bh->u.def.section->owner != 
# 1987 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
       
# 1988 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && (bh->u.def.section->owner->flags & 0x10000) != 0)
     {



       bh->type = bfd_link_hash_undefined;
       bh->u.undef.abfd = bh->u.def.section->owner;
     }
   if (! (_bfd_generic_link_add_one_symbol
   (info, abfd, shortname, (1 << 13),
    (&_bfd_std_section[3]),
    0, name, 
# 1999 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 1999 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 , collect, &bh)))
     return 
# 2000 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 2000 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   hi = (struct elf_link_hash_entry *) bh;
 }
    }
  else
    {
# 2024 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      while (hi->root.type == bfd_link_hash_indirect
      || hi->root.type == bfd_link_hash_warning)
 hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

      h->root.type = bfd_link_hash_indirect;
      h->root.u.i.link = (struct bfd_link_hash_entry *) hi;
      if (h->def_dynamic)
 {
   h->def_dynamic = 0;
   hi->ref_dynamic = 1;
   if (hi->ref_regular
       || hi->def_regular)
     {
       if (! bfd_elf_link_record_dynamic_symbol (info, hi))
  return 
# 2038 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 2038 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
     }
 }



      hi = h;
    }


  if (hi->root.type == bfd_link_hash_warning)
    hi = (struct elf_link_hash_entry *) hi->root.u.i.link;





  if (hi->root.type == bfd_link_hash_indirect)
    {
      struct elf_link_hash_entry *ht;

      ht = (struct elf_link_hash_entry *) hi->root.u.i.link;
      (*bed->elf_backend_copy_indirect_symbol) (info, ht, hi);



      elf_merge_st_other (abfd, ht, hi->other, sec, 
# 2064 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                   1
# 2064 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                       , dynamic);




      ht->ref_dynamic_nonweak |= hi->ref_dynamic_nonweak;
      hi->dynamic_def |= ht->dynamic_def;



      if (! *dynsym)
 {
   if (! dynamic)
     {
       if (! (((info)->type == type_pde) || ((info)->type == type_pie))
    || hi->def_dynamic
    || hi->ref_dynamic)
  *dynsym = 
# 2081 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 2081 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
     }
   else
     {
       if (hi->ref_regular)
  *dynsym = 
# 2086 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 2086 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
     }
 }
    }




 nondefault:
  len = strlen (name);
  shortname = (char *) bfd_hash_allocate (&info->hash->table, len);
  if (shortname == 
# 2097 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 2097 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
    return 
# 2098 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 2098 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  memcpy (shortname, name, shortlen);
  memcpy (shortname + shortlen, p + 1, len - shortlen);


  type_change_ok = 
# 2103 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  0
# 2103 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
  size_change_ok = 
# 2104 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  0
# 2104 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
  tmp_sec = sec;
  if (!_bfd_elf_merge_symbol (abfd, info, shortname, sym, &tmp_sec, &value,
         &hi, poldbfd, 
# 2107 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 2107 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          , 
# 2107 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 2107 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                , &skip, &override,
         &type_change_ok, &size_change_ok, &matched))
    return 
# 2109 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 2109 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (skip)
    {
      if (!dynamic
   && h->root.type == bfd_link_hash_defweak
   && hi->root.type == bfd_link_hash_defined)
 {





   h->root.type = bfd_link_hash_defined;
   h->root.u.def.section = hi->root.u.def.section;
   h->root.u.def.value = hi->root.u.def.value;
   hi->root.type = bfd_link_hash_indirect;
   hi->root.u.i.link = &h->root;
 }
      else
 return 
# 2129 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 2129 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
    }
  else if (override)
    {



      if (hi->root.type != bfd_link_hash_defined
   && hi->root.type != bfd_link_hash_defweak)
 _bfd_error_handler

   (dgettext ("bfd", "%pB: unexpected redefinition of indirect versioned symbol `%s'"),
    abfd, shortname);
      return 
# 2142 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 2142 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }
  else
    {
      bh = &hi->root;
      if (! (_bfd_generic_link_add_one_symbol
      (info, abfd, shortname, (1 << 13),
       (&_bfd_std_section[3]), 0, name, 
# 2149 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                    0
# 2149 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         , collect, &bh)))
 return 
# 2150 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 2150 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      hi = (struct elf_link_hash_entry *) bh;
    }




  if (hi->root.type == bfd_link_hash_indirect)
    {
      (*bed->elf_backend_copy_indirect_symbol) (info, h, hi);
      h->ref_dynamic_nonweak |= hi->ref_dynamic_nonweak;
      hi->dynamic_def |= h->dynamic_def;




      elf_merge_st_other (abfd, h, hi->other, sec, 
# 2166 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                  1
# 2166 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                      , dynamic);



      if (! *dynsym)
 {
   if (! dynamic)
     {
       if (! (((info)->type == type_pde) || ((info)->type == type_pie))
    || hi->ref_dynamic)
  *dynsym = 
# 2176 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 2176 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
     }
   else
     {
       if (hi->ref_regular)
  *dynsym = 
# 2181 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 2181 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
     }
 }
    }

  return 
# 2186 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2186 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




static 
# 2192 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 2193 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_export_symbol (struct elf_link_hash_entry *h, void *data)
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;


  if (h->root.type == bfd_link_hash_indirect)
    return 
# 2199 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 2199 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (!eif->info->export_dynamic && !h->dynamic)
    return 
# 2203 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 2203 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  if (h->dynindx == -1
      && (h->def_regular || h->ref_regular)
      && ! bfd_hide_sym_by_version (eif->info->version_info,
        h->root.root.string))
    {
      if (! bfd_elf_link_record_dynamic_symbol (eif->info, h))
 {
   eif->failed = 
# 2212 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                1
# 2212 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;
   return 
# 2213 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 2213 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }
    }

  return 
# 2217 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2217 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





static 
# 2224 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 2225 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_add_dt_relr_dependency (struct elf_find_verdep_info *rinfo)
{
  bfd *glibc_bfd = 
# 2227 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 2227 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
  Elf_Internal_Verneed *t;
  Elf_Internal_Vernaux *a;
  size_t amt;
  const char *relr = "GLIBC_ABI_DT_RELR";


  for (t = ((rinfo->info->output_bfd) -> tdata.elf_obj_data)->verref;
       t != 
# 2235 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 2235 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
       t = t->vn_nextref)
    {
      const char *soname = bfd_elf_get_dt_soname (t->vn_bfd);

      if (!soname || !startswith (soname, "libc.so."))
 continue;

      for (a = t->vn_auxptr; a != 
# 2243 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 ((void *)0)
# 2243 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                     ; a = a->vna_nextptr)
 {


   if (a->vna_nodename == relr
       || strcmp (a->vna_nodename, relr) == 0)
     return 
# 2249 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 2249 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


   if (!glibc_bfd && startswith (a->vna_nodename, "GLIBC_2."))
     glibc_bfd = t->vn_bfd;
 }

      break;
    }


  if (glibc_bfd == 
# 2260 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 2260 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
    return 
# 2261 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 2261 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (t == 
# 2264 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 2264 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {
      amt = sizeof *t;
      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->info->output_bfd,
            amt);
      if (t == 
# 2269 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 2269 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 {
   rinfo->failed = 
# 2271 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 2271 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
   return 
# 2272 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 2272 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }

      t->vn_bfd = glibc_bfd;
      t->vn_nextref = ((rinfo->info->output_bfd) -> tdata.elf_obj_data)->verref;
      ((rinfo->info->output_bfd) -> tdata.elf_obj_data)->verref = t;
    }

  amt = sizeof *a;
  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->info->output_bfd, amt);
  if (a == 
# 2282 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 2282 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {
      rinfo->failed = 
# 2284 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     1
# 2284 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
      return 
# 2285 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 2285 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }

  a->vna_nodename = relr;
  a->vna_flags = 0;
  a->vna_nextptr = t->vn_auxptr;
  a->vna_other = rinfo->vers + 1;
  ++rinfo->vers;

  t->vn_auxptr = a;

  return 
# 2296 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2296 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






static 
# 2304 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 2305 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_find_version_dependencies (struct elf_link_hash_entry *h,
      void *data)
{
  struct elf_find_verdep_info *rinfo = (struct elf_find_verdep_info *) data;
  Elf_Internal_Verneed *t;
  Elf_Internal_Vernaux *a;
  size_t amt;



  if (!h->def_dynamic
      || h->def_regular
      || h->dynindx == -1
      || h->verinfo.verdef == 
# 2318 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
      
# 2319 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || ((((h->verinfo.verdef->vd_bfd) -> tdata.elf_obj_data) -> dyn_lib_class)
   & (DYN_AS_NEEDED | DYN_DT_NEEDED | DYN_NO_NEEDED)))
    return 
# 2321 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 2321 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  for (t = ((rinfo->info->output_bfd) -> tdata.elf_obj_data)->verref;
       t != 
# 2325 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 2325 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
       t = t->vn_nextref)
    {
      if (t->vn_bfd != h->verinfo.verdef->vd_bfd)
 continue;

      for (a = t->vn_auxptr; a != 
# 2331 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 ((void *)0)
# 2331 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                     ; a = a->vna_nextptr)
 if (a->vna_nodename == h->verinfo.verdef->vd_nodename)
   return 
# 2333 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 2333 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;

      break;
    }



  if (t == 
# 2340 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 2340 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {
      amt = sizeof *t;
      t = (Elf_Internal_Verneed *) bfd_zalloc (rinfo->info->output_bfd, amt);
      if (t == 
# 2344 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 2344 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 {
   rinfo->failed = 
# 2346 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 2346 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
   return 
# 2347 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 2347 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }

      t->vn_bfd = h->verinfo.verdef->vd_bfd;
      t->vn_nextref = ((rinfo->info->output_bfd) -> tdata.elf_obj_data)->verref;
      ((rinfo->info->output_bfd) -> tdata.elf_obj_data)->verref = t;
    }

  amt = sizeof *a;
  a = (Elf_Internal_Vernaux *) bfd_zalloc (rinfo->info->output_bfd, amt);
  if (a == 
# 2357 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 2357 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {
      rinfo->failed = 
# 2359 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     1
# 2359 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
      return 
# 2360 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 2360 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }





  a->vna_nodename = h->verinfo.verdef->vd_nodename;

  a->vna_flags = h->verinfo.verdef->vd_flags;
  a->vna_nextptr = t->vn_auxptr;

  h->verinfo.verdef->vd_exp_refno = rinfo->vers;
  ++rinfo->vers;

  a->vna_other = h->verinfo.verdef->vd_exp_refno + 1;

  t->vn_auxptr = a;

  return 
# 2379 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2379 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




static 
# 2385 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 2386 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_hide_versioned_symbol (struct bfd_link_info *info,
         struct elf_link_hash_entry *h,
         const char *version_p,
         struct bfd_elf_version_tree **t_p,
         
# 2390 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool 
# 2390 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             *hide)
{
  struct bfd_elf_version_tree *t;


  for (t = info->version_info; t != 
# 2395 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 2395 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; t = t->next)
    {
      if (strcmp (t->name, version_p) == 0)
 {
   size_t len;
   char *alc;
   struct bfd_elf_version_expr *d;

   len = version_p - h->root.root.string;
   alc = (char *) bfd_malloc (len);
   if (alc == 
# 2405 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 2405 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
     return 
# 2406 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 2406 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   memcpy (alc, h->root.root.string, len - 1);
   alc[len - 1] = '\0';
   if (alc[len - 2] == '@')
     alc[len - 2] = '\0';

   h->verinfo.vertree = t;
   t->used = 
# 2413 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 2413 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   d = 
# 2414 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      ((void *)0)
# 2414 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          ;

   if (t->globals.list != 
# 2416 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 2416 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
     d = (*t->match) (&t->globals, 
# 2417 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 2417 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      , alc);



   if (d == 
# 2421 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0) 
# 2421 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                && t->locals.list != 
# 2421 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 2421 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         )
     {
       d = (*t->match) (&t->locals, 
# 2423 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 2423 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       , alc);
       if (d != 
# 2424 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
    
# 2425 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && h->dynindx != -1
    && ! info->export_dynamic)
  *hide = 
# 2427 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 2427 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
     }

   free (alc);
   break;
 }
    }

  *t_p = t;

  return 
# 2437 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2437 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




# 2442 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 2443 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_hide_sym_by_version (struct bfd_link_info *info,
       struct elf_link_hash_entry *h)
{
  const char *p;
  
# 2447 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 2447 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      hide = 
# 2447 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 2447 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
  const struct elf_backend_data *bed
    = ((const struct elf_backend_data *) ((info->output_bfd)->xvec)->backend_data);


  if (!h->def_regular && !(!(h)->def_regular && !(h)->def_dynamic && (h)->root.type == bfd_link_hash_defined))
    return 
# 2453 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 2453 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  p = strchr (h->root.root.string, '@');
  if (p != 
# 2456 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0) 
# 2456 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               && h->verinfo.vertree == 
# 2456 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                        ((void *)0)
# 2456 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                            )
    {
      struct bfd_elf_version_tree *t;

      ++p;
      if (*p == '@')
 ++p;

      if (*p != '\0'
   && _bfd_elf_link_hide_versioned_symbol (info, h, p, &t, &hide)
   && hide)
 {
   if (hide)
     (*bed->elf_backend_hide_symbol) (info, h, 
# 2469 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                              1
# 2469 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                  );
   return 
# 2470 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 2470 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }
    }



  if (h->verinfo.vertree == 
# 2476 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0) 
# 2476 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                && info->version_info != 
# 2476 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                         ((void *)0)
# 2476 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                             )
    {
      h->verinfo.vertree
 = bfd_find_version_for_sym (info->version_info,
        h->root.root.string, &hide);
      if (h->verinfo.vertree != 
# 2481 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0) 
# 2481 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    && hide)
 {
   (*bed->elf_backend_hide_symbol) (info, h, 
# 2483 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                            1
# 2483 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                );
   return 
# 2484 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 2484 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }
    }

  return 
# 2488 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 2488 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}






static 
# 2496 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 2497 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_assign_sym_version (struct elf_link_hash_entry *h, void *data)
{
  struct elf_info_failed *sinfo;
  struct bfd_link_info *info;
  const struct elf_backend_data *bed;
  struct elf_info_failed eif;
  char *p;
  
# 2504 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 2504 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      hide;

  sinfo = (struct elf_info_failed *) data;
  info = sinfo->info;


  eif.failed = 
# 2510 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              0
# 2510 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
  eif.info = info;
  if (! _bfd_elf_fix_symbol_flags (h, &eif))
    {
      if (eif.failed)
 sinfo->failed = 
# 2515 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                1
# 2515 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;
      return 
# 2516 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 2516 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }

  bed = ((const struct elf_backend_data *) ((info->output_bfd)->xvec)->backend_data);



  if (!h->def_regular && !(!(h)->def_regular && !(h)->def_dynamic && (h)->root.type == bfd_link_hash_defined))
    {

      if ((h->root.type == bfd_link_hash_defined
    || h->root.type == bfd_link_hash_defweak)
   && discarded_section (h->root.u.def.section))
 (*bed->elf_backend_hide_symbol) (info, h, 
# 2529 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          1
# 2529 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              );
      return 
# 2530 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 2530 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }

  hide = 
# 2533 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 2533 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
  p = strchr (h->root.root.string, '@');
  if (p != 
# 2535 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0) 
# 2535 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               && h->verinfo.vertree == 
# 2535 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                        ((void *)0)
# 2535 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                            )
    {
      struct bfd_elf_version_tree *t;

      ++p;
      if (*p == '@')
 ++p;


      if (*p == '\0')
 return 
# 2545 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 2545 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;

      if (!_bfd_elf_link_hide_versioned_symbol (info, h, p, &t, &hide))
 {
   sinfo->failed = 
# 2549 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 2549 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
   return 
# 2550 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 2550 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }

      if (hide)
 (*bed->elf_backend_hide_symbol) (info, h, 
# 2554 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          1
# 2554 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              );



      if (t == 
# 2558 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 2558 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   && (((info)->type == type_pde) || ((info)->type == type_pie)))
 {
   struct bfd_elf_version_tree **pp;
   int version_index;



   if (h->dynindx == -1)
     return 
# 2566 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 2566 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

   t = (struct bfd_elf_version_tree *) bfd_zalloc (info->output_bfd,
         sizeof *t);
   if (t == 
# 2570 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 2570 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               )
     {
       sinfo->failed = 
# 2572 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      1
# 2572 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          ;
       return 
# 2573 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 2573 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }

   t->name = p;
   t->name_indx = (unsigned int) -1;
   t->used = 
# 2578 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 2578 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   version_index = 1;

   if (sinfo->info->version_info != 
# 2582 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
       
# 2583 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && sinfo->info->version_info->vernum == 0)
     version_index = 0;
   for (pp = &sinfo->info->version_info;
        *pp != 
# 2586 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 2586 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
        pp = &(*pp)->next)
     ++version_index;
   t->vernum = version_index;

   *pp = t;

   h->verinfo.vertree = t;
 }
      else if (t == 
# 2595 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 2595 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
 {


   _bfd_error_handler

     (dgettext ("bfd", "%pB: version node not found for symbol %s"),
      info->output_bfd, h->root.root.string);
   bfd_set_error (bfd_error_bad_value);
   sinfo->failed = 
# 2604 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 2604 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
   return 
# 2605 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 2605 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }
    }



  if (!hide
      && h->verinfo.vertree == 
# 2612 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
      
# 2613 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && sinfo->info->version_info != 
# 2613 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 2613 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         )
    {
      h->verinfo.vertree
 = bfd_find_version_for_sym (sinfo->info->version_info,
        h->root.root.string, &hide);
      if (h->verinfo.vertree != 
# 2618 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0) 
# 2618 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    && hide)
 (*bed->elf_backend_hide_symbol) (info, h, 
# 2619 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          1
# 2619 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              );
    }

  return 
# 2622 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2622 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}
# 2634 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
static 
# 2634 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 2635 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_read_relocs_from_section (bfd *abfd,
       asection *sec,
       Elf_Internal_Shdr *shdr,
       void *external_relocs,
       Elf_Internal_Rela *internal_relocs)
{
  const struct elf_backend_data *bed;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  const bfd_byte *erela;
  const bfd_byte *erelaend;
  Elf_Internal_Rela *irela;
  Elf_Internal_Shdr *symtab_hdr;
  size_t nsyms;


  if (bfd_seek (abfd, shdr->sh_offset, 
# 2650 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      0
# 2650 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              ) != 0)
    return 
# 2651 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 2651 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  if (bfd_bread (external_relocs, shdr->sh_size, abfd) != shdr->sh_size)
    return 
# 2655 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 2655 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  symtab_hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;
  nsyms = ((symtab_hdr)->sh_entsize > 0 ? (symtab_hdr)->sh_size / (symtab_hdr)->sh_entsize : 0);

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);


  if (shdr->sh_entsize == bed->s->sizeof_rel)
    swap_in = bed->s->swap_reloc_in;
  else if (shdr->sh_entsize == bed->s->sizeof_rela)
    swap_in = bed->s->swap_reloca_in;
  else
    {
      bfd_set_error (bfd_error_wrong_format);
      return 
# 2670 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 2670 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }

  erela = (const bfd_byte *) external_relocs;


  erelaend = erela + shdr->sh_size - shdr->sh_entsize;
  irela = internal_relocs;
  while (erela <= erelaend)
    {
      bfd_vma r_symndx;

      (*swap_in) (abfd, erela, irela);
      r_symndx = ((irela->r_info) >> 8);
      if (bed->s->arch_size == 64)
 r_symndx >>= 24;
      if (nsyms > 0)
 {
   if ((size_t) r_symndx >= nsyms)
     {
       _bfd_error_handler

  (dgettext ("bfd", "%pB: bad reloc symbol index (%#" 
# 2692 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  "l" "x" 
# 2692 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  " >= %#lx)" " for offset %#" 
# 2692 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  "l" "x" 
# 2692 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  " in section `%pA'")
                                                 ,
   abfd, (uint64_t) r_symndx, (unsigned long) nsyms,
   (uint64_t) irela->r_offset, sec);
       bfd_set_error (bfd_error_bad_value);
       return 
# 2697 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 2697 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
 }
      else if (r_symndx != 0)
 {
   _bfd_error_handler

     (dgettext ("bfd", "%pB: non-zero symbol index (%#" 
# 2704 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     "l" "x" 
# 2704 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ")" " for offset %#" 
# 2704 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     "l" "x" 
# 2704 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     " in section `%pA'" " when the object file has no symbol table")

                                                    ,
      abfd, (uint64_t) r_symndx,
      (uint64_t) irela->r_offset, sec);
   bfd_set_error (bfd_error_bad_value);
   return 
# 2710 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 2710 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }
      irela += bed->s->int_rels_per_ext_rel;
      erela += shdr->sh_entsize;
    }

  return 
# 2716 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2716 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}
# 2730 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
Elf_Internal_Rela *
_bfd_elf_link_info_read_relocs (bfd *abfd,
    struct bfd_link_info *info,
    asection *o,
    void *external_relocs,
    Elf_Internal_Rela *internal_relocs,
    
# 2736 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
   _Bool 
# 2736 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        keep_memory)
{
  void *alloc1 = 
# 2738 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 2738 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;
  Elf_Internal_Rela *alloc2 = 
# 2739 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
# 2739 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 ;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  struct bfd_elf_section_data *esdo = ((struct bfd_elf_section_data*)(o)->used_by_bfd);
  Elf_Internal_Rela *internal_rela_relocs;

  if (esdo->relocs != 
# 2744 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 2744 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
    return esdo->relocs;

  if (o->reloc_count == 0)
    return 
# 2748 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 2748 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  if (internal_relocs == 
# 2750 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0)
# 2750 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                            )
    {
      bfd_size_type size;

      size = (bfd_size_type) o->reloc_count * sizeof (Elf_Internal_Rela);
      if (keep_memory)
 {
   internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_alloc (abfd, size);
   if (info)
     info->cache_size += size;
 }
      else
 internal_relocs = alloc2 = (Elf_Internal_Rela *) bfd_malloc (size);
      if (internal_relocs == 
# 2763 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 2763 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
 goto error_return;
    }

  if (external_relocs == 
# 2767 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0)
# 2767 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                            )
    {
      bfd_size_type size = 0;

      if (esdo->rel.hdr)
 size += esdo->rel.hdr->sh_size;
      if (esdo->rela.hdr)
 size += esdo->rela.hdr->sh_size;

      alloc1 = bfd_malloc (size);
      if (alloc1 == 
# 2777 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 2777 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
 goto error_return;
      external_relocs = alloc1;
    }

  internal_rela_relocs = internal_relocs;
  if (esdo->rel.hdr)
    {
      if (!elf_link_read_relocs_from_section (abfd, o, esdo->rel.hdr,
           external_relocs,
           internal_relocs))
 goto error_return;
      external_relocs = (((bfd_byte *) external_relocs)
    + esdo->rel.hdr->sh_size);
      internal_rela_relocs += (((esdo->rel.hdr)->sh_entsize > 0 ? (esdo->rel.hdr)->sh_size / (esdo->rel.hdr)->sh_entsize : 0)
          * bed->s->int_rels_per_ext_rel);
    }

  if (esdo->rela.hdr
      && (!elf_link_read_relocs_from_section (abfd, o, esdo->rela.hdr,
           external_relocs,
           internal_rela_relocs)))
    goto error_return;


  if (keep_memory)
    esdo->relocs = internal_relocs;

  free (alloc1);




  return internal_relocs;

 error_return:
  free (alloc1);
  if (alloc2 != 
# 2814 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 2814 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
    {
      if (keep_memory)
 bfd_release (abfd, alloc2);
      else
 free (alloc2);
    }
  return 
# 2821 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 2821 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





Elf_Internal_Rela *
_bfd_elf_link_read_relocs (bfd *abfd,
      asection *o,
      void *external_relocs,
      Elf_Internal_Rela *internal_relocs,
      
# 2833 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 2833 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          keep_memory)
{
  return _bfd_elf_link_info_read_relocs (abfd, 
# 2835 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                              ((void *)0)
# 2835 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                  , o, external_relocs,
      internal_relocs, keep_memory);

}




static 
# 2843 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 2844 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_size_reloc_section (bfd *abfd,
      struct bfd_elf_section_reloc_data *reldata)
{
  Elf_Internal_Shdr *rel_hdr = reldata->hdr;


  rel_hdr->sh_size = rel_hdr->sh_entsize * reldata->count;





  rel_hdr->contents = (unsigned char *) bfd_zalloc (abfd, rel_hdr->sh_size);
  if (rel_hdr->contents == 
# 2857 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0) 
# 2857 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               && rel_hdr->sh_size != 0)
    return 
# 2858 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 2858 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (reldata->hashes == 
# 2860 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0) 
# 2860 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             && reldata->count)
    {
      struct elf_link_hash_entry **p;

      p = ((struct elf_link_hash_entry **)
    bfd_zmalloc (reldata->count * sizeof (*p)));
      if (p == 
# 2866 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 2866 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 return 
# 2867 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 2867 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

      reldata->hashes = p;
    }

  return 
# 2872 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2872 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






# 2879 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 2880 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_output_relocs (bfd *output_bfd,
        asection *input_section,
        Elf_Internal_Shdr *input_rel_hdr,
        Elf_Internal_Rela *internal_relocs,
        struct elf_link_hash_entry **rel_hash
          __attribute__ ((__unused__)))
{
  Elf_Internal_Rela *irela;
  Elf_Internal_Rela *irelaend;
  bfd_byte *erel;
  struct bfd_elf_section_reloc_data *output_reldata;
  asection *output_section;
  const struct elf_backend_data *bed;
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  struct bfd_elf_section_data *esdo;

  output_section = input_section->output_section;

  bed = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);
  esdo = ((struct bfd_elf_section_data*)(output_section)->used_by_bfd);
  if (esdo->rel.hdr && esdo->rel.hdr->sh_entsize == input_rel_hdr->sh_entsize)
    {
      output_reldata = &esdo->rel;
      swap_out = bed->s->swap_reloc_out;
    }
  else if (esdo->rela.hdr
    && esdo->rela.hdr->sh_entsize == input_rel_hdr->sh_entsize)
    {
      output_reldata = &esdo->rela;
      swap_out = bed->s->swap_reloca_out;
    }
  else
    {
      _bfd_error_handler

 (dgettext ("bfd", "%pB: relocation size mismatch in %pB section %pA"),
  output_bfd, input_section->owner, input_section);
      bfd_set_error (bfd_error_wrong_format);
      return 
# 2918 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 2918 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }

  erel = output_reldata->hdr->contents;
  erel += output_reldata->count * input_rel_hdr->sh_entsize;
  irela = internal_relocs;
  irelaend = irela + (((input_rel_hdr)->sh_entsize > 0 ? (input_rel_hdr)->sh_size / (input_rel_hdr)->sh_entsize : 0)
        * bed->s->int_rels_per_ext_rel);
  while (irela < irelaend)
    {
      (*swap_out) (output_bfd, irela, erel);
      irela += bed->s->int_rels_per_ext_rel;
      erel += input_rel_hdr->sh_entsize;
    }



  output_reldata->count += ((input_rel_hdr)->sh_entsize > 0 ? (input_rel_hdr)->sh_size / (input_rel_hdr)->sh_entsize : 0);

  return 
# 2937 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2937 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




# 2942 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 2943 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_hash_fixup_symbol (struct bfd_link_info *info,
     struct elf_link_hash_entry *h)
{
  if (((info)->type == type_pie)
      && h->dynindx == -1
      && h->root.type == bfd_link_hash_undefweak)
    return bfd_elf_link_record_dynamic_symbol (info, h);

  return 
# 2951 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 2951 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}







static 
# 2960 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 2961 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_fix_symbol_flags (struct elf_link_hash_entry *h,
      struct elf_info_failed *eif)
{
  const struct elf_backend_data *bed;





  if (h->non_elf)
    {
      while (h->root.type == bfd_link_hash_indirect)
 h = (struct elf_link_hash_entry *) h->root.u.i.link;

      if (h->root.type != bfd_link_hash_defined
   && h->root.type != bfd_link_hash_defweak)
 {
   h->ref_regular = 1;
   h->ref_regular_nonweak = 1;
 }
      else
 {
   if (h->root.u.def.section->owner != 
# 2983 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
       
# 2984 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && (bfd_get_flavour (h->root.u.def.section->owner)
    == bfd_target_elf_flavour))
     {
       h->ref_regular = 1;
       h->ref_regular_nonweak = 1;
     }
   else
     h->def_regular = 1;
 }

      if (h->dynindx == -1
   && (h->def_dynamic
       || h->ref_dynamic))
 {
   if (! bfd_elf_link_record_dynamic_symbol (eif->info, h))
     {
       eif->failed = 
# 3000 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    1
# 3000 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
       return 
# 3001 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 3001 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
 }
    }
  else
    {






      if ((h->root.type == bfd_link_hash_defined
    || h->root.type == bfd_link_hash_defweak)
   && !h->def_regular
   && (h->root.u.def.section->owner != 
# 3016 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
       
# 3017 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ? (bfd_get_flavour (h->root.u.def.section->owner)
   != bfd_target_elf_flavour)
       : (bfd_is_abs_section (h->root.u.def.section)
   && !h->def_dynamic)))
 h->def_regular = 1;
    }


  bed = ((const struct elf_backend_data *) ((elf_hash_table (eif->info)->dynobj)->xvec)->backend_data);
  if (bed->elf_backend_fixup_symbol
      && !(*bed->elf_backend_fixup_symbol) (eif->info, h))
    return 
# 3028 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3028 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;






  if (h->root.type == bfd_link_hash_defined
      && !h->def_regular
      && h->ref_regular
      && !h->def_dynamic
      && (h->root.u.def.section->owner->flags & (0x40 | 0x10000)) == 0)
    h->def_regular = 1;


  if (h->root.type == bfd_link_hash_undefined && h->indx == -3)
    (*bed->elf_backend_hide_symbol) (eif->info, h, 
# 3044 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                  1
# 3044 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                      );



  else if (((h->other) & 0x3) != 0
    && h->root.type == bfd_link_hash_undefweak)
    (*bed->elf_backend_hide_symbol) (eif->info, h, 
# 3050 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                  1
# 3050 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                      );




  else if ((((eif->info)->type == type_pde) || ((eif->info)->type == type_pie))
    && h->versioned == versioned_hidden
    && !eif->info->export_dynamic
    && !h->dynamic
    && !h->ref_dynamic
    && h->def_regular)
    (*bed->elf_backend_hide_symbol) (eif->info, h, 
# 3061 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                  1
# 3061 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                      );







  else if (h->needs_plt
    && (((eif->info)->type == type_dll) || ((eif->info)->type == type_pie))
    && is_elf_hash_table (eif->info->hash)
    && ((!(h)->unique_global && ((eif->info)->symbolic || (h)->start_stop || ((eif->info)->dynamic && !(h)->dynamic)))
        || ((h->other) & 0x3) != 0)
    && h->def_regular)
    {
      
# 3076 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 3076 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          force_local;

      force_local = (((h->other) & 0x3) == 1
       || ((h->other) & 0x3) == 2);
      (*bed->elf_backend_hide_symbol) (eif->info, h, force_local);
    }




  if (h->is_weakalias)
    {
      struct elf_link_hash_entry *def = weakdef (h);
# 3100 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      if (def->def_regular
   || def->root.type != bfd_link_hash_defined)
 {
   h = def;
   while ((h = h->u.alias) != def)
     h->is_weakalias = 0;
 }
      else
 {
   while (h->root.type == bfd_link_hash_indirect)
     h = (struct elf_link_hash_entry *) h->root.u.i.link;
   do { if (!(h->root.type == bfd_link_hash_defined || h->root.type == bfd_link_hash_defweak)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",3111); } while (0)
                                                 ;
   do { if (!(def->def_dynamic)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",3113); } while (0);
   (*bed->elf_backend_copy_indirect_symbol) (eif->info, def, h);
 }
    }

  return 
# 3118 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 3118 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





static 
# 3125 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 3126 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_adjust_dynamic_symbol (struct elf_link_hash_entry *h, void *data)
{
  struct elf_info_failed *eif = (struct elf_info_failed *) data;
  struct elf_link_hash_table *htab;
  const struct elf_backend_data *bed;

  if (! is_elf_hash_table (eif->info->hash))
    return 
# 3133 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3133 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  if (h->root.type == bfd_link_hash_indirect)
    return 
# 3137 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3137 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (! _bfd_elf_fix_symbol_flags (h, eif))
    return 
# 3141 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3141 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  htab = elf_hash_table (eif->info);
  bed = ((const struct elf_backend_data *) ((htab->dynobj)->xvec)->backend_data);

  if (h->root.type == bfd_link_hash_undefweak)
    {
      if (eif->info->dynamic_undefined_weak == 0)
 (*bed->elf_backend_hide_symbol) (eif->info, h, 
# 3149 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                               1
# 3149 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                   );
      else if (eif->info->dynamic_undefined_weak > 0
        && h->ref_regular
        && ((h->other) & 0x3) == 0
        && !bfd_hide_sym_by_version (eif->info->version_info,
         h->root.root.string))
 {
   if (!bfd_elf_link_record_dynamic_symbol (eif->info, h))
     {
       eif->failed = 
# 3158 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    1
# 3158 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
       return 
# 3159 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 3159 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
 }
    }
# 3171 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if (!h->needs_plt
      && h->type != 10
      && (h->def_regular
   || !h->def_dynamic
   || (!h->ref_regular
       && (!h->is_weakalias || weakdef (h)->dynindx == -1))))
    {
      h->plt = elf_hash_table (eif->info)->init_plt_offset;
      return 
# 3179 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 3179 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }



  if (h->dynamic_adjusted)
    return 
# 3185 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3185 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;





  h->dynamic_adjusted = 1;
# 3221 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if (h->is_weakalias)
    {
      struct elf_link_hash_entry *def = weakdef (h);



      def->ref_regular = 1;



      if (!_bfd_elf_adjust_dynamic_symbol (def, eif))
 return 
# 3232 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 3232 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }






  if (h->size == 0
      && h->type == 0
      && !h->needs_plt)
    _bfd_error_handler
      (dgettext ("bfd", "warning: type and size of dynamic symbol `%s' are not defined"),
       h->root.root.string);

  if (! (*bed->elf_backend_adjust_dynamic_symbol) (eif->info, h))
    {
      eif->failed = 
# 3249 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   1
# 3249 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
      return 
# 3250 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 3250 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }

  return 
# 3253 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 3253 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





# 3259 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 3260 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_adjust_dynamic_copy (struct bfd_link_info *info,
         struct elf_link_hash_entry *h,
         asection *dynbss)
{
  unsigned int power_of_two;
  bfd_vma mask;
  asection *sec = h->root.u.def.section;






  power_of_two = bfd_section_alignment (sec);
  mask = ((bfd_vma) 1 << power_of_two) - 1;
  while ((h->root.u.def.value & mask) != 0)
    {
       mask >>= 1;
       --power_of_two;
    }

  if (power_of_two > bfd_section_alignment (dynbss))
    {

      if (!bfd_set_section_alignment (dynbss, power_of_two))
 return 
# 3285 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 3285 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }


  dynbss->size = ((((bfd_vma) (dynbss->size) + (mask + 1) - 1) >= (bfd_vma) (dynbss->size)) ? (((bfd_vma) (dynbss->size) + ((mask + 1) - 1)) & ~ (bfd_vma) ((mask + 1)-1)) : ~ (bfd_vma) 0);


  h->root.u.def.section = dynbss;
  h->root.u.def.value = dynbss->size;


  dynbss->size += h->size;


  if (h->protected_def
      && (!info->extern_protected_data
   || (info->extern_protected_data < 0
       && !((const struct elf_backend_data *) ((dynbss->owner)->xvec)->backend_data)->extern_protected_data)))
    info->callbacks->einfo
      (dgettext ("bfd", "%P: copy reloc against protected `%pT' is dangerous\n"),
       h->root.root.string);

  return 
# 3307 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 3307 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




static 
# 3313 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 3314 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_sec_merge_syms (struct elf_link_hash_entry *h, void *data)
{
  asection *sec;

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && ((sec = h->root.u.def.section)->flags & 0x800000)
      && sec->sec_info_type == 2)
    {
      bfd *output_bfd = (bfd *) data;

      h->root.u.def.value =
 _bfd_merged_section_offset (output_bfd,
        &h->root.u.def.section,
        ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sec_info,
        h->root.u.def.value);
    }

  return 
# 3332 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 3332 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






# 3339 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 3340 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_dynamic_symbol_p (struct elf_link_hash_entry *h,
      struct bfd_link_info *info,
      
# 3342 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 3342 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          not_local_protected)
{
  
# 3344 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 3344 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      binding_stays_local_p;
  const struct elf_backend_data *bed;
  struct elf_link_hash_table *hash_table;

  if (h == 
# 3348 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 3348 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    return 
# 3349 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3349 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  while (h->root.type == bfd_link_hash_indirect
  || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;


  if (h->dynindx == -1)
    return 
# 3357 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3357 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  if (h->forced_local)
    return 
# 3359 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3359 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



  binding_stays_local_p = ((((info)->type == type_pde) || ((info)->type == type_pie))
      || (!(h)->unique_global && ((info)->symbolic || (h)->start_stop || ((info)->dynamic && !(h)->dynamic))));

  switch (((h->other) & 0x3))
    {
    case 1:
    case 2:
      return 
# 3370 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 3370 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;

    case 3:
      hash_table = elf_hash_table (info);
      if (!is_elf_hash_table (&hash_table->root))
 return 
# 3375 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 3375 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

      bed = ((const struct elf_backend_data *) ((hash_table->dynobj)->xvec)->backend_data);




      if (!not_local_protected || !bed->is_function_type (h->type))
 binding_stays_local_p = 
# 3383 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        1
# 3383 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                            ;
      break;

    default:
      break;
    }


  if (!h->def_regular && !(!(h)->def_regular && !(h)->def_dynamic && (h)->root.type == bfd_link_hash_defined))
    return 
# 3392 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3392 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;



  return !binding_stays_local_p;
}
# 3412 "/doner/binutils/binutils-515f23e/bfd/elflink.c"

# 3412 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 3413 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_symbol_refs_local_p (struct elf_link_hash_entry *h,
         struct bfd_link_info *info,
         
# 3415 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool 
# 3415 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             local_protected)
{
  const struct elf_backend_data *bed;
  struct elf_link_hash_table *hash_table;


  if (h == 
# 3421 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 3421 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    return 
# 3422 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3422 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (((h->other) & 0x3) == 2
      || ((h->other) & 0x3) == 1)
    return 
# 3427 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3427 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (h->forced_local)
    return 
# 3431 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3431 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;



  if ((!(h)->def_regular && !(h)->def_dynamic && (h)->root.type == bfd_link_hash_defined))
                      ;


  else if (!h->def_regular)
    return 
# 3440 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3440 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  if (h->dynindx == -1)
    return 
# 3444 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3444 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;




  if ((((info)->type == type_pde) || ((info)->type == type_pie)) || (!(h)->unique_global && ((info)->symbolic || (h)->start_stop || ((info)->dynamic && !(h)->dynamic))))
    return 
# 3450 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3450 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;



  if (((h->other) & 0x3) == 0)
    return 
# 3455 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3455 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  hash_table = elf_hash_table (info);
  if (!is_elf_hash_table (&hash_table->root))
    return 
# 3459 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3459 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (info->indirect_extern_access > 0)
    return 
# 3463 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3463 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  bed = ((const struct elf_backend_data *) ((hash_table->dynobj)->xvec)->backend_data);



  if ((!info->extern_protected_data
       || (info->extern_protected_data < 0
    && !bed->extern_protected_data))
      && !bed->is_function_type (h->type))
    return 
# 3473 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3473 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;






  return local_protected;
}




struct bfd_section *
_bfd_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
{
  struct bfd_section *sec, *tls;
  unsigned int align = 0;

  for (sec = obfd->sections; sec != 
# 3492 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 3492 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; sec = sec->next)
    if ((sec->flags & 0x400) != 0)
      break;
  tls = sec;

  for (; sec != 
# 3497 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0) 
# 3497 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    && (sec->flags & 0x400) != 0; sec = sec->next)
    if (sec->alignment_power > align)
      align = sec->alignment_power;

  elf_hash_table (info)->tls_sec = tls;



  if (tls != 
# 3505 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 3505 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                )
    tls->alignment_power = align;

  return tls;
}


static 
# 3512 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 3513 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
is_global_data_symbol_definition (bfd *abfd __attribute__ ((__unused__)),
      Elf_Internal_Sym *sym)
{
  const struct elf_backend_data *bed;


  if ((((unsigned int)(sym->st_info)) >> 4) != 1
      && (((unsigned int)(sym->st_info)) >> 4) < 10)
    return 
# 3521 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3521 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  if (bed->is_function_type (((sym->st_info) & 0xF)))
    return 
# 3526 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3526 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  if (sym->st_shndx == 0)
    return 
# 3530 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3530 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



  if (bed->common_definition (sym))
    return 
# 3535 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3535 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



  if (sym->st_shndx >= (-0x100u) && sym->st_shndx < (-0xFu))







    return 
# 3547 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3547 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  return 
# 3549 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 3549 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




static 
# 3555 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 3556 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_is_defined_archive_symbol (bfd * abfd, carsym * symdef)
{
  Elf_Internal_Shdr * hdr;
  size_t symcount;
  size_t extsymcount;
  size_t extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  
# 3565 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 3565 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      result;

  abfd = _bfd_get_elt_at_filepos (abfd, symdef->file_offset, 
# 3567 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                            ((void *)0)
# 3567 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                );
  if (abfd == 
# 3568 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 3568 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
    return 
# 3569 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3569 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (! bfd_check_format (abfd, bfd_object))
    return 
# 3572 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3572 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if ((((abfd) -> tdata.elf_obj_data) -> dt_symtab_count != 0))
    {
      bfd_set_error (bfd_error_wrong_format);
      return 
# 3577 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 3577 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }




  if (abfd->plugin_format == bfd_plugin_yes

      || (abfd->plugin_format == bfd_plugin_unknown
   && bfd_link_plugin_object_p (abfd))

      )
    {


      abfd = abfd->plugin_dummy_bfd;
      hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;
    }
  else if ((abfd->flags & 0x40) == 0 || (((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) == 0)
    hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;
  else
    hdr = &((abfd) -> tdata.elf_obj_data)->dynsymtab_hdr;

  symcount = hdr->sh_size / ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->s->sizeof_sym;



  if ((((abfd) -> tdata.elf_obj_data) -> bad_symtab))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  if (extsymcount == 0)
    return 
# 3616 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3616 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
      
# 3620 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 3620 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
         , 
# 3620 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 3620 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               , 
# 3620 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 3620 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     );
  if (isymbuf == 
# 3621 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 3621 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
    return 
# 3622 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3622 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  result = 
# 3625 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3625 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  for (isym = isymbuf, isymend = isymbuf + extsymcount; isym < isymend; isym++)
    {
      const char *name;

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
           isym->st_name);
      if (name == 
# 3632 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 3632 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
 break;

      if (strcmp (name, symdef->name) == 0)
 {
   result = is_global_data_symbol_definition (abfd, isym);
   break;
 }
    }

  free (isymbuf);

  return result;
}




# 3649 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 3650 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_add_dynamic_entry (struct bfd_link_info *info,
       bfd_vma tag,
       bfd_vma val)
{
  struct elf_link_hash_table *hash_table;
  const struct elf_backend_data *bed;
  asection *s;
  bfd_size_type newsize;
  bfd_byte *newcontents;
  Elf_Internal_Dyn dyn;

  hash_table = elf_hash_table (info);
  if (! is_elf_hash_table (&hash_table->root))
    return 
# 3663 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3663 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (tag == 7 || tag == 17)
    hash_table->dynamic_relocs = 
# 3666 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                1
# 3666 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    ;

  bed = ((const struct elf_backend_data *) ((hash_table->dynobj)->xvec)->backend_data);
  s = bfd_get_linker_section (hash_table->dynobj, ".dynamic");
  do { if (!(s != 
# 3670 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 ((void *)0)
# 3670 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
 )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",3670); } while (0);

  newsize = s->size + bed->s->sizeof_dyn;
  newcontents = (bfd_byte *) bfd_realloc (s->contents, newsize);
  if (newcontents == 
# 3674 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 3674 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        )
    return 
# 3675 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3675 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  dyn.d_tag = tag;
  dyn.d_un.d_val = val;
  bed->s->swap_dyn_out (hash_table->dynobj, &dyn, newcontents + s->size);

  s->size = newsize;
  s->contents = newcontents;

  return 
# 3684 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 3684 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




# 3689 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 3690 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_strip_zero_sized_dynamic_sections (struct bfd_link_info *info)
{
  struct elf_link_hash_table *hash_table;
  const struct elf_backend_data *bed;
  asection *s, *sdynamic, **pp;
  asection *rela_dyn, *rel_dyn;
  Elf_Internal_Dyn dyn;
  bfd_byte *extdyn, *next;
  void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);
  
# 3699 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 3699 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      strip_zero_sized;
  
# 3700 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 3700 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      strip_zero_sized_plt;

  if (((info)->type == type_relocatable))
    return 
# 3703 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3703 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  hash_table = elf_hash_table (info);
  if (!is_elf_hash_table (&hash_table->root))
    return 
# 3707 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 3707 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (!hash_table->dynobj)
    return 
# 3710 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3710 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  sdynamic= bfd_get_linker_section (hash_table->dynobj, ".dynamic");
  if (!sdynamic)
    return 
# 3714 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 3714 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  bed = ((const struct elf_backend_data *) ((hash_table->dynobj)->xvec)->backend_data);
  swap_dyn_in = bed->s->swap_dyn_in;

  strip_zero_sized = 
# 3719 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 3719 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
  strip_zero_sized_plt = 
# 3720 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        0
# 3720 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;


  rela_dyn = bfd_get_section_by_name (info->output_bfd, ".rela.dyn");
  rel_dyn = bfd_get_section_by_name (info->output_bfd, ".rel.dyn");
  for (pp = &info->output_bfd->sections; (s = *pp) != 
# 3725 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                     ((void *)0)
# 3725 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                         ;)
    if (s->size == 0
 && (s == rela_dyn
     || s == rel_dyn
     || s == hash_table->srelplt->output_section
     || s == hash_table->splt->output_section))
      {
 *pp = s->next;
 info->output_bfd->section_count--;
 strip_zero_sized = 
# 3734 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   1
# 3734 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
 if (s == rela_dyn)
   s = rela_dyn;
 if (s == rel_dyn)
   s = rel_dyn;
 else if (s == hash_table->splt->output_section)
   {
     s = hash_table->splt;
     strip_zero_sized_plt = 
# 3742 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           1
# 3742 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               ;
   }
 else
   s = hash_table->srelplt;
 s->flags |= 0x8000;
 s->output_section = (&_bfd_std_section[2]);
      }
    else
      pp = &s->next;

  if (strip_zero_sized_plt && sdynamic->size != 0)
    for (extdyn = sdynamic->contents;
  extdyn < sdynamic->contents + sdynamic->size;
  extdyn = next)
      {
 next = extdyn + bed->s->sizeof_dyn;
 swap_dyn_in (hash_table->dynobj, extdyn, &dyn);
 switch (dyn.d_tag)
   {
   default:
     break;
   case 23:
   case 2:
   case 20:



     memmove (extdyn, next,
       sdynamic->size - (next - sdynamic->contents));
     next = extdyn;
   }
      }

  if (strip_zero_sized)
    {

      (((info->output_bfd) -> tdata.elf_obj_data) -> o->seg_map) = 
# 3778 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
# 3778 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          ;
      return _bfd_elf_map_sections_to_segments (info->output_bfd, info,
      
# 3780 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 3780 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
         );
    }

  return 
# 3783 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 3783 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




int
bfd_elf_add_dt_needed_tag (bfd *abfd, struct bfd_link_info *info)
{
  struct elf_link_hash_table *hash_table;
  size_t strindex;
  const char *soname;

  if (!_bfd_elf_link_create_dynstrtab (abfd, info))
    return -1;

  hash_table = elf_hash_table (info);
  soname = (((abfd) -> tdata.elf_obj_data) -> dt_name);
  strindex = _bfd_elf_strtab_add (hash_table->dynstr, soname, 
# 3801 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                             0
# 3801 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                  );
  if (strindex == (size_t) -1)
    return -1;

  if (_bfd_elf_strtab_refcount (hash_table->dynstr, strindex) != 1)
    {
      asection *sdyn;
      const struct elf_backend_data *bed;
      bfd_byte *extdyn;

      bed = ((const struct elf_backend_data *) ((hash_table->dynobj)->xvec)->backend_data);
      sdyn = bfd_get_linker_section (hash_table->dynobj, ".dynamic");
      if (sdyn != 
# 3813 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0) 
# 3813 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      && sdyn->size != 0)
 for (extdyn = sdyn->contents;
      extdyn < sdyn->contents + sdyn->size;
      extdyn += bed->s->sizeof_dyn)
   {
     Elf_Internal_Dyn dyn;

     bed->s->swap_dyn_in (hash_table->dynobj, extdyn, &dyn);
     if (dyn.d_tag == 1
  && dyn.d_un.d_val == strindex)
       {
  _bfd_elf_strtab_delref (hash_table->dynstr, strindex);
  return 1;
       }
   }
    }

  if (!_bfd_elf_link_create_dynamic_sections (hash_table->dynobj, info))
    return -1;

  if (!_bfd_elf_add_dynamic_entry (info, 1, strindex))
    return -1;

  return 0;
}





static 
# 3843 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 3844 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
on_needed_list (const char *soname,
  struct bfd_link_needed_list *needed,
  struct bfd_link_needed_list *stop)
{
  struct bfd_link_needed_list *look;
  for (look = needed; look != stop; look = look->next)
    if (strcmp (soname, look->name) == 0
 && (((((look->by) -> tdata.elf_obj_data) -> dyn_lib_class) & DYN_AS_NEEDED) == 0






     || on_needed_list ((((look->by) -> tdata.elf_obj_data) -> dt_name), needed, look)))
      return 
# 3859 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 3859 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

  return 
# 3861 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 3861 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}


static int
elf_sort_symbol (const void *arg1, const void *arg2)
{
  const struct elf_link_hash_entry *h1;
  const struct elf_link_hash_entry *h2;
  bfd_signed_vma vdiff;
  int sdiff;
  const char *n1;
  const char *n2;

  h1 = *(const struct elf_link_hash_entry **) arg1;
  h2 = *(const struct elf_link_hash_entry **) arg2;
  vdiff = h1->root.u.def.value - h2->root.u.def.value;
  if (vdiff != 0)
    return vdiff > 0 ? 1 : -1;

  sdiff = h1->root.u.def.section->id - h2->root.u.def.section->id;
  if (sdiff != 0)
    return sdiff;


  vdiff = h1->size - h2->size;
  if (vdiff != 0)
    return vdiff > 0 ? 1 : -1;


  if (h1->type != h2->type)
    return h1->type - h2->type;
# 3901 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  n1 = h1->root.root.string;
  n2 = h2->root.root.string;
  while (*n1 == *n2)
    {
      if (*n1 == 0)
 break;
      ++n1;
      ++n2;
    }
  if (*n1 == '_')
    return -1;
  if (*n2 == '_')
    return 1;



  return *n1 - *n2;
}




static 
# 3923 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 3924 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_adjust_dynstr_offsets (struct elf_link_hash_entry *h, void *data)
{
  struct elf_strtab_hash *dynstr = (struct elf_strtab_hash *) data;

  if (h->dynindx != -1)
    h->dynstr_index = _bfd_elf_strtab_offset (dynstr, h->dynstr_index);
  return 
# 3930 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 3930 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




static 
# 3936 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 3937 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_finalize_dynstr (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_link_hash_table *hash_table = elf_hash_table (info);
  struct elf_link_local_dynamic_entry *entry;
  struct elf_strtab_hash *dynstr = hash_table->dynstr;
  bfd *dynobj = hash_table->dynobj;
  asection *sdyn;
  bfd_size_type size;
  const struct elf_backend_data *bed;
  bfd_byte *extdyn;

  _bfd_elf_strtab_finalize (dynstr);
  size = _bfd_elf_strtab_size (dynstr);



  if (info->callbacks->examine_strtab)
    info->callbacks->examine_strtab (dynstr);

  bed = ((const struct elf_backend_data *) ((dynobj)->xvec)->backend_data);
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");
  do { if (!(sdyn != 
# 3958 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 ((void *)0)
# 3958 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
 )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",3958); } while (0);


  for (extdyn = sdyn->contents;
       extdyn < ((sdyn->size) != 0 ? (sdyn->contents) + (sdyn->size) : (sdyn->contents));
       extdyn += bed->s->sizeof_dyn)
    {
      Elf_Internal_Dyn dyn;

      bed->s->swap_dyn_in (dynobj, extdyn, &dyn);
      switch (dyn.d_tag)
 {
 case 10:
   dyn.d_un.d_val = size;
   break;
 case 1:
 case 14:
 case 15:
 case 29:
 case 0x7fffffff:
 case 0x7ffffffd:
 case 0x6ffffefc:
 case 0x6ffffefb:
   dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);
   break;
 default:
   continue;
 }
      bed->s->swap_dyn_out (dynobj, &dyn, extdyn);
    }


  for (entry = hash_table->dynlocal; entry ; entry = entry->next)
    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,
        entry->isym.st_name);


  elf_link_hash_traverse (hash_table, elf_adjust_dynstr_offsets, dynstr);


  if (((output_bfd) -> tdata.elf_obj_data)->cverdefs)
    {
      asection *s;
      bfd_byte *p;
      size_t i;
      Elf_Internal_Verdef def;
      Elf_Internal_Verdaux defaux;

      s = bfd_get_linker_section (dynobj, ".gnu.version_d");
      p = s->contents;
      do
 {
   _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,
       &def);
   p += sizeof (Elf_External_Verdef);
   if (def.vd_aux != sizeof (Elf_External_Verdef))
     continue;
   for (i = 0; i < def.vd_cnt; ++i)
     {
       _bfd_elf_swap_verdaux_in (output_bfd,
     (Elf_External_Verdaux *) p, &defaux);
       defaux.vda_name = _bfd_elf_strtab_offset (dynstr,
       defaux.vda_name);
       _bfd_elf_swap_verdaux_out (output_bfd,
      &defaux, (Elf_External_Verdaux *) p);
       p += sizeof (Elf_External_Verdaux);
     }
 }
      while (def.vd_next);
    }


  if (((output_bfd) -> tdata.elf_obj_data)->verref)
    {
      asection *s;
      bfd_byte *p;
      size_t i;
      Elf_Internal_Verneed need;
      Elf_Internal_Vernaux needaux;

      s = bfd_get_linker_section (dynobj, ".gnu.version_r");
      p = s->contents;
      do
 {
   _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,
        &need);
   need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);
   _bfd_elf_swap_verneed_out (output_bfd, &need,
         (Elf_External_Verneed *) p);
   p += sizeof (Elf_External_Verneed);
   for (i = 0; i < need.vn_cnt; ++i)
     {
       _bfd_elf_swap_vernaux_in (output_bfd,
     (Elf_External_Vernaux *) p, &needaux);
       needaux.vna_name = _bfd_elf_strtab_offset (dynstr,
        needaux.vna_name);
       _bfd_elf_swap_vernaux_out (output_bfd,
      &needaux,
      (Elf_External_Vernaux *) p);
       p += sizeof (Elf_External_Vernaux);
     }
 }
      while (need.vn_next);
    }

  return 
# 4063 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 4063 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






# 4070 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 4071 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_default_relocs_compatible (const bfd_target *input,
        const bfd_target *output)
{
  return input == output;
}






# 4081 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 4082 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_relocs_compatible (const bfd_target *input,
       const bfd_target *output)
{
  const struct elf_backend_data *obed, *ibed;

  if (input == output)
    return 
# 4088 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 4088 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  ibed = ((const struct elf_backend_data *) (input)->backend_data);
  obed = ((const struct elf_backend_data *) (output)->backend_data);

  if (ibed->arch != obed->arch)
    return 
# 4094 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 4094 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  return ibed->relocs_compatible == obed->relocs_compatible;
}






# 4104 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 4105 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_notice_as_needed (bfd *ibfd,
      struct bfd_link_info *info,
      enum notice_asneeded_action act)
{
  return (*info->callbacks->notice) (info, 
# 4109 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 4109 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              , 
# 4109 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                ((void *)0)
# 4109 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                    , ibfd, 
# 4109 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                            ((void *)0)
# 4109 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                , act, 0);
}




# 4114 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 4115 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_iterate_on_relocs
  (bfd *abfd, struct bfd_link_info *info,
   
# 4117 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 4117 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       (*action) (bfd *, struct bfd_link_info *, asection *,
     const Elf_Internal_Rela *))
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  struct elf_link_hash_table *htab = elf_hash_table (info);
# 4140 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if ((abfd->flags & 0x40) == 0
      && is_elf_hash_table (&htab->root)
      && (((abfd) -> tdata.elf_obj_data) -> object_id) == elf_hash_table_id (htab)
      && (*bed->relocs_compatible) (abfd->xvec, info->output_bfd->xvec))
    {
      asection *o;

      for (o = abfd->sections; o != 
# 4147 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 4147 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; o = o->next)
 {
   Elf_Internal_Rela *internal_relocs;
   
# 4150 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 4150 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       ok;
# 4160 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   if ((o->flags & 0x1) == 0
       || (o->flags & 0x4) == 0
       || (o->flags & 0x8000) != 0
       || o->reloc_count == 0
       || ((info->strip == strip_all || info->strip == strip_debugger)
    && (o->flags & 0x2000) != 0)
       || bfd_is_abs_section (o->output_section))
     continue;

   internal_relocs = _bfd_elf_link_info_read_relocs (abfd, info,
           o, 
# 4170 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 4170 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ,
           
# 4171 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 4171 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ,
           _bfd_link_keep_memory (info));
   if (internal_relocs == 
# 4173 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 4173 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
     return 
# 4174 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 4174 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   ok = action (abfd, info, o, internal_relocs);

   if (((struct bfd_elf_section_data*)(o)->used_by_bfd)->relocs != internal_relocs)
     free (internal_relocs);

   if (! ok)
     return 
# 4182 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 4182 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
    }

  return 
# 4186 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 4186 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





# 4192 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 4193 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_check_relocs (bfd *abfd, struct bfd_link_info *info)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  if (bed->check_relocs != 
# 4196 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0)
# 4196 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                              )
    return _bfd_elf_link_iterate_on_relocs (abfd, info,
         bed->check_relocs);
  return 
# 4199 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 4199 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



static 
# 4204 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 4205 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
{
  Elf_Internal_Ehdr *ehdr;
  Elf_Internal_Shdr *hdr;
  size_t symcount;
  size_t extsymcount;
  size_t extsymoff;
  struct elf_link_hash_entry **sym_hash;
  
# 4213 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 4213 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      dynamic;
  Elf_External_Versym *extversym = 
# 4214 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 4214 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ;
  Elf_External_Versym *extversym_end = 
# 4215 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
# 4215 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          ;
  Elf_External_Versym *ever;
  struct elf_link_hash_entry *weaks;
  struct elf_link_hash_entry **nondeflt_vers = 
# 4218 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                              ((void *)0)
# 4218 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                  ;
  size_t nondeflt_vers_cnt = 0;
  Elf_Internal_Sym *isymbuf = 
# 4220 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
# 4220 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 ;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  const struct elf_backend_data *bed;
  
# 4224 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 4224 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      add_needed;
  struct elf_link_hash_table *htab;
  void *alloc_mark = 
# 4226 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 4226 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
  struct bfd_hash_entry **old_table = 
# 4227 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 4227 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ;
  unsigned int old_size = 0;
  unsigned int old_count = 0;
  void *old_tab = 
# 4230 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 4230 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ;
  void *old_ent;
  struct bfd_link_hash_entry *old_undefs = 
# 4232 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 4232 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              ;
  struct bfd_link_hash_entry *old_undefs_tail = 
# 4233 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                               ((void *)0)
# 4233 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                   ;
  void *old_strtab = 
# 4234 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 4234 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
  size_t tabsize = 0;
  asection *s;
  
# 4237 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 4237 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      just_syms;

  htab = elf_hash_table (info);
  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  if ((((abfd) -> tdata.elf_obj_data) -> dt_symtab_count != 0))
    {
      bfd_set_error (bfd_error_wrong_format);
      return 
# 4245 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 4245 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }

  if ((abfd->flags & 0x40) == 0)
    dynamic = 
# 4249 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 4249 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
  else
    {
      dynamic = 
# 4252 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               1
# 4252 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;




      if (((info)->type == type_relocatable)
   || !is_elf_hash_table (&htab->root)
   || info->output_bfd->xvec != abfd->xvec)
 {
   if (((info)->type == type_relocatable))
     bfd_set_error (bfd_error_invalid_operation);
   else
     bfd_set_error (bfd_error_wrong_format);
   goto error_return;
 }
    }

  ehdr = (((abfd) -> tdata.elf_obj_data) -> elf_header);
  if (info->warn_alternate_em
      && bed->elf_machine_code != ehdr->e_machine
      && ((bed->elf_machine_alt1 != 0
    && ehdr->e_machine == bed->elf_machine_alt1)
   || (bed->elf_machine_alt2 != 0
       && ehdr->e_machine == bed->elf_machine_alt2)))
    _bfd_error_handler

      (dgettext ("bfd", "alternate ELF machine code found (%d) in %pB, expecting %d"),
       ehdr->e_machine, abfd, bed->elf_machine_code);






  for (s = abfd->sections; s != 
# 4286 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 4286 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   ; s = s->next)
    {
      const char *name;

      name = bfd_section_name (s);
      if (startswith (name, ".gnu.warning."))
 {
   char *msg;
   bfd_size_type sz;

   name += sizeof ".gnu.warning." - 1;
# 4307 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   if (dynamic)
     {
       struct elf_link_hash_entry *h;

       h = elf_link_hash_lookup (htab, name, 
# 4311 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                            0
# 4311 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                 , 
# 4311 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                   0
# 4311 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                        , 
# 4311 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                          1
# 4311 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                              );


       if (h != 
# 4314 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
    
# 4315 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && (h->root.type == bfd_link_hash_defined
        || h->root.type == bfd_link_hash_defweak))
  continue;
     }

   sz = s->size;
   msg = (char *) bfd_alloc (abfd, sz + 1);
   if (msg == 
# 4322 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 4322 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
     goto error_return;

   if (! bfd_get_section_contents (abfd, s, msg, 0, sz))
     goto error_return;

   msg[sz] = '\0';

   if (! (_bfd_generic_link_add_one_symbol
   (info, abfd, name, (1 << 12), s, 0, msg,
    
# 4332 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
   0
# 4332 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        , bed->collect, 
# 4332 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0)
# 4332 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                            )))
     goto error_return;

   if ((((info)->type == type_pde) || ((info)->type == type_pie)))
     {


       s->size = 0;



       s->flags |= 0x8000;
     }
 }
    }

  just_syms = ((s = abfd->sections) != 
# 4348 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
        
# 4349 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       && s->sec_info_type == 4);

  add_needed = 
# 4351 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              1
# 4351 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
  if (! dynamic)
    {







      if (!just_syms
   && ((((info)->type == type_dll) || ((info)->type == type_pie))
       || (!((info)->type == type_relocatable)
    && info->nointerp
    && (info->export_dynamic || info->dynamic)))
   && is_elf_hash_table (&htab->root)
   && info->output_bfd->xvec == abfd->xvec
   && !htab->dynamic_sections_created)
 {
   if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
     goto error_return;
 }
    }
  else if (!is_elf_hash_table (&htab->root))
    goto error_return;
  else
    {
      const char *soname = 
# 4378 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0)
# 4378 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                              ;
      char *audit = 
# 4379 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 4379 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
      struct bfd_link_needed_list *rpath = 
# 4380 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 4380 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              , *runpath = 
# 4380 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                           ((void *)0)
# 4380 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                               ;
      const Elf_Internal_Phdr *phdr;
      struct elf_link_loaded_list *loaded_lib;



      if (just_syms)
 _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 4387, __PRETTY_FUNCTION__);
# 4396 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      add_needed = ((((abfd) -> tdata.elf_obj_data) -> dyn_lib_class)
      & (DYN_AS_NEEDED | DYN_DT_NEEDED
         | DYN_NO_NEEDED)) == 0;

      s = bfd_get_section_by_name (abfd, ".dynamic");
      if (s != 
# 4401 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 4401 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   && s->size != 0 && (s->flags & 0x100) != 0)
 {
   bfd_byte *dynbuf;
   bfd_byte *extdyn;
   unsigned int elfsec;
   unsigned long shlink;

   if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
     {
     error_free_dyn:
       free (dynbuf);
       goto error_return;
     }

   elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
   if (elfsec == (-0x101u))
     goto error_free_dyn;
   shlink = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[elfsec]->sh_link;

   for (extdyn = dynbuf;
        (size_t) (dynbuf + s->size - extdyn) >= bed->s->sizeof_dyn;
        extdyn += bed->s->sizeof_dyn)
     {
       Elf_Internal_Dyn dyn;

       bed->s->swap_dyn_in (abfd, extdyn, &dyn);
       if (dyn.d_tag == 14)
  {
    unsigned int tagv = dyn.d_un.d_val;
    soname = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
    if (soname == 
# 4431 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 4431 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
      goto error_free_dyn;
  }
       if (dyn.d_tag == 1)
  {
    struct bfd_link_needed_list *n, **pn;
    char *fnm, *anm;
    unsigned int tagv = dyn.d_un.d_val;
    size_t amt = sizeof (struct bfd_link_needed_list);

    n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
    fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
    if (n == 
# 4443 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0) 
# 4443 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 || fnm == 
# 4443 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 4443 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
      goto error_free_dyn;
    amt = strlen (fnm) + 1;
    anm = (char *) bfd_alloc (abfd, amt);
    if (anm == 
# 4447 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 4447 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
      goto error_free_dyn;
    memcpy (anm, fnm, amt);
    n->name = anm;
    n->by = abfd;
    n->next = 
# 4452 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 4452 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    for (pn = &htab->needed; *pn != 
# 4453 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 4453 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; pn = &(*pn)->next)
      ;
    *pn = n;
  }
       if (dyn.d_tag == 29)
  {
    struct bfd_link_needed_list *n, **pn;
    char *fnm, *anm;
    unsigned int tagv = dyn.d_un.d_val;
    size_t amt = sizeof (struct bfd_link_needed_list);

    n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
    fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
    if (n == 
# 4466 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0) 
# 4466 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 || fnm == 
# 4466 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 4466 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
      goto error_free_dyn;
    amt = strlen (fnm) + 1;
    anm = (char *) bfd_alloc (abfd, amt);
    if (anm == 
# 4470 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 4470 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
      goto error_free_dyn;
    memcpy (anm, fnm, amt);
    n->name = anm;
    n->by = abfd;
    n->next = 
# 4475 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 4475 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    for (pn = & runpath;
         *pn != 
# 4477 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 4477 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
         pn = &(*pn)->next)
      ;
    *pn = n;
  }

       if (!runpath && dyn.d_tag == 15)
  {
    struct bfd_link_needed_list *n, **pn;
    char *fnm, *anm;
    unsigned int tagv = dyn.d_un.d_val;
    size_t amt = sizeof (struct bfd_link_needed_list);

    n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
    fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
    if (n == 
# 4492 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0) 
# 4492 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 || fnm == 
# 4492 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 4492 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
      goto error_free_dyn;
    amt = strlen (fnm) + 1;
    anm = (char *) bfd_alloc (abfd, amt);
    if (anm == 
# 4496 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 4496 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
      goto error_free_dyn;
    memcpy (anm, fnm, amt);
    n->name = anm;
    n->by = abfd;
    n->next = 
# 4501 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 4501 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    for (pn = & rpath;
         *pn != 
# 4503 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 4503 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
         pn = &(*pn)->next)
      ;
    *pn = n;
  }
       if (dyn.d_tag == 0x6ffffefc)
  {
    unsigned int tagv = dyn.d_un.d_val;
    audit = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
  }
       if (dyn.d_tag == 0x6ffffffb)
  ((abfd) -> tdata.elf_obj_data)->is_pie = (dyn.d_un.d_val & 0x08000000) != 0;
     }

   free (dynbuf);
 }



      if (runpath)
 rpath = runpath;

      if (rpath)
 {
   struct bfd_link_needed_list **pn;
   for (pn = &htab->runpath; *pn != 
# 4528 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 4528 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; pn = &(*pn)->next)
     ;
   *pn = rpath;
 }




      phdr = ((abfd) -> tdata.elf_obj_data)->phdr + (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum;
      while (phdr-- > ((abfd) -> tdata.elf_obj_data)->phdr)
 if (phdr->p_type == (0x60000000 + 0x474e552))
   {
     for (s = abfd->sections; s != 
# 4540 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 4540 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ; s = s->next)
       {
  unsigned int opb = bfd_octets_per_byte (abfd, s);

  if ((s->flags & 0x1) != 0
      && s->vma * opb >= phdr->p_vaddr
      && s->vma * opb + s->size <= phdr->p_vaddr + phdr->p_memsz)
    s->flags |= 0x8;
       }
     break;
   }
# 4559 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      bfd_section_list_clear (abfd);






      if (soname == 
# 4566 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0) 
# 4566 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        || *soname == '\0')
 {
   soname = (((abfd) -> tdata.elf_obj_data) -> dt_name);
   if (soname == 
# 4569 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0) 
# 4569 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     || *soname == '\0')
     soname = bfd_get_filename (abfd);
 }



      (((abfd) -> tdata.elf_obj_data) -> dt_name) = soname;




      for (loaded_lib = htab->dyn_loaded;
    loaded_lib != 
# 4581 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 4581 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ;
    loaded_lib = loaded_lib->next)
 {
   if (strcmp ((((loaded_lib->abfd) -> tdata.elf_obj_data) -> dt_name), soname) == 0)
     return 
# 4585 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 4585 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
 }



      if (add_needed
   && !_bfd_elf_link_create_dynamic_sections (abfd, info))
 return 
# 4592 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 4592 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;


      (((abfd) -> tdata.elf_obj_data) -> dt_audit) = audit;
    }






  if (! dynamic || (((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) == 0)
    hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;
  else
    hdr = &((abfd) -> tdata.elf_obj_data)->dynsymtab_hdr;

  symcount = hdr->sh_size / bed->s->sizeof_sym;




  if ((((abfd) -> tdata.elf_obj_data) -> bad_symtab))
    {
      extsymcount = symcount;
      extsymoff = 0;
    }
  else
    {
      extsymcount = symcount - hdr->sh_info;
      extsymoff = hdr->sh_info;
    }

  sym_hash = (((abfd) -> tdata.elf_obj_data) -> sym_hashes);
  if (extsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,
          
# 4628 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         ((void *)0)
# 4628 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             , 
# 4628 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 4628 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   , 
# 4628 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 4628 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         );
      if (isymbuf == 
# 4629 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 4629 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        )
 goto error_return;

      if (sym_hash == 
# 4632 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 4632 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
 {


   size_t amt = extsymcount * sizeof (struct elf_link_hash_entry *);
   sym_hash = (struct elf_link_hash_entry **) bfd_zalloc (abfd, amt);
   if (sym_hash == 
# 4638 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 4638 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
     goto error_free_sym;
   (((abfd) -> tdata.elf_obj_data) -> sym_hashes) = sym_hash;
 }
    }

  if (dynamic)
    {

      if (!_bfd_elf_slurp_version_tables (abfd,
       info->default_imported_symver))
 goto error_free_sym;



      if ((((abfd) -> tdata.elf_obj_data) -> dynversym_section) != 0)
 {
   Elf_Internal_Shdr *versymhdr = &((abfd) -> tdata.elf_obj_data)->dynversym_hdr;
   bfd_size_type amt = versymhdr->sh_size;

   if (bfd_seek (abfd, versymhdr->sh_offset, 
# 4658 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                            0
# 4658 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                    ) != 0)
     goto error_free_sym;
   extversym = (Elf_External_Versym *)
     _bfd_malloc_and_read (abfd, amt, amt);
   if (extversym == 
# 4662 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 4662 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
     goto error_free_sym;
   extversym_end = extversym + amt / sizeof (*extversym);
 }
    }




  if (((((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) & DYN_AS_NEEDED) != 0)
    {
      unsigned int i;
      size_t entsize;

      for (entsize = 0, i = 0; i < htab->root.table.size; i++)
 {
   struct bfd_hash_entry *p;
   struct elf_link_hash_entry *h;

   for (p = htab->root.table.table[i]; p != 
# 4681 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 4681 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               ; p = p->next)
     {
       h = (struct elf_link_hash_entry *) p;
       entsize += htab->root.table.entsize;
       if (h->root.type == bfd_link_hash_warning)
  {
    entsize += htab->root.table.entsize;
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
  }
       if (h->root.type == bfd_link_hash_common)
  entsize += sizeof (*h->root.u.c.p);
     }
 }

      tabsize = htab->root.table.size * sizeof (struct bfd_hash_entry *);
      old_tab = bfd_malloc (tabsize + entsize);
      if (old_tab == 
# 4697 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 4697 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        )
 goto error_free_vers;



      alloc_mark = bfd_hash_allocate (&htab->root.table, 1);
      if (alloc_mark == 
# 4703 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       ((void *)0)
# 4703 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           )
 goto error_free_vers;



      if (!(*bed->notice_as_needed) (abfd, info, notice_as_needed))
 goto error_free_vers;



      old_ent = (char *) old_tab + tabsize;
      memcpy (old_tab, htab->root.table.table, tabsize);
      old_undefs = htab->root.undefs;
      old_undefs_tail = htab->root.undefs_tail;
      old_table = htab->root.table.table;
      old_size = htab->root.table.size;
      old_count = htab->root.table.count;
      old_strtab = 
# 4720 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 4720 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
      if (htab->dynstr != 
# 4721 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 4721 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
 {
   old_strtab = _bfd_elf_strtab_save (htab->dynstr);
   if (old_strtab == 
# 4724 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 4724 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        )
     goto error_free_vers;
 }

      for (i = 0; i < htab->root.table.size; i++)
 {
   struct bfd_hash_entry *p;
   struct elf_link_hash_entry *h;

   for (p = htab->root.table.table[i]; p != 
# 4733 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 4733 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               ; p = p->next)
     {
       h = (struct elf_link_hash_entry *) p;
       memcpy (old_ent, h, htab->root.table.entsize);
       old_ent = (char *) old_ent + htab->root.table.entsize;
       if (h->root.type == bfd_link_hash_warning)
  {
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
    memcpy (old_ent, h, htab->root.table.entsize);
    old_ent = (char *) old_ent + htab->root.table.entsize;
  }
       if (h->root.type == bfd_link_hash_common)
  {
    memcpy (old_ent, h->root.u.c.p, sizeof (*h->root.u.c.p));
    old_ent = (char *) old_ent + sizeof (*h->root.u.c.p);
  }
     }
 }
    }

  weaks = 
# 4753 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         ((void *)0)
# 4753 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
  if (extversym == 
# 4754 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 4754 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
    ever = 
# 4755 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 4755 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  else if (extversym + extsymoff < extversym_end)
    ever = extversym + extsymoff;
  else
    {

      _bfd_error_handler (dgettext ("bfd", "%pB: invalid version offset %lx (max %lx)"),
     abfd, (long) extsymoff,
     (long) (extversym_end - extversym) / sizeof (* extversym));
      bfd_set_error (bfd_error_bad_value);
      goto error_free_vers;
    }

  if (!((info)->type == type_relocatable)
      && abfd->lto_slim_object)
    {
      _bfd_error_handler
 (dgettext ("bfd", "%pB: plugin needed to handle lto object"), abfd);
    }

  for (isym = isymbuf, isymend = ((extsymcount) != 0 ? (isymbuf) + (extsymcount) : (isymbuf));
       isym < isymend;
       isym++, sym_hash++, ever = (ever != 
# 4777 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0) 
# 4777 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               ? ever + 1 : 
# 4777 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                            ((void *)0)
# 4777 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                ))
    {
      int bind;
      bfd_vma value;
      asection *sec, *new_sec;
      flagword flags;
      const char *name;
      struct elf_link_hash_entry *h;
      struct elf_link_hash_entry *hi;
      
# 4786 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 4786 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          definition;
      
# 4787 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 4787 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          size_change_ok;
      
# 4788 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 4788 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          type_change_ok;
      
# 4789 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 4789 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          new_weak;
      
# 4790 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 4790 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          old_weak;
      bfd *override;
      
# 4792 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 4792 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          common;
      
# 4793 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 4793 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          discarded;
      unsigned int old_alignment;
      unsigned int shindex;
      bfd *old_bfd;
      
# 4797 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 4797 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          matched;

      override = 
# 4799 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 4799 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;

      flags = 0;
      sec = 
# 4802 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 4802 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
      value = isym->st_value;
      common = bed->common_definition (isym);
      if (common && info->inhibit_common_definition)
 {

   isym->st_shndx = 0;
   common = 
# 4809 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 4809 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
      discarded = 
# 4811 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 0
# 4811 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;

      bind = (((unsigned int)(isym->st_info)) >> 4);
      switch (bind)
 {
 case 0:




   if ((((abfd) -> tdata.elf_obj_data) -> bad_symtab))
     continue;




   shindex = (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_shstrndx;
   name = bfd_elf_string_from_elf_section (abfd, shindex, hdr->sh_name);
   _bfd_error_handler (dgettext ("bfd", "%pB: %s local symbol at index %lu" " (>= sh_info of %lu)")
                           ,
         abfd, name, (long) (isym - isymbuf + extsymoff),
         (long) extsymoff);



   if (dynamic)
     continue;
   bfd_set_error (bfd_error_bad_value);
   goto error_free_vers;

 case 1:
   if (isym->st_shndx != 0 && !common)
     flags = (1 << 1);
   break;

 case 2:
   flags = (1 << 7);
   break;

 case 10:
   flags = (1 << 23);
   break;

 default:

   break;
 }

      if (isym->st_shndx == 0)
 sec = (&_bfd_std_section[1]);
      else if (isym->st_shndx == (-0xFu))
 sec = (&_bfd_std_section[2]);
      else if (isym->st_shndx == (-0xEu))
 {
   sec = (&_bfd_std_section[0]);


   value = isym->st_size;
 }
      else
 {
   sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
   if (sec == 
# 4873 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 4873 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
     sec = (&_bfd_std_section[2]);
   else if (discarded_section (sec))
     {


       sec = (&_bfd_std_section[1]);
       discarded = 
# 4880 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 4880 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
       isym->st_shndx = 0;
     }
   else if ((abfd->flags & (0x2 | 0x40)) != 0)
     value -= sec->vma;
 }

      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
           isym->st_name);
      if (name == 
# 4889 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 4889 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
 goto error_free_vers;

      if (isym->st_shndx == (-0xEu)
   && (abfd->flags & 0x10000) != 0)
 {
   asection *xc = bfd_get_section_by_name (abfd, "COMMON");

   if (xc == 
# 4897 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 4897 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                )
     {
       flagword sflags = (0x1 | 0x1000 | 0x200000
     | 0x8000);
       xc = bfd_make_section_with_flags (abfd, "COMMON", sflags);
       if (xc == 
# 4902 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 4902 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
  goto error_free_vers;
     }
   sec = xc;
 }
      else if (isym->st_shndx == (-0xEu)
        && ((isym->st_info) & 0xF) == 6
        && !((info)->type == type_relocatable))
 {
   asection *tcomm = bfd_get_section_by_name (abfd, ".tcommon");

   if (tcomm == 
# 4913 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 4913 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
     {
       flagword sflags = (0x1 | 0x400 | 0x1000
     | 0x100000);
       tcomm = bfd_make_section_with_flags (abfd, ".tcommon", sflags);
       if (tcomm == 
# 4918 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 4918 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
  goto error_free_vers;
     }
   sec = tcomm;
 }
      else if (bed->elf_add_symbol_hook)
 {
   if (! (*bed->elf_add_symbol_hook) (abfd, info, isym, &name, &flags,
          &sec, &value))
     goto error_free_vers;



   if (name == 
# 4931 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 4931 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
     continue;
 }


      if (sec == 
# 4936 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 4936 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
 _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 4937, __PRETTY_FUNCTION__);




      if (((isym->st_info) & 0xF) == 6
   && sec->sec_info_type == 4)
 continue;

      if (bfd_is_und_section (sec)
   || bfd_is_com_section (sec))
 definition = 
# 4948 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 4948 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
      else
 definition = 
# 4950 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             1
# 4950 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;

      size_change_ok = 
# 4952 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      0
# 4952 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
      type_change_ok = bed->type_change_ok;
      old_weak = 
# 4954 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                0
# 4954 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ;
      matched = 
# 4955 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               0
# 4955 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;
      old_alignment = 0;
      old_bfd = 
# 4957 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 4957 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
      new_sec = sec;

      if (is_elf_hash_table (&htab->root))
 {
   Elf_Internal_Versym iver;
   unsigned int vernum = 0;
   
# 4964 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 4964 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       skip;

   if (ever == 
# 4966 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 4966 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
     {
       if (info->default_imported_symver)

  iver.vs_vers = ((abfd) -> tdata.elf_obj_data)->cverdefs;
       else
  iver.vs_vers = 0;
     }
   else if (ever >= extversym_end)
     {

       _bfd_error_handler (dgettext ("bfd", "%pB: not enough version information"),
      abfd);
       bfd_set_error (bfd_error_bad_value);
       goto error_free_vers;
     }
   else
     _bfd_elf_swap_versym_in (abfd, ever, &iver);

   vernum = iver.vs_vers & 0x7fff;






   if ((iver.vs_vers & 0x8000) != 0
       || (vernum > 1
    && (!bfd_is_abs_section (sec)
        || bed->is_function_type (((isym->st_info) & 0xF)))))
     {
       const char *verstr;
       size_t namelen, verlen, newlen;
       char *newname, *p;

       if (isym->st_shndx != 0)
  {
    if (vernum > ((abfd) -> tdata.elf_obj_data)->cverdefs)
      verstr = 
# 5004 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 5004 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
    else if (vernum > 1)
      verstr =
        ((abfd) -> tdata.elf_obj_data)->verdef[vernum - 1].vd_nodename;
    else
      verstr = "";

    if (verstr == 
# 5011 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 5011 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
      {
        _bfd_error_handler

   (dgettext ("bfd", "%pB: %s: invalid version %u (max %d)"),
    abfd, name, vernum,
    ((abfd) -> tdata.elf_obj_data)->cverdefs);
        bfd_set_error (bfd_error_bad_value);
        goto error_free_vers;
      }
  }
       else
  {




    Elf_Internal_Verneed *t;

    verstr = 
# 5030 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 5030 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    for (t = ((abfd) -> tdata.elf_obj_data)->verref;
         t != 
# 5032 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 5032 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
         t = t->vn_nextref)
      {
        Elf_Internal_Vernaux *a;

        for (a = t->vn_auxptr; a != 
# 5037 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 5037 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; a = a->vna_nextptr)
   {
     if (a->vna_other == vernum)
       {
         verstr = a->vna_nodename;
         break;
       }
   }
        if (a != 
# 5045 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 5045 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
   break;
      }
    if (verstr == 
# 5048 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 5048 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
      {
        _bfd_error_handler

   (dgettext ("bfd", "%pB: %s: invalid needed version %d"),
    abfd, name, vernum);
        bfd_set_error (bfd_error_bad_value);
        goto error_free_vers;
      }
  }

       namelen = strlen (name);
       verlen = strlen (verstr);
       newlen = namelen + verlen + 2;
       if ((iver.vs_vers & 0x8000) == 0
    && isym->st_shndx != 0)
  ++newlen;

       newname = (char *) bfd_hash_allocate (&htab->root.table, newlen);
       if (newname == 
# 5067 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 5067 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
  goto error_free_vers;
       memcpy (newname, name, namelen);
       p = newname + namelen;
       *p++ = '@';



       if ((iver.vs_vers & 0x8000) == 0
    && isym->st_shndx != 0)
  *p++ = '@';
       memcpy (p, verstr, verlen + 1);

       name = newname;
     }



   if (!bfd_is_und_section (sec)
       && !dynamic
       && abfd->no_export
       && ((isym->st_other) & 0x3) != 1)
     isym->st_other = (2
         | (isym->st_other & ~((-1) & 0x3)));

   if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,
          sym_hash, &old_bfd, &old_weak,
          &old_alignment, &skip, &override,
          &type_change_ok, &size_change_ok,
          &matched))
     goto error_free_vers;

   if (skip)
     continue;



   if (override && matched)
     definition = 
# 5105 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 0
# 5105 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;

   h = *sym_hash;
   while (h->root.type == bfd_link_hash_indirect
   || h->root.type == bfd_link_hash_warning)
     h = (struct elf_link_hash_entry *) h->root.u.i.link;

   if (h->versioned != unversioned
       && ((abfd) -> tdata.elf_obj_data)->verdef != 
# 5113 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
       
# 5114 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && vernum > 1
       && definition)
     h->verinfo.verdef = &((abfd) -> tdata.elf_obj_data)->verdef[vernum - 1];
 }

      if (! (_bfd_generic_link_add_one_symbol
      (info, override ? override : abfd, name, flags, sec, value,
       
# 5121 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      ((void *)0)
# 5121 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          , 
# 5121 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 5121 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 , bed->collect,
       (struct bfd_link_hash_entry **) sym_hash)))
 goto error_free_vers;

      h = *sym_hash;


      hi = h;
      while (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
 h = (struct elf_link_hash_entry *) h->root.u.i.link;

      *sym_hash = h;



      if (discarded && is_elf_hash_table (&htab->root))
 h->indx = -3;

      new_weak = (flags & (1 << 7)) != 0;
      if (dynamic
   && definition
   && new_weak
   && !bed->is_function_type (((isym->st_info) & 0xF))
   && is_elf_hash_table (&htab->root)
   && h->u.alias == 
# 5146 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 5146 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
 {
# 5160 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   h->u.alias = weaks;
   weaks = h;
 }


      if ((common || bfd_is_com_section (sec))
   && h->root.type == bfd_link_hash_common)
 {
   unsigned int align;

   if (common)
     align = bfd_log2 (isym->st_value);
   else
     {


       align = new_sec->alignment_power;
     }
   if (align > old_alignment)
     h->root.u.c.p->alignment_power = align;
   else
     h->root.u.c.p->alignment_power = old_alignment;
 }

      if (is_elf_hash_table (&htab->root))
 {




   
# 5190 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 5190 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       dynsym = 
# 5190 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                0
# 5190 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ;


   if ((abfd->flags & 0x10000) != 0)
     {

       if (!definition
    && bind != 2)
  h->ref_ir_nonweak = 1;
     }
   else if (!dynamic)
     {
       if (! definition)
  {
    h->ref_regular = 1;
    if (bind != 2)
      h->ref_regular_nonweak = 1;
  }
       else
  {
    h->def_regular = 1;
    if (h->def_dynamic)
      {
        h->def_dynamic = 0;
        h->ref_dynamic = 1;
      }
  }
     }
   else
     {
       if (! definition)
  {
    h->ref_dynamic = 1;
    hi->ref_dynamic = 1;
  }
       else
  {
    h->def_dynamic = 1;
    hi->def_dynamic = 1;
  }
     }



   if (h != hi && hi->forced_local)
     ;
   else if (!dynamic)
     {
       if (((info)->type == type_dll)
    || h->def_dynamic
    || h->ref_dynamic)
  dynsym = 
# 5241 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 5241 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
     }
   else
     {
       if (h->def_regular
    || h->ref_regular
    || (h->is_weakalias
        && weakdef (h)->dynindx != -1))
  dynsym = 
# 5249 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 5249 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
     }



   if ((definition
        || (!override && h->root.type == bfd_link_hash_common))
       && !(hi != h
     && hi->versioned == versioned_hidden))
     if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,
           sec, value, &old_bfd, &dynsym))
       goto error_free_vers;






   if ((old_alignment || common)
       && h->root.type != bfd_link_hash_common)
     {
       unsigned int common_align;
       unsigned int normal_align;
       unsigned int symbol_align;
       bfd *normal_bfd;
       bfd *common_bfd;

       do { if (!(h->root.type == bfd_link_hash_defined || h->root.type == bfd_link_hash_defweak)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",5276); } while (0)
                                              ;

       symbol_align = ffs (h->root.u.def.value) - 1;
       if (h->root.u.def.section->owner != 
# 5280 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
    
# 5281 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && (h->root.u.def.section->owner->flags
         & (0x40 | 0x10000)) == 0)
  {
    normal_align = h->root.u.def.section->alignment_power;
    if (normal_align > symbol_align)
      normal_align = symbol_align;
  }
       else
  normal_align = symbol_align;

       if (old_alignment)
  {
    common_align = old_alignment;
    common_bfd = old_bfd;
    normal_bfd = abfd;
  }
       else
  {
    common_align = bfd_log2 (isym->st_value);
    common_bfd = abfd;
    normal_bfd = old_bfd;
  }

       if (normal_align < common_align)
  {

    if (normal_bfd == 
# 5307 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 5307 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
      _bfd_error_handler

        (dgettext ("bfd", "warning: alignment %u of common symbol `%s' in %pB is" " greater than the alignment (%u) of its section %pA")
                                                          ,
         1 << common_align, name, common_bfd,
         1 << normal_align, h->root.u.def.section);
    else
      _bfd_error_handler

        (dgettext ("bfd", "warning: alignment %u of normal symbol `%s' in %pB" " is smaller than %u used by the common definition in %pB")
                                                               ,
         1 << normal_align, name, normal_bfd,
         1 << common_align, common_bfd);


    _bfd_error_handler
      (dgettext ("bfd", "warning: NOTE: alignment discrepancies can cause real problems.  Investigation is advised."));
  }
     }


   if (isym->st_size != 0
       && isym->st_shndx != 0
       && (definition || h->size == 0))
     {
       if (h->size != 0
    && h->size != isym->st_size
    && ! size_change_ok)
  {
    _bfd_error_handler

      (dgettext ("bfd", "warning: size of symbol `%s' changed" " from %" 
# 5339 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      "l" "u" 
# 5339 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      " in %pB to %" 
# 5339 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      "l" "u" 
# 5339 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      " in %pB")
                                                          ,
       name, (uint64_t) h->size, old_bfd,
       (uint64_t) isym->st_size, abfd);


    _bfd_error_handler
      (dgettext ("bfd", "warning: NOTE: size discrepancies can cause real problems.  Investigation is advised."));
  }

       h->size = isym->st_size;
     }







   if (h->root.type == bfd_link_hash_common)
     h->size = h->root.u.c.size;

   if (((isym->st_info) & 0xF) != 0
       && ((definition && !new_weak)
    || (old_weak && h->root.type == bfd_link_hash_common)
    || h->type == 0))
     {
       unsigned int type = ((isym->st_info) & 0xF);



       if (type == 10
    && (abfd->flags & 0x40) != 0)
  type = 2;

       if (h->type != type)
  {
    if (h->type != 0 && ! type_change_ok)

      _bfd_error_handler
        (dgettext ("bfd", "warning: type of symbol `%s' changed" " from %d to %d in %pB")
                            ,
         name, h->type, type, abfd);

    h->type = type;
  }
     }


   elf_merge_st_other (abfd, h, isym->st_other, sec,
         definition, dynamic);


   if (definition
       && (sec->flags & 0x2000)
       && !((info)->type == type_relocatable))
     dynsym = 
# 5395 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 5395 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;


   if ((abfd->flags & 0x10000) != 0)
     dynsym = 
# 5399 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 5399 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;

   if (definition)
     {
       h->target_internal = isym->st_target_internal;
       h->unique_global = (flags & (1 << 23)) != 0;
     }






   if (definition
       && !dynamic
       && (abfd->flags & 0x10000) == 0)
     {
       char *p = strchr (name, '@');
       if (p != 
# 5417 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0) 
# 5417 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    && p[1] != '@')
  {


    if (!nondeflt_vers)
      {
        size_t amt = ((isymend - isym + 1)
        * sizeof (struct elf_link_hash_entry *));
        nondeflt_vers
   = (struct elf_link_hash_entry **) bfd_malloc (amt);
        if (!nondeflt_vers)
   goto error_free_vers;
      }
    nondeflt_vers[nondeflt_vers_cnt++] = h;
  }
     }

   if (dynsym && h->dynindx == -1)
     {
       if (! bfd_elf_link_record_dynamic_symbol (info, h))
  goto error_free_vers;
       if (h->is_weakalias
    && weakdef (h)->dynindx == -1)
  {
    if (!bfd_elf_link_record_dynamic_symbol (info, weakdef (h)))
      goto error_free_vers;
  }
     }
   else if (h->dynindx != -1)



     switch (((h->other) & 0x3))
       {
       case 1:
       case 2:
  (*bed->elf_backend_hide_symbol) (info, h, 
# 5453 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           1
# 5453 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               );
  dynsym = 
# 5454 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 5454 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  break;
       }

   if (!add_needed
       && matched
       && definition
       && h->root.type != bfd_link_hash_indirect
       && ((dynsym
     && h->ref_regular_nonweak)
    || (old_bfd != 
# 5464 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
        
# 5465 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       && (old_bfd->flags & 0x10000) != 0
        && h->ref_ir_nonweak
        && !info->lto_all_symbols_read)
    || (h->ref_dynamic_nonweak
        && ((((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) & DYN_AS_NEEDED) != 0
        && !on_needed_list ((((abfd) -> tdata.elf_obj_data) -> dt_name),
       htab->needed, 
# 5471 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 5471 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ))))
     {
       const char *soname = (((abfd) -> tdata.elf_obj_data) -> dt_name);

       info->callbacks->minfo ("%!", soname, old_bfd,
          h->root.root.string);






       if (old_bfd != 
# 5483 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
    
# 5484 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && ((((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) & DYN_NO_NEEDED) != 0)
  {
    _bfd_error_handler

      (dgettext ("bfd", "%pB: undefined reference to symbol '%s'"),
       old_bfd, name);
    bfd_set_error (bfd_error_missing_dso);
    goto error_free_vers;
  }

       (((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) = (enum dynamic_lib_link_class)
  ((((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) & ~DYN_AS_NEEDED);



       if (!_bfd_elf_link_create_dynamic_sections (abfd, info))
  return 
# 5500 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 5500 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
       add_needed = 
# 5501 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   1
# 5501 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
     }
 }
    }

  if (info->lto_plugin_active
      && !((info)->type == type_relocatable)
      && (abfd->flags & 0x10000) == 0
      && !just_syms
      && extsymcount)
    {
      int r_sym_shift;

      if (bed->s->arch_size == 32)
 r_sym_shift = 8;
      else
 r_sym_shift = 32;





      sym_hash = (((abfd) -> tdata.elf_obj_data) -> sym_hashes);
      for (s = abfd->sections; s != 
# 5524 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 5524 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; s = s->next)
 {
   Elf_Internal_Rela *internal_relocs;
   Elf_Internal_Rela *rel, *relend;


   if ((s->flags & 0x4) == 0
       || s->reloc_count == 0
       || (s->flags & 0x8000) != 0
       || ((info->strip == strip_all
     || info->strip == strip_debugger)
    && (s->flags & 0x2000) != 0))
     continue;

   internal_relocs = _bfd_elf_link_info_read_relocs (abfd, info,
           s, 
# 5539 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 5539 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ,
           
# 5540 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 5540 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ,
           _bfd_link_keep_memory (info));
   if (internal_relocs == 
# 5542 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 5542 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
     goto error_free_vers;

   rel = internal_relocs;
   relend = rel + s->reloc_count;
   for ( ; rel < relend; rel++)
     {
       unsigned long r_symndx = rel->r_info >> r_sym_shift;
       struct elf_link_hash_entry *h;


       if (r_symndx < extsymoff)
  continue;

       h = sym_hash[r_symndx - extsymoff];
       if (h != 
# 5557 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 5557 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
  h->root.non_ir_ref_regular = 1;
     }

   if (((struct bfd_elf_section_data*)(s)->used_by_bfd)->relocs != internal_relocs)
     free (internal_relocs);
 }
    }

  free (extversym);
  extversym = 
# 5567 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 5567 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
  free (isymbuf);
  isymbuf = 
# 5569 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 5569 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (((((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) & DYN_AS_NEEDED) != 0)
    {
      unsigned int i;


      old_ent = (char *) old_tab + tabsize;
      memset ((((abfd) -> tdata.elf_obj_data) -> sym_hashes), 0,
       extsymcount * sizeof (struct elf_link_hash_entry *));
      htab->root.table.table = old_table;
      htab->root.table.size = old_size;
      htab->root.table.count = old_count;
      memcpy (htab->root.table.table, old_tab, tabsize);
      htab->root.undefs = old_undefs;
      htab->root.undefs_tail = old_undefs_tail;
      if (htab->dynstr != 
# 5585 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 5585 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
 _bfd_elf_strtab_restore (htab->dynstr, old_strtab);
      free (old_strtab);
      old_strtab = 
# 5588 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 5588 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
      for (i = 0; i < htab->root.table.size; i++)
 {
   struct bfd_hash_entry *p;
   struct elf_link_hash_entry *h;
   unsigned int non_ir_ref_dynamic;

   for (p = htab->root.table.table[i]; p != 
# 5595 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 5595 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               ; p = p->next)
     {



       h = (struct elf_link_hash_entry *) p;
       if (h->root.type == bfd_link_hash_warning)
  h = (struct elf_link_hash_entry *) h->root.u.i.link;
       non_ir_ref_dynamic = h->root.non_ir_ref_dynamic;

       h = (struct elf_link_hash_entry *) p;
       memcpy (h, old_ent, htab->root.table.entsize);
       old_ent = (char *) old_ent + htab->root.table.entsize;
       if (h->root.type == bfd_link_hash_warning)
  {
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
    memcpy (h, old_ent, htab->root.table.entsize);
    old_ent = (char *) old_ent + htab->root.table.entsize;
  }
       if (h->root.type == bfd_link_hash_common)
  {
    memcpy (h->root.u.c.p, old_ent, sizeof (*h->root.u.c.p));
    old_ent = (char *) old_ent + sizeof (*h->root.u.c.p);
  }
       h->root.non_ir_ref_dynamic = non_ir_ref_dynamic;
     }
 }



      if (!(*bed->notice_as_needed) (abfd, info, notice_not_needed))
 goto error_free_vers;

      free (old_tab);
      objalloc_free_block ((struct objalloc *) htab->root.table.memory,
      alloc_mark);
      free (nondeflt_vers);
      return 
# 5632 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 5632 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }

  if (old_tab != 
# 5635 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 5635 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
    {
      if (!(*bed->notice_as_needed) (abfd, info, notice_needed))
 goto error_free_vers;
      free (old_tab);
      old_tab = 
# 5640 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 5640 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
    }




  if (!((info)->type == type_relocatable) && nondeflt_vers != 
# 5646 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                      ((void *)0)
# 5646 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                          )
    {
      size_t cnt, symidx;

      for (cnt = 0; cnt < nondeflt_vers_cnt; ++cnt)
 {
   struct elf_link_hash_entry *h = nondeflt_vers[cnt], *hi;
   char *shortname, *p;
   size_t amt;

   p = strchr (h->root.root.string, '@');
   if (p == 
# 5657 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
       
# 5658 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      || (h->root.type != bfd_link_hash_defined
    && h->root.type != bfd_link_hash_defweak))
     continue;

   amt = p - h->root.root.string;
   shortname = (char *) bfd_malloc (amt + 1);
   if (!shortname)
     goto error_free_vers;
   memcpy (shortname, h->root.root.string, amt);
   shortname[amt] = '\0';

   hi = (struct elf_link_hash_entry *)
        bfd_link_hash_lookup (&htab->root, shortname,
         
# 5671 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 5671 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             , 
# 5671 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               0
# 5671 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    , 
# 5671 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      0
# 5671 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           );
   if (hi != 
# 5672 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
       
# 5673 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && hi->root.type == h->root.type
       && hi->root.u.def.value == h->root.u.def.value
       && hi->root.u.def.section == h->root.u.def.section)
     {
       (*bed->elf_backend_hide_symbol) (info, hi, 
# 5677 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                 1
# 5677 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                     );
       hi->root.type = bfd_link_hash_indirect;
       hi->root.u.i.link = (struct bfd_link_hash_entry *) h;
       (*bed->elf_backend_copy_indirect_symbol) (info, h, hi);
       sym_hash = (((abfd) -> tdata.elf_obj_data) -> sym_hashes);
       if (sym_hash)
  for (symidx = 0; symidx < extsymcount; ++symidx)
    if (sym_hash[symidx] == hi)
      {
        sym_hash[symidx] = h;
        break;
      }
     }
   free (shortname);
 }
      free (nondeflt_vers);
      nondeflt_vers = 
# 5693 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 5693 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
    }
# 5709 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if (weaks != 
# 5709 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 5709 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    {
      struct elf_link_hash_entry **hpp;
      struct elf_link_hash_entry **hppend;
      struct elf_link_hash_entry **sorted_sym_hash;
      struct elf_link_hash_entry *h;
      size_t sym_count, amt;




      amt = extsymcount * sizeof (*sorted_sym_hash);
      sorted_sym_hash = bfd_malloc (amt);
      if (sorted_sym_hash == 
# 5722 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 5722 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
 goto error_return;
      sym_hash = sorted_sym_hash;
      hpp = (((abfd) -> tdata.elf_obj_data) -> sym_hashes);
      hppend = hpp + extsymcount;
      sym_count = 0;
      for (; hpp < hppend; hpp++)
 {
   h = *hpp;
   if (h != 
# 5731 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
       
# 5732 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && h->root.type == bfd_link_hash_defined
       && !bed->is_function_type (h->type))
     {
       *sym_hash = h;
       sym_hash++;
       sym_count++;
     }
 }

      qsort (sorted_sym_hash, sym_count, sizeof (*sorted_sym_hash),
      elf_sort_symbol);

      while (weaks != 
# 5744 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 5744 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
 {
   struct elf_link_hash_entry *hlook;
   asection *slook;
   bfd_vma vlook;
   size_t i, j, idx = 0;

   hlook = weaks;
   weaks = hlook->u.alias;
   hlook->u.alias = 
# 5753 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 5753 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;

   if (hlook->root.type != bfd_link_hash_defined
       && hlook->root.type != bfd_link_hash_defweak)
     continue;

   slook = hlook->root.u.def.section;
   vlook = hlook->root.u.def.value;

   i = 0;
   j = sym_count;
   while (i != j)
     {
       bfd_signed_vma vdiff;
       idx = (i + j) / 2;
       h = sorted_sym_hash[idx];
       vdiff = vlook - h->root.u.def.value;
       if (vdiff < 0)
  j = idx;
       else if (vdiff > 0)
  i = idx + 1;
       else
  {
    int sdiff = slook->id - h->root.u.def.section->id;
    if (sdiff < 0)
      j = idx;
    else if (sdiff > 0)
      i = idx + 1;
    else
      break;
  }
     }


   if (i == j)
     continue;





   while (++idx != j)
     {
       h = sorted_sym_hash[idx];
       if (h->root.u.def.section != slook
    || h->root.u.def.value != vlook)
  break;
     }




   while (idx-- != i)
     {
       h = sorted_sym_hash[idx];


       if (h->root.u.def.section != slook
    || h->root.u.def.value != vlook)
  break;
       else if (h != hlook)
  {
    struct elf_link_hash_entry *t;

    hlook->u.alias = h;
    hlook->is_weakalias = 1;
    t = h;
    if (t->u.alias != 
# 5820 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 5820 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
      while (t->u.alias != h)
        t = t->u.alias;
    t->u.alias = hlook;




    if (hlook->dynindx != -1 && h->dynindx == -1)
      {
        if (! bfd_elf_link_record_dynamic_symbol (info, h))
   {
   err_free_sym_hash:
     free (sorted_sym_hash);
     goto error_return;
   }
      }






    if (h->dynindx != -1 && hlook->dynindx == -1)
      {
        if (! bfd_elf_link_record_dynamic_symbol (info, hlook))
   goto err_free_sym_hash;
      }
    break;
  }
     }
 }

      free (sorted_sym_hash);
    }

  if (bed->check_directives
      && !(*bed->check_directives) (abfd, info))
    return 
# 5858 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 5858 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



  if (! dynamic
      && ! info->traditional_format
      && is_elf_hash_table (&htab->root)
      && (info->strip != strip_all && info->strip != strip_debugger))
    {
      asection *stabstr;

      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
      if (stabstr != 
# 5870 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 5870 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        )
 {
   bfd_size_type string_offset = 0;
   asection *stab;

   for (stab = abfd->sections; stab; stab = stab->next)
     if (startswith (stab->name, ".stab")
  && (!stab->name[5] ||
      (stab->name[5] == '.' && (_sch_istable[(stab->name[6]) & 0xff] & (unsigned short)(_sch_isdigit))))
  && (stab->flags & 0x800000) == 0
  && !bfd_is_abs_section (stab->output_section))
       {
  struct bfd_elf_section_data *secdata;

  secdata = ((struct bfd_elf_section_data*)(stab)->used_by_bfd);
  if (! _bfd_link_section_stabs (abfd, &htab->stab_info, stab,
            stabstr, &secdata->sec_info,
            &string_offset))
    goto error_return;
  if (secdata->sec_info)
    stab->sec_info_type = 1;
     }
 }
    }

  if (dynamic && add_needed)
    {

      struct elf_link_loaded_list *n;

      n = (struct elf_link_loaded_list *) bfd_alloc (abfd, sizeof (*n));
      if (n == 
# 5901 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 5901 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 goto error_return;
      n->abfd = abfd;
      n->next = htab->dyn_loaded;
      htab->dyn_loaded = n;
    }
  if (dynamic && !add_needed
      && ((((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) & DYN_DT_NEEDED) != 0)
    (((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) |= DYN_NO_NEEDED;

  return 
# 5911 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 5911 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

 error_free_vers:
  free (old_tab);
  free (old_strtab);
  free (nondeflt_vers);
  free (extversym);
 error_free_sym:
  free (isymbuf);
 error_return:
  return 
# 5921 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 5921 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}




struct bfd_link_hash_entry *
_bfd_elf_archive_symbol_lookup (bfd *abfd,
    struct bfd_link_info *info,
    const char *name)
{
  struct bfd_link_hash_entry *h;
  char *p, *copy;
  size_t len, first;

  h = bfd_link_hash_lookup (info->hash, name, 
# 5936 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             0
# 5936 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                  , 
# 5936 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                    0
# 5936 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                         , 
# 5936 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                           1
# 5936 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                               );
  if (h != 
# 5937 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 5937 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    return h;






  p = strchr (name, '@');
  if (p == 
# 5946 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0) 
# 5946 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               || p[1] != '@')
    return h;


  len = strlen (name);
  copy = (char *) bfd_alloc (abfd, len);
  if (copy == 
# 5952 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 5952 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
    return (struct bfd_link_hash_entry *) -1;

  first = p - name + 1;
  memcpy (copy, name, first);
  memcpy (copy + first, name + first + 1, len - first);

  h = bfd_link_hash_lookup (info->hash, copy, 
# 5959 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             0
# 5959 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                  , 
# 5959 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                    0
# 5959 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                         , 
# 5959 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                           1
# 5959 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                               );
  if (h == 
# 5960 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 5960 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {


      copy[first - 1] = '\0';
      h = bfd_link_hash_lookup (info->hash, copy, 
# 5965 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                 0
# 5965 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                      , 
# 5965 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                        0
# 5965 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                             , 
# 5965 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                               1
# 5965 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                   );
    }

  bfd_release (abfd, copy);
  return h;
}
# 5985 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
static 
# 5985 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 5986 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
{
  symindex c;
  unsigned char *included = 
# 5989 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 5989 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               ;
  carsym *symdefs;
  
# 5991 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 5991 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      loop;
  size_t amt;
  const struct elf_backend_data *bed;
  struct bfd_link_hash_entry * (*archive_symbol_lookup)
    (bfd *, struct bfd_link_info *, const char *);

  if (! bfd_has_map (abfd))
    {

      if (bfd_openr_next_archived_file (abfd, 
# 6000 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             ((void *)0)
# 6000 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                 ) == 
# 6000 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                      ((void *)0)
# 6000 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                          )
 return 
# 6001 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 6001 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
      bfd_set_error (bfd_error_no_armap);
      return 
# 6003 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 6003 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }




  c = ((abfd)->tdata.aout_ar_data)->symdef_count;
  if (c == 0)
    return 
# 6011 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 6011 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  amt = c * sizeof (*included);
  included = (unsigned char *) bfd_zmalloc (amt);
  if (included == 
# 6014 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 6014 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
    return 
# 6015 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 6015 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  symdefs = ((abfd)->tdata.aout_ar_data)->symdefs;
  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  archive_symbol_lookup = bed->elf_backend_archive_symbol_lookup;

  do
    {
      file_ptr last;
      symindex i;
      carsym *symdef;
      carsym *symdefend;

      loop = 
# 6028 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 6028 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
      last = -1;

      symdef = symdefs;
      symdefend = symdef + c;
      for (i = 0; symdef < symdefend; symdef++, i++)
 {
   struct bfd_link_hash_entry *h;
   bfd *element;
   struct bfd_link_hash_entry *undefs_tail;
   symindex mark;

   if (included[i])
     continue;
   if (symdef->file_offset == last)
     {
       included[i] = 
# 6044 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    1
# 6044 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
       continue;
     }

   h = archive_symbol_lookup (abfd, info, symdef->name);
   if (h == (struct bfd_link_hash_entry *) -1)
     goto error_return;

   if (h == 
# 6052 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 6052 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               )
     continue;

   if (h->type == bfd_link_hash_undefined)
     {



       if (is_elf_hash_table (info->hash)
    && ((struct elf_link_hash_entry *) h)->indx == -3)
  continue;
     }
   else if (h->type == bfd_link_hash_common)
     {
# 6078 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       if (! elf_link_is_defined_archive_symbol (abfd, symdef))
  continue;
     }
   else
     {
       if (h->type != bfd_link_hash_undefweak)

  included[i] = 
# 6085 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               1
# 6085 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
       continue;
     }


   element = _bfd_get_elt_at_filepos (abfd, symdef->file_offset,
          info);
   if (element == 
# 6092 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 6092 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
     goto error_return;

   if (! bfd_check_format (element, bfd_object))
     goto error_return;

   undefs_tail = info->hash->undefs_tail;

   if (!(*info->callbacks
  ->add_archive_element) (info, element, symdef->name, &element))
     continue;
   if (!((*((element)->xvec->_bfd_link_add_symbols)) (element, info)))
     goto error_return;
# 6113 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   if (undefs_tail != info->hash->undefs_tail)
     loop = 
# 6114 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 6114 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



   mark = i;
   do
     {
       included[mark] = 
# 6121 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 6121 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
       if (mark == 0)
  break;
       --mark;
     }
   while (symdefs[mark].file_offset == symdef->file_offset);



   last = symdef->file_offset;
 }
    }
  while (loop);

  free (included);
  return 
# 6136 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 6136 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

 error_return:
  free (included);
  return 
# 6140 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 6140 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}





# 6146 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 6147 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return elf_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return elf_link_add_archive_symbols (abfd, info);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return 
# 6157 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 6157 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }
}

struct hash_codes_info
{
  unsigned long *hashcodes;
  
# 6164 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 6164 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      error;
};




static 
# 6170 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 6171 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_collect_hash_codes (struct elf_link_hash_entry *h, void *data)
{
  struct hash_codes_info *inf = (struct hash_codes_info *) data;
  const char *name;
  unsigned long ha;
  char *alc = 
# 6176 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 6176 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;


  if (h->dynindx == -1)
    return 
# 6180 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 6180 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  name = h->root.root.string;
  if (h->versioned >= versioned)
    {
      char *p = strchr (name, '@');
      if (p != 
# 6186 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 6186 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 {
   alc = (char *) bfd_malloc (p - name + 1);
   if (alc == 
# 6189 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 6189 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
     {
       inf->error = 
# 6191 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   1
# 6191 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
       return 
# 6192 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 6192 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
   memcpy (alc, name, p - name);
   alc[p - name] = '\0';
   name = alc;
 }
    }


  ha = bfd_elf_hash (name);


  *(inf->hashcodes)++ = ha;



  h->u.elf_hash_value = ha;

  free (alc);
  return 
# 6211 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 6211 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}

struct collect_gnu_hash_codes
{
  bfd *output_bfd;
  const struct elf_backend_data *bed;
  unsigned long int nsyms;
  unsigned long int maskbits;
  unsigned long int *hashcodes;
  unsigned long int *hashval;
  unsigned long int *indx;
  unsigned long int *counts;
  bfd_vma *bitmask;
  bfd_byte *contents;
  bfd_size_type xlat;
  long int min_dynindx;
  unsigned long int bucketcount;
  unsigned long int symindx;
  long int local_indx;
  long int shift1, shift2;
  unsigned long int mask;
  
# 6233 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 6233 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      error;
};




static 
# 6239 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 6240 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_collect_gnu_hash_codes (struct elf_link_hash_entry *h, void *data)
{
  struct collect_gnu_hash_codes *s = (struct collect_gnu_hash_codes *) data;
  const char *name;
  unsigned long ha;
  char *alc = 
# 6245 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 6245 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;


  if (h->dynindx == -1)
    return 
# 6249 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 6249 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (! (*s->bed->elf_hash_symbol) (h))
    return 
# 6253 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 6253 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  name = h->root.root.string;
  if (h->versioned >= versioned)
    {
      char *p = strchr (name, '@');
      if (p != 
# 6259 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 6259 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 {
   alc = (char *) bfd_malloc (p - name + 1);
   if (alc == 
# 6262 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 6262 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
     {
       s->error = 
# 6264 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 1
# 6264 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ;
       return 
# 6265 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 6265 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
   memcpy (alc, name, p - name);
   alc[p - name] = '\0';
   name = alc;
 }
    }


  ha = bfd_elf_gnu_hash (name);



  s->hashcodes[s->nsyms] = ha;
  s->hashval[h->dynindx] = ha;
  ++s->nsyms;
  if (s->min_dynindx < 0 || s->min_dynindx > h->dynindx)
    s->min_dynindx = h->dynindx;

  free (alc);
  return 
# 6285 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 6285 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






static 
# 6293 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 6294 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_gnu_hash_process_symidx (struct elf_link_hash_entry *h, void *data)
{
  struct collect_gnu_hash_codes *s = (struct collect_gnu_hash_codes *) data;
  unsigned long int bucket;
  unsigned long int val;


  if (h->dynindx == -1)
    return 
# 6302 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 6302 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (! (*s->bed->elf_hash_symbol) (h))
    {
      if (h->dynindx >= s->min_dynindx)
 {
   if (s->bed->record_xhash_symbol != 
# 6309 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 6309 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         )
     {
       (*s->bed->record_xhash_symbol) (h, 0);
       s->local_indx++;
     }
   else
     h->dynindx = s->local_indx++;
 }
      return 
# 6317 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 6317 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }

  bucket = s->hashval[h->dynindx] % s->bucketcount;
  val = (s->hashval[h->dynindx] >> s->shift1)
 & ((s->maskbits >> s->shift1) - 1);
  s->bitmask[val] |= ((bfd_vma) 1) << (s->hashval[h->dynindx] & s->mask);
  s->bitmask[val]
    |= ((bfd_vma) 1) << ((s->hashval[h->dynindx] >> s->shift2) & s->mask);
  val = s->hashval[h->dynindx] & ~(unsigned long int) 1;
  if (s->counts[bucket] == 1)

    val |= 1;
  ((*((s->output_bfd)->xvec->bfd_putx32)) ((val),(s->contents + (s->indx[bucket] - s->symindx) * 4)))
                                                        ;
  --s->counts[bucket];
  if (s->bed->record_xhash_symbol != 
# 6333 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                    ((void *)0)
# 6333 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                        )
    {
      bfd_vma xlat_loc = s->xlat + (s->indx[bucket]++ - s->symindx) * 4;

      (*s->bed->record_xhash_symbol) (h, xlat_loc);
    }
  else
    h->dynindx = s->indx[bucket]++;
  return 
# 6341 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 6341 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




# 6346 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 6347 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_hash_symbol (struct elf_link_hash_entry *h)
{
  return !(h->forced_local
    || h->root.type == bfd_link_hash_undefined
    || h->root.type == bfd_link_hash_undefweak
    || ((h->root.type == bfd_link_hash_defined
  || h->root.type == bfd_link_hash_defweak)
        && h->root.u.def.section->output_section == 
# 6354 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                   ((void *)0)
# 6354 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                       ));
}







static const size_t elf_buckets[] =
{
  1, 3, 17, 37, 67, 97, 131, 197, 263, 521, 1031, 2053, 4099, 8209,
  16411, 32771, 0
};
# 6377 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
static size_t
compute_bucket_count (struct bfd_link_info *info __attribute__ ((__unused__)),
        unsigned long int *hashcodes __attribute__ ((__unused__)),
        unsigned long int nsyms,
        int gnu_hash)
{
  size_t best_size = 0;
  unsigned long int i;

  if (info->optimize)
    {
      size_t minsize;
      size_t maxsize;
      uint64_t best_chlen = ~((uint64_t) 0);
      bfd *dynobj = elf_hash_table (info)->dynobj;
      size_t dynsymcount = elf_hash_table (info)->dynsymcount;
      const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((dynobj)->xvec)->backend_data);
      unsigned long int *counts;
      bfd_size_type amt;
      unsigned int no_improvement_count = 0;




      minsize = nsyms / 4;
      if (minsize == 0)
 minsize = 1;
      best_size = maxsize = nsyms * 2;
      if (gnu_hash)
 {
   if (minsize < 2)
     minsize = 2;
   if ((best_size & 31) == 0)
     ++best_size;
 }



      amt = maxsize;
      amt *= sizeof (unsigned long int);
      counts = (unsigned long int *) bfd_malloc (amt);
      if (counts == 
# 6418 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 6418 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
 return 0;




      for (i = minsize; i < maxsize; ++i)
 {

   uint64_t max;
   unsigned long int j;
   unsigned long int fact;

   if (gnu_hash && (i & 31) == 0)
     continue;

   memset (counts, '\0', i * sizeof (unsigned long int));


   for (j = 0; j < nsyms; ++j)
     ++counts[hashcodes[j] % i];
# 6451 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   max = (2 + dynsymcount) * bed->s->sizeof_hash_entry;





   for (j = 0; j < i; ++j)
     max += counts[j] * counts[j];


   fact = i / ((4096) / bed->s->sizeof_hash_entry) + 1;
   max *= fact * fact;
# 6477 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   if (max < best_chlen)
     {
       best_chlen = max;
       best_size = i;
       no_improvement_count = 0;
     }


   else if (++no_improvement_count == 100)
     break;
 }

      free (counts);
    }
  else
    {
      for (i = 0; elf_buckets[i] != 0; i++)
 {
   best_size = elf_buckets[i];
   if (nsyms < elf_buckets[i + 1])
     break;
 }
      if (gnu_hash && best_size < 2)
 best_size = 2;
    }

  return best_size;
}




# 6508 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 6509 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_size_group_sections (struct bfd_link_info *info)
{
  bfd *ibfd;
  asection *s;

  for (ibfd = info->input_bfds; ibfd != 
# 6514 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 6514 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           ; ibfd = ibfd->link.next)
    if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
 && (s = ibfd->sections) != 
# 6516 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
 
# 6517 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
&& s->sec_info_type != 4
 && !_bfd_elf_fixup_group_sections (ibfd, (&_bfd_std_section[2])))
      return 
# 6519 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 6519 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
  return 
# 6520 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 6520 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






# 6527 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 6528 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_stack_segment_size (bfd *output_bfd,
       struct bfd_link_info *info,
       const char *legacy_symbol,
       bfd_vma default_size)
{
  struct elf_link_hash_entry *h = 
# 6533 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 ((void *)0)
# 6533 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                     ;


  if (legacy_symbol)
    h = elf_link_hash_lookup (elf_hash_table (info), legacy_symbol,
         
# 6538 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 6538 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             , 
# 6538 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               0
# 6538 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    , 
# 6538 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      0
# 6538 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           );
  if (h && (h->root.type == bfd_link_hash_defined
     || h->root.type == bfd_link_hash_defweak)
      && h->def_regular
      && (h->type == 0 || h->type == 1))
    {

      h->type = 1;
      if (info->stacksize)

 _bfd_error_handler (dgettext ("bfd", "%pB: stack size specified and %s set"),
       output_bfd, legacy_symbol);
      else if (h->root.u.def.section != (&_bfd_std_section[2]))

 _bfd_error_handler (dgettext ("bfd", "%pB: %s not absolute"),
       output_bfd, legacy_symbol);
      else
 info->stacksize = h->root.u.def.value;
    }

  if (!info->stacksize)


    info->stacksize = default_size;


  if (h && (h->root.type == bfd_link_hash_undefined
     || h->root.type == bfd_link_hash_undefweak))
    {
      struct bfd_link_hash_entry *bh = 
# 6567 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
# 6567 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          ;

      if (!(_bfd_generic_link_add_one_symbol
     (info, output_bfd, legacy_symbol,
      (1 << 1), (&_bfd_std_section[2]),
      info->stacksize >= 0 ? info->stacksize : 0,
      
# 6573 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 6573 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
         , 
# 6573 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 6573 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                , ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data)->collect, &bh)))
 return 
# 6574 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 6574 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

      h = (struct elf_link_hash_entry *) bh;
      h->def_regular = 1;
      h->type = 1;
    }

  return 
# 6581 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 6581 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



struct elf_gc_sweep_symbol_info
{
  struct bfd_link_info *info;
  void (*hide_symbol) (struct bfd_link_info *, struct elf_link_hash_entry *,
         
# 6590 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool
# 6590 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            );
};

static 
# 6593 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 6594 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_gc_sweep_symbol (struct elf_link_hash_entry *h, void *data)
{
  if (!h->mark
      && (((h->root.type == bfd_link_hash_defined
     || h->root.type == bfd_link_hash_defweak)
    && !((h->def_regular || (!(h)->def_regular && !(h)->def_dynamic && (h)->root.type == bfd_link_hash_defined))
  && h->root.u.def.section->gc_mark))
   || h->root.type == bfd_link_hash_undefined
   || h->root.type == bfd_link_hash_undefweak))
    {
      struct elf_gc_sweep_symbol_info *inf;

      inf = (struct elf_gc_sweep_symbol_info *) data;
      (*inf->hide_symbol) (inf->info, h, 
# 6607 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                        1
# 6607 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                            );
      h->def_regular = 0;
      h->ref_regular = 0;
      h->ref_regular_nonweak = 0;
    }

  return 
# 6613 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 6613 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}







# 6621 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 6622 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_size_dynamic_sections (bfd *output_bfd,
          const char *soname,
          const char *rpath,
          const char *filter_shlib,
          const char *audit,
          const char *depaudit,
          const char * const *auxiliary_filters,
          struct bfd_link_info *info,
          asection **sinterpptr)
{
  bfd *dynobj;
  const struct elf_backend_data *bed;

  *sinterpptr = 
# 6635 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 6635 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;

  if (!is_elf_hash_table (info->hash))
    return 
# 6638 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 6638 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;



  elf_hash_table (info)->init_got_refcount
    = elf_hash_table (info)->init_got_offset;
  elf_hash_table (info)->init_plt_refcount
    = elf_hash_table (info)->init_plt_offset;

  bed = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);



  if (bed->elf_backend_always_size_sections
      && ! (*bed->elf_backend_always_size_sections) (output_bfd, info))
    return 
# 6653 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 6653 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  dynobj = elf_hash_table (info)->dynobj;

  if (dynobj != 
# 6657 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0) 
# 6657 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    && elf_hash_table (info)->dynamic_sections_created)
    {
      struct bfd_elf_version_tree *verdefs;
      struct elf_info_failed asvinfo;
      struct bfd_elf_version_tree *t;
      struct bfd_elf_version_expr *d;
      asection *s;
      size_t soname_indx;



      if (info->export_dynamic
   || ((((info)->type == type_pde) || ((info)->type == type_pie)) && info->dynamic))
 {
   struct elf_info_failed eif;

   eif.info = info;
   eif.failed = 
# 6674 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               0
# 6674 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;
   elf_link_hash_traverse (elf_hash_table (info),
      _bfd_elf_export_symbol,
      &eif);
   if (eif.failed)
     return 
# 6679 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 6679 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (soname != 
# 6682 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 6682 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
 {
   soname_indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
          soname, 
# 6685 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 1
# 6685 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     );
   if (soname_indx == (size_t) -1
       || !_bfd_elf_add_dynamic_entry (info, 14, soname_indx))
     return 
# 6688 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 6688 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
      else
 soname_indx = (size_t) -1;


      for (t = info->version_info; t != 
# 6694 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 6694 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           ; t = t->next)
 for (d = t->globals.list; d != 
# 6695 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 6695 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   ; d = d->next)
   if (!d->symver && d->literal)
     {
       const char *verstr, *name;
       size_t namelen, verlen, newlen;
       char *newname, *p, leading_char;
       struct elf_link_hash_entry *newh;

       leading_char = bfd_get_symbol_leading_char (output_bfd);
       name = d->pattern;
       namelen = strlen (name) + (leading_char != '\0');
       verstr = t->name;
       verlen = strlen (verstr);
       newlen = namelen + verlen + 3;

       newname = (char *) bfd_malloc (newlen);
       if (newname == 
# 6711 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 6711 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
  return 
# 6712 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 6712 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
       newname[0] = leading_char;
       memcpy (newname + (leading_char != '\0'), name, namelen);


       p = newname + namelen;
       *p++ = '@';
       memcpy (p, verstr, verlen + 1);
       newh = elf_link_hash_lookup (elf_hash_table (info),
        newname, 
# 6721 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                0
# 6721 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     , 
# 6721 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       0
# 6721 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                            ,
        
# 6722 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 6722 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            );
       if (newh == 
# 6723 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
    
# 6724 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   || (newh->root.type != bfd_link_hash_defined
        && newh->root.type != bfd_link_hash_defweak))
  {

    *p++ = '@';
    memcpy (p, verstr, verlen + 1);
    newh = elf_link_hash_lookup (elf_hash_table (info),
            newname, 
# 6731 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 6731 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         , 
# 6731 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           0
# 6731 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                ,
            
# 6732 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 6732 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                );
  }
       free (newname);



       if (newh != 
# 6738 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
    
# 6739 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && !newh->def_dynamic
    && (newh->root.type == bfd_link_hash_defined
        || newh->root.type == bfd_link_hash_defweak))
  d->symver = 1;
     }


      asvinfo.info = info;
      asvinfo.failed = 
# 6747 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      0
# 6747 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;

      elf_link_hash_traverse (elf_hash_table (info),
         _bfd_elf_link_assign_sym_version,
         &asvinfo);
      if (asvinfo.failed)
 return 
# 6753 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 6753 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

      if (!info->allow_undefined_version)
 {

   
# 6758 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 6758 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       all_defined = 
# 6758 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     1
# 6758 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
   for (t = info->version_info; t != 
# 6759 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                    ((void *)0)
# 6759 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                        ; t = t->next)
     for (d = t->globals.list; d != 
# 6760 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 6760 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; d = d->next)
       if (d->literal && !d->symver && !d->script)
  {
    _bfd_error_handler
      (dgettext ("bfd", "%s: undefined version: %s"),
       d->pattern, t->name);
    all_defined = 
# 6766 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 0
# 6766 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
  }

   if (!all_defined)
     {
       bfd_set_error (bfd_error_bad_value);
       return 
# 6772 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 6772 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
 }


      s = bfd_get_linker_section (dynobj, ".gnu.version_d");
      do { if (!(s != 
# 6778 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 6778 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",6778); } while (0);



      verdefs = info->version_info;


      if (verdefs != 
# 6785 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0) 
# 6785 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         && verdefs->vernum == 0)
 verdefs = verdefs->next;

      if (verdefs == 
# 6788 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0) 
# 6788 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         && !info->create_default_symver)
 s->flags |= 0x8000;
      else
 {
   unsigned int cdefs;
   bfd_size_type size;
   bfd_byte *p;
   Elf_Internal_Verdef def;
   Elf_Internal_Verdaux defaux;
   struct bfd_link_hash_entry *bh;
   struct elf_link_hash_entry *h;
   const char *name;

   cdefs = 0;
   size = 0;


   size += sizeof (Elf_External_Verdef);
   size += sizeof (Elf_External_Verdaux);
   ++cdefs;


   if (info->create_default_symver)
     {
       size += sizeof (Elf_External_Verdef);
       ++cdefs;
     }

   for (t = verdefs; t != 
# 6816 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 6816 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ; t = t->next)
     {
       struct bfd_elf_version_deps *n;


       if (t->vernum == 0)
  continue;

       size += sizeof (Elf_External_Verdef);
       size += sizeof (Elf_External_Verdaux);
       ++cdefs;

       for (n = t->deps; n != 
# 6828 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
# 6828 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 ; n = n->next)
  size += sizeof (Elf_External_Verdaux);
     }

   s->size = size;
   s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
   if (s->contents == 
# 6834 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0) 
# 6834 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          && s->size != 0)
     return 
# 6835 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 6835 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;



   p = s->contents;

   def.vd_version = 1;
   def.vd_flags = 0x1;
   def.vd_ndx = 1;
   def.vd_cnt = 1;
   if (info->create_default_symver)
     {
       def.vd_aux = 2 * sizeof (Elf_External_Verdef);
       def.vd_next = sizeof (Elf_External_Verdef);
     }
   else
     {
       def.vd_aux = sizeof (Elf_External_Verdef);
       def.vd_next = (sizeof (Elf_External_Verdef)
        + sizeof (Elf_External_Verdaux));
     }

   if (soname_indx != (size_t) -1)
     {
       _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
          soname_indx);
       def.vd_hash = bfd_elf_hash (soname);
       defaux.vda_name = soname_indx;
       name = soname;
     }
   else
     {
       size_t indx;

       name = lbasename (bfd_get_filename (output_bfd));
       def.vd_hash = bfd_elf_hash (name);
       indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
       name, 
# 6872 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 6872 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 );
       if (indx == (size_t) -1)
  return 
# 6874 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 6874 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
       defaux.vda_name = indx;
     }
   defaux.vda_next = 0;

   _bfd_elf_swap_verdef_out (output_bfd, &def,
        (Elf_External_Verdef *) p);
   p += sizeof (Elf_External_Verdef);
   if (info->create_default_symver)
     {

       bh = 
# 6885 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 6885 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
       if (! (_bfd_generic_link_add_one_symbol
       (info, dynobj, name, (1 << 1), (&_bfd_std_section[2]),
        0, 
# 6888 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 6888 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              , 
# 6888 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                0
# 6888 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ,
        ((const struct elf_backend_data *) ((dynobj)->xvec)->backend_data)->collect, &bh)))
  return 
# 6890 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 6890 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
       h = (struct elf_link_hash_entry *) bh;
       h->non_elf = 0;
       h->def_regular = 1;
       h->type = 1;
       h->verinfo.vertree = 
# 6895 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 6895 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               ;

       if (! bfd_elf_link_record_dynamic_symbol (info, h))
  return 
# 6898 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 6898 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;



       def.vd_flags = 0;
       def.vd_ndx = 2;
       def.vd_aux = sizeof (Elf_External_Verdef);
       if (verdefs)
  def.vd_next = (sizeof (Elf_External_Verdef)
          + sizeof (Elf_External_Verdaux));
       else
  def.vd_next = 0;
       _bfd_elf_swap_verdef_out (output_bfd, &def,
     (Elf_External_Verdef *) p);
       p += sizeof (Elf_External_Verdef);
     }
   _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
         (Elf_External_Verdaux *) p);
   p += sizeof (Elf_External_Verdaux);

   for (t = verdefs; t != 
# 6918 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 6918 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ; t = t->next)
     {
       unsigned int cdeps;
       struct bfd_elf_version_deps *n;


       if (t->vernum == 0)
  continue;

       cdeps = 0;
       for (n = t->deps; n != 
# 6928 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
# 6928 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 ; n = n->next)
  ++cdeps;


       bh = 
# 6932 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 6932 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
       if (! (_bfd_generic_link_add_one_symbol
       (info, dynobj, t->name, (1 << 1), (&_bfd_std_section[2]),
        0, 
# 6935 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 6935 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              , 
# 6935 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                0
# 6935 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ,
        ((const struct elf_backend_data *) ((dynobj)->xvec)->backend_data)->collect, &bh)))
  return 
# 6937 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 6937 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
       h = (struct elf_link_hash_entry *) bh;
       h->non_elf = 0;
       h->def_regular = 1;
       h->type = 1;
       h->verinfo.vertree = t;

       if (! bfd_elf_link_record_dynamic_symbol (info, h))
  return 
# 6945 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 6945 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;

       def.vd_version = 1;
       def.vd_flags = 0;
       if (t->globals.list == 
# 6949 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
    
# 6950 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && t->locals.list == 
# 6950 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0)
    
# 6951 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && ! t->used)
  def.vd_flags |= 0x2;
       def.vd_ndx = t->vernum + (info->create_default_symver ? 2 : 1);
       def.vd_cnt = cdeps + 1;
       def.vd_hash = bfd_elf_hash (t->name);
       def.vd_aux = sizeof (Elf_External_Verdef);
       def.vd_next = 0;



       if (t->next != 
# 6961 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0) 
# 6961 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          && t->next->vernum == 0)
  do { if (!(t->next->next == 
# 6962 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 ((void *)0)
# 6962 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
 )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",6962); } while (0);

       if (t->next != 
# 6964 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0) 
# 6964 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          && t->next->vernum != 0)
  def.vd_next = (sizeof (Elf_External_Verdef)
          + (cdeps + 1) * sizeof (Elf_External_Verdaux));

       _bfd_elf_swap_verdef_out (output_bfd, &def,
     (Elf_External_Verdef *) p);
       p += sizeof (Elf_External_Verdef);

       defaux.vda_name = h->dynstr_index;
       _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
          h->dynstr_index);
       defaux.vda_next = 0;
       if (t->deps != 
# 6976 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 6976 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
  defaux.vda_next = sizeof (Elf_External_Verdaux);
       t->name_indx = defaux.vda_name;

       _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
      (Elf_External_Verdaux *) p);
       p += sizeof (Elf_External_Verdaux);

       for (n = t->deps; n != 
# 6984 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
# 6984 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 ; n = n->next)
  {
    if (n->version_needed == 
# 6986 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 6986 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
      {


        defaux.vda_name = 0;
      }
    else
      {
        defaux.vda_name = n->version_needed->name_indx;
        _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,
           defaux.vda_name);
      }
    if (n->next == 
# 6998 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 6998 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
      defaux.vda_next = 0;
    else
      defaux.vda_next = sizeof (Elf_External_Verdaux);

    _bfd_elf_swap_verdaux_out (output_bfd, &defaux,
          (Elf_External_Verdaux *) p);
    p += sizeof (Elf_External_Verdaux);
  }
     }

   ((output_bfd) -> tdata.elf_obj_data)->cverdefs = cdefs;
 }
    }

  if (info->gc_sections && bed->can_gc_sections)
    {
      struct elf_gc_sweep_symbol_info sweep_info;



      sweep_info.info = info;
      sweep_info.hide_symbol = bed->elf_backend_hide_symbol;
      elf_link_hash_traverse (elf_hash_table (info), elf_gc_sweep_symbol,
         &sweep_info);
    }

  if (dynobj != 
# 7025 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0) 
# 7025 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    && elf_hash_table (info)->dynamic_sections_created)
    {
      asection *s;
      struct elf_find_verdep_info sinfo;



      s = bfd_get_linker_section (dynobj, ".gnu.version_r");
      do { if (!(s != 
# 7033 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 7033 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7033); } while (0);

      sinfo.info = info;
      sinfo.vers = ((output_bfd) -> tdata.elf_obj_data)->cverdefs;
      if (sinfo.vers == 0)
 sinfo.vers = 1;
      sinfo.failed = 
# 7039 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 7039 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;

      elf_link_hash_traverse (elf_hash_table (info),
         _bfd_elf_link_find_version_dependencies,
         &sinfo);
      if (sinfo.failed)
 return 
# 7045 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 7045 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

      if (info->enable_dt_relr)
 {
   elf_link_add_dt_relr_dependency (&sinfo);
   if (sinfo.failed)
     return 
# 7051 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7051 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (((output_bfd) -> tdata.elf_obj_data)->verref == 
# 7054 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 7054 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               )
 s->flags |= 0x8000;
      else
 {
   Elf_Internal_Verneed *vn;
   unsigned int size;
   unsigned int crefs;
   bfd_byte *p;


   size = 0;
   crefs = 0;
   for (vn = ((output_bfd) -> tdata.elf_obj_data)->verref;
        vn != 
# 7067 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 7067 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
        vn = vn->vn_nextref)
     {
       Elf_Internal_Vernaux *a;

       size += sizeof (Elf_External_Verneed);
       ++crefs;
       for (a = vn->vn_auxptr; a != 
# 7074 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 7074 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; a = a->vna_nextptr)
  size += sizeof (Elf_External_Vernaux);
     }

   s->size = size;
   s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
   if (s->contents == 
# 7080 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 7080 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
     return 
# 7081 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7081 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   p = s->contents;
   for (vn = ((output_bfd) -> tdata.elf_obj_data)->verref;
        vn != 
# 7085 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 7085 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
        vn = vn->vn_nextref)
     {
       unsigned int caux;
       Elf_Internal_Vernaux *a;
       size_t indx;

       caux = 0;
       for (a = vn->vn_auxptr; a != 
# 7093 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 7093 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; a = a->vna_nextptr)
  ++caux;

       vn->vn_version = 1;
       vn->vn_cnt = caux;
       indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
       (((vn->vn_bfd) -> tdata.elf_obj_data) -> dt_name) != 
# 7099 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
       
# 7100 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ? (((vn->vn_bfd) -> tdata.elf_obj_data) -> dt_name)
       : lbasename (bfd_get_filename
             (vn->vn_bfd)),
       
# 7103 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      0
# 7103 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           );
       if (indx == (size_t) -1)
  return 
# 7105 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 7105 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
       vn->vn_file = indx;
       vn->vn_aux = sizeof (Elf_External_Verneed);
       if (vn->vn_nextref == 
# 7108 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 7108 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
  vn->vn_next = 0;
       else
  vn->vn_next = (sizeof (Elf_External_Verneed)
          + caux * sizeof (Elf_External_Vernaux));

       _bfd_elf_swap_verneed_out (output_bfd, vn,
      (Elf_External_Verneed *) p);
       p += sizeof (Elf_External_Verneed);

       for (a = vn->vn_auxptr; a != 
# 7118 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 7118 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ; a = a->vna_nextptr)
  {
    a->vna_hash = bfd_elf_hash (a->vna_nodename);
    indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
           a->vna_nodename, 
# 7122 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           0
# 7122 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                );
    if (indx == (size_t) -1)
      return 
# 7124 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 7124 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    a->vna_name = indx;
    if (a->vna_nextptr == 
# 7126 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 7126 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
      a->vna_next = 0;
    else
      a->vna_next = sizeof (Elf_External_Vernaux);

    _bfd_elf_swap_vernaux_out (output_bfd, a,
          (Elf_External_Vernaux *) p);
    p += sizeof (Elf_External_Vernaux);
  }
     }

   ((output_bfd) -> tdata.elf_obj_data)->cverrefs = crefs;
 }
    }

  if (((info)->type == type_relocatable)
      && !_bfd_elf_size_group_sections (info))
    return 
# 7143 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 7143 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



  if (info->execstack)
    {


      if (info->warn_execstack == 1)
 _bfd_error_handler
   (dgettext ("bfd", "warning: enabling an executable stack because of -z execstack command line option")
                                                                                   );
      (((output_bfd) -> tdata.elf_obj_data) -> o->stack_flags) = (1 << 2) | (1 << 1) | (1 << 0);
    }
  else if (info->noexecstack)
    (((output_bfd) -> tdata.elf_obj_data) -> o->stack_flags) = (1 << 2) | (1 << 1);
  else
    {
      bfd *inputobj;
      asection *notesec = 
# 7162 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 7162 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;
      bfd *noteobj = 
# 7163 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 7163 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
      bfd *emptyobj = 
# 7164 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 7164 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
      int exec = 0;

      for (inputobj = info->input_bfds;
    inputobj;
    inputobj = inputobj->link.next)
 {
   asection *s;

   if (inputobj->flags
       & (0x40 | 0x2 | 0x10000 | 0x1000))
     continue;
   s = inputobj->sections;
   if (s == 
# 7177 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0) 
# 7177 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                || s->sec_info_type == 4)
     continue;

   s = bfd_get_section_by_name (inputobj, ".note.GNU-stack");
   if (s)
     {
       notesec = s;
       if (s->flags & 0x10)
  {
    noteobj = inputobj;
    exec = (1 << 0);

    break;
  }
     }
   else if (bed->default_execstack && info->default_execstack)
     {
       exec = (1 << 0);
       emptyobj = inputobj;
     }
 }

      if (notesec || info->stacksize > 0)
 {
   if (exec)
     {
       if (info->warn_execstack != 0)
  {




    if (noteobj)
      _bfd_error_handler (dgettext ("bfd", "warning: %s: requires executable stack (because the .note.GNU-stack section is executable)")
                                                                                            ,
         bfd_get_filename (noteobj));
    else if (emptyobj)
      {
        _bfd_error_handler (dgettext ("bfd", "warning: %s: missing .note.GNU-stack section implies executable stack")
                                                                       ,
       bfd_get_filename (emptyobj));
        _bfd_error_handler (dgettext ("bfd", "NOTE: This behaviour is deprecated and will be removed in a future version of the linker")
                                                                                          );
      }
  }
     }
   (((output_bfd) -> tdata.elf_obj_data) -> o->stack_flags) = (1 << 2) | (1 << 1) | exec;
 }

      if (notesec && exec && ((info)->type == type_relocatable)
   && notesec->output_section != (&_bfd_std_section[2]))
 notesec->output_section->flags |= 0x10;
    }

  if (dynobj != 
# 7231 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0) 
# 7231 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    && elf_hash_table (info)->dynamic_sections_created)
    {
      struct elf_info_failed eif;
      struct elf_link_hash_entry *h;
      asection *dynstr;
      asection *s;

      *sinterpptr = bfd_get_linker_section (dynobj, ".interp");
      do { if (!(*sinterpptr != 
# 7239 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0) 
# 7239 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || !(((info)->type == type_pde) || ((info)->type == type_pie)) || info->nointerp)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7239); } while (0);

      if (info->symbolic)
 {
   if (!_bfd_elf_add_dynamic_entry (info, 16, 0))
     return 
# 7244 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7244 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   info->flags |= (1 << 1);
 }

      if (rpath != 
# 7248 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 7248 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
 {
   size_t indx;
   bfd_vma tag;

   indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, rpath,
          
# 7254 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 7254 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             );
   if (indx == (size_t) -1)
     return 
# 7256 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7256 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   tag = info->new_dtags ? 29 : 15;
   if (!_bfd_elf_add_dynamic_entry (info, tag, indx))
     return 
# 7260 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7260 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (filter_shlib != 
# 7263 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 7263 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
 {
   size_t indx;

   indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
          filter_shlib, 
# 7268 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 7268 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           );
   if (indx == (size_t) -1
       || !_bfd_elf_add_dynamic_entry (info, 0x7fffffff, indx))
     return 
# 7271 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7271 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (auxiliary_filters != 
# 7274 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
# 7274 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                  )
 {
   const char * const *p;

   for (p = auxiliary_filters; *p != 
# 7278 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                    ((void *)0)
# 7278 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                        ; p++)
     {
       size_t indx;

       indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,
       *p, 
# 7283 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 7283 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              );
       if (indx == (size_t) -1
    || !_bfd_elf_add_dynamic_entry (info, 0x7ffffffd, indx))
  return 
# 7286 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 7286 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
     }
 }

      if (audit != 
# 7290 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 7290 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
 {
   size_t indx;

   indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, audit,
          
# 7295 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 7295 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             );
   if (indx == (size_t) -1
       || !_bfd_elf_add_dynamic_entry (info, 0x6ffffefc, indx))
     return 
# 7298 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7298 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (depaudit != 
# 7301 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 7301 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
 {
   size_t indx;

   indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, depaudit,
          
# 7306 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 7306 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             );
   if (indx == (size_t) -1
       || !_bfd_elf_add_dynamic_entry (info, 0x6ffffefb, indx))
     return 
# 7309 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7309 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      eif.info = info;
      eif.failed = 
# 7313 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  0
# 7313 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;



      elf_link_hash_traverse (elf_hash_table (info),
         _bfd_elf_adjust_dynamic_symbol,
         &eif);
      if (eif.failed)
 return 
# 7321 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 7321 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;







      h = (info->init_function
    ? elf_link_hash_lookup (elf_hash_table (info),
       info->init_function, 
# 7331 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           0
# 7331 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                ,
       
# 7332 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      0
# 7332 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           , 
# 7332 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 7332 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    : 
# 7333 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 7333 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
         );
      if (h != 
# 7334 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
   
# 7335 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && (h->ref_regular
       || h->def_regular))
 {
   if (!_bfd_elf_add_dynamic_entry (info, 12, 0))
     return 
# 7339 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7339 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
      h = (info->fini_function
    ? elf_link_hash_lookup (elf_hash_table (info),
       info->fini_function, 
# 7343 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           0
# 7343 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                ,
       
# 7344 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      0
# 7344 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           , 
# 7344 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 7344 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    : 
# 7345 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 7345 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
         );
      if (h != 
# 7346 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
   
# 7347 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && (h->ref_regular
       || h->def_regular))
 {
   if (!_bfd_elf_add_dynamic_entry (info, 13, 0))
     return 
# 7351 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7351 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      s = bfd_get_section_by_name (output_bfd, ".preinit_array");
      if (s != 
# 7355 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 7355 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   && s->linker_has_input)
 {

   if (! (((info)->type == type_pde) || ((info)->type == type_pie)))
     {
       bfd *sub;
       asection *o;

       for (sub = info->input_bfds; sub != 
# 7363 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 7363 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              ; sub = sub->link.next)
  if (bfd_get_flavour (sub) == bfd_target_elf_flavour
      && (o = sub->sections) != 
# 7365 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
      
# 7366 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && o->sec_info_type != 4)
    for (o = sub->sections; o != 
# 7367 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
# 7367 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    ; o = o->next)
      if (((struct bfd_elf_section_data*)(o)->used_by_bfd)->this_hdr.sh_type
   == 16)
        {
   _bfd_error_handler
     (dgettext ("bfd", "%pB: .preinit_array section is not allowed in DSO"),
      sub);
   break;
        }

       bfd_set_error (bfd_error_nonrepresentable_section);
       return 
# 7378 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 7378 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }

   if (!_bfd_elf_add_dynamic_entry (info, 32, 0)
       || !_bfd_elf_add_dynamic_entry (info, 33, 0))
     return 
# 7383 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7383 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
      s = bfd_get_section_by_name (output_bfd, ".init_array");
      if (s != 
# 7386 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 7386 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   && s->linker_has_input)
 {
   if (!_bfd_elf_add_dynamic_entry (info, 25, 0)
       || !_bfd_elf_add_dynamic_entry (info, 27, 0))
     return 
# 7390 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7390 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
      s = bfd_get_section_by_name (output_bfd, ".fini_array");
      if (s != 
# 7393 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 7393 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   && s->linker_has_input)
 {
   if (!_bfd_elf_add_dynamic_entry (info, 26, 0)
       || !_bfd_elf_add_dynamic_entry (info, 28, 0))
     return 
# 7397 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7397 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      dynstr = bfd_get_linker_section (dynobj, ".dynstr");




      if (dynstr != 
# 7405 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0) 
# 7405 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        && dynstr->output_section != (&_bfd_std_section[2]))
 {
   bfd_size_type strsize;

   strsize = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);
   if ((info->emit_hash
        && !_bfd_elf_add_dynamic_entry (info, 4, 0))
       || (info->emit_gnu_hash
    && (bed->record_xhash_symbol == 
# 7413 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
        
# 7414 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       && !_bfd_elf_add_dynamic_entry (info, 0x6ffffef5, 0)))
       || !_bfd_elf_add_dynamic_entry (info, 5, 0)
       || !_bfd_elf_add_dynamic_entry (info, 6, 0)
       || !_bfd_elf_add_dynamic_entry (info, 10, strsize)
       || !_bfd_elf_add_dynamic_entry (info, 11,
           bed->s->sizeof_sym)
       || (info->gnu_flags_1
    && !_bfd_elf_add_dynamic_entry (info, 0x6ffffdf4,
        info->gnu_flags_1)))
     return 
# 7423 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7423 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
    }

  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))
    return 
# 7428 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 7428 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



  if (dynobj != 
# 7432 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
      
# 7433 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && bed->elf_backend_size_dynamic_sections != 
# 7433 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                  ((void *)0)
      
# 7434 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && ! (*bed->elf_backend_size_dynamic_sections) (output_bfd, info))
    return 
# 7435 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 7435 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (dynobj != 
# 7437 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0) 
# 7437 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    && elf_hash_table (info)->dynamic_sections_created)
    {
      if (((output_bfd) -> tdata.elf_obj_data)->cverdefs)
 {
   unsigned int crefs = ((output_bfd) -> tdata.elf_obj_data)->cverdefs;

   if (!_bfd_elf_add_dynamic_entry (info, 0x6ffffffc, 0)
       || !_bfd_elf_add_dynamic_entry (info, 0x6ffffffd, crefs))
     return 
# 7445 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7445 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if ((info->new_dtags && info->flags) || (info->flags & (1 << 4)))
 {
   if (!_bfd_elf_add_dynamic_entry (info, 30, info->flags))
     return 
# 7451 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7451 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
      else if (info->flags & (1 << 3))
 {
   if (!_bfd_elf_add_dynamic_entry (info, 24, 0))
     return 
# 7456 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7456 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (info->flags_1)
 {
   if ((((info)->type == type_pde) || ((info)->type == type_pie)))
     info->flags_1 &= ~ (0x00000020
    | 0x00000008
    | 0x00000040);
   if (!_bfd_elf_add_dynamic_entry (info, 0x6ffffffb, info->flags_1))
     return 
# 7466 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7466 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (((output_bfd) -> tdata.elf_obj_data)->cverrefs)
 {
   unsigned int crefs = ((output_bfd) -> tdata.elf_obj_data)->cverrefs;

   if (!_bfd_elf_add_dynamic_entry (info, 0x6ffffffe, 0)
       || !_bfd_elf_add_dynamic_entry (info, 0x6fffffff, crefs))
     return 
# 7475 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7475 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if ((((output_bfd) -> tdata.elf_obj_data)->cverrefs == 0
    && ((output_bfd) -> tdata.elf_obj_data)->cverdefs == 0)
   || _bfd_elf_link_renumber_dynsyms (output_bfd, info, 
# 7480 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                       ((void *)0)
# 7480 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                           ) <= 1)
 {
   asection *s;

   s = bfd_get_linker_section (dynobj, ".gnu.version");
   s->flags |= 0x8000;
 }
    }
  return 
# 7488 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 7488 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



void
_bfd_elf_init_1_index_section (bfd *output_bfd, struct bfd_link_info *info)
{
  asection *s;
  asection *found = 
# 7497 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 7497 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;

  for (s = output_bfd->sections; s != 
# 7499 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 7499 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ; s = s->next)
    if ((s->flags & (0x8000 | 0x1)) == 0x1
 && !_bfd_elf_omit_section_dynsym_default (output_bfd, info, s))
      {
 found = s;
 if ((s->flags & 0x400) == 0)
   break;
      }
  elf_hash_table (info)->text_index_section = found;
}



void
_bfd_elf_init_2_index_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  asection *s;
  asection *found = 
# 7516 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 7516 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;



  for (s = output_bfd->sections; s != 
# 7520 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 7520 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ; s = s->next)
    if ((s->flags & (0x8000 | 0x1)) == 0x1
 && !(s->flags & 0x8)
 && !_bfd_elf_omit_section_dynsym_default (output_bfd, info, s))
      {
 found = s;
 if ((s->flags & 0x400) == 0)
   break;
      }
  elf_hash_table (info)->data_index_section = found;

  for (s = output_bfd->sections; s != 
# 7531 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 7531 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ; s = s->next)
    if ((s->flags & (0x8000 | 0x1)) == 0x1
 && (s->flags & 0x8)
 && !_bfd_elf_omit_section_dynsym_default (output_bfd, info, s))
      {
 found = s;
 break;
      }
  elf_hash_table (info)->text_index_section = found;
}





# 7545 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 7546 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
{
  const struct elf_backend_data *bed;
  unsigned long section_sym_count;
  bfd_size_type dynsymcount = 0;

  if (!is_elf_hash_table (info->hash))
    return 
# 7553 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 7553 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  bed = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);
  (*bed->elf_backend_init_index_section) (output_bfd, info);
# 7569 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if (elf_hash_table (info)->dynamic_sections_created
      || bed->always_renumber_dynsyms)
    dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info,
        &section_sym_count);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      bfd *dynobj;
      asection *s;
      unsigned int dtagcount;

      dynobj = elf_hash_table (info)->dynobj;


      s = bfd_get_linker_section (dynobj, ".gnu.version");
      do { if (!(s != 
# 7584 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 7584 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7584); } while (0);
      if ((s->flags & 0x8000) == 0)
 {
   s->size = dynsymcount * sizeof (Elf_External_Versym);
   s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
   if (s->contents == 
# 7589 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 7589 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
     return 
# 7590 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7590 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   if (!_bfd_elf_add_dynamic_entry (info, 0x6ffffff0, 0))
     return 
# 7593 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7593 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }







      s = elf_hash_table (info)->dynsym;
      do { if (!(s != 
# 7603 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 7603 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7603); } while (0);
      s->size = dynsymcount * bed->s->sizeof_sym;

      s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);
      if (s->contents == 
# 7607 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0)
# 7607 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                            )
 return 
# 7608 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 7608 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;



      ++section_sym_count;
      memset (s->contents, 0, section_sym_count * bed->s->sizeof_sym);

      elf_hash_table (info)->bucketcount = 0;



      if (info->emit_hash)
 {
   unsigned long int *hashcodes;
   struct hash_codes_info hashinf;
   bfd_size_type amt;
   unsigned long int nsyms;
   size_t bucketcount;
   size_t hash_entry_size;




   amt = dynsymcount * sizeof (unsigned long int);
   hashcodes = (unsigned long int *) bfd_malloc (amt);
   if (hashcodes == 
# 7633 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 7633 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
     return 
# 7634 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7634 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   hashinf.hashcodes = hashcodes;
   hashinf.error = 
# 7636 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  0
# 7636 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;


   elf_link_hash_traverse (elf_hash_table (info),
      elf_collect_hash_codes, &hashinf);
   if (hashinf.error)
     {
       free (hashcodes);
       return 
# 7644 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 7644 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }

   nsyms = hashinf.hashcodes - hashcodes;
   bucketcount
     = compute_bucket_count (info, hashcodes, nsyms, 0);
   free (hashcodes);

   if (bucketcount == 0 && nsyms > 0)
     return 
# 7653 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7653 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   elf_hash_table (info)->bucketcount = bucketcount;

   s = bfd_get_linker_section (dynobj, ".hash");
   do { if (!(s != 
# 7658 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  ((void *)0)
# 7658 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7658); } while (0);
   hash_entry_size = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize;
   s->size = ((2 + bucketcount + dynsymcount) * hash_entry_size);
   s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
   if (s->contents == 
# 7662 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 7662 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
     return 
# 7663 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7663 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   ((8 * hash_entry_size) == 8 ? ((void) (*((bfd_byte *) (s->contents)) = (bucketcount) & 0xff)) : (8 * hash_entry_size) == 16 ? ((*((output_bfd)->xvec->bfd_putx16)) ((bucketcount),(s->contents))) : (8 * hash_entry_size) == 32 ? ((*((output_bfd)->xvec->bfd_putx32)) ((bucketcount),(s->contents))) : (8 * hash_entry_size) == 64 ? ((*((output_bfd)->xvec->bfd_putx64)) ((bucketcount), (s->contents))) : (_bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 7665, __PRETTY_FUNCTION__), (void) 0));
   ((8 * hash_entry_size) == 8 ? ((void) (*((bfd_byte *) (s->contents + hash_entry_size)) = (dynsymcount) & 0xff)) : (8 * hash_entry_size) == 16 ? ((*((output_bfd)->xvec->bfd_putx16)) ((dynsymcount),(s->contents + hash_entry_size))) : (8 * hash_entry_size) == 32 ? ((*((output_bfd)->xvec->bfd_putx32)) ((dynsymcount),(s->contents + hash_entry_size))) : (8 * hash_entry_size) == 64 ? ((*((output_bfd)->xvec->bfd_putx64)) ((dynsymcount), (s->contents + hash_entry_size))) : (_bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 7666, __PRETTY_FUNCTION__), (void) 0))
                                   ;
 }

      if (info->emit_gnu_hash)
 {
   size_t i, cnt;
   unsigned char *contents;
   struct collect_gnu_hash_codes cinfo;
   bfd_size_type amt;
   size_t bucketcount;

   memset (&cinfo, 0, sizeof (cinfo));




   amt = dynsymcount * 2 * sizeof (unsigned long int);
   cinfo.hashcodes = (long unsigned int *) bfd_malloc (amt);
   if (cinfo.hashcodes == 
# 7685 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 7685 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
     return 
# 7686 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 7686 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   cinfo.hashval = cinfo.hashcodes + dynsymcount;
   cinfo.min_dynindx = -1;
   cinfo.output_bfd = output_bfd;
   cinfo.bed = bed;


   elf_link_hash_traverse (elf_hash_table (info),
      elf_collect_gnu_hash_codes, &cinfo);
   if (cinfo.error)
     {
       free (cinfo.hashcodes);
       return 
# 7699 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 7699 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }

   bucketcount
     = compute_bucket_count (info, cinfo.hashcodes, cinfo.nsyms, 1);

   if (bucketcount == 0)
     {
       free (cinfo.hashcodes);
       return 
# 7708 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 7708 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }

   s = bfd_get_linker_section (dynobj, (bed)->record_xhash_symbol != 
# 7711 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0) 
# 7711 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ? ".MIPS.xhash" : ".gnu.hash");
   do { if (!(s != 
# 7712 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  ((void *)0)
# 7712 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7712); } while (0);

   if (cinfo.nsyms == 0)
     {

       do { if (!(cinfo.min_dynindx == -1)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7717); } while (0);
       free (cinfo.hashcodes);
       s->size = 5 * 4 + bed->s->arch_size / 8;
       contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
       if (contents == 
# 7721 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 7721 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          )
  return 
# 7722 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 7722 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
       s->contents = contents;

       ((*((output_bfd)->xvec->bfd_putx32)) ((1),(contents)));

       ((*((output_bfd)->xvec->bfd_putx32)) ((1),(contents + 4)));

       ((*((output_bfd)->xvec->bfd_putx32)) ((1),(contents + 8)));

       ((*((output_bfd)->xvec->bfd_putx32)) ((0),(contents + 12)));

       ((bed->s->arch_size) == 8 ? ((void) (*((bfd_byte *) (contents + 16)) = (0) & 0xff)) : (bed->s->arch_size) == 16 ? ((*((output_bfd)->xvec->bfd_putx16)) ((0),(contents + 16))) : (bed->s->arch_size) == 32 ? ((*((output_bfd)->xvec->bfd_putx32)) ((0),(contents + 16))) : (bed->s->arch_size) == 64 ? ((*((output_bfd)->xvec->bfd_putx64)) ((0), (contents + 16))) : (_bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 7733, __PRETTY_FUNCTION__), (void) 0));

       ((*((output_bfd)->xvec->bfd_putx32)) ((0),(contents + 16 + bed->s->arch_size / 8)))
                                           ;
     }
   else
     {
       unsigned long int maskwords, maskbitslog2, x;
       do { if (!(cinfo.min_dynindx != -1)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7741); } while (0);

       x = cinfo.nsyms;
       maskbitslog2 = 1;
       while ((x >>= 1) != 0)
  ++maskbitslog2;
       if (maskbitslog2 < 3)
  maskbitslog2 = 5;
       else if ((1 << (maskbitslog2 - 2)) & cinfo.nsyms)
  maskbitslog2 = maskbitslog2 + 3;
       else
  maskbitslog2 = maskbitslog2 + 2;
       if (bed->s->arch_size == 64)
  {
    if (maskbitslog2 == 5)
      maskbitslog2 = 6;
    cinfo.shift1 = 6;
  }
       else
  cinfo.shift1 = 5;
       cinfo.mask = (1 << cinfo.shift1) - 1;
       cinfo.shift2 = maskbitslog2;
       cinfo.maskbits = 1 << maskbitslog2;
       maskwords = 1 << (maskbitslog2 - cinfo.shift1);
       amt = bucketcount * sizeof (unsigned long int) * 2;
       amt += maskwords * sizeof (bfd_vma);
       cinfo.bitmask = (bfd_vma *) bfd_malloc (amt);
       if (cinfo.bitmask == 
# 7768 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 7768 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
  {
    free (cinfo.hashcodes);
    return 
# 7771 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 7771 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  }

       cinfo.counts = (long unsigned int *) (cinfo.bitmask + maskwords);
       cinfo.indx = cinfo.counts + bucketcount;
       cinfo.symindx = dynsymcount - cinfo.nsyms;
       memset (cinfo.bitmask, 0, maskwords * sizeof (bfd_vma));


       memset (cinfo.counts, 0, bucketcount * sizeof (cinfo.counts[0]));
       for (i = 0; i < cinfo.nsyms; ++i)
  ++cinfo.counts[cinfo.hashcodes[i] % bucketcount];

       for (i = 0, cnt = cinfo.symindx; i < bucketcount; ++i)
  if (cinfo.counts[i] != 0)
    {
      cinfo.indx[i] = cnt;
      cnt += cinfo.counts[i];
    }
       do { if (!(cnt == dynsymcount)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7790); } while (0);
       cinfo.bucketcount = bucketcount;
       cinfo.local_indx = cinfo.min_dynindx;

       s->size = (4 + bucketcount + cinfo.nsyms) * 4;
       s->size += cinfo.maskbits / 8;
       if (bed->record_xhash_symbol != 
# 7796 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
# 7796 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          )
  s->size += cinfo.nsyms * 4;
       contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);
       if (contents == 
# 7799 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 7799 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          )
  {
    free (cinfo.bitmask);
    free (cinfo.hashcodes);
    return 
# 7803 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 7803 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  }

       s->contents = contents;
       ((*((output_bfd)->xvec->bfd_putx32)) ((bucketcount),(contents)));
       ((*((output_bfd)->xvec->bfd_putx32)) ((cinfo.symindx),(contents + 4)));
       ((*((output_bfd)->xvec->bfd_putx32)) ((maskwords),(contents + 8)));
       ((*((output_bfd)->xvec->bfd_putx32)) ((cinfo.shift2),(contents + 12)));
       contents += 16 + cinfo.maskbits / 8;

       for (i = 0; i < bucketcount; ++i)
  {
    if (cinfo.counts[i] == 0)
      ((*((output_bfd)->xvec->bfd_putx32)) ((0),(contents)));
    else
      ((*((output_bfd)->xvec->bfd_putx32)) ((cinfo.indx[i]),(contents)));
    contents += 4;
  }

       cinfo.contents = contents;

       cinfo.xlat = contents + cinfo.nsyms * 4 - s->contents;


       elf_link_hash_traverse (elf_hash_table (info),
          elf_gnu_hash_process_symidx, &cinfo);

       contents = s->contents + 16;
       for (i = 0; i < maskwords; ++i)
  {
    ((bed->s->arch_size) == 8 ? ((void) (*((bfd_byte *) (contents)) = (cinfo.bitmask[i]) & 0xff)) : (bed->s->arch_size) == 16 ? ((*((output_bfd)->xvec->bfd_putx16)) ((cinfo.bitmask[i]),(contents))) : (bed->s->arch_size) == 32 ? ((*((output_bfd)->xvec->bfd_putx32)) ((cinfo.bitmask[i]),(contents))) : (bed->s->arch_size) == 64 ? ((*((output_bfd)->xvec->bfd_putx64)) ((cinfo.bitmask[i]), (contents))) : (_bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 7833, __PRETTY_FUNCTION__), (void) 0))
               ;
    contents += bed->s->arch_size / 8;
  }

       free (cinfo.bitmask);
       free (cinfo.hashcodes);
     }
 }

      s = bfd_get_linker_section (dynobj, ".dynstr");
      do { if (!(s != 
# 7844 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 7844 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7844); } while (0);

      elf_finalize_dynstr (output_bfd, info);

      s->size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);

      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)
 if (!_bfd_elf_add_dynamic_entry (info, 0, 0))
   return 
# 7852 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 7852 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
    }

  return 
# 7855 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 7855 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



static void
merge_sections_remove_hook (bfd *abfd __attribute__ ((__unused__)),
       asection *sec)
{
  do { if (!(sec->sec_info_type == 2)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",7864); } while (0);
  sec->sec_info_type = 0;
}




# 7870 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 7871 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_merge_sections (bfd *obfd, struct bfd_link_info *info)
{
  bfd *ibfd;
  asection *sec;

  if (!is_elf_hash_table (info->hash))
    return 
# 7877 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 7877 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  for (ibfd = info->input_bfds; ibfd != 
# 7879 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 7879 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           ; ibfd = ibfd->link.next)
    if ((ibfd->flags & 0x40) == 0
 && bfd_get_flavour (ibfd) == bfd_target_elf_flavour
 && ((((ibfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[4]
     == ((const struct elf_backend_data *) ((obfd)->xvec)->backend_data)->s->elfclass))
      for (sec = ibfd->sections; sec != 
# 7884 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 7884 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           ; sec = sec->next)
 if ((sec->flags & 0x800000) != 0
     && !bfd_is_abs_section (sec->output_section))
   {
     struct bfd_elf_section_data *secdata;

     secdata = ((struct bfd_elf_section_data*)(sec)->used_by_bfd);
     if (! _bfd_add_merge_section (obfd,
       &elf_hash_table (info)->merge_info,
       sec, &secdata->sec_info))
       return 
# 7894 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 7894 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     else if (secdata->sec_info)
       sec->sec_info_type = 2;
   }

  if (elf_hash_table (info)->merge_info != 
# 7899 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 7899 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              )
    _bfd_merge_sections (obfd, info, elf_hash_table (info)->merge_info,
    merge_sections_remove_hook);
  return 
# 7902 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 7902 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



struct bfd_hash_entry *
_bfd_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
       struct bfd_hash_table *table,
       const char *string)
{


  if (entry == 
# 7914 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 7914 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    {
      entry = (struct bfd_hash_entry *)
 bfd_hash_allocate (table, sizeof (struct elf_link_hash_entry));
      if (entry == 
# 7918 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 7918 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
 return entry;
    }


  entry = _bfd_link_hash_newfunc (entry, table, string);
  if (entry != 
# 7924 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 7924 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    {
      struct elf_link_hash_entry *ret = (struct elf_link_hash_entry *) entry;
      struct elf_link_hash_table *htab = (struct elf_link_hash_table *) table;


      ret->indx = -1;
      ret->dynindx = -1;
      ret->got = htab->init_got_refcount;
      ret->plt = htab->init_plt_refcount;
      memset (&ret->size, 0, (sizeof (struct elf_link_hash_entry)
         - 
# 7935 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          __builtin_offsetof (
# 7935 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          struct elf_link_hash_entry
# 7935 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          , 
# 7935 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          size
# 7935 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          )
# 7935 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                     ));




      ret->non_elf = 1;
    }

  return entry;
}




void
_bfd_elf_link_hash_copy_indirect (struct bfd_link_info *info,
      struct elf_link_hash_entry *dir,
      struct elf_link_hash_entry *ind)
{
  struct elf_link_hash_table *htab;

  if (ind->dyn_relocs != 
# 7956 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0)
# 7956 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                            )
    {
      if (dir->dyn_relocs != 
# 7958 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 7958 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
 {
   struct elf_dyn_relocs **pp;
   struct elf_dyn_relocs *p;



   for (pp = &ind->dyn_relocs; (p = *pp) != 
# 7965 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 7965 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               ; )
     {
       struct elf_dyn_relocs *q;

       for (q = dir->dyn_relocs; q != 
# 7969 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 7969 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ; q = q->next)
  if (q->sec == p->sec)
    {
      q->pc_count += p->pc_count;
      q->count += p->count;
      *pp = p->next;
      break;
    }
       if (q == 
# 7977 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 7977 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
  pp = &p->next;
     }
   *pp = dir->dyn_relocs;
 }

      dir->dyn_relocs = ind->dyn_relocs;
      ind->dyn_relocs = 
# 7984 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       ((void *)0)
# 7984 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
    }




  if (dir->versioned != versioned_hidden)
    dir->ref_dynamic |= ind->ref_dynamic;
  dir->ref_regular |= ind->ref_regular;
  dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
  dir->non_got_ref |= ind->non_got_ref;
  dir->needs_plt |= ind->needs_plt;
  dir->pointer_equality_needed |= ind->pointer_equality_needed;

  if (ind->root.type != bfd_link_hash_indirect)
    return;



  htab = elf_hash_table (info);
  if (ind->got.refcount > htab->init_got_refcount.refcount)
    {
      if (dir->got.refcount < 0)
 dir->got.refcount = 0;
      dir->got.refcount += ind->got.refcount;
      ind->got.refcount = htab->init_got_refcount.refcount;
    }

  if (ind->plt.refcount > htab->init_plt_refcount.refcount)
    {
      if (dir->plt.refcount < 0)
 dir->plt.refcount = 0;
      dir->plt.refcount += ind->plt.refcount;
      ind->plt.refcount = htab->init_plt_refcount.refcount;
    }

  if (ind->dynindx != -1)
    {
      if (dir->dynindx != -1)
 _bfd_elf_strtab_delref (htab->dynstr, dir->dynstr_index);
      dir->dynindx = ind->dynindx;
      dir->dynstr_index = ind->dynstr_index;
      ind->dynindx = -1;
      ind->dynstr_index = 0;
    }
}

void
_bfd_elf_link_hash_hide_symbol (struct bfd_link_info *info,
    struct elf_link_hash_entry *h,
    
# 8034 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
   _Bool 
# 8034 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        force_local)
{

  if (h->type != 10)
    {
      h->plt = elf_hash_table (info)->init_plt_offset;
      h->needs_plt = 0;
    }
  if (force_local)
    {
      h->forced_local = 1;
      if (h->dynindx != -1)
 {
   _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
      h->dynstr_index);
   h->dynindx = -1;
   h->dynstr_index = 0;
 }
    }
}



void
_bfd_elf_link_hide_symbol (bfd *output_bfd,
      struct bfd_link_info *info,
      struct bfd_link_hash_entry *h)
{
  if (is_elf_hash_table (info->hash))
    {
      const struct elf_backend_data *bed
 = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);
      struct elf_link_hash_entry *eh
 = (struct elf_link_hash_entry *) h;
      bed->elf_backend_hide_symbol (info, eh, 
# 8068 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             1
# 8068 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                 );
      eh->def_dynamic = 0;
      eh->ref_dynamic = 0;
      eh->dynamic_def = 0;
    }
}





# 8078 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 8079 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *table,
   bfd *abfd,
   struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int entsize,
   enum elf_target_id target_id)
{
  
# 8088 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 8088 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ret;
  int can_refcount = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->can_refcount;

  table->init_got_refcount.refcount = can_refcount - 1;
  table->init_plt_refcount.refcount = can_refcount - 1;
  table->init_got_offset.offset = -(bfd_vma) 1;
  table->init_plt_offset.offset = -(bfd_vma) 1;

  table->dynsymcount = 1;

  ret = _bfd_link_hash_table_init (&table->root, abfd, newfunc, entsize);

  table->root.type = bfd_link_elf_hash_table;
  table->hash_table_id = target_id;
  table->target_os = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->target_os;

  return ret;
}



struct bfd_link_hash_table *
_bfd_elf_link_hash_table_create (bfd *abfd)
{
  struct elf_link_hash_table *ret;
  size_t amt = sizeof (struct elf_link_hash_table);

  ret = (struct elf_link_hash_table *) bfd_zmalloc (amt);
  if (ret == 
# 8116 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 8116 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                )
    return 
# 8117 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 8117 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  if (! _bfd_elf_link_hash_table_init (ret, abfd, _bfd_elf_link_hash_newfunc,
           sizeof (struct elf_link_hash_entry),
           GENERIC_ELF_DATA))
    {
      free (ret);
      return 
# 8124 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 8124 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }
  ret->root.hash_table_free = _bfd_elf_link_hash_table_free;

  return &ret->root;
}



void
_bfd_elf_link_hash_table_free (bfd *obfd)
{
  struct elf_link_hash_table *htab;

  htab = (struct elf_link_hash_table *) obfd->link.hash;
  if (htab->dynstr != 
# 8139 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 8139 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
    _bfd_elf_strtab_free (htab->dynstr);
  _bfd_merge_sections_free (htab->merge_info);
  _bfd_generic_link_hash_table_free (obfd);
}





void
bfd_elf_set_dt_needed_name (bfd *abfd, const char *name)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    (((abfd) -> tdata.elf_obj_data) -> dt_name) = name;
}

int
bfd_elf_get_dyn_lib_class (bfd *abfd)
{
  int lib_class;
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    lib_class = (((abfd) -> tdata.elf_obj_data) -> dyn_lib_class);
  else
    lib_class = 0;
  return lib_class;
}

void
bfd_elf_set_dyn_lib_class (bfd *abfd, enum dynamic_lib_link_class lib_class)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    (((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) = lib_class;
}




struct bfd_link_needed_list *
bfd_elf_get_needed_list (bfd *abfd __attribute__ ((__unused__)),
    struct bfd_link_info *info)
{
  if (! is_elf_hash_table (info->hash))
    return 
# 8185 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 8185 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  return elf_hash_table (info)->needed;
}




struct bfd_link_needed_list *
bfd_elf_get_runpath_list (bfd *abfd __attribute__ ((__unused__)),
     struct bfd_link_info *info)
{
  if (! is_elf_hash_table (info->hash))
    return 
# 8197 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 8197 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  return elf_hash_table (info)->runpath;
}





const char *
bfd_elf_get_dt_soname (bfd *abfd)
{
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && bfd_get_format (abfd) == bfd_object)
    return (((abfd) -> tdata.elf_obj_data) -> dt_name);
  return 
# 8211 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 8211 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





# 8217 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 8218 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_get_bfd_needed_list (bfd *abfd,
        struct bfd_link_needed_list **pneeded)
{
  asection *s;
  bfd_byte *dynbuf = 
# 8222 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 8222 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
  unsigned int elfsec;
  unsigned long shlink;
  bfd_byte *extdyn, *extdynend;
  size_t extdynsize;
  void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);

  *pneeded = 
# 8229 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 8229 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour
      || bfd_get_format (abfd) != bfd_object)
    return 
# 8233 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 8233 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s == 
# 8236 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0) 
# 8236 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               || s->size == 0 || (s->flags & 0x100) == 0)
    return 
# 8237 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 8237 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
    goto error_return;

  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
  if (elfsec == (-0x101u))
    goto error_return;

  shlink = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[elfsec]->sh_link;

  extdynsize = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->s->sizeof_dyn;
  swap_dyn_in = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->s->swap_dyn_in;

  for (extdyn = dynbuf, extdynend = dynbuf + s->size;
       (size_t) (extdynend - extdyn) >= extdynsize;
       extdyn += extdynsize)
    {
      Elf_Internal_Dyn dyn;

      (*swap_dyn_in) (abfd, extdyn, &dyn);

      if (dyn.d_tag == 0)
 break;

      if (dyn.d_tag == 1)
 {
   const char *string;
   struct bfd_link_needed_list *l;
   unsigned int tagv = dyn.d_un.d_val;
   size_t amt;

   string = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
   if (string == 
# 8270 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 8270 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
     goto error_return;

   amt = sizeof *l;
   l = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);
   if (l == 
# 8275 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 8275 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               )
     goto error_return;

   l->by = abfd;
   l->name = string;
   l->next = *pneeded;
   *pneeded = l;
 }
    }

  free (dynbuf);

  return 
# 8287 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 8287 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

 error_return:
  free (dynbuf);
  return 
# 8291 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 8291 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}

struct elf_symbuf_symbol
{
  unsigned long st_name;
  unsigned char st_info;
  unsigned char st_other;
};

struct elf_symbuf_head
{
  struct elf_symbuf_symbol *ssym;
  size_t count;
  unsigned int st_shndx;
};

struct elf_symbol
{
  union
    {
      Elf_Internal_Sym *isym;
      struct elf_symbuf_symbol *ssym;
      void *p;
    } u;
  const char *name;
};



static int
elf_sort_elf_symbol (const void *arg1, const void *arg2)
{
  const Elf_Internal_Sym *s1 = *(const Elf_Internal_Sym **) arg1;
  const Elf_Internal_Sym *s2 = *(const Elf_Internal_Sym **) arg2;

  if (s1->st_shndx != s2->st_shndx)
    return s1->st_shndx > s2->st_shndx ? 1 : -1;


  if (s1 != s2)
    return s1 > s2 ? 1 : -1;
  return 0;
}

static int
elf_sym_name_compare (const void *arg1, const void *arg2)
{
  const struct elf_symbol *s1 = (const struct elf_symbol *) arg1;
  const struct elf_symbol *s2 = (const struct elf_symbol *) arg2;
  int ret = strcmp (s1->name, s2->name);
  if (ret != 0)
    return ret;
  if (s1->u.p != s2->u.p)
    return s1->u.p > s2->u.p ? 1 : -1;
  return 0;
}

static struct elf_symbuf_head *
elf_create_symbuf (size_t symcount, Elf_Internal_Sym *isymbuf)
{
  Elf_Internal_Sym **ind, **indbufend, **indbuf;
  struct elf_symbuf_symbol *ssym;
  struct elf_symbuf_head *ssymbuf, *ssymhead;
  size_t i, shndx_count, total_size, amt;

  amt = symcount * sizeof (*indbuf);
  indbuf = (Elf_Internal_Sym **) bfd_malloc (amt);
  if (indbuf == 
# 8359 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 8359 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
    return 
# 8360 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 8360 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  for (ind = indbuf, i = 0; i < symcount; i++)
    if (isymbuf[i].st_shndx != 0)
      *ind++ = &isymbuf[i];
  indbufend = ind;

  qsort (indbuf, indbufend - indbuf, sizeof (Elf_Internal_Sym *),
  elf_sort_elf_symbol);

  shndx_count = 0;
  if (indbufend > indbuf)
    for (ind = indbuf, shndx_count++; ind < indbufend - 1; ind++)
      if (ind[0]->st_shndx != ind[1]->st_shndx)
 shndx_count++;

  total_size = ((shndx_count + 1) * sizeof (*ssymbuf)
  + (indbufend - indbuf) * sizeof (*ssym));
  ssymbuf = (struct elf_symbuf_head *) bfd_malloc (total_size);
  if (ssymbuf == 
# 8379 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 8379 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
    {
      free (indbuf);
      return 
# 8382 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 8382 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }

  ssym = (struct elf_symbuf_symbol *) (ssymbuf + shndx_count + 1);
  ssymbuf->ssym = 
# 8386 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 8386 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ;
  ssymbuf->count = shndx_count;
  ssymbuf->st_shndx = 0;
  for (ssymhead = ssymbuf, ind = indbuf; ind < indbufend; ssym++, ind++)
    {
      if (ind == indbuf || ssymhead->st_shndx != (*ind)->st_shndx)
 {
   ssymhead++;
   ssymhead->ssym = ssym;
   ssymhead->count = 0;
   ssymhead->st_shndx = (*ind)->st_shndx;
 }
      ssym->st_name = (*ind)->st_name;
      ssym->st_info = (*ind)->st_info;
      ssym->st_other = (*ind)->st_other;
      ssymhead->count++;
    }
  do { if (!((size_t) (ssymhead - ssymbuf) == shndx_count && (uintptr_t) ssym - (uintptr_t) ssymbuf == total_size)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",8403); } while (0)
                                                               ;

  free (indbuf);
  return ssymbuf;
}




static 
# 8413 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 8414 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_match_symbols_in_sections (asection *sec1, asection *sec2,
       struct bfd_link_info *info)
{
  bfd *bfd1, *bfd2;
  const struct elf_backend_data *bed1, *bed2;
  Elf_Internal_Shdr *hdr1, *hdr2;
  size_t symcount1, symcount2;
  Elf_Internal_Sym *isymbuf1, *isymbuf2;
  struct elf_symbuf_head *ssymbuf1, *ssymbuf2;
  Elf_Internal_Sym *isym, *isymend;
  struct elf_symbol *symtable1 = 
# 8424 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
# 8424 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    , *symtable2 = 
# 8424 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                   ((void *)0)
# 8424 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                       ;
  size_t count1, count2, sec_count1, sec_count2, i;
  unsigned int shndx1, shndx2;
  
# 8427 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 8427 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      result;
  
# 8428 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 8428 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ignore_section_symbol_p;

  bfd1 = sec1->owner;
  bfd2 = sec2->owner;


  if (bfd_get_flavour (bfd1) != bfd_target_elf_flavour
      || bfd_get_flavour (bfd2) != bfd_target_elf_flavour)
    return 
# 8436 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 8436 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if ((((struct bfd_elf_section_data*)(sec1)->used_by_bfd)->this_hdr.sh_type) != (((struct bfd_elf_section_data*)(sec2)->used_by_bfd)->this_hdr.sh_type))
    return 
# 8439 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 8439 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  shndx1 = _bfd_elf_section_from_bfd_section (bfd1, sec1);
  shndx2 = _bfd_elf_section_from_bfd_section (bfd2, sec2);
  if (shndx1 == (-0x101u) || shndx2 == (-0x101u))
    return 
# 8444 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 8444 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  bed1 = ((const struct elf_backend_data *) ((bfd1)->xvec)->backend_data);
  bed2 = ((const struct elf_backend_data *) ((bfd2)->xvec)->backend_data);
  hdr1 = &((bfd1) -> tdata.elf_obj_data)->symtab_hdr;
  symcount1 = hdr1->sh_size / bed1->s->sizeof_sym;
  hdr2 = &((bfd2) -> tdata.elf_obj_data)->symtab_hdr;
  symcount2 = hdr2->sh_size / bed2->s->sizeof_sym;

  if (symcount1 == 0 || symcount2 == 0)
    return 
# 8454 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 8454 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  result = 
# 8456 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 8456 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  isymbuf1 = 
# 8457 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 8457 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
  isymbuf2 = 
# 8458 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 8458 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
  ssymbuf1 = (struct elf_symbuf_head *) ((bfd1) -> tdata.elf_obj_data)->symbuf;
  ssymbuf2 = (struct elf_symbuf_head *) ((bfd2) -> tdata.elf_obj_data)->symbuf;



  ignore_section_symbol_p
    = ((sec1->flags & 0x2000) == 0
       || (((((struct bfd_elf_section_data*)(sec1)->used_by_bfd)->this_hdr.sh_flags) & (1 << 9))
    != ((((struct bfd_elf_section_data*)(sec2)->used_by_bfd)->this_hdr.sh_flags) & (1 << 9))));

  if (ssymbuf1 == 
# 8469 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 8469 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
    {
      isymbuf1 = bfd_elf_get_elf_syms (bfd1, hdr1, symcount1, 0,
           
# 8472 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 8472 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              , 
# 8472 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 8472 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    , 
# 8472 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 8472 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          );
      if (isymbuf1 == 
# 8473 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 8473 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
 goto done;

      if (info != 
# 8476 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0) 
# 8476 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      && !info->reduce_memory_overheads)
 {
   ssymbuf1 = elf_create_symbuf (symcount1, isymbuf1);
   ((bfd1) -> tdata.elf_obj_data)->symbuf = ssymbuf1;
 }
    }

  if (ssymbuf1 == 
# 8483 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0) 
# 8483 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      || ssymbuf2 == 
# 8483 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 8483 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         )
    {
      isymbuf2 = bfd_elf_get_elf_syms (bfd2, hdr2, symcount2, 0,
           
# 8486 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 8486 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              , 
# 8486 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 8486 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    , 
# 8486 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 8486 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          );
      if (isymbuf2 == 
# 8487 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 8487 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
 goto done;

      if (ssymbuf1 != 
# 8490 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0) 
# 8490 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          && info != 
# 8490 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0) 
# 8490 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          && !info->reduce_memory_overheads)
 {
   ssymbuf2 = elf_create_symbuf (symcount2, isymbuf2);
   ((bfd2) -> tdata.elf_obj_data)->symbuf = ssymbuf2;
 }
    }

  if (ssymbuf1 != 
# 8497 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0) 
# 8497 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      && ssymbuf2 != 
# 8497 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 8497 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         )
    {

      size_t lo, hi, mid;
      struct elf_symbol *symp;
      struct elf_symbuf_symbol *ssym, *ssymend;

      lo = 0;
      hi = ssymbuf1->count;
      ssymbuf1++;
      count1 = 0;
      sec_count1 = 0;
      while (lo < hi)
 {
   mid = (lo + hi) / 2;
   if (shndx1 < ssymbuf1[mid].st_shndx)
     hi = mid;
   else if (shndx1 > ssymbuf1[mid].st_shndx)
     lo = mid + 1;
   else
     {
       count1 = ssymbuf1[mid].count;
       ssymbuf1 += mid;
       break;
     }
 }
      if (ignore_section_symbol_p)
 {
   for (i = 0; i < count1; i++)
     if (((ssymbuf1->ssym[i].st_info) & 0xF) == 3)
       sec_count1++;
   count1 -= sec_count1;
 }

      lo = 0;
      hi = ssymbuf2->count;
      ssymbuf2++;
      count2 = 0;
      sec_count2 = 0;
      while (lo < hi)
 {
   mid = (lo + hi) / 2;
   if (shndx2 < ssymbuf2[mid].st_shndx)
     hi = mid;
   else if (shndx2 > ssymbuf2[mid].st_shndx)
     lo = mid + 1;
   else
     {
       count2 = ssymbuf2[mid].count;
       ssymbuf2 += mid;
       break;
     }
 }
      if (ignore_section_symbol_p)
 {
   for (i = 0; i < count2; i++)
     if (((ssymbuf2->ssym[i].st_info) & 0xF) == 3)
       sec_count2++;
   count2 -= sec_count2;
 }

      if (count1 == 0 || count2 == 0 || count1 != count2)
 goto done;

      symtable1
 = (struct elf_symbol *) bfd_malloc (count1 * sizeof (*symtable1));
      symtable2
 = (struct elf_symbol *) bfd_malloc (count2 * sizeof (*symtable2));
      if (symtable1 == 
# 8565 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0) 
# 8565 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           || symtable2 == 
# 8565 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 8565 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               )
 goto done;

      symp = symtable1;
      for (ssym = ssymbuf1->ssym, ssymend = ssym + count1 + sec_count1;
    ssym < ssymend; ssym++)
 if (sec_count1 == 0
     || ((ssym->st_info) & 0xF) != 3)
   {
     symp->u.ssym = ssym;
     symp->name = bfd_elf_string_from_elf_section (bfd1,
         hdr1->sh_link,
         ssym->st_name);
     symp++;
   }

      symp = symtable2;
      for (ssym = ssymbuf2->ssym, ssymend = ssym + count2 + sec_count2;
    ssym < ssymend; ssym++)
 if (sec_count2 == 0
     || ((ssym->st_info) & 0xF) != 3)
   {
     symp->u.ssym = ssym;
     symp->name = bfd_elf_string_from_elf_section (bfd2,
         hdr2->sh_link,
         ssym->st_name);
     symp++;
   }


      qsort (symtable1, count1, sizeof (struct elf_symbol),
      elf_sym_name_compare);
      qsort (symtable2, count1, sizeof (struct elf_symbol),
      elf_sym_name_compare);

      for (i = 0; i < count1; i++)

 if (symtable1 [i].u.ssym->st_info != symtable2 [i].u.ssym->st_info
     || symtable1 [i].u.ssym->st_other != symtable2 [i].u.ssym->st_other
     || strcmp (symtable1 [i].name, symtable2 [i].name) != 0)
   goto done;

      result = 
# 8607 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              1
# 8607 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
      goto done;
    }

  symtable1 = (struct elf_symbol *)
      bfd_malloc (symcount1 * sizeof (struct elf_symbol));
  symtable2 = (struct elf_symbol *)
      bfd_malloc (symcount2 * sizeof (struct elf_symbol));
  if (symtable1 == 
# 8615 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0) 
# 8615 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       || symtable2 == 
# 8615 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 8615 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           )
    goto done;


  count1 = 0;
  for (isym = isymbuf1, isymend = isym + symcount1; isym < isymend; isym++)
    if (isym->st_shndx == shndx1
 && (!ignore_section_symbol_p
     || ((isym->st_info) & 0xF) != 3))
      symtable1[count1++].u.isym = isym;

  count2 = 0;
  for (isym = isymbuf2, isymend = isym + symcount2; isym < isymend; isym++)
    if (isym->st_shndx == shndx2
 && (!ignore_section_symbol_p
     || ((isym->st_info) & 0xF) != 3))
      symtable2[count2++].u.isym = isym;

  if (count1 == 0 || count2 == 0 || count1 != count2)
    goto done;

  for (i = 0; i < count1; i++)
    symtable1[i].name
      = bfd_elf_string_from_elf_section (bfd1, hdr1->sh_link,
      symtable1[i].u.isym->st_name);

  for (i = 0; i < count2; i++)
    symtable2[i].name
      = bfd_elf_string_from_elf_section (bfd2, hdr2->sh_link,
      symtable2[i].u.isym->st_name);


  qsort (symtable1, count1, sizeof (struct elf_symbol),
  elf_sym_name_compare);
  qsort (symtable2, count1, sizeof (struct elf_symbol),
  elf_sym_name_compare);

  for (i = 0; i < count1; i++)

    if (symtable1 [i].u.isym->st_info != symtable2 [i].u.isym->st_info
 || symtable1 [i].u.isym->st_other != symtable2 [i].u.isym->st_other
 || strcmp (symtable1 [i].name, symtable2 [i].name) != 0)
      goto done;

  result = 
# 8659 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 8659 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

 done:
  free (symtable1);
  free (symtable2);
  free (isymbuf1);
  free (isymbuf2);

  return result;
}




# 8672 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 8673 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_match_sections_by_type (bfd *abfd, const asection *asec,
     bfd *bbfd, const asection *bsec)
{
  if (asec == 
# 8676 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
      
# 8677 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || bsec == 
# 8677 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
      
# 8678 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || abfd->xvec->flavour != bfd_target_elf_flavour
      || bbfd->xvec->flavour != bfd_target_elf_flavour)
    return 
# 8680 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 8680 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  return (((struct bfd_elf_section_data*)(asec)->used_by_bfd)->this_hdr.sh_type) == (((struct bfd_elf_section_data*)(bsec)->used_by_bfd)->this_hdr.sh_type);
}





struct elf_final_link_info
{

  struct bfd_link_info *info;

  bfd *output_bfd;

  struct elf_strtab_hash *symstrtab;

  asection *hash_sec;

  asection *symver_sec;

  bfd_byte *contents;

  void *external_relocs;

  Elf_Internal_Rela *internal_relocs;


  bfd_byte *external_syms;

  Elf_External_Sym_Shndx *locsym_shndx;


  Elf_Internal_Sym *internal_syms;


  long *indices;


  asection **sections;

  Elf_External_Sym_Shndx *symshndxbuf;

  size_t filesym_count;

  struct bfd_hash_table local_hash_table;
};

struct local_hash_entry
{

  struct bfd_hash_entry root;

  size_t size;

  long count;
};



static struct bfd_hash_entry *
local_hash_newfunc (struct bfd_hash_entry *entry,
      struct bfd_hash_table *table,
      const char *string)
{



  if (entry == 
# 8749 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 8749 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    {
      entry = bfd_hash_allocate (table,
     sizeof (struct local_hash_entry));
      if (entry == 
# 8753 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 8753 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
        return entry;
    }


  entry = bfd_hash_newfunc (entry, table, string);
  if (entry != 
# 8759 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 8759 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    {
      ((struct local_hash_entry *) entry)->count = 0;
      ((struct local_hash_entry *) entry)->size = 0;
    }

  return entry;
}



struct elf_outext_info
{
  
# 8772 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 8772 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      failed;
  
# 8773 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 8773 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      localsyms;
  
# 8774 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 8774 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      file_sym_done;
  struct elf_final_link_info *flinfo;
};
# 8808 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
static void
set_symbol_value (bfd *bfd_with_globals,
    Elf_Internal_Sym *isymbuf,
    size_t locsymcount,
    size_t symidx,
    bfd_vma val)
{
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry *h;
  size_t extsymoff = locsymcount;

  if (symidx < locsymcount)
    {
      Elf_Internal_Sym *sym;

      sym = isymbuf + symidx;
      if ((((unsigned int)(sym->st_info)) >> 4) == 0)
 {


   sym->st_shndx = (-0xFu);
   sym->st_value = val;
   return;
 }
      do { if (!((((bfd_with_globals) -> tdata.elf_obj_data) -> bad_symtab))) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",8832); } while (0);
      extsymoff = 0;
    }




  sym_hashes = (((bfd_with_globals) -> tdata.elf_obj_data) -> sym_hashes);
  h = sym_hashes [symidx - extsymoff];
  while (h->root.type == bfd_link_hash_indirect
  || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
  h->root.type = bfd_link_hash_defined;
  h->root.u.def.value = val;
  h->root.u.def.section = (&_bfd_std_section[2]);
}

static 
# 8849 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 8850 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
resolve_symbol (const char *name,
  bfd *input_bfd,
  struct elf_final_link_info *flinfo,
  bfd_vma *result,
  Elf_Internal_Sym *isymbuf,
  size_t locsymcount)
{
  Elf_Internal_Sym *sym;
  struct bfd_link_hash_entry *global_entry;
  const char *candidate = 
# 8859 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 8859 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;
  Elf_Internal_Shdr *symtab_hdr;
  size_t i;

  symtab_hdr = & ((input_bfd) -> tdata.elf_obj_data)->symtab_hdr;

  for (i = 0; i < locsymcount; ++ i)
    {
      sym = isymbuf + i;

      if ((((unsigned int)(sym->st_info)) >> 4) != 0)
 continue;

      candidate = bfd_elf_string_from_elf_section (input_bfd,
         symtab_hdr->sh_link,
         sym->st_name);




      if (candidate && strcmp (candidate, name) == 0)
 {
   asection *sec = flinfo->sections [i];

   *result = _bfd_elf_rel_local_sym (input_bfd, sym, &sec, 0);
   *result += sec->output_offset + sec->output_section->vma;




   return 
# 8889 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 8889 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }
    }


  global_entry = bfd_link_hash_lookup (flinfo->info->hash, name,
           
# 8895 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 8895 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               , 
# 8895 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 0
# 8895 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      , 
# 8895 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        1
# 8895 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                            );
  if (!global_entry)
    return 
# 8897 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 8897 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (global_entry->type == bfd_link_hash_defined
      || global_entry->type == bfd_link_hash_defweak)
    {
      *result = (global_entry->u.def.value
   + global_entry->u.def.section->output_section->vma
   + global_entry->u.def.section->output_offset);




      return 
# 8909 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 8909 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }

  return 
# 8912 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 8912 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}





static 
# 8919 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 8920 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
resolve_section (const char *name,
   asection *sections,
   bfd_vma *result,
   bfd * abfd)
{
  asection *curr;
  unsigned int len;

  for (curr = sections; curr; curr = curr->next)
    if (strcmp (curr->name, name) == 0)
      {
 *result = curr->vma;
 return 
# 8932 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 8932 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
      }



  for (curr = sections; curr; curr = curr->next)
    {
      len = strlen (curr->name);
      if (len > strlen (name))
 continue;

      if (strncmp (curr->name, name, len) == 0)
 {
   if (startswith (name + len, ".end"))
     {
       *result = (curr->vma
    + curr->size / bfd_octets_per_byte (abfd, curr));
       return 
# 8949 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             1
# 8949 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
     }


 }
    }

  return 
# 8956 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 8956 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}

static void
undefined_reference (const char *reftype, const char *name)
{

  _bfd_error_handler (dgettext ("bfd", "undefined %s reference in complex symbol: %s"),
        reftype, name);
  bfd_set_error (bfd_error_bad_value);
}

static 
# 8968 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 8969 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
eval_symbol (bfd_vma *result,
      const char **symp,
      bfd *input_bfd,
      struct elf_final_link_info *flinfo,
      bfd_vma dot,
      Elf_Internal_Sym *isymbuf,
      size_t locsymcount,
      int signed_p)
{
  size_t len;
  size_t symlen;
  bfd_vma a;
  bfd_vma b;
  char symbuf[4096];
  const char *sym = *symp;
  const char *symend;
  
# 8985 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 8985 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      symbol_is_section = 
# 8985 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          0
# 8985 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               ;

  len = strlen (sym);
  symend = sym + len;

  if (len < 1 || len > sizeof (symbuf))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return 
# 8993 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 8993 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }

  switch (* sym)
    {
    case '.':
      *result = dot;
      *symp = sym + 1;
      return 
# 9001 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 9001 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

    case '#':
      ++sym;
      *result = strtoul (sym, (char **) symp, 16);
      return 
# 9006 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 9006 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

    case 'S':
      symbol_is_section = 
# 9009 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         1
# 9009 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;

    case 's':
      ++sym;
      symlen = strtol (sym, (char **) symp, 10);
      sym = *symp + 1;

      if (symend < sym || symlen + 1 > sizeof (symbuf))
 {
   bfd_set_error (bfd_error_invalid_operation);
   return 
# 9019 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 9019 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }

      memcpy (symbuf, sym, symlen);
      symbuf[symlen] = '\0';
      *symp = sym + symlen;






      if (symbol_is_section)
 {
   if (!resolve_section (symbuf, flinfo->output_bfd->sections, result, input_bfd)
       && !resolve_symbol (symbuf, input_bfd, flinfo, result,
      isymbuf, locsymcount))
     {
       undefined_reference ("section", symbuf);
       return 
# 9038 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 9038 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
 }
      else
 {
   if (!resolve_symbol (symbuf, input_bfd, flinfo, result,
          isymbuf, locsymcount)
       && !resolve_section (symbuf, flinfo->output_bfd->sections,
       result, input_bfd))
     {
       undefined_reference ("symbol", symbuf);
       return 
# 9049 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 9049 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
 }

      return 
# 9053 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 9053 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
# 9097 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
    default:
      if (startswith (sym, "0-")) { sym += strlen ("0-"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9098 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9098 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = 0- ((bfd_signed_vma) a); else *result = 0- a; return 
# 9098 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9098 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "<<")) { sym += strlen ("<<"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9099 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9099 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9099 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9099 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ;;
      if (b >= sizeof (a) * 8)
 {
   *result = 0;
   return 
# 9103 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 9103 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }
      signed_p = 0;
      if (signed_p) *result = ((bfd_signed_vma) a) << ((bfd_signed_vma) b); else *result = a << b; return 
# 9106 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9106 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, ">>")) { sym += strlen (">>"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9107 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9107 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9107 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9107 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ;;
      if (b >= sizeof (a) * 8)
 {
   *result = signed_p && (bfd_signed_vma) a < 0 ? -1 : 0;
   return 
# 9111 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 9111 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }
      if (signed_p) *result = ((bfd_signed_vma) a) >> ((bfd_signed_vma) b); else *result = a >> b; return 
# 9113 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9113 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "==")) { sym += strlen ("=="); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9114 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9114 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9114 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9114 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) == ((bfd_signed_vma) b); else *result = a == b; return 
# 9114 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9114 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "!=")) { sym += strlen ("!="); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9115 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9115 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9115 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9115 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) != ((bfd_signed_vma) b); else *result = a != b; return 
# 9115 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9115 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "<=")) { sym += strlen ("<="); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9116 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9116 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9116 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9116 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) <= ((bfd_signed_vma) b); else *result = a <= b; return 
# 9116 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9116 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, ">=")) { sym += strlen (">="); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9117 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9117 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9117 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9117 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) >= ((bfd_signed_vma) b); else *result = a >= b; return 
# 9117 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9117 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "&&")) { sym += strlen ("&&"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9118 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9118 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9118 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9118 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) && ((bfd_signed_vma) b); else *result = a && b; return 
# 9118 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9118 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "||")) { sym += strlen ("||"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9119 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9119 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9119 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9119 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) || ((bfd_signed_vma) b); else *result = a || b; return 
# 9119 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9119 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "~")) { sym += strlen ("~"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9120 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9120 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ~ ((bfd_signed_vma) a); else *result = ~ a; return 
# 9120 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9120 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "!")) { sym += strlen ("!"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9121 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9121 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ! ((bfd_signed_vma) a); else *result = ! a; return 
# 9121 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9121 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "*")) { sym += strlen ("*"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9122 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9122 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9122 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9122 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) * ((bfd_signed_vma) b); else *result = a * b; return 
# 9122 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9122 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "/")) { sym += strlen ("/"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9123 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9123 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9123 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9123 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ;;
      if (b == 0)
 {
   _bfd_error_handler (dgettext ("bfd", "division by zero"));
   bfd_set_error (bfd_error_bad_value);
   return 
# 9128 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 9128 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }
      if (signed_p) *result = ((bfd_signed_vma) a) / ((bfd_signed_vma) b); else *result = a / b; return 
# 9130 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9130 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "%")) { sym += strlen ("%"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9131 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9131 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9131 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9131 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ;;
      if (b == 0)
 {
   _bfd_error_handler (dgettext ("bfd", "division by zero"));
   bfd_set_error (bfd_error_bad_value);
   return 
# 9136 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 9136 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }
      if (signed_p) *result = ((bfd_signed_vma) a) % ((bfd_signed_vma) b); else *result = a % b; return 
# 9138 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9138 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "^")) { sym += strlen ("^"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9139 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9139 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9139 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9139 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) ^ ((bfd_signed_vma) b); else *result = a ^ b; return 
# 9139 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9139 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "|")) { sym += strlen ("|"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9140 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9140 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9140 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9140 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) | ((bfd_signed_vma) b); else *result = a | b; return 
# 9140 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9140 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "&")) { sym += strlen ("&"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9141 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9141 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9141 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9141 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) & ((bfd_signed_vma) b); else *result = a & b; return 
# 9141 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9141 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "+")) { sym += strlen ("+"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9142 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9142 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9142 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9142 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) + ((bfd_signed_vma) b); else *result = a + b; return 
# 9142 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9142 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "-")) { sym += strlen ("-"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9143 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9143 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9143 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9143 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) - ((bfd_signed_vma) b); else *result = a - b; return 
# 9143 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9143 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, "<")) { sym += strlen ("<"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9144 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9144 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9144 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9144 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) < ((bfd_signed_vma) b); else *result = a < b; return 
# 9144 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9144 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };
      if (startswith (sym, ">")) { sym += strlen (">"); if (*sym == ':') ++sym; *symp = sym; if (!eval_symbol (&a, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9145 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9145 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; ++*symp; if (!eval_symbol (&b, symp, input_bfd, flinfo, dot, isymbuf, locsymcount, signed_p)) return 
# 9145 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 9145 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; if (signed_p) *result = ((bfd_signed_vma) a) > ((bfd_signed_vma) b); else *result = a > b; return 
# 9145 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     1
# 9145 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     ; };


      _bfd_error_handler (dgettext ("bfd", "unknown operator '%c' in complex symbol"), * sym);
      bfd_set_error (bfd_error_invalid_operation);
      return 
# 9150 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 9150 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }
}

static void
put_value (bfd_vma size,
    unsigned long chunksz,
    bfd *input_bfd,
    bfd_vma x,
    bfd_byte *location)
{
  location += (size - chunksz);

  for (; size; size -= chunksz, location -= chunksz)
    {
      switch (chunksz)
 {
 case 1:
   ((void) (*((bfd_byte *) (location)) = (x) & 0xff));
   x >>= 8;
   break;
 case 2:
   ((*((input_bfd)->xvec->bfd_putx16)) ((x),(location)));
   x >>= 16;
   break;
 case 4:
   ((*((input_bfd)->xvec->bfd_putx32)) ((x),(location)));

   x >>= 16;
   x >>= 16;
   break;

 case 8:
   ((*((input_bfd)->xvec->bfd_putx64)) ((x), (location)));

   x >>= 32;
   x >>= 32;
   break;

 default:
   _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 9190, __PRETTY_FUNCTION__);
   break;
 }
    }
}

static bfd_vma
get_value (bfd_vma size,
    unsigned long chunksz,
    bfd *input_bfd,
    bfd_byte *location)
{
  int shift;
  bfd_vma x = 0;


  do { if (!(chunksz <= sizeof (x) && size >= chunksz && chunksz != 0 && (size % chunksz) == 0 && input_bfd != 
# 9206 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 ((void *)0) 
# 9206 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
 && location != 
# 9206 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 ((void *)0)
# 9206 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
 )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",9206); } while (0)




                           ;

  if (chunksz == sizeof (x))
    {
      do { if (!(size == chunksz)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",9215); } while (0);




      shift = 0;
    }
  else
    shift = 8 * chunksz;

  for (; size; size -= chunksz, location += chunksz)
    {
      switch (chunksz)
 {
 case 1:
   x = (x << shift) | ((bfd_vma) *(const bfd_byte *) (location) & 0xff);
   break;
 case 2:
   x = (x << shift) | ((*((input_bfd)->xvec->bfd_getx16)) (location));
   break;
 case 4:
   x = (x << shift) | ((*((input_bfd)->xvec->bfd_getx32)) (location));
   break;

 case 8:
   x = (x << shift) | ((*((input_bfd)->xvec->bfd_getx64)) (location));
   break;

 default:
   _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 9244, __PRETTY_FUNCTION__);
 }
    }
  return x;
}

static void
decode_complex_addend (unsigned long *start,
         unsigned long *oplen,
         unsigned long *len,
         unsigned long *wordsz,
         unsigned long *chunksz,
         unsigned long *lsb0_p,
         unsigned long *signed_p,
         unsigned long *trunc_p,
         unsigned long encoded)
{
  * start = encoded & 0x3F;
  * len = (encoded >> 6) & 0x3F;
  * oplen = (encoded >> 12) & 0x3F;
  * wordsz = (encoded >> 18) & 0xF;
  * chunksz = (encoded >> 22) & 0xF;
  * lsb0_p = (encoded >> 27) & 1;
  * signed_p = (encoded >> 28) & 1;
  * trunc_p = (encoded >> 29) & 1;
}

bfd_reloc_status_type
bfd_elf_perform_complex_relocation (bfd *input_bfd,
        asection *input_section,
        bfd_byte *contents,
        Elf_Internal_Rela *rel,
        bfd_vma relocation)
{
  bfd_vma shift, x, mask;
  unsigned long start, oplen, len, wordsz, chunksz, lsb0_p, signed_p, trunc_p;
  bfd_reloc_status_type r;
  bfd_size_type octets;







  decode_complex_addend (&start, &oplen, &len, &wordsz,
    &chunksz, &lsb0_p, &signed_p,
    &trunc_p, rel->r_addend);

  mask = (((1L << (len - 1)) - 1) << 1) | 1;

  if (lsb0_p)
    shift = (start + 1) - len;
  else
    shift = (8 * wordsz) - (start + len);

  octets = rel->r_offset * bfd_octets_per_byte (input_bfd, input_section);
  x = get_value (wordsz, chunksz, input_bfd, contents + octets);
# 9313 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  r = bfd_reloc_ok;
  if (! trunc_p)

    r = bfd_check_overflow ((signed_p
        ? complain_overflow_signed
        : complain_overflow_unsigned),
       len, 0, (8 * wordsz),
       relocation);


  x = (x & ~(mask << shift)) | ((relocation & mask) << shift);
# 9333 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  put_value (wordsz, chunksz, input_bfd, x, contents + octets);
  return r;
}





static bfd_vma
ext32l_r_offset (const void *p)
{
  union aligned32
  {
    uint32_t v;
    unsigned char c[4];
  };
  const union aligned32 *a
    = (const union aligned32 *) &((const Elf32_External_Rel *) p)->r_offset;

  uint32_t aval = ( (uint32_t) a->c[0]
     | (uint32_t) a->c[1] << 8
     | (uint32_t) a->c[2] << 16
     | (uint32_t) a->c[3] << 24);
  return aval;
}

static bfd_vma
ext32b_r_offset (const void *p)
{
  union aligned32
  {
    uint32_t v;
    unsigned char c[4];
  };
  const union aligned32 *a
    = (const union aligned32 *) &((const Elf32_External_Rel *) p)->r_offset;

  uint32_t aval = ( (uint32_t) a->c[0] << 24
     | (uint32_t) a->c[1] << 16
     | (uint32_t) a->c[2] << 8
     | (uint32_t) a->c[3]);
  return aval;
}

static bfd_vma
ext64l_r_offset (const void *p)
{
  union aligned64
  {
    uint64_t v;
    unsigned char c[8];
  };
  const union aligned64 *a
    = (const union aligned64 *) &((const Elf64_External_Rel *) p)->r_offset;

  uint64_t aval = ( (uint64_t) a->c[0]
     | (uint64_t) a->c[1] << 8
     | (uint64_t) a->c[2] << 16
     | (uint64_t) a->c[3] << 24
     | (uint64_t) a->c[4] << 32
     | (uint64_t) a->c[5] << 40
     | (uint64_t) a->c[6] << 48
     | (uint64_t) a->c[7] << 56);
  return aval;
}

static bfd_vma
ext64b_r_offset (const void *p)
{
  union aligned64
  {
    uint64_t v;
    unsigned char c[8];
  };
  const union aligned64 *a
    = (const union aligned64 *) &((const Elf64_External_Rel *) p)->r_offset;

  uint64_t aval = ( (uint64_t) a->c[0] << 56
     | (uint64_t) a->c[1] << 48
     | (uint64_t) a->c[2] << 40
     | (uint64_t) a->c[3] << 32
     | (uint64_t) a->c[4] << 24
     | (uint64_t) a->c[5] << 16
     | (uint64_t) a->c[6] << 8
     | (uint64_t) a->c[7]);
  return aval;
}






static 
# 9426 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 9427 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_adjust_relocs (bfd *abfd,
   asection *sec,
   struct bfd_elf_section_reloc_data *reldata,
   
# 9430 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 9430 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       sort,
   struct bfd_link_info *info)
{
  unsigned int i;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  bfd_byte *erela;
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  bfd_vma r_type_mask;
  int r_sym_shift;
  unsigned int count = reldata->count;
  struct elf_link_hash_entry **rel_hash = reldata->hashes;

  if (reldata->hdr->sh_entsize == bed->s->sizeof_rel)
    {
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }
  else if (reldata->hdr->sh_entsize == bed->s->sizeof_rela)
    {
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  else
    _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 9454, __PRETTY_FUNCTION__);

  if (bed->s->int_rels_per_ext_rel > 3)
    _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 9457, __PRETTY_FUNCTION__);

  if (bed->s->arch_size == 32)
    {
      r_type_mask = 0xff;
      r_sym_shift = 8;
    }
  else
    {
      r_type_mask = 0xffffffff;
      r_sym_shift = 32;
    }

  erela = reldata->hdr->contents;
  for (i = 0; i < count; i++, rel_hash++, erela += reldata->hdr->sh_entsize)
    {
      Elf_Internal_Rela irela[3];
      unsigned int j;

      if (*rel_hash == 
# 9476 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 9476 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          )
 continue;

      if ((*rel_hash)->indx == -2
   && info->gc_sections
   && ! info->gc_keep_exported)
 {

   _bfd_error_handler (dgettext ("bfd", "%pB:%pA: error: relocation references symbol %s which was removed by garbage collection"),
         abfd, sec,
         (*rel_hash)->root.root.string);
   _bfd_error_handler (dgettext ("bfd", "%pB:%pA: error: try relinking with --gc-keep-exported enabled"),
         abfd, sec);
   bfd_set_error (bfd_error_invalid_operation);
   return 
# 9490 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 9490 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }
      do { if (!((*rel_hash)->indx >= 0)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",9492); } while (0);

      (*swap_in) (abfd, erela, irela);
      for (j = 0; j < bed->s->int_rels_per_ext_rel; j++)
 irela[j].r_info = ((bfd_vma) (*rel_hash)->indx << r_sym_shift
      | (irela[j].r_info & r_type_mask));
      (*swap_out) (abfd, irela, erela);
    }

  if (bed->elf_backend_update_relocs)
    (*bed->elf_backend_update_relocs) (sec, reldata);

  if (sort && count != 0)
    {
      bfd_vma (*ext_r_off) (const void *);
      bfd_vma r_off;
      size_t elt_size;
      bfd_byte *base, *end, *p, *loc;
      bfd_byte *buf = 
# 9510 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 9510 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;

      if (bed->s->arch_size == 32)
 {
   if (abfd->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
     ext_r_off = ext32l_r_offset;
   else if (abfd->xvec->header_byteorder == BFD_ENDIAN_BIG)
     ext_r_off = ext32b_r_offset;
   else
     _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 9519, __PRETTY_FUNCTION__);
 }
      else
 {
   if (abfd->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
     ext_r_off = ext64l_r_offset;
   else if (abfd->xvec->header_byteorder == BFD_ENDIAN_BIG)
     ext_r_off = ext64b_r_offset;
   else
     _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 9528, __PRETTY_FUNCTION__);
 }



      elt_size = reldata->hdr->sh_entsize;
      base = reldata->hdr->contents;
      end = base + count * elt_size;
      if (elt_size > sizeof (Elf64_External_Rela))
 _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 9537, __PRETTY_FUNCTION__);



      r_off = (*ext_r_off) (base);
      for (p = loc = base; (p += elt_size) < end; )
 {
   bfd_vma r_off2 = (*ext_r_off) (p);
   if (r_off > r_off2)
     {
       r_off = r_off2;
       loc = p;
     }
 }
      if (loc != base)
 {



   bfd_byte onebuf[sizeof (Elf64_External_Rela)];
   memcpy (onebuf, loc, elt_size);
   memmove (base + elt_size, base, loc - base);
   memcpy (base, onebuf, elt_size);
 }

      for (p = base + elt_size; (p += elt_size) < end; )
 {

   r_off = (*ext_r_off) (p);

   loc = p - elt_size;
   while (r_off < (*ext_r_off) (loc))
     loc -= elt_size;
   loc += elt_size;
   if (loc != p)
     {




       size_t sortlen = p - loc;
       bfd_vma r_off2 = (*ext_r_off) (loc);
       size_t runlen = elt_size;
       bfd_vma r_off_runend = r_off;
       bfd_vma r_off_runend_next;
       size_t buf_size = 96 * 1024;
       while (p + runlen < end
       && (sortlen <= buf_size
    || runlen + elt_size <= buf_size)

       && r_off2 > (r_off_runend_next = (*ext_r_off) (p + runlen))

       && r_off_runend_next >= r_off_runend)
  {
    runlen += elt_size;
    r_off_runend = r_off_runend_next;
  }
       if (buf == 
# 9594 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 9594 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
  {
    buf = bfd_malloc (buf_size);
    if (buf == 
# 9597 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 9597 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
      return 
# 9598 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 9598 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
  }
       if (runlen < sortlen)
  {
    memcpy (buf, p, runlen);
    memmove (loc + runlen, loc, sortlen);
    memcpy (loc, buf, runlen);
  }
       else
  {
    memcpy (buf, loc, sortlen);
    memmove (loc, p, runlen);
    memcpy (loc + runlen, buf, sortlen);
  }
       p += runlen - elt_size;
     }
 }

      free (reldata->hashes);
      reldata->hashes = 
# 9617 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       ((void *)0)
# 9617 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
      free (buf);
    }
  return 
# 9620 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 9620 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}

struct elf_link_sort_rela
{
  union {
    bfd_vma offset;
    bfd_vma sym_mask;
  } u;
  enum elf_reloc_type_class type;

  Elf_Internal_Rela rela[1];
};
# 9643 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
static int
elf_link_sort_cmp1 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = (const struct elf_link_sort_rela *) A;
  const struct elf_link_sort_rela *b = (const struct elf_link_sort_rela *) B;
  int relativea, relativeb;

  relativea = a->type == reloc_class_relative;
  relativeb = b->type == reloc_class_relative;

  if (relativea < relativeb)
    return 1;
  if (relativea > relativeb)
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) < (b->rela->r_info & b->u.sym_mask))
    return -1;
  if ((a->rela->r_info & a->u.sym_mask) > (b->rela->r_info & b->u.sym_mask))
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static int
elf_link_sort_cmp2 (const void *A, const void *B)
{
  const struct elf_link_sort_rela *a = (const struct elf_link_sort_rela *) A;
  const struct elf_link_sort_rela *b = (const struct elf_link_sort_rela *) B;

  if (a->type < b->type)
    return -1;
  if (a->type > b->type)
    return 1;
  if (a->u.offset < b->u.offset)
    return -1;
  if (a->u.offset > b->u.offset)
    return 1;
  if (a->rela->r_offset < b->rela->r_offset)
    return -1;
  if (a->rela->r_offset > b->rela->r_offset)
    return 1;
  return 0;
}

static size_t
elf_link_sort_relocs (bfd *abfd, struct bfd_link_info *info, asection **psec)
{
  asection *dynamic_relocs;
  asection *rela_dyn;
  asection *rel_dyn;
  bfd_size_type count, size;
  size_t i, ret, sort_elt, ext_size;
  bfd_byte *sort, *s_non_relative, *p;
  struct elf_link_sort_rela *sq;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  int i2e = bed->s->int_rels_per_ext_rel;
  unsigned int opb = bfd_octets_per_byte (abfd, 
# 9701 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                               ((void *)0)
# 9701 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                   );
  void (*swap_in) (bfd *, const bfd_byte *, Elf_Internal_Rela *);
  void (*swap_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
  struct bfd_link_order *lo;
  bfd_vma r_sym_mask;
  
# 9706 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 9706 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      use_rela;


  rela_dyn = bfd_get_section_by_name (abfd, ".rela.dyn");
  rel_dyn = bfd_get_section_by_name (abfd, ".rel.dyn");
  if (rela_dyn != 
# 9711 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0) 
# 9711 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      && rela_dyn->size > 0
      && rel_dyn != 
# 9712 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0) 
# 9712 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        && rel_dyn->size > 0)
    {
      
# 9714 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 9714 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          use_rela_initialised = 
# 9714 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 0
# 9714 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ;



      use_rela = 
# 9718 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                1
# 9718 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;



      for (lo = rela_dyn->map_head.link_order; lo != 
# 9722 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                    ((void *)0)
# 9722 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                        ; lo = lo->next)
 if (lo->type == bfd_indirect_link_order)
   {
     asection *o = lo->u.indirect.section;

     if ((o->size % bed->s->sizeof_rela) == 0)
       {
  if ((o->size % bed->s->sizeof_rel) == 0)


    ;
  else
    {

      if (use_rela_initialised && !use_rela)
        {
   _bfd_error_handler (dgettext ("bfd", "%pB: unable to sort relocs - " "they are in more than one size")
                                            ,
         abfd);
   bfd_set_error (bfd_error_invalid_operation);
   return 0;
        }
      else
        {
   use_rela = 
# 9746 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             1
# 9746 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
   use_rela_initialised = 
# 9747 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         1
# 9747 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;
        }
    }
       }
     else if ((o->size % bed->s->sizeof_rel) == 0)
       {

  if (use_rela_initialised && use_rela)
    {
      _bfd_error_handler (dgettext ("bfd", "%pB: unable to sort relocs - " "they are in more than one size")
                                        ,
     abfd);
      bfd_set_error (bfd_error_invalid_operation);
      return 0;
    }
  else
    {
      use_rela = 
# 9764 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                0
# 9764 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ;
      use_rela_initialised = 
# 9765 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            1
# 9765 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                ;
    }
       }
     else
       {


  _bfd_error_handler (dgettext ("bfd", "%pB: unable to sort relocs - " "they are of an unknown size")
                                        , abfd);
  bfd_set_error (bfd_error_invalid_operation);
  return 0;
       }
   }

      for (lo = rel_dyn->map_head.link_order; lo != 
# 9779 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                   ((void *)0)
# 9779 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                       ; lo = lo->next)
 if (lo->type == bfd_indirect_link_order)
   {
     asection *o = lo->u.indirect.section;

     if ((o->size % bed->s->sizeof_rela) == 0)
       {
  if ((o->size % bed->s->sizeof_rel) == 0)


    ;
  else
    {

      if (use_rela_initialised && !use_rela)
        {
   _bfd_error_handler (dgettext ("bfd", "%pB: unable to sort relocs - " "they are in more than one size")
                                            ,
         abfd);
   bfd_set_error (bfd_error_invalid_operation);
   return 0;
        }
      else
        {
   use_rela = 
# 9803 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             1
# 9803 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
   use_rela_initialised = 
# 9804 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         1
# 9804 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;
        }
    }
       }
     else if ((o->size % bed->s->sizeof_rel) == 0)
       {

  if (use_rela_initialised && use_rela)
    {
      _bfd_error_handler (dgettext ("bfd", "%pB: unable to sort relocs - " "they are in more than one size")
                                        ,
     abfd);
      bfd_set_error (bfd_error_invalid_operation);
      return 0;
    }
  else
    {
      use_rela = 
# 9821 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                0
# 9821 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ;
      use_rela_initialised = 
# 9822 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            1
# 9822 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                ;
    }
       }
     else
       {


  _bfd_error_handler (dgettext ("bfd", "%pB: unable to sort relocs - " "they are of an unknown size")
                                        , abfd);
  bfd_set_error (bfd_error_invalid_operation);
  return 0;
       }
   }

      if (! use_rela_initialised)

 use_rela = 
# 9838 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 9838 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
    }
  else if (rela_dyn != 
# 9840 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0) 
# 9840 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           && rela_dyn->size > 0)
    use_rela = 
# 9841 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              1
# 9841 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
  else if (rel_dyn != 
# 9842 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0) 
# 9842 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          && rel_dyn->size > 0)
    use_rela = 
# 9843 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              0
# 9843 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
  else
    return 0;

  if (use_rela)
    {
      dynamic_relocs = rela_dyn;
      ext_size = bed->s->sizeof_rela;
      swap_in = bed->s->swap_reloca_in;
      swap_out = bed->s->swap_reloca_out;
    }
  else
    {
      dynamic_relocs = rel_dyn;
      ext_size = bed->s->sizeof_rel;
      swap_in = bed->s->swap_reloc_in;
      swap_out = bed->s->swap_reloc_out;
    }

  size = 0;
  for (lo = dynamic_relocs->map_head.link_order; lo != 
# 9863 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                      ((void *)0)
# 9863 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                          ; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      size += lo->u.indirect.section->size;

  if (size != dynamic_relocs->size)
    return 0;

  sort_elt = (sizeof (struct elf_link_sort_rela)
       + (i2e - 1) * sizeof (Elf_Internal_Rela));

  count = dynamic_relocs->size / ext_size;
  if (count == 0)
    return 0;
  sort = (bfd_byte *) bfd_zmalloc (sort_elt * count);

  if (sort == 
# 9878 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 9878 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
    {
      (*info->callbacks->warning)
 (info, dgettext ("bfd", "not enough memory to sort relocations"), 0, abfd, 0, 0);
      return 0;
    }

  if (bed->s->arch_size == 32)
    r_sym_mask = ~(bfd_vma) 0xff;
  else
    r_sym_mask = ~(bfd_vma) 0xffffffff;

  for (lo = dynamic_relocs->map_head.link_order; lo != 
# 9890 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                      ((void *)0)
# 9890 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                          ; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
 bfd_byte *erel, *erelend;
 asection *o = lo->u.indirect.section;

 if (o->contents == 
# 9896 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0) 
# 9896 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        && o->size != 0)
   {



     free (sort);
     return 0;
   }
 erel = o->contents;
 erelend = o->contents + o->size;
 p = sort + o->output_offset * opb / ext_size * sort_elt;

 while (erel < erelend)
   {
     struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;

     (*swap_in) (abfd, erel, s->rela);
     s->type = (*bed->elf_backend_reloc_type_class) (info, o, s->rela);
     s->u.sym_mask = r_sym_mask;
     p += sort_elt;
     erel += ext_size;
   }
      }

  qsort (sort, count, sort_elt, elf_link_sort_cmp1);

  for (i = 0, p = sort; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
      if (s->type != reloc_class_relative)
 break;
    }
  ret = i;
  s_non_relative = p;

  sq = (struct elf_link_sort_rela *) s_non_relative;
  for (; i < count; i++, p += sort_elt)
    {
      struct elf_link_sort_rela *sp = (struct elf_link_sort_rela *) p;
      if (((sp->rela->r_info ^ sq->rela->r_info) & r_sym_mask) != 0)
 sq = sp;
      sp->u.offset = sq->rela->r_offset;
    }

  qsort (s_non_relative, count - ret, sort_elt, elf_link_sort_cmp2);

  struct elf_link_hash_table *htab = elf_hash_table (info);
  if (htab->srelplt && htab->srelplt->output_section == dynamic_relocs)
    {

      sq = (struct elf_link_sort_rela *) sort;
      for (i = 0; i < count; i++)
 if (sq[count - i - 1].type != reloc_class_plt)
   break;
      if (i != 0 && htab->srelplt->size == i * ext_size)
 {
   struct bfd_link_order **plo;


   for (plo = &dynamic_relocs->map_head.link_order; *plo != 
# 9955 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                           ((void *)0)
# 9955 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                               ; )
     if ((*plo)->type == bfd_indirect_link_order
  && (*plo)->u.indirect.section == htab->srelplt)
       {
  lo = *plo;
  *plo = lo->next;
       }
     else
       plo = &(*plo)->next;
   *plo = lo;
   lo->next = 
# 9965 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 9965 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
   dynamic_relocs->map_tail.link_order = lo;
 }
    }

  p = sort;
  for (lo = dynamic_relocs->map_head.link_order; lo != 
# 9971 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                      ((void *)0)
# 9971 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                          ; lo = lo->next)
    if (lo->type == bfd_indirect_link_order)
      {
 bfd_byte *erel, *erelend;
 asection *o = lo->u.indirect.section;

 erel = o->contents;
 erelend = o->contents + o->size;
 o->output_offset = (p - sort) / sort_elt * ext_size / opb;
 while (erel < erelend)
   {
     struct elf_link_sort_rela *s = (struct elf_link_sort_rela *) p;
     (*swap_out) (abfd, s->rela, erel);
     p += sort_elt;
     erel += ext_size;
   }
      }

  free (sort);
  *psec = dynamic_relocs;
  return ret;
}



static int
elf_link_output_symstrtab (void *finf,
      const char *name,
      Elf_Internal_Sym *elfsym,
      asection *input_sec,
      struct elf_link_hash_entry *h)
{
  struct elf_final_link_info *flinfo = finf;
  int (*output_symbol_hook)
    (struct bfd_link_info *, const char *, Elf_Internal_Sym *, asection *,
     struct elf_link_hash_entry *);
  struct elf_link_hash_table *hash_table;
  const struct elf_backend_data *bed;
  bfd_size_type strtabsize;

  do { if (!((((flinfo->output_bfd) -> tdata.elf_obj_data) -> symtab_section))) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",10011); } while (0);

  bed = ((const struct elf_backend_data *) ((flinfo->output_bfd)->xvec)->backend_data);
  output_symbol_hook = bed->elf_backend_link_output_symbol_hook;
  if (output_symbol_hook != 
# 10015 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 10015 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
    {
      int ret = (*output_symbol_hook) (flinfo->info, name, elfsym, input_sec, h);
      if (ret != 1)
 return ret;
    }

  if (((elfsym->st_info) & 0xF) == 10)
    ((flinfo->output_bfd) -> tdata.elf_obj_data)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
  if ((((unsigned int)(elfsym->st_info)) >> 4) == 10)
    ((flinfo->output_bfd) -> tdata.elf_obj_data)->has_gnu_osabi |= elf_gnu_osabi_unique;

  if (name == 
# 10027 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0) 
# 10027 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  || *name == '\0')
    elfsym->st_name = (unsigned long) -1;
  else
    {


      char *versioned_name = (char *) name;
      if (h != 
# 10034 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 10034 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 {
   if (h->versioned == versioned && h->def_dynamic)
     {


       char *version = strrchr (name, '@');
       char *base_end = strchr (name, '@');
       if (version != base_end)
  {
    size_t base_len;
    size_t len = strlen (name);
    versioned_name = bfd_alloc (flinfo->output_bfd, len);
    if (versioned_name == 
# 10047 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 10047 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
      return 0;
    base_len = base_end - name;
    memcpy (versioned_name, name, base_len);
    memcpy (versioned_name + base_len, version,
     len - base_len);
  }
     }
 }
      else if (flinfo->info->unique_symbol
        && (((unsigned int)(elfsym->st_info)) >> 4) == 0)
 {
   struct local_hash_entry *lh;
   size_t count_len;
   size_t base_len;
   char buf[30];
   switch (((elfsym->st_info) & 0xF))
     {
     case 4:
     case 3:
       break;
     default:
       lh = (struct local_hash_entry *) bfd_hash_lookup
       (&flinfo->local_hash_table, name, 
# 10070 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                        1
# 10070 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                            , 
# 10070 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                              0
# 10070 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                   );
       if (lh == 
# 10071 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 10071 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
  return 0;


       sprintf (buf, "%lx", lh->count);
       base_len = lh->size;
       if (!base_len)
  {
    base_len = strlen (name);
    lh->size = base_len;
  }
       count_len = strlen (buf);
       versioned_name = bfd_alloc (flinfo->output_bfd,
       base_len + count_len + 2);
       if (versioned_name == 
# 10085 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 10085 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
  return 0;
       memcpy (versioned_name, name, base_len);
       versioned_name[base_len] = '.';
       memcpy (versioned_name + base_len + 1, buf,
        count_len + 1);
       lh->count++;
       break;
     }
 }
      elfsym->st_name
 = (unsigned long) _bfd_elf_strtab_add (flinfo->symstrtab,
            versioned_name, 
# 10097 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           0
# 10097 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                );
      if (elfsym->st_name == (unsigned long) -1)
 return 0;
    }

  hash_table = elf_hash_table (flinfo->info);
  strtabsize = hash_table->strtabsize;
  if (strtabsize <= flinfo->output_bfd->symcount)
    {
      strtabsize += strtabsize;
      hash_table->strtabsize = strtabsize;
      strtabsize *= sizeof (*hash_table->strtab);
      hash_table->strtab
 = (struct elf_sym_strtab *) bfd_realloc (hash_table->strtab,
       strtabsize);
      if (hash_table->strtab == 
# 10112 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 10112 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   )
 return 0;
    }
  hash_table->strtab[flinfo->output_bfd->symcount].sym = *elfsym;
  hash_table->strtab[flinfo->output_bfd->symcount].dest_index
    = flinfo->output_bfd->symcount;
  flinfo->output_bfd->symcount += 1;

  return 1;
}




static 
# 10126 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 10127 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_swap_symbols_out (struct elf_final_link_info *flinfo)
{
  struct elf_link_hash_table *hash_table = elf_hash_table (flinfo->info);
  size_t amt;
  size_t i;
  const struct elf_backend_data *bed;
  bfd_byte *symbuf;
  Elf_Internal_Shdr *hdr;
  file_ptr pos;
  
# 10136 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 10136 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ret;

  if (flinfo->output_bfd->symcount == 0)
    return 
# 10139 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 10139 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  do { if (!((((flinfo->output_bfd) -> tdata.elf_obj_data) -> symtab_section))) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",10141); } while (0);

  bed = ((const struct elf_backend_data *) ((flinfo->output_bfd)->xvec)->backend_data);

  amt = bed->s->sizeof_sym * flinfo->output_bfd->symcount;
  symbuf = (bfd_byte *) bfd_malloc (amt);
  if (symbuf == 
# 10147 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 10147 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
    return 
# 10148 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 10148 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (flinfo->symshndxbuf)
    {
      amt = sizeof (Elf_External_Sym_Shndx);
      amt *= bfd_get_symcount (flinfo->output_bfd);
      flinfo->symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);
      if (flinfo->symshndxbuf == 
# 10155 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
# 10155 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    )
 {
   free (symbuf);
   return 
# 10158 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 10158 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }
    }


  for (i = 0; i < flinfo->output_bfd->symcount; i++)
    {
      struct elf_sym_strtab *elfsym = &hash_table->strtab[i];
      if (elfsym->sym.st_name == (unsigned long) -1)
 elfsym->sym.st_name = 0;
      else
 elfsym->sym.st_name
   = (unsigned long) _bfd_elf_strtab_offset (flinfo->symstrtab,
          elfsym->sym.st_name);



      if (flinfo->info->callbacks->ctf_new_symbol)
 flinfo->info->callbacks->ctf_new_symbol (elfsym->dest_index,
       &elfsym->sym);

      bed->s->swap_symbol_out (flinfo->output_bfd, &elfsym->sym,
          ((bfd_byte *) symbuf
    + (elfsym->dest_index
       * bed->s->sizeof_sym)),
          ((flinfo->symshndxbuf) != 
# 10183 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         ((void *)0) 
# 10183 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
         ? (flinfo->symshndxbuf) + (elfsym->dest_index) : (flinfo->symshndxbuf))
                         );
    }

  hdr = &((flinfo->output_bfd) -> tdata.elf_obj_data)->symtab_hdr;
  pos = hdr->sh_offset + hdr->sh_size;
  amt = bed->s->sizeof_sym * flinfo->output_bfd->symcount;
  if (bfd_seek (flinfo->output_bfd, pos, 
# 10190 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                        0
# 10190 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                ) == 0
      && bfd_bwrite (symbuf, amt, flinfo->output_bfd) == amt)
    {
      hdr->sh_size += amt;
      ret = 
# 10194 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 10194 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
    }
  else
    ret = 
# 10197 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 10197 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  free (symbuf);

  free (hash_table->strtab);
  hash_table->strtab = 
# 10202 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 10202 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          ;

  return ret;
}



static 
# 10209 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 10210 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
check_dynsym (bfd *abfd, Elf_Internal_Sym *sym)
{
  if (sym->st_shndx >= ((-0x100u) & 0xffff)
      && sym->st_shndx < (-0x100u))
    {


      _bfd_error_handler

 (dgettext ("bfd", "%pB: too many sections: %d (>= %d)"),
  abfd, bfd_count_sections (abfd), (-0x100u) & 0xffff);
      bfd_set_error (bfd_error_nonrepresentable_section);
      return 
# 10222 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 10222 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }
  return 
# 10224 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 10224 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}







static 
# 10233 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 10234 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_check_versioned_symbol (struct bfd_link_info *info,
     const struct elf_backend_data *bed,
     struct elf_link_hash_entry *h)
{
  bfd *abfd;
  struct elf_link_loaded_list *loaded;

  if (!is_elf_hash_table (info->hash))
    return 
# 10242 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 10242 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  while (h->root.type == bfd_link_hash_indirect)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  switch (h->root.type)
    {
    default:
      abfd = 
# 10251 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 10251 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
      break;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      abfd = h->root.u.undef.abfd;
      if (abfd == 
# 10257 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
   
# 10258 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  || (abfd->flags & 0x40) == 0
   || ((((abfd) -> tdata.elf_obj_data) -> dyn_lib_class) & DYN_DT_NEEDED) == 0)
 return 
# 10260 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 10260 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      abfd = h->root.u.def.section->owner;
      break;

    case bfd_link_hash_common:
      abfd = h->root.u.c.p->section->owner;
      break;
    }
  do { if (!(abfd != 
# 10272 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 ((void *)0)
# 10272 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
 )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",10272); } while (0);

  for (loaded = elf_hash_table (info)->dyn_loaded;
       loaded != 
# 10275 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 10275 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;
       loaded = loaded->next)
    {
      bfd *input;
      Elf_Internal_Shdr *hdr;
      size_t symcount;
      size_t extsymcount;
      size_t extsymoff;
      Elf_Internal_Shdr *versymhdr;
      Elf_Internal_Sym *isym;
      Elf_Internal_Sym *isymend;
      Elf_Internal_Sym *isymbuf;
      Elf_External_Versym *ever;
      Elf_External_Versym *extversym;

      input = loaded->abfd;


      if (input == abfd
   || (((input) -> tdata.elf_obj_data) -> dynversym_section) == 0)
 continue;

      hdr = &((input) -> tdata.elf_obj_data)->dynsymtab_hdr;

      symcount = hdr->sh_size / bed->s->sizeof_sym;
      if ((((input) -> tdata.elf_obj_data) -> bad_symtab))
 {
   extsymcount = symcount;
   extsymoff = 0;
 }
      else
 {
   extsymcount = symcount - hdr->sh_info;
   extsymoff = hdr->sh_info;
 }

      if (extsymcount == 0)
 continue;

      isymbuf = bfd_elf_get_elf_syms (input, hdr, extsymcount, extsymoff,
          
# 10315 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         ((void *)0)
# 10315 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             , 
# 10315 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 10315 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   , 
# 10315 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 10315 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         );
      if (isymbuf == 
# 10316 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 10316 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        )
 return 
# 10317 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 10317 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;


      versymhdr = &((input) -> tdata.elf_obj_data)->dynversym_hdr;
      if (bfd_seek (input, versymhdr->sh_offset, 
# 10321 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                0
# 10321 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                        ) != 0
   || (extversym = (Elf_External_Versym *)
       _bfd_malloc_and_read (input, versymhdr->sh_size,
        versymhdr->sh_size)) == 
# 10324 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 10324 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   )
 {
   free (isymbuf);
   return 
# 10327 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 10327 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }

      ever = extversym + extsymoff;
      isymend = isymbuf + extsymcount;
      for (isym = isymbuf; isym < isymend; isym++, ever++)
 {
   const char *name;
   Elf_Internal_Versym iver;
   unsigned short version_index;

   if ((((unsigned int)(isym->st_info)) >> 4) == 0
       || isym->st_shndx == 0)
     continue;

   name = bfd_elf_string_from_elf_section (input,
        hdr->sh_link,
        isym->st_name);
   if (strcmp (name, h->root.root.string) != 0)
     continue;

   _bfd_elf_swap_versym_in (input, ever, &iver);

   if ((iver.vs_vers & 0x8000) == 0
       && !(h->def_regular
     && h->forced_local))
     {




       _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 10358, __PRETTY_FUNCTION__);
     }

   version_index = iver.vs_vers & 0x7fff;
   if (version_index == 1 || version_index == 2)
     {

       free (extversym);
       free (isymbuf);
       return 
# 10367 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             1
# 10367 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
     }
 }

      free (extversym);
      free (isymbuf);
    }

  return 
# 10375 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 10375 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}



static int
elf_link_convert_common_type (struct bfd_link_info *info, int type)
{

  if (!((info)->type == type_relocatable))
    _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 10385, __PRETTY_FUNCTION__);
  switch (info->elf_stt_common)
    {
    case unchanged:
      break;
    case elf_stt_common:
      type = 5;
      break;
    case no_elf_stt_common:
      type = 1;
      break;
    }
  return type;
}
# 10407 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
static 
# 10407 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 10408 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_output_extsym (struct bfd_hash_entry *bh, void *data)
{
  struct elf_link_hash_entry *h = (struct elf_link_hash_entry *) bh;
  struct elf_outext_info *eoinfo = (struct elf_outext_info *) data;
  struct elf_final_link_info *flinfo = eoinfo->flinfo;
  
# 10413 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 10413 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      strip;
  Elf_Internal_Sym sym;
  asection *input_sec;
  const struct elf_backend_data *bed;
  long indx;
  int ret;
  unsigned int type;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
 return 
# 10425 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 10425 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
    }


  if (eoinfo->localsyms)
    {
      if (!h->forced_local)
 return 
# 10432 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 10432 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
    }
  else
    {
      if (h->forced_local)
 return 
# 10437 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 10437 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
    }

  bed = ((const struct elf_backend_data *) ((flinfo->output_bfd)->xvec)->backend_data);

  if (h->root.type == bfd_link_hash_undefined)
    {





      
# 10449 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 10449 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          ignore_undef = 
# 10449 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         0
# 10449 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                              ;



      if (bed->elf_backend_ignore_undef_symbol)
 ignore_undef = bed->elf_backend_ignore_undef_symbol (h);


      if (!ignore_undef
   && h->ref_dynamic_nonweak
   && (!h->ref_regular || flinfo->info->gc_sections)
   && !elf_link_check_versioned_symbol (flinfo->info, bed, h)
   && flinfo->info->unresolved_syms_in_shared_libs != RM_IGNORE)
 {
   flinfo->info->callbacks->undefined_symbol
     (flinfo->info, h->root.root.string,
      h->ref_regular ? 
# 10465 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0) 
# 10465 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           : h->root.u.undef.abfd, 
# 10465 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                   ((void *)0)
# 10465 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                       , 0,
      flinfo->info->unresolved_syms_in_shared_libs == RM_DIAGNOSE
      && !flinfo->info->warn_unresolved_syms);
 }


      if (h->indx == -3)
 return 
# 10472 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 10472 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
    }



  if ((((flinfo->info)->type == type_pde) || ((flinfo->info)->type == type_pie))
      && h->forced_local
      && h->ref_dynamic
      && h->def_regular
      && !h->dynamic_def
      && h->ref_dynamic_nonweak
      && !elf_link_check_versioned_symbol (flinfo->info, bed, h))
    {
      bfd *def_bfd;
      const char *msg;
      struct elf_link_hash_entry *hi = h;


      while (hi->root.type == bfd_link_hash_indirect)
 hi = (struct elf_link_hash_entry *) hi->root.u.i.link;

      if (((h->other) & 0x3) == 1)

 msg = dgettext ("bfd", "%pB: internal symbol `%s' in %pB is referenced by DSO");
      else if (((h->other) & 0x3) == 2)

 msg = dgettext ("bfd", "%pB: hidden symbol `%s' in %pB is referenced by DSO");
      else

 msg = dgettext ("bfd", "%pB: local symbol `%s' in %pB is referenced by DSO");
      def_bfd = flinfo->output_bfd;
      if (hi->root.u.def.section != (&_bfd_std_section[2]))
 def_bfd = hi->root.u.def.section->owner;
      _bfd_error_handler (msg, flinfo->output_bfd,
     h->root.root.string, def_bfd);
      bfd_set_error (bfd_error_bad_value);
      eoinfo->failed = 
# 10508 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      1
# 10508 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          ;
      return 
# 10509 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 10509 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }





  strip = 
# 10516 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 10516 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  if (h->indx == -2)
    ;
  else if ((h->def_dynamic
     || h->ref_dynamic
     || h->root.type == bfd_link_hash_new)
    && !h->def_regular
    && !h->ref_regular)
    strip = 
# 10524 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 10524 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  else if (flinfo->info->strip == strip_all)
    strip = 
# 10526 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 10526 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  else if (flinfo->info->strip == strip_some
    && bfd_hash_lookup (flinfo->info->keep_hash,
          h->root.root.string, 
# 10529 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              0
# 10529 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   , 
# 10529 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     0
# 10529 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          ) == 
# 10529 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                               ((void *)0)
# 10529 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                   )
    strip = 
# 10530 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 10530 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  else if ((h->root.type == bfd_link_hash_defined
     || h->root.type == bfd_link_hash_defweak)
    && ((flinfo->info->strip_discarded
  && discarded_section (h->root.u.def.section))
        || ((h->root.u.def.section->flags & 0x100000) == 0
     && h->root.u.def.section->owner != 
# 10536 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
     
# 10537 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
    && (h->root.u.def.section->owner->flags & 0x10000) != 0)))
    strip = 
# 10538 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 10538 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  else if ((h->root.type == bfd_link_hash_undefined
     || h->root.type == bfd_link_hash_undefweak)
    && h->root.u.undef.abfd != 
# 10541 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
    
# 10542 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && (h->root.u.undef.abfd->flags & 0x10000) != 0)
    strip = 
# 10543 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 10543 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  type = h->type;





  if (strip
      && h->dynindx == -1
      && type != 10
      && !h->forced_local)
    return 
# 10555 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 10555 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  sym.st_value = 0;
  sym.st_size = h->size;
  sym.st_other = h->other;
  switch (h->root.type)
    {
    default:
    case bfd_link_hash_new:
    case bfd_link_hash_warning:
      _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 10565, __PRETTY_FUNCTION__);
      return 
# 10566 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 10566 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      input_sec = (&_bfd_std_section[1]);
      sym.st_shndx = 0;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
 input_sec = h->root.u.def.section;
 if (input_sec->output_section != 
# 10578 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 ((void *)0)
# 10578 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                     )
   {
     sym.st_shndx =
       _bfd_elf_section_from_bfd_section (flinfo->output_bfd,
       input_sec->output_section);
     if (sym.st_shndx == (-0x101u))
       {
  _bfd_error_handler

    (dgettext ("bfd", "%pB: could not find output section %pA for input section %pA"),
     flinfo->output_bfd, input_sec->output_section, input_sec);
  bfd_set_error (bfd_error_nonrepresentable_section);
  eoinfo->failed = 
# 10590 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 10590 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
  return 
# 10591 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 10591 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
       }




     sym.st_value = h->root.u.def.value + input_sec->output_offset;
     if (!((flinfo->info)->type == type_relocatable))
       {
  sym.st_value += input_sec->output_section->vma;
  if (h->type == 6)
    {
      asection *tls_sec = elf_hash_table (flinfo->info)->tls_sec;
      if (tls_sec != 
# 10604 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 10604 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        )
        sym.st_value -= tls_sec->vma;
    }
       }
   }
 else
   {
     do { if (!(input_sec->owner == 
# 10611 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
    ((void *)0) 
# 10611 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
    || (input_sec->owner->flags & 0x40) != 0)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",10611); } while (0)
                                               ;
     sym.st_shndx = 0;
     input_sec = (&_bfd_std_section[1]);
   }
      }
      break;

    case bfd_link_hash_common:
      input_sec = h->root.u.c.p->section;
      sym.st_shndx = bed->common_section_index (input_sec);
      sym.st_value = 1 << h->root.u.c.p->alignment_power;
      break;

    case bfd_link_hash_indirect:






      return 
# 10632 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 10632 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }

  if (type == 5 || type == 1)
    switch (h->root.type)
      {
      case bfd_link_hash_common:
 type = elf_link_convert_common_type (flinfo->info, type);
 break;
      case bfd_link_hash_defined:
      case bfd_link_hash_defweak:
 if (bed->common_definition (&sym))
   type = elf_link_convert_common_type (flinfo->info, type);
 else
   type = 1;
 break;
      case bfd_link_hash_undefined:
      case bfd_link_hash_undefweak:
 break;
      default:
 _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 10652, __PRETTY_FUNCTION__);
      }

  if (h->forced_local)
    {
      sym.st_info = (((0) << 4) + ((type) & 0xF));

      sym.st_other &= ~((-1) & 0x3);
    }

  else if (h->unique_global && h->def_regular)
    sym.st_info = (((10) << 4) + ((type) & 0xF));
  else if (h->root.type == bfd_link_hash_undefweak
    || h->root.type == bfd_link_hash_defweak)
    sym.st_info = (((2) << 4) + ((type) & 0xF));
  else
    sym.st_info = (((1) << 4) + ((type) & 0xF));
  sym.st_target_internal = h->target_internal;






  if ((h->type == 10
       && h->def_regular
       && !((flinfo->info)->type == type_relocatable))
      || ((h->dynindx != -1
    || h->forced_local)
   && (((((flinfo->info)->type == type_dll) || ((flinfo->info)->type == type_pie))
        && (((h->other) & 0x3) == 0
     || h->root.type != bfd_link_hash_undefweak))
       || !h->forced_local)
   && elf_hash_table (flinfo->info)->dynamic_sections_created))
    {
      if (! ((*bed->elf_backend_finish_dynamic_symbol)
      (flinfo->output_bfd, flinfo->info, h, &sym)))
 {
   eoinfo->failed = 
# 10690 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   1
# 10690 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
   return 
# 10691 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 10691 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }
    }







  if (sym.st_shndx == 0
      && h->ref_regular
      && ((((unsigned int)(sym.st_info)) >> 4) == 1
   || (((unsigned int)(sym.st_info)) >> 4) == 2))
    {
      int bindtype;
      type = ((sym.st_info) & 0xF);


      if (type == 10)
 type = 2;

      if (h->ref_regular_nonweak)
 bindtype = 1;
      else
 bindtype = 2;
      sym.st_info = (((bindtype) << 4) + ((type) & 0xF));
    }





  if (sym.st_shndx == 0
      && !h->def_regular
      && h->def_dynamic)
    sym.st_size = 0;



  if (!((flinfo->info)->type == type_relocatable)
      && ((sym.st_other) & 0x3) != 0
      && (((unsigned int)(sym.st_info)) >> 4) != 2
      && h->root.type == bfd_link_hash_undefined
      && !h->def_regular)
    {
      const char *msg;

      if (((sym.st_other) & 0x3) == 3)

 msg = dgettext ("bfd", "%pB: protected symbol `%s' isn't defined");
      else if (((sym.st_other) & 0x3) == 1)

 msg = dgettext ("bfd", "%pB: internal symbol `%s' isn't defined");
      else

 msg = dgettext ("bfd", "%pB: hidden symbol `%s' isn't defined");
      _bfd_error_handler (msg, flinfo->output_bfd, h->root.root.string);
      bfd_set_error (bfd_error_bad_value);
      eoinfo->failed = 
# 10750 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      1
# 10750 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          ;
      return 
# 10751 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 10751 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }




  if (h->dynindx != -1
      && elf_hash_table (flinfo->info)->dynamic_sections_created
      && elf_hash_table (flinfo->info)->dynsym != 
# 10759 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                 ((void *)0)
      
# 10760 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && !discarded_section (elf_hash_table (flinfo->info)->dynsym))
    {
      bfd_byte *esym;





      if (h->verinfo.verdef == 
# 10768 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
   
# 10769 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && (!(((flinfo->info)->type == type_pde) || ((flinfo->info)->type == type_pie))
       || h->ref_dynamic
       || !h->def_regular))
 {
   char *p = strrchr (h->root.root.string, '@');

   if (p && p [1] != '\0')
     {
       _bfd_error_handler

  (dgettext ("bfd", "%pB: no symbol version section for versioned symbol `%s'"),
   flinfo->output_bfd, h->root.root.string);
       eoinfo->failed = 
# 10781 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 10781 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
       return 
# 10782 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 10782 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
 }

      sym.st_name = h->dynstr_index;
      esym = (elf_hash_table (flinfo->info)->dynsym->contents
       + h->dynindx * bed->s->sizeof_sym);
      if (!check_dynsym (flinfo->output_bfd, &sym))
 {
   eoinfo->failed = 
# 10791 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   1
# 10791 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
   return 
# 10792 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 10792 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }



      if (flinfo->info->callbacks->ctf_new_dynsym)
 flinfo->info->callbacks->ctf_new_dynsym (h->dynindx, &sym);

      bed->s->swap_symbol_out (flinfo->output_bfd, &sym, esym, 0);

      if (flinfo->hash_sec != 
# 10802 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
# 10802 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 )
 {
   size_t hash_entry_size;
   bfd_byte *bucketpos;
   bfd_vma chain;
   size_t bucketcount;
   size_t bucket;

   bucketcount = elf_hash_table (flinfo->info)->bucketcount;
   bucket = h->u.elf_hash_value % bucketcount;

   hash_entry_size
     = ((struct bfd_elf_section_data*)(flinfo->hash_sec)->used_by_bfd)->this_hdr.sh_entsize;
   bucketpos = ((bfd_byte *) flinfo->hash_sec->contents
         + (bucket + 2) * hash_entry_size);
   chain = ((8 * hash_entry_size) == 8 ? ((bfd_vma) *(const bfd_byte *) (bucketpos) & 0xff) : (8 * hash_entry_size) == 16 ? ((*((flinfo->output_bfd)->xvec->bfd_getx16)) (bucketpos)) : (8 * hash_entry_size) == 32 ? ((*((flinfo->output_bfd)->xvec->bfd_getx32)) (bucketpos)) : (8 * hash_entry_size) == 64 ? ((*((flinfo->output_bfd)->xvec->bfd_getx64)) (bucketpos)) : (_bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 10817, __PRETTY_FUNCTION__), (bfd_vma) - 1));
   ((8 * hash_entry_size) == 8 ? ((void) (*((bfd_byte *) (bucketpos)) = (h->dynindx) & 0xff)) : (8 * hash_entry_size) == 16 ? ((*((flinfo->output_bfd)->xvec->bfd_putx16)) ((h->dynindx),(bucketpos))) : (8 * hash_entry_size) == 32 ? ((*((flinfo->output_bfd)->xvec->bfd_putx32)) ((h->dynindx),(bucketpos))) : (8 * hash_entry_size) == 64 ? ((*((flinfo->output_bfd)->xvec->bfd_putx64)) ((h->dynindx), (bucketpos))) : (_bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 10818, __PRETTY_FUNCTION__), (void) 0))
               ;
   ((8 * hash_entry_size) == 8 ? ((void) (*((bfd_byte *) (((bfd_byte *) flinfo->hash_sec->contents + (bucketcount + 2 + h->dynindx) * hash_entry_size))) = (chain) & 0xff)) : (8 * hash_entry_size) == 16 ? ((*((flinfo->output_bfd)->xvec->bfd_putx16)) ((chain),(((bfd_byte *) flinfo->hash_sec->contents + (bucketcount + 2 + h->dynindx) * hash_entry_size)))) : (8 * hash_entry_size) == 32 ? ((*((flinfo->output_bfd)->xvec->bfd_putx32)) ((chain),(((bfd_byte *) flinfo->hash_sec->contents + (bucketcount + 2 + h->dynindx) * hash_entry_size)))) : (8 * hash_entry_size) == 64 ? ((*((flinfo->output_bfd)->xvec->bfd_putx64)) ((chain), (((bfd_byte *) flinfo->hash_sec->contents + (bucketcount + 2 + h->dynindx) * hash_entry_size)))) : (_bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 10820, __PRETTY_FUNCTION__), (void) 0))

                                                          ;
 }

      if (flinfo->symver_sec != 
# 10825 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0) 
# 10825 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    && flinfo->symver_sec->contents != 
# 10825 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                                       ((void *)0)
# 10825 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                           )
 {
   Elf_Internal_Versym iversym;
   Elf_External_Versym *eversym;

   if (!h->def_regular && !(!(h)->def_regular && !(h)->def_dynamic && (h)->root.type == bfd_link_hash_defined))
     {
       if (h->verinfo.verdef == 
# 10832 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
    
# 10833 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   || ((((h->verinfo.verdef->vd_bfd) -> tdata.elf_obj_data) -> dyn_lib_class)
        & (DYN_AS_NEEDED | DYN_DT_NEEDED | DYN_NO_NEEDED)))
  iversym.vs_vers = 1;
       else
  iversym.vs_vers = h->verinfo.verdef->vd_exp_refno + 1;
     }
   else
     {
       if (h->verinfo.vertree == 
# 10841 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
# 10841 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    )
  iversym.vs_vers = 1;
       else
  iversym.vs_vers = h->verinfo.vertree->vernum + 1;
       if (flinfo->info->create_default_symver)
  iversym.vs_vers++;
     }



   if (h->versioned == versioned_hidden && h->def_regular)
     iversym.vs_vers |= 0x8000;

   eversym = (Elf_External_Versym *) flinfo->symver_sec->contents;
   eversym += h->dynindx;
   _bfd_elf_swap_versym_out (flinfo->output_bfd, &iversym, eversym);
 }
    }




  else if (input_sec == (&_bfd_std_section[1])
    && h->indx != -2

    && (h->mark != 1 || (((unsigned int)(sym.st_info)) >> 4) != 1)
    && !((flinfo->info)->type == type_relocatable))
    return 
# 10868 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 10868 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;



  if (strip)
    return 
# 10873 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 10873 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
  if ((input_sec->flags & 0x8000) != 0)
    return 
# 10875 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 10875 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
# 10884 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if (eoinfo->localsyms
      && !eoinfo->file_sym_done
      && eoinfo->flinfo->filesym_count != 0)
    {
      Elf_Internal_Sym fsym;

      memset (&fsym, 0, sizeof (fsym));
      fsym.st_info = (((0) << 4) + ((4) & 0xF));
      fsym.st_shndx = (-0xFu);
      if (!elf_link_output_symstrtab (eoinfo->flinfo, 
# 10893 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                     ((void *)0)
# 10893 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                         , &fsym,
          (&_bfd_std_section[1]), 
# 10894 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
# 10894 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                  ))
 return 
# 10895 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 10895 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

      eoinfo->file_sym_done = 
# 10897 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             1
# 10897 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 ;
    }

  indx = bfd_get_symcount (flinfo->output_bfd);
  ret = elf_link_output_symstrtab (flinfo, h->root.root.string, &sym,
       input_sec, h);
  if (ret == 0)
    {
      eoinfo->failed = 
# 10905 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      1
# 10905 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          ;
      return 
# 10906 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 10906 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }
  else if (ret == 1)
    h->indx = indx;
  else if (h->indx == -2)
    _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 10911, __PRETTY_FUNCTION__);

  return 
# 10913 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 10913 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




static 
# 10919 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 10920 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_section_ignore_discarded_relocs (asection *sec)
{
  const struct elf_backend_data *bed;

  switch (sec->sec_info_type)
    {
    case 1:
    case 3:
    case 6:
    case 7:
      return 
# 10930 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 10930 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    default:
      break;
    }

  bed = ((const struct elf_backend_data *) ((sec->owner)->xvec)->backend_data);
  if (bed->elf_backend_ignore_discarded_relocs != 
# 10936 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                 ((void *)0)
      
# 10937 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && (*bed->elf_backend_ignore_discarded_relocs) (sec))
    return 
# 10938 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 10938 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  return 
# 10940 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 10940 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}
# 10952 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
unsigned int
_bfd_elf_default_action_discarded (asection *sec)
{
  const struct elf_backend_data *bed;
  bed = ((const struct elf_backend_data *) ((sec->owner)->xvec)->backend_data);

  if (sec->flags & 0x2000)
    return PRETEND;

  if (strcmp (".eh_frame", sec->name) == 0)
    return 0;

  if (bed->elf_backend_can_make_multiple_eh_frame
      && strncmp (sec->name, ".eh_frame.", 10) == 0)
    return 0;

  if (strcmp (".sframe", sec->name) == 0)
    return 0;

  if (strcmp (".gcc_except_table", sec->name) == 0)
    return 0;

  return COMPLAIN | PRETEND;
}



static asection *
match_group_member (asection *sec, asection *group,
      struct bfd_link_info *info)
{
  asection *first = (((struct bfd_elf_section_data*)(group)->used_by_bfd)->next_in_group);
  asection *s = first;

  while (s != 
# 10986 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 10986 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
    {
      if (bfd_elf_match_symbols_in_sections (s, sec, info))
 return s;

      s = (((struct bfd_elf_section_data*)(s)->used_by_bfd)->next_in_group);
      if (s == first)
 break;
    }

  return 
# 10996 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 10996 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





asection *
_bfd_elf_check_kept_section (asection *sec, struct bfd_link_info *info)
{
  asection *kept;

  kept = sec->kept_section;
  if (kept != 
# 11009 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 11009 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
    {
      if ((kept->flags & 0x2000000) != 0)
 kept = match_group_member (sec, kept, info);
      if (kept != 
# 11013 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 11013 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
 {
   if ((sec->rawsize != 0 ? sec->rawsize : sec->size)
       != (kept->rawsize != 0 ? kept->rawsize : kept->size))
     kept = 
# 11017 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 11017 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
   else
     {

       asection *next;
       for (next = kept->kept_section;
     next != 
# 11023 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 11023 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
     next = next->kept_section)
  kept = next;
     }
 }
      sec->kept_section = kept;
    }
  return kept;
}






static 
# 11038 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 11039 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_link_input_bfd (struct elf_final_link_info *flinfo, bfd *input_bfd)
{
  int (*relocate_section)
    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
     Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
  bfd *output_bfd;
  Elf_Internal_Shdr *symtab_hdr;
  size_t locsymcount;
  size_t extsymoff;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  long *pindex;
  asection **ppsection;
  asection *o;
  const struct elf_backend_data *bed;
  struct elf_link_hash_entry **sym_hashes;
  bfd_size_type address_size;
  bfd_vma r_type_mask;
  int r_sym_shift;
  
# 11059 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 11059 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      have_file_sym = 
# 11059 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      0
# 11059 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;

  output_bfd = flinfo->output_bfd;
  bed = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);
  relocate_section = bed->elf_backend_relocate_section;




  if ((input_bfd->flags & 0x40) != 0)
    return 
# 11069 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 11069 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  symtab_hdr = &((input_bfd) -> tdata.elf_obj_data)->symtab_hdr;
  if ((((input_bfd) -> tdata.elf_obj_data) -> bad_symtab))
    {
      locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      extsymoff = 0;
    }
  else
    {
      locsymcount = symtab_hdr->sh_info;
      extsymoff = symtab_hdr->sh_info;
    }



  if (bed->elf_osabi == 0
      || bed->elf_osabi == 3
      || bed->elf_osabi == 9)
    ((output_bfd) -> tdata.elf_obj_data)->has_gnu_osabi
      |= (((input_bfd) -> tdata.elf_obj_data)->has_gnu_osabi
   & (((flinfo->info)->type == type_relocatable)
      ? -1 : ~elf_gnu_osabi_retain));


  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (isymbuf == 
# 11095 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0) 
# 11095 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     && locsymcount != 0)
    {
      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
          flinfo->internal_syms,
          flinfo->external_syms,
          flinfo->locsym_shndx);
      if (isymbuf == 
# 11101 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 11101 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        )
 return 
# 11102 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 11102 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }




  isymend = ((locsymcount) != 0 ? (isymbuf) + (locsymcount) : (isymbuf));
  for (isym = isymbuf, pindex = flinfo->indices, ppsection = flinfo->sections;
       isym < isymend;
       isym++, pindex++, ppsection++)
    {
      asection *isec;
      const char *name;
      Elf_Internal_Sym osym;
      long indx;
      int ret;

      *pindex = -1;

      if ((((input_bfd) -> tdata.elf_obj_data) -> bad_symtab))
 {
   if ((((unsigned int)(isym->st_info)) >> 4) != 0)
     {
       *ppsection = 
# 11125 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 11125 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
       continue;
     }
 }

      if (isym->st_shndx == 0)
 isec = (&_bfd_std_section[1]);
      else if (isym->st_shndx == (-0xFu))
 isec = (&_bfd_std_section[2]);
      else if (isym->st_shndx == (-0xEu))
 isec = (&_bfd_std_section[0]);
      else
 {
   isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);
   if (isec == 
# 11139 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 11139 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
     {


       isec = (&_bfd_std_section[1]);
     }
   else if (isec->sec_info_type == 2
     && ((isym->st_info) & 0xF) != 3)
     isym->st_value =
       _bfd_merged_section_offset (output_bfd, &isec,
       ((struct bfd_elf_section_data*)(isec)->used_by_bfd)->sec_info,
       isym->st_value);
 }

      *ppsection = isec;



      if (isec == (&_bfd_std_section[1]))
 continue;

      if (((isym->st_info) & 0xF) == 3)
 {



   continue;
 }



      if (flinfo->info->strip == strip_all)
 continue;






      if (flinfo->info->discard == discard_all)
 continue;



      if (isym->st_shndx < (-0x100u)
   && (isec->output_section == 
# 11184 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
       
# 11185 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      || bfd_section_removed_from_list (output_bfd,
      isec->output_section)))
 continue;


      name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link,
           isym->st_name);
      if (name == 
# 11192 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 11192 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
 return 
# 11193 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 11193 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;


      if ((flinfo->info->strip == strip_some
    && (bfd_hash_lookup (flinfo->info->keep_hash, name, 
# 11197 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                       0
# 11197 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                            , 
# 11197 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                              0
# 11197 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                   )
        == 
# 11198 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 11198 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ))
   || (((flinfo->info->discard == discard_sec_merge
  && (isec->flags & 0x800000)
  && !((flinfo->info)->type == type_relocatable))
        || flinfo->info->discard == discard_l)
       && ((*((input_bfd)->xvec->_bfd_is_local_label_name)) (input_bfd, name))))
 continue;

      if (((isym->st_info) & 0xF) == 4)
 {
   if (input_bfd->lto_output)


     continue;
   have_file_sym = 
# 11212 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 11212 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
   flinfo->filesym_count += 1;
 }
      if (!have_file_sym)
 {






   const char *filename;
   have_file_sym = 
# 11224 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 11224 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
   flinfo->filesym_count += 1;
   memset (&osym, 0, sizeof (osym));
   osym.st_info = (((0) << 4) + ((4) & 0xF));
   osym.st_shndx = (-0xFu);
   if (input_bfd->lto_output)
     filename = 
# 11230 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 11230 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
   else
     filename = lbasename (bfd_get_filename (input_bfd));
   if (!elf_link_output_symstrtab (flinfo, filename, &osym,
       (&_bfd_std_section[2]), 
# 11234 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 11234 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               ))
     return 
# 11235 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 11235 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      osym = *isym;


      osym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
        isec->output_section);
      if (osym.st_shndx == (-0x101u))
 return 
# 11244 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 11244 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
# 11253 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      osym.st_value += isec->output_offset;
      if (!((flinfo->info)->type == type_relocatable))
 {
   osym.st_value += isec->output_section->vma;
   if (((osym.st_info) & 0xF) == 6)
     {

       if (elf_hash_table (flinfo->info)->tls_sec != 
# 11260 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                    ((void *)0)
# 11260 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                        )
  osym.st_value -= elf_hash_table (flinfo->info)->tls_sec->vma;
       else
  osym.st_info = ((((((unsigned int)(osym.st_info)) >> 4)) << 4) + ((0) & 0xF))
                    ;
     }
 }

      indx = bfd_get_symcount (output_bfd);
      ret = elf_link_output_symstrtab (flinfo, name, &osym, isec, 
# 11269 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                                 ((void *)0)
# 11269 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                     );
      if (ret == 0)
 return 
# 11271 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 11271 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      else if (ret == 1)
 *pindex = indx;
    }

  if (bed->s->arch_size == 32)
    {
      r_type_mask = 0xff;
      r_sym_shift = 8;
      address_size = 4;
    }
  else
    {
      r_type_mask = 0xffffffff;
      r_sym_shift = 32;
      address_size = 8;
    }


  sym_hashes = (((input_bfd) -> tdata.elf_obj_data) -> sym_hashes);
  for (o = input_bfd->sections; o != 
# 11291 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                    ((void *)0)
# 11291 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                        ; o = o->next)
    {
      bfd_byte *contents;

      if (! o->linker_mark)
 {

   continue;
 }

      if (!flinfo->info->resolve_section_groups
   && (o->flags & (0x100000 | 0x2000000)) == 0x2000000)
 {

   struct bfd_elf_section_data *sec_data = ((struct bfd_elf_section_data*)(o)->used_by_bfd);
   unsigned long symndx = sec_data->this_hdr.sh_info;
   asection *osec = o->output_section;

   do { if (!(((flinfo->info)->type == type_relocatable))) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",11309); } while (0);
   if (symndx >= locsymcount
       || ((((input_bfd) -> tdata.elf_obj_data) -> bad_symtab)
    && flinfo->sections[symndx] == 
# 11312 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 11312 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ))
     {
       struct elf_link_hash_entry *h = sym_hashes[symndx - extsymoff];
       while (h->root.type == bfd_link_hash_indirect
       || h->root.type == bfd_link_hash_warning)
  h = (struct elf_link_hash_entry *) h->root.u.i.link;

       h->indx = -2;
       ((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr.sh_info = -2;
     }
   else if (((isymbuf[symndx].st_info) & 0xF) == 3)
     {

       asection *sec = flinfo->sections[symndx]->output_section;
       ((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr.sh_info = sec->target_index;
     }
   else
     {
       if (flinfo->indices[symndx] == -1)
  {

    Elf_Internal_Sym sym = isymbuf[symndx];
    asection *sec = flinfo->sections[symndx]->output_section;
    const char *name;
    long indx;
    int ret;

    name = bfd_elf_string_from_elf_section (input_bfd,
         symtab_hdr->sh_link,
         sym.st_name);
    if (name == 
# 11342 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 11342 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
      return 
# 11343 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 11343 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;

    sym.st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
            sec);
    if (sym.st_shndx == (-0x101u))
      return 
# 11348 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 11348 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;

    sym.st_value += o->output_offset;

    indx = bfd_get_symcount (output_bfd);
    ret = elf_link_output_symstrtab (flinfo, name, &sym, o,
         
# 11354 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 11354 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            );
    if (ret == 0)
      return 
# 11356 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 11356 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    else if (ret == 1)
      flinfo->indices[symndx] = indx;
    else
      _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 11360, __PRETTY_FUNCTION__);
  }
       ((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr.sh_info
  = flinfo->indices[symndx];
     }
 }

      if ((o->flags & 0x100) == 0
   || (o->size == 0 && (o->flags & 0x4) == 0))
 continue;

      if ((o->flags & 0x100000) != 0)
 {


   continue;
 }





      if (((struct bfd_elf_section_data*)(o)->used_by_bfd)->this_hdr.contents != 
# 11382 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                    ((void *)0)
# 11382 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                        )
 {
   contents = ((struct bfd_elf_section_data*)(o)->used_by_bfd)->this_hdr.contents;
   if (bed->caches_rawsize
       && o->rawsize != 0
       && o->rawsize < o->size)
     {
       memcpy (flinfo->contents, contents, o->rawsize);
       contents = flinfo->contents;
     }
 }
      else if (!(o->flags & 0x4)
        && !bed->elf_backend_write_section
        && o->sec_info_type == 2)



 contents = 
# 11399 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 11399 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
      else
 {
   contents = flinfo->contents;
   if (! bfd_get_full_section_contents (input_bfd, o, &contents))
     return 
# 11404 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 11404 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if ((o->flags & 0x4) != 0)
 {
   Elf_Internal_Rela *internal_relocs;
   Elf_Internal_Rela *rel, *relend;
   int action_discarded;
   int ret;


   internal_relocs
     = _bfd_elf_link_info_read_relocs (input_bfd, flinfo->info, o,
           flinfo->external_relocs,
           flinfo->internal_relocs,
           
# 11419 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 11419 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               );
   if (internal_relocs == 
# 11420 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
       
# 11421 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && o->reloc_count > 0)
     return 
# 11422 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 11422 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   action_discarded = -1;
   if (!elf_section_ignore_discarded_relocs (o))
     action_discarded = (*bed->action_discarded) (o);







   rel = internal_relocs;
   relend = rel + o->reloc_count;
   for ( ; rel < relend; rel++)
     {
       unsigned long r_symndx = rel->r_info >> r_sym_shift;
       unsigned int s_type;
       asection **ps, *sec;
       struct elf_link_hash_entry *h = 
# 11441 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
# 11441 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          ;
       const char *sym_name;

       if (r_symndx == 0)
  continue;

       if (r_symndx >= locsymcount
    || ((((input_bfd) -> tdata.elf_obj_data) -> bad_symtab)
        && flinfo->sections[r_symndx] == 
# 11449 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                        ((void *)0)
# 11449 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                            ))
  {
    h = sym_hashes[r_symndx - extsymoff];




    if (h == 
# 11456 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 11456 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                )
      {
        _bfd_error_handler

   (dgettext ("bfd", "error: %pB contains a reloc (%#" 
# 11460 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
   "l" "x" 
# 11460 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   ") for section %pA " "that references a non-existent global symbol")
                                                     ,
    input_bfd, (uint64_t) rel->r_info, o);
        bfd_set_error (bfd_error_bad_value);
        return 
# 11464 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              0
# 11464 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
      }

    while (h->root.type == bfd_link_hash_indirect
    || h->root.type == bfd_link_hash_warning)
      h = (struct elf_link_hash_entry *) h->root.u.i.link;

    s_type = h->type;






    if ((h->root.non_ir_ref_regular
         || h->root.non_ir_ref_dynamic)
        && (h->root.type == bfd_link_hash_defined
     || h->root.type == bfd_link_hash_defweak)
        && (h->root.u.def.section->flags
     & 0x100000) == 0
        && h->root.u.def.section->owner != 
# 11484 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
        
# 11485 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       && (h->root.u.def.section->owner->flags
     & 0x10000) != 0)
      {
        h->root.type = bfd_link_hash_undefined;
        h->root.u.undef.abfd = h->root.u.def.section->owner;
      }

    ps = 
# 11492 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 11492 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    if (h->root.type == bfd_link_hash_defined
        || h->root.type == bfd_link_hash_defweak)
      ps = &h->root.u.def.section;

    sym_name = h->root.root.string;
  }
       else
  {
    Elf_Internal_Sym *sym = isymbuf + r_symndx;

    s_type = ((sym->st_info) & 0xF);
    ps = &flinfo->sections[r_symndx];
    sym_name = bfd_elf_sym_name (input_bfd, symtab_hdr,
            sym, *ps);
  }

       if ((s_type == 8 || s_type == 9)
    && !((flinfo->info)->type == type_relocatable))
  {
    bfd_vma val;
    bfd_vma dot = (rel->r_offset
     + o->output_offset + o->output_section->vma);
# 11526 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
    if (!eval_symbol (&val, &sym_name, input_bfd, flinfo, dot,
        isymbuf, locsymcount, s_type == 9))
      return 
# 11528 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 11528 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;


    set_symbol_value (input_bfd, isymbuf, locsymcount,
        r_symndx, val);
    continue;
  }

       if (action_discarded != -1 && ps != 
# 11536 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 11536 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              )
  {


    if ((sec = *ps) != 
# 11540 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0) 
# 11540 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           && discarded_section (sec))
      {
        do { if (!(r_symndx != 0)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",11542); } while (0);
        if (action_discarded & COMPLAIN)
   (*flinfo->info->callbacks->einfo)

     (dgettext ("bfd", "%X`%s' referenced in section `%pA' of %pB: " "defined in discarded section `%pA' of %pB\n")
                                                      ,
      sym_name, o, input_bfd, sec, sec->owner);







        if (action_discarded & PRETEND)
   {
     asection *kept;

     kept = _bfd_elf_check_kept_section (sec,
             flinfo->info);
     if (kept != 
# 11562 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 11562 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
       {
         *ps = kept;
         continue;
       }
   }
      }
  }
     }
# 11592 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   ret = (*relocate_section) (output_bfd, flinfo->info,
         input_bfd, o, contents,
         internal_relocs,
         isymbuf,
         flinfo->sections);
   if (!ret)
     return 
# 11598 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 11598 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   if (ret == 2
       || ((flinfo->info)->type == type_relocatable)
       || flinfo->info->emitrelocations)
     {
       Elf_Internal_Rela *irela;
       Elf_Internal_Rela *irelaend, *irelamid;
       bfd_vma last_offset;
       struct elf_link_hash_entry **rel_hash;
       struct elf_link_hash_entry **rel_hash_list, **rela_hash_list;
       Elf_Internal_Shdr *input_rel_hdr, *input_rela_hdr;
       unsigned int next_erel;
       
# 11611 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool 
# 11611 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           rela_normal;
       struct bfd_elf_section_data *esdi, *esdo;

       esdi = ((struct bfd_elf_section_data*)(o)->used_by_bfd);
       esdo = ((struct bfd_elf_section_data*)(o->output_section)->used_by_bfd);
       rela_normal = 
# 11616 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 11616 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;



       irela = internal_relocs;
       irelaend = irela + o->reloc_count;
       rel_hash = ((esdo->rel.count) != 0 ? (esdo->rel.hashes) + (esdo->rel.count) : (esdo->rel.hashes));


       irelamid = irela;
       if (esdi->rel.hdr != 
# 11626 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 11626 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
  irelamid += (((esdi->rel.hdr)->sh_entsize > 0 ? (esdi->rel.hdr)->sh_size / (esdi->rel.hdr)->sh_entsize : 0)
        * bed->s->int_rels_per_ext_rel);
       rel_hash_list = rel_hash;
       rela_hash_list = 
# 11630 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       ((void *)0)
# 11630 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
       last_offset = o->output_offset;
       if (!((flinfo->info)->type == type_relocatable))
  last_offset += o->output_section->vma;
       for (next_erel = 0; irela < irelaend; irela++, next_erel++)
  {
    unsigned long r_symndx;
    asection *sec;
    Elf_Internal_Sym sym;

    if (next_erel == bed->s->int_rels_per_ext_rel)
      {
        rel_hash++;
        next_erel = 0;
      }

    if (irela == irelamid)
      {
        rel_hash = ((esdo->rela.count) != 0 ? (esdo->rela.hashes) + (esdo->rela.count) : (esdo->rela.hashes));
        rela_hash_list = rel_hash;
        rela_normal = bed->rela_normal;
      }

    irela->r_offset = _bfd_elf_section_offset (output_bfd,
            flinfo->info, o,
            irela->r_offset);
    if (irela->r_offset >= (bfd_vma) -2)
      {





        irela->r_offset = last_offset;
        irela->r_info = 0;
        irela->r_addend = 0;
        continue;
      }

    irela->r_offset += o->output_offset;


    if (!((flinfo->info)->type == type_relocatable))
      irela->r_offset += o->output_section->vma;

    last_offset = irela->r_offset;

    r_symndx = irela->r_info >> r_sym_shift;
    if (r_symndx == 0)
      continue;

    if (r_symndx >= locsymcount
        || ((((input_bfd) -> tdata.elf_obj_data) -> bad_symtab)
     && flinfo->sections[r_symndx] == 
# 11683 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 11683 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ))
      {
        struct elf_link_hash_entry *rh;
        unsigned long indx;
# 11695 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        indx = r_symndx - extsymoff;
        rh = (((input_bfd) -> tdata.elf_obj_data) -> sym_hashes)[indx];
        while (rh->root.type == bfd_link_hash_indirect
        || rh->root.type == bfd_link_hash_warning)
   rh = (struct elf_link_hash_entry *) rh->root.u.i.link;




        do { if (!(rh->indx < 0)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",11704); } while (0);
        rh->indx = -2;
        *rel_hash = rh;

        continue;
      }



    *rel_hash = 
# 11713 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 11713 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
    sym = isymbuf[r_symndx];
    sec = flinfo->sections[r_symndx];
    if (((sym.st_info) & 0xF) == 3)
      {



        r_symndx = 0;
        if (bfd_is_abs_section (sec))
   ;
        else if (sec == 
# 11724 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       ((void *)0) 
# 11724 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                            || sec->owner == 
# 11724 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             ((void *)0)
# 11724 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                 )
   {
     bfd_set_error (bfd_error_bad_value);
     return 
# 11727 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 11727 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   }
        else
   {
     asection *osec = sec->output_section;







     if (bfd_is_abs_section (osec)
         && sec->kept_section != 
# 11740 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
         
# 11741 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        && sec->kept_section->output_section != 
# 11741 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                ((void *)0)
# 11741 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                    )
       {
         osec = sec->kept_section->output_section;
         irela->r_addend -= osec->vma;
       }

     if (!bfd_is_abs_section (osec))
       {
         r_symndx = osec->target_index;
         if (r_symndx == 0)
    {
      irela->r_addend += osec->vma;
      osec = _bfd_nearby_section (output_bfd, osec,
             osec->vma);
      irela->r_addend -= osec->vma;
      r_symndx = osec->target_index;
    }
       }
   }



        if (rela_normal)
   irela->r_addend += sec->output_offset;
      }
    else
      {
        if (flinfo->indices[r_symndx] == -1)
   {
     unsigned long shlink;
     const char *name;
     asection *osec;
     long indx;

     if (flinfo->info->strip == strip_all)
       {

         bfd_set_error (bfd_error_invalid_operation);
         return 
# 11779 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               0
# 11779 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;
       }




     shlink = symtab_hdr->sh_link;
     name = (bfd_elf_string_from_elf_section
      (input_bfd, shlink, sym.st_name));
     if (name == 
# 11788 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 11788 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
       return 
# 11789 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 11789 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;

     osec = sec->output_section;
     sym.st_shndx =
       _bfd_elf_section_from_bfd_section (output_bfd,
              osec);
     if (sym.st_shndx == (-0x101u))
       return 
# 11796 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 11796 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;

     sym.st_value += sec->output_offset;
     if (!((flinfo->info)->type == type_relocatable))
       {
         sym.st_value += osec->vma;
         if (((sym.st_info) & 0xF) == 6)
    {
      struct elf_link_hash_table *htab
        = elf_hash_table (flinfo->info);



      if (htab->tls_sec != 
# 11809 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0)
# 11809 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                              )
        sym.st_value -= htab->tls_sec->vma;
      else
        sym.st_info
          = ((((((unsigned int)(sym.st_info)) >> 4)) << 4) + ((0) & 0xF))
                      ;
    }
       }

     indx = bfd_get_symcount (output_bfd);
     ret = elf_link_output_symstrtab (flinfo, name,
          &sym, sec,
          
# 11821 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         ((void *)0)
# 11821 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             );
     if (ret == 0)
       return 
# 11823 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 11823 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     else if (ret == 1)
       flinfo->indices[r_symndx] = indx;
     else
       _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 11827, __PRETTY_FUNCTION__);
   }

        r_symndx = flinfo->indices[r_symndx];
      }

    irela->r_info = ((bfd_vma) r_symndx << r_sym_shift
       | (irela->r_info & r_type_mask));
  }


       input_rel_hdr = esdi->rel.hdr;
       if (input_rel_hdr && input_rel_hdr->sh_size != 0)
  {
    if (!bed->elf_backend_emit_relocs (output_bfd, o,
           input_rel_hdr,
           internal_relocs,
           rel_hash_list))
      return 
# 11845 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 11845 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    internal_relocs += (((input_rel_hdr)->sh_entsize > 0 ? (input_rel_hdr)->sh_size / (input_rel_hdr)->sh_entsize : 0)
          * bed->s->int_rels_per_ext_rel);
    rel_hash_list += ((input_rel_hdr)->sh_entsize > 0 ? (input_rel_hdr)->sh_size / (input_rel_hdr)->sh_entsize : 0);
  }

       input_rela_hdr = esdi->rela.hdr;
       if (input_rela_hdr && input_rela_hdr->sh_size != 0)
  {
    if (!bed->elf_backend_emit_relocs (output_bfd, o,
           input_rela_hdr,
           internal_relocs,
           rela_hash_list))
      return 
# 11858 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 11858 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
  }
     }
 }


      if (bed->elf_backend_write_section
   && (*bed->elf_backend_write_section) (output_bfd, flinfo->info, o,
      contents))
 {

 }
      else switch (o->sec_info_type)
 {
 case 1:
   if (! (_bfd_write_section_stabs
   (output_bfd,
    &elf_hash_table (flinfo->info)->stab_info,
    o, &((struct bfd_elf_section_data*)(o)->used_by_bfd)->sec_info, contents)))
     return 
# 11877 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 11877 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   break;
 case 2:
   if (! _bfd_write_merged_section (output_bfd, o,
        ((struct bfd_elf_section_data*)(o)->used_by_bfd)->sec_info))
     return 
# 11882 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 11882 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   break;
 case 3:
   {
     if (! _bfd_elf_write_section_eh_frame (output_bfd, flinfo->info,
         o, contents))
       return 
# 11888 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 11888 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
   }
   break;
 case 6:
   {
     if (! _bfd_elf_write_section_eh_frame_entry (output_bfd,
        flinfo->info,
        o, contents))
       return 
# 11896 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 11896 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
   }
   break;
 case 7:
     {



       if (!_bfd_elf_merge_section_sframe (output_bfd, flinfo->info,
        o, contents))
  return 
# 11906 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 11906 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
     }
     break;
 default:
   {
     if (! (o->flags & 0x8000))
       {
  file_ptr offset = (file_ptr) o->output_offset;
  bfd_size_type todo = o->size;

  offset *= bfd_octets_per_byte (output_bfd, o);

  if ((o->flags & 0x4000000)
      && o->size > address_size)
    {


      if ((o->size & (address_size - 1)) != 0
   || (o->reloc_count != 0
       && (o->size * bed->s->int_rels_per_ext_rel
    != o->reloc_count * address_size)))
        {
   _bfd_error_handler

     (dgettext ("bfd", "error: %pB: size of section %pA is not " "multiple of address size")
                                   ,
      input_bfd, o);
   bfd_set_error (bfd_error_bad_value);
   return 
# 11934 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 11934 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
        }

      do
        {
   todo -= address_size;
   if (! bfd_set_section_contents (output_bfd,
       o->output_section,
       contents + todo,
       offset,
       address_size))
     return 
# 11945 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 11945 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
   if (todo == 0)
     break;
   offset += address_size;
        }
      while (1);
    }
  else if (! bfd_set_section_contents (output_bfd,
           o->output_section,
           contents,
           offset, todo))
    return 
# 11956 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 11956 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
       }
   }
   break;
 }
    }

  return 
# 11963 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 11963 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






static 
# 11971 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 11972 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_reloc_link_order (bfd *output_bfd,
        struct bfd_link_info *info,
        asection *output_section,
        struct bfd_link_order *link_order)
{
  reloc_howto_type *howto;
  long indx;
  bfd_vma offset;
  bfd_vma addend;
  struct bfd_elf_section_reloc_data *reldata;
  struct elf_link_hash_entry **rel_hash_ptr;
  Elf_Internal_Shdr *rel_hdr;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);
  Elf_Internal_Rela irel[3];
  bfd_byte *erel;
  unsigned int i;
  struct bfd_elf_section_data *esdo = ((struct bfd_elf_section_data*)(output_section)->used_by_bfd);

  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (howto == 
# 11991 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 11991 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    {
      bfd_set_error (bfd_error_bad_value);
      return 
# 11994 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 11994 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }

  addend = link_order->u.reloc.p->addend;

  if (esdo->rel.hdr)
    reldata = &esdo->rel;
  else if (esdo->rela.hdr)
    reldata = &esdo->rela;
  else
    {
      reldata = 
# 12005 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 12005 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
      do { if (!(0)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",12006); } while (0);
    }


  rel_hash_ptr = reldata->hashes + reldata->count;
  if (link_order->type == bfd_section_reloc_link_order)
    {
      indx = link_order->u.reloc.p->u.section->target_index;
      do { if (!(indx != 0)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",12014); } while (0);
      *rel_hash_ptr = 
# 12015 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 12015 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
    }
  else
    {
      struct elf_link_hash_entry *h;



      h = ((struct elf_link_hash_entry *)
    bfd_wrapped_link_hash_lookup (output_bfd, info,
      link_order->u.reloc.p->u.name,
      
# 12026 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     0
# 12026 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          , 
# 12026 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 12026 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 , 
# 12026 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   1
# 12026 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ));
      if (h != 
# 12027 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
   
# 12028 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && (h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak))
 {
   asection *section;

   section = h->root.u.def.section;
   indx = section->output_section->target_index;
   *rel_hash_ptr = 
# 12035 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 12035 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;



   addend += section->output_section->vma + section->output_offset;
 }
      else if (h != 
# 12041 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 12041 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
 {


   h->indx = -2;
   *rel_hash_ptr = h;
   indx = 0;
 }
      else
 {
   (*info->callbacks->unattached_reloc)
     (info, link_order->u.reloc.p->u.name, 
# 12052 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 12052 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              , 
# 12052 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                ((void *)0)
# 12052 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                    , 0);
   indx = 0;
 }
    }



  if (howto->partial_inplace && addend != 0)
    {
      bfd_size_type size;
      bfd_reloc_status_type rstat;
      bfd_byte *buf;
      
# 12064 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 12064 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          ok;
      const char *sym_name;
      bfd_size_type octets;

      size = (bfd_size_type) bfd_get_reloc_size (howto);
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == 
# 12070 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0) 
# 12070 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     && size != 0)
 return 
# 12071 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 12071 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
      switch (rstat)
 {
 case bfd_reloc_ok:
   break;

 default:
 case bfd_reloc_outofrange:
   _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 12080, __PRETTY_FUNCTION__);

 case bfd_reloc_overflow:
   if (link_order->type == bfd_section_reloc_link_order)
     sym_name = bfd_section_name (link_order->u.reloc.p->u.section);
   else
     sym_name = link_order->u.reloc.p->u.name;
   (*info->callbacks->reloc_overflow) (info, 
# 12087 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                            ((void *)0)
# 12087 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                , sym_name,
           howto->name, addend, 
# 12088 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 12088 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   , 
# 12088 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 12088 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ,
           (bfd_vma) 0);
   break;
 }

      octets = link_order->offset * bfd_octets_per_byte (output_bfd,
        output_section);
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
         octets, size);
      free (buf);
      if (! ok)
 return 
# 12099 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 12099 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }




  offset = link_order->offset;
  if (! ((info)->type == type_relocatable))
    offset += output_section->vma;

  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
    {
      irel[i].r_offset = offset;
      irel[i].r_info = 0;
      irel[i].r_addend = 0;
    }
  if (bed->s->arch_size == 32)
    irel[0].r_info = (((unsigned) (indx) << 8) + ((howto->type) & 0xff));
  else
    irel[0].r_info = (((bfd_vma) (indx) << 31 << 1) + (bfd_vma) (howto->type));

  rel_hdr = reldata->hdr;
  erel = rel_hdr->contents;
  if (rel_hdr->sh_type == 9)
    {
      erel += reldata->count * bed->s->sizeof_rel;
      (*bed->s->swap_reloc_out) (output_bfd, irel, erel);
    }
  else
    {
      irel[0].r_addend = addend;
      erel += reldata->count * bed->s->sizeof_rela;
      (*bed->s->swap_reloca_out) (output_bfd, irel, erel);
    }

  ++reldata->count;

  return 
# 12136 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 12136 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




static 
# 12142 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 12143 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_output_implib (bfd *abfd, struct bfd_link_info *info)
{
  
# 12145 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 12145 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ret = 
# 12145 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 12145 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
  bfd *implib_bfd;
  const struct elf_backend_data *bed;
  flagword flags;
  enum bfd_architecture arch;
  unsigned int mach;
  asymbol **sympp = 
# 12151 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 12151 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
  long symsize;
  long symcount;
  long src_count;
  elf_symbol_type *osymbuf;
  size_t amt;

  implib_bfd = info->out_implib_bfd;
  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  if (!bfd_set_format (implib_bfd, bfd_object))
    return 
# 12162 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12162 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  flags = bfd_get_file_flags (abfd);
  flags &= ~0x1;
  if (!bfd_set_start_address (implib_bfd, 0)
      || !bfd_set_file_flags (implib_bfd, flags & ~0x2))
    return 
# 12169 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12169 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  arch = bfd_get_arch (abfd);
  mach = bfd_get_mach (abfd);
  if (!((*((implib_bfd)->xvec->_bfd_set_arch_mach)) (implib_bfd, arch, mach))
      && (abfd->target_defaulted
   || bfd_get_arch (abfd) != bfd_get_arch (implib_bfd)))
    return 
# 12177 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12177 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  symsize = ((*((abfd)->xvec->_bfd_get_symtab_upper_bound)) (abfd));
  if (symsize < 0)
    return 
# 12182 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12182 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  sympp = (asymbol **) bfd_malloc (symsize);
  if (sympp == 
# 12186 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 12186 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
    return 
# 12187 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12187 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  symcount = ((*((abfd)->xvec->_bfd_canonicalize_symtab)) (abfd, sympp));
  if (symcount < 0)
    goto free_sym_buf;



  if (! ((*((implib_bfd)->xvec->_bfd_copy_private_header_data)) (abfd, implib_bfd)))
    goto free_sym_buf;


  if (bed->elf_backend_filter_implib_symbols)
    symcount = bed->elf_backend_filter_implib_symbols (abfd, info, sympp,
             symcount);
  else
    symcount = _bfd_elf_filter_global_symbols (abfd, info, sympp, symcount);
  if (symcount == 0)
    {
      bfd_set_error (bfd_error_no_symbols);
      _bfd_error_handler (dgettext ("bfd", "%pB: no symbol found for import library"),
     implib_bfd);
      goto free_sym_buf;
    }



  amt = symcount * sizeof (*osymbuf);
  osymbuf = (elf_symbol_type *) bfd_alloc (implib_bfd, amt);
  if (osymbuf == 
# 12216 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 12216 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
    goto free_sym_buf;

  for (src_count = 0; src_count < symcount; src_count++)
    {
      memcpy (&osymbuf[src_count], (elf_symbol_type *) sympp[src_count],
       sizeof (*osymbuf));
      osymbuf[src_count].symbol.section = (&_bfd_std_section[2]);
      osymbuf[src_count].internal_elf_sym.st_shndx = (-0xFu);
      osymbuf[src_count].symbol.value += sympp[src_count]->section->vma;
      osymbuf[src_count].internal_elf_sym.st_value =
 osymbuf[src_count].symbol.value;
      sympp[src_count] = &osymbuf[src_count].symbol;
    }

  bfd_set_symtab (implib_bfd, sympp, symcount);




  if (! ((*((implib_bfd)->xvec->_bfd_copy_private_bfd_data)) (abfd, implib_bfd)))
    goto free_sym_buf;

  if (!bfd_close (implib_bfd))
    goto free_sym_buf;

  ret = 
# 12242 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 12242 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;

 free_sym_buf:
  free (sympp);
  return ret;
}

static void
elf_final_link_free (bfd *obfd, struct elf_final_link_info *flinfo)
{
  asection *o;

  if (flinfo->symstrtab != 
# 12254 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0)
# 12254 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                              )
    _bfd_elf_strtab_free (flinfo->symstrtab);
  free (flinfo->contents);
  free (flinfo->external_relocs);
  free (flinfo->internal_relocs);
  free (flinfo->external_syms);
  free (flinfo->locsym_shndx);
  free (flinfo->internal_syms);
  free (flinfo->indices);
  free (flinfo->sections);
  if (flinfo->symshndxbuf != (Elf_External_Sym_Shndx *) -1)
    free (flinfo->symshndxbuf);
  for (o = obfd->sections; o != 
# 12266 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 12266 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   ; o = o->next)
    {
      struct bfd_elf_section_data *esdo = ((struct bfd_elf_section_data*)(o)->used_by_bfd);
      free (esdo->rel.hashes);
      free (esdo->rela.hashes);
    }
}




# 12276 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 12277 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
{
  
# 12279 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 12279 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      dynamic;
  
# 12280 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 12280 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      emit_relocs;
  bfd *dynobj;
  struct elf_final_link_info flinfo;
  asection *o;
  struct bfd_link_order *p;
  bfd *sub;
  bfd_size_type max_contents_size;
  bfd_size_type max_external_reloc_size;
  bfd_size_type max_internal_reloc_count;
  bfd_size_type max_sym_count;
  bfd_size_type max_sym_shndx_count;
  Elf_Internal_Sym elfsym;
  unsigned int i;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *symtab_shndx_hdr;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  struct elf_outext_info eoinfo;
  
# 12297 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 12297 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      merged;
  size_t relativecount;
  size_t relr_entsize;
  asection *reldyn = 0;
  bfd_size_type amt;
  asection *attr_section = 
# 12302 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0)
# 12302 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                              ;
  bfd_vma attr_size = 0;
  const char *std_attrs_section;
  struct elf_link_hash_table *htab = elf_hash_table (info);
  
# 12306 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 12306 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      sections_removed;
  
# 12307 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 12307 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ret;

  if (!is_elf_hash_table (&htab->root))
    return 
# 12310 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12310 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if ((((info)->type == type_dll) || ((info)->type == type_pie)))
    abfd->flags |= 0x40;

  dynamic = htab->dynamic_sections_created;
  dynobj = htab->dynobj;

  emit_relocs = (((info)->type == type_relocatable)
   || info->emitrelocations);

  memset (&flinfo, 0, sizeof (flinfo));
  flinfo.info = info;
  flinfo.output_bfd = abfd;
  flinfo.symstrtab = _bfd_elf_strtab_init ();
  if (flinfo.symstrtab == 
# 12325 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 12325 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
    return 
# 12326 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12326 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if (! dynamic)
    {
      flinfo.hash_sec = 
# 12330 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       ((void *)0)
# 12330 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
      flinfo.symver_sec = 
# 12331 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 12331 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;
    }
  else
    {
      flinfo.hash_sec = bfd_get_linker_section (dynobj, ".hash");

      flinfo.symver_sec = bfd_get_linker_section (dynobj, ".gnu.version");

    }

  if (info->unique_symbol
      && !bfd_hash_table_init (&flinfo.local_hash_table,
          local_hash_newfunc,
          sizeof (struct local_hash_entry)))
    return 
# 12345 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12345 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;




  sections_removed = 
# 12350 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 12350 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
  std_attrs_section = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->obj_attrs_section;
  for (o = abfd->sections; o != 
# 12352 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 12352 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   ; o = o->next)
    {
      
# 12354 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 12354 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          remove_section = 
# 12354 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           0
# 12354 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                ;

      if ((std_attrs_section && strcmp (o->name, std_attrs_section) == 0)
   || strcmp (o->name, ".gnu.attributes") == 0)
 {
   for (p = o->map_head.link_order; p != 
# 12359 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                        ((void *)0)
# 12359 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                            ; p = p->next)
     {
       asection *input_section;

       if (p->type != bfd_indirect_link_order)
  continue;
       input_section = p->u.indirect.section;


       input_section->flags &= ~0x100;
     }

   attr_size = bfd_elf_obj_attr_size (abfd);
   bfd_set_section_size (o, attr_size);

   o->map_head.link_order = 
# 12374 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 12374 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               ;
   if (attr_size)
     attr_section = o;
   else
     remove_section = 
# 12378 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     1
# 12378 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
 }
      else if ((o->flags & 0x2000000) != 0 && o->size == 0)
 {

   remove_section = 
# 12383 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   1
# 12383 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       ;
 }
      if (remove_section)
 {
   o->flags |= 0x8000;
   bfd_section_list_remove (abfd, o);
   abfd->section_count--;
   sections_removed = 
# 12390 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     1
# 12390 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
 }
    }
  if (sections_removed)
    _bfd_fix_excluded_sec_syms (abfd, info);




  max_contents_size = 0;
  max_external_reloc_size = 0;
  max_internal_reloc_count = 0;
  max_sym_count = 0;
  max_sym_shndx_count = 0;
  merged = 
# 12404 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12404 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  for (o = abfd->sections; o != 
# 12405 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 12405 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   ; o = o->next)
    {
      struct bfd_elf_section_data *esdo = ((struct bfd_elf_section_data*)(o)->used_by_bfd);
      o->reloc_count = 0;

      for (p = o->map_head.link_order; p != 
# 12410 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 12410 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               ; p = p->next)
 {
   unsigned int reloc_count = 0;
   unsigned int additional_reloc_count = 0;
   struct bfd_elf_section_data *esdi = 
# 12414 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
# 12414 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          ;

   if (p->type == bfd_section_reloc_link_order
       || p->type == bfd_symbol_reloc_link_order)
     reloc_count = 1;
   else if (p->type == bfd_indirect_link_order)
     {
       asection *sec;

       sec = p->u.indirect.section;





       sec->linker_mark = 
# 12429 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         1
# 12429 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;

       if (sec->flags & 0x800000)
  merged = 
# 12432 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 12432 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

       if (sec->rawsize > max_contents_size)
  max_contents_size = sec->rawsize;
       if (sec->size > max_contents_size)
  max_contents_size = sec->size;

       if (bfd_get_flavour (sec->owner) == bfd_target_elf_flavour
    && (sec->owner->flags & 0x40) == 0)
  {
    size_t sym_count;



    if ((((sec->owner) -> tdata.elf_obj_data) -> bad_symtab))
      sym_count = (((sec->owner) -> tdata.elf_obj_data)->symtab_hdr.sh_size
     / bed->s->sizeof_sym);
    else
      sym_count = ((sec->owner) -> tdata.elf_obj_data)->symtab_hdr.sh_info;

    if (sym_count > max_sym_count)
      max_sym_count = sym_count;

    if (sym_count > max_sym_shndx_count
        && (((sec->owner) -> tdata.elf_obj_data) -> symtab_shndx_list) != 
# 12456 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                ((void *)0)
# 12456 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                    )
      max_sym_shndx_count = sym_count;

    esdi = ((struct bfd_elf_section_data*)(sec)->used_by_bfd);

    if (esdi->this_hdr.sh_type == 9
        || esdi->this_hdr.sh_type == 4)



      ;
    else if (emit_relocs)
      {
        reloc_count = sec->reloc_count;
        if (bed->elf_backend_count_additional_relocs)
   {
     int c;
     c = (*bed->elf_backend_count_additional_relocs) (sec);
     additional_reloc_count += c;
   }
      }
    else if (bed->elf_backend_count_relocs)
      reloc_count = (*bed->elf_backend_count_relocs) (info, sec);

    if ((sec->flags & 0x4) != 0)
      {
        size_t ext_size = 0;

        if (esdi->rel.hdr != 
# 12484 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 12484 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
   ext_size = esdi->rel.hdr->sh_size;
        if (esdi->rela.hdr != 
# 12486 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
# 12486 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 )
   ext_size += esdi->rela.hdr->sh_size;

        if (ext_size > max_external_reloc_size)
   max_external_reloc_size = ext_size;
        if (sec->reloc_count > max_internal_reloc_count)
   max_internal_reloc_count = sec->reloc_count;
      }
  }
     }

   if (reloc_count == 0)
     continue;

   reloc_count += additional_reloc_count;
   o->reloc_count += reloc_count;

   if (p->type == bfd_indirect_link_order && emit_relocs)
     {
       if (esdi->rel.hdr)
  {
    esdo->rel.count += ((esdi->rel.hdr)->sh_entsize > 0 ? (esdi->rel.hdr)->sh_size / (esdi->rel.hdr)->sh_entsize : 0);
    esdo->rel.count += additional_reloc_count;
  }
       if (esdi->rela.hdr)
  {
    esdo->rela.count += ((esdi->rela.hdr)->sh_entsize > 0 ? (esdi->rela.hdr)->sh_size / (esdi->rela.hdr)->sh_entsize : 0);
    esdo->rela.count += additional_reloc_count;
  }
     }
   else
     {
       if (o->use_rela_p)
  esdo->rela.count += reloc_count;
       else
  esdo->rel.count += reloc_count;
     }
 }

      if (o->reloc_count > 0)
 o->flags |= 0x4;
      else
 {



   o->flags &=~ 0x4;
 }





      if ((o->flags & 0x1) == 0
   && ! o->user_set_vma)
 o->vma = 0;
    }

  if (! ((info)->type == type_relocatable) && merged)
    elf_link_hash_traverse (htab, _bfd_elf_link_sec_merge_syms, abfd);




  abfd->symcount = info->strip != strip_all || emit_relocs;
  do { if (!(! abfd->output_has_begun)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",12551); } while (0);
  if (! _bfd_elf_compute_section_file_positions (abfd, info))
    goto error_return;


  for (o = abfd->sections; o != 
# 12556 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 12556 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   ; o = o->next)
    {
      struct bfd_elf_section_data *esdo = ((struct bfd_elf_section_data*)(o)->used_by_bfd);
      if ((o->flags & 0x4) != 0)
 {
   if (esdo->rel.hdr
       && !(_bfd_elf_link_size_reloc_section (abfd, &esdo->rel)))
     goto error_return;

   if (esdo->rela.hdr
       && !(_bfd_elf_link_size_reloc_section (abfd, &esdo->rela)))
     goto error_return;
 }



      o->target_index = 0;



      esdo->rel.count = 0;
      esdo->rela.count = 0;

      if ((esdo->this_hdr.sh_offset == (file_ptr) -1)
   && !bfd_section_is_ctf (o))
 {



   unsigned char *contents = esdo->this_hdr.contents;
   if (contents != 
# 12586 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 12586 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
     _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 12587, __PRETTY_FUNCTION__);
   contents
     = (unsigned char *) bfd_malloc (esdo->this_hdr.sh_size);
   if (contents == 
# 12590 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 12590 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
     goto error_return;
   esdo->this_hdr.contents = contents;
 }
    }





  abfd->symcount = 0;
  symtab_hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;

  symtab_hdr->sh_type = 2;

  symtab_hdr->sh_entsize = bed->s->sizeof_sym;



  symtab_hdr->sh_addralign = (bfd_vma) 1 << bed->s->log_file_align;

  if (max_sym_count < 20)
    max_sym_count = 20;
  htab->strtabsize = max_sym_count;
  amt = max_sym_count * sizeof (struct elf_sym_strtab);
  htab->strtab = (struct elf_sym_strtab *) bfd_malloc (amt);
  if (htab->strtab == 
# 12616 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 12616 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
    goto error_return;

  flinfo.symshndxbuf
    = ((((abfd) -> tdata.elf_obj_data) -> num_elf_sections) > ((-0x100u) & 0xFFFF)
       ? (Elf_External_Sym_Shndx *) -1 : 
# 12621 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                        ((void *)0)
# 12621 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                            );

  if (info->strip != strip_all || emit_relocs)
    {
      file_ptr off = (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos);

      _bfd_elf_assign_file_position_for_section (symtab_hdr, off, 
# 12627 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                                 1
# 12627 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                     );







      elfsym.st_value = 0;
      elfsym.st_size = 0;
      elfsym.st_info = 0;
      elfsym.st_other = 0;
      elfsym.st_shndx = 0;
      elfsym.st_target_internal = 0;
      if (elf_link_output_symstrtab (&flinfo, 
# 12641 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             ((void *)0)
# 12641 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                 , &elfsym,
         (&_bfd_std_section[1]), 
# 12642 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                             ((void *)0)
# 12642 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                 ) != 1)
 goto error_return;






      if (bfd_keep_unused_section_symbols (abfd) || emit_relocs)
 {
   
# 12652 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
  _Bool 
# 12652 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       name_local_sections
     = (bed->elf_backend_name_local_section_symbols
        && bed->elf_backend_name_local_section_symbols (abfd));
   const char *name = 
# 12655 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 12655 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;

   elfsym.st_size = 0;
   elfsym.st_info = (((0) << 4) + ((3) & 0xF));
   elfsym.st_other = 0;
   elfsym.st_value = 0;
   elfsym.st_target_internal = 0;
   for (i = 1; i < (((abfd) -> tdata.elf_obj_data) -> num_elf_sections); i++)
     {
       o = bfd_section_from_elf_index (abfd, i);
       if (o != 
# 12665 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 12665 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
  {
    o->target_index = bfd_get_symcount (abfd);
    elfsym.st_shndx = i;
    if (!((info)->type == type_relocatable))
      elfsym.st_value = o->vma;
    if (name_local_sections)
      name = o->name;
    if (elf_link_output_symstrtab (&flinfo, name, &elfsym, o,
       
# 12674 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      ((void *)0)
# 12674 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          ) != 1)
      goto error_return;
  }
     }
 }
    }




  if (bed->elf_backend_elfsym_local_is_section
      && bed->elf_backend_elfsym_local_is_section (abfd))
    symtab_hdr->sh_info = bfd_get_symcount (abfd);



  if (max_contents_size != 0)
    {
      flinfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
      if (flinfo.contents == 
# 12693 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 12693 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
 goto error_return;
    }

  if (max_external_reloc_size != 0)
    {
      flinfo.external_relocs = bfd_malloc (max_external_reloc_size);
      if (flinfo.external_relocs == 
# 12700 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 12700 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       )
 goto error_return;
    }

  if (max_internal_reloc_count != 0)
    {
      amt = max_internal_reloc_count * sizeof (Elf_Internal_Rela);
      flinfo.internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);
      if (flinfo.internal_relocs == 
# 12708 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
# 12708 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       )
 goto error_return;
    }

  if (max_sym_count != 0)
    {
      amt = max_sym_count * bed->s->sizeof_sym;
      flinfo.external_syms = (bfd_byte *) bfd_malloc (amt);
      if (flinfo.external_syms == 
# 12716 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 ((void *)0)
# 12716 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                     )
 goto error_return;

      amt = max_sym_count * sizeof (Elf_Internal_Sym);
      flinfo.internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (flinfo.internal_syms == 
# 12721 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 ((void *)0)
# 12721 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                     )
 goto error_return;

      amt = max_sym_count * sizeof (long);
      flinfo.indices = (long int *) bfd_malloc (amt);
      if (flinfo.indices == 
# 12726 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 12726 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
 goto error_return;

      amt = max_sym_count * sizeof (asection *);
      flinfo.sections = (asection **) bfd_malloc (amt);
      if (flinfo.sections == 
# 12731 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 12731 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
 goto error_return;
    }

  if (max_sym_shndx_count != 0)
    {
      amt = max_sym_shndx_count * sizeof (Elf_External_Sym_Shndx);
      flinfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (flinfo.locsym_shndx == 
# 12739 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
# 12739 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    )
 goto error_return;
    }

  if (htab->tls_sec)
    {
      bfd_vma base, end = 0;
      asection *sec;

      for (sec = htab->tls_sec;
    sec && (sec->flags & 0x400);
    sec = sec->next)
 {
   bfd_size_type size = sec->size;
   unsigned int opb = bfd_octets_per_byte (abfd, sec);

   if (size == 0
       && (sec->flags & 0x100) == 0)
     {
       struct bfd_link_order *ord = sec->map_tail.link_order;

       if (ord != 
# 12760 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 12760 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
  size = ord->offset * opb + ord->size;
     }
   end = sec->vma + size / opb;
 }
      base = htab->tls_sec->vma;


      if (bed->static_tls_alignment == 1)
 end = (((end) + ((bfd_vma) 1 << (htab->tls_sec->alignment_power)) - 1) & (-((bfd_vma) 1 << (htab->tls_sec->alignment_power))));
      htab->tls_size = end - base;
    }

  if (!_bfd_elf_fixup_eh_frame_hdr (info))
    return 
# 12774 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 12774 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



  if (info->enable_dt_relr
      && bed->finish_relative_relocs
      && !bed->finish_relative_relocs (info))
    info->callbacks->einfo
      (dgettext ("bfd", "%F%P: %pB: failed to finish relative relocations\n"), abfd);
# 12804 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  for (sub = info->input_bfds; sub != 
# 12804 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 12804 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ; sub = sub->link.next)
    sub->output_has_begun = 
# 12805 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           0
# 12805 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                ;
  for (o = abfd->sections; o != 
# 12806 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 12806 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   ; o = o->next)
    {
      for (p = o->map_head.link_order; p != 
# 12808 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 12808 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               ; p = p->next)
 {
   if (p->type == bfd_indirect_link_order
       && (bfd_get_flavour ((sub = p->u.indirect.section->owner))
    == bfd_target_elf_flavour)
       && (((sub) -> tdata.elf_obj_data) -> elf_header)->e_ident[4] == bed->s->elfclass)
     {
       if (! sub->output_has_begun)
  {
    if (! elf_link_input_bfd (&flinfo, sub))
      goto error_return;
    sub->output_has_begun = 
# 12819 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           1
# 12819 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               ;
  }
     }
   else if (p->type == bfd_section_reloc_link_order
     || p->type == bfd_symbol_reloc_link_order)
     {
       if (! elf_reloc_link_order (abfd, info, o, p))
  goto error_return;
     }
   else
     {
       if (! _bfd_default_link_order (abfd, info, o, p))
  {
    if (p->type == bfd_indirect_link_order
        && (bfd_get_flavour (sub)
     == bfd_target_elf_flavour)
        && ((((sub) -> tdata.elf_obj_data) -> elf_header)->e_ident[4]
     != bed->s->elfclass))
      {
        const char *iclass, *oclass;

        switch (bed->s->elfclass)
   {
   case 2: oclass = "ELFCLASS64"; break;
   case 1: oclass = "ELFCLASS32"; break;
   case 0: oclass = "ELFCLASSNONE"; break;
   default: _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 12845, __PRETTY_FUNCTION__);
   }

        switch ((((sub) -> tdata.elf_obj_data) -> elf_header)->e_ident[4])
   {
   case 2: iclass = "ELFCLASS64"; break;
   case 1: iclass = "ELFCLASS32"; break;
   case 0: iclass = "ELFCLASSNONE"; break;
   default: _bfd_abort ("/doner/binutils/binutils-515f23e/bfd/elflink.c", 12853, __PRETTY_FUNCTION__);
   }

        bfd_set_error (bfd_error_wrong_format);
        _bfd_error_handler

   (dgettext ("bfd", "%pB: file class %s incompatible with %s"),
    sub, iclass, oclass);
      }

    goto error_return;
  }
     }
 }
    }


  if (!info->reduce_memory_overheads)
    {
      for (sub = info->input_bfds; sub != 
# 12872 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                         ((void *)0)
# 12872 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                             ; sub = sub->link.next)
 if (bfd_get_flavour (sub) == bfd_target_elf_flavour)
   {
     free (((sub) -> tdata.elf_obj_data)->symbuf);
     ((sub) -> tdata.elf_obj_data)->symbuf = 
# 12876 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
# 12876 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                  ;
   }
    }

  ret = 
# 12880 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 12880 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;







  eoinfo.failed = 
# 12888 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 0
# 12888 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
  eoinfo.flinfo = &flinfo;
  eoinfo.localsyms = 
# 12890 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    1
# 12890 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
  eoinfo.file_sym_done = 
# 12891 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        0
# 12891 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;
  bfd_hash_traverse (&info->hash->table, elf_link_output_extsym, &eoinfo);
  if (eoinfo.failed)
    {
      ret = 
# 12895 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 12895 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
      goto return_local_hash_table;
    }



  if (bed->elf_backend_output_arch_local_syms)
    {
      if (! ((*bed->elf_backend_output_arch_local_syms)
      (abfd, info, &flinfo, elf_link_output_symstrtab)))
 {
   ret = 
# 12906 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 12906 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
   goto return_local_hash_table;
 }
    }







  if (!symtab_hdr->sh_info)
    symtab_hdr->sh_info = bfd_get_symcount (abfd);

  if (dynamic
      && htab->dynsym != 
# 12921 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0)
      
# 12922 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && htab->dynsym->output_section != (&_bfd_std_section[2]))
    {
      Elf_Internal_Sym sym;
      bfd_byte *dynsym = htab->dynsym->contents;

      o = htab->dynsym->output_section;
      ((struct bfd_elf_section_data*)(o)->used_by_bfd)->this_hdr.sh_info = htab->local_dynsymcount + 1;


      if ((((info)->type == type_dll) || ((info)->type == type_pie))
   || htab->is_relocatable_executable)
 {
   asection *s;

   sym.st_size = 0;
   sym.st_name = 0;
   sym.st_info = (((0) << 4) + ((3) & 0xF));
   sym.st_other = 0;
   sym.st_target_internal = 0;

   for (s = abfd->sections; s != 
# 12942 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
# 12942 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    ; s = s->next)
     {
       int indx;
       bfd_byte *dest;
       long dynindx;

       dynindx = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->dynindx;
       if (dynindx <= 0)
  continue;
       indx = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_idx;
       do { if (!(indx > 0)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",12952); } while (0);
       sym.st_shndx = indx;
       if (! check_dynsym (abfd, &sym))
  {
    ret = 
# 12956 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 12956 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
    goto return_local_hash_table;
  }
       sym.st_value = s->vma;
       dest = dynsym + dynindx * bed->s->sizeof_sym;



       if (info->callbacks->ctf_new_dynsym)
  info->callbacks->ctf_new_dynsym (dynindx, &sym);

       bed->s->swap_symbol_out (abfd, &sym, dest, 0);
     }
 }


      if (htab->dynlocal)
 {
   struct elf_link_local_dynamic_entry *e;
   for (e = htab->dynlocal; e ; e = e->next)
     {
       asection *s;
       bfd_byte *dest;




       sym = e->isym;
       sym.st_other &= ~((-1) & 0x3);
       sym.st_shndx = 0;

       s = bfd_section_from_elf_index (e->input_bfd,
           e->isym.st_shndx);
       if (s != 
# 12989 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
    
# 12990 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && s->output_section != 
# 12990 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
    
# 12991 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   && ((struct bfd_elf_section_data*)(s->output_section)->used_by_bfd) != 
# 12991 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                              ((void *)0)
# 12991 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                  )
  {
    sym.st_shndx =
      ((struct bfd_elf_section_data*)(s->output_section)->used_by_bfd)->this_idx;
    if (! check_dynsym (abfd, &sym))
      {
        ret = 
# 12997 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 12997 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
        goto return_local_hash_table;
      }
    sym.st_value = (s->output_section->vma
      + s->output_offset
      + e->isym.st_value);
  }



       if (info->callbacks->ctf_new_dynsym)
  info->callbacks->ctf_new_dynsym (e->dynindx, &sym);

       dest = dynsym + e->dynindx * bed->s->sizeof_sym;
       bed->s->swap_symbol_out (abfd, &sym, dest, 0);
     }
 }
    }


  eoinfo.failed = 
# 13017 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 0
# 13017 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;
  eoinfo.localsyms = 
# 13018 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    0
# 13018 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;
  eoinfo.flinfo = &flinfo;
  bfd_hash_traverse (&info->hash->table, elf_link_output_extsym, &eoinfo);
  if (eoinfo.failed)
    {
      ret = 
# 13023 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 13023 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
      goto return_local_hash_table;
    }



  if (bed->elf_backend_output_arch_syms
      && (info->strip != strip_all || emit_relocs))
    {
      if (! ((*bed->elf_backend_output_arch_syms)
      (abfd, info, &flinfo, elf_link_output_symstrtab)))
 {
   ret = 
# 13035 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 13035 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
   goto return_local_hash_table;
 }
    }


  _bfd_elf_strtab_finalize (flinfo.symstrtab);


  if (!elf_link_swap_symbols_out (&flinfo))
    {
      ret = 
# 13046 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 13046 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
      goto return_local_hash_table;
    }


  if (bfd_get_symcount (abfd) > 0)
    {


      Elf_Internal_Shdr *symstrtab_hdr = 
# 13055 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                        ((void *)0)
# 13055 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                            ;
      file_ptr off = symtab_hdr->sh_offset + symtab_hdr->sh_size;

      if ((((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list))
 {
   symtab_shndx_hdr = & (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list)->hdr;

   if (symtab_shndx_hdr != 
# 13062 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0) 
# 13062 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               && symtab_shndx_hdr->sh_name != 0)
     {
       symtab_shndx_hdr->sh_type = 18;
       symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
       symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
       amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);
       symtab_shndx_hdr->sh_size = amt;

       off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,
              off, 
# 13071 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  1
# 13071 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      );

       if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, 
# 13073 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                       0
# 13073 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                               ) != 0
    || (bfd_bwrite (flinfo.symshndxbuf, amt, abfd) != amt))
  {
    ret = 
# 13076 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 13076 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
    goto return_local_hash_table;
  }
     }
 }

      symstrtab_hdr = &((abfd) -> tdata.elf_obj_data)->strtab_hdr;

      symstrtab_hdr->sh_type = 3;
      symstrtab_hdr->sh_flags = bed->elf_strtab_flags;
      symstrtab_hdr->sh_addr = 0;
      symstrtab_hdr->sh_size = _bfd_elf_strtab_size (flinfo.symstrtab);
      symstrtab_hdr->sh_entsize = 0;
      symstrtab_hdr->sh_link = 0;
      symstrtab_hdr->sh_info = 0;

      symstrtab_hdr->sh_addralign = 1;

      off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr,
             off, 
# 13095 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 1
# 13095 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     );
      (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos) = off;

      if (bfd_seek (abfd, symstrtab_hdr->sh_offset, 
# 13098 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                   0
# 13098 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                           ) != 0
   || ! _bfd_elf_strtab_emit (abfd, flinfo.symstrtab))
 {
   ret = 
# 13101 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 13101 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
   goto return_local_hash_table;
 }
    }

  if (info->out_implib_bfd && !elf_output_implib (abfd, info))
    {
      _bfd_error_handler (dgettext ("bfd", "%pB: failed to generate import library"),
     info->out_implib_bfd);
      ret = 
# 13110 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 13110 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
      goto return_local_hash_table;
    }


  for (o = abfd->sections; o != 
# 13115 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               ((void *)0)
# 13115 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                   ; o = o->next)
    {
      struct bfd_elf_section_data *esdo = ((struct bfd_elf_section_data*)(o)->used_by_bfd);
      
# 13118 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 13118 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          sort;

      if ((o->flags & 0x4) == 0)
 continue;

      sort = bed->sort_relocs_p == 
# 13123 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0) 
# 13123 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       || (*bed->sort_relocs_p) (o);
      if (esdo->rel.hdr != 
# 13124 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          ((void *)0)
   
# 13125 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && !elf_link_adjust_relocs (abfd, o, &esdo->rel, sort, info))
 {
   ret = 
# 13127 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 13127 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
   goto return_local_hash_table;
 }
      if (esdo->rela.hdr != 
# 13130 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
   
# 13131 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && !elf_link_adjust_relocs (abfd, o, &esdo->rela, sort, info))
 {
   ret = 
# 13133 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 13133 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
   goto return_local_hash_table;
 }



      o->reloc_count = 0;
    }

  relativecount = 0;
  if (dynamic && info->combreloc && dynobj != 
# 13143 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             ((void *)0)
# 13143 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                 )
    relativecount = elf_link_sort_relocs (abfd, info, &reldyn);

  relr_entsize = 0;
  if (htab->srelrdyn != 
# 13147 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       ((void *)0)
      
# 13148 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && htab->srelrdyn->output_section != 
# 13148 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
      
# 13149 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && htab->srelrdyn->size != 0)
    {
      asection *s = htab->srelrdyn->output_section;
      relr_entsize = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize;
      if (relr_entsize == 0)
 {
   relr_entsize = bed->s->arch_size / 8;
   ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize = relr_entsize;
 }
    }



  if (dynamic)
    {
      bfd_byte *dyncon, *dynconend;


      o = bfd_get_linker_section (dynobj, ".dynamic");
      do { if (!(o != 
# 13168 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 13168 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     )) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",13168); } while (0);

      dyncon = o->contents;
      dynconend = ((o->size) != 0 ? (o->contents) + (o->size) : (o->contents));
      for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
 {
   Elf_Internal_Dyn dyn;
   const char *name;
   unsigned int type;
   bfd_size_type sh_size;
   bfd_vma sh_addr;

   bed->s->swap_dyn_in (dynobj, dyncon, &dyn);

   switch (dyn.d_tag)
     {
     default:
       continue;
     case 0:
       if (relativecount != 0)
  {
    switch (((struct bfd_elf_section_data*)(reldyn)->used_by_bfd)->this_hdr.sh_type)
      {
      case 9: dyn.d_tag = 0x6ffffffa; break;
      case 4: dyn.d_tag = 0x6ffffff9; break;
      }
    if (dyn.d_tag != 0
        && dynconend - dyncon >= bed->s->sizeof_dyn)
      {
        dyn.d_un.d_val = relativecount;
        relativecount = 0;
        break;
      }
    relativecount = 0;
  }
       if (relr_entsize != 0)
  {
    if (dynconend - dyncon >= 3 * bed->s->sizeof_dyn)
      {
        asection *s = htab->srelrdyn;
        dyn.d_tag = 36;
        dyn.d_un.d_ptr
   = s->output_section->vma + s->output_offset;
        bed->s->swap_dyn_out (dynobj, &dyn, dyncon);
        dyncon += bed->s->sizeof_dyn;

        dyn.d_tag = 35;
        dyn.d_un.d_val = s->size;
        bed->s->swap_dyn_out (dynobj, &dyn, dyncon);
        dyncon += bed->s->sizeof_dyn;

        dyn.d_tag = 37;
        dyn.d_un.d_val = relr_entsize;
        relr_entsize = 0;
        break;
      }
    relr_entsize = 0;
  }
       continue;

     case 12:
       name = info->init_function;
       goto get_sym;
     case 13:
       name = info->fini_function;
     get_sym:
       {
  struct elf_link_hash_entry *h;

  h = elf_link_hash_lookup (htab, name, 
# 13237 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       0
# 13237 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                            , 
# 13237 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                              0
# 13237 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                   , 
# 13237 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                     1
# 13237 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                         );
  if (h != 
# 13238 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 13239 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && (h->root.type == bfd_link_hash_defined
   || h->root.type == bfd_link_hash_defweak))
    {
      dyn.d_un.d_ptr = h->root.u.def.value;
      o = h->root.u.def.section;
      if (o->output_section != 
# 13244 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
# 13244 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                  )
        dyn.d_un.d_ptr += (o->output_section->vma
      + o->output_offset);
      else
        {


   dyn.d_un.d_ptr = 0;
        }
      break;
    }
       }
       continue;

     case 33:
       name = ".preinit_array";
       goto get_out_size;
     case 27:
       name = ".init_array";
       goto get_out_size;
     case 28:
       name = ".fini_array";
     get_out_size:
       o = bfd_get_section_by_name (abfd, name);
       if (o == 
# 13268 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 13268 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
  {
    _bfd_error_handler
      (dgettext ("bfd", "could not find section %s"), name);
    goto error_return;
  }
       if (o->size == 0)
  _bfd_error_handler
    (dgettext ("bfd", "warning: %s section has zero size"), name);
       dyn.d_un.d_val = o->size;
       break;

     case 32:
       name = ".preinit_array";
       goto get_out_vma;
     case 25:
       name = ".init_array";
       goto get_out_vma;
     case 26:
       name = ".fini_array";
     get_out_vma:
       o = bfd_get_section_by_name (abfd, name);
       goto do_vma;

     case 4:
       name = ".hash";
       goto get_vma;
     case 0x6ffffef5:
       name = ".gnu.hash";
       goto get_vma;
     case 5:
       name = ".dynstr";
       goto get_vma;
     case 6:
       name = ".dynsym";
       goto get_vma;
     case 0x6ffffffc:
       name = ".gnu.version_d";
       goto get_vma;
     case 0x6ffffffe:
       name = ".gnu.version_r";
       goto get_vma;
     case 0x6ffffff0:
       name = ".gnu.version";
     get_vma:
       o = bfd_get_linker_section (dynobj, name);
     do_vma:
       if (o == 
# 13315 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0) 
# 13315 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    || bfd_is_abs_section (o->output_section))
  {
    _bfd_error_handler
      (dgettext ("bfd", "could not find section %s"), name);
    goto error_return;
  }
       if (((struct bfd_elf_section_data*)(o->output_section)->used_by_bfd)->this_hdr.sh_type == 7)
  {
    _bfd_error_handler
      (dgettext ("bfd", "warning: section '%s' is being made into a note"), name);
    bfd_set_error (bfd_error_nonrepresentable_section);
    goto error_return;
  }
       dyn.d_un.d_ptr = o->output_section->vma + o->output_offset;
       break;

     case 17:
     case 7:
     case 18:
     case 8:
       if (dyn.d_tag == 17 || dyn.d_tag == 18)
  type = 9;
       else
  type = 4;
       sh_size = 0;
       sh_addr = 0;
       for (i = 1; i < (((abfd) -> tdata.elf_obj_data) -> num_elf_sections); i++)
  {
    Elf_Internal_Shdr *hdr;

    hdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[i];
    if (hdr->sh_type == type
        && (hdr->sh_flags & (1 << 1)) != 0)
      {
        sh_size += hdr->sh_size;
        if (sh_addr == 0
     || sh_addr > hdr->sh_addr)
   sh_addr = hdr->sh_addr;
      }
  }

       if (bed->dtrel_excludes_plt && htab->srelplt != 
# 13356 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                      ((void *)0)
# 13356 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                          )
  {
    unsigned int opb = bfd_octets_per_byte (abfd, o);



    sh_size -= htab->srelplt->size;
    if (sh_size == 0)
# 13374 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      sh_addr = 0;



    else if (sh_addr == (htab->srelplt->output_section->vma
           + htab->srelplt->output_offset) * opb)
      sh_addr += htab->srelplt->size;
  }

       if (dyn.d_tag == 18 || dyn.d_tag == 8)
  dyn.d_un.d_val = sh_size;
       else
  dyn.d_un.d_ptr = sh_addr;
       break;
     }
   bed->s->swap_dyn_out (dynobj, &dyn, dyncon);
 }
    }


  if (dynobj != 
# 13394 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 13394 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
    {
      if (! (*bed->elf_backend_finish_dynamic_sections) (abfd, info))
 goto error_return;


      if ((info->textrel_check != textrel_check_none)
   && (o = bfd_get_linker_section (dynobj, ".dynamic")) != 
# 13401 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                          ((void *)0)
   
# 13402 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && o->size != 0)
 {
   bfd_byte *dyncon, *dynconend;

   dyncon = o->contents;
   dynconend = o->contents + o->size;
   for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
     {
       Elf_Internal_Dyn dyn;

       bed->s->swap_dyn_in (dynobj, dyncon, &dyn);

       if (dyn.d_tag == 22)
  {
    if (info->textrel_check == textrel_check_error)
      info->callbacks->einfo
        (dgettext ("bfd", "%P%X: read-only segment has dynamic relocations\n"));
    else if (((info)->type == type_dll))
      info->callbacks->einfo
        (dgettext ("bfd", "%P: warning: creating DT_TEXTREL in a shared object\n"));
    else if (((info)->type == type_pde))
      info->callbacks->einfo
        (dgettext ("bfd", "%P: warning: creating DT_TEXTREL in a PDE\n"));
    else
      info->callbacks->einfo
        (dgettext ("bfd", "%P: warning: creating DT_TEXTREL in a PIE\n"));
    break;
  }
     }
 }

      for (o = dynobj->sections; o != 
# 13433 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 13433 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ; o = o->next)
 {
   if ((o->flags & 0x100) == 0
       || o->size == 0
       || o->output_section == (&_bfd_std_section[2]))
     continue;
   if ((o->flags & 0x100000) == 0)
     {


       continue;
     }
   if (htab->stab_info.stabstr == o)
     continue;
   if (htab->eh_info.hdr_sec == o)
     continue;
   if (strcmp (o->name, ".dynstr") != 0)
     {
       bfd_size_type octets = ((file_ptr) o->output_offset
          * bfd_octets_per_byte (abfd, o));
       if (!bfd_set_section_contents (abfd, o->output_section,
          o->contents, octets, o->size))
  goto error_return;
     }
   else
     {


       file_ptr off;

       off = ((struct bfd_elf_section_data*)(o->output_section)->used_by_bfd)->this_hdr.sh_offset;
       if (bfd_seek (abfd, off, 
# 13464 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                               0
# 13464 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ) != 0
    || !_bfd_elf_strtab_emit (abfd, htab->dynstr))
  goto error_return;
     }
 }
    }

  if (!info->resolve_section_groups)
    {
      
# 13473 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 13473 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          failed = 
# 13473 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   0
# 13473 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;

      do { if (!(((info)->type == type_relocatable))) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",13475); } while (0);
      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
 goto error_return;
    }


  if (htab->stab_info.stabstr != 
# 13482 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
# 13482 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    )
    {
      if (!_bfd_write_stab_strings (abfd, &htab->stab_info))
 goto error_return;
    }

  if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))
    goto error_return;

  if (! _bfd_elf_write_section_sframe (abfd, info))
    goto error_return;

  if (info->callbacks->emit_ctf)
      info->callbacks->emit_ctf ();

  elf_final_link_free (abfd, &flinfo);

  if (attr_section)
    {
      bfd_byte *contents = (bfd_byte *) bfd_malloc (attr_size);
      if (contents == 
# 13502 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0)
# 13502 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         )
 {

   ret = 
# 13505 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 13505 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
   goto return_local_hash_table;
 }
      bfd_elf_set_obj_attr_contents (abfd, contents, attr_size);
      bfd_set_section_contents (abfd, attr_section, contents, 0, attr_size);
      free (contents);
    }

 return_local_hash_table:
  if (info->unique_symbol)
    bfd_hash_table_free (&flinfo.local_hash_table);
  return ret;

 error_return:
  elf_final_link_free (abfd, &flinfo);
  ret = 
# 13520 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 13520 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
  goto return_local_hash_table;
}



static 
# 13526 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 13527 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
init_reloc_cookie (struct elf_reloc_cookie *cookie,
     struct bfd_link_info *info, bfd *abfd)
{
  Elf_Internal_Shdr *symtab_hdr;
  const struct elf_backend_data *bed;

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  symtab_hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;

  cookie->abfd = abfd;
  cookie->sym_hashes = (((abfd) -> tdata.elf_obj_data) -> sym_hashes);
  cookie->bad_symtab = (((abfd) -> tdata.elf_obj_data) -> bad_symtab);
  if (cookie->bad_symtab)
    {
      cookie->locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      cookie->extsymoff = 0;
    }
  else
    {
      cookie->locsymcount = symtab_hdr->sh_info;
      cookie->extsymoff = symtab_hdr->sh_info;
    }

  if (bed->s->arch_size == 32)
    cookie->r_sym_shift = 8;
  else
    cookie->r_sym_shift = 32;

  cookie->locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
  if (cookie->locsyms == 
# 13556 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0) 
# 13556 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             && cookie->locsymcount != 0)
    {
      cookie->locsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
           cookie->locsymcount, 0,
           
# 13560 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 13560 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              , 
# 13560 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 13560 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    , 
# 13560 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 13560 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          );
      if (cookie->locsyms == 
# 13561 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 13561 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
 {
   info->callbacks->einfo (dgettext ("bfd", "%P%X: can not read symbols: %E\n"));
   return 
# 13564 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 13564 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
 }
      if (_bfd_link_keep_memory (info) )
 {
   symtab_hdr->contents = (bfd_byte *) cookie->locsyms;
   info->cache_size += (cookie->locsymcount
          * sizeof (Elf_External_Sym_Shndx));
 }
    }
  return 
# 13573 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 13573 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



static void
fini_reloc_cookie (struct elf_reloc_cookie *cookie, bfd *abfd)
{
  Elf_Internal_Shdr *symtab_hdr;

  symtab_hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;
  if (symtab_hdr->contents != (unsigned char *) cookie->locsyms)
    free (cookie->locsyms);
}




static 
# 13591 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 13592 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
init_reloc_cookie_rels (struct elf_reloc_cookie *cookie,
   struct bfd_link_info *info, bfd *abfd,
   asection *sec)
{
  if (sec->reloc_count == 0)
    {
      cookie->rels = 
# 13598 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 13598 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
      cookie->relend = 
# 13599 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 13599 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          ;
    }
  else
    {
      cookie->rels = _bfd_elf_link_info_read_relocs (abfd, info, sec,
           
# 13604 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 13604 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              , 
# 13604 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 13604 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ,
           _bfd_link_keep_memory (info));
      if (cookie->rels == 
# 13606 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 13606 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
 return 
# 13607 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 13607 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
      cookie->rel = cookie->rels;
      cookie->relend = cookie->rels + sec->reloc_count;
    }
  cookie->rel = cookie->rels;
  return 
# 13612 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 13612 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




static void
fini_reloc_cookie_rels (struct elf_reloc_cookie *cookie,
   asection *sec)
{
  if (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->relocs != cookie->rels)
    free (cookie->rels);
}



static 
# 13628 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 13629 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
init_reloc_cookie_for_section (struct elf_reloc_cookie *cookie,
          struct bfd_link_info *info,
          asection *sec)
{
  if (!init_reloc_cookie (cookie, info, sec->owner))
    goto error1;
  if (!init_reloc_cookie_rels (cookie, info, sec->owner, sec))
    goto error2;
  return 
# 13637 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 13637 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

 error2:
  fini_reloc_cookie (cookie, sec->owner);
 error1:
  return 
# 13642 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 13642 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}




static void
fini_reloc_cookie_for_section (struct elf_reloc_cookie *cookie,
          asection *sec)
{
  fini_reloc_cookie_rels (cookie, sec);
  fini_reloc_cookie (cookie, sec->owner);
}





asection *
_bfd_elf_gc_mark_hook (asection *sec,
         struct bfd_link_info *info __attribute__ ((__unused__)),
         Elf_Internal_Rela *rel __attribute__ ((__unused__)),
         struct elf_link_hash_entry *h,
         Elf_Internal_Sym *sym)
{
  if (h != 
# 13667 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 13667 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {
      switch (h->root.type)
 {
 case bfd_link_hash_defined:
 case bfd_link_hash_defweak:
   return h->root.u.def.section;

 case bfd_link_hash_common:
   return h->root.u.c.p->section;

 default:
   break;
 }
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return 
# 13685 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 13685 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



static asection *
elf_gc_mark_debug_section (asection *sec __attribute__ ((__unused__)),
      struct bfd_link_info *info __attribute__ ((__unused__)),
      Elf_Internal_Rela *rel __attribute__ ((__unused__)),
      struct elf_link_hash_entry *h,
      Elf_Internal_Sym *sym)
{
  if (h != 
# 13697 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 13697 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {

      if ((h->root.type == bfd_link_hash_defined
    || h->root.type == bfd_link_hash_defweak)
   && (h->root.u.def.section->flags & 0x2000) != 0)
 return h->root.u.def.section;
    }
  else
    {

      asection *isec = bfd_section_from_elf_index (sec->owner,
         sym->st_shndx);
      if ((isec->flags & 0x2000) != 0)
 return isec;
    }

  return 
# 13714 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 13714 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





asection *
_bfd_elf_gc_mark_rsec (struct bfd_link_info *info, asection *sec,
         elf_gc_mark_hook_fn gc_mark_hook,
         struct elf_reloc_cookie *cookie,
         
# 13725 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool 
# 13725 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             *start_stop)
{
  unsigned long r_symndx;
  struct elf_link_hash_entry *h, *hw;

  r_symndx = cookie->rel->r_info >> cookie->r_sym_shift;
  if (r_symndx == 0)
    return 
# 13732 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 13732 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  if (r_symndx >= cookie->locsymcount
      || (((unsigned int)(cookie->locsyms[r_symndx].st_info)) >> 4) != 0)
    {
      
# 13737 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 13737 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          was_marked;

      h = cookie->sym_hashes[r_symndx - cookie->extsymoff];
      if (h == 
# 13740 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 13740 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 {
   info->callbacks->einfo (dgettext ("bfd", "%F%P: corrupt input: %pB\n"),
      sec->owner);
   return 
# 13744 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         ((void *)0)
# 13744 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }
      while (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
 h = (struct elf_link_hash_entry *) h->root.u.i.link;

      was_marked = h->mark;
      h->mark = 1;




      hw = h;
      while (hw->is_weakalias)
 {
   hw = hw->u.alias;
   hw->mark = 1;
 }

      if (!was_marked && h->start_stop && !h->root.ldscript_def)
 {
   if (info->start_stop_gc)
     return 
# 13766 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           ((void *)0)
# 13766 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;




   else if (start_stop != 
# 13771 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 13771 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             )
     {
       asection *s = h->u2.start_stop_section;
       *start_stop = 
# 13774 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    1
# 13774 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;
       return s;
     }
 }

      return (*gc_mark_hook) (sec, info, cookie->rel, h, 
# 13779 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                        ((void *)0)
# 13779 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                            );
    }

  return (*gc_mark_hook) (sec, info, cookie->rel, 
# 13782 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                 ((void *)0)
# 13782 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                     ,
     &cookie->locsyms[r_symndx]);
}






# 13790 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 13791 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_gc_mark_reloc (struct bfd_link_info *info,
   asection *sec,
   elf_gc_mark_hook_fn gc_mark_hook,
   struct elf_reloc_cookie *cookie)
{
  asection *rsec;
  
# 13797 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 13797 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      start_stop = 
# 13797 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   0
# 13797 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        ;

  rsec = _bfd_elf_gc_mark_rsec (info, sec, gc_mark_hook, cookie, &start_stop);
  while (rsec != 
# 13800 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 13800 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
    {
      if (!rsec->gc_mark)
 {
   if (bfd_get_flavour (rsec->owner) != bfd_target_elf_flavour
       || (rsec->owner->flags & 0x40) != 0)
     rsec->gc_mark = 1;
   else if (!_bfd_elf_gc_mark (info, rsec, gc_mark_hook))
     return 
# 13808 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 13808 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }
      if (!start_stop)
 break;
      rsec = bfd_get_next_section_by_name (rsec->owner, rsec);
    }
  return 
# 13814 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 13814 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






# 13821 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 13822 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_gc_mark (struct bfd_link_info *info,
    asection *sec,
    elf_gc_mark_hook_fn gc_mark_hook)
{
  
# 13826 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 13826 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ret;
  asection *group_sec, *eh_frame;

  sec->gc_mark = 1;


  group_sec = ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->next_in_group;
  if (group_sec && !group_sec->gc_mark)
    if (!_bfd_elf_gc_mark (info, group_sec, gc_mark_hook))
      return 
# 13835 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 13835 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;


  ret = 
# 13838 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 13838 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
  eh_frame = (((sec->owner) -> tdata.elf_obj_data) -> eh_frame_section);
  if ((sec->flags & 0x4) != 0
      && sec->reloc_count > 0
      && sec != eh_frame)
    {
      struct elf_reloc_cookie cookie;

      if (!init_reloc_cookie_for_section (&cookie, info, sec))
 ret = 
# 13847 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      0
# 13847 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
      else
 {
   for (; cookie.rel < cookie.relend; cookie.rel++)
     if (!_bfd_elf_gc_mark_reloc (info, sec, gc_mark_hook, &cookie))
       {
  ret = 
# 13853 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 13853 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
  break;
       }
   fini_reloc_cookie_for_section (&cookie, sec);
 }
    }

  if (ret && eh_frame && (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->fde_list))
    {
      struct elf_reloc_cookie cookie;

      if (!init_reloc_cookie_for_section (&cookie, info, eh_frame))
 ret = 
# 13865 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      0
# 13865 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
      else
 {
   if (!_bfd_elf_gc_mark_fdes (info, sec, eh_frame,
          gc_mark_hook, &cookie))
     ret = 
# 13870 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 13870 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
   fini_reloc_cookie_for_section (&cookie, eh_frame);
 }
    }

  eh_frame = (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->eh_frame_entry);
  if (ret && eh_frame && !eh_frame->gc_mark)
    if (!_bfd_elf_gc_mark (info, eh_frame, gc_mark_hook))
      ret = 
# 13878 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 13878 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

  return ret;
}



static void
_bfd_elf_gc_mark_debug_special_section_group (asection *grp)
{

  asection *ssec;

  asection *msec;

  
# 13893 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 13893 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      is_special_grp = 
# 13893 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                       1
# 13893 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                           ;
  
# 13894 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 13894 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      is_debug_grp = 
# 13894 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     1
# 13894 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                         ;



  ssec = msec = (((struct bfd_elf_section_data*)(grp)->used_by_bfd)->next_in_group);
  do
    {
      if ((msec->flags & 0x2000) == 0)
 is_debug_grp = 
# 13902 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               0
# 13902 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;

      if ((msec->flags & (0x1 | 0x2 | 0x4)) != 0)
 is_special_grp = 
# 13905 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 0
# 13905 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      ;

      msec = (((struct bfd_elf_section_data*)(msec)->used_by_bfd)->next_in_group);
    }
  while (msec != ssec);



  if (is_debug_grp || is_special_grp)
    {
      do
 {
   msec->gc_mark = 1;
   msec = (((struct bfd_elf_section_data*)(msec)->used_by_bfd)->next_in_group);
 }
      while (msec != ssec);
    }
}




# 13926 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 13927 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_gc_mark_extra_sections (struct bfd_link_info *info,
     elf_gc_mark_hook_fn mark_hook)
{
  bfd *ibfd;

  for (ibfd = info->input_bfds; ibfd != 
# 13932 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 13932 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           ; ibfd = ibfd->link.next)
    {
      asection *isec;
      
# 13935 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 13935 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          some_kept;
      
# 13936 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 13936 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          debug_frag_seen;
      
# 13937 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 13937 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          has_kept_debug_info;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
 continue;
      isec = ibfd->sections;
      if (isec == 
# 13942 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0) 
# 13942 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      || isec->sec_info_type == 4)
 continue;




      debug_frag_seen = some_kept = has_kept_debug_info = 
# 13948 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                         0
# 13948 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                              ;
      for (isec = ibfd->sections; isec != 
# 13949 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                         ((void *)0)
# 13949 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                             ; isec = isec->next)
 {
   if ((isec->flags & 0x100000) != 0)
     isec->gc_mark = 1;
   else if (isec->gc_mark
     && (isec->flags & 0x1) != 0
     && (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr.sh_type) != 7)
     some_kept = 
# 13956 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                1
# 13956 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    ;
   else
     {



       asection *linked_to_sec;
       for (linked_to_sec = (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->linked_to);
     linked_to_sec != 
# 13964 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0) 
# 13964 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          && !linked_to_sec->linker_mark;
     linked_to_sec = (((struct bfd_elf_section_data*)(linked_to_sec)->used_by_bfd)->linked_to))
  {
    if (linked_to_sec->gc_mark)
      {
        if (!_bfd_elf_gc_mark (info, isec, mark_hook))
   return 
# 13970 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 13970 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
        break;
      }
    linked_to_sec->linker_mark = 1;
  }
       for (linked_to_sec = (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->linked_to);
     linked_to_sec != 
# 13976 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     ((void *)0) 
# 13976 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          && linked_to_sec->linker_mark;
     linked_to_sec = (((struct bfd_elf_section_data*)(linked_to_sec)->used_by_bfd)->linked_to))
  linked_to_sec->linker_mark = 0;
     }

   if (!debug_frag_seen
       && (isec->flags & 0x2000)
       && startswith (isec->name, ".debug_line."))
     debug_frag_seen = 
# 13984 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      1
# 13984 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          ;
   else if (strcmp (bfd_section_name (isec),
      "__patchable_function_entries") == 0
     && (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->linked_to) == 
# 13987 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 13987 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           )
       info->callbacks->einfo (dgettext ("bfd", "%F%P: %pB(%pA): error: " "need linked-to section " "for --gc-sections\n")

                           ,
          isec->owner, isec);
 }



      if (!some_kept)
 continue;





      for (isec = ibfd->sections; isec != 
# 14003 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                         ((void *)0)
# 14003 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                             ; isec = isec->next)
 {
   if ((isec->flags & 0x2000000) != 0)
     _bfd_elf_gc_mark_debug_special_section_group (isec);
   else if (((isec->flags & 0x2000) != 0
      || (isec->flags & (0x1 | 0x2 | 0x4)) == 0)
     && (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->next_in_group) == 
# 14009 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
     
# 14010 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
    && (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->linked_to) == 
# 14010 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 14010 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           )
     isec->gc_mark = 1;
   if (isec->gc_mark && (isec->flags & 0x2000) != 0)
     has_kept_debug_info = 
# 14013 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          1
# 14013 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                              ;
 }




      if (debug_frag_seen)
 for (isec = ibfd->sections; isec != 
# 14020 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                    ((void *)0)
# 14020 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                        ; isec = isec->next)
   if ((isec->flags & 0x10) != 0
       && isec->gc_mark == 0)
     {
       unsigned int ilen;
       asection *dsec;

       ilen = strlen (isec->name);





       for (dsec = ibfd->sections; dsec != 
# 14033 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 14033 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              ; dsec = dsec->next)
  {
    unsigned int dlen;

    if (dsec->gc_mark == 0
        || (dsec->flags & 0x2000) == 0)
      continue;

    dlen = strlen (dsec->name);

    if (dlen > ilen
        && strncmp (dsec->name + (dlen - ilen),
      isec->name, ilen) == 0)
      dsec->gc_mark = 0;
  }
   }


      if (has_kept_debug_info)
 for (isec = ibfd->sections; isec != 
# 14052 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                    ((void *)0)
# 14052 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                        ; isec = isec->next)
   if (isec->gc_mark
       && (isec->flags & 0x2000) != 0)
     if (!_bfd_elf_gc_mark (info, isec,
       elf_gc_mark_debug_section))
       return 
# 14057 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 14057 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
    }
  return 
# 14059 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14059 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}

static 
# 14062 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 14063 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_gc_sweep (bfd *abfd, struct bfd_link_info *info)
{
  bfd *sub;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  for (sub = info->input_bfds; sub != 
# 14068 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 14068 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ; sub = sub->link.next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour
   || (((sub) -> tdata.elf_obj_data) -> object_id) != elf_hash_table_id (elf_hash_table (info))
   || !(*bed->relocs_compatible) (sub->xvec, abfd->xvec))
 continue;
      o = sub->sections;
      if (o == 
# 14077 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 14077 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   || o->sec_info_type == 4)
 continue;

      for (o = sub->sections; o != 
# 14080 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 14080 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ; o = o->next)
 {




   if (o->flags & 0x2000000)
     {
       asection *first = (((struct bfd_elf_section_data*)(o)->used_by_bfd)->next_in_group);
       o->gc_mark = first->gc_mark;
     }

   if (o->gc_mark)
     continue;


   if (o->flags & 0x8000)
     continue;



   o->flags |= 0x8000;

   if (info->print_gc_sections && o->size != 0)

     _bfd_error_handler (dgettext ("bfd", "removing unused section '%pA' in file '%pB'"),
    o, sub);
 }
    }

  return 
# 14110 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14110 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




static 
# 14116 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 14117 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_gc_propagate_vtable_entries_used (struct elf_link_hash_entry *h, void *okp)
{

  if (h->start_stop
      || h->u2.vtable == 
# 14121 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0)
      
# 14122 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || h->u2.vtable->parent == 
# 14122 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
# 14122 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    )
    return 
# 14123 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 14123 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (h->u2.vtable->parent == (struct elf_link_hash_entry *) -1)
    return 
# 14127 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 14127 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  if (h->u2.vtable->used && h->u2.vtable->used[-1])
    return 
# 14131 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 14131 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;


  elf_gc_propagate_vtable_entries_used (h->u2.vtable->parent, okp);

  if (h->u2.vtable->used == 
# 14136 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                           ((void *)0)
# 14136 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                               )
    {


      h->u2.vtable->used = h->u2.vtable->parent->u2.vtable->used;
      h->u2.vtable->size = h->u2.vtable->parent->u2.vtable->size;
    }
  else
    {
      size_t n;
      
# 14146 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 14146 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          *cu, *pu;


      cu = h->u2.vtable->used;
      cu[-1] = 
# 14150 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              1
# 14150 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
      pu = h->u2.vtable->parent->u2.vtable->used;
      if (pu != 
# 14152 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
# 14152 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   )
 {
   const struct elf_backend_data *bed;
   unsigned int log_file_align;

   bed = ((const struct elf_backend_data *) ((h->root.u.def.section->owner)->xvec)->backend_data);
   log_file_align = bed->s->log_file_align;
   n = h->u2.vtable->parent->u2.vtable->size >> log_file_align;
   while (n--)
     {
       if (*pu)
  *cu = 
# 14163 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 14163 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;
       pu++;
       cu++;
     }
 }
    }

  return 
# 14170 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14170 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}

struct link_info_ok
{
  struct bfd_link_info *info;
  
# 14176 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 14176 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ok;
};

static 
# 14179 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 14180 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_gc_smash_unused_vtentry_relocs (struct elf_link_hash_entry *h,
        void *ptr)
{
  asection *sec;
  bfd_vma hstart, hend;
  Elf_Internal_Rela *relstart, *relend, *rel;
  const struct elf_backend_data *bed;
  unsigned int log_file_align;
  struct link_info_ok *info = (struct link_info_ok *) ptr;



  if (h->start_stop
      || h->u2.vtable == 
# 14193 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                        ((void *)0)
      
# 14194 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     || h->u2.vtable->parent == 
# 14194 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
# 14194 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                    )
    return 
# 14195 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 14195 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  do { if (!(h->root.type == bfd_link_hash_defined || h->root.type == bfd_link_hash_defweak)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",14197); } while (0)
                                                ;

  sec = h->root.u.def.section;
  hstart = h->root.u.def.value;
  hend = hstart + h->size;

  relstart = _bfd_elf_link_info_read_relocs (sec->owner, info->info,
          sec, 
# 14205 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 14205 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  , 
# 14205 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    ((void *)0)
# 14205 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        , 
# 14205 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                          1
# 14205 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                              );
  if (!relstart)
    return info->ok = 
# 14207 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     0
# 14207 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          ;
  bed = ((const struct elf_backend_data *) ((sec->owner)->xvec)->backend_data);
  log_file_align = bed->s->log_file_align;

  relend = relstart + sec->reloc_count;

  for (rel = relstart; rel < relend; ++rel)
    if (rel->r_offset >= hstart && rel->r_offset < hend)
      {

 if (h->u2.vtable->used
     && (rel->r_offset - hstart) < h->u2.vtable->size)
   {
     bfd_vma entry = (rel->r_offset - hstart) >> log_file_align;
     if (h->u2.vtable->used[entry])
       continue;
   }

 rel->r_offset = rel->r_info = rel->r_addend = 0;
      }

  return 
# 14228 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14228 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}






# 14235 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 14236 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_gc_mark_dynamic_ref_symbol (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info = (struct bfd_link_info *) inf;
  struct bfd_elf_dynamic_list *d = info->dynamic_list;

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && (!h->start_stop
   || h->root.ldscript_def
   || !info->start_stop_gc)
      && ((h->ref_dynamic && !h->forced_local)
   || ((h->def_regular || (!(h)->def_regular && !(h)->def_dynamic && (h)->root.type == bfd_link_hash_defined))
       && ((h->other) & 0x3) != 1
       && ((h->other) & 0x3) != 2
       && (!(((info)->type == type_pde) || ((info)->type == type_pie))
    || info->gc_keep_exported
    || info->export_dynamic
    || (h->dynamic
        && d != 
# 14254 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
        
# 14255 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
       && (*d->match) (&d->head, 
# 14255 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 ((void *)0)
# 14255 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                     , h->root.root.string)))
       && (h->versioned >= versioned
    || !bfd_hide_sym_by_version (info->version_info,
            h->root.root.string)))))
    h->root.u.def.section->flags |= 0x200000;

  return 
# 14261 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14261 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




void
_bfd_elf_gc_keep (struct bfd_link_info *info)
{
  struct bfd_sym_chain *sym;

  for (sym = info->gc_sym_list; sym != 
# 14272 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
# 14272 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          ; sym = sym->next)
    {
      struct elf_link_hash_entry *h;

      h = elf_link_hash_lookup (elf_hash_table (info), sym->name,
    
# 14277 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
   0
# 14277 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        , 
# 14277 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 14277 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               , 
# 14277 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 0
# 14277 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      );

      if (h != 
# 14279 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
   
# 14280 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && (h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
   && !bfd_is_const_section (h->root.u.def.section))
 h->root.u.def.section->flags |= 0x200000;
    }
}


# 14287 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 14288 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_parse_eh_frame_entries (bfd *abfd __attribute__ ((__unused__)),
    struct bfd_link_info *info)
{
  bfd *ibfd = info->input_bfds;

  for (ibfd = info->input_bfds; ibfd != 
# 14293 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 14293 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           ; ibfd = ibfd->link.next)
    {
      asection *sec;
      struct elf_reloc_cookie cookie;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
 continue;
      sec = ibfd->sections;
      if (sec == 
# 14301 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0) 
# 14301 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     || sec->sec_info_type == 4)
 continue;

      if (!init_reloc_cookie (&cookie, info, ibfd))
 return 
# 14305 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 14305 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

      for (sec = ibfd->sections; sec; sec = sec->next)
 {
   if (startswith (bfd_section_name (sec), ".eh_frame_entry")
       && init_reloc_cookie_rels (&cookie, info, ibfd, sec))
     {
       _bfd_elf_parse_eh_frame_entry (info, sec, &cookie);
       fini_reloc_cookie_rels (&cookie, sec);
     }
 }
    }
  return 
# 14317 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14317 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




# 14322 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 14323 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_gc_sections (bfd *abfd, struct bfd_link_info *info)
{
  
# 14325 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
 _Bool 
# 14325 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      ok = 
# 14325 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 14325 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
  bfd *sub;
  elf_gc_mark_hook_fn gc_mark_hook;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  struct elf_link_hash_table *htab;
  struct link_info_ok info_ok;

  if (!bed->can_gc_sections
      || !is_elf_hash_table (info->hash))
    {
      _bfd_error_handler(dgettext ("bfd", "warning: gc-sections option ignored"));
      return 
# 14336 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            1
# 14336 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
    }

  bed->gc_keep (info);
  htab = elf_hash_table (info);



  for (sub = info->input_bfds;
       info->eh_frame_hdr_type != 2 && sub != 
# 14345 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                          ((void *)0)
# 14345 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                              ;
       sub = sub->link.next)
    {
      asection *sec;
      struct elf_reloc_cookie cookie;

      sec = sub->sections;
      if (sec == 
# 14352 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0) 
# 14352 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     || sec->sec_info_type == 4)
 continue;
      sec = bfd_get_section_by_name (sub, ".eh_frame");
      while (sec && init_reloc_cookie_for_section (&cookie, info, sec))
 {
   _bfd_elf_parse_eh_frame (sub, info, sec, &cookie);
   if (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sec_info
       && (sec->flags & 0x100000) == 0)
     (((sub) -> tdata.elf_obj_data) -> eh_frame_section) = sec;
   fini_reloc_cookie_for_section (&cookie, sec);
   sec = bfd_get_next_section_by_name (
# 14362 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                      ((void *)0)
# 14362 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                          , sec);
 }
    }


  elf_link_hash_traverse (htab, elf_gc_propagate_vtable_entries_used, &ok);
  if (!ok)
    return 
# 14369 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 14369 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  info_ok.info = info;
  info_ok.ok = 
# 14373 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              1
# 14373 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
  elf_link_hash_traverse (htab, elf_gc_smash_unused_vtentry_relocs, &info_ok);
  if (!info_ok.ok)
    return 
# 14376 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 14376 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  if (htab->dynamic_sections_created || info->gc_keep_exported)
    elf_link_hash_traverse (htab, bed->gc_mark_dynamic_ref, info);


  gc_mark_hook = bed->gc_mark_hook;
  for (sub = info->input_bfds; sub != 
# 14384 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 14384 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         ; sub = sub->link.next)
    {
      asection *o;

      if (bfd_get_flavour (sub) != bfd_target_elf_flavour
   || (((sub) -> tdata.elf_obj_data) -> object_id) != elf_hash_table_id (htab)
   || !(*bed->relocs_compatible) (sub->xvec, abfd->xvec))
 continue;

      o = sub->sections;
      if (o == 
# 14394 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 14394 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   || o->sec_info_type == 4)
 continue;





      for (o = sub->sections; o != 
# 14401 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 14401 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ; o = o->next)
 if (!o->gc_mark
     && (o->flags & 0x8000) == 0
     && ((o->flags & 0x200000) != 0
  || (((info)->type == type_relocatable)
      && ((((struct bfd_elf_section_data*)(o)->used_by_bfd)->this_hdr.sh_type
    == 16)
   || (((struct bfd_elf_section_data*)(o)->used_by_bfd)->this_hdr.sh_type
       == 14)
   || (((struct bfd_elf_section_data*)(o)->used_by_bfd)->this_hdr.sh_type
       == 15)))
  || (((struct bfd_elf_section_data*)(o)->used_by_bfd)->this_hdr.sh_type == 7
      && (((struct bfd_elf_section_data*)(o)->used_by_bfd)->next_in_group) == 
# 14413 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                 ((void *)0)
      
# 14414 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && (((struct bfd_elf_section_data*)(o)->used_by_bfd)->linked_to) == 
# 14414 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                     ((void *)0)
# 14414 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                         )
  || ((((sub) -> tdata.elf_obj_data)->has_gnu_osabi & elf_gnu_osabi_retain)
      && ((((struct bfd_elf_section_data*)(o)->used_by_bfd)->this_hdr.sh_flags) & (1 << 21)))))
   {
     if (!_bfd_elf_gc_mark (info, o, gc_mark_hook))
       return 
# 14419 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 14419 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
   }
    }


  bed->gc_mark_extra_sections (info, gc_mark_hook);


  return elf_gc_sweep (abfd, info);
}




# 14432 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 14433 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_gc_record_vtinherit (bfd *abfd,
        asection *sec,
        struct elf_link_hash_entry *h,
        bfd_vma offset)
{
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
  struct elf_link_hash_entry **search, *child;
  size_t extsymcount;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);




  extsymcount = ((abfd) -> tdata.elf_obj_data)->symtab_hdr.sh_size / bed->s->sizeof_sym;
  if (!(((abfd) -> tdata.elf_obj_data) -> bad_symtab))
    extsymcount -= ((abfd) -> tdata.elf_obj_data)->symtab_hdr.sh_info;

  sym_hashes = (((abfd) -> tdata.elf_obj_data) -> sym_hashes);
  sym_hashes_end = ((extsymcount) != 0 ? (sym_hashes) + (extsymcount) : (sym_hashes));



  for (search = sym_hashes; search != sym_hashes_end; ++search)
    {
      if ((child = *search) != 
# 14457 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
   
# 14458 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  && (child->root.type == bfd_link_hash_defined
       || child->root.type == bfd_link_hash_defweak)
   && child->root.u.def.section == sec
   && child->root.u.def.value == offset)
 goto win;
    }


  _bfd_error_handler (dgettext ("bfd", "%pB: %pA+%#" 
# 14466 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                     "l" "x" 
# 14466 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ": no symbol found for INHERIT"),
        abfd, sec, (uint64_t) offset);
  bfd_set_error (bfd_error_invalid_operation);
  return 
# 14469 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 14469 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;

 win:
  if (!child->u2.vtable)
    {
      child->u2.vtable = ((struct elf_link_virtual_table_entry *)
     bfd_zalloc (abfd, sizeof (*child->u2.vtable)));
      if (!child->u2.vtable)
 return 
# 14477 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 14477 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }
  if (!h)
    {





      child->u2.vtable->parent = (struct elf_link_hash_entry *) -1;
    }
  else
    child->u2.vtable->parent = h;

  return 
# 14491 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14491 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




# 14496 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 14497 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_gc_record_vtentry (bfd *abfd, asection *sec,
      struct elf_link_hash_entry *h,
      bfd_vma addend)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  unsigned int log_file_align = bed->s->log_file_align;

  if (!h)
    {

      _bfd_error_handler (dgettext ("bfd", "%pB: section '%pA': corrupt VTENTRY entry"),
     abfd, sec);
      bfd_set_error (bfd_error_bad_value);
      return 
# 14510 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 14510 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }

  if (!h->u2.vtable)
    {
      h->u2.vtable = ((struct elf_link_virtual_table_entry *)
        bfd_zalloc (abfd, sizeof (*h->u2.vtable)));
      if (!h->u2.vtable)
 return 
# 14518 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 14518 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
    }

  if (addend >= h->u2.vtable->size)
    {
      size_t size, bytes, file_align;
      
# 14524 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 14524 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          *ptr = h->u2.vtable->used;



      file_align = 1 << log_file_align;
      if (h->root.type == bfd_link_hash_undefined)
 size = addend + file_align;
      else
 {
   size = h->size;
   if (addend >= size)
     {


       size = addend + file_align;
     }
 }
      size = (size + file_align - 1) & -file_align;



      bytes = ((size >> log_file_align) + 1) * sizeof (
# 14545 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                      _Bool
# 14545 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                          );

      if (ptr)
 {
   ptr = (
# 14549 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         _Bool 
# 14549 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              *) bfd_realloc (ptr - 1, bytes);

   if (ptr != 
# 14551 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 14551 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 )
     {
       size_t oldbytes;

       oldbytes = (((h->u2.vtable->size >> log_file_align) + 1)
     * sizeof (
# 14556 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              _Bool
# 14556 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ));
       memset (((char *) ptr) + oldbytes, 0, bytes - oldbytes);
     }
 }
      else
 ptr = (
# 14561 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       _Bool 
# 14561 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            *) bfd_zmalloc (bytes);

      if (ptr == 
# 14563 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 14563 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
 return 
# 14564 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 14564 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;


      h->u2.vtable->used = ptr + 1;
      h->u2.vtable->size = size;
    }

  h->u2.vtable->used[addend >> log_file_align] = 
# 14571 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                1
# 14571 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                    ;

  return 
# 14573 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14573 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}


typedef struct
{
  char *flag_name;
  flagword flag_value;
} elf_flags_to_name_table;

static const elf_flags_to_name_table elf_flags_to_names [] =
{
  { "SHF_WRITE", (1 << 0) },
  { "SHF_ALLOC", (1 << 1) },
  { "SHF_EXECINSTR", (1 << 2) },
  { "SHF_MERGE", (1 << 4) },
  { "SHF_STRINGS", (1 << 5) },
  { "SHF_INFO_LINK", (1 << 6)},
  { "SHF_LINK_ORDER", (1 << 7)},
  { "SHF_OS_NONCONFORMING", (1 << 8)},
  { "SHF_GROUP", (1 << 9) },
  { "SHF_TLS", (1 << 10) },
  { "SHF_MASKOS", 0x0FF00000 },
  { "SHF_EXCLUDE", 0x80000000 },
};



# 14600 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 14601 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_lookup_section_flags (struct bfd_link_info *info,
         struct flag_info *flaginfo,
         asection *section)
{
  const bfd_vma sh_flags = (((struct bfd_elf_section_data*)(section)->used_by_bfd)->this_hdr.sh_flags);

  if (!flaginfo->flags_initialized)
    {
      bfd *obfd = info->output_bfd;
      const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((obfd)->xvec)->backend_data);
      struct flag_info_list *tf = flaginfo->flag_list;
      int with_hex = 0;
      int without_hex = 0;

      for (tf = flaginfo->flag_list; tf != 
# 14615 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 14615 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              ; tf = tf->next)
 {
   unsigned i;
   flagword (*lookup) (char *);

   lookup = bed->elf_backend_lookup_section_flags_hook;
   if (lookup != 
# 14621 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                ((void *)0)
# 14621 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                    )
     {
       flagword hexval = (*lookup) ((char *) tf->name);

       if (hexval != 0)
  {
    if (tf->with == with_flags)
      with_hex |= hexval;
    else if (tf->with == without_flags)
      without_hex |= hexval;
    tf->valid = 
# 14631 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               1
# 14631 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
    continue;
  }
     }
   for (i = 0; i < (sizeof (elf_flags_to_names) / sizeof ((elf_flags_to_names)[0])); ++i)
     {
       if (strcmp (tf->name, elf_flags_to_names[i].flag_name) == 0)
  {
    if (tf->with == with_flags)
      with_hex |= elf_flags_to_names[i].flag_value;
    else if (tf->with == without_flags)
      without_hex |= elf_flags_to_names[i].flag_value;
    tf->valid = 
# 14643 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               1
# 14643 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   ;
    break;
  }
     }
   if (!tf->valid)
     {
       info->callbacks->einfo
  (dgettext ("bfd", "unrecognized INPUT_SECTION_FLAG %s\n"), tf->name);
       return 
# 14651 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 14651 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  ;
     }
 }
      flaginfo->flags_initialized = 
# 14654 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   1
# 14654 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                       ;
      flaginfo->only_with_flags |= with_hex;
      flaginfo->not_with_flags |= without_hex;
    }

  if ((flaginfo->only_with_flags & sh_flags) != flaginfo->only_with_flags)
    return 
# 14660 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 14660 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  if ((flaginfo->not_with_flags & sh_flags) != 0)
    return 
# 14663 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 14663 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  return 
# 14665 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14665 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}

struct alloc_got_off_arg {
  bfd_vma gotoff;
  struct bfd_link_info *info;
};




static 
# 14676 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      _Bool

# 14677 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
elf_gc_allocate_got_offsets (struct elf_link_hash_entry *h, void *arg)
{
  struct alloc_got_off_arg *gofarg = (struct alloc_got_off_arg *) arg;
  bfd *obfd = gofarg->info->output_bfd;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((obfd)->xvec)->backend_data);

  if (h->got.refcount > 0)
    {
      h->got.offset = gofarg->gotoff;
      gofarg->gotoff += bed->got_elt_size (obfd, gofarg->info, h, 
# 14686 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                                 ((void *)0)
# 14686 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                     , 0);
    }
  else
    h->got.offset = (bfd_vma) -1;

  return 
# 14691 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14691 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





# 14697 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 14698 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_gc_common_finalize_got_offsets (bfd *abfd,
     struct bfd_link_info *info)
{
  bfd *i;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  bfd_vma gotoff;
  struct alloc_got_off_arg gofarg;

  do { if (!(abfd == info->output_bfd)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",14706); } while (0);

  if (! is_elf_hash_table (info->hash))
    return 
# 14709 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 14709 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



  if (bed->want_got_plt)
    gotoff = 0;
  else
    gotoff = bed->got_header_size;


  for (i = info->input_bfds; i; i = i->link.next)
    {
      bfd_signed_vma *local_got;
      size_t j, locsymcount;
      Elf_Internal_Shdr *symtab_hdr;

      if (bfd_get_flavour (i) != bfd_target_elf_flavour)
 continue;

      local_got = (((i) -> tdata.elf_obj_data) -> local_got.refcounts);
      if (!local_got)
 continue;

      symtab_hdr = &((i) -> tdata.elf_obj_data)->symtab_hdr;
      if ((((i) -> tdata.elf_obj_data) -> bad_symtab))
 locsymcount = symtab_hdr->sh_size / bed->s->sizeof_sym;
      else
 locsymcount = symtab_hdr->sh_info;

      for (j = 0; j < locsymcount; ++j)
 {
   if (local_got[j] > 0)
     {
       local_got[j] = gotoff;
       gotoff += bed->got_elt_size (abfd, info, 
# 14743 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                               ((void *)0)
# 14743 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                   , i, j);
     }
   else
     local_got[j] = (bfd_vma) -1;
 }
    }



  gofarg.gotoff = gotoff;
  gofarg.info = info;
  elf_link_hash_traverse (elf_hash_table (info),
     elf_gc_allocate_got_offsets,
     &gofarg);
  return 
# 14757 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 14757 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





# 14763 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 14764 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_gc_common_final_link (bfd *abfd, struct bfd_link_info *info)
{
  if (!bfd_elf_gc_common_finalize_got_offsets (abfd, info))
    return 
# 14767 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 14767 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  return bfd_elf_final_link (abfd, info);
}


# 14773 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 14774 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
bfd_elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
{
  struct elf_reloc_cookie *rcookie = (struct elf_reloc_cookie *) cookie;

  if (rcookie->bad_symtab)
    rcookie->rel = rcookie->rels;

  for (; rcookie->rel < rcookie->relend; rcookie->rel++)
    {
      unsigned long r_symndx;

      if (! rcookie->bad_symtab)
 if (rcookie->rel->r_offset > offset)
   return 
# 14787 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         0
# 14787 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;
      if (rcookie->rel->r_offset != offset)
 continue;

      r_symndx = rcookie->rel->r_info >> rcookie->r_sym_shift;
      if (r_symndx == 0)
 return 
# 14793 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       1
# 14793 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;

      if (r_symndx >= rcookie->locsymcount
   || (((unsigned int)(rcookie->locsyms[r_symndx].st_info)) >> 4) != 0)
 {
   struct elf_link_hash_entry *h;

   h = rcookie->sym_hashes[r_symndx - rcookie->extsymoff];

   while (h->root.type == bfd_link_hash_indirect
   || h->root.type == bfd_link_hash_warning)
     h = (struct elf_link_hash_entry *) h->root.u.i.link;

   if ((h->root.type == bfd_link_hash_defined
        || h->root.type == bfd_link_hash_defweak)
       && (h->root.u.def.section->owner != rcookie->abfd
    || h->root.u.def.section->kept_section != 
# 14809 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             ((void *)0)
    
# 14810 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   || discarded_section (h->root.u.def.section)))
     return 
# 14811 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 14811 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
 }
      else
 {



   asection *isec;
   Elf_Internal_Sym *isym;


   isym = &rcookie->locsyms[r_symndx];
   isec = bfd_section_from_elf_index (rcookie->abfd, isym->st_shndx);
   if (isec != 
# 14824 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
       
# 14825 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && (isec->kept_section != 
# 14825 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                ((void *)0)
    
# 14826 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
   || discarded_section (isec)))
     return 
# 14827 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           1
# 14827 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;
 }
      return 
# 14829 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 14829 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }
  return 
# 14831 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 14831 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
}






int
bfd_elf_discard_info (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf_reloc_cookie cookie;
  asection *o;
  bfd *abfd;
  int changed = 0;

  if (info->traditional_format
      || !is_elf_hash_table (info->hash))
    return 0;

  o = bfd_get_section_by_name (output_bfd, ".stab");
  if (o != 
# 14852 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 14852 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {
      asection *i;

      for (i = o->map_head.s; i != 
# 14856 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 14856 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ; i = i->map_head.s)
 {
   if (i->size == 0
       || i->reloc_count == 0
       || i->sec_info_type != 1)
     continue;

   abfd = i->owner;
   if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
     continue;

   if (!init_reloc_cookie_for_section (&cookie, info, i))
     return -1;

   if (_bfd_discard_section_stabs (abfd, i,
       ((struct bfd_elf_section_data*)(i)->used_by_bfd)->sec_info,
       bfd_elf_reloc_symbol_deleted_p,
       &cookie))
     changed = 1;

   fini_reloc_cookie_for_section (&cookie, i);
 }
    }

  o = 
# 14880 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     ((void *)0)
# 14880 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
         ;
  if (info->eh_frame_hdr_type != 2)
    o = bfd_get_section_by_name (output_bfd, ".eh_frame");
  if (o != 
# 14883 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 14883 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {
      asection *i;
      int eh_changed = 0;
      unsigned int eh_alignment;

      for (i = o->map_head.s; i != 
# 14889 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 14889 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ; i = i->map_head.s)
 {
   if (i->size == 0)
     continue;

   abfd = i->owner;
   if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
     continue;

   if (!init_reloc_cookie_for_section (&cookie, info, i))
     return -1;

   _bfd_elf_parse_eh_frame (abfd, info, i, &cookie);
   if (_bfd_elf_discard_section_eh_frame (abfd, info, i,
       bfd_elf_reloc_symbol_deleted_p,
       &cookie))
     {
       eh_changed = 1;
       if (i->size != i->rawsize)
  changed = 1;
     }

   fini_reloc_cookie_for_section (&cookie, i);
 }

      eh_alignment = ((1 << o->alignment_power)
        * bfd_octets_per_byte (output_bfd, o));


      for (i = o->map_tail.s; i != 
# 14918 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 14918 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ; i = i->map_tail.s)
 if (i->size == 0)
   i->flags |= 0x8000;
 else if (i->size > 4)
   break;

      if (i != 
# 14924 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0)
# 14924 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  )
 i = i->map_tail.s;



      for (; i != 
# 14929 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 14929 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     ; i = i->map_tail.s)
 if (i->size == 4)

   do { bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",14932); } while (0);
 else
   {
     bfd_size_type size
       = (i->size + eh_alignment - 1) & -eh_alignment;
     if (i->size != size)
       {
  i->size = size;
  changed = 1;
  eh_changed = 1;
       }
   }
      if (eh_changed)
 elf_link_hash_traverse (elf_hash_table (info),
    _bfd_elf_adjust_eh_frame_global_symbol, 
# 14946 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 14946 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               );
    }

  o = bfd_get_section_by_name (output_bfd, ".sframe");
  if (o != 
# 14950 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 14950 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              )
    {
      asection *i;

      for (i = o->map_head.s; i != 
# 14954 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                  ((void *)0)
# 14954 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                      ; i = i->map_head.s)
 {
   if (i->size == 0)
     continue;

   abfd = i->owner;
   if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
     continue;

   if (!init_reloc_cookie_for_section (&cookie, info, i))
     return -1;

   if (_bfd_elf_parse_sframe (abfd, info, i, &cookie))
     {
       if (_bfd_elf_discard_section_sframe (i,
         bfd_elf_reloc_symbol_deleted_p,
         &cookie))
  {
    if (i->size != i->rawsize)
      changed = 1;
  }
     }
   fini_reloc_cookie_for_section (&cookie, i);
 }


      if (!_bfd_elf_set_section_sframe (output_bfd, info))
 return -1;
    }

  for (abfd = info->input_bfds; abfd != 
# 14984 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                       ((void *)0)
# 14984 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                           ; abfd = abfd->link.next)
    {
      const struct elf_backend_data *bed;
      asection *s;

      if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
 continue;
      s = abfd->sections;
      if (s == 
# 14992 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 14992 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   || s->sec_info_type == 4)
 continue;

      bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

      if (bed->elf_backend_discard_info != 
# 14997 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 14997 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              )
 {
   if (!init_reloc_cookie (&cookie, info, abfd))
     return -1;

   if ((*bed->elf_backend_discard_info) (abfd, &cookie, info))
     changed = 1;

   fini_reloc_cookie (&cookie, abfd);
 }
    }

  if (info->eh_frame_hdr_type == 2)
    _bfd_elf_end_eh_frame_parsing (info);

  if (info->eh_frame_hdr_type
      && !((info)->type == type_relocatable)
      && _bfd_elf_discard_section_eh_frame_hdr (info))
    changed = 1;

  return changed;
}


# 15020 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 15021 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_section_already_linked (bfd *abfd,
     asection *sec,
     struct bfd_link_info *info)
{
  flagword flags;
  const char *name, *key;
  struct bfd_section_already_linked *l;
  struct bfd_section_already_linked_hash_entry *already_linked_list;

  if (sec->output_section == (&_bfd_std_section[2]))
    return 
# 15031 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 15031 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;

  flags = sec->flags;



  if ((flags & 0x20000) == 0)
    return 
# 15038 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 15038 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;



  if ((((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sec_group) != 
# 15042 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                            ((void *)0)
# 15042 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                )
    return 
# 15043 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          0
# 15043 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
               ;


  name = sec->name;
  if ((flags & 0x2000000) != 0
      && (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->next_in_group) != 
# 15048 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                   ((void *)0)
      
# 15049 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && (((struct bfd_elf_section_data*)((((struct bfd_elf_section_data*)(sec)->used_by_bfd)->next_in_group))->used_by_bfd)->group.name) != 
# 15049 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                    ((void *)0)
# 15049 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                        )
    key = (((struct bfd_elf_section_data*)((((struct bfd_elf_section_data*)(sec)->used_by_bfd)->next_in_group))->used_by_bfd)->group.name);
  else
    {

      if (startswith (name, ".gnu.linkonce.")
   && (key = strchr (name + sizeof (".gnu.linkonce.") - 1, '.')) != 
# 15055 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                                   ((void *)0)
# 15055 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                       )
 key++;
      else



 key = name;
    }

  already_linked_list = bfd_section_already_linked_table_lookup (key);

  for (l = already_linked_list->entry; l != 
# 15066 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                           ((void *)0)
# 15066 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                               ; l = l->next)
    {






      if (((flags & 0x2000000) == (l->sec->flags & 0x2000000)
    && ((flags & 0x2000000) != 0
        || strcmp (name, l->sec->name) == 0))
   || (l->sec->owner->flags & 0x10000) != 0
   || (sec->owner->flags & 0x10000) != 0)
 {


   if (!_bfd_handle_already_linked (sec, l, info))
     return 
# 15083 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 15083 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;

   if (flags & 0x2000000)
     {
       asection *first = (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->next_in_group);
       asection *s = first;

       while (s != 
# 15090 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 15090 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
  {
    s->output_section = (&_bfd_std_section[2]);

    s->kept_section = l->sec;
    s = (((struct bfd_elf_section_data*)(s)->used_by_bfd)->next_in_group);

    if (s == first)
      break;
  }
     }

   return 
# 15102 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
         1
# 15102 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
 }
    }



  if ((flags & 0x2000000) != 0)
    {
      asection *first = (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->next_in_group);

      if (first != 
# 15112 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0) 
# 15112 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       && (((struct bfd_elf_section_data*)(first)->used_by_bfd)->next_in_group) == first)

 for (l = already_linked_list->entry; l != 
# 15114 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                          ((void *)0)
# 15114 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                              ; l = l->next)
   if ((l->sec->flags & 0x2000000) == 0
       && bfd_elf_match_symbols_in_sections (l->sec, first, info))
     {
       first->output_section = (&_bfd_std_section[2]);
       first->kept_section = l->sec;
       sec->output_section = (&_bfd_std_section[2]);
       break;
     }
    }
  else

    for (l = already_linked_list->entry; l != 
# 15126 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             ((void *)0)
# 15126 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                 ; l = l->next)
      if (l->sec->flags & 0x2000000)
 {
   asection *first = (((struct bfd_elf_section_data*)(l->sec)->used_by_bfd)->next_in_group);

   if (first != 
# 15131 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
               ((void *)0)
       
# 15132 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      && (((struct bfd_elf_section_data*)(first)->used_by_bfd)->next_in_group) == first
       && bfd_elf_match_symbols_in_sections (first, sec, info))
     {
       sec->output_section = (&_bfd_std_section[2]);
       sec->kept_section = first;
       break;
     }
 }
# 15153 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
  if ((flags & 0x2000000) == 0 && startswith (name, ".gnu.linkonce.r."))
    for (l = already_linked_list->entry; l != 
# 15154 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                             ((void *)0)
# 15154 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                 ; l = l->next)
      if ((l->sec->flags & 0x2000000) == 0
   && startswith (l->sec->name, ".gnu.linkonce.t."))
 {
   if (abfd != l->sec->owner)
     sec->output_section = (&_bfd_std_section[2]);
   break;
 }


  if (!bfd_section_already_linked_table_insert (already_linked_list, sec))
    info->callbacks->einfo (dgettext ("bfd", "%F%P: already_linked_table: %E\n"));
  return sec->output_section == (&_bfd_std_section[2]);
}


# 15169 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 15170 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_common_definition (Elf_Internal_Sym *sym)
{
  return sym->st_shndx == (-0xEu);
}

unsigned int
_bfd_elf_common_section_index (asection *sec __attribute__ ((__unused__)))
{
  return (-0xEu);
}

asection *
_bfd_elf_common_section (asection *sec __attribute__ ((__unused__)))
{
  return (&_bfd_std_section[0]);
}

bfd_vma
_bfd_elf_default_got_elt_size (bfd *abfd,
          struct bfd_link_info *info __attribute__ ((__unused__)),
          struct elf_link_hash_entry *h __attribute__ ((__unused__)),
          bfd *ibfd __attribute__ ((__unused__)),
          unsigned long symndx __attribute__ ((__unused__)))
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  return bed->s->arch_size / 8;
}





static const char *
get_dynamic_reloc_section_name (bfd * abfd,
    asection * sec,
    
# 15205 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
   _Bool 
# 15205 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
        is_rela)
{
  char *name;
  const char *old_name = bfd_section_name (sec);
  const char *prefix = is_rela ? ".rela" : ".rel";

  if (old_name == 
# 15211 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 15211 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
    return 
# 15212 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
# 15212 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  name = bfd_alloc (abfd, strlen (prefix) + strlen (old_name) + 1);
  sprintf (name, "%s%s", prefix, old_name);

  return name;
}






asection *
_bfd_elf_get_dynamic_reloc_section (bfd *abfd,
        asection *sec,
        
# 15228 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       _Bool 
# 15228 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            is_rela)
{
  asection *reloc_sec = ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sreloc;

  if (reloc_sec == 
# 15232 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 15232 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
    {
      const char *name = get_dynamic_reloc_section_name (abfd, sec, is_rela);

      if (name != 
# 15236 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 15236 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
 {
   reloc_sec = bfd_get_linker_section (abfd, name);

   if (reloc_sec != 
# 15240 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 15240 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
     ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sreloc = reloc_sec;
 }
    }

  return reloc_sec;
}
# 15258 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
asection *
_bfd_elf_make_dynamic_reloc_section (asection *sec,
         bfd *dynobj,
         unsigned int alignment,
         bfd *abfd,
         
# 15263 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        _Bool 
# 15263 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             is_rela)
{
  asection * reloc_sec = ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sreloc;

  if (reloc_sec == 
# 15267 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                  ((void *)0)
# 15267 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                      )
    {
      const char * name = get_dynamic_reloc_section_name (abfd, sec, is_rela);

      if (name == 
# 15271 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                 ((void *)0)
# 15271 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                     )
 return 
# 15272 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       ((void *)0)
# 15272 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           ;

      reloc_sec = bfd_get_linker_section (dynobj, name);

      if (reloc_sec == 
# 15276 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                      ((void *)0)
# 15276 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                          )
 {
   flagword flags = (0x100 | 0x8
       | 0x4000 | 0x100000);
   if ((sec->flags & 0x1) != 0)
     flags |= 0x1 | 0x2;

   reloc_sec = bfd_make_section_anyway_with_flags (dynobj, name, flags);
   if (reloc_sec != 
# 15284 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                   ((void *)0)
# 15284 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                       )
     {




       (((struct bfd_elf_section_data*)(reloc_sec)->used_by_bfd)->this_hdr.sh_type) = is_rela ? 4 : 9;
       if (!bfd_set_section_alignment (reloc_sec, alignment))
  reloc_sec = 
# 15292 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             ((void *)0)
# 15292 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
     }
 }

      ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sreloc = reloc_sec;
    }

  return reloc_sec;
}





void
_bfd_elf_copy_link_hash_symbol_type (bfd *abfd,
         struct bfd_link_hash_entry *hdest,
         struct bfd_link_hash_entry *hsrc)
{
  struct elf_link_hash_entry *ehdest = (struct elf_link_hash_entry *) hdest;
  struct elf_link_hash_entry *ehsrc = (struct elf_link_hash_entry *) hsrc;
  Elf_Internal_Sym isym;

  ehdest->type = ehsrc->type;
  ehdest->target_internal = ehsrc->target_internal;

  isym.st_other = ehsrc->other;
  elf_merge_st_other (abfd, ehdest, isym.st_other, 
# 15319 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                  ((void *)0)
# 15319 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                      , 
# 15319 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                        1
# 15319 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                            , 
# 15319 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                                              0
# 15319 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                                   );
}



void
elf_append_rela (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  bfd_byte *loc = s->contents + (s->reloc_count++ * bed->s->sizeof_rela);
  do { if (!(loc + bed->s->sizeof_rela <= s->contents + s->size)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",15329); } while (0);
  bed->s->swap_reloca_out (abfd, rel, loc);
}



void
elf_append_rel (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  bfd_byte *loc = s->contents + (s->reloc_count++ * bed->s->sizeof_rel);
  do { if (!(loc + bed->s->sizeof_rel <= s->contents + s->size)) bfd_assert("/doner/binutils/binutils-515f23e/bfd/elflink.c",15340); } while (0);
  bed->s->swap_reloc_out (abfd, rel, loc);
}



struct bfd_link_hash_entry *
bfd_elf_define_start_stop (struct bfd_link_info *info,
      const char *symbol, asection *sec)
{
  struct elf_link_hash_entry *h;

  h = elf_link_hash_lookup (elf_hash_table (info), symbol,
       
# 15353 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
      0
# 15353 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
           , 
# 15353 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
             0
# 15353 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                  , 
# 15353 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                    1
# 15353 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                        );

  if (h != 
# 15355 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          ((void *)0)
      
# 15356 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
     && !h->root.ldscript_def
      && (h->root.type == bfd_link_hash_undefined
   || h->root.type == bfd_link_hash_undefweak
   || ((h->ref_regular || h->def_dynamic)
       && !h->def_regular
       && h->root.type != bfd_link_hash_common)))
    {
      
# 15363 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 15363 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          was_dynamic = h->ref_dynamic || h->def_dynamic;
      h->verinfo.verdef = 
# 15364 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                         ((void *)0)
# 15364 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                             ;
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = sec;
      h->root.u.def.value = 0;
      h->def_regular = 1;
      h->def_dynamic = 0;
      h->start_stop = 1;
      h->u2.start_stop_section = sec;
      if (symbol[0] == '.')
 {

   const struct elf_backend_data *bed;
   bed = ((const struct elf_backend_data *) ((info->output_bfd)->xvec)->backend_data);
   (*bed->elf_backend_hide_symbol) (info, h, 
# 15377 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                                            1
# 15377 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                                );
 }
      else
 {
   if (((h->other) & 0x3) == 0)
     h->other = ((h->other & ~((-1) & 0x3))
   | info->start_stop_visibility);
   if (was_dynamic)
     bfd_elf_link_record_dynamic_symbol (info, h);
 }
      return &h->root;
    }
  return 
# 15389 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 15389 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}



asection *
_bfd_elf_readonly_dynrelocs (struct elf_link_hash_entry *h)
{
  struct elf_dyn_relocs *p;

  for (p = h->dyn_relocs; p != 
# 15399 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
                              ((void *)0)
# 15399 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                                  ; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != 
# 15403 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
              ((void *)0) 
# 15403 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                   && (s->flags & 0x8) != 0)
 return p->sec;
    }
  return 
# 15406 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        ((void *)0)
# 15406 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}





# 15412 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 15413 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_maybe_set_textrel (struct elf_link_hash_entry *h, void *inf)
{
  asection *sec;

  if (h->root.type == bfd_link_hash_indirect)
    return 
# 15418 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
          1
# 15418 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
              ;

  sec = _bfd_elf_readonly_dynrelocs (h);
  if (sec != 
# 15421 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            ((void *)0)
# 15421 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                )
    {
      struct bfd_link_info *info = (struct bfd_link_info *) inf;

      info->flags |= (1 << 2);

      info->callbacks->minfo (dgettext ("bfd", "%pB: dynamic relocation against `%pT' " "in read-only section `%pA'\n")
                                   ,
         sec->owner, h->root.root.string, sec);

      if ((info->textrel_check != textrel_check_none))

 info->callbacks->einfo (dgettext ("bfd", "%P: %pB: warning: relocation against `%s' " "in read-only section `%pA'\n")
                                     ,
    sec->owner, h->root.root.string, sec);


      return 
# 15438 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
            0
# 15438 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                 ;
    }
  return 
# 15440 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 15440 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}




# 15445 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
_Bool

# 15446 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
_bfd_elf_add_dynamic_tags (bfd *output_bfd, struct bfd_link_info *info,
      
# 15447 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
     _Bool 
# 15447 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
          need_dynamic_reloc)
{
  struct elf_link_hash_table *htab = elf_hash_table (info);

  if (htab->dynamic_sections_created)
    {
# 15461 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
      const struct elf_backend_data *bed
 = ((const struct elf_backend_data *) ((output_bfd)->xvec)->backend_data);

      if ((((info)->type == type_pde) || ((info)->type == type_pie)))
 {
   if (!_bfd_elf_add_dynamic_entry (info, 21, 0))
     return 
# 15467 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 15467 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (htab->dt_pltgot_required || htab->splt->size != 0)
 {


   if (!_bfd_elf_add_dynamic_entry (info, 3, 0))
     return 
# 15475 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 15475 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (htab->dt_jmprel_required || htab->srelplt->size != 0)
 {
   if (!_bfd_elf_add_dynamic_entry (info, 2, 0)
       || !_bfd_elf_add_dynamic_entry (info, 20, (bed->rela_plts_and_copies_p ? 7 : 17))


       || !_bfd_elf_add_dynamic_entry (info, 23, 0))
     return 
# 15485 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
           0
# 15485 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
                ;
 }

      if (htab->tlsdesc_plt
   && (!_bfd_elf_add_dynamic_entry (info, 0x6ffffef6, 0)
       || !_bfd_elf_add_dynamic_entry (info, 0x6ffffef7, 0)))
 return 
# 15491 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
       0
# 15491 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;

      if (need_dynamic_reloc)
 {
   if (bed->rela_plts_and_copies_p)
     {
       if (!_bfd_elf_add_dynamic_entry (info, 7, 0)
    || !_bfd_elf_add_dynamic_entry (info, 8, 0)
    || !_bfd_elf_add_dynamic_entry (info, 9, bed->s->sizeof_rela)
                          )
  return 
# 15501 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 15501 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
     }
   else
     {
       if (!_bfd_elf_add_dynamic_entry (info, 17, 0)
    || !_bfd_elf_add_dynamic_entry (info, 18, 0)
    || !_bfd_elf_add_dynamic_entry (info, 19, bed->s->sizeof_rel)
                         )
  return 
# 15509 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 15509 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
     }



   if ((info->flags & (1 << 2)) == 0)
     elf_link_hash_traverse (htab, _bfd_elf_maybe_set_textrel,
        info);

   if ((info->flags & (1 << 2)) != 0)
     {
       if (htab->ifunc_resolvers)
  info->callbacks->einfo
    (dgettext ("bfd", "%P: warning: GNU indirect functions with DT_TEXTREL " "may result in a segfault at runtime; recompile with %s\n")
                                                                  ,
     ((info)->type == type_dll) ? "-fPIC" : "-fPIE");

       if (!_bfd_elf_add_dynamic_entry (info, 22, 0))
  return 
# 15527 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        0
# 15527 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
             ;
     }
 }
    }


  return 
# 15533 "/doner/binutils/binutils-515f23e/bfd/elflink.c" 3 4
        1
# 15533 "/doner/binutils/binutils-515f23e/bfd/elflink.c"
            ;
}
