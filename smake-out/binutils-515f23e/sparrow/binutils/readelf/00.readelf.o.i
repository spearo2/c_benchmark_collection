# 1 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
# 1 "/doner/binutils/binutils-515f23e/binutils//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
# 43 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
# 1 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 1
# 23 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h"
# 1 "/doner/binutils/binutils-515f23e/binutils/./config.h" 1
# 24 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 873 "/usr/include/stdio.h" 3 4

# 25 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 27 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2


# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));


# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4



int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 5)));


# 39 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 447 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 534 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 30 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2

# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 272 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 273 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1014 "/usr/include/stdlib.h" 2 3 4
# 1023 "/usr/include/stdlib.h" 3 4

# 32 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 104 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 115 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 266 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 360 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 499 "/usr/include/string.h" 3 4

# 33 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 34 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2
# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4




# 35 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2

# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 870 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 991 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1003 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1014 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1024 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1035 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1056 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1079 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1089 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1107 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1124 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1161 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;
# 1170 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));
# 1171 "/usr/include/unistd.h" 2 3 4


# 37 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2


# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 353 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 392 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 447 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 148 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 168 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 178 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 293 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 304 "/usr/include/fcntl.h" 3 4

# 40 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2






# 1 "./../include/ansidecl.h" 1
# 47 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2
# 1 "../bfd/bfdver.h" 1
# 48 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2




# 1 "./../include/fopen-same.h" 1
# 53 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2


# 1 "./../include/binary-io.h" 1
# 56 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2
# 92 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h"
# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4


# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) __attribute__ ((__nothrow__ , __leaf__));
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));



extern void freelocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));






extern locale_t uselocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));








# 93 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2


# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4





extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/libintl.h" 3 4

# 96 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2
# 121 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 122 "/doner/binutils/binutils-515f23e/binutils/./sysdep.h" 2
# 44 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4



extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 45 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4




extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 46 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../zlib/zlib.h" 1
# 34 "./../zlib/zlib.h"
# 1 "./../zlib/zconf.h" 1
# 247 "./../zlib/zconf.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;
# 248 "./../zlib/zconf.h" 2
     
# 248 "./../zlib/zconf.h"
    typedef size_t z_size_t;
# 391 "./../zlib/zconf.h"
typedef unsigned char Byte;

typedef unsigned int uInt;
typedef unsigned long uLong;





   typedef Byte Bytef;

typedef char charf;
typedef int intf;
typedef uInt uIntf;
typedef uLong uLongf;


   typedef void const *voidpc;
   typedef void *voidpf;
   typedef void *voidp;







# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 419 "./../zlib/zconf.h" 2
# 429 "./../zlib/zconf.h"
   typedef unsigned z_crc_t;
# 35 "./../zlib/zlib.h" 2
# 81 "./../zlib/zlib.h"
typedef voidpf (*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void (*free_func) (voidpf opaque, voidpf address);

struct internal_state;

typedef struct z_stream_s {
    Bytef *next_in;
    uInt avail_in;
    uLong total_in;

    Bytef *next_out;
    uInt avail_out;
    uLong total_out;

    char *msg;
    struct internal_state *state;

    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;

    int data_type;

    uLong adler;
    uLong reserved;
} z_stream;

typedef z_stream *z_streamp;





typedef struct gz_header_s {
    int text;
    uLong time;
    int xflags;
    int os;
    Bytef *extra;
    uInt extra_len;
    uInt extra_max;
    Bytef *name;
    uInt name_max;
    Bytef *comment;
    uInt comm_max;
    int hcrc;
    int done;

} gz_header;

typedef gz_header *gz_headerp;
# 220 "./../zlib/zlib.h"
extern const char * zlibVersion (void);
# 250 "./../zlib/zlib.h"
extern int deflate (z_streamp strm, int flush);
# 363 "./../zlib/zlib.h"
extern int deflateEnd (z_streamp strm);
# 400 "./../zlib/zlib.h"
extern int inflate (z_streamp strm, int flush);
# 520 "./../zlib/zlib.h"
extern int inflateEnd (z_streamp strm);
# 610 "./../zlib/zlib.h"
extern int deflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength)

                                                               ;
# 654 "./../zlib/zlib.h"
extern int deflateGetDictionary (z_streamp strm, Bytef *dictionary, uInt *dictLength)

                                                                ;
# 676 "./../zlib/zlib.h"
extern int deflateCopy (z_streamp dest, z_streamp source)
                                                      ;
# 694 "./../zlib/zlib.h"
extern int deflateReset (z_streamp strm);
# 705 "./../zlib/zlib.h"
extern int deflateParams (z_streamp strm, int level, int strategy)

                                                    ;
# 743 "./../zlib/zlib.h"
extern int deflateTune (z_streamp strm, int good_length, int max_lazy, int nice_length, int max_chain)



                                                   ;
# 760 "./../zlib/zlib.h"
extern uLong deflateBound (z_streamp strm, uLong sourceLen)
                                                        ;
# 775 "./../zlib/zlib.h"
extern int deflatePending (z_streamp strm, unsigned *pending, int *bits)

                                                  ;
# 790 "./../zlib/zlib.h"
extern int deflatePrime (z_streamp strm, int bits, int value)

                                                ;
# 807 "./../zlib/zlib.h"
extern int deflateSetHeader (z_streamp strm, gz_headerp head)
                                                          ;
# 886 "./../zlib/zlib.h"
extern int inflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength)

                                                               ;
# 909 "./../zlib/zlib.h"
extern int inflateGetDictionary (z_streamp strm, Bytef *dictionary, uInt *dictLength)

                                                                ;
# 924 "./../zlib/zlib.h"
extern int inflateSync (z_streamp strm);
# 943 "./../zlib/zlib.h"
extern int inflateCopy (z_streamp dest, z_streamp source)
                                                      ;
# 959 "./../zlib/zlib.h"
extern int inflateReset (z_streamp strm);
# 969 "./../zlib/zlib.h"
extern int inflateReset2 (z_streamp strm, int windowBits)
                                                      ;
# 983 "./../zlib/zlib.h"
extern int inflatePrime (z_streamp strm, int bits, int value)

                                                ;
# 1004 "./../zlib/zlib.h"
extern long inflateMark (z_streamp strm);
# 1032 "./../zlib/zlib.h"
extern int inflateGetHeader (z_streamp strm, gz_headerp head)
                                                          ;
# 1094 "./../zlib/zlib.h"
typedef unsigned (*in_func) (void *, unsigned char * *)
                                                                   ;
typedef int (*out_func) (void *, unsigned char *, unsigned);

extern int inflateBack (z_streamp strm, in_func in, void *in_desc, out_func out, void *out_desc)

                                                                      ;
# 1168 "./../zlib/zlib.h"
extern int inflateBackEnd (z_streamp strm);







extern uLong zlibCompileFlags (void);
# 1229 "./../zlib/zlib.h"
extern int compress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
                                                                       ;
# 1244 "./../zlib/zlib.h"
extern int compress2 (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level)

                                             ;
# 1260 "./../zlib/zlib.h"
extern uLong compressBound (uLong sourceLen);






extern int uncompress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
                                                                         ;
# 1285 "./../zlib/zlib.h"
extern int uncompress2 (Bytef *dest, uLongf *destLen, const Bytef *source, uLong *sourceLen)
                                                                           ;
# 1302 "./../zlib/zlib.h"
typedef struct gzFile_s *gzFile;
# 1342 "./../zlib/zlib.h"
extern gzFile gzdopen (int fd, const char *mode);
# 1365 "./../zlib/zlib.h"
extern int gzbuffer (gzFile file, unsigned size);
# 1381 "./../zlib/zlib.h"
extern int gzsetparams (gzFile file, int level, int strategy);
# 1392 "./../zlib/zlib.h"
extern int gzread (gzFile file, voidp buf, unsigned len);
# 1422 "./../zlib/zlib.h"
extern z_size_t gzfread (voidp buf, z_size_t size, z_size_t nitems, gzFile file)
                                                  ;
# 1448 "./../zlib/zlib.h"
extern int gzwrite (gzFile file, voidpc buf, unsigned len);





extern z_size_t gzfwrite (voidpc buf, z_size_t size, z_size_t nitems, gzFile file)
                                                                    ;
# 1468 "./../zlib/zlib.h"
extern int gzprintf (gzFile file, const char *format, ...);
# 1483 "./../zlib/zlib.h"
extern int gzputs (gzFile file, const char *s);







extern char * gzgets (gzFile file, char *buf, int len);
# 1505 "./../zlib/zlib.h"
extern int gzputc (gzFile file, int c);





extern int gzgetc (gzFile file);
# 1520 "./../zlib/zlib.h"
extern int gzungetc (int c, gzFile file);
# 1532 "./../zlib/zlib.h"
extern int gzflush (gzFile file, int flush);
# 1567 "./../zlib/zlib.h"
extern int gzrewind (gzFile file);
# 1595 "./../zlib/zlib.h"
extern int gzeof (gzFile file);
# 1610 "./../zlib/zlib.h"
extern int gzdirect (gzFile file);
# 1631 "./../zlib/zlib.h"
extern int gzclose (gzFile file);
# 1644 "./../zlib/zlib.h"
extern int gzclose_r (gzFile file);
extern int gzclose_w (gzFile file);
# 1656 "./../zlib/zlib.h"
extern const char * gzerror (gzFile file, int *errnum);
# 1672 "./../zlib/zlib.h"
extern void gzclearerr (gzFile file);
# 1689 "./../zlib/zlib.h"
extern uLong adler32 (uLong adler, const Bytef *buf, uInt len);
# 1709 "./../zlib/zlib.h"
extern uLong adler32_z (uLong adler, const Bytef *buf, z_size_t len)
                                                  ;
# 1727 "./../zlib/zlib.h"
extern uLong crc32 (uLong crc, const Bytef *buf, uInt len);
# 1745 "./../zlib/zlib.h"
extern uLong crc32_z (uLong crc, const Bytef *buf, z_size_t len)
                                                ;
# 1768 "./../zlib/zlib.h"
extern uLong crc32_combine_op (uLong crc1, uLong crc2, uLong op);
# 1781 "./../zlib/zlib.h"
extern int deflateInit_ (z_streamp strm, int level, const char *version, int stream_size)
                                                                           ;
extern int inflateInit_ (z_streamp strm, const char *version, int stream_size)
                                                                           ;
extern int deflateInit2_ (z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)


                                                       ;
extern int inflateInit2_ (z_streamp strm, int windowBits, const char *version, int stream_size)
                                                                            ;
extern int inflateBackInit_ (z_streamp strm, int windowBits, unsigned char *window, const char *version, int stream_size)


                                                          ;
# 1834 "./../zlib/zlib.h"
struct gzFile_s {
    unsigned have;
    unsigned char *next;
    off64_t pos;
};
extern int gzgetc_ (gzFile file);
# 1856 "./../zlib/zlib.h"
   extern gzFile gzopen64 (const char *, const char *);
   extern off64_t gzseek64 (gzFile, off64_t, int);
   extern off64_t gztell64 (gzFile);
   extern off64_t gzoffset64 (gzFile);
   extern uLong adler32_combine64 (uLong, uLong, off64_t);
   extern uLong crc32_combine64 (uLong, uLong, off64_t);
   extern uLong crc32_combine_gen64 (off64_t);
# 1893 "./../zlib/zlib.h"
   extern gzFile gzopen (const char *, const char *);
   extern off_t gzseek (gzFile, off_t, int);
   extern off_t gztell (gzFile);
   extern off_t gzoffset (gzFile);
   extern uLong adler32_combine (uLong, uLong, off_t);
   extern uLong crc32_combine (uLong, uLong, off_t);
   extern uLong crc32_combine_gen (off_t);
# 1911 "./../zlib/zlib.h"
extern const char * zError (int);
extern int inflateSyncPoint (z_streamp);
extern const z_crc_t * get_crc_table (void);
extern int inflateUndermine (z_streamp, int);
extern int inflateValidate (z_streamp, int);
extern unsigned long inflateCodesUsed (z_streamp);
extern int inflateResetKeep (z_streamp);
extern int deflateResetKeep (z_streamp);






extern int gzvprintf (gzFile file, const char *format, va_list va)

                                                              ;
# 47 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2



# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 36 "/usr/include/wchar.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 41 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4

# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4





typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4




struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) __attribute__ ((__nothrow__ , __leaf__));



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));


extern wchar_t *wcsdup (const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
# 164 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 174 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));





extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 201 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 212 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) __attribute__ ((__nothrow__ , __leaf__));


extern size_t wcslen (const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 233 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 253 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));





extern wint_t btowc (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int wctob (wint_t __c) __attribute__ ((__nothrow__ , __leaf__));



extern int mbsinit (const mbstate_t *__ps) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) __attribute__ ((__nothrow__ , __leaf__));


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));
# 337 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));






extern int wcwidth (wchar_t __c) __attribute__ ((__nothrow__ , __leaf__));



extern int wcswidth (const wchar_t *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) __attribute__ ((__nothrow__ , __leaf__));





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) __attribute__ ((__nothrow__ , __leaf__));






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) __attribute__ ((__nothrow__ , __leaf__));



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__));





extern int fwide (__FILE *__fp, int __mode) __attribute__ ((__nothrow__ , __leaf__));






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern int fwscanf (__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_fwscanf")


                                                          ;
extern int wscanf (const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_wscanf")

                                                          ;
extern int swscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_swscanf") __attribute__ ((__nothrow__ , __leaf__))


                                                          ;
# 671 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern int vfwscanf (__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfwscanf")


                                                          ;
extern int vwscanf (const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vwscanf")

                                                          ;
extern int vswscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vswscanf") __attribute__ ((__nothrow__ , __leaf__))


                                                          ;
# 726 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 781 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 807 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 817 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 856 "/usr/include/wchar.h" 3 4

# 51 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 60 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
# 1 "../bfd/bfd.h" 1
# 44 "../bfd/bfd.h"
# 1 "./../include/symcat.h" 1
# 45 "../bfd/bfd.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 2 3 4
# 46 "../bfd/bfd.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdbool.h" 1 3 4
# 47 "../bfd/bfd.h" 2
# 1 "./../include/diagnostics.h" 1
# 48 "../bfd/bfd.h" 2
# 80 "../bfd/bfd.h"
# 1 "/usr/include/inttypes.h" 1 3 4
# 34 "/usr/include/inttypes.h" 3 4
typedef int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 432 "/usr/include/inttypes.h" 3 4

# 81 "../bfd/bfd.h" 2
# 91 "../bfd/bfd.h"
        
# 110 "../bfd/bfd.h"

# 110 "../bfd/bfd.h"
typedef uint64_t bfd_vma;





typedef int64_t bfd_signed_vma;

typedef uint64_t bfd_size_type;
typedef uint64_t symvalue;
# 135 "../bfd/bfd.h"
typedef int64_t file_ptr;
typedef uint64_t ufile_ptr;

typedef uint32_t flagword;
typedef uint8_t bfd_byte;


typedef struct bfd bfd;
struct bfd_link_info;
struct bfd_link_hash_entry;
typedef struct bfd_section *sec_ptr;
typedef struct reloc_cache_entry arelent;
struct orl;
# 163 "../bfd/bfd.h"
static inline 
# 163 "../bfd/bfd.h" 3 4
             _Bool

# 164 "../bfd/bfd.h"
startswith (const char *str, const char *prefix)
{
  return strncmp (str, prefix, strlen (prefix)) == 0;
}


void *bfd_alloc (bfd *abfd, bfd_size_type wanted);

void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);

void bfd_release (bfd *, void *);
# 205 "../bfd/bfd.h"
bfd_vma bfd_getb24 (const void *p);
bfd_vma bfd_getl24 (const void *p);
# 302 "../bfd/bfd.h"
uint64_t bfd_getb64 (const void *);
uint64_t bfd_getl64 (const void *);
int64_t bfd_getb_signed_64 (const void *);
int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (uint64_t, void *);
void bfd_putl64 (uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb24 (bfd_vma, void *);
void bfd_putl24 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);
uint64_t bfd_get_bits (const void *, int, 
# 322 "../bfd/bfd.h" 3 4
                                         _Bool
# 322 "../bfd/bfd.h"
                                             );
void bfd_put_bits (uint64_t, void *, int, 
# 323 "../bfd/bfd.h" 3 4
                                         _Bool
# 323 "../bfd/bfd.h"
                                             );





struct bfd_hash_entry
{

  struct bfd_hash_entry *next;

  const char *string;


  unsigned long hash;
};



struct bfd_hash_table
{

  struct bfd_hash_entry **table;







  struct bfd_hash_entry *(*newfunc)
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


  void *memory;

  unsigned int size;

  unsigned int count;

  unsigned int entsize;

  unsigned int frozen:1;
};


# 368 "../bfd/bfd.h" 3 4
_Bool 
# 368 "../bfd/bfd.h"
    bfd_hash_table_init_n
   (struct bfd_hash_table *,
    struct bfd_hash_entry *(* )
       (struct bfd_hash_entry *, struct bfd_hash_table *, const char *),
    unsigned int , unsigned int );


# 374 "../bfd/bfd.h" 3 4
_Bool 
# 374 "../bfd/bfd.h"
    bfd_hash_table_init
   (struct bfd_hash_table *,
    struct bfd_hash_entry *(* )
       (struct bfd_hash_entry *, struct bfd_hash_table *, const char *),
    unsigned int );

void bfd_hash_table_free (struct bfd_hash_table *);

struct bfd_hash_entry *bfd_hash_lookup
   (struct bfd_hash_table *, const char *,
    
# 384 "../bfd/bfd.h" 3 4
   _Bool 
# 384 "../bfd/bfd.h"
                  , 
# 384 "../bfd/bfd.h" 3 4
                    _Bool 
# 384 "../bfd/bfd.h"
                                 );

struct bfd_hash_entry *bfd_hash_insert
   (struct bfd_hash_table *,
    const char *,
    unsigned long );

void bfd_hash_rename (struct bfd_hash_table *,
    const char *,
    struct bfd_hash_entry *);

void bfd_hash_replace (struct bfd_hash_table *,
    struct bfd_hash_entry * ,
    struct bfd_hash_entry * );

void *bfd_hash_allocate (struct bfd_hash_table *,
    unsigned int );

struct bfd_hash_entry *bfd_hash_newfunc
   (struct bfd_hash_entry *,
    struct bfd_hash_table *,
    const char *);

void bfd_hash_traverse
   (struct bfd_hash_table *,
    
# 409 "../bfd/bfd.h" 3 4
   _Bool 
# 409 "../bfd/bfd.h"
        (*) (struct bfd_hash_entry *, void *),
    void *);

unsigned int bfd_hash_set_default_size (unsigned int);



typedef struct lineno_cache_entry
{
  unsigned int line_number;
  union
  {
    struct bfd_symbol *sym;
    bfd_vma offset;
  } u;
}
alent;

typedef struct bfd_section
{


  const char *name;


  struct bfd_section *next;


  struct bfd_section *prev;


  unsigned int id;



  unsigned int section_id;


  unsigned int index;




  flagword flags;
# 653 "../bfd/bfd.h"
  unsigned int user_set_vma : 1;


  unsigned int linker_mark : 1;



  unsigned int linker_has_input : 1;


  unsigned int gc_mark : 1;


  unsigned int compress_status : 2;
# 675 "../bfd/bfd.h"
  unsigned int segment_mark : 1;


  unsigned int sec_info_type:3;
# 689 "../bfd/bfd.h"
  unsigned int use_rela_p:1;




  unsigned int sec_flg0:1;
  unsigned int sec_flg1:1;
  unsigned int sec_flg2:1;
  unsigned int sec_flg3:1;
  unsigned int sec_flg4:1;
  unsigned int sec_flg5:1;
# 709 "../bfd/bfd.h"
  bfd_vma vma;




  bfd_vma lma;




  bfd_size_type size;
# 729 "../bfd/bfd.h"
  bfd_size_type rawsize;


  bfd_size_type compressed_size;
# 741 "../bfd/bfd.h"
  bfd_vma output_offset;


  struct bfd_section *output_section;



  struct reloc_cache_entry *relocation;



  struct reloc_cache_entry **orelocation;


  unsigned reloc_count;



  unsigned int alignment_power;





  file_ptr filepos;


  file_ptr rel_filepos;


  file_ptr line_filepos;


  void *userdata;



  bfd_byte *contents;


  alent *lineno;


  unsigned int lineno_count;


  unsigned int entsize;



  struct bfd_section *kept_section;



  file_ptr moving_line_filepos;


  int target_index;

  void *used_by_bfd;



  struct relent_chain *constructor_chain;


  bfd *owner;


  struct bfd_symbol *symbol;
  struct bfd_symbol **symbol_ptr_ptr;






  union {
    struct bfd_link_order *link_order;
    struct bfd_section *s;
    const char *linked_to_symbol_name;
  } map_head, map_tail;




  struct bfd_section *already_assigned;


  unsigned int type;

} asection;

static inline const char *
bfd_section_name (const asection *sec)
{
  return sec->name;
}

static inline bfd_size_type
bfd_section_size (const asection *sec)
{
  return sec->size;
}

static inline bfd_vma
bfd_section_vma (const asection *sec)
{
  return sec->vma;
}

static inline bfd_vma
bfd_section_lma (const asection *sec)
{
  return sec->lma;
}

static inline unsigned int
bfd_section_alignment (const asection *sec)
{
  return sec->alignment_power;
}

static inline flagword
bfd_section_flags (const asection *sec)
{
  return sec->flags;
}

static inline void *
bfd_section_userdata (const asection *sec)
{
  return sec->userdata;
}
static inline 
# 875 "../bfd/bfd.h" 3 4
             _Bool

# 876 "../bfd/bfd.h"
bfd_is_com_section (const asection *sec)
{
  return (sec->flags & 0x1000) != 0;
}





static inline 
# 885 "../bfd/bfd.h" 3 4
             _Bool

# 886 "../bfd/bfd.h"
bfd_set_section_userdata (asection *sec, void *val)
{
  sec->userdata = val;
  return 
# 889 "../bfd/bfd.h" 3 4
        1
# 889 "../bfd/bfd.h"
            ;
}

static inline 
# 892 "../bfd/bfd.h" 3 4
             _Bool

# 893 "../bfd/bfd.h"
bfd_set_section_vma (asection *sec, bfd_vma val)
{
  sec->vma = sec->lma = val;
  sec->user_set_vma = 
# 896 "../bfd/bfd.h" 3 4
                     1
# 896 "../bfd/bfd.h"
                         ;
  return 
# 897 "../bfd/bfd.h" 3 4
        1
# 897 "../bfd/bfd.h"
            ;
}

static inline 
# 900 "../bfd/bfd.h" 3 4
             _Bool

# 901 "../bfd/bfd.h"
bfd_set_section_lma (asection *sec, bfd_vma val)
{
  sec->lma = val;
  return 
# 904 "../bfd/bfd.h" 3 4
        1
# 904 "../bfd/bfd.h"
            ;
}

static inline 
# 907 "../bfd/bfd.h" 3 4
             _Bool

# 908 "../bfd/bfd.h"
bfd_set_section_alignment (asection *sec, unsigned int val)
{
  if (val >= sizeof (bfd_vma) * 8 - 1)
    return 
# 911 "../bfd/bfd.h" 3 4
          0
# 911 "../bfd/bfd.h"
               ;
  sec->alignment_power = val;
  return 
# 913 "../bfd/bfd.h" 3 4
        1
# 913 "../bfd/bfd.h"
            ;
}




extern asection _bfd_std_section[4];
# 935 "../bfd/bfd.h"
static inline 
# 935 "../bfd/bfd.h" 3 4
             _Bool

# 936 "../bfd/bfd.h"
bfd_is_und_section (const asection *sec)
{
  return sec == (&_bfd_std_section[1]);
}

static inline 
# 941 "../bfd/bfd.h" 3 4
             _Bool

# 942 "../bfd/bfd.h"
bfd_is_abs_section (const asection *sec)
{
  return sec == (&_bfd_std_section[2]);
}

static inline 
# 947 "../bfd/bfd.h" 3 4
             _Bool

# 948 "../bfd/bfd.h"
bfd_is_ind_section (const asection *sec)
{
  return sec == (&_bfd_std_section[3]);
}

static inline 
# 953 "../bfd/bfd.h" 3 4
             _Bool

# 954 "../bfd/bfd.h"
bfd_is_const_section (const asection *sec)
{
  return (sec >= _bfd_std_section
   && sec < _bfd_std_section + (sizeof (_bfd_std_section)
           / sizeof (_bfd_std_section[0])));
}


static inline 
# 962 "../bfd/bfd.h" 3 4
             _Bool

# 963 "../bfd/bfd.h"
discarded_section (const asection *sec)
{
  return (!bfd_is_abs_section (sec)
   && bfd_is_abs_section (sec->output_section)
   && sec->sec_info_type != 2
   && sec->sec_info_type != 4);
}
# 1022 "../bfd/bfd.h"
void bfd_section_list_clear (bfd *);

asection *bfd_get_section_by_name (bfd *abfd, const char *name);

asection *bfd_get_next_section_by_name (bfd *ibfd, asection *sec);

asection *bfd_get_linker_section (bfd *abfd, const char *name);

asection *bfd_get_section_by_name_if
   (bfd *abfd,
    const char *name,
    
# 1033 "../bfd/bfd.h" 3 4
   _Bool 
# 1033 "../bfd/bfd.h"
        (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

char *bfd_get_unique_section_name
   (bfd *abfd, const char *templat, int *count);

asection *bfd_make_section_old_way (bfd *abfd, const char *name);

asection *bfd_make_section_anyway_with_flags
   (bfd *abfd, const char *name, flagword flags);

asection *bfd_make_section_anyway (bfd *abfd, const char *name);

asection *bfd_make_section_with_flags
   (bfd *, const char *name, flagword flags);

asection *bfd_make_section (bfd *, const char *name);


# 1051 "../bfd/bfd.h" 3 4
_Bool 
# 1051 "../bfd/bfd.h"
    bfd_set_section_flags (asection *sec, flagword flags);

void bfd_rename_section
   (asection *sec, const char *newname);

void bfd_map_over_sections
   (bfd *abfd,
    void (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

asection *bfd_sections_find_if
   (bfd *abfd,
    
# 1063 "../bfd/bfd.h" 3 4
   _Bool 
# 1063 "../bfd/bfd.h"
        (*operation) (bfd *abfd, asection *sect, void *obj),
    void *obj);


# 1066 "../bfd/bfd.h" 3 4
_Bool 
# 1066 "../bfd/bfd.h"
    bfd_set_section_size (asection *sec, bfd_size_type val);


# 1068 "../bfd/bfd.h" 3 4
_Bool 
# 1068 "../bfd/bfd.h"
    bfd_set_section_contents
   (bfd *abfd, asection *section, const void *data,
    file_ptr offset, bfd_size_type count);


# 1072 "../bfd/bfd.h" 3 4
_Bool 
# 1072 "../bfd/bfd.h"
    bfd_get_section_contents
   (bfd *abfd, asection *section, void *location, file_ptr offset,
    bfd_size_type count);


# 1076 "../bfd/bfd.h" 3 4
_Bool 
# 1076 "../bfd/bfd.h"
    bfd_malloc_and_get_section
   (bfd *abfd, asection *section, bfd_byte **buf);


# 1079 "../bfd/bfd.h" 3 4
_Bool 
# 1079 "../bfd/bfd.h"
    bfd_copy_private_section_data
   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);





# 1085 "../bfd/bfd.h" 3 4
_Bool 
# 1085 "../bfd/bfd.h"
    bfd_generic_is_group_section (bfd *, const asection *sec);

const char *bfd_generic_group_name (bfd *, const asection *sec);


# 1089 "../bfd/bfd.h" 3 4
_Bool 
# 1089 "../bfd/bfd.h"
    bfd_generic_discard_group (bfd *abfd, asection *group);


typedef struct bfd_symbol
{
# 1103 "../bfd/bfd.h"
  struct bfd *the_bfd;



  const char *name;




  symvalue value;
# 1221 "../bfd/bfd.h"
  flagword flags;




  struct bfd_section *section;


  union
    {
      void *p;
      bfd_vma i;
    }
  udata;
}
asymbol;

typedef enum bfd_print_symbol
{
  bfd_print_symbol_name,
  bfd_print_symbol_more,
  bfd_print_symbol_all
} bfd_print_symbol_type;



typedef struct _symbol_info
{
  symvalue value;
  char type;
  const char *name;
  unsigned char stab_type;
  char stab_other;
  short stab_desc;
  const char *stab_name;
} symbol_info;





# 1261 "../bfd/bfd.h" 3 4
_Bool 
# 1261 "../bfd/bfd.h"
    bfd_is_local_label (bfd *abfd, asymbol *sym);


# 1263 "../bfd/bfd.h" 3 4
_Bool 
# 1263 "../bfd/bfd.h"
    bfd_is_local_label_name (bfd *abfd, const char *name);





# 1268 "../bfd/bfd.h" 3 4
_Bool 
# 1268 "../bfd/bfd.h"
    bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);








# 1276 "../bfd/bfd.h" 3 4
_Bool 
# 1276 "../bfd/bfd.h"
    bfd_set_symtab
   (bfd *abfd, asymbol **location, unsigned int count);

void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);




asymbol *_bfd_generic_make_empty_symbol (bfd *);




int bfd_decode_symclass (asymbol *symbol);


# 1291 "../bfd/bfd.h" 3 4
_Bool 
# 1291 "../bfd/bfd.h"
    bfd_is_undefined_symclass (int symclass);

void bfd_symbol_info (asymbol *symbol, symbol_info *ret);


# 1295 "../bfd/bfd.h" 3 4
_Bool 
# 1295 "../bfd/bfd.h"
    bfd_copy_private_symbol_data
   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
# 1305 "../bfd/bfd.h"
typedef struct carsym
{
  const char *name;
  file_ptr file_offset;
}
carsym;


 typedef unsigned long symindex;


symindex bfd_get_next_mapent
   (bfd *abfd, symindex previous, carsym **sym);


# 1319 "../bfd/bfd.h" 3 4
_Bool 
# 1319 "../bfd/bfd.h"
    bfd_set_archive_head (bfd *output, bfd *new_head);

bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);


enum bfd_architecture
{
  bfd_arch_unknown,
  bfd_arch_obscure,
  bfd_arch_m68k,
# 1360 "../bfd/bfd.h"
  bfd_arch_vax,

  bfd_arch_or1k,



  bfd_arch_sparc,
# 1404 "../bfd/bfd.h"
  bfd_arch_spu,

  bfd_arch_mips,
# 1456 "../bfd/bfd.h"
  bfd_arch_i386,
# 1465 "../bfd/bfd.h"
  bfd_arch_iamcu,



  bfd_arch_romp,
  bfd_arch_convex,
  bfd_arch_m98k,
  bfd_arch_pyramid,
  bfd_arch_h8300,







  bfd_arch_pdp11,
  bfd_arch_powerpc,
# 1509 "../bfd/bfd.h"
  bfd_arch_rs6000,




  bfd_arch_hppa,




  bfd_arch_d10v,



  bfd_arch_d30v,
  bfd_arch_dlx,
  bfd_arch_m68hc11,
  bfd_arch_m68hc12,



  bfd_arch_m9s12x,
  bfd_arch_m9s12xg,
  bfd_arch_s12z,

  bfd_arch_z8k,


  bfd_arch_sh,
# 1558 "../bfd/bfd.h"
  bfd_arch_alpha,



  bfd_arch_arm,
# 1592 "../bfd/bfd.h"
  bfd_arch_nds32,





  bfd_arch_ns32k,
  bfd_arch_tic30,
  bfd_arch_tic4x,


  bfd_arch_tic54x,
  bfd_arch_tic6x,
  bfd_arch_v850,
  bfd_arch_v850_rh850,






  bfd_arch_arc,






 bfd_arch_m32c,


  bfd_arch_m32r,



  bfd_arch_mn10200,
  bfd_arch_mn10300,



  bfd_arch_fr30,

  bfd_arch_frv,
# 1643 "../bfd/bfd.h"
  bfd_arch_moxie,

  bfd_arch_ft32,


  bfd_arch_mcore,
  bfd_arch_mep,



  bfd_arch_metag,

  bfd_arch_ia64,


  bfd_arch_ip2k,


 bfd_arch_iq2000,


  bfd_arch_bpf,


  bfd_arch_epiphany,


  bfd_arch_mt,



  bfd_arch_pj,
  bfd_arch_avr,
# 1694 "../bfd/bfd.h"
  bfd_arch_bfin,

  bfd_arch_cr16,

  bfd_arch_crx,

  bfd_arch_cris,



  bfd_arch_riscv,


  bfd_arch_rl78,

  bfd_arch_rx,



  bfd_arch_s390,


  bfd_arch_score,


  bfd_arch_mmix,
  bfd_arch_xstormy16,

  bfd_arch_msp430,
# 1747 "../bfd/bfd.h"
  bfd_arch_xgate,

  bfd_arch_xtensa,

  bfd_arch_z80,
# 1771 "../bfd/bfd.h"
  bfd_arch_lm32,

  bfd_arch_microblaze,
  bfd_arch_tilepro,
  bfd_arch_tilegx,



  bfd_arch_aarch64,




  bfd_arch_nios2,



  bfd_arch_visium,

  bfd_arch_wasm32,

  bfd_arch_pru,

  bfd_arch_nfp,


  bfd_arch_csky,
# 1807 "../bfd/bfd.h"
  bfd_arch_loongarch,


  bfd_arch_amdgcn,
# 1823 "../bfd/bfd.h"
  bfd_arch_last
  };

typedef struct bfd_arch_info
{
  int bits_per_word;
  int bits_per_address;
  int bits_per_byte;
  enum bfd_architecture arch;
  unsigned long mach;
  const char *arch_name;
  const char *printable_name;
  unsigned int section_align_power;



  
# 1839 "../bfd/bfd.h" 3 4
 _Bool 
# 1839 "../bfd/bfd.h"
      the_default;
  const struct bfd_arch_info * (*compatible) (const struct bfd_arch_info *,
           const struct bfd_arch_info *);

  
# 1843 "../bfd/bfd.h" 3 4
 _Bool 
# 1843 "../bfd/bfd.h"
      (*scan) (const struct bfd_arch_info *, const char *);




  void *(*fill) (bfd_size_type count, 
# 1848 "../bfd/bfd.h" 3 4
                                     _Bool 
# 1848 "../bfd/bfd.h"
                                          is_bigendian, 
# 1848 "../bfd/bfd.h" 3 4
                                                        _Bool 
# 1848 "../bfd/bfd.h"
                                                             code);

  const struct bfd_arch_info *next;
# 1860 "../bfd/bfd.h"
  signed int max_reloc_offset_into_insn;
}
bfd_arch_info_type;

const char *bfd_printable_name (bfd *abfd);

const bfd_arch_info_type *bfd_scan_arch (const char *string);

const char **bfd_arch_list (void);

const bfd_arch_info_type *bfd_arch_get_compatible
   (const bfd *abfd, const bfd *bbfd, 
# 1871 "../bfd/bfd.h" 3 4
                                     _Bool 
# 1871 "../bfd/bfd.h"
                                          accept_unknowns);

void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);


# 1875 "../bfd/bfd.h" 3 4
_Bool 
# 1875 "../bfd/bfd.h"
    bfd_default_set_arch_mach
   (bfd *abfd, enum bfd_architecture arch, unsigned long mach);

enum bfd_architecture bfd_get_arch (const bfd *abfd);

unsigned long bfd_get_mach (const bfd *abfd);

unsigned int bfd_arch_bits_per_byte (const bfd *abfd);

unsigned int bfd_arch_bits_per_address (const bfd *abfd);

const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);

const bfd_arch_info_type *bfd_lookup_arch
   (enum bfd_architecture arch, unsigned long machine);

const char *bfd_printable_arch_mach
   (enum bfd_architecture arch, unsigned long machine);

unsigned int bfd_octets_per_byte (const bfd *abfd,
    const asection *sec);

unsigned int bfd_arch_mach_octets_per_byte
   (enum bfd_architecture arch, unsigned long machine);


typedef enum bfd_format
  {
    bfd_unknown = 0,
    bfd_object,
    bfd_archive,
    bfd_core,
    bfd_type_end
  }
bfd_format;

enum bfd_direction
  {
    no_direction = 0,
    read_direction = 1,
    write_direction = 2,
    both_direction = 3
  };

enum bfd_plugin_format
  {
    bfd_plugin_unknown = 0,
    bfd_plugin_yes = 1,
    bfd_plugin_no = 2
  };

struct bfd_build_id
  {
    bfd_size_type size;
    bfd_byte data[1];
  };

struct bfd
{

  const char *filename;


  const struct bfd_target *xvec;



  void *iostream;
  const struct bfd_iovec *iovec;



  struct bfd *lru_prev, *lru_next;




  ufile_ptr where;


  long mtime;


  unsigned int id;


  flagword flags;
# 2066 "../bfd/bfd.h"
  __extension__ enum bfd_format format : 3;


  __extension__ enum bfd_direction direction : 2;



  unsigned int cacheable : 1;




  unsigned int target_defaulted : 1;


  unsigned int opened_once : 1;



  unsigned int mtime_set : 1;


  unsigned int no_export : 1;



  unsigned int output_has_begun : 1;


  unsigned int has_armap : 1;


  unsigned int is_thin_archive : 1;


  unsigned int no_element_cache : 1;



  unsigned int selective_search : 1;


  unsigned int is_linker_output : 1;


  unsigned int is_linker_input : 1;


  __extension__ enum bfd_plugin_format plugin_format : 2;


  unsigned int lto_output : 1;


  unsigned int lto_slim_object : 1;



  unsigned int read_only : 1;



  bfd *plugin_dummy_bfd;



  ufile_ptr origin;






  ufile_ptr proxy_origin;


  struct bfd_hash_table section_htab;


  struct bfd_section *sections;


  struct bfd_section *section_last;


  unsigned int section_count;


  int archive_plugin_fd;


  unsigned int archive_plugin_fd_open_count;



  int archive_pass;


  bfd_size_type alloc_size;



  bfd_vma start_address;



  struct bfd_symbol **outsymbols;


  unsigned int symcount;


  unsigned int dynsymcount;


  const struct bfd_arch_info *arch_info;




  ufile_ptr size;


  void *arelt_data;
  struct bfd *my_archive;
  struct bfd *archive_next;
  struct bfd *archive_head;
  struct bfd *nested_archives;


  union {

    struct bfd *next;

    struct bfd_link_hash_table *hash;
  } link;


  union
    {
      struct aout_data_struct *aout_data;
      struct artdata *aout_ar_data;
      struct coff_tdata *coff_obj_data;
      struct pe_tdata *pe_obj_data;
      struct xcoff_tdata *xcoff_obj_data;
      struct ecoff_tdata *ecoff_obj_data;
      struct srec_data_struct *srec_data;
      struct verilog_data_struct *verilog_data;
      struct ihex_data_struct *ihex_data;
      struct tekhex_data_struct *tekhex_data;
      struct elf_obj_tdata *elf_obj_data;
      struct mmo_data_struct *mmo_data;
      struct trad_core_struct *trad_core_data;
      struct som_data_struct *som_data;
      struct hpux_core_struct *hpux_core_data;
      struct hppabsd_core_struct *hppabsd_core_data;
      struct sgi_core_struct *sgi_core_data;
      struct lynx_core_struct *lynx_core_data;
      struct osf_core_struct *osf_core_data;
      struct cisco_core_struct *cisco_core_data;
      struct netbsd_core_struct *netbsd_core_data;
      struct mach_o_data_struct *mach_o_data;
      struct mach_o_fat_data_struct *mach_o_fat_data;
      struct plugin_data_struct *plugin_data;
      struct bfd_pef_data_struct *pef_data;
      struct bfd_pef_xlib_data_struct *pef_xlib_data;
      struct bfd_sym_data_struct *sym_data;
      void *any;
    }
  tdata;


  void *usrdata;




  void *memory;


  const struct bfd_build_id *build_id;
};

static inline const char *
bfd_get_filename (const bfd *abfd)
{
  return abfd->filename;
}

static inline 
# 2255 "../bfd/bfd.h" 3 4
             _Bool

# 2256 "../bfd/bfd.h"
bfd_get_cacheable (const bfd *abfd)
{
  return abfd->cacheable;
}

static inline enum bfd_format
bfd_get_format (const bfd *abfd)
{
  return abfd->format;
}

static inline flagword
bfd_get_file_flags (const bfd *abfd)
{
  return abfd->flags;
}

static inline bfd_vma
bfd_get_start_address (const bfd *abfd)
{
  return abfd->start_address;
}

static inline unsigned int
bfd_get_symcount (const bfd *abfd)
{
  return abfd->symcount;
}

static inline unsigned int
bfd_get_dynamic_symcount (const bfd *abfd)
{
  return abfd->dynsymcount;
}

static inline struct bfd_symbol **
bfd_get_outsymbols (const bfd *abfd)
{
  return abfd->outsymbols;
}

static inline unsigned int
bfd_count_sections (const bfd *abfd)
{
  return abfd->section_count;
}

static inline 
# 2303 "../bfd/bfd.h" 3 4
             _Bool

# 2304 "../bfd/bfd.h"
bfd_has_map (const bfd *abfd)
{
  return abfd->has_armap;
}

static inline 
# 2309 "../bfd/bfd.h" 3 4
             _Bool

# 2310 "../bfd/bfd.h"
bfd_is_thin_archive (const bfd *abfd)
{
  return abfd->is_thin_archive;
}

static inline void *
bfd_usrdata (const bfd *abfd)
{
  return abfd->usrdata;
}


static inline 
# 2322 "../bfd/bfd.h" 3 4
             _Bool

# 2323 "../bfd/bfd.h"
bfd_set_cacheable (bfd * abfd, 
# 2323 "../bfd/bfd.h" 3 4
                              _Bool 
# 2323 "../bfd/bfd.h"
                                   val)
{
  abfd->cacheable = val;
  return 
# 2326 "../bfd/bfd.h" 3 4
        1
# 2326 "../bfd/bfd.h"
            ;
}

static inline void
bfd_set_thin_archive (bfd *abfd, 
# 2330 "../bfd/bfd.h" 3 4
                                _Bool 
# 2330 "../bfd/bfd.h"
                                     val)
{
  abfd->is_thin_archive = val;
}

static inline void
bfd_set_usrdata (bfd *abfd, void *val)
{
  abfd->usrdata = val;
}

static inline asection *
bfd_asymbol_section (const asymbol *sy)
{
  return sy->section;
}

static inline bfd_vma
bfd_asymbol_value (const asymbol *sy)
{
  return sy->section->vma + sy->value;
}

static inline const char *
bfd_asymbol_name (const asymbol *sy)
{
  return sy->name;
}

static inline struct bfd *
bfd_asymbol_bfd (const asymbol *sy)
{
  return sy->the_bfd;
}

static inline void
bfd_set_asymbol_name (asymbol *sy, const char *name)
{
  sy->name = name;
}



static inline bfd_size_type
bfd_get_section_limit_octets (const bfd *abfd, const asection *sec)
{
  if (abfd->direction != write_direction && sec->rawsize != 0)
    return sec->rawsize;
  return sec->size;
}


static inline bfd_size_type
bfd_get_section_limit (const bfd *abfd, const asection *sec)
{
  return (bfd_get_section_limit_octets (abfd, sec)
   / bfd_octets_per_byte (abfd, sec));
}




static inline bfd_size_type
bfd_get_section_alloc_size (const bfd *abfd, const asection *sec)
{
  if (abfd->direction != write_direction && sec->rawsize > sec->size)
    return sec->rawsize;
  return sec->size;
}




static inline void
bfd_section_list_remove (bfd *abfd, asection *s)
{
  asection *next = s->next;
  asection *prev = s->prev;
  if (prev)
    prev->next = next;
  else
    abfd->sections = next;
  if (next)
    next->prev = prev;
  else
    abfd->section_last = prev;
}

static inline void
bfd_section_list_append (bfd *abfd, asection *s)
{
  s->next = 0;
  if (abfd->section_last)
    {
      s->prev = abfd->section_last;
      abfd->section_last->next = s;
    }
  else
    {
      s->prev = 0;
      abfd->sections = s;
    }
  abfd->section_last = s;
}

static inline void
bfd_section_list_prepend (bfd *abfd, asection *s)
{
  s->prev = 0;
  if (abfd->sections)
    {
      s->next = abfd->sections;
      abfd->sections->prev = s;
    }
  else
    {
      s->next = 0;
      abfd->section_last = s;
    }
  abfd->sections = s;
}

static inline void
bfd_section_list_insert_after (bfd *abfd, asection *a, asection *s)
{
  asection *next = a->next;
  s->next = next;
  s->prev = a;
  a->next = s;
  if (next)
    next->prev = s;
  else
    abfd->section_last = s;
}

static inline void
bfd_section_list_insert_before (bfd *abfd, asection *b, asection *s)
{
  asection *prev = b->prev;
  s->prev = prev;
  s->next = b;
  b->prev = s;
  if (prev)
    prev->next = s;
  else
    abfd->sections = s;
}

static inline 
# 2478 "../bfd/bfd.h" 3 4
             _Bool

# 2479 "../bfd/bfd.h"
bfd_section_removed_from_list (const bfd *abfd, const asection *s)
{
  return s->next ? s->next->prev != s : abfd->section_last != s;
}

typedef enum bfd_error
{
  bfd_error_no_error = 0,
  bfd_error_system_call,
  bfd_error_invalid_target,
  bfd_error_wrong_format,
  bfd_error_wrong_object_format,
  bfd_error_invalid_operation,
  bfd_error_no_memory,
  bfd_error_no_symbols,
  bfd_error_no_armap,
  bfd_error_no_more_archived_files,
  bfd_error_malformed_archive,
  bfd_error_missing_dso,
  bfd_error_file_not_recognized,
  bfd_error_file_ambiguously_recognized,
  bfd_error_no_contents,
  bfd_error_nonrepresentable_section,
  bfd_error_no_debug_section,
  bfd_error_bad_value,
  bfd_error_file_truncated,
  bfd_error_file_too_big,
  bfd_error_sorry,
  bfd_error_on_input,
  bfd_error_invalid_error_code
}
bfd_error_type;

bfd_error_type bfd_get_error (void);

void bfd_set_error (bfd_error_type error_tag);

void bfd_set_input_error (bfd *input, bfd_error_type error_tag);

const char *bfd_errmsg (bfd_error_type error_tag);

void bfd_perror (const char *message);

typedef void (*bfd_error_handler_type) (const char *, va_list);

void _bfd_error_handler (const char *fmt, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));

bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);

void bfd_set_error_program_name (const char *);

typedef void (*bfd_assert_handler_type) (const char *bfd_formatmsg,
      const char *bfd_version,
      const char *bfd_file,
      int bfd_line);

bfd_assert_handler_type bfd_set_assert_handler (bfd_assert_handler_type);

unsigned int bfd_init (void);




long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);

long bfd_canonicalize_reloc
   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);

void bfd_set_reloc
   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);




# 2552 "../bfd/bfd.h" 3 4
_Bool 
# 2552 "../bfd/bfd.h"
    bfd_set_file_flags (bfd *abfd, flagword flags);

int bfd_get_arch_size (bfd *abfd);

int bfd_get_sign_extend_vma (bfd *abfd);


# 2558 "../bfd/bfd.h" 3 4
_Bool 
# 2558 "../bfd/bfd.h"
    bfd_set_start_address (bfd *abfd, bfd_vma vma);

unsigned int bfd_get_gp_size (bfd *abfd);

void bfd_set_gp_size (bfd *abfd, unsigned int i);

void bfd_set_gp_value (bfd *abfd, bfd_vma v);

bfd_vma bfd_scan_vma (const char *string, const char **end, int base);


# 2568 "../bfd/bfd.h" 3 4
_Bool 
# 2568 "../bfd/bfd.h"
    bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);





# 2573 "../bfd/bfd.h" 3 4
_Bool 
# 2573 "../bfd/bfd.h"
    bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);





# 2578 "../bfd/bfd.h" 3 4
_Bool 
# 2578 "../bfd/bfd.h"
    bfd_set_private_flags (bfd *abfd, flagword flags);
# 2681 "../bfd/bfd.h"
bfd_byte *bfd_get_relocated_section_contents
   (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
    
# 2683 "../bfd/bfd.h" 3 4
   _Bool
# 2683 "../bfd/bfd.h"
       , asymbol **);


# 2685 "../bfd/bfd.h" 3 4
_Bool 
# 2685 "../bfd/bfd.h"
    bfd_record_phdr
   (bfd *, unsigned long, 
# 2686 "../bfd/bfd.h" 3 4
                         _Bool
# 2686 "../bfd/bfd.h"
                             , flagword, 
# 2686 "../bfd/bfd.h" 3 4
                                         _Bool
# 2686 "../bfd/bfd.h"
                                             , bfd_vma,
    
# 2687 "../bfd/bfd.h" 3 4
   _Bool
# 2687 "../bfd/bfd.h"
       , 
# 2687 "../bfd/bfd.h" 3 4
         _Bool
# 2687 "../bfd/bfd.h"
             , unsigned int, struct bfd_section **);

void bfd_sprintf_vma (bfd *, char *, bfd_vma);
void bfd_fprintf_vma (bfd *, void *, bfd_vma);




# 2694 "../bfd/bfd.h" 3 4
_Bool 
# 2694 "../bfd/bfd.h"
    bfd_alt_mach_code (bfd *abfd, int alternative);

bfd_vma bfd_emul_get_maxpagesize (const char *);

bfd_vma bfd_emul_get_commonpagesize (const char *);

char *bfd_demangle (bfd *, const char *, int);


bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);

bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);

file_ptr bfd_tell (bfd *);

int bfd_flush (bfd *);

int bfd_stat (bfd *, struct stat *);

int bfd_seek (bfd *, file_ptr, int);

long bfd_get_mtime (bfd *abfd);

ufile_ptr bfd_get_size (bfd *abfd);

ufile_ptr bfd_get_file_size (bfd *abfd);

void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
    int prot, int flags, file_ptr offset,
    void **map_addr, bfd_size_type *map_len);


struct _bfd_window_internal;

typedef struct _bfd_window
{

  void *data;
  bfd_size_type size;






  struct _bfd_window_internal *i;
}
bfd_window;

void bfd_init_window (bfd_window *);

void bfd_free_window (bfd_window *);


# 2747 "../bfd/bfd.h" 3 4
_Bool 
# 2747 "../bfd/bfd.h"
    bfd_get_file_window
   (bfd *, file_ptr, bfd_size_type, bfd_window *, 
# 2748 "../bfd/bfd.h" 3 4
                                                 _Bool 
# 2748 "../bfd/bfd.h"
                                                                  );



# 2751 "../bfd/bfd.h" 3 4
_Bool 
# 2751 "../bfd/bfd.h"
    bfd_cache_close (bfd *abfd);


# 2753 "../bfd/bfd.h" 3 4
_Bool 
# 2753 "../bfd/bfd.h"
    bfd_cache_close_all (void);



enum compressed_debug_section_type
{
  COMPRESS_DEBUG_NONE = 0,
  COMPRESS_DEBUG_GNU_ZLIB = 1 << 1,
  COMPRESS_DEBUG_GABI_ZLIB = 1 << 2,
  COMPRESS_DEBUG_ZSTD = 1 << 3,
  COMPRESS_UNKNOWN = 1 << 4
};


struct compressed_type_tuple
{
  enum compressed_debug_section_type type;
  const char *name;
};


enum compression_type
{
  ch_none = 0,
  ch_compress_zlib = 1 ,
  ch_compress_zstd = 2
};

static inline char *
bfd_debug_name_to_zdebug (bfd *abfd, const char *name)
{
  size_t len = strlen (name);
  char *new_name = (char *) bfd_alloc (abfd, len + 2);
  if (new_name == 
# 2786 "../bfd/bfd.h" 3 4
                 ((void *)0)
# 2786 "../bfd/bfd.h"
                     )
    return 
# 2787 "../bfd/bfd.h" 3 4
          ((void *)0)
# 2787 "../bfd/bfd.h"
              ;
  new_name[0] = '.';
  new_name[1] = 'z';
  memcpy (new_name + 2, name + 1, len);
  return new_name;
}

static inline char *
bfd_zdebug_name_to_debug (bfd *abfd, const char *name)
{
  size_t len = strlen (name);
  char *new_name = (char *) bfd_alloc (abfd, len);
  if (new_name == 
# 2799 "../bfd/bfd.h" 3 4
                 ((void *)0)
# 2799 "../bfd/bfd.h"
                     )
    return 
# 2800 "../bfd/bfd.h" 3 4
          ((void *)0)
# 2800 "../bfd/bfd.h"
              ;
  new_name[0] = '.';
  memcpy (new_name + 1, name + 2, len - 1);
  return new_name;
}

enum compressed_debug_section_type
bfd_get_compression_algorithm (const char *name);

const char *bfd_get_compression_algorithm_name
   (enum compressed_debug_section_type type);

void bfd_update_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec);

int bfd_get_compression_header_size (bfd *abfd, asection *sec);


# 2817 "../bfd/bfd.h" 3 4
_Bool 
# 2817 "../bfd/bfd.h"
    bfd_convert_section_setup
   (bfd *ibfd, asection *isec, bfd *obfd,
    const char **new_name, bfd_size_type *new_size);


# 2821 "../bfd/bfd.h" 3 4
_Bool 
# 2821 "../bfd/bfd.h"
    bfd_convert_section_contents
   (bfd *ibfd, asection *isec, bfd *obfd,
    bfd_byte **ptr, bfd_size_type *ptr_size);


# 2825 "../bfd/bfd.h" 3 4
_Bool 
# 2825 "../bfd/bfd.h"
    bfd_get_full_section_contents
   (bfd *abfd, asection *section, bfd_byte **ptr);


# 2828 "../bfd/bfd.h" 3 4
_Bool 
# 2828 "../bfd/bfd.h"
    bfd_is_section_compressed_info
   (bfd *abfd, asection *section,
    int *compression_header_size_p,
    bfd_size_type *uncompressed_size_p,
    unsigned int *uncompressed_alignment_power_p,
    enum compression_type *ch_type);


# 2835 "../bfd/bfd.h" 3 4
_Bool 
# 2835 "../bfd/bfd.h"
    bfd_is_section_compressed
   (bfd *abfd, asection *section);


# 2838 "../bfd/bfd.h" 3 4
_Bool 
# 2838 "../bfd/bfd.h"
    bfd_init_section_decompress_status
   (bfd *abfd, asection *section);


# 2841 "../bfd/bfd.h" 3 4
_Bool 
# 2841 "../bfd/bfd.h"
    bfd_init_section_compress_status
   (bfd *abfd, asection *section);


# 2844 "../bfd/bfd.h" 3 4
_Bool 
# 2844 "../bfd/bfd.h"
    bfd_compress_section
   (bfd *abfd, asection *section, bfd_byte *uncompressed_buffer);


const char *bfd_core_file_failing_command (bfd *abfd);

int bfd_core_file_failing_signal (bfd *abfd);

int bfd_core_file_pid (bfd *abfd);


# 2854 "../bfd/bfd.h" 3 4
_Bool 
# 2854 "../bfd/bfd.h"
    core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);


# 2857 "../bfd/bfd.h" 3 4
_Bool 
# 2857 "../bfd/bfd.h"
    generic_core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);



# 2861 "../bfd/bfd.h" 3 4
_Bool 
# 2861 "../bfd/bfd.h"
    bfd_check_format (bfd *abfd, bfd_format format);


# 2863 "../bfd/bfd.h" 3 4
_Bool 
# 2863 "../bfd/bfd.h"
    bfd_check_format_matches
   (bfd *abfd, bfd_format format, char ***matching);


# 2866 "../bfd/bfd.h" 3 4
_Bool 
# 2866 "../bfd/bfd.h"
    bfd_set_format (bfd *abfd, bfd_format format);

const char *bfd_format_string (bfd_format format);
# 2882 "../bfd/bfd.h"

# 2882 "../bfd/bfd.h" 3 4
_Bool 
# 2882 "../bfd/bfd.h"
    bfd_link_split_section (bfd *abfd, asection *sec);





# 2887 "../bfd/bfd.h" 3 4
_Bool 
# 2887 "../bfd/bfd.h"
    bfd_section_already_linked (bfd *abfd,
    asection *sec,
    struct bfd_link_info *info);





# 2894 "../bfd/bfd.h" 3 4
_Bool 
# 2894 "../bfd/bfd.h"
    bfd_generic_define_common_symbol
   (bfd *output_bfd, struct bfd_link_info *info,
    struct bfd_link_hash_entry *h);




void _bfd_generic_link_hide_symbol
   (bfd *output_bfd, struct bfd_link_info *info,
    struct bfd_link_hash_entry *h);




struct bfd_link_hash_entry *bfd_generic_define_start_stop
   (struct bfd_link_info *info,
    const char *symbol, asection *sec);




struct bfd_elf_version_tree * bfd_find_version_for_sym
   (struct bfd_elf_version_tree *verdefs,
    const char *sym_name, 
# 2917 "../bfd/bfd.h" 3 4
                         _Bool 
# 2917 "../bfd/bfd.h"
                              *hide);


# 2919 "../bfd/bfd.h" 3 4
_Bool 
# 2919 "../bfd/bfd.h"
    bfd_hide_sym_by_version
   (struct bfd_elf_version_tree *verdefs, const char *sym_name);


# 2922 "../bfd/bfd.h" 3 4
_Bool 
# 2922 "../bfd/bfd.h"
    bfd_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);


# 2925 "../bfd/bfd.h" 3 4
_Bool 
# 2925 "../bfd/bfd.h"
    _bfd_generic_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);


# 2928 "../bfd/bfd.h" 3 4
_Bool 
# 2928 "../bfd/bfd.h"
    bfd_merge_private_bfd_data
   (bfd *ibfd, struct bfd_link_info *info);







extern unsigned int bfd_use_reserved_id;

bfd *bfd_fopen (const char *filename, const char *target,
    const char *mode, int fd);

bfd *bfd_openr (const char *filename, const char *target);

bfd *bfd_fdopenr (const char *filename, const char *target, int fd);

bfd *bfd_fdopenw (const char *filename, const char *target, int fd);

bfd *bfd_openstreamr (const char * filename, const char * target,
    void * stream);

bfd *bfd_openr_iovec (const char *filename, const char *target,
    void *(*open_func) (struct bfd *nbfd,
 void *open_closure),
    void *open_closure,
    file_ptr (*pread_func) (struct bfd *nbfd,
 void *stream,
 void *buf,
 file_ptr nbytes,
 file_ptr offset),
    int (*close_func) (struct bfd *nbfd,
 void *stream),
    int (*stat_func) (struct bfd *abfd,
 void *stream,
 struct stat *sb));

bfd *bfd_openw (const char *filename, const char *target);

bfd *bfd_elf_bfd_from_remote_memory
   (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
    int (*target_read_memory)
       (bfd_vma vma, bfd_byte *myaddr, bfd_size_type len));


# 2973 "../bfd/bfd.h" 3 4
_Bool 
# 2973 "../bfd/bfd.h"
    bfd_close (bfd *abfd);


# 2975 "../bfd/bfd.h" 3 4
_Bool 
# 2975 "../bfd/bfd.h"
    bfd_close_all_done (bfd *);

bfd *bfd_create (const char *filename, bfd *templ);


# 2979 "../bfd/bfd.h" 3 4
_Bool 
# 2979 "../bfd/bfd.h"
    bfd_make_writable (bfd *abfd);


# 2981 "../bfd/bfd.h" 3 4
_Bool 
# 2981 "../bfd/bfd.h"
    bfd_make_readable (bfd *abfd);

uint32_t bfd_calc_gnu_debuglink_crc32
   (uint32_t crc, const bfd_byte *buf, bfd_size_type len);

char *bfd_get_debug_link_info (bfd *abfd, uint32_t *crc32_out);

char *bfd_get_alt_debug_link_info (bfd * abfd,
    bfd_size_type *buildid_len,
    bfd_byte **buildid_out);

char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

char *bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir);

struct bfd_section *bfd_create_gnu_debuglink_section
   (bfd *abfd, const char *filename);


# 2999 "../bfd/bfd.h" 3 4
_Bool 
# 2999 "../bfd/bfd.h"
    bfd_fill_in_gnu_debuglink_section
   (bfd *abfd, struct bfd_section *sect, const char *filename);

char *bfd_follow_build_id_debuglink (bfd *abfd, const char *dir);

const char *bfd_set_filename (bfd *abfd, const char *filename);


typedef enum bfd_reloc_status
{


  bfd_reloc_ok = 2,


  bfd_reloc_overflow,


  bfd_reloc_outofrange,


  bfd_reloc_continue,


  bfd_reloc_notsupported,


  bfd_reloc_other,


  bfd_reloc_undefined,




  bfd_reloc_dangerous
 }
 bfd_reloc_status_type;

typedef const struct reloc_howto_struct reloc_howto_type;

struct reloc_cache_entry
{

  struct bfd_symbol **sym_ptr_ptr;


  bfd_size_type address;


  bfd_vma addend;


  reloc_howto_type *howto;

};

enum complain_overflow
{

  complain_overflow_dont,




  complain_overflow_bitfield,



  complain_overflow_signed,



  complain_overflow_unsigned
};

struct reloc_howto_struct
{



  unsigned int type;


  unsigned int size:4;



  unsigned int bitsize:7;



  unsigned int rightshift:6;



  unsigned int bitpos:6;



  __extension__ enum complain_overflow complain_on_overflow:2;


  unsigned int negate:1;


  unsigned int pc_relative:1;
# 3122 "../bfd/bfd.h"
  unsigned int partial_inplace:1;







  unsigned int pcrel_offset:1;




  unsigned int install_addend:1;
# 3145 "../bfd/bfd.h"
  bfd_vma src_mask;



  bfd_vma dst_mask;




  bfd_reloc_status_type (*special_function)
    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
     bfd *, char **);


  const char *name;
};
# 3173 "../bfd/bfd.h"
static inline unsigned int
bfd_get_reloc_size (reloc_howto_type *howto)
{
  return howto->size;
}

typedef struct relent_chain
{
  arelent relent;
  struct relent_chain *next;
}
arelent_chain;

bfd_reloc_status_type bfd_check_overflow
   (enum complain_overflow how,
    unsigned int bitsize,
    unsigned int rightshift,
    unsigned int addrsize,
    bfd_vma relocation);


# 3193 "../bfd/bfd.h" 3 4
_Bool 
# 3193 "../bfd/bfd.h"
    bfd_reloc_offset_in_range
   (reloc_howto_type *howto,
    bfd *abfd,
    asection *section,
    bfd_size_type offset);

bfd_reloc_status_type bfd_perform_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data,
    asection *input_section,
    bfd *output_bfd,
    char **error_message);

bfd_reloc_status_type bfd_install_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data, bfd_vma data_start,
    asection *input_section,
    char **error_message);

enum bfd_reloc_code_real {
  _dummy_first_bfd_reloc_code_real,



  BFD_RELOC_64,
  BFD_RELOC_32,
  BFD_RELOC_26,
  BFD_RELOC_24,
  BFD_RELOC_16,
  BFD_RELOC_14,
  BFD_RELOC_8,




  BFD_RELOC_64_PCREL,
  BFD_RELOC_32_PCREL,
  BFD_RELOC_24_PCREL,
  BFD_RELOC_16_PCREL,
  BFD_RELOC_12_PCREL,
  BFD_RELOC_8_PCREL,


  BFD_RELOC_32_SECREL,
  BFD_RELOC_16_SECIDX,


  BFD_RELOC_32_GOT_PCREL,
  BFD_RELOC_16_GOT_PCREL,
  BFD_RELOC_8_GOT_PCREL,
  BFD_RELOC_32_GOTOFF,
  BFD_RELOC_16_GOTOFF,
  BFD_RELOC_LO16_GOTOFF,
  BFD_RELOC_HI16_GOTOFF,
  BFD_RELOC_HI16_S_GOTOFF,
  BFD_RELOC_8_GOTOFF,
  BFD_RELOC_64_PLT_PCREL,
  BFD_RELOC_32_PLT_PCREL,
  BFD_RELOC_24_PLT_PCREL,
  BFD_RELOC_16_PLT_PCREL,
  BFD_RELOC_8_PLT_PCREL,
  BFD_RELOC_64_PLTOFF,
  BFD_RELOC_32_PLTOFF,
  BFD_RELOC_16_PLTOFF,
  BFD_RELOC_LO16_PLTOFF,
  BFD_RELOC_HI16_PLTOFF,
  BFD_RELOC_HI16_S_PLTOFF,
  BFD_RELOC_8_PLTOFF,


  BFD_RELOC_SIZE32,
  BFD_RELOC_SIZE64,


  BFD_RELOC_68K_GLOB_DAT,
  BFD_RELOC_68K_JMP_SLOT,
  BFD_RELOC_68K_RELATIVE,
  BFD_RELOC_68K_TLS_GD32,
  BFD_RELOC_68K_TLS_GD16,
  BFD_RELOC_68K_TLS_GD8,
  BFD_RELOC_68K_TLS_LDM32,
  BFD_RELOC_68K_TLS_LDM16,
  BFD_RELOC_68K_TLS_LDM8,
  BFD_RELOC_68K_TLS_LDO32,
  BFD_RELOC_68K_TLS_LDO16,
  BFD_RELOC_68K_TLS_LDO8,
  BFD_RELOC_68K_TLS_IE32,
  BFD_RELOC_68K_TLS_IE16,
  BFD_RELOC_68K_TLS_IE8,
  BFD_RELOC_68K_TLS_LE32,
  BFD_RELOC_68K_TLS_LE16,
  BFD_RELOC_68K_TLS_LE8,


  BFD_RELOC_32_BASEREL,
  BFD_RELOC_16_BASEREL,
  BFD_RELOC_LO16_BASEREL,
  BFD_RELOC_HI16_BASEREL,
  BFD_RELOC_HI16_S_BASEREL,
  BFD_RELOC_8_BASEREL,
  BFD_RELOC_RVA,


  BFD_RELOC_8_FFnn,







  BFD_RELOC_32_PCREL_S2,
  BFD_RELOC_16_PCREL_S2,
  BFD_RELOC_23_PCREL_S2,



  BFD_RELOC_HI22,
  BFD_RELOC_LO10,





  BFD_RELOC_GPREL16,
  BFD_RELOC_GPREL32,



  BFD_RELOC_NONE,
  BFD_RELOC_SPARC_WDISP22,
  BFD_RELOC_SPARC22,
  BFD_RELOC_SPARC13,
  BFD_RELOC_SPARC_GOT10,
  BFD_RELOC_SPARC_GOT13,
  BFD_RELOC_SPARC_GOT22,
  BFD_RELOC_SPARC_PC10,
  BFD_RELOC_SPARC_PC22,
  BFD_RELOC_SPARC_WPLT30,
  BFD_RELOC_SPARC_COPY,
  BFD_RELOC_SPARC_GLOB_DAT,
  BFD_RELOC_SPARC_JMP_SLOT,
  BFD_RELOC_SPARC_RELATIVE,
  BFD_RELOC_SPARC_UA16,
  BFD_RELOC_SPARC_UA32,
  BFD_RELOC_SPARC_UA64,
  BFD_RELOC_SPARC_GOTDATA_HIX22,
  BFD_RELOC_SPARC_GOTDATA_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP_HIX22,
  BFD_RELOC_SPARC_GOTDATA_OP_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP,
  BFD_RELOC_SPARC_JMP_IREL,
  BFD_RELOC_SPARC_IRELATIVE,


  BFD_RELOC_SPARC_BASE13,
  BFD_RELOC_SPARC_BASE22,



  BFD_RELOC_SPARC_10,
  BFD_RELOC_SPARC_11,
  BFD_RELOC_SPARC_OLO10,
  BFD_RELOC_SPARC_HH22,
  BFD_RELOC_SPARC_HM10,
  BFD_RELOC_SPARC_LM22,
  BFD_RELOC_SPARC_PC_HH22,
  BFD_RELOC_SPARC_PC_HM10,
  BFD_RELOC_SPARC_PC_LM22,
  BFD_RELOC_SPARC_WDISP16,
  BFD_RELOC_SPARC_WDISP19,
  BFD_RELOC_SPARC_7,
  BFD_RELOC_SPARC_6,
  BFD_RELOC_SPARC_5,

  BFD_RELOC_SPARC_PLT32,
  BFD_RELOC_SPARC_PLT64,
  BFD_RELOC_SPARC_HIX22,
  BFD_RELOC_SPARC_LOX10,
  BFD_RELOC_SPARC_H44,
  BFD_RELOC_SPARC_M44,
  BFD_RELOC_SPARC_L44,
  BFD_RELOC_SPARC_REGISTER,
  BFD_RELOC_SPARC_H34,
  BFD_RELOC_SPARC_SIZE32,
  BFD_RELOC_SPARC_SIZE64,
  BFD_RELOC_SPARC_WDISP10,


  BFD_RELOC_SPARC_REV32,


  BFD_RELOC_SPARC_TLS_GD_HI22,
  BFD_RELOC_SPARC_TLS_GD_LO10,
  BFD_RELOC_SPARC_TLS_GD_ADD,
  BFD_RELOC_SPARC_TLS_GD_CALL,
  BFD_RELOC_SPARC_TLS_LDM_HI22,
  BFD_RELOC_SPARC_TLS_LDM_LO10,
  BFD_RELOC_SPARC_TLS_LDM_ADD,
  BFD_RELOC_SPARC_TLS_LDM_CALL,
  BFD_RELOC_SPARC_TLS_LDO_HIX22,
  BFD_RELOC_SPARC_TLS_LDO_LOX10,
  BFD_RELOC_SPARC_TLS_LDO_ADD,
  BFD_RELOC_SPARC_TLS_IE_HI22,
  BFD_RELOC_SPARC_TLS_IE_LO10,
  BFD_RELOC_SPARC_TLS_IE_LD,
  BFD_RELOC_SPARC_TLS_IE_LDX,
  BFD_RELOC_SPARC_TLS_IE_ADD,
  BFD_RELOC_SPARC_TLS_LE_HIX22,
  BFD_RELOC_SPARC_TLS_LE_LOX10,
  BFD_RELOC_SPARC_TLS_DTPMOD32,
  BFD_RELOC_SPARC_TLS_DTPMOD64,
  BFD_RELOC_SPARC_TLS_DTPOFF32,
  BFD_RELOC_SPARC_TLS_DTPOFF64,
  BFD_RELOC_SPARC_TLS_TPOFF32,
  BFD_RELOC_SPARC_TLS_TPOFF64,


  BFD_RELOC_SPU_IMM7,
  BFD_RELOC_SPU_IMM8,
  BFD_RELOC_SPU_IMM10,
  BFD_RELOC_SPU_IMM10W,
  BFD_RELOC_SPU_IMM16,
  BFD_RELOC_SPU_IMM16W,
  BFD_RELOC_SPU_IMM18,
  BFD_RELOC_SPU_PCREL9a,
  BFD_RELOC_SPU_PCREL9b,
  BFD_RELOC_SPU_PCREL16,
  BFD_RELOC_SPU_LO16,
  BFD_RELOC_SPU_HI16,
  BFD_RELOC_SPU_PPU32,
  BFD_RELOC_SPU_PPU64,
  BFD_RELOC_SPU_ADD_PIC,







  BFD_RELOC_ALPHA_GPDISP_HI16,





  BFD_RELOC_ALPHA_GPDISP_LO16,




  BFD_RELOC_ALPHA_GPDISP,
# 3471 "../bfd/bfd.h"
  BFD_RELOC_ALPHA_LITERAL,
  BFD_RELOC_ALPHA_ELF_LITERAL,
  BFD_RELOC_ALPHA_LITUSE,




  BFD_RELOC_ALPHA_HINT,



  BFD_RELOC_ALPHA_LINKAGE,



  BFD_RELOC_ALPHA_CODEADDR,



  BFD_RELOC_ALPHA_GPREL_HI16,
  BFD_RELOC_ALPHA_GPREL_LO16,




  BFD_RELOC_ALPHA_BRSGP,



  BFD_RELOC_ALPHA_NOP,



  BFD_RELOC_ALPHA_BSR,



  BFD_RELOC_ALPHA_LDA,



  BFD_RELOC_ALPHA_BOH,


  BFD_RELOC_ALPHA_TLSGD,
  BFD_RELOC_ALPHA_TLSLDM,
  BFD_RELOC_ALPHA_DTPMOD64,
  BFD_RELOC_ALPHA_GOTDTPREL16,
  BFD_RELOC_ALPHA_DTPREL64,
  BFD_RELOC_ALPHA_DTPREL_HI16,
  BFD_RELOC_ALPHA_DTPREL_LO16,
  BFD_RELOC_ALPHA_DTPREL16,
  BFD_RELOC_ALPHA_GOTTPREL16,
  BFD_RELOC_ALPHA_TPREL64,
  BFD_RELOC_ALPHA_TPREL_HI16,
  BFD_RELOC_ALPHA_TPREL_LO16,
  BFD_RELOC_ALPHA_TPREL16,


  BFD_RELOC_MIPS_JMP,
  BFD_RELOC_MICROMIPS_JMP,


  BFD_RELOC_MIPS16_JMP,


  BFD_RELOC_MIPS16_GPREL,


  BFD_RELOC_HI16,





  BFD_RELOC_HI16_S,


  BFD_RELOC_LO16,


  BFD_RELOC_HI16_PCREL,


  BFD_RELOC_HI16_S_PCREL,


  BFD_RELOC_LO16_PCREL,



  BFD_RELOC_MIPS16_GOT16,
  BFD_RELOC_MIPS16_CALL16,


  BFD_RELOC_MIPS16_HI16,





  BFD_RELOC_MIPS16_HI16_S,


  BFD_RELOC_MIPS16_LO16,


  BFD_RELOC_MIPS16_TLS_GD,
  BFD_RELOC_MIPS16_TLS_LDM,
  BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS16_TLS_GOTTPREL,
  BFD_RELOC_MIPS16_TLS_TPREL_HI16,
  BFD_RELOC_MIPS16_TLS_TPREL_LO16,


  BFD_RELOC_MIPS_LITERAL,
  BFD_RELOC_MICROMIPS_LITERAL,


  BFD_RELOC_MICROMIPS_7_PCREL_S1,
  BFD_RELOC_MICROMIPS_10_PCREL_S1,
  BFD_RELOC_MICROMIPS_16_PCREL_S1,


  BFD_RELOC_MIPS16_16_PCREL_S1,


  BFD_RELOC_MIPS_21_PCREL_S2,
  BFD_RELOC_MIPS_26_PCREL_S2,
  BFD_RELOC_MIPS_18_PCREL_S3,
  BFD_RELOC_MIPS_19_PCREL_S2,


  BFD_RELOC_MICROMIPS_GPREL16,
  BFD_RELOC_MICROMIPS_HI16,
  BFD_RELOC_MICROMIPS_HI16_S,
  BFD_RELOC_MICROMIPS_LO16,


  BFD_RELOC_MIPS_GOT16,
  BFD_RELOC_MICROMIPS_GOT16,
  BFD_RELOC_MIPS_CALL16,
  BFD_RELOC_MICROMIPS_CALL16,
  BFD_RELOC_MIPS_GOT_HI16,
  BFD_RELOC_MICROMIPS_GOT_HI16,
  BFD_RELOC_MIPS_GOT_LO16,
  BFD_RELOC_MICROMIPS_GOT_LO16,
  BFD_RELOC_MIPS_CALL_HI16,
  BFD_RELOC_MICROMIPS_CALL_HI16,
  BFD_RELOC_MIPS_CALL_LO16,
  BFD_RELOC_MICROMIPS_CALL_LO16,
  BFD_RELOC_MIPS_SUB,
  BFD_RELOC_MICROMIPS_SUB,
  BFD_RELOC_MIPS_GOT_PAGE,
  BFD_RELOC_MICROMIPS_GOT_PAGE,
  BFD_RELOC_MIPS_GOT_OFST,
  BFD_RELOC_MICROMIPS_GOT_OFST,
  BFD_RELOC_MIPS_GOT_DISP,
  BFD_RELOC_MICROMIPS_GOT_DISP,
  BFD_RELOC_MIPS_SHIFT5,
  BFD_RELOC_MIPS_SHIFT6,
  BFD_RELOC_MIPS_INSERT_A,
  BFD_RELOC_MIPS_INSERT_B,
  BFD_RELOC_MIPS_DELETE,
  BFD_RELOC_MIPS_HIGHEST,
  BFD_RELOC_MICROMIPS_HIGHEST,
  BFD_RELOC_MIPS_HIGHER,
  BFD_RELOC_MICROMIPS_HIGHER,
  BFD_RELOC_MIPS_SCN_DISP,
  BFD_RELOC_MICROMIPS_SCN_DISP,
  BFD_RELOC_MIPS_16,
  BFD_RELOC_MIPS_RELGOT,
  BFD_RELOC_MIPS_JALR,
  BFD_RELOC_MICROMIPS_JALR,
  BFD_RELOC_MIPS_TLS_DTPMOD32,
  BFD_RELOC_MIPS_TLS_DTPREL32,
  BFD_RELOC_MIPS_TLS_DTPMOD64,
  BFD_RELOC_MIPS_TLS_DTPREL64,
  BFD_RELOC_MIPS_TLS_GD,
  BFD_RELOC_MICROMIPS_TLS_GD,
  BFD_RELOC_MIPS_TLS_LDM,
  BFD_RELOC_MICROMIPS_TLS_LDM,
  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS_TLS_GOTTPREL,
  BFD_RELOC_MICROMIPS_TLS_GOTTPREL,
  BFD_RELOC_MIPS_TLS_TPREL32,
  BFD_RELOC_MIPS_TLS_TPREL64,
  BFD_RELOC_MIPS_TLS_TPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_HI16,
  BFD_RELOC_MIPS_TLS_TPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_LO16,
  BFD_RELOC_MIPS_EH,



  BFD_RELOC_MIPS_COPY,
  BFD_RELOC_MIPS_JUMP_SLOT,



  BFD_RELOC_MOXIE_10_PCREL,



  BFD_RELOC_FT32_10,
  BFD_RELOC_FT32_20,
  BFD_RELOC_FT32_17,
  BFD_RELOC_FT32_18,
  BFD_RELOC_FT32_RELAX,
  BFD_RELOC_FT32_SC0,
  BFD_RELOC_FT32_SC1,
  BFD_RELOC_FT32_15,
  BFD_RELOC_FT32_DIFF32,



  BFD_RELOC_FRV_LABEL16,
  BFD_RELOC_FRV_LABEL24,
  BFD_RELOC_FRV_LO16,
  BFD_RELOC_FRV_HI16,
  BFD_RELOC_FRV_GPREL12,
  BFD_RELOC_FRV_GPRELU12,
  BFD_RELOC_FRV_GPREL32,
  BFD_RELOC_FRV_GPRELHI,
  BFD_RELOC_FRV_GPRELLO,
  BFD_RELOC_FRV_GOT12,
  BFD_RELOC_FRV_GOTHI,
  BFD_RELOC_FRV_GOTLO,
  BFD_RELOC_FRV_FUNCDESC,
  BFD_RELOC_FRV_FUNCDESC_GOT12,
  BFD_RELOC_FRV_FUNCDESC_GOTHI,
  BFD_RELOC_FRV_FUNCDESC_GOTLO,
  BFD_RELOC_FRV_FUNCDESC_VALUE,
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
  BFD_RELOC_FRV_GOTOFF12,
  BFD_RELOC_FRV_GOTOFFHI,
  BFD_RELOC_FRV_GOTOFFLO,
  BFD_RELOC_FRV_GETTLSOFF,
  BFD_RELOC_FRV_TLSDESC_VALUE,
  BFD_RELOC_FRV_GOTTLSDESC12,
  BFD_RELOC_FRV_GOTTLSDESCHI,
  BFD_RELOC_FRV_GOTTLSDESCLO,
  BFD_RELOC_FRV_TLSMOFF12,
  BFD_RELOC_FRV_TLSMOFFHI,
  BFD_RELOC_FRV_TLSMOFFLO,
  BFD_RELOC_FRV_GOTTLSOFF12,
  BFD_RELOC_FRV_GOTTLSOFFHI,
  BFD_RELOC_FRV_GOTTLSOFFLO,
  BFD_RELOC_FRV_TLSOFF,
  BFD_RELOC_FRV_TLSDESC_RELAX,
  BFD_RELOC_FRV_GETTLSOFF_RELAX,
  BFD_RELOC_FRV_TLSOFF_RELAX,
  BFD_RELOC_FRV_TLSMOFF,



  BFD_RELOC_MN10300_GOTOFF24,



  BFD_RELOC_MN10300_GOT32,



  BFD_RELOC_MN10300_GOT24,



  BFD_RELOC_MN10300_GOT16,


  BFD_RELOC_MN10300_COPY,


  BFD_RELOC_MN10300_GLOB_DAT,


  BFD_RELOC_MN10300_JMP_SLOT,


  BFD_RELOC_MN10300_RELATIVE,




  BFD_RELOC_MN10300_SYM_DIFF,




  BFD_RELOC_MN10300_ALIGN,


  BFD_RELOC_MN10300_TLS_GD,
  BFD_RELOC_MN10300_TLS_LD,
  BFD_RELOC_MN10300_TLS_LDO,
  BFD_RELOC_MN10300_TLS_GOTIE,
  BFD_RELOC_MN10300_TLS_IE,
  BFD_RELOC_MN10300_TLS_LE,
  BFD_RELOC_MN10300_TLS_DTPMOD,
  BFD_RELOC_MN10300_TLS_DTPOFF,
  BFD_RELOC_MN10300_TLS_TPOFF,



  BFD_RELOC_MN10300_32_PCREL,



  BFD_RELOC_MN10300_16_PCREL,



  BFD_RELOC_386_GOT32,
  BFD_RELOC_386_PLT32,
  BFD_RELOC_386_COPY,
  BFD_RELOC_386_GLOB_DAT,
  BFD_RELOC_386_JUMP_SLOT,
  BFD_RELOC_386_RELATIVE,
  BFD_RELOC_386_GOTOFF,
  BFD_RELOC_386_GOTPC,
  BFD_RELOC_386_TLS_TPOFF,
  BFD_RELOC_386_TLS_IE,
  BFD_RELOC_386_TLS_GOTIE,
  BFD_RELOC_386_TLS_LE,
  BFD_RELOC_386_TLS_GD,
  BFD_RELOC_386_TLS_LDM,
  BFD_RELOC_386_TLS_LDO_32,
  BFD_RELOC_386_TLS_IE_32,
  BFD_RELOC_386_TLS_LE_32,
  BFD_RELOC_386_TLS_DTPMOD32,
  BFD_RELOC_386_TLS_DTPOFF32,
  BFD_RELOC_386_TLS_TPOFF32,
  BFD_RELOC_386_TLS_GOTDESC,
  BFD_RELOC_386_TLS_DESC_CALL,
  BFD_RELOC_386_TLS_DESC,
  BFD_RELOC_386_IRELATIVE,
  BFD_RELOC_386_GOT32X,


  BFD_RELOC_X86_64_GOT32,
  BFD_RELOC_X86_64_PLT32,
  BFD_RELOC_X86_64_COPY,
  BFD_RELOC_X86_64_GLOB_DAT,
  BFD_RELOC_X86_64_JUMP_SLOT,
  BFD_RELOC_X86_64_RELATIVE,
  BFD_RELOC_X86_64_GOTPCREL,
  BFD_RELOC_X86_64_32S,
  BFD_RELOC_X86_64_DTPMOD64,
  BFD_RELOC_X86_64_DTPOFF64,
  BFD_RELOC_X86_64_TPOFF64,
  BFD_RELOC_X86_64_TLSGD,
  BFD_RELOC_X86_64_TLSLD,
  BFD_RELOC_X86_64_DTPOFF32,
  BFD_RELOC_X86_64_GOTTPOFF,
  BFD_RELOC_X86_64_TPOFF32,
  BFD_RELOC_X86_64_GOTOFF64,
  BFD_RELOC_X86_64_GOTPC32,
  BFD_RELOC_X86_64_GOT64,
  BFD_RELOC_X86_64_GOTPCREL64,
  BFD_RELOC_X86_64_GOTPC64,
  BFD_RELOC_X86_64_GOTPLT64,
  BFD_RELOC_X86_64_PLTOFF64,
  BFD_RELOC_X86_64_GOTPC32_TLSDESC,
  BFD_RELOC_X86_64_TLSDESC_CALL,
  BFD_RELOC_X86_64_TLSDESC,
  BFD_RELOC_X86_64_IRELATIVE,
  BFD_RELOC_X86_64_PC32_BND,
  BFD_RELOC_X86_64_PLT32_BND,
  BFD_RELOC_X86_64_GOTPCRELX,
  BFD_RELOC_X86_64_REX_GOTPCRELX,


  BFD_RELOC_NS32K_IMM_8,
  BFD_RELOC_NS32K_IMM_16,
  BFD_RELOC_NS32K_IMM_32,
  BFD_RELOC_NS32K_IMM_8_PCREL,
  BFD_RELOC_NS32K_IMM_16_PCREL,
  BFD_RELOC_NS32K_IMM_32_PCREL,
  BFD_RELOC_NS32K_DISP_8,
  BFD_RELOC_NS32K_DISP_16,
  BFD_RELOC_NS32K_DISP_32,
  BFD_RELOC_NS32K_DISP_8_PCREL,
  BFD_RELOC_NS32K_DISP_16_PCREL,
  BFD_RELOC_NS32K_DISP_32_PCREL,


  BFD_RELOC_PDP11_DISP_8_PCREL,
  BFD_RELOC_PDP11_DISP_6_PCREL,


  BFD_RELOC_PJ_CODE_HI16,
  BFD_RELOC_PJ_CODE_LO16,
  BFD_RELOC_PJ_CODE_DIR16,
  BFD_RELOC_PJ_CODE_DIR32,
  BFD_RELOC_PJ_CODE_REL16,
  BFD_RELOC_PJ_CODE_REL32,


  BFD_RELOC_PPC_B26,
  BFD_RELOC_PPC_BA26,
  BFD_RELOC_PPC_TOC16,
  BFD_RELOC_PPC_TOC16_LO,
  BFD_RELOC_PPC_TOC16_HI,
  BFD_RELOC_PPC_B16,
  BFD_RELOC_PPC_B16_BRTAKEN,
  BFD_RELOC_PPC_B16_BRNTAKEN,
  BFD_RELOC_PPC_BA16,
  BFD_RELOC_PPC_BA16_BRTAKEN,
  BFD_RELOC_PPC_BA16_BRNTAKEN,
  BFD_RELOC_PPC_COPY,
  BFD_RELOC_PPC_GLOB_DAT,
  BFD_RELOC_PPC_JMP_SLOT,
  BFD_RELOC_PPC_RELATIVE,
  BFD_RELOC_PPC_LOCAL24PC,
  BFD_RELOC_PPC_EMB_NADDR32,
  BFD_RELOC_PPC_EMB_NADDR16,
  BFD_RELOC_PPC_EMB_NADDR16_LO,
  BFD_RELOC_PPC_EMB_NADDR16_HI,
  BFD_RELOC_PPC_EMB_NADDR16_HA,
  BFD_RELOC_PPC_EMB_SDAI16,
  BFD_RELOC_PPC_EMB_SDA2I16,
  BFD_RELOC_PPC_EMB_SDA2REL,
  BFD_RELOC_PPC_EMB_SDA21,
  BFD_RELOC_PPC_EMB_MRKREF,
  BFD_RELOC_PPC_EMB_RELSEC16,
  BFD_RELOC_PPC_EMB_RELST_LO,
  BFD_RELOC_PPC_EMB_RELST_HI,
  BFD_RELOC_PPC_EMB_RELST_HA,
  BFD_RELOC_PPC_EMB_BIT_FLD,
  BFD_RELOC_PPC_EMB_RELSDA,
  BFD_RELOC_PPC_VLE_REL8,
  BFD_RELOC_PPC_VLE_REL15,
  BFD_RELOC_PPC_VLE_REL24,
  BFD_RELOC_PPC_VLE_LO16A,
  BFD_RELOC_PPC_VLE_LO16D,
  BFD_RELOC_PPC_VLE_HI16A,
  BFD_RELOC_PPC_VLE_HI16D,
  BFD_RELOC_PPC_VLE_HA16A,
  BFD_RELOC_PPC_VLE_HA16D,
  BFD_RELOC_PPC_VLE_SDA21,
  BFD_RELOC_PPC_VLE_SDA21_LO,
  BFD_RELOC_PPC_VLE_SDAREL_LO16A,
  BFD_RELOC_PPC_VLE_SDAREL_LO16D,
  BFD_RELOC_PPC_VLE_SDAREL_HI16A,
  BFD_RELOC_PPC_VLE_SDAREL_HI16D,
  BFD_RELOC_PPC_VLE_SDAREL_HA16A,
  BFD_RELOC_PPC_VLE_SDAREL_HA16D,
  BFD_RELOC_PPC_16DX_HA,
  BFD_RELOC_PPC_REL16DX_HA,
  BFD_RELOC_PPC_NEG,
  BFD_RELOC_PPC64_HIGHER,
  BFD_RELOC_PPC64_HIGHER_S,
  BFD_RELOC_PPC64_HIGHEST,
  BFD_RELOC_PPC64_HIGHEST_S,
  BFD_RELOC_PPC64_TOC16_LO,
  BFD_RELOC_PPC64_TOC16_HI,
  BFD_RELOC_PPC64_TOC16_HA,
  BFD_RELOC_PPC64_TOC,
  BFD_RELOC_PPC64_PLTGOT16,
  BFD_RELOC_PPC64_PLTGOT16_LO,
  BFD_RELOC_PPC64_PLTGOT16_HI,
  BFD_RELOC_PPC64_PLTGOT16_HA,
  BFD_RELOC_PPC64_ADDR16_DS,
  BFD_RELOC_PPC64_ADDR16_LO_DS,
  BFD_RELOC_PPC64_GOT16_DS,
  BFD_RELOC_PPC64_GOT16_LO_DS,
  BFD_RELOC_PPC64_PLT16_LO_DS,
  BFD_RELOC_PPC64_SECTOFF_DS,
  BFD_RELOC_PPC64_SECTOFF_LO_DS,
  BFD_RELOC_PPC64_TOC16_DS,
  BFD_RELOC_PPC64_TOC16_LO_DS,
  BFD_RELOC_PPC64_PLTGOT16_DS,
  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
  BFD_RELOC_PPC64_ADDR16_HIGH,
  BFD_RELOC_PPC64_ADDR16_HIGHA,
  BFD_RELOC_PPC64_REL16_HIGH,
  BFD_RELOC_PPC64_REL16_HIGHA,
  BFD_RELOC_PPC64_REL16_HIGHER,
  BFD_RELOC_PPC64_REL16_HIGHERA,
  BFD_RELOC_PPC64_REL16_HIGHEST,
  BFD_RELOC_PPC64_REL16_HIGHESTA,
  BFD_RELOC_PPC64_ADDR64_LOCAL,
  BFD_RELOC_PPC64_ENTRY,
  BFD_RELOC_PPC64_REL24_NOTOC,
  BFD_RELOC_PPC64_REL24_P9NOTOC,
  BFD_RELOC_PPC64_D34,
  BFD_RELOC_PPC64_D34_LO,
  BFD_RELOC_PPC64_D34_HI30,
  BFD_RELOC_PPC64_D34_HA30,
  BFD_RELOC_PPC64_PCREL34,
  BFD_RELOC_PPC64_GOT_PCREL34,
  BFD_RELOC_PPC64_PLT_PCREL34,
  BFD_RELOC_PPC64_ADDR16_HIGHER34,
  BFD_RELOC_PPC64_ADDR16_HIGHERA34,
  BFD_RELOC_PPC64_ADDR16_HIGHEST34,
  BFD_RELOC_PPC64_ADDR16_HIGHESTA34,
  BFD_RELOC_PPC64_REL16_HIGHER34,
  BFD_RELOC_PPC64_REL16_HIGHERA34,
  BFD_RELOC_PPC64_REL16_HIGHEST34,
  BFD_RELOC_PPC64_REL16_HIGHESTA34,
  BFD_RELOC_PPC64_D28,
  BFD_RELOC_PPC64_PCREL28,


  BFD_RELOC_PPC_TLS,
  BFD_RELOC_PPC_TLSGD,
  BFD_RELOC_PPC_TLSLD,
  BFD_RELOC_PPC_TLSLE,
  BFD_RELOC_PPC_TLSIE,
  BFD_RELOC_PPC_TLSM,
  BFD_RELOC_PPC_TLSML,
  BFD_RELOC_PPC_DTPMOD,
  BFD_RELOC_PPC_TPREL16,
  BFD_RELOC_PPC_TPREL16_LO,
  BFD_RELOC_PPC_TPREL16_HI,
  BFD_RELOC_PPC_TPREL16_HA,
  BFD_RELOC_PPC_TPREL,
  BFD_RELOC_PPC_DTPREL16,
  BFD_RELOC_PPC_DTPREL16_LO,
  BFD_RELOC_PPC_DTPREL16_HI,
  BFD_RELOC_PPC_DTPREL16_HA,
  BFD_RELOC_PPC_DTPREL,
  BFD_RELOC_PPC_GOT_TLSGD16,
  BFD_RELOC_PPC_GOT_TLSGD16_LO,
  BFD_RELOC_PPC_GOT_TLSGD16_HI,
  BFD_RELOC_PPC_GOT_TLSGD16_HA,
  BFD_RELOC_PPC_GOT_TLSLD16,
  BFD_RELOC_PPC_GOT_TLSLD16_LO,
  BFD_RELOC_PPC_GOT_TLSLD16_HI,
  BFD_RELOC_PPC_GOT_TLSLD16_HA,
  BFD_RELOC_PPC_GOT_TPREL16,
  BFD_RELOC_PPC_GOT_TPREL16_LO,
  BFD_RELOC_PPC_GOT_TPREL16_HI,
  BFD_RELOC_PPC_GOT_TPREL16_HA,
  BFD_RELOC_PPC_GOT_DTPREL16,
  BFD_RELOC_PPC_GOT_DTPREL16_LO,
  BFD_RELOC_PPC_GOT_DTPREL16_HI,
  BFD_RELOC_PPC_GOT_DTPREL16_HA,
  BFD_RELOC_PPC64_TLSGD,
  BFD_RELOC_PPC64_TLSLD,
  BFD_RELOC_PPC64_TLSLE,
  BFD_RELOC_PPC64_TLSIE,
  BFD_RELOC_PPC64_TLSM,
  BFD_RELOC_PPC64_TLSML,
  BFD_RELOC_PPC64_TPREL16_DS,
  BFD_RELOC_PPC64_TPREL16_LO_DS,
  BFD_RELOC_PPC64_TPREL16_HIGH,
  BFD_RELOC_PPC64_TPREL16_HIGHA,
  BFD_RELOC_PPC64_TPREL16_HIGHER,
  BFD_RELOC_PPC64_TPREL16_HIGHERA,
  BFD_RELOC_PPC64_TPREL16_HIGHEST,
  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
  BFD_RELOC_PPC64_DTPREL16_DS,
  BFD_RELOC_PPC64_DTPREL16_LO_DS,
  BFD_RELOC_PPC64_DTPREL16_HIGH,
  BFD_RELOC_PPC64_DTPREL16_HIGHA,
  BFD_RELOC_PPC64_DTPREL16_HIGHER,
  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
  BFD_RELOC_PPC64_TPREL34,
  BFD_RELOC_PPC64_DTPREL34,
  BFD_RELOC_PPC64_GOT_TLSGD_PCREL34,
  BFD_RELOC_PPC64_GOT_TLSLD_PCREL34,
  BFD_RELOC_PPC64_GOT_TPREL_PCREL34,
  BFD_RELOC_PPC64_GOT_DTPREL_PCREL34,
  BFD_RELOC_PPC64_TLS_PCREL,


  BFD_RELOC_I370_D12,




  BFD_RELOC_CTOR,



  BFD_RELOC_ARM_PCREL_BRANCH,




  BFD_RELOC_ARM_PCREL_BLX,




  BFD_RELOC_THUMB_PCREL_BLX,


  BFD_RELOC_ARM_PCREL_CALL,


  BFD_RELOC_ARM_PCREL_JUMP,


  BFD_RELOC_THUMB_PCREL_BRANCH5,


  BFD_RELOC_THUMB_PCREL_BFCSEL,


  BFD_RELOC_ARM_THUMB_BF17,


  BFD_RELOC_ARM_THUMB_BF13,


  BFD_RELOC_ARM_THUMB_BF19,


  BFD_RELOC_ARM_THUMB_LOOP12,






  BFD_RELOC_THUMB_PCREL_BRANCH7,
  BFD_RELOC_THUMB_PCREL_BRANCH9,
  BFD_RELOC_THUMB_PCREL_BRANCH12,
  BFD_RELOC_THUMB_PCREL_BRANCH20,
  BFD_RELOC_THUMB_PCREL_BRANCH23,
  BFD_RELOC_THUMB_PCREL_BRANCH25,


  BFD_RELOC_ARM_OFFSET_IMM,


  BFD_RELOC_ARM_THUMB_OFFSET,



  BFD_RELOC_ARM_TARGET1,


  BFD_RELOC_ARM_ROSEGREL32,


  BFD_RELOC_ARM_SBREL32,




  BFD_RELOC_ARM_TARGET2,


  BFD_RELOC_ARM_PREL31,


  BFD_RELOC_ARM_MOVW,
  BFD_RELOC_ARM_MOVT,
  BFD_RELOC_ARM_MOVW_PCREL,
  BFD_RELOC_ARM_MOVT_PCREL,
  BFD_RELOC_ARM_THUMB_MOVW,
  BFD_RELOC_ARM_THUMB_MOVT,
  BFD_RELOC_ARM_THUMB_MOVW_PCREL,
  BFD_RELOC_ARM_THUMB_MOVT_PCREL,


  BFD_RELOC_ARM_GOTFUNCDESC,
  BFD_RELOC_ARM_GOTOFFFUNCDESC,
  BFD_RELOC_ARM_FUNCDESC,
  BFD_RELOC_ARM_FUNCDESC_VALUE,
  BFD_RELOC_ARM_TLS_GD32_FDPIC,
  BFD_RELOC_ARM_TLS_LDM32_FDPIC,
  BFD_RELOC_ARM_TLS_IE32_FDPIC,


  BFD_RELOC_ARM_JUMP_SLOT,
  BFD_RELOC_ARM_GLOB_DAT,
  BFD_RELOC_ARM_GOT32,
  BFD_RELOC_ARM_PLT32,
  BFD_RELOC_ARM_RELATIVE,
  BFD_RELOC_ARM_GOTOFF,
  BFD_RELOC_ARM_GOTPC,
  BFD_RELOC_ARM_GOT_PREL,


  BFD_RELOC_ARM_TLS_GD32,
  BFD_RELOC_ARM_TLS_LDO32,
  BFD_RELOC_ARM_TLS_LDM32,
  BFD_RELOC_ARM_TLS_DTPOFF32,
  BFD_RELOC_ARM_TLS_DTPMOD32,
  BFD_RELOC_ARM_TLS_TPOFF32,
  BFD_RELOC_ARM_TLS_IE32,
  BFD_RELOC_ARM_TLS_LE32,
  BFD_RELOC_ARM_TLS_GOTDESC,
  BFD_RELOC_ARM_TLS_CALL,
  BFD_RELOC_ARM_THM_TLS_CALL,
  BFD_RELOC_ARM_TLS_DESCSEQ,
  BFD_RELOC_ARM_THM_TLS_DESCSEQ,
  BFD_RELOC_ARM_TLS_DESC,


  BFD_RELOC_ARM_ALU_PC_G0_NC,
  BFD_RELOC_ARM_ALU_PC_G0,
  BFD_RELOC_ARM_ALU_PC_G1_NC,
  BFD_RELOC_ARM_ALU_PC_G1,
  BFD_RELOC_ARM_ALU_PC_G2,
  BFD_RELOC_ARM_LDR_PC_G0,
  BFD_RELOC_ARM_LDR_PC_G1,
  BFD_RELOC_ARM_LDR_PC_G2,
  BFD_RELOC_ARM_LDRS_PC_G0,
  BFD_RELOC_ARM_LDRS_PC_G1,
  BFD_RELOC_ARM_LDRS_PC_G2,
  BFD_RELOC_ARM_LDC_PC_G0,
  BFD_RELOC_ARM_LDC_PC_G1,
  BFD_RELOC_ARM_LDC_PC_G2,
  BFD_RELOC_ARM_ALU_SB_G0_NC,
  BFD_RELOC_ARM_ALU_SB_G0,
  BFD_RELOC_ARM_ALU_SB_G1_NC,
  BFD_RELOC_ARM_ALU_SB_G1,
  BFD_RELOC_ARM_ALU_SB_G2,
  BFD_RELOC_ARM_LDR_SB_G0,
  BFD_RELOC_ARM_LDR_SB_G1,
  BFD_RELOC_ARM_LDR_SB_G2,
  BFD_RELOC_ARM_LDRS_SB_G0,
  BFD_RELOC_ARM_LDRS_SB_G1,
  BFD_RELOC_ARM_LDRS_SB_G2,
  BFD_RELOC_ARM_LDC_SB_G0,
  BFD_RELOC_ARM_LDC_SB_G1,
  BFD_RELOC_ARM_LDC_SB_G2,


  BFD_RELOC_ARM_V4BX,


  BFD_RELOC_ARM_IRELATIVE,


  BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC,



  BFD_RELOC_ARM_IMMEDIATE,
  BFD_RELOC_ARM_ADRL_IMMEDIATE,
  BFD_RELOC_ARM_T32_IMMEDIATE,
  BFD_RELOC_ARM_T32_ADD_IMM,
  BFD_RELOC_ARM_T32_IMM12,
  BFD_RELOC_ARM_T32_ADD_PC12,
  BFD_RELOC_ARM_SHIFT_IMM,
  BFD_RELOC_ARM_SMC,
  BFD_RELOC_ARM_HVC,
  BFD_RELOC_ARM_SWI,
  BFD_RELOC_ARM_MULTI,
  BFD_RELOC_ARM_CP_OFF_IMM,
  BFD_RELOC_ARM_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_T32_CP_OFF_IMM,
  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_T32_VLDR_VSTR_OFF_IMM,
  BFD_RELOC_ARM_ADR_IMM,
  BFD_RELOC_ARM_LDR_IMM,
  BFD_RELOC_ARM_LITERAL,
  BFD_RELOC_ARM_IN_POOL,
  BFD_RELOC_ARM_OFFSET_IMM8,
  BFD_RELOC_ARM_T32_OFFSET_U8,
  BFD_RELOC_ARM_T32_OFFSET_IMM,
  BFD_RELOC_ARM_HWLITERAL,
  BFD_RELOC_ARM_THUMB_ADD,
  BFD_RELOC_ARM_THUMB_IMM,
  BFD_RELOC_ARM_THUMB_SHIFT,


  BFD_RELOC_SH_PCDISP8BY2,
  BFD_RELOC_SH_PCDISP12BY2,
  BFD_RELOC_SH_IMM3,
  BFD_RELOC_SH_IMM3U,
  BFD_RELOC_SH_DISP12,
  BFD_RELOC_SH_DISP12BY2,
  BFD_RELOC_SH_DISP12BY4,
  BFD_RELOC_SH_DISP12BY8,
  BFD_RELOC_SH_DISP20,
  BFD_RELOC_SH_DISP20BY8,
  BFD_RELOC_SH_IMM4,
  BFD_RELOC_SH_IMM4BY2,
  BFD_RELOC_SH_IMM4BY4,
  BFD_RELOC_SH_IMM8,
  BFD_RELOC_SH_IMM8BY2,
  BFD_RELOC_SH_IMM8BY4,
  BFD_RELOC_SH_PCRELIMM8BY2,
  BFD_RELOC_SH_PCRELIMM8BY4,
  BFD_RELOC_SH_SWITCH16,
  BFD_RELOC_SH_SWITCH32,
  BFD_RELOC_SH_USES,
  BFD_RELOC_SH_COUNT,
  BFD_RELOC_SH_ALIGN,
  BFD_RELOC_SH_CODE,
  BFD_RELOC_SH_DATA,
  BFD_RELOC_SH_LABEL,
  BFD_RELOC_SH_LOOP_START,
  BFD_RELOC_SH_LOOP_END,
  BFD_RELOC_SH_COPY,
  BFD_RELOC_SH_GLOB_DAT,
  BFD_RELOC_SH_JMP_SLOT,
  BFD_RELOC_SH_RELATIVE,
  BFD_RELOC_SH_GOTPC,
  BFD_RELOC_SH_GOT_LOW16,
  BFD_RELOC_SH_GOT_MEDLOW16,
  BFD_RELOC_SH_GOT_MEDHI16,
  BFD_RELOC_SH_GOT_HI16,
  BFD_RELOC_SH_GOTPLT_LOW16,
  BFD_RELOC_SH_GOTPLT_MEDLOW16,
  BFD_RELOC_SH_GOTPLT_MEDHI16,
  BFD_RELOC_SH_GOTPLT_HI16,
  BFD_RELOC_SH_PLT_LOW16,
  BFD_RELOC_SH_PLT_MEDLOW16,
  BFD_RELOC_SH_PLT_MEDHI16,
  BFD_RELOC_SH_PLT_HI16,
  BFD_RELOC_SH_GOTOFF_LOW16,
  BFD_RELOC_SH_GOTOFF_MEDLOW16,
  BFD_RELOC_SH_GOTOFF_MEDHI16,
  BFD_RELOC_SH_GOTOFF_HI16,
  BFD_RELOC_SH_GOTPC_LOW16,
  BFD_RELOC_SH_GOTPC_MEDLOW16,
  BFD_RELOC_SH_GOTPC_MEDHI16,
  BFD_RELOC_SH_GOTPC_HI16,
  BFD_RELOC_SH_COPY64,
  BFD_RELOC_SH_GLOB_DAT64,
  BFD_RELOC_SH_JMP_SLOT64,
  BFD_RELOC_SH_RELATIVE64,
  BFD_RELOC_SH_GOT10BY4,
  BFD_RELOC_SH_GOT10BY8,
  BFD_RELOC_SH_GOTPLT10BY4,
  BFD_RELOC_SH_GOTPLT10BY8,
  BFD_RELOC_SH_GOTPLT32,
  BFD_RELOC_SH_SHMEDIA_CODE,
  BFD_RELOC_SH_IMMU5,
  BFD_RELOC_SH_IMMS6,
  BFD_RELOC_SH_IMMS6BY32,
  BFD_RELOC_SH_IMMU6,
  BFD_RELOC_SH_IMMS10,
  BFD_RELOC_SH_IMMS10BY2,
  BFD_RELOC_SH_IMMS10BY4,
  BFD_RELOC_SH_IMMS10BY8,
  BFD_RELOC_SH_IMMS16,
  BFD_RELOC_SH_IMMU16,
  BFD_RELOC_SH_IMM_LOW16,
  BFD_RELOC_SH_IMM_LOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDLOW16,
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDHI16,
  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
  BFD_RELOC_SH_IMM_HI16,
  BFD_RELOC_SH_IMM_HI16_PCREL,
  BFD_RELOC_SH_PT_16,
  BFD_RELOC_SH_TLS_GD_32,
  BFD_RELOC_SH_TLS_LD_32,
  BFD_RELOC_SH_TLS_LDO_32,
  BFD_RELOC_SH_TLS_IE_32,
  BFD_RELOC_SH_TLS_LE_32,
  BFD_RELOC_SH_TLS_DTPMOD32,
  BFD_RELOC_SH_TLS_DTPOFF32,
  BFD_RELOC_SH_TLS_TPOFF32,
  BFD_RELOC_SH_GOT20,
  BFD_RELOC_SH_GOTOFF20,
  BFD_RELOC_SH_GOTFUNCDESC,
  BFD_RELOC_SH_GOTFUNCDESC20,
  BFD_RELOC_SH_GOTOFFFUNCDESC,
  BFD_RELOC_SH_GOTOFFFUNCDESC20,
  BFD_RELOC_SH_FUNCDESC,


  BFD_RELOC_ARC_NONE,
  BFD_RELOC_ARC_8,
  BFD_RELOC_ARC_16,
  BFD_RELOC_ARC_24,
  BFD_RELOC_ARC_32,
  BFD_RELOC_ARC_N8,
  BFD_RELOC_ARC_N16,
  BFD_RELOC_ARC_N24,
  BFD_RELOC_ARC_N32,
  BFD_RELOC_ARC_SDA,
  BFD_RELOC_ARC_SECTOFF,
  BFD_RELOC_ARC_S21H_PCREL,
  BFD_RELOC_ARC_S21W_PCREL,
  BFD_RELOC_ARC_S25H_PCREL,
  BFD_RELOC_ARC_S25W_PCREL,
  BFD_RELOC_ARC_SDA32,
  BFD_RELOC_ARC_SDA_LDST,
  BFD_RELOC_ARC_SDA_LDST1,
  BFD_RELOC_ARC_SDA_LDST2,
  BFD_RELOC_ARC_SDA16_LD,
  BFD_RELOC_ARC_SDA16_LD1,
  BFD_RELOC_ARC_SDA16_LD2,
  BFD_RELOC_ARC_S13_PCREL,
  BFD_RELOC_ARC_W,
  BFD_RELOC_ARC_32_ME,
  BFD_RELOC_ARC_32_ME_S,
  BFD_RELOC_ARC_N32_ME,
  BFD_RELOC_ARC_SECTOFF_ME,
  BFD_RELOC_ARC_SDA32_ME,
  BFD_RELOC_ARC_W_ME,
  BFD_RELOC_AC_SECTOFF_U8,
  BFD_RELOC_AC_SECTOFF_U8_1,
  BFD_RELOC_AC_SECTOFF_U8_2,
  BFD_RELOC_AC_SECTOFF_S9,
  BFD_RELOC_AC_SECTOFF_S9_1,
  BFD_RELOC_AC_SECTOFF_S9_2,
  BFD_RELOC_ARC_SECTOFF_ME_1,
  BFD_RELOC_ARC_SECTOFF_ME_2,
  BFD_RELOC_ARC_SECTOFF_1,
  BFD_RELOC_ARC_SECTOFF_2,
  BFD_RELOC_ARC_SDA_12,
  BFD_RELOC_ARC_SDA16_ST2,
  BFD_RELOC_ARC_32_PCREL,
  BFD_RELOC_ARC_PC32,
  BFD_RELOC_ARC_GOT32,
  BFD_RELOC_ARC_GOTPC32,
  BFD_RELOC_ARC_PLT32,
  BFD_RELOC_ARC_COPY,
  BFD_RELOC_ARC_GLOB_DAT,
  BFD_RELOC_ARC_JMP_SLOT,
  BFD_RELOC_ARC_RELATIVE,
  BFD_RELOC_ARC_GOTOFF,
  BFD_RELOC_ARC_GOTPC,
  BFD_RELOC_ARC_S21W_PCREL_PLT,
  BFD_RELOC_ARC_S25H_PCREL_PLT,
  BFD_RELOC_ARC_TLS_DTPMOD,
  BFD_RELOC_ARC_TLS_TPOFF,
  BFD_RELOC_ARC_TLS_GD_GOT,
  BFD_RELOC_ARC_TLS_GD_LD,
  BFD_RELOC_ARC_TLS_GD_CALL,
  BFD_RELOC_ARC_TLS_IE_GOT,
  BFD_RELOC_ARC_TLS_DTPOFF,
  BFD_RELOC_ARC_TLS_DTPOFF_S9,
  BFD_RELOC_ARC_TLS_LE_S9,
  BFD_RELOC_ARC_TLS_LE_32,
  BFD_RELOC_ARC_S25W_PCREL_PLT,
  BFD_RELOC_ARC_S21H_PCREL_PLT,
  BFD_RELOC_ARC_NPS_CMEM16,
  BFD_RELOC_ARC_JLI_SECTOFF,


  BFD_RELOC_BFIN_16_IMM,


  BFD_RELOC_BFIN_16_HIGH,


  BFD_RELOC_BFIN_4_PCREL,


  BFD_RELOC_BFIN_5_PCREL,


  BFD_RELOC_BFIN_16_LOW,


  BFD_RELOC_BFIN_10_PCREL,


  BFD_RELOC_BFIN_11_PCREL,


  BFD_RELOC_BFIN_12_PCREL_JUMP,


  BFD_RELOC_BFIN_12_PCREL_JUMP_S,


  BFD_RELOC_BFIN_24_PCREL_CALL_X,


  BFD_RELOC_BFIN_24_PCREL_JUMP_L,


  BFD_RELOC_BFIN_GOT17M4,
  BFD_RELOC_BFIN_GOTHI,
  BFD_RELOC_BFIN_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC,
  BFD_RELOC_BFIN_FUNCDESC_GOT17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC_VALUE,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO,
  BFD_RELOC_BFIN_GOTOFF17M4,
  BFD_RELOC_BFIN_GOTOFFHI,
  BFD_RELOC_BFIN_GOTOFFLO,


  BFD_RELOC_BFIN_GOT,


  BFD_RELOC_BFIN_PLTPC,


  BFD_ARELOC_BFIN_PUSH,


  BFD_ARELOC_BFIN_CONST,


  BFD_ARELOC_BFIN_ADD,


  BFD_ARELOC_BFIN_SUB,


  BFD_ARELOC_BFIN_MULT,


  BFD_ARELOC_BFIN_DIV,


  BFD_ARELOC_BFIN_MOD,


  BFD_ARELOC_BFIN_LSHIFT,


  BFD_ARELOC_BFIN_RSHIFT,


  BFD_ARELOC_BFIN_AND,


  BFD_ARELOC_BFIN_OR,


  BFD_ARELOC_BFIN_XOR,


  BFD_ARELOC_BFIN_LAND,


  BFD_ARELOC_BFIN_LOR,


  BFD_ARELOC_BFIN_LEN,


  BFD_ARELOC_BFIN_NEG,


  BFD_ARELOC_BFIN_COMP,


  BFD_ARELOC_BFIN_PAGE,


  BFD_ARELOC_BFIN_HWPAGE,


  BFD_ARELOC_BFIN_ADDR,




  BFD_RELOC_D10V_10_PCREL_R,






  BFD_RELOC_D10V_10_PCREL_L,



  BFD_RELOC_D10V_18,



  BFD_RELOC_D10V_18_PCREL,



  BFD_RELOC_D30V_6,



  BFD_RELOC_D30V_9_PCREL,





  BFD_RELOC_D30V_9_PCREL_R,



  BFD_RELOC_D30V_15,



  BFD_RELOC_D30V_15_PCREL,





  BFD_RELOC_D30V_15_PCREL_R,



  BFD_RELOC_D30V_21,



  BFD_RELOC_D30V_21_PCREL,





  BFD_RELOC_D30V_21_PCREL_R,


  BFD_RELOC_D30V_32,


  BFD_RELOC_D30V_32_PCREL,


  BFD_RELOC_DLX_HI16_S,


  BFD_RELOC_DLX_LO16,


  BFD_RELOC_DLX_JMP26,


  BFD_RELOC_M32C_HI8,
  BFD_RELOC_M32C_RL_JUMP,
  BFD_RELOC_M32C_RL_1ADDR,
  BFD_RELOC_M32C_RL_2ADDR,



  BFD_RELOC_M32R_24,


  BFD_RELOC_M32R_10_PCREL,


  BFD_RELOC_M32R_18_PCREL,


  BFD_RELOC_M32R_26_PCREL,



  BFD_RELOC_M32R_HI16_ULO,



  BFD_RELOC_M32R_HI16_SLO,


  BFD_RELOC_M32R_LO16,



  BFD_RELOC_M32R_SDA16,


  BFD_RELOC_M32R_GOT24,
  BFD_RELOC_M32R_26_PLTREL,
  BFD_RELOC_M32R_COPY,
  BFD_RELOC_M32R_GLOB_DAT,
  BFD_RELOC_M32R_JMP_SLOT,
  BFD_RELOC_M32R_RELATIVE,
  BFD_RELOC_M32R_GOTOFF,
  BFD_RELOC_M32R_GOTOFF_HI_ULO,
  BFD_RELOC_M32R_GOTOFF_HI_SLO,
  BFD_RELOC_M32R_GOTOFF_LO,
  BFD_RELOC_M32R_GOTPC24,
  BFD_RELOC_M32R_GOT16_HI_ULO,
  BFD_RELOC_M32R_GOT16_HI_SLO,
  BFD_RELOC_M32R_GOT16_LO,
  BFD_RELOC_M32R_GOTPC_HI_ULO,
  BFD_RELOC_M32R_GOTPC_HI_SLO,
  BFD_RELOC_M32R_GOTPC_LO,



  BFD_RELOC_NDS32_20,


  BFD_RELOC_NDS32_9_PCREL,


  BFD_RELOC_NDS32_WORD_9_PCREL,


  BFD_RELOC_NDS32_15_PCREL,


  BFD_RELOC_NDS32_17_PCREL,


  BFD_RELOC_NDS32_25_PCREL,



  BFD_RELOC_NDS32_HI20,



  BFD_RELOC_NDS32_LO12S3,



  BFD_RELOC_NDS32_LO12S2,



  BFD_RELOC_NDS32_LO12S1,



  BFD_RELOC_NDS32_LO12S0,



  BFD_RELOC_NDS32_LO12S0_ORI,



  BFD_RELOC_NDS32_SDA15S3,



  BFD_RELOC_NDS32_SDA15S2,



  BFD_RELOC_NDS32_SDA15S1,



  BFD_RELOC_NDS32_SDA15S0,



  BFD_RELOC_NDS32_SDA16S3,



  BFD_RELOC_NDS32_SDA17S2,



  BFD_RELOC_NDS32_SDA18S1,



  BFD_RELOC_NDS32_SDA19S0,


  BFD_RELOC_NDS32_GOT20,
  BFD_RELOC_NDS32_9_PLTREL,
  BFD_RELOC_NDS32_25_PLTREL,
  BFD_RELOC_NDS32_COPY,
  BFD_RELOC_NDS32_GLOB_DAT,
  BFD_RELOC_NDS32_JMP_SLOT,
  BFD_RELOC_NDS32_RELATIVE,
  BFD_RELOC_NDS32_GOTOFF,
  BFD_RELOC_NDS32_GOTOFF_HI20,
  BFD_RELOC_NDS32_GOTOFF_LO12,
  BFD_RELOC_NDS32_GOTPC20,
  BFD_RELOC_NDS32_GOT_HI20,
  BFD_RELOC_NDS32_GOT_LO12,
  BFD_RELOC_NDS32_GOTPC_HI20,
  BFD_RELOC_NDS32_GOTPC_LO12,


  BFD_RELOC_NDS32_INSN16,
  BFD_RELOC_NDS32_LABEL,
  BFD_RELOC_NDS32_LONGCALL1,
  BFD_RELOC_NDS32_LONGCALL2,
  BFD_RELOC_NDS32_LONGCALL3,
  BFD_RELOC_NDS32_LONGJUMP1,
  BFD_RELOC_NDS32_LONGJUMP2,
  BFD_RELOC_NDS32_LONGJUMP3,
  BFD_RELOC_NDS32_LOADSTORE,
  BFD_RELOC_NDS32_9_FIXED,
  BFD_RELOC_NDS32_15_FIXED,
  BFD_RELOC_NDS32_17_FIXED,
  BFD_RELOC_NDS32_25_FIXED,
  BFD_RELOC_NDS32_LONGCALL4,
  BFD_RELOC_NDS32_LONGCALL5,
  BFD_RELOC_NDS32_LONGCALL6,
  BFD_RELOC_NDS32_LONGJUMP4,
  BFD_RELOC_NDS32_LONGJUMP5,
  BFD_RELOC_NDS32_LONGJUMP6,
  BFD_RELOC_NDS32_LONGJUMP7,


  BFD_RELOC_NDS32_PLTREL_HI20,
  BFD_RELOC_NDS32_PLTREL_LO12,
  BFD_RELOC_NDS32_PLT_GOTREL_HI20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO12,


  BFD_RELOC_NDS32_SDA12S2_DP,
  BFD_RELOC_NDS32_SDA12S2_SP,
  BFD_RELOC_NDS32_LO12S2_DP,
  BFD_RELOC_NDS32_LO12S2_SP,


  BFD_RELOC_NDS32_DWARF2_OP1,
  BFD_RELOC_NDS32_DWARF2_OP2,
  BFD_RELOC_NDS32_DWARF2_LEB,


  BFD_RELOC_NDS32_UPDATE_TA,


  BFD_RELOC_NDS32_PLT_GOTREL_LO20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO15,
  BFD_RELOC_NDS32_PLT_GOTREL_LO19,
  BFD_RELOC_NDS32_GOT_LO15,
  BFD_RELOC_NDS32_GOT_LO19,
  BFD_RELOC_NDS32_GOTOFF_LO15,
  BFD_RELOC_NDS32_GOTOFF_LO19,
  BFD_RELOC_NDS32_GOT15S2,
  BFD_RELOC_NDS32_GOT17S2,



  BFD_RELOC_NDS32_5,


  BFD_RELOC_NDS32_10_UPCREL,


  BFD_RELOC_NDS32_SDA_FP7U2_RELA,


  BFD_RELOC_NDS32_RELAX_ENTRY,
  BFD_RELOC_NDS32_GOT_SUFF,
  BFD_RELOC_NDS32_GOTOFF_SUFF,
  BFD_RELOC_NDS32_PLT_GOT_SUFF,
  BFD_RELOC_NDS32_MULCALL_SUFF,
  BFD_RELOC_NDS32_PTR,
  BFD_RELOC_NDS32_PTR_COUNT,
  BFD_RELOC_NDS32_PTR_RESOLVED,
  BFD_RELOC_NDS32_PLTBLOCK,
  BFD_RELOC_NDS32_RELAX_REGION_BEGIN,
  BFD_RELOC_NDS32_RELAX_REGION_END,
  BFD_RELOC_NDS32_MINUEND,
  BFD_RELOC_NDS32_SUBTRAHEND,
  BFD_RELOC_NDS32_DIFF8,
  BFD_RELOC_NDS32_DIFF16,
  BFD_RELOC_NDS32_DIFF32,
  BFD_RELOC_NDS32_DIFF_ULEB128,
  BFD_RELOC_NDS32_EMPTY,


  BFD_RELOC_NDS32_25_ABS,


  BFD_RELOC_NDS32_DATA,
  BFD_RELOC_NDS32_TRAN,
  BFD_RELOC_NDS32_17IFC_PCREL,
  BFD_RELOC_NDS32_10IFCU_PCREL,


  BFD_RELOC_NDS32_TPOFF,
  BFD_RELOC_NDS32_GOTTPOFF,
  BFD_RELOC_NDS32_TLS_LE_HI20,
  BFD_RELOC_NDS32_TLS_LE_LO12,
  BFD_RELOC_NDS32_TLS_LE_20,
  BFD_RELOC_NDS32_TLS_LE_15S0,
  BFD_RELOC_NDS32_TLS_LE_15S1,
  BFD_RELOC_NDS32_TLS_LE_15S2,
  BFD_RELOC_NDS32_TLS_LE_ADD,
  BFD_RELOC_NDS32_TLS_LE_LS,
  BFD_RELOC_NDS32_TLS_IE_HI20,
  BFD_RELOC_NDS32_TLS_IE_LO12,
  BFD_RELOC_NDS32_TLS_IE_LO12S2,
  BFD_RELOC_NDS32_TLS_IEGP_HI20,
  BFD_RELOC_NDS32_TLS_IEGP_LO12,
  BFD_RELOC_NDS32_TLS_IEGP_LO12S2,
  BFD_RELOC_NDS32_TLS_IEGP_LW,
  BFD_RELOC_NDS32_TLS_DESC,
  BFD_RELOC_NDS32_TLS_DESC_HI20,
  BFD_RELOC_NDS32_TLS_DESC_LO12,
  BFD_RELOC_NDS32_TLS_DESC_20,
  BFD_RELOC_NDS32_TLS_DESC_SDA17S2,
  BFD_RELOC_NDS32_TLS_DESC_ADD,
  BFD_RELOC_NDS32_TLS_DESC_FUNC,
  BFD_RELOC_NDS32_TLS_DESC_CALL,
  BFD_RELOC_NDS32_TLS_DESC_MEM,
  BFD_RELOC_NDS32_REMOVE,
  BFD_RELOC_NDS32_GROUP,


  BFD_RELOC_NDS32_LSI,


  BFD_RELOC_V850_9_PCREL,


  BFD_RELOC_V850_22_PCREL,


  BFD_RELOC_V850_SDA_16_16_OFFSET,



  BFD_RELOC_V850_SDA_15_16_OFFSET,


  BFD_RELOC_V850_ZDA_16_16_OFFSET,



  BFD_RELOC_V850_ZDA_15_16_OFFSET,



  BFD_RELOC_V850_TDA_6_8_OFFSET,



  BFD_RELOC_V850_TDA_7_8_OFFSET,


  BFD_RELOC_V850_TDA_7_7_OFFSET,


  BFD_RELOC_V850_TDA_16_16_OFFSET,



  BFD_RELOC_V850_TDA_4_5_OFFSET,


  BFD_RELOC_V850_TDA_4_4_OFFSET,



  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,



  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,


  BFD_RELOC_V850_CALLT_6_7_OFFSET,


  BFD_RELOC_V850_CALLT_16_16_OFFSET,


  BFD_RELOC_V850_LONGCALL,


  BFD_RELOC_V850_LONGJUMP,


  BFD_RELOC_V850_ALIGN,



  BFD_RELOC_V850_LO16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_PCREL,


  BFD_RELOC_V850_17_PCREL,


  BFD_RELOC_V850_23,


  BFD_RELOC_V850_32_PCREL,


  BFD_RELOC_V850_32_ABS,


  BFD_RELOC_V850_16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_S1,


  BFD_RELOC_V850_LO16_S1,


  BFD_RELOC_V850_CALLT_15_16_OFFSET,


  BFD_RELOC_V850_32_GOTPCREL,


  BFD_RELOC_V850_16_GOT,


  BFD_RELOC_V850_32_GOT,


  BFD_RELOC_V850_22_PLT_PCREL,


  BFD_RELOC_V850_32_PLT_PCREL,


  BFD_RELOC_V850_COPY,


  BFD_RELOC_V850_GLOB_DAT,


  BFD_RELOC_V850_JMP_SLOT,


  BFD_RELOC_V850_RELATIVE,


  BFD_RELOC_V850_16_GOTOFF,


  BFD_RELOC_V850_32_GOTOFF,


  BFD_RELOC_V850_CODE,


  BFD_RELOC_V850_DATA,




  BFD_RELOC_TIC30_LDP,




  BFD_RELOC_TIC54X_PARTLS7,




  BFD_RELOC_TIC54X_PARTMS9,


  BFD_RELOC_TIC54X_23,




  BFD_RELOC_TIC54X_16_OF_23,




  BFD_RELOC_TIC54X_MS7_OF_23,


  BFD_RELOC_C6000_PCR_S21,
  BFD_RELOC_C6000_PCR_S12,
  BFD_RELOC_C6000_PCR_S10,
  BFD_RELOC_C6000_PCR_S7,
  BFD_RELOC_C6000_ABS_S16,
  BFD_RELOC_C6000_ABS_L16,
  BFD_RELOC_C6000_ABS_H16,
  BFD_RELOC_C6000_SBR_U15_B,
  BFD_RELOC_C6000_SBR_U15_H,
  BFD_RELOC_C6000_SBR_U15_W,
  BFD_RELOC_C6000_SBR_S16,
  BFD_RELOC_C6000_SBR_L16_B,
  BFD_RELOC_C6000_SBR_L16_H,
  BFD_RELOC_C6000_SBR_L16_W,
  BFD_RELOC_C6000_SBR_H16_B,
  BFD_RELOC_C6000_SBR_H16_H,
  BFD_RELOC_C6000_SBR_H16_W,
  BFD_RELOC_C6000_SBR_GOT_U15_W,
  BFD_RELOC_C6000_SBR_GOT_L16_W,
  BFD_RELOC_C6000_SBR_GOT_H16_W,
  BFD_RELOC_C6000_DSBT_INDEX,
  BFD_RELOC_C6000_PREL31,
  BFD_RELOC_C6000_COPY,
  BFD_RELOC_C6000_JUMP_SLOT,
  BFD_RELOC_C6000_EHTYPE,
  BFD_RELOC_C6000_PCR_H16,
  BFD_RELOC_C6000_PCR_L16,
  BFD_RELOC_C6000_ALIGN,
  BFD_RELOC_C6000_FPHEAD,
  BFD_RELOC_C6000_NOCMP,


  BFD_RELOC_FR30_48,



  BFD_RELOC_FR30_20,



  BFD_RELOC_FR30_6_IN_4,



  BFD_RELOC_FR30_8_IN_8,



  BFD_RELOC_FR30_9_IN_8,



  BFD_RELOC_FR30_10_IN_8,



  BFD_RELOC_FR30_9_PCREL,



  BFD_RELOC_FR30_12_PCREL,


  BFD_RELOC_MCORE_PCREL_IMM8BY4,
  BFD_RELOC_MCORE_PCREL_IMM11BY2,
  BFD_RELOC_MCORE_PCREL_IMM4BY2,
  BFD_RELOC_MCORE_PCREL_32,
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_MCORE_RVA,


  BFD_RELOC_MEP_8,
  BFD_RELOC_MEP_16,
  BFD_RELOC_MEP_32,
  BFD_RELOC_MEP_PCREL8A2,
  BFD_RELOC_MEP_PCREL12A2,
  BFD_RELOC_MEP_PCREL17A2,
  BFD_RELOC_MEP_PCREL24A2,
  BFD_RELOC_MEP_PCABS24A2,
  BFD_RELOC_MEP_LOW16,
  BFD_RELOC_MEP_HI16U,
  BFD_RELOC_MEP_HI16S,
  BFD_RELOC_MEP_GPREL,
  BFD_RELOC_MEP_TPREL,
  BFD_RELOC_MEP_TPREL7,
  BFD_RELOC_MEP_TPREL7A2,
  BFD_RELOC_MEP_TPREL7A4,
  BFD_RELOC_MEP_UIMM24,
  BFD_RELOC_MEP_ADDR24A4,
  BFD_RELOC_MEP_GNU_VTINHERIT,
  BFD_RELOC_MEP_GNU_VTENTRY,



  BFD_RELOC_METAG_HIADDR16,
  BFD_RELOC_METAG_LOADDR16,
  BFD_RELOC_METAG_RELBRANCH,
  BFD_RELOC_METAG_GETSETOFF,
  BFD_RELOC_METAG_HIOG,
  BFD_RELOC_METAG_LOOG,
  BFD_RELOC_METAG_REL8,
  BFD_RELOC_METAG_REL16,
  BFD_RELOC_METAG_HI16_GOTOFF,
  BFD_RELOC_METAG_LO16_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOT,
  BFD_RELOC_METAG_HI16_GOTPC,
  BFD_RELOC_METAG_LO16_GOTPC,
  BFD_RELOC_METAG_HI16_PLT,
  BFD_RELOC_METAG_LO16_PLT,
  BFD_RELOC_METAG_RELBRANCH_PLT,
  BFD_RELOC_METAG_GOTOFF,
  BFD_RELOC_METAG_PLT,
  BFD_RELOC_METAG_COPY,
  BFD_RELOC_METAG_JMP_SLOT,
  BFD_RELOC_METAG_RELATIVE,
  BFD_RELOC_METAG_GLOB_DAT,
  BFD_RELOC_METAG_TLS_GD,
  BFD_RELOC_METAG_TLS_LDM,
  BFD_RELOC_METAG_TLS_LDO_HI16,
  BFD_RELOC_METAG_TLS_LDO_LO16,
  BFD_RELOC_METAG_TLS_LDO,
  BFD_RELOC_METAG_TLS_IE,
  BFD_RELOC_METAG_TLS_IENONPIC,
  BFD_RELOC_METAG_TLS_IENONPIC_HI16,
  BFD_RELOC_METAG_TLS_IENONPIC_LO16,
  BFD_RELOC_METAG_TLS_TPOFF,
  BFD_RELOC_METAG_TLS_DTPMOD,
  BFD_RELOC_METAG_TLS_DTPOFF,
  BFD_RELOC_METAG_TLS_LE,
  BFD_RELOC_METAG_TLS_LE_HI16,
  BFD_RELOC_METAG_TLS_LE_LO16,


  BFD_RELOC_MMIX_GETA,
  BFD_RELOC_MMIX_GETA_1,
  BFD_RELOC_MMIX_GETA_2,
  BFD_RELOC_MMIX_GETA_3,


  BFD_RELOC_MMIX_CBRANCH,
  BFD_RELOC_MMIX_CBRANCH_J,
  BFD_RELOC_MMIX_CBRANCH_1,
  BFD_RELOC_MMIX_CBRANCH_2,
  BFD_RELOC_MMIX_CBRANCH_3,


  BFD_RELOC_MMIX_PUSHJ,
  BFD_RELOC_MMIX_PUSHJ_1,
  BFD_RELOC_MMIX_PUSHJ_2,
  BFD_RELOC_MMIX_PUSHJ_3,
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,


  BFD_RELOC_MMIX_JMP,
  BFD_RELOC_MMIX_JMP_1,
  BFD_RELOC_MMIX_JMP_2,
  BFD_RELOC_MMIX_JMP_3,



  BFD_RELOC_MMIX_ADDR19,


  BFD_RELOC_MMIX_ADDR27,



  BFD_RELOC_MMIX_REG_OR_BYTE,



  BFD_RELOC_MMIX_REG,



  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,



  BFD_RELOC_MMIX_LOCAL,



  BFD_RELOC_AVR_7_PCREL,



  BFD_RELOC_AVR_13_PCREL,



  BFD_RELOC_AVR_16_PM,



  BFD_RELOC_AVR_LO8_LDI,



  BFD_RELOC_AVR_HI8_LDI,



  BFD_RELOC_AVR_HH8_LDI,



  BFD_RELOC_AVR_MS8_LDI,



  BFD_RELOC_AVR_LO8_LDI_NEG,




  BFD_RELOC_AVR_HI8_LDI_NEG,




  BFD_RELOC_AVR_HH8_LDI_NEG,



  BFD_RELOC_AVR_MS8_LDI_NEG,



  BFD_RELOC_AVR_LO8_LDI_PM,





  BFD_RELOC_AVR_LO8_LDI_GS,



  BFD_RELOC_AVR_HI8_LDI_PM,





  BFD_RELOC_AVR_HI8_LDI_GS,



  BFD_RELOC_AVR_HH8_LDI_PM,



  BFD_RELOC_AVR_LO8_LDI_PM_NEG,




  BFD_RELOC_AVR_HI8_LDI_PM_NEG,




  BFD_RELOC_AVR_HH8_LDI_PM_NEG,



  BFD_RELOC_AVR_CALL,



  BFD_RELOC_AVR_LDI,



  BFD_RELOC_AVR_6,



  BFD_RELOC_AVR_6_ADIW,



  BFD_RELOC_AVR_8_LO,



  BFD_RELOC_AVR_8_HI,



  BFD_RELOC_AVR_8_HLO,







  BFD_RELOC_AVR_DIFF8,
  BFD_RELOC_AVR_DIFF16,
  BFD_RELOC_AVR_DIFF32,



  BFD_RELOC_AVR_LDS_STS_16,



  BFD_RELOC_AVR_PORT6,



  BFD_RELOC_AVR_PORT5,


  BFD_RELOC_RISCV_HI20,
  BFD_RELOC_RISCV_PCREL_HI20,
  BFD_RELOC_RISCV_PCREL_LO12_I,
  BFD_RELOC_RISCV_PCREL_LO12_S,
  BFD_RELOC_RISCV_LO12_I,
  BFD_RELOC_RISCV_LO12_S,
  BFD_RELOC_RISCV_GPREL12_I,
  BFD_RELOC_RISCV_GPREL12_S,
  BFD_RELOC_RISCV_TPREL_HI20,
  BFD_RELOC_RISCV_TPREL_LO12_I,
  BFD_RELOC_RISCV_TPREL_LO12_S,
  BFD_RELOC_RISCV_TPREL_ADD,
  BFD_RELOC_RISCV_CALL,
  BFD_RELOC_RISCV_CALL_PLT,
  BFD_RELOC_RISCV_ADD8,
  BFD_RELOC_RISCV_ADD16,
  BFD_RELOC_RISCV_ADD32,
  BFD_RELOC_RISCV_ADD64,
  BFD_RELOC_RISCV_SUB8,
  BFD_RELOC_RISCV_SUB16,
  BFD_RELOC_RISCV_SUB32,
  BFD_RELOC_RISCV_SUB64,
  BFD_RELOC_RISCV_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GD_HI20,
  BFD_RELOC_RISCV_JMP,
  BFD_RELOC_RISCV_TLS_DTPMOD32,
  BFD_RELOC_RISCV_TLS_DTPREL32,
  BFD_RELOC_RISCV_TLS_DTPMOD64,
  BFD_RELOC_RISCV_TLS_DTPREL64,
  BFD_RELOC_RISCV_TLS_TPREL32,
  BFD_RELOC_RISCV_TLS_TPREL64,
  BFD_RELOC_RISCV_ALIGN,
  BFD_RELOC_RISCV_RVC_BRANCH,
  BFD_RELOC_RISCV_RVC_JUMP,
  BFD_RELOC_RISCV_RVC_LUI,
  BFD_RELOC_RISCV_GPREL_I,
  BFD_RELOC_RISCV_GPREL_S,
  BFD_RELOC_RISCV_TPREL_I,
  BFD_RELOC_RISCV_TPREL_S,
  BFD_RELOC_RISCV_RELAX,
  BFD_RELOC_RISCV_CFA,
  BFD_RELOC_RISCV_SUB6,
  BFD_RELOC_RISCV_SET6,
  BFD_RELOC_RISCV_SET8,
  BFD_RELOC_RISCV_SET16,
  BFD_RELOC_RISCV_SET32,
  BFD_RELOC_RISCV_32_PCREL,
  BFD_RELOC_RISCV_SET_ULEB128,
  BFD_RELOC_RISCV_SUB_ULEB128,


  BFD_RELOC_RL78_NEG8,
  BFD_RELOC_RL78_NEG16,
  BFD_RELOC_RL78_NEG24,
  BFD_RELOC_RL78_NEG32,
  BFD_RELOC_RL78_16_OP,
  BFD_RELOC_RL78_24_OP,
  BFD_RELOC_RL78_32_OP,
  BFD_RELOC_RL78_8U,
  BFD_RELOC_RL78_16U,
  BFD_RELOC_RL78_24U,
  BFD_RELOC_RL78_DIR3U_PCREL,
  BFD_RELOC_RL78_DIFF,
  BFD_RELOC_RL78_GPRELB,
  BFD_RELOC_RL78_GPRELW,
  BFD_RELOC_RL78_GPRELL,
  BFD_RELOC_RL78_SYM,
  BFD_RELOC_RL78_OP_SUBTRACT,
  BFD_RELOC_RL78_OP_NEG,
  BFD_RELOC_RL78_OP_AND,
  BFD_RELOC_RL78_OP_SHRA,
  BFD_RELOC_RL78_ABS8,
  BFD_RELOC_RL78_ABS16,
  BFD_RELOC_RL78_ABS16_REV,
  BFD_RELOC_RL78_ABS32,
  BFD_RELOC_RL78_ABS32_REV,
  BFD_RELOC_RL78_ABS16U,
  BFD_RELOC_RL78_ABS16UW,
  BFD_RELOC_RL78_ABS16UL,
  BFD_RELOC_RL78_RELAX,
  BFD_RELOC_RL78_HI16,
  BFD_RELOC_RL78_HI8,
  BFD_RELOC_RL78_LO16,
  BFD_RELOC_RL78_CODE,
  BFD_RELOC_RL78_SADDR,


  BFD_RELOC_RX_NEG8,
  BFD_RELOC_RX_NEG16,
  BFD_RELOC_RX_NEG24,
  BFD_RELOC_RX_NEG32,
  BFD_RELOC_RX_16_OP,
  BFD_RELOC_RX_24_OP,
  BFD_RELOC_RX_32_OP,
  BFD_RELOC_RX_8U,
  BFD_RELOC_RX_16U,
  BFD_RELOC_RX_24U,
  BFD_RELOC_RX_DIR3U_PCREL,
  BFD_RELOC_RX_DIFF,
  BFD_RELOC_RX_GPRELB,
  BFD_RELOC_RX_GPRELW,
  BFD_RELOC_RX_GPRELL,
  BFD_RELOC_RX_SYM,
  BFD_RELOC_RX_OP_SUBTRACT,
  BFD_RELOC_RX_OP_NEG,
  BFD_RELOC_RX_ABS8,
  BFD_RELOC_RX_ABS16,
  BFD_RELOC_RX_ABS16_REV,
  BFD_RELOC_RX_ABS32,
  BFD_RELOC_RX_ABS32_REV,
  BFD_RELOC_RX_ABS16U,
  BFD_RELOC_RX_ABS16UW,
  BFD_RELOC_RX_ABS16UL,
  BFD_RELOC_RX_RELAX,


  BFD_RELOC_390_12,


  BFD_RELOC_390_GOT12,


  BFD_RELOC_390_PLT32,


  BFD_RELOC_390_COPY,


  BFD_RELOC_390_GLOB_DAT,


  BFD_RELOC_390_JMP_SLOT,


  BFD_RELOC_390_RELATIVE,


  BFD_RELOC_390_GOTPC,


  BFD_RELOC_390_GOT16,


  BFD_RELOC_390_PC12DBL,


  BFD_RELOC_390_PLT12DBL,


  BFD_RELOC_390_PC16DBL,


  BFD_RELOC_390_PLT16DBL,


  BFD_RELOC_390_PC24DBL,


  BFD_RELOC_390_PLT24DBL,


  BFD_RELOC_390_PC32DBL,


  BFD_RELOC_390_PLT32DBL,


  BFD_RELOC_390_GOTPCDBL,


  BFD_RELOC_390_GOT64,


  BFD_RELOC_390_PLT64,


  BFD_RELOC_390_GOTENT,


  BFD_RELOC_390_GOTOFF64,


  BFD_RELOC_390_GOTPLT12,


  BFD_RELOC_390_GOTPLT16,


  BFD_RELOC_390_GOTPLT32,


  BFD_RELOC_390_GOTPLT64,


  BFD_RELOC_390_GOTPLTENT,


  BFD_RELOC_390_PLTOFF16,


  BFD_RELOC_390_PLTOFF32,


  BFD_RELOC_390_PLTOFF64,


  BFD_RELOC_390_TLS_LOAD,
  BFD_RELOC_390_TLS_GDCALL,
  BFD_RELOC_390_TLS_LDCALL,
  BFD_RELOC_390_TLS_GD32,
  BFD_RELOC_390_TLS_GD64,
  BFD_RELOC_390_TLS_GOTIE12,
  BFD_RELOC_390_TLS_GOTIE32,
  BFD_RELOC_390_TLS_GOTIE64,
  BFD_RELOC_390_TLS_LDM32,
  BFD_RELOC_390_TLS_LDM64,
  BFD_RELOC_390_TLS_IE32,
  BFD_RELOC_390_TLS_IE64,
  BFD_RELOC_390_TLS_IEENT,
  BFD_RELOC_390_TLS_LE32,
  BFD_RELOC_390_TLS_LE64,
  BFD_RELOC_390_TLS_LDO32,
  BFD_RELOC_390_TLS_LDO64,
  BFD_RELOC_390_TLS_DTPMOD,
  BFD_RELOC_390_TLS_DTPOFF,
  BFD_RELOC_390_TLS_TPOFF,


  BFD_RELOC_390_20,
  BFD_RELOC_390_GOT20,
  BFD_RELOC_390_GOTPLT20,
  BFD_RELOC_390_TLS_GOTIE20,


  BFD_RELOC_390_IRELATIVE,



  BFD_RELOC_SCORE_GPREL15,


  BFD_RELOC_SCORE_DUMMY2,
  BFD_RELOC_SCORE_JMP,


  BFD_RELOC_SCORE_BRANCH,


  BFD_RELOC_SCORE_IMM30,


  BFD_RELOC_SCORE_IMM32,


  BFD_RELOC_SCORE16_JMP,


  BFD_RELOC_SCORE16_BRANCH,


  BFD_RELOC_SCORE_BCMP,


  BFD_RELOC_SCORE_GOT15,
  BFD_RELOC_SCORE_GOT_LO16,
  BFD_RELOC_SCORE_CALL15,
  BFD_RELOC_SCORE_DUMMY_HI16,


  BFD_RELOC_IP2K_FR9,


  BFD_RELOC_IP2K_BANK,


  BFD_RELOC_IP2K_ADDR16CJP,


  BFD_RELOC_IP2K_PAGE3,


  BFD_RELOC_IP2K_LO8DATA,
  BFD_RELOC_IP2K_HI8DATA,
  BFD_RELOC_IP2K_EX8DATA,


  BFD_RELOC_IP2K_LO8INSN,
  BFD_RELOC_IP2K_HI8INSN,


  BFD_RELOC_IP2K_PC_SKIP,


  BFD_RELOC_IP2K_TEXT,


  BFD_RELOC_IP2K_FR_OFFSET,


  BFD_RELOC_VPE4KMATH_DATA,
  BFD_RELOC_VPE4KMATH_INSN,
# 5677 "../bfd/bfd.h"
  BFD_RELOC_VTABLE_INHERIT,
  BFD_RELOC_VTABLE_ENTRY,


  BFD_RELOC_IA64_IMM14,
  BFD_RELOC_IA64_IMM22,
  BFD_RELOC_IA64_IMM64,
  BFD_RELOC_IA64_DIR32MSB,
  BFD_RELOC_IA64_DIR32LSB,
  BFD_RELOC_IA64_DIR64MSB,
  BFD_RELOC_IA64_DIR64LSB,
  BFD_RELOC_IA64_GPREL22,
  BFD_RELOC_IA64_GPREL64I,
  BFD_RELOC_IA64_GPREL32MSB,
  BFD_RELOC_IA64_GPREL32LSB,
  BFD_RELOC_IA64_GPREL64MSB,
  BFD_RELOC_IA64_GPREL64LSB,
  BFD_RELOC_IA64_LTOFF22,
  BFD_RELOC_IA64_LTOFF64I,
  BFD_RELOC_IA64_PLTOFF22,
  BFD_RELOC_IA64_PLTOFF64I,
  BFD_RELOC_IA64_PLTOFF64MSB,
  BFD_RELOC_IA64_PLTOFF64LSB,
  BFD_RELOC_IA64_FPTR64I,
  BFD_RELOC_IA64_FPTR32MSB,
  BFD_RELOC_IA64_FPTR32LSB,
  BFD_RELOC_IA64_FPTR64MSB,
  BFD_RELOC_IA64_FPTR64LSB,
  BFD_RELOC_IA64_PCREL21B,
  BFD_RELOC_IA64_PCREL21BI,
  BFD_RELOC_IA64_PCREL21M,
  BFD_RELOC_IA64_PCREL21F,
  BFD_RELOC_IA64_PCREL22,
  BFD_RELOC_IA64_PCREL60B,
  BFD_RELOC_IA64_PCREL64I,
  BFD_RELOC_IA64_PCREL32MSB,
  BFD_RELOC_IA64_PCREL32LSB,
  BFD_RELOC_IA64_PCREL64MSB,
  BFD_RELOC_IA64_PCREL64LSB,
  BFD_RELOC_IA64_LTOFF_FPTR22,
  BFD_RELOC_IA64_LTOFF_FPTR64I,
  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
  BFD_RELOC_IA64_SEGREL32MSB,
  BFD_RELOC_IA64_SEGREL32LSB,
  BFD_RELOC_IA64_SEGREL64MSB,
  BFD_RELOC_IA64_SEGREL64LSB,
  BFD_RELOC_IA64_SECREL32MSB,
  BFD_RELOC_IA64_SECREL32LSB,
  BFD_RELOC_IA64_SECREL64MSB,
  BFD_RELOC_IA64_SECREL64LSB,
  BFD_RELOC_IA64_REL32MSB,
  BFD_RELOC_IA64_REL32LSB,
  BFD_RELOC_IA64_REL64MSB,
  BFD_RELOC_IA64_REL64LSB,
  BFD_RELOC_IA64_LTV32MSB,
  BFD_RELOC_IA64_LTV32LSB,
  BFD_RELOC_IA64_LTV64MSB,
  BFD_RELOC_IA64_LTV64LSB,
  BFD_RELOC_IA64_IPLTMSB,
  BFD_RELOC_IA64_IPLTLSB,
  BFD_RELOC_IA64_COPY,
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,
  BFD_RELOC_IA64_TPREL14,
  BFD_RELOC_IA64_TPREL22,
  BFD_RELOC_IA64_TPREL64I,
  BFD_RELOC_IA64_TPREL64MSB,
  BFD_RELOC_IA64_TPREL64LSB,
  BFD_RELOC_IA64_LTOFF_TPREL22,
  BFD_RELOC_IA64_DTPMOD64MSB,
  BFD_RELOC_IA64_DTPMOD64LSB,
  BFD_RELOC_IA64_LTOFF_DTPMOD22,
  BFD_RELOC_IA64_DTPREL14,
  BFD_RELOC_IA64_DTPREL22,
  BFD_RELOC_IA64_DTPREL64I,
  BFD_RELOC_IA64_DTPREL32MSB,
  BFD_RELOC_IA64_DTPREL32LSB,
  BFD_RELOC_IA64_DTPREL64MSB,
  BFD_RELOC_IA64_DTPREL64LSB,
  BFD_RELOC_IA64_LTOFF_DTPREL22,



  BFD_RELOC_M68HC11_HI8,



  BFD_RELOC_M68HC11_LO8,



  BFD_RELOC_M68HC11_3B,






  BFD_RELOC_M68HC11_RL_JUMP,





  BFD_RELOC_M68HC11_RL_GROUP,





  BFD_RELOC_M68HC11_LO16,





  BFD_RELOC_M68HC11_PAGE,





  BFD_RELOC_M68HC11_24,



  BFD_RELOC_M68HC12_5B,



  BFD_RELOC_XGATE_RL_JUMP,





  BFD_RELOC_XGATE_RL_GROUP,




  BFD_RELOC_XGATE_LO16,


  BFD_RELOC_XGATE_GPAGE,


  BFD_RELOC_XGATE_24,



  BFD_RELOC_XGATE_PCREL_9,



  BFD_RELOC_XGATE_PCREL_10,




  BFD_RELOC_XGATE_IMM8_LO,




  BFD_RELOC_XGATE_IMM8_HI,



  BFD_RELOC_XGATE_IMM3,



  BFD_RELOC_XGATE_IMM4,



  BFD_RELOC_XGATE_IMM5,



  BFD_RELOC_M68HC12_9B,



  BFD_RELOC_M68HC12_16B,



  BFD_RELOC_M68HC12_9_PCREL,



  BFD_RELOC_M68HC12_10_PCREL,




  BFD_RELOC_M68HC12_LO8XG,




  BFD_RELOC_M68HC12_HI8XG,




  BFD_RELOC_S12Z_15_PCREL,


  BFD_RELOC_CR16_NUM8,
  BFD_RELOC_CR16_NUM16,
  BFD_RELOC_CR16_NUM32,
  BFD_RELOC_CR16_NUM32a,
  BFD_RELOC_CR16_REGREL0,
  BFD_RELOC_CR16_REGREL4,
  BFD_RELOC_CR16_REGREL4a,
  BFD_RELOC_CR16_REGREL14,
  BFD_RELOC_CR16_REGREL14a,
  BFD_RELOC_CR16_REGREL16,
  BFD_RELOC_CR16_REGREL20,
  BFD_RELOC_CR16_REGREL20a,
  BFD_RELOC_CR16_ABS20,
  BFD_RELOC_CR16_ABS24,
  BFD_RELOC_CR16_IMM4,
  BFD_RELOC_CR16_IMM8,
  BFD_RELOC_CR16_IMM16,
  BFD_RELOC_CR16_IMM20,
  BFD_RELOC_CR16_IMM24,
  BFD_RELOC_CR16_IMM32,
  BFD_RELOC_CR16_IMM32a,
  BFD_RELOC_CR16_DISP4,
  BFD_RELOC_CR16_DISP8,
  BFD_RELOC_CR16_DISP16,
  BFD_RELOC_CR16_DISP20,
  BFD_RELOC_CR16_DISP24,
  BFD_RELOC_CR16_DISP24a,
  BFD_RELOC_CR16_SWITCH8,
  BFD_RELOC_CR16_SWITCH16,
  BFD_RELOC_CR16_SWITCH32,
  BFD_RELOC_CR16_GOT_REGREL20,
  BFD_RELOC_CR16_GOTC_REGREL20,
  BFD_RELOC_CR16_GLOB_DAT,


  BFD_RELOC_CRX_REL4,
  BFD_RELOC_CRX_REL8,
  BFD_RELOC_CRX_REL8_CMP,
  BFD_RELOC_CRX_REL16,
  BFD_RELOC_CRX_REL24,
  BFD_RELOC_CRX_REL32,
  BFD_RELOC_CRX_REGREL12,
  BFD_RELOC_CRX_REGREL22,
  BFD_RELOC_CRX_REGREL28,
  BFD_RELOC_CRX_REGREL32,
  BFD_RELOC_CRX_ABS16,
  BFD_RELOC_CRX_ABS32,
  BFD_RELOC_CRX_NUM8,
  BFD_RELOC_CRX_NUM16,
  BFD_RELOC_CRX_NUM32,
  BFD_RELOC_CRX_IMM16,
  BFD_RELOC_CRX_IMM32,
  BFD_RELOC_CRX_SWITCH8,
  BFD_RELOC_CRX_SWITCH16,
  BFD_RELOC_CRX_SWITCH32,



  BFD_RELOC_CRIS_BDISP8,
  BFD_RELOC_CRIS_UNSIGNED_5,
  BFD_RELOC_CRIS_SIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_6,
  BFD_RELOC_CRIS_SIGNED_8,
  BFD_RELOC_CRIS_UNSIGNED_8,
  BFD_RELOC_CRIS_SIGNED_16,
  BFD_RELOC_CRIS_UNSIGNED_16,
  BFD_RELOC_CRIS_LAPCQ_OFFSET,
  BFD_RELOC_CRIS_UNSIGNED_4,


  BFD_RELOC_CRIS_COPY,
  BFD_RELOC_CRIS_GLOB_DAT,
  BFD_RELOC_CRIS_JUMP_SLOT,
  BFD_RELOC_CRIS_RELATIVE,


  BFD_RELOC_CRIS_32_GOT,


  BFD_RELOC_CRIS_16_GOT,


  BFD_RELOC_CRIS_32_GOTPLT,


  BFD_RELOC_CRIS_16_GOTPLT,


  BFD_RELOC_CRIS_32_GOTREL,


  BFD_RELOC_CRIS_32_PLT_GOTREL,


  BFD_RELOC_CRIS_32_PLT_PCREL,


  BFD_RELOC_CRIS_32_GOT_GD,
  BFD_RELOC_CRIS_16_GOT_GD,
  BFD_RELOC_CRIS_32_GD,
  BFD_RELOC_CRIS_DTP,
  BFD_RELOC_CRIS_32_DTPREL,
  BFD_RELOC_CRIS_16_DTPREL,
  BFD_RELOC_CRIS_32_GOT_TPREL,
  BFD_RELOC_CRIS_16_GOT_TPREL,
  BFD_RELOC_CRIS_32_TPREL,
  BFD_RELOC_CRIS_16_TPREL,
  BFD_RELOC_CRIS_DTPMOD,
  BFD_RELOC_CRIS_32_IE,


  BFD_RELOC_OR1K_REL_26,
  BFD_RELOC_OR1K_SLO16,
  BFD_RELOC_OR1K_PCREL_PG21,
  BFD_RELOC_OR1K_LO13,
  BFD_RELOC_OR1K_SLO13,
  BFD_RELOC_OR1K_GOTPC_HI16,
  BFD_RELOC_OR1K_GOTPC_LO16,
  BFD_RELOC_OR1K_GOT_AHI16,
  BFD_RELOC_OR1K_GOT16,
  BFD_RELOC_OR1K_GOT_PG21,
  BFD_RELOC_OR1K_GOT_LO13,
  BFD_RELOC_OR1K_PLT26,
  BFD_RELOC_OR1K_PLTA26,
  BFD_RELOC_OR1K_GOTOFF_SLO16,
  BFD_RELOC_OR1K_COPY,
  BFD_RELOC_OR1K_GLOB_DAT,
  BFD_RELOC_OR1K_JMP_SLOT,
  BFD_RELOC_OR1K_RELATIVE,
  BFD_RELOC_OR1K_TLS_GD_HI16,
  BFD_RELOC_OR1K_TLS_GD_LO16,
  BFD_RELOC_OR1K_TLS_GD_PG21,
  BFD_RELOC_OR1K_TLS_GD_LO13,
  BFD_RELOC_OR1K_TLS_LDM_HI16,
  BFD_RELOC_OR1K_TLS_LDM_LO16,
  BFD_RELOC_OR1K_TLS_LDM_PG21,
  BFD_RELOC_OR1K_TLS_LDM_LO13,
  BFD_RELOC_OR1K_TLS_LDO_HI16,
  BFD_RELOC_OR1K_TLS_LDO_LO16,
  BFD_RELOC_OR1K_TLS_IE_HI16,
  BFD_RELOC_OR1K_TLS_IE_AHI16,
  BFD_RELOC_OR1K_TLS_IE_LO16,
  BFD_RELOC_OR1K_TLS_IE_PG21,
  BFD_RELOC_OR1K_TLS_IE_LO13,
  BFD_RELOC_OR1K_TLS_LE_HI16,
  BFD_RELOC_OR1K_TLS_LE_AHI16,
  BFD_RELOC_OR1K_TLS_LE_LO16,
  BFD_RELOC_OR1K_TLS_LE_SLO16,
  BFD_RELOC_OR1K_TLS_TPOFF,
  BFD_RELOC_OR1K_TLS_DTPOFF,
  BFD_RELOC_OR1K_TLS_DTPMOD,


  BFD_RELOC_H8_DIR16A8,
  BFD_RELOC_H8_DIR16R8,
  BFD_RELOC_H8_DIR24A8,
  BFD_RELOC_H8_DIR24R8,
  BFD_RELOC_H8_DIR32A16,
  BFD_RELOC_H8_DISP32A16,


  BFD_RELOC_XSTORMY16_REL_12,
  BFD_RELOC_XSTORMY16_12,
  BFD_RELOC_XSTORMY16_24,
  BFD_RELOC_XSTORMY16_FPTR16,


  BFD_RELOC_RELC,



  BFD_RELOC_VAX_GLOB_DAT,
  BFD_RELOC_VAX_JMP_SLOT,
  BFD_RELOC_VAX_RELATIVE,


  BFD_RELOC_MT_PC16,


  BFD_RELOC_MT_HI16,


  BFD_RELOC_MT_LO16,


  BFD_RELOC_MT_GNU_VTINHERIT,


  BFD_RELOC_MT_GNU_VTENTRY,


  BFD_RELOC_MT_PCINSN8,


  BFD_RELOC_MSP430_10_PCREL,
  BFD_RELOC_MSP430_16_PCREL,
  BFD_RELOC_MSP430_16,
  BFD_RELOC_MSP430_16_PCREL_BYTE,
  BFD_RELOC_MSP430_16_BYTE,
  BFD_RELOC_MSP430_2X_PCREL,
  BFD_RELOC_MSP430_RL_PCREL,
  BFD_RELOC_MSP430_ABS8,
  BFD_RELOC_MSP430X_PCR20_EXT_SRC,
  BFD_RELOC_MSP430X_PCR20_EXT_DST,
  BFD_RELOC_MSP430X_PCR20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_EXT_SRC,
  BFD_RELOC_MSP430X_ABS20_EXT_DST,
  BFD_RELOC_MSP430X_ABS20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_ADR_SRC,
  BFD_RELOC_MSP430X_ABS20_ADR_DST,
  BFD_RELOC_MSP430X_PCR16,
  BFD_RELOC_MSP430X_PCR20_CALL,
  BFD_RELOC_MSP430X_ABS16,
  BFD_RELOC_MSP430_ABS_HI16,
  BFD_RELOC_MSP430_PREL31,
  BFD_RELOC_MSP430_SYM_DIFF,
  BFD_RELOC_MSP430_SET_ULEB128,
  BFD_RELOC_MSP430_SUB_ULEB128,


  BFD_RELOC_NIOS2_S16,
  BFD_RELOC_NIOS2_U16,
  BFD_RELOC_NIOS2_CALL26,
  BFD_RELOC_NIOS2_IMM5,
  BFD_RELOC_NIOS2_CACHE_OPX,
  BFD_RELOC_NIOS2_IMM6,
  BFD_RELOC_NIOS2_IMM8,
  BFD_RELOC_NIOS2_HI16,
  BFD_RELOC_NIOS2_LO16,
  BFD_RELOC_NIOS2_HIADJ16,
  BFD_RELOC_NIOS2_GPREL,
  BFD_RELOC_NIOS2_UJMP,
  BFD_RELOC_NIOS2_CJMP,
  BFD_RELOC_NIOS2_CALLR,
  BFD_RELOC_NIOS2_ALIGN,
  BFD_RELOC_NIOS2_GOT16,
  BFD_RELOC_NIOS2_CALL16,
  BFD_RELOC_NIOS2_GOTOFF_LO,
  BFD_RELOC_NIOS2_GOTOFF_HA,
  BFD_RELOC_NIOS2_PCREL_LO,
  BFD_RELOC_NIOS2_PCREL_HA,
  BFD_RELOC_NIOS2_TLS_GD16,
  BFD_RELOC_NIOS2_TLS_LDM16,
  BFD_RELOC_NIOS2_TLS_LDO16,
  BFD_RELOC_NIOS2_TLS_IE16,
  BFD_RELOC_NIOS2_TLS_LE16,
  BFD_RELOC_NIOS2_TLS_DTPMOD,
  BFD_RELOC_NIOS2_TLS_DTPREL,
  BFD_RELOC_NIOS2_TLS_TPREL,
  BFD_RELOC_NIOS2_COPY,
  BFD_RELOC_NIOS2_GLOB_DAT,
  BFD_RELOC_NIOS2_JUMP_SLOT,
  BFD_RELOC_NIOS2_RELATIVE,
  BFD_RELOC_NIOS2_GOTOFF,
  BFD_RELOC_NIOS2_CALL26_NOAT,
  BFD_RELOC_NIOS2_GOT_LO,
  BFD_RELOC_NIOS2_GOT_HA,
  BFD_RELOC_NIOS2_CALL_LO,
  BFD_RELOC_NIOS2_CALL_HA,
  BFD_RELOC_NIOS2_R2_S12,
  BFD_RELOC_NIOS2_R2_I10_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_2,
  BFD_RELOC_NIOS2_R2_T2I4,
  BFD_RELOC_NIOS2_R2_T2I4_1,
  BFD_RELOC_NIOS2_R2_T2I4_2,
  BFD_RELOC_NIOS2_R2_X1I7_2,
  BFD_RELOC_NIOS2_R2_X2L5,
  BFD_RELOC_NIOS2_R2_F1I5_2,
  BFD_RELOC_NIOS2_R2_L5I4X1,
  BFD_RELOC_NIOS2_R2_T1X1I6,
  BFD_RELOC_NIOS2_R2_T1X1I6_2,


  BFD_RELOC_PRU_U16,


  BFD_RELOC_PRU_U16_PMEMIMM,




  BFD_RELOC_PRU_LDI32,


  BFD_RELOC_PRU_S10_PCREL,


  BFD_RELOC_PRU_U8_PCREL,



  BFD_RELOC_PRU_32_PMEM,
  BFD_RELOC_PRU_16_PMEM,
# 6193 "../bfd/bfd.h"
  BFD_RELOC_PRU_GNU_DIFF8,
  BFD_RELOC_PRU_GNU_DIFF16,
  BFD_RELOC_PRU_GNU_DIFF32,
  BFD_RELOC_PRU_GNU_DIFF16_PMEM,
  BFD_RELOC_PRU_GNU_DIFF32_PMEM,


  BFD_RELOC_IQ2000_OFFSET_16,
  BFD_RELOC_IQ2000_OFFSET_21,
  BFD_RELOC_IQ2000_UHI16,




  BFD_RELOC_XTENSA_RTLD,


  BFD_RELOC_XTENSA_GLOB_DAT,
  BFD_RELOC_XTENSA_JMP_SLOT,
  BFD_RELOC_XTENSA_RELATIVE,



  BFD_RELOC_XTENSA_PLT,
# 6226 "../bfd/bfd.h"
  BFD_RELOC_XTENSA_DIFF8,
  BFD_RELOC_XTENSA_DIFF16,
  BFD_RELOC_XTENSA_DIFF32,





  BFD_RELOC_XTENSA_SLOT0_OP,
  BFD_RELOC_XTENSA_SLOT1_OP,
  BFD_RELOC_XTENSA_SLOT2_OP,
  BFD_RELOC_XTENSA_SLOT3_OP,
  BFD_RELOC_XTENSA_SLOT4_OP,
  BFD_RELOC_XTENSA_SLOT5_OP,
  BFD_RELOC_XTENSA_SLOT6_OP,
  BFD_RELOC_XTENSA_SLOT7_OP,
  BFD_RELOC_XTENSA_SLOT8_OP,
  BFD_RELOC_XTENSA_SLOT9_OP,
  BFD_RELOC_XTENSA_SLOT10_OP,
  BFD_RELOC_XTENSA_SLOT11_OP,
  BFD_RELOC_XTENSA_SLOT12_OP,
  BFD_RELOC_XTENSA_SLOT13_OP,
  BFD_RELOC_XTENSA_SLOT14_OP,



  BFD_RELOC_XTENSA_SLOT0_ALT,
  BFD_RELOC_XTENSA_SLOT1_ALT,
  BFD_RELOC_XTENSA_SLOT2_ALT,
  BFD_RELOC_XTENSA_SLOT3_ALT,
  BFD_RELOC_XTENSA_SLOT4_ALT,
  BFD_RELOC_XTENSA_SLOT5_ALT,
  BFD_RELOC_XTENSA_SLOT6_ALT,
  BFD_RELOC_XTENSA_SLOT7_ALT,
  BFD_RELOC_XTENSA_SLOT8_ALT,
  BFD_RELOC_XTENSA_SLOT9_ALT,
  BFD_RELOC_XTENSA_SLOT10_ALT,
  BFD_RELOC_XTENSA_SLOT11_ALT,
  BFD_RELOC_XTENSA_SLOT12_ALT,
  BFD_RELOC_XTENSA_SLOT13_ALT,
  BFD_RELOC_XTENSA_SLOT14_ALT,



  BFD_RELOC_XTENSA_OP0,
  BFD_RELOC_XTENSA_OP1,
  BFD_RELOC_XTENSA_OP2,




  BFD_RELOC_XTENSA_ASM_EXPAND,





  BFD_RELOC_XTENSA_ASM_SIMPLIFY,


  BFD_RELOC_XTENSA_TLSDESC_FN,
  BFD_RELOC_XTENSA_TLSDESC_ARG,
  BFD_RELOC_XTENSA_TLS_DTPOFF,
  BFD_RELOC_XTENSA_TLS_TPOFF,
  BFD_RELOC_XTENSA_TLS_FUNC,
  BFD_RELOC_XTENSA_TLS_ARG,
  BFD_RELOC_XTENSA_TLS_CALL,
# 6303 "../bfd/bfd.h"
  BFD_RELOC_XTENSA_PDIFF8,
  BFD_RELOC_XTENSA_PDIFF16,
  BFD_RELOC_XTENSA_PDIFF32,
  BFD_RELOC_XTENSA_NDIFF8,
  BFD_RELOC_XTENSA_NDIFF16,
  BFD_RELOC_XTENSA_NDIFF32,


  BFD_RELOC_Z80_DISP8,


  BFD_RELOC_Z80_BYTE0,


  BFD_RELOC_Z80_BYTE1,


  BFD_RELOC_Z80_BYTE2,


  BFD_RELOC_Z80_BYTE3,


  BFD_RELOC_Z80_WORD0,


  BFD_RELOC_Z80_WORD1,


  BFD_RELOC_Z80_16_BE,


  BFD_RELOC_Z8K_DISP7,


  BFD_RELOC_Z8K_CALLR,


  BFD_RELOC_Z8K_IMM4L,


  BFD_RELOC_LM32_CALL,
  BFD_RELOC_LM32_BRANCH,
  BFD_RELOC_LM32_16_GOT,
  BFD_RELOC_LM32_GOTOFF_HI16,
  BFD_RELOC_LM32_GOTOFF_LO16,
  BFD_RELOC_LM32_COPY,
  BFD_RELOC_LM32_GLOB_DAT,
  BFD_RELOC_LM32_JMP_SLOT,
  BFD_RELOC_LM32_RELATIVE,



  BFD_RELOC_MACH_O_SECTDIFF,


  BFD_RELOC_MACH_O_LOCAL_SECTDIFF,


  BFD_RELOC_MACH_O_PAIR,


  BFD_RELOC_MACH_O_SUBTRACTOR32,


  BFD_RELOC_MACH_O_SUBTRACTOR64,



  BFD_RELOC_MACH_O_X86_64_BRANCH32,
  BFD_RELOC_MACH_O_X86_64_BRANCH8,


  BFD_RELOC_MACH_O_X86_64_GOT,



  BFD_RELOC_MACH_O_X86_64_GOT_LOAD,


  BFD_RELOC_MACH_O_X86_64_PCREL32_1,


  BFD_RELOC_MACH_O_X86_64_PCREL32_2,


  BFD_RELOC_MACH_O_X86_64_PCREL32_4,


  BFD_RELOC_MACH_O_X86_64_TLV,


  BFD_RELOC_MACH_O_ARM64_ADDEND,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12,


  BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT,



  BFD_RELOC_MICROBLAZE_32_LO,



  BFD_RELOC_MICROBLAZE_32_LO_PCREL,



  BFD_RELOC_MICROBLAZE_32_ROSDA,



  BFD_RELOC_MICROBLAZE_32_RWSDA,



  BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM,




  BFD_RELOC_MICROBLAZE_64_NONE,




  BFD_RELOC_MICROBLAZE_64_GOTPC,




  BFD_RELOC_MICROBLAZE_64_GOT,




  BFD_RELOC_MICROBLAZE_64_PLT,




  BFD_RELOC_MICROBLAZE_64_GOTOFF,



  BFD_RELOC_MICROBLAZE_32_GOTOFF,



  BFD_RELOC_MICROBLAZE_COPY,


  BFD_RELOC_MICROBLAZE_64_TLS,




  BFD_RELOC_MICROBLAZE_64_TLSGD,




  BFD_RELOC_MICROBLAZE_64_TLSLD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPMOD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSTPREL,




  BFD_RELOC_MICROBLAZE_64_TEXTPCREL,




  BFD_RELOC_MICROBLAZE_64_TEXTREL,





  BFD_RELOC_AARCH64_RELOC_START,


  BFD_RELOC_AARCH64_NULL,


  BFD_RELOC_AARCH64_NONE,




  BFD_RELOC_AARCH64_64,
  BFD_RELOC_AARCH64_32,
  BFD_RELOC_AARCH64_16,



  BFD_RELOC_AARCH64_64_PCREL,
  BFD_RELOC_AARCH64_32_PCREL,
  BFD_RELOC_AARCH64_16_PCREL,



  BFD_RELOC_AARCH64_MOVW_G0,



  BFD_RELOC_AARCH64_MOVW_G0_NC,



  BFD_RELOC_AARCH64_MOVW_G1,



  BFD_RELOC_AARCH64_MOVW_G1_NC,



  BFD_RELOC_AARCH64_MOVW_G2,



  BFD_RELOC_AARCH64_MOVW_G2_NC,



  BFD_RELOC_AARCH64_MOVW_G3,




  BFD_RELOC_AARCH64_MOVW_G0_S,




  BFD_RELOC_AARCH64_MOVW_G1_S,




  BFD_RELOC_AARCH64_MOVW_G2_S,




  BFD_RELOC_AARCH64_MOVW_PREL_G0,




  BFD_RELOC_AARCH64_MOVW_PREL_G0_NC,



  BFD_RELOC_AARCH64_MOVW_PREL_G1,



  BFD_RELOC_AARCH64_MOVW_PREL_G1_NC,



  BFD_RELOC_AARCH64_MOVW_PREL_G2,



  BFD_RELOC_AARCH64_MOVW_PREL_G2_NC,



  BFD_RELOC_AARCH64_MOVW_PREL_G3,




  BFD_RELOC_AARCH64_LD_LO19_PCREL,


  BFD_RELOC_AARCH64_ADR_LO21_PCREL,



  BFD_RELOC_AARCH64_ADR_HI21_PCREL,




  BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL,



  BFD_RELOC_AARCH64_ADD_LO12,



  BFD_RELOC_AARCH64_LDST8_LO12,




  BFD_RELOC_AARCH64_TSTBR14,




  BFD_RELOC_AARCH64_BRANCH19,




  BFD_RELOC_AARCH64_JUMP26,




  BFD_RELOC_AARCH64_CALL26,



  BFD_RELOC_AARCH64_LDST16_LO12,



  BFD_RELOC_AARCH64_LDST32_LO12,



  BFD_RELOC_AARCH64_LDST64_LO12,



  BFD_RELOC_AARCH64_LDST128_LO12,






  BFD_RELOC_AARCH64_GOT_LD_PREL19,




  BFD_RELOC_AARCH64_ADR_GOT_PAGE,




  BFD_RELOC_AARCH64_LD64_GOT_LO12_NC,




  BFD_RELOC_AARCH64_LD32_GOT_LO12_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G1,



  BFD_RELOC_AARCH64_LD64_GOTOFF_LO15,


  BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14,


  BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15,





  BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSGD_ADR_PREL21,




  BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G1,


  BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21,


  BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC,




  BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSLD_ADR_PREL21,



  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST16_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST32_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST64_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST8_TPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_LD_PREL19,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSDESC_LD64_LO12,


  BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_ADD_LO12,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G1,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC,


  BFD_RELOC_AARCH64_TLSDESC_LDR,


  BFD_RELOC_AARCH64_TLSDESC_ADD,


  BFD_RELOC_AARCH64_TLSDESC_CALL,


  BFD_RELOC_AARCH64_COPY,


  BFD_RELOC_AARCH64_GLOB_DAT,


  BFD_RELOC_AARCH64_JUMP_SLOT,


  BFD_RELOC_AARCH64_RELATIVE,


  BFD_RELOC_AARCH64_TLS_DTPMOD,


  BFD_RELOC_AARCH64_TLS_DTPREL,


  BFD_RELOC_AARCH64_TLS_TPREL,


  BFD_RELOC_AARCH64_TLSDESC,


  BFD_RELOC_AARCH64_IRELATIVE,






  BFD_RELOC_AARCH64_RELOC_END,



  BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP,



  BFD_RELOC_AARCH64_LDST_LO12,




  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC,




  BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_LDST_TPREL_LO12_NC,



  BFD_RELOC_AARCH64_LD_GOT_LO12_NC,



  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC,


  BFD_RELOC_TILEPRO_COPY,
  BFD_RELOC_TILEPRO_GLOB_DAT,
  BFD_RELOC_TILEPRO_JMP_SLOT,
  BFD_RELOC_TILEPRO_RELATIVE,
  BFD_RELOC_TILEPRO_BROFF_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT,
  BFD_RELOC_TILEPRO_IMM8_X0,
  BFD_RELOC_TILEPRO_IMM8_Y0,
  BFD_RELOC_TILEPRO_IMM8_X1,
  BFD_RELOC_TILEPRO_IMM8_Y1,
  BFD_RELOC_TILEPRO_DEST_IMM8_X1,
  BFD_RELOC_TILEPRO_MT_IMM15_X1,
  BFD_RELOC_TILEPRO_MF_IMM15_X1,
  BFD_RELOC_TILEPRO_IMM16_X0,
  BFD_RELOC_TILEPRO_IMM16_X1,
  BFD_RELOC_TILEPRO_IMM16_X0_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA,
  BFD_RELOC_TILEPRO_MMSTART_X0,
  BFD_RELOC_TILEPRO_MMEND_X0,
  BFD_RELOC_TILEPRO_MMSTART_X1,
  BFD_RELOC_TILEPRO_MMEND_X1,
  BFD_RELOC_TILEPRO_SHAMT_X0,
  BFD_RELOC_TILEPRO_SHAMT_X1,
  BFD_RELOC_TILEPRO_SHAMT_Y0,
  BFD_RELOC_TILEPRO_SHAMT_Y1,
  BFD_RELOC_TILEPRO_TLS_GD_CALL,
  BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_TLS_IE_LOAD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA,
  BFD_RELOC_TILEPRO_TLS_DTPMOD32,
  BFD_RELOC_TILEPRO_TLS_DTPOFF32,
  BFD_RELOC_TILEPRO_TLS_TPOFF32,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA,


  BFD_RELOC_TILEGX_HW0,
  BFD_RELOC_TILEGX_HW1,
  BFD_RELOC_TILEGX_HW2,
  BFD_RELOC_TILEGX_HW3,
  BFD_RELOC_TILEGX_HW0_LAST,
  BFD_RELOC_TILEGX_HW1_LAST,
  BFD_RELOC_TILEGX_HW2_LAST,
  BFD_RELOC_TILEGX_COPY,
  BFD_RELOC_TILEGX_GLOB_DAT,
  BFD_RELOC_TILEGX_JMP_SLOT,
  BFD_RELOC_TILEGX_RELATIVE,
  BFD_RELOC_TILEGX_BROFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1_PLT,
  BFD_RELOC_TILEGX_IMM8_X0,
  BFD_RELOC_TILEGX_IMM8_Y0,
  BFD_RELOC_TILEGX_IMM8_X1,
  BFD_RELOC_TILEGX_IMM8_Y1,
  BFD_RELOC_TILEGX_DEST_IMM8_X1,
  BFD_RELOC_TILEGX_MT_IMM14_X1,
  BFD_RELOC_TILEGX_MF_IMM14_X1,
  BFD_RELOC_TILEGX_MMSTART_X0,
  BFD_RELOC_TILEGX_MMEND_X0,
  BFD_RELOC_TILEGX_SHAMT_X0,
  BFD_RELOC_TILEGX_SHAMT_X1,
  BFD_RELOC_TILEGX_SHAMT_Y0,
  BFD_RELOC_TILEGX_SHAMT_Y1,
  BFD_RELOC_TILEGX_IMM16_X0_HW0,
  BFD_RELOC_TILEGX_IMM16_X1_HW0,
  BFD_RELOC_TILEGX_IMM16_X0_HW1,
  BFD_RELOC_TILEGX_IMM16_X1_HW1,
  BFD_RELOC_TILEGX_IMM16_X0_HW2,
  BFD_RELOC_TILEGX_IMM16_X1_HW2,
  BFD_RELOC_TILEGX_IMM16_X0_HW3,
  BFD_RELOC_TILEGX_IMM16_X1_HW3,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_TLS_DTPMOD64,
  BFD_RELOC_TILEGX_TLS_DTPOFF64,
  BFD_RELOC_TILEGX_TLS_TPOFF64,
  BFD_RELOC_TILEGX_TLS_DTPMOD32,
  BFD_RELOC_TILEGX_TLS_DTPOFF32,
  BFD_RELOC_TILEGX_TLS_TPOFF32,
  BFD_RELOC_TILEGX_TLS_GD_CALL,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_TLS_IE_LOAD,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD,


  BFD_RELOC_BPF_64,
  BFD_RELOC_BPF_DISP32,
  BFD_RELOC_BPF_DISPCALL32,
  BFD_RELOC_BPF_DISP16,


  BFD_RELOC_EPIPHANY_SIMM8,


  BFD_RELOC_EPIPHANY_SIMM24,


  BFD_RELOC_EPIPHANY_HIGH,


  BFD_RELOC_EPIPHANY_LOW,


  BFD_RELOC_EPIPHANY_SIMM11,


  BFD_RELOC_EPIPHANY_IMM11,


  BFD_RELOC_EPIPHANY_IMM8,


  BFD_RELOC_VISIUM_HI16,
  BFD_RELOC_VISIUM_LO16,
  BFD_RELOC_VISIUM_IM16,
  BFD_RELOC_VISIUM_REL16,
  BFD_RELOC_VISIUM_HI16_PCREL,
  BFD_RELOC_VISIUM_LO16_PCREL,
  BFD_RELOC_VISIUM_IM16_PCREL,


  BFD_RELOC_WASM32_LEB128,
  BFD_RELOC_WASM32_LEB128_GOT,
  BFD_RELOC_WASM32_LEB128_GOT_CODE,
  BFD_RELOC_WASM32_LEB128_PLT,
  BFD_RELOC_WASM32_PLT_INDEX,
  BFD_RELOC_WASM32_ABS32_CODE,
  BFD_RELOC_WASM32_COPY,
  BFD_RELOC_WASM32_CODE_POINTER,
  BFD_RELOC_WASM32_INDEX,
  BFD_RELOC_WASM32_PLT_SIG,


  BFD_RELOC_CKCORE_NONE,
  BFD_RELOC_CKCORE_ADDR32,
  BFD_RELOC_CKCORE_PCREL_IMM8BY4,
  BFD_RELOC_CKCORE_PCREL_IMM11BY2,
  BFD_RELOC_CKCORE_PCREL_IMM4BY2,
  BFD_RELOC_CKCORE_PCREL32,
  BFD_RELOC_CKCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_CKCORE_GNU_VTINHERIT,
  BFD_RELOC_CKCORE_GNU_VTENTRY,
  BFD_RELOC_CKCORE_RELATIVE,
  BFD_RELOC_CKCORE_COPY,
  BFD_RELOC_CKCORE_GLOB_DAT,
  BFD_RELOC_CKCORE_JUMP_SLOT,
  BFD_RELOC_CKCORE_GOTOFF,
  BFD_RELOC_CKCORE_GOTPC,
  BFD_RELOC_CKCORE_GOT32,
  BFD_RELOC_CKCORE_PLT32,
  BFD_RELOC_CKCORE_ADDRGOT,
  BFD_RELOC_CKCORE_ADDRPLT,
  BFD_RELOC_CKCORE_PCREL_IMM26BY2,
  BFD_RELOC_CKCORE_PCREL_IMM16BY2,
  BFD_RELOC_CKCORE_PCREL_IMM16BY4,
  BFD_RELOC_CKCORE_PCREL_IMM10BY2,
  BFD_RELOC_CKCORE_PCREL_IMM10BY4,
  BFD_RELOC_CKCORE_ADDR_HI16,
  BFD_RELOC_CKCORE_ADDR_LO16,
  BFD_RELOC_CKCORE_GOTPC_HI16,
  BFD_RELOC_CKCORE_GOTPC_LO16,
  BFD_RELOC_CKCORE_GOTOFF_HI16,
  BFD_RELOC_CKCORE_GOTOFF_LO16,
  BFD_RELOC_CKCORE_GOT12,
  BFD_RELOC_CKCORE_GOT_HI16,
  BFD_RELOC_CKCORE_GOT_LO16,
  BFD_RELOC_CKCORE_PLT12,
  BFD_RELOC_CKCORE_PLT_HI16,
  BFD_RELOC_CKCORE_PLT_LO16,
  BFD_RELOC_CKCORE_ADDRGOT_HI16,
  BFD_RELOC_CKCORE_ADDRGOT_LO16,
  BFD_RELOC_CKCORE_ADDRPLT_HI16,
  BFD_RELOC_CKCORE_ADDRPLT_LO16,
  BFD_RELOC_CKCORE_PCREL_JSR_IMM26BY2,
  BFD_RELOC_CKCORE_TOFFSET_LO16,
  BFD_RELOC_CKCORE_DOFFSET_LO16,
  BFD_RELOC_CKCORE_PCREL_IMM18BY2,
  BFD_RELOC_CKCORE_DOFFSET_IMM18,
  BFD_RELOC_CKCORE_DOFFSET_IMM18BY2,
  BFD_RELOC_CKCORE_DOFFSET_IMM18BY4,
  BFD_RELOC_CKCORE_GOTOFF_IMM18,
  BFD_RELOC_CKCORE_GOT_IMM18BY4,
  BFD_RELOC_CKCORE_PLT_IMM18BY4,
  BFD_RELOC_CKCORE_PCREL_IMM7BY4,
  BFD_RELOC_CKCORE_TLS_LE32,
  BFD_RELOC_CKCORE_TLS_IE32,
  BFD_RELOC_CKCORE_TLS_GD32,
  BFD_RELOC_CKCORE_TLS_LDM32,
  BFD_RELOC_CKCORE_TLS_LDO32,
  BFD_RELOC_CKCORE_TLS_DTPMOD32,
  BFD_RELOC_CKCORE_TLS_DTPOFF32,
  BFD_RELOC_CKCORE_TLS_TPOFF32,
  BFD_RELOC_CKCORE_PCREL_FLRW_IMM8BY4,
  BFD_RELOC_CKCORE_NOJSRI,
  BFD_RELOC_CKCORE_CALLGRAPH,
  BFD_RELOC_CKCORE_IRELATIVE,
  BFD_RELOC_CKCORE_PCREL_BLOOP_IMM4BY4,
  BFD_RELOC_CKCORE_PCREL_BLOOP_IMM12BY4,


  BFD_RELOC_S12Z_OPR,


  BFD_RELOC_LARCH_TLS_DTPMOD32,
  BFD_RELOC_LARCH_TLS_DTPREL32,
  BFD_RELOC_LARCH_TLS_DTPMOD64,
  BFD_RELOC_LARCH_TLS_DTPREL64,
  BFD_RELOC_LARCH_TLS_TPREL32,
  BFD_RELOC_LARCH_TLS_TPREL64,
  BFD_RELOC_LARCH_MARK_LA,
  BFD_RELOC_LARCH_MARK_PCREL,
  BFD_RELOC_LARCH_SOP_PUSH_PCREL,
  BFD_RELOC_LARCH_SOP_PUSH_ABSOLUTE,
  BFD_RELOC_LARCH_SOP_PUSH_DUP,
  BFD_RELOC_LARCH_SOP_PUSH_GPREL,
  BFD_RELOC_LARCH_SOP_PUSH_TLS_TPREL,
  BFD_RELOC_LARCH_SOP_PUSH_TLS_GOT,
  BFD_RELOC_LARCH_SOP_PUSH_TLS_GD,
  BFD_RELOC_LARCH_SOP_PUSH_PLT_PCREL,
  BFD_RELOC_LARCH_SOP_ASSERT,
  BFD_RELOC_LARCH_SOP_NOT,
  BFD_RELOC_LARCH_SOP_SUB,
  BFD_RELOC_LARCH_SOP_SL,
  BFD_RELOC_LARCH_SOP_SR,
  BFD_RELOC_LARCH_SOP_ADD,
  BFD_RELOC_LARCH_SOP_AND,
  BFD_RELOC_LARCH_SOP_IF_ELSE,
  BFD_RELOC_LARCH_SOP_POP_32_S_10_5,
  BFD_RELOC_LARCH_SOP_POP_32_U_10_12,
  BFD_RELOC_LARCH_SOP_POP_32_S_10_12,
  BFD_RELOC_LARCH_SOP_POP_32_S_10_16,
  BFD_RELOC_LARCH_SOP_POP_32_S_10_16_S2,
  BFD_RELOC_LARCH_SOP_POP_32_S_5_20,
  BFD_RELOC_LARCH_SOP_POP_32_S_0_5_10_16_S2,
  BFD_RELOC_LARCH_SOP_POP_32_S_0_10_10_16_S2,
  BFD_RELOC_LARCH_SOP_POP_32_U,
  BFD_RELOC_LARCH_ADD8,
  BFD_RELOC_LARCH_ADD16,
  BFD_RELOC_LARCH_ADD24,
  BFD_RELOC_LARCH_ADD32,
  BFD_RELOC_LARCH_ADD64,
  BFD_RELOC_LARCH_SUB8,
  BFD_RELOC_LARCH_SUB16,
  BFD_RELOC_LARCH_SUB24,
  BFD_RELOC_LARCH_SUB32,
  BFD_RELOC_LARCH_SUB64,
  BFD_RELOC_LARCH_B16,
  BFD_RELOC_LARCH_B21,
  BFD_RELOC_LARCH_B26,
  BFD_RELOC_LARCH_ABS_HI20,
  BFD_RELOC_LARCH_ABS_LO12,
  BFD_RELOC_LARCH_ABS64_LO20,
  BFD_RELOC_LARCH_ABS64_HI12,
  BFD_RELOC_LARCH_PCALA_HI20,
  BFD_RELOC_LARCH_PCALA_LO12,
  BFD_RELOC_LARCH_PCALA64_LO20,
  BFD_RELOC_LARCH_PCALA64_HI12,
  BFD_RELOC_LARCH_GOT_PC_HI20,
  BFD_RELOC_LARCH_GOT_PC_LO12,
  BFD_RELOC_LARCH_GOT64_PC_LO20,
  BFD_RELOC_LARCH_GOT64_PC_HI12,
  BFD_RELOC_LARCH_GOT_HI20,
  BFD_RELOC_LARCH_GOT_LO12,
  BFD_RELOC_LARCH_GOT64_LO20,
  BFD_RELOC_LARCH_GOT64_HI12,
  BFD_RELOC_LARCH_TLS_LE_HI20,
  BFD_RELOC_LARCH_TLS_LE_LO12,
  BFD_RELOC_LARCH_TLS_LE64_LO20,
  BFD_RELOC_LARCH_TLS_LE64_HI12,
  BFD_RELOC_LARCH_TLS_IE_PC_HI20,
  BFD_RELOC_LARCH_TLS_IE_PC_LO12,
  BFD_RELOC_LARCH_TLS_IE64_PC_LO20,
  BFD_RELOC_LARCH_TLS_IE64_PC_HI12,
  BFD_RELOC_LARCH_TLS_IE_HI20,
  BFD_RELOC_LARCH_TLS_IE_LO12,
  BFD_RELOC_LARCH_TLS_IE64_LO20,
  BFD_RELOC_LARCH_TLS_IE64_HI12,
  BFD_RELOC_LARCH_TLS_LD_PC_HI20,
  BFD_RELOC_LARCH_TLS_LD_HI20,
  BFD_RELOC_LARCH_TLS_GD_PC_HI20,
  BFD_RELOC_LARCH_TLS_GD_HI20,
  BFD_RELOC_LARCH_32_PCREL,
  BFD_RELOC_LARCH_RELAX,
  BFD_RELOC_LARCH_DELETE,
  BFD_RELOC_LARCH_ALIGN,
  BFD_RELOC_LARCH_PCREL20_S2,
  BFD_RELOC_LARCH_CFA,
  BFD_RELOC_LARCH_ADD6,
  BFD_RELOC_LARCH_SUB6,
  BFD_RELOC_LARCH_ADD_ULEB128,
  BFD_RELOC_LARCH_SUB_ULEB128,
  BFD_RELOC_LARCH_64_PCREL,
  BFD_RELOC_UNUSED };
typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;

reloc_howto_type *bfd_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code);
reloc_howto_type *bfd_reloc_name_lookup
   (bfd *abfd, const char *reloc_name);

const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);


bfd_byte *bfd_simple_get_relocated_section_contents
   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);


const char *bfd_get_stab_name (int);





struct stab_info
{

  struct bfd_strtab_hash *strings;

  struct bfd_hash_table includes;

  struct bfd_section *stabstr;
};
# 7414 "../bfd/bfd.h"
enum bfd_flavour
{

  bfd_target_unknown_flavour,
  bfd_target_aout_flavour,
  bfd_target_coff_flavour,
  bfd_target_ecoff_flavour,
  bfd_target_xcoff_flavour,
  bfd_target_elf_flavour,
  bfd_target_tekhex_flavour,
  bfd_target_srec_flavour,
  bfd_target_verilog_flavour,
  bfd_target_ihex_flavour,
  bfd_target_som_flavour,
  bfd_target_msdos_flavour,
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
};

enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };


struct flag_info;
typedef void (*bfd_cleanup) (bfd *);

typedef struct bfd_target
{

  const char *name;



  enum bfd_flavour flavour;


  enum bfd_endian byteorder;


  enum bfd_endian header_byteorder;



  flagword object_flags;



  flagword section_flags;



  char symbol_leading_char;


  char ar_pad_char;


  unsigned char ar_max_namelen;



  unsigned char match_priority;


  
# 7481 "../bfd/bfd.h" 3 4
 _Bool 
# 7481 "../bfd/bfd.h"
      keep_unused_section_symbols;




  uint64_t (*bfd_getx64) (const void *);
  int64_t (*bfd_getx_signed_64) (const void *);
  void (*bfd_putx64) (uint64_t, void *);
  bfd_vma (*bfd_getx32) (const void *);
  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
  void (*bfd_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_getx16) (const void *);
  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
  void (*bfd_putx16) (bfd_vma, void *);


  uint64_t (*bfd_h_getx64) (const void *);
  int64_t (*bfd_h_getx_signed_64) (const void *);
  void (*bfd_h_putx64) (uint64_t, void *);
  bfd_vma (*bfd_h_getx32) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
  void (*bfd_h_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_h_getx16) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
  void (*bfd_h_putx16) (bfd_vma, void *);






  bfd_cleanup (*_bfd_check_format[bfd_type_end]) (bfd *);


  
# 7515 "../bfd/bfd.h" 3 4
 _Bool 
# 7515 "../bfd/bfd.h"
      (*_bfd_set_format[bfd_type_end]) (bfd *);


  
# 7518 "../bfd/bfd.h" 3 4
 _Bool 
# 7518 "../bfd/bfd.h"
      (*_bfd_write_contents[bfd_type_end]) (bfd *);
# 7529 "../bfd/bfd.h"
  
# 7529 "../bfd/bfd.h" 3 4
 _Bool 
# 7529 "../bfd/bfd.h"
      (*_close_and_cleanup) (bfd *);

  
# 7531 "../bfd/bfd.h" 3 4
 _Bool 
# 7531 "../bfd/bfd.h"
      (*_bfd_free_cached_info) (bfd *);

  
# 7533 "../bfd/bfd.h" 3 4
 _Bool 
# 7533 "../bfd/bfd.h"
      (*_new_section_hook) (bfd *, sec_ptr);

  
# 7535 "../bfd/bfd.h" 3 4
 _Bool 
# 7535 "../bfd/bfd.h"
      (*_bfd_get_section_contents) (bfd *, sec_ptr, void *, file_ptr,
         bfd_size_type);
  
# 7537 "../bfd/bfd.h" 3 4
 _Bool 
# 7537 "../bfd/bfd.h"
      (*_bfd_get_section_contents_in_window) (bfd *, sec_ptr, bfd_window *,
            file_ptr, bfd_size_type);
# 7553 "../bfd/bfd.h"
  
# 7553 "../bfd/bfd.h" 3 4
 _Bool 
# 7553 "../bfd/bfd.h"
      (*_bfd_copy_private_bfd_data) (bfd *, bfd *);


  
# 7556 "../bfd/bfd.h" 3 4
 _Bool 
# 7556 "../bfd/bfd.h"
      (*_bfd_merge_private_bfd_data) (bfd *, struct bfd_link_info *);





  
# 7562 "../bfd/bfd.h" 3 4
 _Bool 
# 7562 "../bfd/bfd.h"
      (*_bfd_init_private_section_data) (bfd *, sec_ptr, bfd *, sec_ptr,
       struct bfd_link_info *);


  
# 7566 "../bfd/bfd.h" 3 4
 _Bool 
# 7566 "../bfd/bfd.h"
      (*_bfd_copy_private_section_data) (bfd *, sec_ptr, bfd *, sec_ptr);


  
# 7569 "../bfd/bfd.h" 3 4
 _Bool 
# 7569 "../bfd/bfd.h"
      (*_bfd_copy_private_symbol_data) (bfd *, asymbol *,
      bfd *, asymbol *);


  
# 7573 "../bfd/bfd.h" 3 4
 _Bool 
# 7573 "../bfd/bfd.h"
      (*_bfd_copy_private_header_data) (bfd *, bfd *);

  
# 7575 "../bfd/bfd.h" 3 4
 _Bool 
# 7575 "../bfd/bfd.h"
      (*_bfd_set_private_flags) (bfd *, flagword);


  
# 7578 "../bfd/bfd.h" 3 4
 _Bool 
# 7578 "../bfd/bfd.h"
      (*_bfd_print_private_bfd_data) (bfd *, void *);
# 7587 "../bfd/bfd.h"
  char *(*_core_file_failing_command) (bfd *);
  int (*_core_file_failing_signal) (bfd *);
  
# 7589 "../bfd/bfd.h" 3 4
 _Bool 
# 7589 "../bfd/bfd.h"
       (*_core_file_matches_executable_p) (bfd *, bfd *);
  int (*_core_file_pid) (bfd *);
# 7606 "../bfd/bfd.h"
  
# 7606 "../bfd/bfd.h" 3 4
 _Bool 
# 7606 "../bfd/bfd.h"
      (*_bfd_slurp_armap) (bfd *);
  
# 7607 "../bfd/bfd.h" 3 4
 _Bool 
# 7607 "../bfd/bfd.h"
      (*_bfd_slurp_extended_name_table) (bfd *);
  
# 7608 "../bfd/bfd.h" 3 4
 _Bool 
# 7608 "../bfd/bfd.h"
      (*_bfd_construct_extended_name_table) (bfd *, char **,
           bfd_size_type *,
           const char **);
  void (*_bfd_truncate_arname) (bfd *, const char *, char *);
  
# 7612 "../bfd/bfd.h" 3 4
 _Bool 
# 7612 "../bfd/bfd.h"
      (*write_armap) (bfd *, unsigned, struct orl *, unsigned, int);
  void *(*_bfd_read_ar_hdr_fn) (bfd *);
  
# 7614 "../bfd/bfd.h" 3 4
 _Bool 
# 7614 "../bfd/bfd.h"
      (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);
  bfd *(*openr_next_archived_file) (bfd *, bfd *);


  bfd *(*_bfd_get_elt_at_index) (bfd *, symindex);
  int (*_bfd_stat_arch_elt) (bfd *, struct stat *);
  
# 7620 "../bfd/bfd.h" 3 4
 _Bool 
# 7620 "../bfd/bfd.h"
      (*_bfd_update_armap_timestamp) (bfd *);
# 7641 "../bfd/bfd.h"
  long (*_bfd_get_symtab_upper_bound) (bfd *);
  long (*_bfd_canonicalize_symtab) (bfd *, struct bfd_symbol **);
  struct bfd_symbol *
       (*_bfd_make_empty_symbol) (bfd *);
  void (*_bfd_print_symbol) (bfd *, void *, struct bfd_symbol *,
        bfd_print_symbol_type);


  void (*_bfd_get_symbol_info) (bfd *, struct bfd_symbol *, symbol_info *);


  const char *
       (*_bfd_get_symbol_version_string) (bfd *, struct bfd_symbol *,
       
# 7654 "../bfd/bfd.h" 3 4
      _Bool
# 7654 "../bfd/bfd.h"
          , 
# 7654 "../bfd/bfd.h" 3 4
            _Bool 
# 7654 "../bfd/bfd.h"
                 *);


  
# 7657 "../bfd/bfd.h" 3 4
 _Bool 
# 7657 "../bfd/bfd.h"
      (*_bfd_is_local_label_name) (bfd *, const char *);
  
# 7658 "../bfd/bfd.h" 3 4
 _Bool 
# 7658 "../bfd/bfd.h"
      (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
  alent *
       (*_get_lineno) (bfd *, struct bfd_symbol *);
  
# 7661 "../bfd/bfd.h" 3 4
 _Bool 
# 7661 "../bfd/bfd.h"
      (*_bfd_find_nearest_line) (bfd *, struct bfd_symbol **,
      struct bfd_section *, bfd_vma,
      const char **, const char **,
      unsigned int *, unsigned int *);
  
# 7665 "../bfd/bfd.h" 3 4
 _Bool 
# 7665 "../bfd/bfd.h"
      (*_bfd_find_nearest_line_with_alt) (bfd *, const char *,
        struct bfd_symbol **,
        struct bfd_section *, bfd_vma,
        const char **, const char **,
        unsigned int *, unsigned int *);
  
# 7670 "../bfd/bfd.h" 3 4
 _Bool 
# 7670 "../bfd/bfd.h"
      (*_bfd_find_line) (bfd *, struct bfd_symbol **,
     struct bfd_symbol *, const char **,
     unsigned int *);
  
# 7673 "../bfd/bfd.h" 3 4
 _Bool 
# 7673 "../bfd/bfd.h"
      (*_bfd_find_inliner_info)
    (bfd *, const char **, const char **, unsigned int *);



  asymbol *
       (*_bfd_make_debug_symbol) (bfd *);


  long (*_read_minisymbols) (bfd *, 
# 7682 "../bfd/bfd.h" 3 4
                                   _Bool
# 7682 "../bfd/bfd.h"
                                       , void **, unsigned int *);


  asymbol *
       (*_minisymbol_to_symbol) (bfd *, 
# 7686 "../bfd/bfd.h" 3 4
                                       _Bool
# 7686 "../bfd/bfd.h"
                                           , const void *, asymbol *);
# 7696 "../bfd/bfd.h"
  long (*_get_reloc_upper_bound) (bfd *, sec_ptr);
  long (*_bfd_canonicalize_reloc) (bfd *, sec_ptr, arelent **,
       struct bfd_symbol **);
  void (*_bfd_set_reloc) (bfd *, sec_ptr, arelent **, unsigned int);

  reloc_howto_type *
       (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
  reloc_howto_type *
       (*reloc_name_lookup) (bfd *, const char *);






  
# 7711 "../bfd/bfd.h" 3 4
 _Bool 
# 7711 "../bfd/bfd.h"
      (*_bfd_set_arch_mach) (bfd *, enum bfd_architecture,
         unsigned long);
  
# 7713 "../bfd/bfd.h" 3 4
 _Bool 
# 7713 "../bfd/bfd.h"
      (*_bfd_set_section_contents) (bfd *, sec_ptr, const void *,
         file_ptr, bfd_size_type);
# 7739 "../bfd/bfd.h"
  int (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
  bfd_byte *
       (*_bfd_get_relocated_section_contents) (bfd *,
            struct bfd_link_info *,
            struct bfd_link_order *,
            bfd_byte *, 
# 7744 "../bfd/bfd.h" 3 4
                       _Bool
# 7744 "../bfd/bfd.h"
                           ,
            struct bfd_symbol **);

  
# 7747 "../bfd/bfd.h" 3 4
 _Bool 
# 7747 "../bfd/bfd.h"
      (*_bfd_relax_section) (bfd *, struct bfd_section *,
         struct bfd_link_info *, 
# 7748 "../bfd/bfd.h" 3 4
                                _Bool 
# 7748 "../bfd/bfd.h"
                                     *);



  struct bfd_link_hash_table *
       (*_bfd_link_hash_table_create) (bfd *);


  
# 7756 "../bfd/bfd.h" 3 4
 _Bool 
# 7756 "../bfd/bfd.h"
      (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);


  void (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);





  void (*_bfd_copy_link_hash_symbol_type) (bfd *,
        struct bfd_link_hash_entry *,
        struct bfd_link_hash_entry *);



  
# 7771 "../bfd/bfd.h" 3 4
 _Bool 
# 7771 "../bfd/bfd.h"
      (*_bfd_final_link) (bfd *, struct bfd_link_info *);


  
# 7774 "../bfd/bfd.h" 3 4
 _Bool 
# 7774 "../bfd/bfd.h"
      (*_bfd_link_split_section) (bfd *, struct bfd_section *);


  
# 7777 "../bfd/bfd.h" 3 4
 _Bool 
# 7777 "../bfd/bfd.h"
      (* _bfd_link_check_relocs)(bfd *, struct bfd_link_info *);


  
# 7780 "../bfd/bfd.h" 3 4
 _Bool 
# 7780 "../bfd/bfd.h"
      (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);


  
# 7783 "../bfd/bfd.h" 3 4
 _Bool 
# 7783 "../bfd/bfd.h"
      (*_bfd_lookup_section_flags) (struct bfd_link_info *,
         struct flag_info *, asection *);


  
# 7787 "../bfd/bfd.h" 3 4
 _Bool 
# 7787 "../bfd/bfd.h"
      (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);


  
# 7790 "../bfd/bfd.h" 3 4
 _Bool 
# 7790 "../bfd/bfd.h"
      (*_bfd_is_group_section) (bfd *, const struct bfd_section *);


  const char *(*_bfd_group_name) (bfd *, const struct bfd_section *);


  
# 7796 "../bfd/bfd.h" 3 4
 _Bool 
# 7796 "../bfd/bfd.h"
      (*_bfd_discard_group) (bfd *, struct bfd_section *);



  
# 7800 "../bfd/bfd.h" 3 4
 _Bool 
# 7800 "../bfd/bfd.h"
      (*_section_already_linked) (bfd *, asection *,
       struct bfd_link_info *);


  
# 7804 "../bfd/bfd.h" 3 4
 _Bool 
# 7804 "../bfd/bfd.h"
      (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,
         struct bfd_link_hash_entry *);


  void (*_bfd_link_hide_symbol) (bfd *, struct bfd_link_info *,
     struct bfd_link_hash_entry *);


  struct bfd_link_hash_entry *
       (*_bfd_define_start_stop) (struct bfd_link_info *, const char *,
      asection *);
# 7825 "../bfd/bfd.h"
  long (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_symtab) (bfd *, struct bfd_symbol **);

  long (*_bfd_get_synthetic_symtab) (bfd *, long, struct bfd_symbol **,
         long, struct bfd_symbol **,
         struct bfd_symbol **);

  long (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_reloc) (bfd *, arelent **,
        struct bfd_symbol **);


  const struct bfd_target *alternative_target;



  const void *backend_data;

} bfd_target;

static inline const char *
bfd_get_target (const bfd *abfd)
{
  return abfd->xvec->name;
}

static inline enum bfd_flavour
bfd_get_flavour (const bfd *abfd)
{
  return abfd->xvec->flavour;
}

static inline flagword
bfd_applicable_file_flags (const bfd *abfd)
{
  return abfd->xvec->object_flags;
}

static inline 
# 7865 "../bfd/bfd.h" 3 4
             _Bool

# 7866 "../bfd/bfd.h"
bfd_family_coff (const bfd *abfd)
{
  return (bfd_get_flavour (abfd) == bfd_target_coff_flavour
   || bfd_get_flavour (abfd) == bfd_target_xcoff_flavour);
}

static inline 
# 7872 "../bfd/bfd.h" 3 4
             _Bool

# 7873 "../bfd/bfd.h"
bfd_big_endian (const bfd *abfd)
{
  return abfd->xvec->byteorder == BFD_ENDIAN_BIG;
}
static inline 
# 7877 "../bfd/bfd.h" 3 4
             _Bool

# 7878 "../bfd/bfd.h"
bfd_little_endian (const bfd *abfd)
{
  return abfd->xvec->byteorder == BFD_ENDIAN_LITTLE;
}

static inline 
# 7883 "../bfd/bfd.h" 3 4
             _Bool

# 7884 "../bfd/bfd.h"
bfd_header_big_endian (const bfd *abfd)
{
  return abfd->xvec->header_byteorder == BFD_ENDIAN_BIG;
}

static inline 
# 7889 "../bfd/bfd.h" 3 4
             _Bool

# 7890 "../bfd/bfd.h"
bfd_header_little_endian (const bfd *abfd)
{
  return abfd->xvec->header_byteorder == BFD_ENDIAN_LITTLE;
}

static inline flagword
bfd_applicable_section_flags (const bfd *abfd)
{
  return abfd->xvec->section_flags;
}

static inline char
bfd_get_symbol_leading_char (const bfd *abfd)
{
  return abfd->xvec->symbol_leading_char;
}

static inline enum bfd_flavour
bfd_asymbol_flavour (const asymbol *sy)
{
  if ((sy->flags & (1 << 21)) != 0)
    return bfd_target_unknown_flavour;
  return sy->the_bfd->xvec->flavour;
}

static inline 
# 7915 "../bfd/bfd.h" 3 4
             _Bool

# 7916 "../bfd/bfd.h"
bfd_keep_unused_section_symbols (const bfd *abfd)
{
  return abfd->xvec->keep_unused_section_symbols;
}


# 7921 "../bfd/bfd.h" 3 4
_Bool 
# 7921 "../bfd/bfd.h"
    bfd_set_default_target (const char *name);

const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);

const bfd_target *bfd_get_target_info (const char *target_name,
    bfd *abfd,
    
# 7927 "../bfd/bfd.h" 3 4
   _Bool 
# 7927 "../bfd/bfd.h"
        *is_bigendian,
    int *underscoring,
    const char **def_target_arch);

const char ** bfd_target_list (void);

const bfd_target *bfd_iterate_over_targets
   (int (*func) (const bfd_target *, void *),
    void *data);

const char *bfd_flavour_name (enum bfd_flavour flavour);
# 61 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h" 1
# 27 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h"
const char *bfd_get_archive_filename (const bfd *);

void bfd_nonfatal (const char *);

void bfd_nonfatal_message (const char *, const bfd *, const asection *,
      const char *, ...);

void bfd_fatal (const char *) __attribute__ ((__noreturn__));

void report (const char *, va_list) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));

void fatal (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__noreturn__));

void non_fatal (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));

void *bfd_xalloc (bfd *, size_t);

void set_default_bfd_target (void);

void list_matching_formats (char **);

void list_supported_targets (const char *, FILE *);

void list_supported_architectures (const char *, FILE *);

int display_info (void);

void print_arelt_descr (FILE *, bfd *, 
# 54 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h" 3 4
                                      _Bool
# 54 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h"
                                          , 
# 54 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h" 3 4
                                            _Bool
# 54 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h"
                                                );

char *make_tempname (const char *, int *);
char *make_tempdir (const char *);

bfd_vma parse_vma (const char *, const char *);

off_t get_file_size (const char *);


# 63 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h" 3 4
_Bool 
# 63 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h"
    is_valid_archive_path (char const *);

extern char *program_name;


void mode_string (unsigned long, char *);


extern void print_version (const char *);


extern void set_times (const char *, const struct stat *);

extern int smart_rename (const char *, const char *, int,
    struct stat *, 
# 77 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h" 3 4
                  _Bool
# 77 "/doner/binutils/binutils-515f23e/binutils/./bucomm.h"
                      );



void *xmalloc (size_t);

void *xrealloc (void *, size_t);
# 62 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "/doner/binutils/binutils-515f23e/binutils/./elfcomm.h" 1
# 27 "/doner/binutils/binutils-515f23e/binutils/./elfcomm.h"
# 1 "./../include/aout/ar.h" 1
# 43 "./../include/aout/ar.h"
struct ar_hdr
{
  char ar_name[16];
  char ar_date[12];
  char ar_uid[6];
  char ar_gid[6];
  char ar_mode[8];
  char ar_size[10];
  char ar_fmag[2];
};
# 28 "/doner/binutils/binutils-515f23e/binutils/./elfcomm.h" 2

extern void error (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));
extern void warn (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));

extern void (*byte_put) (unsigned char *, uint64_t, unsigned int);
extern void byte_put_little_endian (unsigned char *, uint64_t, unsigned int);
extern void byte_put_big_endian (unsigned char *, uint64_t, unsigned int);

extern uint64_t (*byte_get) (const unsigned char *, unsigned int);
extern uint64_t byte_get_signed (const unsigned char *, unsigned int);
extern uint64_t byte_get_little_endian (const unsigned char *, unsigned int);
extern uint64_t byte_get_big_endian (const unsigned char *, unsigned int);
# 50 "/doner/binutils/binutils-515f23e/binutils/./elfcomm.h"
struct archive_info
{
  char *file_name;
  FILE *file;
  uint64_t index_num;
  uint64_t *index_array;
  char *sym_table;
  uint64_t sym_size;
  char *longnames;
  uint64_t longnames_size;
  uint64_t nested_member_origin;
  uint64_t next_arhdr_offset;
  int is_thin_archive;
  int uses_64bit_indices;
  struct ar_hdr arhdr;
};


extern char *adjust_relative_path (const char *, const char *, unsigned long);


extern int setup_archive (struct archive_info *, const char *, FILE *,
     off_t, int, int);


extern int setup_nested_archive (struct archive_info *, const char *);


extern void release_archive (struct archive_info *);



extern char *get_archive_member_name (struct archive_info *,
          struct archive_info *);




extern char *get_archive_member_name_at (struct archive_info *,
      unsigned long,
      struct archive_info *);




extern char *make_qualified_name (struct archive_info *,
      struct archive_info *,
      const char *);
# 63 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "/doner/binutils/binutils-515f23e/binutils/./demanguse.h" 1
# 28 "/doner/binutils/binutils-515f23e/binutils/./demanguse.h"
void display_demangler_styles (FILE *, const char *);
# 64 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h" 1
# 21 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h"
# 1 "./../include/dwarf2.h" 1
# 85 "./../include/dwarf2.h"
# 1 "./../include/dwarf2.def" 1
# 71 "./../include/dwarf2.def"
enum dwarf_tag { DW_TAG_padding = 0x00
, DW_TAG_array_type = 0x01
, DW_TAG_class_type = 0x02
, DW_TAG_entry_point = 0x03
, DW_TAG_enumeration_type = 0x04
, DW_TAG_formal_parameter = 0x05
, DW_TAG_imported_declaration = 0x08
, DW_TAG_label = 0x0a
, DW_TAG_lexical_block = 0x0b
, DW_TAG_member = 0x0d
, DW_TAG_pointer_type = 0x0f
, DW_TAG_reference_type = 0x10
, DW_TAG_compile_unit = 0x11
, DW_TAG_string_type = 0x12
, DW_TAG_structure_type = 0x13
, DW_TAG_subroutine_type = 0x15
, DW_TAG_typedef = 0x16
, DW_TAG_union_type = 0x17
, DW_TAG_unspecified_parameters = 0x18
, DW_TAG_variant = 0x19
, DW_TAG_common_block = 0x1a
, DW_TAG_common_inclusion = 0x1b
, DW_TAG_inheritance = 0x1c
, DW_TAG_inlined_subroutine = 0x1d
, DW_TAG_module = 0x1e
, DW_TAG_ptr_to_member_type = 0x1f
, DW_TAG_set_type = 0x20
, DW_TAG_subrange_type = 0x21
, DW_TAG_with_stmt = 0x22
, DW_TAG_access_declaration = 0x23
, DW_TAG_base_type = 0x24
, DW_TAG_catch_block = 0x25
, DW_TAG_const_type = 0x26
, DW_TAG_constant = 0x27
, DW_TAG_enumerator = 0x28
, DW_TAG_file_type = 0x29
, DW_TAG_friend = 0x2a
, DW_TAG_namelist = 0x2b
, DW_TAG_namelist_item = 0x2c
, DW_TAG_packed_type = 0x2d
, DW_TAG_subprogram = 0x2e
, DW_TAG_template_type_param = 0x2f
, DW_TAG_template_value_param = 0x30
, DW_TAG_thrown_type = 0x31
, DW_TAG_try_block = 0x32
, DW_TAG_variant_part = 0x33
, DW_TAG_variable = 0x34
, DW_TAG_volatile_type = 0x35

, DW_TAG_dwarf_procedure = 0x36
, DW_TAG_restrict_type = 0x37
, DW_TAG_interface_type = 0x38
, DW_TAG_namespace = 0x39
, DW_TAG_imported_module = 0x3a
, DW_TAG_unspecified_type = 0x3b
, DW_TAG_partial_unit = 0x3c
, DW_TAG_imported_unit = 0x3d
, DW_TAG_condition = 0x3f
, DW_TAG_shared_type = 0x40

, DW_TAG_type_unit = 0x41
, DW_TAG_rvalue_reference_type = 0x42
, DW_TAG_template_alias = 0x43

, DW_TAG_coarray_type = 0x44
, DW_TAG_generic_subrange = 0x45
, DW_TAG_dynamic_type = 0x46
, DW_TAG_atomic_type = 0x47
, DW_TAG_call_site = 0x48
, DW_TAG_call_site_parameter = 0x49
, DW_TAG_skeleton_unit = 0x4a
, DW_TAG_immutable_type = 0x4b

, DW_TAG_lo_user = 0x4080
, DW_TAG_hi_user = 0xffff


, DW_TAG_MIPS_loop = 0x4081


, DW_TAG_HP_array_descriptor = 0x4090
, DW_TAG_HP_Bliss_field = 0x4091
, DW_TAG_HP_Bliss_field_set = 0x4092


, DW_TAG_format_label = 0x4101
, DW_TAG_function_template = 0x4102
, DW_TAG_class_template = 0x4103
, DW_TAG_GNU_BINCL = 0x4104
, DW_TAG_GNU_EINCL = 0x4105


, DW_TAG_GNU_template_template_param = 0x4106





, DW_TAG_GNU_template_parameter_pack = 0x4107
, DW_TAG_GNU_formal_parameter_pack = 0x4108




, DW_TAG_GNU_call_site = 0x4109
, DW_TAG_GNU_call_site_parameter = 0x410a

, DW_TAG_upc_shared_type = 0x8765
, DW_TAG_upc_strict_type = 0x8766
, DW_TAG_upc_relaxed_type = 0x8767

, DW_TAG_PGI_kanji_type = 0xA000
, DW_TAG_PGI_interface_block = 0xA020
};

enum dwarf_form { DW_FORM_addr = 0x01
, DW_FORM_block2 = 0x03
, DW_FORM_block4 = 0x04
, DW_FORM_data2 = 0x05
, DW_FORM_data4 = 0x06
, DW_FORM_data8 = 0x07
, DW_FORM_string = 0x08
, DW_FORM_block = 0x09
, DW_FORM_block1 = 0x0a
, DW_FORM_data1 = 0x0b
, DW_FORM_flag = 0x0c
, DW_FORM_sdata = 0x0d
, DW_FORM_strp = 0x0e
, DW_FORM_udata = 0x0f
, DW_FORM_ref_addr = 0x10
, DW_FORM_ref1 = 0x11
, DW_FORM_ref2 = 0x12
, DW_FORM_ref4 = 0x13
, DW_FORM_ref8 = 0x14
, DW_FORM_ref_udata = 0x15
, DW_FORM_indirect = 0x16

, DW_FORM_sec_offset = 0x17
, DW_FORM_exprloc = 0x18
, DW_FORM_flag_present = 0x19
, DW_FORM_ref_sig8 = 0x20

, DW_FORM_strx = 0x1a
, DW_FORM_addrx = 0x1b
, DW_FORM_ref_sup4 = 0x1c
, DW_FORM_strp_sup = 0x1d
, DW_FORM_data16 = 0x1e
, DW_FORM_line_strp = 0x1f
, DW_FORM_implicit_const = 0x21
, DW_FORM_loclistx = 0x22
, DW_FORM_rnglistx = 0x23
, DW_FORM_ref_sup8 = 0x24
, DW_FORM_strx1 = 0x25
, DW_FORM_strx2 = 0x26
, DW_FORM_strx3 = 0x27
, DW_FORM_strx4 = 0x28
, DW_FORM_addrx1 = 0x29
, DW_FORM_addrx2 = 0x2a
, DW_FORM_addrx3 = 0x2b
, DW_FORM_addrx4 = 0x2c

, DW_FORM_GNU_addr_index = 0x1f01
, DW_FORM_GNU_str_index = 0x1f02


, DW_FORM_GNU_ref_alt = 0x1f20
, DW_FORM_GNU_strp_alt = 0x1f21
};

enum dwarf_attribute { DW_AT_sibling = 0x01
, DW_AT_location = 0x02
, DW_AT_name = 0x03
, DW_AT_ordering = 0x09
, DW_AT_subscr_data = 0x0a
, DW_AT_byte_size = 0x0b
, DW_AT_bit_offset = 0x0c
, DW_AT_bit_size = 0x0d
, DW_AT_element_list = 0x0f
, DW_AT_stmt_list = 0x10
, DW_AT_low_pc = 0x11
, DW_AT_high_pc = 0x12
, DW_AT_language = 0x13
, DW_AT_member = 0x14
, DW_AT_discr = 0x15
, DW_AT_discr_value = 0x16
, DW_AT_visibility = 0x17
, DW_AT_import = 0x18
, DW_AT_string_length = 0x19
, DW_AT_common_reference = 0x1a
, DW_AT_comp_dir = 0x1b
, DW_AT_const_value = 0x1c
, DW_AT_containing_type = 0x1d
, DW_AT_default_value = 0x1e
, DW_AT_inline = 0x20
, DW_AT_is_optional = 0x21
, DW_AT_lower_bound = 0x22
, DW_AT_producer = 0x25
, DW_AT_prototyped = 0x27
, DW_AT_return_addr = 0x2a
, DW_AT_start_scope = 0x2c
, DW_AT_bit_stride = 0x2e
, DW_AT_upper_bound = 0x2f
, DW_AT_abstract_origin = 0x31
, DW_AT_accessibility = 0x32
, DW_AT_address_class = 0x33
, DW_AT_artificial = 0x34
, DW_AT_base_types = 0x35
, DW_AT_calling_convention = 0x36
, DW_AT_count = 0x37
, DW_AT_data_member_location = 0x38
, DW_AT_decl_column = 0x39
, DW_AT_decl_file = 0x3a
, DW_AT_decl_line = 0x3b
, DW_AT_declaration = 0x3c
, DW_AT_discr_list = 0x3d
, DW_AT_encoding = 0x3e
, DW_AT_external = 0x3f
, DW_AT_frame_base = 0x40
, DW_AT_friend = 0x41
, DW_AT_identifier_case = 0x42
, DW_AT_macro_info = 0x43
, DW_AT_namelist_item = 0x44
, DW_AT_priority = 0x45
, DW_AT_segment = 0x46
, DW_AT_specification = 0x47
, DW_AT_static_link = 0x48
, DW_AT_type = 0x49
, DW_AT_use_location = 0x4a
, DW_AT_variable_parameter = 0x4b
, DW_AT_virtuality = 0x4c
, DW_AT_vtable_elem_location = 0x4d

, DW_AT_allocated = 0x4e
, DW_AT_associated = 0x4f
, DW_AT_data_location = 0x50
, DW_AT_byte_stride = 0x51
, DW_AT_entry_pc = 0x52
, DW_AT_use_UTF8 = 0x53
, DW_AT_extension = 0x54
, DW_AT_ranges = 0x55
, DW_AT_trampoline = 0x56
, DW_AT_call_column = 0x57
, DW_AT_call_file = 0x58
, DW_AT_call_line = 0x59
, DW_AT_description = 0x5a
, DW_AT_binary_scale = 0x5b
, DW_AT_decimal_scale = 0x5c
, DW_AT_small = 0x5d
, DW_AT_decimal_sign = 0x5e
, DW_AT_digit_count = 0x5f
, DW_AT_picture_string = 0x60
, DW_AT_mutable = 0x61
, DW_AT_threads_scaled = 0x62
, DW_AT_explicit = 0x63
, DW_AT_object_pointer = 0x64
, DW_AT_endianity = 0x65
, DW_AT_elemental = 0x66
, DW_AT_pure = 0x67
, DW_AT_recursive = 0x68

, DW_AT_signature = 0x69
, DW_AT_main_subprogram = 0x6a
, DW_AT_data_bit_offset = 0x6b
, DW_AT_const_expr = 0x6c
, DW_AT_enum_class = 0x6d
, DW_AT_linkage_name = 0x6e

, DW_AT_string_length_bit_size = 0x6f
, DW_AT_string_length_byte_size = 0x70
, DW_AT_rank = 0x71
, DW_AT_str_offsets_base = 0x72
, DW_AT_addr_base = 0x73
, DW_AT_rnglists_base = 0x74
, DW_AT_dwo_name = 0x76
, DW_AT_reference = 0x77
, DW_AT_rvalue_reference = 0x78
, DW_AT_macros = 0x79
, DW_AT_call_all_calls = 0x7a
, DW_AT_call_all_source_calls = 0x7b
, DW_AT_call_all_tail_calls = 0x7c
, DW_AT_call_return_pc = 0x7d
, DW_AT_call_value = 0x7e
, DW_AT_call_origin = 0x7f
, DW_AT_call_parameter = 0x80
, DW_AT_call_pc = 0x81
, DW_AT_call_tail_call = 0x82
, DW_AT_call_target = 0x83
, DW_AT_call_target_clobbered = 0x84
, DW_AT_call_data_location = 0x85
, DW_AT_call_data_value = 0x86
, DW_AT_noreturn = 0x87
, DW_AT_alignment = 0x88
, DW_AT_export_symbols = 0x89
, DW_AT_deleted = 0x8a
, DW_AT_defaulted = 0x8b
, DW_AT_loclists_base = 0x8c

, DW_AT_lo_user = 0x2000
, DW_AT_hi_user = 0x3fff


, DW_AT_MIPS_fde = 0x2001
, DW_AT_MIPS_loop_begin = 0x2002
, DW_AT_MIPS_tail_loop_begin = 0x2003
, DW_AT_MIPS_epilog_begin = 0x2004
, DW_AT_MIPS_loop_unroll_factor = 0x2005
, DW_AT_MIPS_software_pipeline_depth = 0x2006
, DW_AT_MIPS_linkage_name = 0x2007
, DW_AT_MIPS_stride = 0x2008
, DW_AT_MIPS_abstract_name = 0x2009
, DW_AT_MIPS_clone_origin = 0x200a
, DW_AT_MIPS_has_inlines = 0x200b

, DW_AT_HP_block_index = 0x2000
, DW_AT_HP_unmodifiable = 0x2001
, DW_AT_HP_prologue = 0x2005
, DW_AT_HP_epilogue = 0x2008
, DW_AT_HP_actuals_stmt_list = 0x2010
, DW_AT_HP_proc_per_section = 0x2011
, DW_AT_HP_raw_data_ptr = 0x2012
, DW_AT_HP_pass_by_reference = 0x2013
, DW_AT_HP_opt_level = 0x2014
, DW_AT_HP_prof_version_id = 0x2015
, DW_AT_HP_opt_flags = 0x2016
, DW_AT_HP_cold_region_low_pc = 0x2017
, DW_AT_HP_cold_region_high_pc = 0x2018
, DW_AT_HP_all_variables_modifiable = 0x2019
, DW_AT_HP_linkage_name = 0x201a
, DW_AT_HP_prof_flags = 0x201b
, DW_AT_HP_unit_name = 0x201f
, DW_AT_HP_unit_size = 0x2020
, DW_AT_HP_widened_byte_size = 0x2021
, DW_AT_HP_definition_points = 0x2022
, DW_AT_HP_default_location = 0x2023
, DW_AT_HP_is_result_param = 0x2029


, DW_AT_sf_names = 0x2101
, DW_AT_src_info = 0x2102
, DW_AT_mac_info = 0x2103
, DW_AT_src_coords = 0x2104
, DW_AT_body_begin = 0x2105
, DW_AT_body_end = 0x2106
, DW_AT_GNU_vector = 0x2107


, DW_AT_GNU_guarded_by = 0x2108
, DW_AT_GNU_pt_guarded_by = 0x2109
, DW_AT_GNU_guarded = 0x210a
, DW_AT_GNU_pt_guarded = 0x210b
, DW_AT_GNU_locks_excluded = 0x210c
, DW_AT_GNU_exclusive_locks_required = 0x210d
, DW_AT_GNU_shared_locks_required = 0x210e


, DW_AT_GNU_odr_signature = 0x210f


, DW_AT_GNU_template_name = 0x2110


, DW_AT_GNU_call_site_value = 0x2111
, DW_AT_GNU_call_site_data_value = 0x2112
, DW_AT_GNU_call_site_target = 0x2113
, DW_AT_GNU_call_site_target_clobbered = 0x2114
, DW_AT_GNU_tail_call = 0x2115
, DW_AT_GNU_all_tail_call_sites = 0x2116
, DW_AT_GNU_all_call_sites = 0x2117
, DW_AT_GNU_all_source_call_sites = 0x2118

, DW_AT_GNU_macros = 0x2119

, DW_AT_GNU_deleted = 0x211a

, DW_AT_GNU_dwo_name = 0x2130
, DW_AT_GNU_dwo_id = 0x2131
, DW_AT_GNU_ranges_base = 0x2132
, DW_AT_GNU_addr_base = 0x2133
, DW_AT_GNU_pubnames = 0x2134
, DW_AT_GNU_pubtypes = 0x2135


, DW_AT_GNU_discriminator = 0x2136
, DW_AT_GNU_locviews = 0x2137
, DW_AT_GNU_entry_view = 0x2138

, DW_AT_VMS_rtnbeg_pd_address = 0x2201



, DW_AT_use_GNAT_descriptive_type = 0x2301
, DW_AT_GNAT_descriptive_type = 0x2302


, DW_AT_GNU_numerator = 0x2303
, DW_AT_GNU_denominator = 0x2304


, DW_AT_GNU_bias = 0x2305

, DW_AT_upc_threads_scaled = 0x3210

, DW_AT_PGI_lbase = 0x3a00
, DW_AT_PGI_soffset = 0x3a01
, DW_AT_PGI_lstride = 0x3a02

, DW_AT_APPLE_optimized = 0x3fe1
, DW_AT_APPLE_flags = 0x3fe2
, DW_AT_APPLE_isa = 0x3fe3
, DW_AT_APPLE_block = 0x3fe4
, DW_AT_APPLE_major_runtime_vers = 0x3fe5
, DW_AT_APPLE_runtime_class = 0x3fe6
, DW_AT_APPLE_omit_frame_ptr = 0x3fe7
, DW_AT_APPLE_property_name = 0x3fe8
, DW_AT_APPLE_property_getter = 0x3fe9
, DW_AT_APPLE_property_setter = 0x3fea
, DW_AT_APPLE_property_attribute = 0x3feb
, DW_AT_APPLE_objc_complete_type = 0x3fec
, DW_AT_APPLE_property = 0x3fed
};

enum dwarf_location_atom { DW_OP_addr = 0x03
, DW_OP_deref = 0x06
, DW_OP_const1u = 0x08
, DW_OP_const1s = 0x09
, DW_OP_const2u = 0x0a
, DW_OP_const2s = 0x0b
, DW_OP_const4u = 0x0c
, DW_OP_const4s = 0x0d
, DW_OP_const8u = 0x0e
, DW_OP_const8s = 0x0f
, DW_OP_constu = 0x10
, DW_OP_consts = 0x11
, DW_OP_dup = 0x12
, DW_OP_drop = 0x13
, DW_OP_over = 0x14
, DW_OP_pick = 0x15
, DW_OP_swap = 0x16
, DW_OP_rot = 0x17
, DW_OP_xderef = 0x18
, DW_OP_abs = 0x19
, DW_OP_and = 0x1a
, DW_OP_div = 0x1b
, DW_OP_minus = 0x1c
, DW_OP_mod = 0x1d
, DW_OP_mul = 0x1e
, DW_OP_neg = 0x1f
, DW_OP_not = 0x20
, DW_OP_or = 0x21
, DW_OP_plus = 0x22
, DW_OP_plus_uconst = 0x23
, DW_OP_shl = 0x24
, DW_OP_shr = 0x25
, DW_OP_shra = 0x26
, DW_OP_xor = 0x27
, DW_OP_bra = 0x28
, DW_OP_eq = 0x29
, DW_OP_ge = 0x2a
, DW_OP_gt = 0x2b
, DW_OP_le = 0x2c
, DW_OP_lt = 0x2d
, DW_OP_ne = 0x2e
, DW_OP_skip = 0x2f
, DW_OP_lit0 = 0x30
, DW_OP_lit1 = 0x31
, DW_OP_lit2 = 0x32
, DW_OP_lit3 = 0x33
, DW_OP_lit4 = 0x34
, DW_OP_lit5 = 0x35
, DW_OP_lit6 = 0x36
, DW_OP_lit7 = 0x37
, DW_OP_lit8 = 0x38
, DW_OP_lit9 = 0x39
, DW_OP_lit10 = 0x3a
, DW_OP_lit11 = 0x3b
, DW_OP_lit12 = 0x3c
, DW_OP_lit13 = 0x3d
, DW_OP_lit14 = 0x3e
, DW_OP_lit15 = 0x3f
, DW_OP_lit16 = 0x40
, DW_OP_lit17 = 0x41
, DW_OP_lit18 = 0x42
, DW_OP_lit19 = 0x43
, DW_OP_lit20 = 0x44
, DW_OP_lit21 = 0x45
, DW_OP_lit22 = 0x46
, DW_OP_lit23 = 0x47
, DW_OP_lit24 = 0x48
, DW_OP_lit25 = 0x49
, DW_OP_lit26 = 0x4a
, DW_OP_lit27 = 0x4b
, DW_OP_lit28 = 0x4c
, DW_OP_lit29 = 0x4d
, DW_OP_lit30 = 0x4e
, DW_OP_lit31 = 0x4f
, DW_OP_reg0 = 0x50
, DW_OP_reg1 = 0x51
, DW_OP_reg2 = 0x52
, DW_OP_reg3 = 0x53
, DW_OP_reg4 = 0x54
, DW_OP_reg5 = 0x55
, DW_OP_reg6 = 0x56
, DW_OP_reg7 = 0x57
, DW_OP_reg8 = 0x58
, DW_OP_reg9 = 0x59
, DW_OP_reg10 = 0x5a
, DW_OP_reg11 = 0x5b
, DW_OP_reg12 = 0x5c
, DW_OP_reg13 = 0x5d
, DW_OP_reg14 = 0x5e
, DW_OP_reg15 = 0x5f
, DW_OP_reg16 = 0x60
, DW_OP_reg17 = 0x61
, DW_OP_reg18 = 0x62
, DW_OP_reg19 = 0x63
, DW_OP_reg20 = 0x64
, DW_OP_reg21 = 0x65
, DW_OP_reg22 = 0x66
, DW_OP_reg23 = 0x67
, DW_OP_reg24 = 0x68
, DW_OP_reg25 = 0x69
, DW_OP_reg26 = 0x6a
, DW_OP_reg27 = 0x6b
, DW_OP_reg28 = 0x6c
, DW_OP_reg29 = 0x6d
, DW_OP_reg30 = 0x6e
, DW_OP_reg31 = 0x6f
, DW_OP_breg0 = 0x70
, DW_OP_breg1 = 0x71
, DW_OP_breg2 = 0x72
, DW_OP_breg3 = 0x73
, DW_OP_breg4 = 0x74
, DW_OP_breg5 = 0x75
, DW_OP_breg6 = 0x76
, DW_OP_breg7 = 0x77
, DW_OP_breg8 = 0x78
, DW_OP_breg9 = 0x79
, DW_OP_breg10 = 0x7a
, DW_OP_breg11 = 0x7b
, DW_OP_breg12 = 0x7c
, DW_OP_breg13 = 0x7d
, DW_OP_breg14 = 0x7e
, DW_OP_breg15 = 0x7f
, DW_OP_breg16 = 0x80
, DW_OP_breg17 = 0x81
, DW_OP_breg18 = 0x82
, DW_OP_breg19 = 0x83
, DW_OP_breg20 = 0x84
, DW_OP_breg21 = 0x85
, DW_OP_breg22 = 0x86
, DW_OP_breg23 = 0x87
, DW_OP_breg24 = 0x88
, DW_OP_breg25 = 0x89
, DW_OP_breg26 = 0x8a
, DW_OP_breg27 = 0x8b
, DW_OP_breg28 = 0x8c
, DW_OP_breg29 = 0x8d
, DW_OP_breg30 = 0x8e
, DW_OP_breg31 = 0x8f
, DW_OP_regx = 0x90
, DW_OP_fbreg = 0x91
, DW_OP_bregx = 0x92
, DW_OP_piece = 0x93
, DW_OP_deref_size = 0x94
, DW_OP_xderef_size = 0x95
, DW_OP_nop = 0x96

, DW_OP_push_object_address = 0x97
, DW_OP_call2 = 0x98
, DW_OP_call4 = 0x99
, DW_OP_call_ref = 0x9a
, DW_OP_form_tls_address = 0x9b
, DW_OP_call_frame_cfa = 0x9c
, DW_OP_bit_piece = 0x9d


, DW_OP_implicit_value = 0x9e
, DW_OP_stack_value = 0x9f


, DW_OP_implicit_pointer = 0xa0
, DW_OP_addrx = 0xa1
, DW_OP_constx = 0xa2
, DW_OP_entry_value = 0xa3
, DW_OP_const_type = 0xa4
, DW_OP_regval_type = 0xa5
, DW_OP_deref_type = 0xa6
, DW_OP_xderef_type = 0xa7
, DW_OP_convert = 0xa8
, DW_OP_reinterpret = 0xa9

, DW_OP_lo_user = 0xe0
, DW_OP_hi_user = 0xff


, DW_OP_GNU_push_tls_address = 0xe0

, DW_OP_GNU_uninit = 0xf0
, DW_OP_GNU_encoded_addr = 0xf1


, DW_OP_GNU_implicit_pointer = 0xf2


, DW_OP_GNU_entry_value = 0xf3


, DW_OP_GNU_const_type = 0xf4
, DW_OP_GNU_regval_type = 0xf5
, DW_OP_GNU_deref_type = 0xf6
, DW_OP_GNU_convert = 0xf7
, DW_OP_GNU_reinterpret = 0xf9

, DW_OP_GNU_parameter_ref = 0xfa

, DW_OP_GNU_addr_index = 0xfb
, DW_OP_GNU_const_index = 0xfc


, DW_OP_GNU_variable_value = 0xfd

, DW_OP_HP_unknown = 0xe0
, DW_OP_HP_is_value = 0xe1
, DW_OP_HP_fltconst4 = 0xe2
, DW_OP_HP_fltconst8 = 0xe3
, DW_OP_HP_mod_range = 0xe4
, DW_OP_HP_unmod_range = 0xe5
, DW_OP_HP_tls = 0xe6

, DW_OP_PGI_omp_thread_num = 0xf8





, DW_OP_AARCH64_operation = 0xea
};

enum dwarf_type { DW_ATE_void = 0x0
, DW_ATE_address = 0x1
, DW_ATE_boolean = 0x2
, DW_ATE_complex_float = 0x3
, DW_ATE_float = 0x4
, DW_ATE_signed = 0x5
, DW_ATE_signed_char = 0x6
, DW_ATE_unsigned = 0x7
, DW_ATE_unsigned_char = 0x8

, DW_ATE_imaginary_float = 0x9
, DW_ATE_packed_decimal = 0xa
, DW_ATE_numeric_string = 0xb
, DW_ATE_edited = 0xc
, DW_ATE_signed_fixed = 0xd
, DW_ATE_unsigned_fixed = 0xe
, DW_ATE_decimal_float = 0xf

, DW_ATE_UTF = 0x10

, DW_ATE_UCS = 0x11
, DW_ATE_ASCII = 0x12

, DW_ATE_lo_user = 0x80
, DW_ATE_hi_user = 0xff


, DW_ATE_HP_float80 = 0x80
, DW_ATE_HP_complex_float80 = 0x81
, DW_ATE_HP_float128 = 0x82
, DW_ATE_HP_complex_float128 = 0x83
, DW_ATE_HP_floathpintel = 0x84
, DW_ATE_HP_imaginary_float80 = 0x85
, DW_ATE_HP_imaginary_float128 = 0x86
, DW_ATE_HP_VAX_float = 0x88
, DW_ATE_HP_VAX_float_d = 0x89
, DW_ATE_HP_packed_decimal = 0x8a
, DW_ATE_HP_zoned_decimal = 0x8b
, DW_ATE_HP_edited = 0x8c
, DW_ATE_HP_signed_fixed = 0x8d
, DW_ATE_HP_unsigned_fixed = 0x8e
, DW_ATE_HP_VAX_complex_float = 0x8f
, DW_ATE_HP_VAX_complex_float_d = 0x90

};

enum dwarf_call_frame_info { DW_CFA_advance_loc = 0x40
, DW_CFA_offset = 0x80
, DW_CFA_restore = 0xc0
, DW_CFA_nop = 0x00
, DW_CFA_set_loc = 0x01
, DW_CFA_advance_loc1 = 0x02
, DW_CFA_advance_loc2 = 0x03
, DW_CFA_advance_loc4 = 0x04
, DW_CFA_offset_extended = 0x05
, DW_CFA_restore_extended = 0x06
, DW_CFA_undefined = 0x07
, DW_CFA_same_value = 0x08
, DW_CFA_register = 0x09
, DW_CFA_remember_state = 0x0a
, DW_CFA_restore_state = 0x0b
, DW_CFA_def_cfa = 0x0c
, DW_CFA_def_cfa_register = 0x0d
, DW_CFA_def_cfa_offset = 0x0e

, DW_CFA_def_cfa_expression = 0x0f
, DW_CFA_expression = 0x10
, DW_CFA_offset_extended_sf = 0x11
, DW_CFA_def_cfa_sf = 0x12
, DW_CFA_def_cfa_offset_sf = 0x13
, DW_CFA_val_offset = 0x14
, DW_CFA_val_offset_sf = 0x15
, DW_CFA_val_expression = 0x16

, DW_CFA_lo_user = 0x1c
, DW_CFA_hi_user = 0x3f


, DW_CFA_MIPS_advance_loc8 = 0x1d


, DW_CFA_GNU_window_save = 0x2d
, DW_CFA_AARCH64_negate_ra_state = 0x2d
, DW_CFA_GNU_args_size = 0x2e
, DW_CFA_GNU_negative_offset_extended = 0x2f

};


enum dwarf_name_index_attribute { DW_IDX_compile_unit = 1
, DW_IDX_type_unit = 2
, DW_IDX_die_offset = 3
, DW_IDX_parent = 4
, DW_IDX_type_hash = 5
, DW_IDX_lo_user = 0x2000
, DW_IDX_hi_user = 0x3fff
, DW_IDX_GNU_internal = 0x2000
, DW_IDX_GNU_external = 0x2001
};


enum dwarf_unit_type { DW_UT_compile = 0x01
, DW_UT_type = 0x02
, DW_UT_partial = 0x03
, DW_UT_skeleton = 0x04
, DW_UT_split_compile = 0x05
, DW_UT_split_type = 0x06
, DW_UT_lo_user = 0x80
, DW_UT_hi_user = 0xff
};
# 86 "./../include/dwarf2.h" 2
# 127 "./../include/dwarf2.h"
enum dwarf_decimal_sign_encoding
  {

    DW_DS_unsigned = 0x01,
    DW_DS_leading_overpunch = 0x02,
    DW_DS_trailing_overpunch = 0x03,
    DW_DS_leading_separate = 0x04,
    DW_DS_trailing_separate = 0x05
  };


enum dwarf_endianity_encoding
  {

    DW_END_default = 0x00,
    DW_END_big = 0x01,
    DW_END_little = 0x02,

    DW_END_lo_user = 0x40,
    DW_END_hi_user = 0xff
  };


enum dwarf_array_dim_ordering
  {
    DW_ORD_row_major = 0,
    DW_ORD_col_major = 1
  };


enum dwarf_access_attribute
  {
    DW_ACCESS_public = 1,
    DW_ACCESS_protected = 2,
    DW_ACCESS_private = 3
  };


enum dwarf_visibility_attribute
  {
    DW_VIS_local = 1,
    DW_VIS_exported = 2,
    DW_VIS_qualified = 3
  };


enum dwarf_virtuality_attribute
  {
    DW_VIRTUALITY_none = 0,
    DW_VIRTUALITY_virtual = 1,
    DW_VIRTUALITY_pure_virtual = 2
  };


enum dwarf_id_case
  {
    DW_ID_case_sensitive = 0,
    DW_ID_up_case = 1,
    DW_ID_down_case = 2,
    DW_ID_case_insensitive = 3
  };


enum dwarf_calling_convention
  {
    DW_CC_normal = 0x1,
    DW_CC_program = 0x2,
    DW_CC_nocall = 0x3,


    DW_CC_pass_by_reference = 0x4,
    DW_CC_pass_by_value = 0x5,

    DW_CC_lo_user = 0x40,
    DW_CC_hi_user = 0xff,

    DW_CC_GNU_renesas_sh = 0x40,
    DW_CC_GNU_borland_fastcall_i386 = 0x41,







    DW_CC_GDB_IBM_OpenCL = 0xff
  };


enum dwarf_inline_attribute
  {
    DW_INL_not_inlined = 0,
    DW_INL_inlined = 1,
    DW_INL_declared_not_inlined = 2,
    DW_INL_declared_inlined = 3
  };


enum dwarf_discrim_list
  {
    DW_DSC_label = 0,
    DW_DSC_range = 1
  };


enum dwarf_line_number_ops
  {
    DW_LNS_extended_op = 0,
    DW_LNS_copy = 1,
    DW_LNS_advance_pc = 2,
    DW_LNS_advance_line = 3,
    DW_LNS_set_file = 4,
    DW_LNS_set_column = 5,
    DW_LNS_negate_stmt = 6,
    DW_LNS_set_basic_block = 7,
    DW_LNS_const_add_pc = 8,
    DW_LNS_fixed_advance_pc = 9,

    DW_LNS_set_prologue_end = 10,
    DW_LNS_set_epilogue_begin = 11,
    DW_LNS_set_isa = 12
  };


enum dwarf_line_number_x_ops
  {
    DW_LNE_end_sequence = 1,
    DW_LNE_set_address = 2,
    DW_LNE_define_file = 3,
    DW_LNE_set_discriminator = 4,

    DW_LNE_HP_negate_is_UV_update = 0x11,
    DW_LNE_HP_push_context = 0x12,
    DW_LNE_HP_pop_context = 0x13,
    DW_LNE_HP_set_file_line_column = 0x14,
    DW_LNE_HP_set_routine_name = 0x15,
    DW_LNE_HP_set_sequence = 0x16,
    DW_LNE_HP_negate_post_semantics = 0x17,
    DW_LNE_HP_negate_function_exit = 0x18,
    DW_LNE_HP_negate_front_end_logical = 0x19,
    DW_LNE_HP_define_proc = 0x20,
    DW_LNE_HP_source_file_correlation = 0x80,

    DW_LNE_lo_user = 0x80,
    DW_LNE_hi_user = 0xff
  };


enum dwarf_line_number_hp_sfc_ops
  {
    DW_LNE_HP_SFC_formfeed = 1,
    DW_LNE_HP_SFC_set_listing_line = 2,
    DW_LNE_HP_SFC_associate = 3
  };



enum dwarf_line_number_content_type
  {
    DW_LNCT_path = 0x1,
    DW_LNCT_directory_index = 0x2,
    DW_LNCT_timestamp = 0x3,
    DW_LNCT_size = 0x4,
    DW_LNCT_MD5 = 0x5,
    DW_LNCT_lo_user = 0x2000,
    DW_LNCT_hi_user = 0x3fff
  };


enum dwarf_location_list_entry_type
  {
    DW_LLE_end_of_list = 0x00,
    DW_LLE_base_addressx = 0x01,
    DW_LLE_startx_endx = 0x02,
    DW_LLE_startx_length = 0x03,
    DW_LLE_offset_pair = 0x04,
    DW_LLE_default_location = 0x05,
    DW_LLE_base_address = 0x06,
    DW_LLE_start_end = 0x07,
    DW_LLE_start_length = 0x08,






    DW_LLE_GNU_view_pair = 0x09,




    DW_LLE_GNU_end_of_list_entry = 0x00,
    DW_LLE_GNU_base_address_selection_entry = 0x01,
    DW_LLE_GNU_start_end_entry = 0x02,
    DW_LLE_GNU_start_length_entry = 0x03
  };
# 335 "./../include/dwarf2.h"
enum dwarf_source_language
  {
    DW_LANG_C89 = 0x0001,
    DW_LANG_C = 0x0002,
    DW_LANG_Ada83 = 0x0003,
    DW_LANG_C_plus_plus = 0x0004,
    DW_LANG_Cobol74 = 0x0005,
    DW_LANG_Cobol85 = 0x0006,
    DW_LANG_Fortran77 = 0x0007,
    DW_LANG_Fortran90 = 0x0008,
    DW_LANG_Pascal83 = 0x0009,
    DW_LANG_Modula2 = 0x000a,

    DW_LANG_Java = 0x000b,
    DW_LANG_C99 = 0x000c,
    DW_LANG_Ada95 = 0x000d,
    DW_LANG_Fortran95 = 0x000e,
    DW_LANG_PLI = 0x000f,
    DW_LANG_ObjC = 0x0010,
    DW_LANG_ObjC_plus_plus = 0x0011,
    DW_LANG_UPC = 0x0012,
    DW_LANG_D = 0x0013,

    DW_LANG_Python = 0x0014,

    DW_LANG_OpenCL = 0x0015,
    DW_LANG_Go = 0x0016,
    DW_LANG_Modula3 = 0x0017,
    DW_LANG_Haskell = 0x0018,
    DW_LANG_C_plus_plus_03 = 0x0019,
    DW_LANG_C_plus_plus_11 = 0x001a,
    DW_LANG_OCaml = 0x001b,
    DW_LANG_Rust = 0x001c,
    DW_LANG_C11 = 0x001d,
    DW_LANG_Swift = 0x001e,
    DW_LANG_Julia = 0x001f,
    DW_LANG_Dylan = 0x0020,
    DW_LANG_C_plus_plus_14 = 0x0021,
    DW_LANG_Fortran03 = 0x0022,
    DW_LANG_Fortran08 = 0x0023,
    DW_LANG_RenderScript = 0x0024,

    DW_LANG_lo_user = 0x8000,
    DW_LANG_hi_user = 0xffff,


    DW_LANG_Mips_Assembler = 0x8001,

    DW_LANG_Upc = 0x8765,

    DW_LANG_HP_Bliss = 0x8003,
    DW_LANG_HP_Basic91 = 0x8004,
    DW_LANG_HP_Pascal91 = 0x8005,
    DW_LANG_HP_IMacro = 0x8006,
    DW_LANG_HP_Assembler = 0x8007,


    DW_LANG_Rust_old = 0x9000
  };


enum dwarf_macinfo_record_type
  {
    DW_MACINFO_define = 1,
    DW_MACINFO_undef = 2,
    DW_MACINFO_start_file = 3,
    DW_MACINFO_end_file = 4,
    DW_MACINFO_vendor_ext = 255
  };


enum dwarf_defaulted_attribute
  {
    DW_DEFAULTED_no = 0x00,
    DW_DEFAULTED_in_class = 0x01,
    DW_DEFAULTED_out_of_class = 0x02
  };


enum dwarf_macro_record_type
  {
    DW_MACRO_define = 0x01,
    DW_MACRO_undef = 0x02,
    DW_MACRO_start_file = 0x03,
    DW_MACRO_end_file = 0x04,
    DW_MACRO_define_strp = 0x05,
    DW_MACRO_undef_strp = 0x06,
    DW_MACRO_import = 0x07,
    DW_MACRO_define_sup = 0x08,
    DW_MACRO_undef_sup = 0x09,
    DW_MACRO_import_sup = 0x0a,
    DW_MACRO_define_strx = 0x0b,
    DW_MACRO_undef_strx = 0x0c,
    DW_MACRO_lo_user = 0xe0,
    DW_MACRO_hi_user = 0xff,


    DW_MACRO_GNU_define = 0x01,
    DW_MACRO_GNU_undef = 0x02,
    DW_MACRO_GNU_start_file = 0x03,
    DW_MACRO_GNU_end_file = 0x04,
    DW_MACRO_GNU_define_indirect = 0x05,
    DW_MACRO_GNU_undef_indirect = 0x06,
    DW_MACRO_GNU_transparent_include = 0x07,


    DW_MACRO_GNU_define_indirect_alt = 0x08,
    DW_MACRO_GNU_undef_indirect_alt = 0x09,
    DW_MACRO_GNU_transparent_include_alt = 0x0a,
    DW_MACRO_GNU_lo_user = 0xe0,
    DW_MACRO_GNU_hi_user = 0xff
  };


enum dwarf_range_list_entry
  {
    DW_RLE_end_of_list = 0x00,
    DW_RLE_base_addressx = 0x01,
    DW_RLE_startx_endx = 0x02,
    DW_RLE_startx_length = 0x03,
    DW_RLE_offset_pair = 0x04,
    DW_RLE_base_address = 0x05,
    DW_RLE_start_end = 0x06,
    DW_RLE_start_length = 0x07
  };
# 487 "./../include/dwarf2.h"
enum dwarf_sect
{
  DW_SECT_INFO = 1,
  DW_SECT_TYPES = 2,
  DW_SECT_ABBREV = 3,
  DW_SECT_LINE = 4,
  DW_SECT_LOC = 5,
  DW_SECT_STR_OFFSETS = 6,
  DW_SECT_MACINFO = 7,
  DW_SECT_MACRO = 8,
  DW_SECT_MAX = 8
};




enum dwarf_sect_v5
{
  DW_SECT_INFO_V5 = 1,
  DW_SECT_RESERVED_V5 = 2,
  DW_SECT_ABBREV_V5 = 3,
  DW_SECT_LINE_V5 = 4,
  DW_SECT_LOCLISTS_V5 = 5,
  DW_SECT_STR_OFFSETS_V5 = 6,
  DW_SECT_MACRO_V5 = 7,
  DW_SECT_RNGLISTS_V5 = 8,
  DW_SECT_MAX_V5 = 8
};







extern const char *get_DW_TAG_name (unsigned int tag);



extern const char *get_DW_AT_name (unsigned int attr);



extern const char *get_DW_FORM_name (unsigned int form);



extern const char *get_DW_OP_name (unsigned int op);



extern const char *get_DW_ATE_name (unsigned int enc);



extern const char *get_DW_CFA_name (unsigned int opc);



extern const char *get_DW_IDX_name (unsigned int idx);



extern const char *get_DW_UT_name (unsigned int ut);
# 22 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h" 2


typedef struct
{
  uint64_t li_length;
  uint16_t li_version;
  uint8_t li_address_size;
  uint8_t li_segment_size;
  uint64_t li_prologue_length;
  uint8_t li_min_insn_length;
  uint8_t li_max_ops_per_insn;
  uint8_t li_default_is_stmt;
  int8_t li_line_base;
  uint8_t li_line_range;
  uint8_t li_opcode_base;

  unsigned int li_offset_size;
}
DWARF2_Internal_LineInfo;


typedef struct
{
  uint64_t pn_length;
  unsigned short pn_version;
  uint64_t pn_offset;
  uint64_t pn_size;
}
DWARF2_Internal_PubNames;


typedef struct
{
  uint64_t cu_length;
  unsigned short cu_version;
  uint64_t cu_abbrev_offset;
  unsigned char cu_pointer_size;
  enum dwarf_unit_type cu_unit_type;
}
DWARF2_Internal_CompUnit;


typedef struct
{
  uint64_t ar_length;
  unsigned short ar_version;
  uint64_t ar_info_offset;
  unsigned char ar_pointer_size;
  unsigned char ar_segment_size;
}
DWARF2_Internal_ARange;



enum dwarf_section_display_enum
{
  abbrev = 0,
  aranges,
  frame,
  info,
  line,
  pubnames,
  gnu_pubnames,
  eh_frame,
  macinfo,
  macro,
  str,
  line_str,
  loc,
  loclists,
  loclists_dwo,
  pubtypes,
  gnu_pubtypes,
  ranges,
  rnglists,
  rnglists_dwo,
  static_func,
  static_vars,
  types,
  weaknames,
  gdb_index,
  debug_names,
  trace_info,
  trace_abbrev,
  trace_aranges,
  info_dwo,
  abbrev_dwo,
  types_dwo,
  line_dwo,
  loc_dwo,
  macro_dwo,
  macinfo_dwo,
  str_dwo,
  str_index,
  str_index_dwo,
  debug_addr,
  dwp_cu_index,
  dwp_tu_index,
  gnu_debuglink,
  gnu_debugaltlink,
  debug_sup,
  separate_debug_str,
  note_gnu_build_id,
  max
};

struct dwarf_section
{





  const char * uncompressed_name;
  const char * compressed_name;
  const char * xcoff_name;
  const char * name;


  const char * filename;
  unsigned char * start;
  uint64_t address;
  uint64_t size;
  enum dwarf_section_display_enum abbrev_sec;

  void * reloc_info;
  uint64_t num_relocs;
};



struct dwarf_section_display
{
  struct dwarf_section section;
  int (*display) (struct dwarf_section *, void *);
  int *enabled;
  
# 158 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h" 3 4
 _Bool 
# 158 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h"
      relocate;
};

extern struct dwarf_section_display debug_displays [];



typedef struct
{
  unsigned int pointer_size;
  unsigned int offset_size;
  int dwarf_version;
  uint64_t cu_offset;
  uint64_t base_address;


  uint64_t addr_base;


  uint64_t ranges_base;

  uint64_t * loc_offsets;

  uint64_t * loc_views;
  int * have_frame_base;


  unsigned int num_loc_offsets;
  unsigned int max_loc_offsets;
  unsigned int num_loc_views;
  uint64_t loclists_base;


  uint64_t * range_lists;
  unsigned int num_range_lists;
  unsigned int max_range_lists;
  uint64_t rnglists_base;
  uint64_t str_offsets_base;
}
debug_info;

typedef struct separate_info
{
  void * handle;
  const char * filename;
  struct separate_info * next;
} separate_info;

extern separate_info * first_separate_info;

extern unsigned int eh_addr_size;

extern int do_debug_info;
extern int do_debug_abbrevs;
extern int do_debug_lines;
extern int do_debug_pubnames;
extern int do_debug_pubtypes;
extern int do_debug_aranges;
extern int do_debug_ranges;
extern int do_debug_frames;
extern int do_debug_frames_interp;
extern int do_debug_macinfo;
extern int do_debug_str;
extern int do_debug_str_offsets;
extern int do_debug_loc;
extern int do_gdb_index;
extern int do_trace_info;
extern int do_trace_abbrevs;
extern int do_trace_aranges;
extern int do_debug_addr;
extern int do_debug_cu_index;
extern int do_wide;
extern int do_debug_links;
extern int do_follow_links;



extern 
# 235 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h" 3 4
      _Bool 
# 235 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h"
           do_checks;

extern int dwarf_cutoff_level;
extern unsigned long dwarf_start_die;

extern int dwarf_check;

extern void init_dwarf_regnames_by_elf_machine_code (unsigned int);
extern void init_dwarf_regnames_by_bfd_arch_and_mach (enum bfd_architecture arch,
            unsigned long mach);

extern 
# 246 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h" 3 4
      _Bool 
# 246 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h"
           load_debug_section (enum dwarf_section_display_enum, void *);
extern void free_debug_section (enum dwarf_section_display_enum);
extern 
# 248 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h" 3 4
      _Bool 
# 248 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h"
           load_separate_debug_files (void *, const char *);
extern void close_debug_file (void *);
extern void *open_debug_file (const char *);

extern void free_debug_memory (void);

extern int dwarf_select_sections_by_names (const char *);
extern int dwarf_select_sections_by_letters (const char *);
extern void dwarf_select_sections_all (void);

extern unsigned int * find_cu_tu_set (void *, unsigned int);

extern void * cmalloc (uint64_t, size_t);
extern void * xcalloc2 (uint64_t, size_t);
extern void * xcmalloc (uint64_t, size_t);
extern void * xcrealloc (void *, uint64_t, size_t);




extern 
# 268 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h" 3 4
      _Bool 
# 268 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h"
           reloc_at (struct dwarf_section *, uint64_t);

extern uint64_t read_leb128 (unsigned char *, const unsigned char *const,
        
# 271 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h" 3 4
       _Bool
# 271 "/doner/binutils/binutils-515f23e/binutils/./dwarf.h"
           , unsigned int *, int *);





static inline void
report_leb_status (int status)
{
  if ((status & 1) != 0)
    error (gettext ("end of data encountered whilst reading LEB\n"));
  else if ((status & 2) != 0)
    error (gettext ("read LEB value is too large to store in destination variable\n"));
}
# 65 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/ctf-api.h" 1
# 28 "./../include/ctf-api.h"
# 1 "./../include/ctf.h" 1
# 24 "./../include/ctf.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 25 "./../include/ctf.h" 2
# 146 "./../include/ctf.h"
typedef struct ctf_preamble
{
  unsigned short ctp_magic;
  unsigned char ctp_version;
  unsigned char ctp_flags;
} ctf_preamble_t;

typedef struct ctf_header_v2
{
  ctf_preamble_t cth_preamble;
  uint32_t cth_parlabel;
  uint32_t cth_parname;
  uint32_t cth_lbloff;
  uint32_t cth_objtoff;
  uint32_t cth_funcoff;
  uint32_t cth_varoff;
  uint32_t cth_typeoff;
  uint32_t cth_stroff;
  uint32_t cth_strlen;
} ctf_header_v2_t;

typedef struct ctf_header
{
  ctf_preamble_t cth_preamble;
  uint32_t cth_parlabel;
  uint32_t cth_parname;
  uint32_t cth_cuname;
  uint32_t cth_lbloff;
  uint32_t cth_objtoff;
  uint32_t cth_funcoff;
  uint32_t cth_objtidxoff;
  uint32_t cth_funcidxoff;
  uint32_t cth_varoff;
  uint32_t cth_typeoff;
  uint32_t cth_stroff;
  uint32_t cth_strlen;
} ctf_header_t;
# 219 "./../include/ctf.h"
typedef struct ctf_lblent
{
  uint32_t ctl_label;
  uint32_t ctl_type;
} ctf_lblent_t;

typedef struct ctf_varent
{
  uint32_t ctv_name;
  uint32_t ctv_type;
} ctf_varent_t;
# 241 "./../include/ctf.h"
typedef struct ctf_stype_v1
{
  uint32_t ctt_name;
  unsigned short ctt_info;







  __extension__
  union
  {
    unsigned short ctt_size;
    unsigned short ctt_type;
  };

} ctf_stype_v1_t;

typedef struct ctf_type_v1
{
  uint32_t ctt_name;
  unsigned short ctt_info;







  __extension__
  union
  {
    unsigned short ctt_size;
    unsigned short ctt_type;
  };

  uint32_t ctt_lsizehi;
  uint32_t ctt_lsizelo;
} ctf_type_v1_t;


typedef struct ctf_stype
{
  uint32_t ctt_name;
  uint32_t ctt_info;







  __extension__
  union
  {
    uint32_t ctt_size;
    uint32_t ctt_type;
  };

} ctf_stype_t;

typedef struct ctf_type
{
  uint32_t ctt_name;
  uint32_t ctt_info;







  __extension__
  union
  {
    uint32_t ctt_size;
    uint32_t ctt_type;
  };

  uint32_t ctt_lsizehi;
  uint32_t ctt_lsizelo;
} ctf_type_t;
# 492 "./../include/ctf.h"
typedef struct ctf_slice
{
  uint32_t cts_type;
  unsigned short cts_offset;
  unsigned short cts_bits;
} ctf_slice_t;

typedef struct ctf_array_v1
{
  unsigned short cta_contents;
  unsigned short cta_index;
  uint32_t cta_nelems;
} ctf_array_v1_t;

typedef struct ctf_array
{
  uint32_t cta_contents;
  uint32_t cta_index;
  uint32_t cta_nelems;
} ctf_array_t;
# 528 "./../include/ctf.h"
typedef struct ctf_member_v1
{
  uint32_t ctm_name;
  unsigned short ctm_type;
  unsigned short ctm_offset;
} ctf_member_v1_t;

typedef struct ctf_lmember_v1
{
  uint32_t ctlm_name;
  unsigned short ctlm_type;
  unsigned short ctlm_pad;
  uint32_t ctlm_offsethi;
  uint32_t ctlm_offsetlo;
} ctf_lmember_v1_t;

typedef struct ctf_member_v2
{
  uint32_t ctm_name;
  uint32_t ctm_offset;
  uint32_t ctm_type;
} ctf_member_t;

typedef struct ctf_lmember_v2
{
  uint32_t ctlm_name;
  uint32_t ctlm_offsethi;
  uint32_t ctlm_type;
  uint32_t ctlm_offsetlo;
} ctf_lmember_t;






typedef struct ctf_enum
{
  uint32_t cte_name;
  int32_t cte_value;
} ctf_enum_t;
# 587 "./../include/ctf.h"
struct ctf_archive
{


  uint64_t ctfa_magic;


  uint64_t ctfa_model;


  uint64_t ctfa_ndicts;


  uint64_t ctfa_names;



  uint64_t ctfa_ctfs;
};





typedef struct ctf_archive_modent
{
  uint64_t name_offset;
  uint64_t ctf_offset;
} ctf_archive_modent_t;
# 29 "./../include/ctf-api.h" 2
# 43 "./../include/ctf-api.h"
typedef struct ctf_dict ctf_dict_t;
typedef struct ctf_archive_internal ctf_archive_t;
typedef unsigned long ctf_id_t;




struct bfd;
# 61 "./../include/ctf-api.h"
typedef struct ctf_sect
{
  const char *cts_name;
  const void *cts_data;
  size_t cts_size;
  size_t cts_entsize;
} ctf_sect_t;






typedef struct ctf_link_sym
{




  const char *st_name;
  size_t st_nameidx;
  int st_nameidx_set;
  uint32_t st_symidx;
  uint32_t st_shndx;
  uint32_t st_type;
  uint32_t st_value;
} ctf_link_sym_t;
# 119 "./../include/ctf-api.h"
typedef enum ctf_sect_names
  {
   CTF_SECT_HEADER,
   CTF_SECT_LABEL,
   CTF_SECT_OBJT,
   CTF_SECT_OBJTIDX = CTF_SECT_OBJT,
   CTF_SECT_FUNC,
   CTF_SECT_FUNCIDX = CTF_SECT_FUNC,
   CTF_SECT_VAR,
   CTF_SECT_TYPE,
   CTF_SECT_STR
  } ctf_sect_names_t;





typedef struct ctf_encoding
{
  uint32_t cte_format;
  uint32_t cte_offset;
  uint32_t cte_bits;
} ctf_encoding_t;

typedef struct ctf_membinfo
{
  ctf_id_t ctm_type;
  unsigned long ctm_offset;
} ctf_membinfo_t;

typedef struct ctf_arinfo
{
  ctf_id_t ctr_contents;
  ctf_id_t ctr_index;
  uint32_t ctr_nelems;
} ctf_arinfo_t;

typedef struct ctf_funcinfo
{
  ctf_id_t ctc_return;
  uint32_t ctc_argc;
  uint32_t ctc_flags;
} ctf_funcinfo_t;

typedef struct ctf_lblinfo
{
  ctf_id_t ctb_type;
} ctf_lblinfo_t;

typedef struct ctf_snapshot_id
{
  unsigned long dtd_id;
  unsigned long snapshot_id;
} ctf_snapshot_id_t;
# 249 "./../include/ctf-api.h"
enum
  {


ECTF_FMT = 1000 , ECTF_BFDERR , ECTF_CTFVERS , ECTF_BFD_AMBIGUOUS , ECTF_SYMTAB , ECTF_SYMBAD , ECTF_STRBAD , ECTF_CORRUPT , ECTF_NOCTFDATA , ECTF_NOCTFBUF , ECTF_NOSYMTAB , ECTF_NOPARENT , ECTF_DMODEL , ECTF_LINKADDEDLATE , ECTF_ZALLOC , ECTF_DECOMPRESS , ECTF_STRTAB , ECTF_BADNAME , ECTF_BADID , ECTF_NOTSOU , ECTF_NOTENUM , ECTF_NOTSUE , ECTF_NOTINTFP , ECTF_NOTARRAY , ECTF_NOTREF , ECTF_NAMELEN , ECTF_NOTYPE , ECTF_SYNTAX , ECTF_NOTFUNC , ECTF_NOFUNCDAT , ECTF_NOTDATA , ECTF_NOTYPEDAT , ECTF_NOLABEL , ECTF_NOLABELDATA , ECTF_NOTSUP , ECTF_NOENUMNAM , ECTF_NOMEMBNAM , ECTF_RDONLY , ECTF_DTFULL , ECTF_FULL , ECTF_DUPLICATE , ECTF_CONFLICT , ECTF_OVERROLLBACK , ECTF_COMPRESS , ECTF_ARCREATE , ECTF_ARNNAME , ECTF_SLICEOVERFLOW , ECTF_DUMPSECTUNKNOWN , ECTF_DUMPSECTCHANGED , ECTF_NOTYET , ECTF_INTERNAL , ECTF_NONREPRESENTABLE , ECTF_NEXT_END , ECTF_NEXT_WRONGFUN , ECTF_NEXT_WRONGFP , ECTF_FLAGS , ECTF_NEEDSBFD , ECTF_INCOMPLETE , ECTF_NONAME


  };
# 286 "./../include/ctf-api.h"
typedef int ctf_visit_f (const char *name, ctf_id_t type, unsigned long offset,
    int depth, void *arg);
typedef int ctf_member_f (const char *name, ctf_id_t membtype,
     unsigned long offset, void *arg);
typedef int ctf_enum_f (const char *name, int val, void *arg);
typedef int ctf_variable_f (const char *name, ctf_id_t type, void *arg);
typedef int ctf_type_f (ctf_id_t type, void *arg);
typedef int ctf_type_all_f (ctf_id_t type, int flag, void *arg);
typedef int ctf_label_f (const char *name, const ctf_lblinfo_t *info,
    void *arg);
typedef int ctf_archive_member_f (ctf_dict_t *fp, const char *name, void *arg);
typedef int ctf_archive_raw_member_f (const char *name, const void *content,
          size_t len, void *arg);
typedef char *ctf_dump_decorate_f (ctf_sect_names_t sect,
       char *line, void *arg);

typedef struct ctf_dump_state ctf_dump_state_t;





typedef struct ctf_next ctf_next_t;
extern ctf_next_t *ctf_next_create (void);
extern void ctf_next_destroy (ctf_next_t *);
extern ctf_next_t *ctf_next_copy (ctf_next_t *);
# 325 "./../include/ctf-api.h"
extern ctf_archive_t *ctf_bfdopen (struct bfd *, int *);
extern ctf_archive_t *ctf_bfdopen_ctfsect (struct bfd *, const ctf_sect_t *,
        int *);
extern ctf_archive_t *ctf_fdopen (int fd, const char *filename,
      const char *target, int *errp);
extern ctf_archive_t *ctf_open (const char *filename,
    const char *target, int *errp);
extern void ctf_close (ctf_archive_t *);
extern ctf_sect_t ctf_getdatasect (const ctf_dict_t *);
extern ctf_sect_t ctf_getsymsect (const ctf_dict_t *);
extern ctf_sect_t ctf_getstrsect (const ctf_dict_t *);
extern void ctf_symsect_endianness (ctf_dict_t *, int little_endian);
extern ctf_archive_t *ctf_get_arc (const ctf_dict_t *);
extern ctf_archive_t *ctf_arc_open (const char *, int *);
extern ctf_archive_t *ctf_arc_bufopen (const ctf_sect_t *,
           const ctf_sect_t *,
           const ctf_sect_t *,
           int *);
extern void ctf_arc_symsect_endianness (ctf_archive_t *, int little_endian);
extern void ctf_arc_close (ctf_archive_t *);
extern ctf_dict_t *ctf_arc_lookup_symbol (ctf_archive_t *,
       unsigned long symidx,
       ctf_id_t *, int *errp);
extern ctf_dict_t *ctf_arc_lookup_symbol_name (ctf_archive_t *,
            const char *name,
            ctf_id_t *, int *errp);
extern void ctf_arc_flush_caches (ctf_archive_t *);
extern ctf_dict_t *ctf_dict_open (const ctf_archive_t *,
      const char *, int *);
extern ctf_dict_t *ctf_dict_open_sections (const ctf_archive_t *,
        const ctf_sect_t *,
        const ctf_sect_t *,
        const char *, int *);
extern size_t ctf_archive_count (const ctf_archive_t *);




extern ctf_dict_t *ctf_simple_open (const char *, size_t, const char *, size_t,
       size_t, const char *, size_t, int *);
extern ctf_dict_t *ctf_bufopen (const ctf_sect_t *, const ctf_sect_t *,
    const ctf_sect_t *, int *);
extern void ctf_ref (ctf_dict_t *);
extern void ctf_dict_close (ctf_dict_t *);

extern int ctf_arc_write (const char *, ctf_dict_t **, size_t,
     const char **, size_t);
extern int ctf_arc_write_fd (int, ctf_dict_t **, size_t, const char **,
        size_t);

extern const char *ctf_cuname (ctf_dict_t *);
extern int ctf_cuname_set (ctf_dict_t *, const char *);
extern ctf_dict_t *ctf_parent_dict (ctf_dict_t *);
extern const char *ctf_parent_name (ctf_dict_t *);
extern int ctf_parent_name_set (ctf_dict_t *, const char *);
extern int ctf_type_isparent (ctf_dict_t *, ctf_id_t);
extern int ctf_type_ischild (ctf_dict_t *, ctf_id_t);

extern int ctf_import (ctf_dict_t *, ctf_dict_t *);
extern int ctf_setmodel (ctf_dict_t *, int);
extern int ctf_getmodel (ctf_dict_t *);

extern void ctf_setspecific (ctf_dict_t *, void *);
extern void *ctf_getspecific (ctf_dict_t *);

extern int ctf_errno (ctf_dict_t *);
extern const char *ctf_errmsg (int);
extern int ctf_version (int);

extern int ctf_func_info (ctf_dict_t *, unsigned long, ctf_funcinfo_t *);
extern int ctf_func_args (ctf_dict_t *, unsigned long, uint32_t, ctf_id_t *);
extern int ctf_func_type_info (ctf_dict_t *, ctf_id_t, ctf_funcinfo_t *);
extern int ctf_func_type_args (ctf_dict_t *, ctf_id_t, uint32_t, ctf_id_t *);

extern ctf_id_t ctf_lookup_by_name (ctf_dict_t *, const char *);
extern ctf_id_t ctf_lookup_by_symbol (ctf_dict_t *, unsigned long);
extern ctf_id_t ctf_lookup_by_symbol_name (ctf_dict_t *, const char *);
extern ctf_id_t ctf_symbol_next (ctf_dict_t *, ctf_next_t **,
     const char **name, int functions);
extern ctf_id_t ctf_lookup_variable (ctf_dict_t *, const char *);

extern ctf_id_t ctf_type_resolve (ctf_dict_t *, ctf_id_t);
extern char *ctf_type_aname (ctf_dict_t *, ctf_id_t);
extern char *ctf_type_aname_raw (ctf_dict_t *, ctf_id_t);
extern ssize_t ctf_type_lname (ctf_dict_t *, ctf_id_t, char *, size_t);
extern char *ctf_type_name (ctf_dict_t *, ctf_id_t, char *, size_t);
extern const char *ctf_type_name_raw (ctf_dict_t *, ctf_id_t);
extern ssize_t ctf_type_size (ctf_dict_t *, ctf_id_t);
extern ssize_t ctf_type_align (ctf_dict_t *, ctf_id_t);
extern int ctf_type_kind (ctf_dict_t *, ctf_id_t);
extern int ctf_type_kind_forwarded (ctf_dict_t *, ctf_id_t);
extern ctf_id_t ctf_type_reference (ctf_dict_t *, ctf_id_t);
extern ctf_id_t ctf_type_pointer (ctf_dict_t *, ctf_id_t);
extern int ctf_type_encoding (ctf_dict_t *, ctf_id_t, ctf_encoding_t *);
extern int ctf_type_visit (ctf_dict_t *, ctf_id_t, ctf_visit_f *, void *);
extern int ctf_type_cmp (ctf_dict_t *, ctf_id_t, ctf_dict_t *, ctf_id_t);
extern int ctf_type_compat (ctf_dict_t *, ctf_id_t, ctf_dict_t *, ctf_id_t);

extern int ctf_member_info (ctf_dict_t *, ctf_id_t, const char *,
       ctf_membinfo_t *);
extern int ctf_array_info (ctf_dict_t *, ctf_id_t, ctf_arinfo_t *);

extern const char *ctf_enum_name (ctf_dict_t *, ctf_id_t, int);
extern int ctf_enum_value (ctf_dict_t *, ctf_id_t, const char *, int *);

extern void ctf_label_set (ctf_dict_t *, const char *);
extern const char *ctf_label_get (ctf_dict_t *);

extern const char *ctf_label_topmost (ctf_dict_t *);
extern int ctf_label_info (ctf_dict_t *, const char *, ctf_lblinfo_t *);

extern int ctf_member_count (ctf_dict_t *, ctf_id_t);
extern int ctf_member_iter (ctf_dict_t *, ctf_id_t, ctf_member_f *, void *);
extern ssize_t ctf_member_next (ctf_dict_t *, ctf_id_t, ctf_next_t **,
    const char **name, ctf_id_t *membtype,
    int flags);
extern int ctf_enum_iter (ctf_dict_t *, ctf_id_t, ctf_enum_f *, void *);
extern const char *ctf_enum_next (ctf_dict_t *, ctf_id_t, ctf_next_t **,
      int *);
extern int ctf_type_iter (ctf_dict_t *, ctf_type_f *, void *);
extern int ctf_type_iter_all (ctf_dict_t *, ctf_type_all_f *, void *);
extern ctf_id_t ctf_type_next (ctf_dict_t *, ctf_next_t **,
          int *flag, int want_hidden);
extern int ctf_label_iter (ctf_dict_t *, ctf_label_f *, void *);
extern int ctf_label_next (ctf_dict_t *, ctf_next_t **, const char **);
extern int ctf_variable_iter (ctf_dict_t *, ctf_variable_f *, void *);
extern ctf_id_t ctf_variable_next (ctf_dict_t *, ctf_next_t **,
       const char **);
extern int ctf_archive_iter (const ctf_archive_t *, ctf_archive_member_f *,
        void *);
extern ctf_dict_t *ctf_archive_next (const ctf_archive_t *, ctf_next_t **,
         const char **, int skip_parent, int *errp);





extern int ctf_archive_raw_iter (const ctf_archive_t *,
     ctf_archive_raw_member_f *, void *);
extern char *ctf_dump (ctf_dict_t *, ctf_dump_state_t **state,
         ctf_sect_names_t sect, ctf_dump_decorate_f *,
         void *arg);




extern char *ctf_errwarning_next (ctf_dict_t *, ctf_next_t **,
      int *is_warning, int *errp);

extern ctf_id_t ctf_add_array (ctf_dict_t *, uint32_t,
          const ctf_arinfo_t *);
extern ctf_id_t ctf_add_const (ctf_dict_t *, uint32_t, ctf_id_t);
extern ctf_id_t ctf_add_enum_encoded (ctf_dict_t *, uint32_t, const char *,
          const ctf_encoding_t *);
extern ctf_id_t ctf_add_enum (ctf_dict_t *, uint32_t, const char *);
extern ctf_id_t ctf_add_float (ctf_dict_t *, uint32_t,
          const char *, const ctf_encoding_t *);
extern ctf_id_t ctf_add_forward (ctf_dict_t *, uint32_t, const char *,
     uint32_t);
extern ctf_id_t ctf_add_function (ctf_dict_t *, uint32_t,
      const ctf_funcinfo_t *, const ctf_id_t *);
extern ctf_id_t ctf_add_integer (ctf_dict_t *, uint32_t, const char *,
     const ctf_encoding_t *);
extern ctf_id_t ctf_add_slice (ctf_dict_t *, uint32_t, ctf_id_t, const ctf_encoding_t *);
extern ctf_id_t ctf_add_pointer (ctf_dict_t *, uint32_t, ctf_id_t);
extern ctf_id_t ctf_add_type (ctf_dict_t *, ctf_dict_t *, ctf_id_t);
extern ctf_id_t ctf_add_typedef (ctf_dict_t *, uint32_t, const char *,
     ctf_id_t);
extern ctf_id_t ctf_add_restrict (ctf_dict_t *, uint32_t, ctf_id_t);
extern ctf_id_t ctf_add_struct (ctf_dict_t *, uint32_t, const char *);
extern ctf_id_t ctf_add_union (ctf_dict_t *, uint32_t, const char *);
extern ctf_id_t ctf_add_struct_sized (ctf_dict_t *, uint32_t, const char *,
          size_t);
extern ctf_id_t ctf_add_union_sized (ctf_dict_t *, uint32_t, const char *,
         size_t);
extern ctf_id_t ctf_add_unknown (ctf_dict_t *, uint32_t, const char *);
extern ctf_id_t ctf_add_volatile (ctf_dict_t *, uint32_t, ctf_id_t);

extern int ctf_add_enumerator (ctf_dict_t *, ctf_id_t, const char *, int);
extern int ctf_add_member (ctf_dict_t *, ctf_id_t, const char *, ctf_id_t);
extern int ctf_add_member_offset (ctf_dict_t *, ctf_id_t, const char *,
      ctf_id_t, unsigned long);
extern int ctf_add_member_encoded (ctf_dict_t *, ctf_id_t, const char *,
       ctf_id_t, unsigned long,
       const ctf_encoding_t);

extern int ctf_add_variable (ctf_dict_t *, const char *, ctf_id_t);

extern int ctf_add_objt_sym (ctf_dict_t *, const char *, ctf_id_t);
extern int ctf_add_func_sym (ctf_dict_t *, const char *, ctf_id_t);

extern int ctf_set_array (ctf_dict_t *, ctf_id_t, const ctf_arinfo_t *);

extern ctf_dict_t *ctf_create (int *);
extern int ctf_update (ctf_dict_t *);
extern ctf_snapshot_id_t ctf_snapshot (ctf_dict_t *);
extern int ctf_rollback (ctf_dict_t *, ctf_snapshot_id_t);
extern int ctf_discard (ctf_dict_t *);
extern int ctf_write (ctf_dict_t *, int);
extern int ctf_gzwrite (ctf_dict_t *fp, gzFile fd);
extern int ctf_compress_write (ctf_dict_t * fp, int fd);
extern unsigned char *ctf_write_mem (ctf_dict_t *, size_t *, size_t threshold);

extern int ctf_link_add_ctf (ctf_dict_t *, ctf_archive_t *, const char *);


typedef int ctf_link_variable_filter_f (ctf_dict_t *, const char *, ctf_id_t,
     void *);
extern int ctf_link_set_variable_filter (ctf_dict_t *,
      ctf_link_variable_filter_f *, void *);
extern int ctf_link (ctf_dict_t *, int flags);
typedef const char *ctf_link_strtab_string_f (uint32_t *offset, void *arg);
extern int ctf_link_add_strtab (ctf_dict_t *, ctf_link_strtab_string_f *,
    void *);
extern int ctf_link_add_linker_symbol (ctf_dict_t *, ctf_link_sym_t *);
extern int ctf_link_shuffle_syms (ctf_dict_t *);
extern unsigned char *ctf_link_write (ctf_dict_t *, size_t *size,
          size_t threshold);




extern int ctf_link_add_cu_mapping (ctf_dict_t *, const char *from,
        const char *to);
typedef char *ctf_link_memb_name_changer_f (ctf_dict_t *,
         const char *, void *);
extern void ctf_link_set_memb_name_changer
  (ctf_dict_t *, ctf_link_memb_name_changer_f *, void *);

extern void ctf_setdebug (int debug);
extern int ctf_getdebug (void);



struct ctf_file;
typedef struct ctf_dict ctf_file_t;
extern void ctf_file_close (ctf_file_t *);
extern ctf_dict_t *ctf_parent_file (ctf_dict_t *);
extern ctf_dict_t *ctf_arc_open_by_name (const ctf_archive_t *,
      const char *, int *);
extern ctf_dict_t *ctf_arc_open_by_name_sections (const ctf_archive_t *,
        const ctf_sect_t *,
        const ctf_sect_t *,
        const char *, int *);
# 66 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/sframe-api.h" 1
# 23 "./../include/sframe-api.h"
# 1 "./../include/sframe.h" 1
# 24 "./../include/sframe.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 25 "./../include/sframe.h" 2


# 1 "./../include/ansidecl.h" 1
# 28 "./../include/sframe.h" 2
# 125 "./../include/sframe.h"
typedef struct sframe_preamble
{
  uint16_t sfp_magic;
  uint8_t sfp_version;
  uint8_t sfp_flags;
} __attribute__ ((packed)) sframe_preamble;

typedef struct sframe_header
{
  sframe_preamble sfh_preamble;

  uint8_t sfh_abi_arch;






  int8_t sfh_cfa_fixed_fp_offset;





  int8_t sfh_cfa_fixed_ra_offset;




  uint8_t sfh_auxhdr_len;

  uint32_t sfh_num_fdes;

  uint32_t sfh_num_fres;

  uint32_t sfh_fre_len;

  uint32_t sfh_fdeoff;

  uint32_t sfh_freoff;
} __attribute__ ((packed)) sframe_header;
# 174 "./../include/sframe.h"
typedef struct sframe_func_desc_entry
{


  int32_t sfde_func_start_address;

  uint32_t sfde_func_size;


  uint32_t sfde_func_start_fre_off;

  uint32_t sfde_func_num_fres;
# 196 "./../include/sframe.h"
  uint8_t sfde_func_info;


  uint8_t sfde_func_rep_size;
  uint16_t sfde_func_padding2;
} __attribute__ ((packed)) sframe_func_desc_entry;
# 239 "./../include/sframe.h"
typedef struct sframe_fre_info
{
# 256 "./../include/sframe.h"
  uint8_t fre_info;
} sframe_fre_info;
# 302 "./../include/sframe.h"
typedef struct sframe_frame_row_entry_addr1
{


  uint8_t sfre_start_address;
  sframe_fre_info sfre_info;
} __attribute__ ((packed)) sframe_frame_row_entry_addr1;







typedef struct sframe_frame_row_entry_addr2
{


  uint16_t sfre_start_address;
  sframe_fre_info sfre_info;
} __attribute__ ((packed)) sframe_frame_row_entry_addr2;







typedef struct sframe_frame_row_entry_addr4
{


  uint32_t sfre_start_address;
  sframe_fre_info sfre_info;
} __attribute__ ((packed)) sframe_frame_row_entry_addr4;
# 24 "./../include/sframe-api.h" 2







typedef struct sframe_decoder_ctx sframe_decoder_ctx;
typedef struct sframe_encoder_ctx sframe_encoder_ctx;
# 47 "./../include/sframe-api.h"
typedef struct sframe_frame_row_entry
{
  uint32_t fre_start_addr;
  unsigned char fre_offsets[((2 * 2 * 3))];
  unsigned char fre_info;
} sframe_frame_row_entry;
# 77 "./../include/sframe-api.h"
enum
  {


SFRAME_ERR_VERSION_INVAL = 2000 , SFRAME_ERR_NOMEM , SFRAME_ERR_INVAL , SFRAME_ERR_BUF_INVAL , SFRAME_ERR_DCTX_INVAL , SFRAME_ERR_ECTX_INVAL , SFRAME_ERR_FDE_INVAL , SFRAME_ERR_FRE_INVAL , SFRAME_ERR_FDE_NOTFOUND , SFRAME_ERR_FDE_NOTSORTED , SFRAME_ERR_FRE_NOTFOUND , SFRAME_ERR_FREOFFSET_NOPRESENT


  };






extern const char *
sframe_errmsg (int error);



extern unsigned char
sframe_fde_create_func_info (uint32_t fre_type, uint32_t fde_type);



extern uint32_t
sframe_calc_fre_type (size_t func_size);





extern sframe_decoder_ctx *
sframe_decode (const char *cf_buf, size_t cf_size, int *errp);


extern void
sframe_decoder_free (sframe_decoder_ctx **dctx);


extern unsigned int
sframe_decoder_get_hdr_size (sframe_decoder_ctx *dctx);


extern uint8_t
sframe_decoder_get_abi_arch (sframe_decoder_ctx *dctx);


extern uint8_t
sframe_decoder_get_version (sframe_decoder_ctx *dctx);



extern uint32_t
sframe_decoder_get_num_fidx (sframe_decoder_ctx *dctx);


extern int8_t
sframe_decoder_get_fixed_fp_offset (sframe_decoder_ctx *dctx);


extern int8_t
sframe_decoder_get_fixed_ra_offset (sframe_decoder_ctx *dctx);





extern void *
sframe_get_funcdesc_with_addr (sframe_decoder_ctx *dctx, int32_t addr,
          int *errp);




extern int
sframe_find_fre (sframe_decoder_ctx *ctx, int32_t pc,
   sframe_frame_row_entry *frep);




extern int
sframe_decoder_get_fre (sframe_decoder_ctx *ctx,
   unsigned int func_idx,
   unsigned int fre_idx,
   sframe_frame_row_entry *fre);




extern int
sframe_decoder_get_funcdesc (sframe_decoder_ctx *ctx,
        unsigned int i,
        uint32_t *num_fres,
        uint32_t *func_size,
        int32_t *func_start_address,
        unsigned char *func_info);





extern int
sframe_decoder_get_funcdesc_v2 (sframe_decoder_ctx *ctx,
    unsigned int i,
    uint32_t *num_fres,
    uint32_t *func_size,
    int32_t *func_start_address,
    unsigned char *func_info,
    uint8_t *rep_block_size);


extern void
dump_sframe (sframe_decoder_ctx *decoder, uint64_t addr);


extern uint8_t
sframe_fre_get_base_reg_id (sframe_frame_row_entry *fre, int *errp);


extern int32_t
sframe_fre_get_cfa_offset (sframe_decoder_ctx *dtcx,
      sframe_frame_row_entry *fre, int *errp);


extern int32_t
sframe_fre_get_fp_offset (sframe_decoder_ctx *dctx,
     sframe_frame_row_entry *fre, int *errp);


extern int32_t
sframe_fre_get_ra_offset (sframe_decoder_ctx *dctx,
     sframe_frame_row_entry *fre, int *errp);



extern 
# 213 "./../include/sframe-api.h" 3 4
      _Bool

# 214 "./../include/sframe-api.h"
sframe_fre_get_ra_mangled_p (sframe_decoder_ctx *dctx,
        sframe_frame_row_entry *fre, int *errp);





extern sframe_encoder_ctx *
sframe_encode (uint8_t ver, uint8_t flags, uint8_t abi_arch,
        int8_t fixed_fp_offset, int8_t fixed_ra_offset, int *errp);


extern void
sframe_encoder_free (sframe_encoder_ctx **encoder);


extern unsigned int
sframe_encoder_get_hdr_size (sframe_encoder_ctx *encoder);


extern uint8_t
sframe_encoder_get_abi_arch (sframe_encoder_ctx *encoder);


extern uint8_t
sframe_encoder_get_version (sframe_encoder_ctx *encoder);



extern uint32_t
sframe_encoder_get_num_fidx (sframe_encoder_ctx *encoder);



extern int
sframe_encoder_add_fre (sframe_encoder_ctx *encoder,
   unsigned int func_idx,
   sframe_frame_row_entry *frep);



extern int
sframe_encoder_add_funcdesc (sframe_encoder_ctx *encoder,
        int32_t start_addr,
        uint32_t func_size,
        unsigned char func_info,
        uint32_t num_fres);



extern int
sframe_encoder_add_funcdesc_v2 (sframe_encoder_ctx *encoder,
    int32_t start_addr,
    uint32_t func_size,
    unsigned char func_info,
    uint8_t rep_block_size,
    uint32_t num_fres);



extern char *
sframe_encoder_write (sframe_encoder_ctx *encoder,
        size_t *encoded_size, int *errp);
# 67 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/demangle.h" 1
# 32 "./../include/demangle.h"
# 1 "./../include/libiberty.h" 1
# 45 "./../include/libiberty.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 46 "./../include/libiberty.h" 2
# 55 "./../include/libiberty.h"
extern void unlock_stream (FILE *);





extern void unlock_std_streams (void);





extern FILE *fopen_unlocked (const char *, const char *);
extern FILE *fdopen_unlocked (int, const char *);
extern FILE *freopen_unlocked (const char *, const char *, FILE *);




extern char **buildargv (const char *) __attribute__ ((__malloc__));



extern void freeargv (char **);




extern char **dupargv (char * const *) __attribute__ ((__malloc__));



extern void expandargv (int *, char ***);



extern int writeargv (char * const *, FILE *);



extern int countargv (char * const *);
# 112 "./../include/libiberty.h"
extern char *basename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));
# 123 "./../include/libiberty.h"
extern const char *lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));




extern const char *dos_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));





extern const char *unix_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));



extern char *lrealpath (const char *);



extern int is_valid_fd (int fd);





extern char *concat (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));
# 157 "./../include/libiberty.h"
extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));





extern unsigned long concat_length (const char *, ...) __attribute__ ((__sentinel__));






extern char *concat_copy (char *, const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__sentinel__));






extern char *concat_copy2 (const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));



extern char *libiberty_concat_ptr;
# 193 "./../include/libiberty.h"
extern int fdmatch (int fd1, int fd2);
# 205 "./../include/libiberty.h"
extern char * getpwd (void);
# 218 "./../include/libiberty.h"
extern long get_run_time (void);




extern char *make_relative_prefix (const char *, const char *,
                                   const char *) __attribute__ ((__malloc__));





extern char *make_relative_prefix_ignore_links (const char *, const char *,
      const char *) __attribute__ ((__malloc__));




extern const char *choose_tmpdir (void) __attribute__ ((__returns_nonnull__));



extern char *choose_temp_base (void) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *make_temp_file (const char *) __attribute__ ((__malloc__));




extern char *make_temp_file_with_prefix (const char *, const char *) __attribute__ ((__malloc__));



extern int unlink_if_ordinary (const char *);



extern const char *spaces (int count);




extern int errno_max (void);




extern const char *strerrno (int);



extern int strtoerrno (const char *);



extern char *xstrerror (int) __attribute__ ((__returns_nonnull__));




extern int signo_max (void);
# 292 "./../include/libiberty.h"
extern const char *strsigno (int);



extern int strtosigno (const char *);



extern int xatexit (void (*fn) (void));



extern void xexit (int status) __attribute__ ((__noreturn__));



extern void xmalloc_set_program_name (const char *);


extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));





extern void *xmalloc (size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (1))) __attribute__ ((warn_unused_result));





extern void *xrealloc (void *, size_t) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (2))) __attribute__ ((warn_unused_result));




extern void *xcalloc (size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((alloc_size (1, 2))) __attribute__ ((warn_unused_result));



extern char *xstrdup (const char *) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));



extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));



extern void *xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((warn_unused_result));


extern double physmem_total (void);
extern double physmem_available (void);


extern unsigned int xcrc32 (const unsigned char *, int, unsigned int);
# 391 "./../include/libiberty.h"
extern const unsigned char _hex_value[256];
extern void hex_init (void);
# 428 "./../include/libiberty.h"
extern struct pex_obj *pex_init (int flags, const char *pname,
     const char *tempbase) __attribute__ ((__returns_nonnull__));
# 528 "./../include/libiberty.h"
extern const char *pex_run (struct pex_obj *obj, int flags,
       const char *executable, char * const *argv,
       const char *outname, const char *errname,
       int *err);
# 543 "./../include/libiberty.h"
extern const char *pex_run_in_environment (struct pex_obj *obj, int flags,
                      const char *executable,
                                           char * const *argv,
                                           char * const *env,
                              const char *outname,
        const char *errname, int *err);





extern FILE *pex_input_file (struct pex_obj *obj, int flags,
                             const char *in_name);






extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);







extern FILE *pex_read_output (struct pex_obj *, int binary);







extern FILE *pex_read_err (struct pex_obj *, int binary);





extern int pex_get_status (struct pex_obj *, int count, int *vector);






struct pex_time
{
  unsigned long user_seconds;
  unsigned long user_microseconds;
  unsigned long system_seconds;
  unsigned long system_microseconds;
};

extern int pex_get_times (struct pex_obj *, int count,
     struct pex_time *vector);




extern void pex_free (struct pex_obj *);
# 618 "./../include/libiberty.h"
extern const char *pex_one (int flags, const char *executable,
       char * const *argv, const char *pname,
       const char *outname, const char *errname,
       int *status, int *err);
# 637 "./../include/libiberty.h"
extern int pexecute (const char *, char * const *, const char *,
                     const char *, char **, char **, int);



extern int pwait (int, int *, int);



extern void *bsearch_r (const void *, const void *,
   size_t, size_t,
   int (*)(const void *, const void *, void *),
   void *);
# 661 "./../include/libiberty.h"
extern char *xasprintf (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));
# 673 "./../include/libiberty.h"
extern char *xvasprintf (const char *, va_list) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));
# 717 "./../include/libiberty.h"
extern void setproctitle (const char *name, ...);


extern void stack_limit_increase (unsigned long);
# 730 "./../include/libiberty.h"
extern void *C_alloca (size_t) __attribute__ ((__malloc__));
# 33 "./../include/demangle.h" 2
# 83 "./../include/demangle.h"
extern enum demangling_styles
{
  no_demangling = -1,
  unknown_demangling = 0,
  auto_demangling = (1 << 8),
  gnu_v3_demangling = (1 << 14),
  java_demangling = (1 << 2),
  gnat_demangling = (1 << 15),
  dlang_demangling = (1 << 16),
  rust_demangling = (1 << 17)
} current_demangling_style;
# 118 "./../include/demangle.h"
extern const struct demangler_engine
{
  const char *const demangling_style_name;
  const enum demangling_styles demangling_style;
  const char *const demangling_style_doc;
} libiberty_demanglers[];

extern char *
cplus_demangle (const char *mangled, int options);



extern enum demangling_styles
cplus_demangle_set_style (enum demangling_styles style);

extern enum demangling_styles
cplus_demangle_name_to_style (const char *name);


typedef void (*demangle_callbackref) (const char *, size_t, void *);




extern int
cplus_demangle_v3_callback (const char *mangled, int options,
                            demangle_callbackref callback, void *opaque);

extern char*
cplus_demangle_v3 (const char *mangled, int options);

extern int
java_demangle_v3_callback (const char *mangled,
                           demangle_callbackref callback, void *opaque);

extern char*
java_demangle_v3 (const char *mangled);

char *
ada_demangle (const char *mangled, int options);

extern char *
dlang_demangle (const char *mangled, int options);

extern int
rust_demangle_callback (const char *mangled, int options,
                        demangle_callbackref callback, void *opaque);


extern char *
rust_demangle (const char *mangled, int options);

enum gnu_v3_ctor_kinds {
  gnu_v3_complete_object_ctor = 1,
  gnu_v3_base_object_ctor,
  gnu_v3_complete_object_allocating_ctor,



  gnu_v3_unified_ctor,
  gnu_v3_object_ctor_group
};





extern enum gnu_v3_ctor_kinds
 is_gnu_v3_mangled_ctor (const char *name);


enum gnu_v3_dtor_kinds {
  gnu_v3_deleting_dtor = 1,
  gnu_v3_complete_object_dtor,
  gnu_v3_base_object_dtor,



  gnu_v3_unified_dtor,
  gnu_v3_object_dtor_group
};





extern enum gnu_v3_dtor_kinds
 is_gnu_v3_mangled_dtor (const char *name);
# 221 "./../include/demangle.h"
enum demangle_component_type
{

  DEMANGLE_COMPONENT_NAME,



  DEMANGLE_COMPONENT_QUAL_NAME,


  DEMANGLE_COMPONENT_LOCAL_NAME,


  DEMANGLE_COMPONENT_TYPED_NAME,


  DEMANGLE_COMPONENT_TEMPLATE,


  DEMANGLE_COMPONENT_TEMPLATE_PARAM,

  DEMANGLE_COMPONENT_FUNCTION_PARAM,


  DEMANGLE_COMPONENT_CTOR,

  DEMANGLE_COMPONENT_DTOR,


  DEMANGLE_COMPONENT_VTABLE,


  DEMANGLE_COMPONENT_VTT,



  DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE,


  DEMANGLE_COMPONENT_TYPEINFO,


  DEMANGLE_COMPONENT_TYPEINFO_NAME,


  DEMANGLE_COMPONENT_TYPEINFO_FN,


  DEMANGLE_COMPONENT_THUNK,


  DEMANGLE_COMPONENT_VIRTUAL_THUNK,


  DEMANGLE_COMPONENT_COVARIANT_THUNK,

  DEMANGLE_COMPONENT_JAVA_CLASS,


  DEMANGLE_COMPONENT_GUARD,

  DEMANGLE_COMPONENT_TLS_INIT,
  DEMANGLE_COMPONENT_TLS_WRAPPER,


  DEMANGLE_COMPONENT_REFTEMP,


  DEMANGLE_COMPONENT_HIDDEN_ALIAS,


  DEMANGLE_COMPONENT_SUB_STD,


  DEMANGLE_COMPONENT_RESTRICT,


  DEMANGLE_COMPONENT_VOLATILE,


  DEMANGLE_COMPONENT_CONST,


  DEMANGLE_COMPONENT_RESTRICT_THIS,


  DEMANGLE_COMPONENT_VOLATILE_THIS,


  DEMANGLE_COMPONENT_CONST_THIS,


  DEMANGLE_COMPONENT_REFERENCE_THIS,


  DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS,



  DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,


  DEMANGLE_COMPONENT_POINTER,


  DEMANGLE_COMPONENT_REFERENCE,


  DEMANGLE_COMPONENT_RVALUE_REFERENCE,

  DEMANGLE_COMPONENT_COMPLEX,

  DEMANGLE_COMPONENT_IMAGINARY,

  DEMANGLE_COMPONENT_BUILTIN_TYPE,

  DEMANGLE_COMPONENT_VENDOR_TYPE,



  DEMANGLE_COMPONENT_FUNCTION_TYPE,



  DEMANGLE_COMPONENT_ARRAY_TYPE,



  DEMANGLE_COMPONENT_PTRMEM_TYPE,

  DEMANGLE_COMPONENT_FIXED_TYPE,


  DEMANGLE_COMPONENT_VECTOR_TYPE,


  DEMANGLE_COMPONENT_ARGLIST,



  DEMANGLE_COMPONENT_TEMPLATE_ARGLIST,


  DEMANGLE_COMPONENT_TPARM_OBJ,


  DEMANGLE_COMPONENT_INITIALIZER_LIST,


  DEMANGLE_COMPONENT_OPERATOR,


  DEMANGLE_COMPONENT_EXTENDED_OPERATOR,


  DEMANGLE_COMPONENT_CAST,



  DEMANGLE_COMPONENT_CONVERSION,

  DEMANGLE_COMPONENT_NULLARY,


  DEMANGLE_COMPONENT_UNARY,


  DEMANGLE_COMPONENT_BINARY,


  DEMANGLE_COMPONENT_BINARY_ARGS,


  DEMANGLE_COMPONENT_TRINARY,


  DEMANGLE_COMPONENT_TRINARY_ARG1,


  DEMANGLE_COMPONENT_TRINARY_ARG2,


  DEMANGLE_COMPONENT_LITERAL,






  DEMANGLE_COMPONENT_LITERAL_NEG,


  DEMANGLE_COMPONENT_VENDOR_EXPR,


  DEMANGLE_COMPONENT_JAVA_RESOURCE,


  DEMANGLE_COMPONENT_COMPOUND_NAME,

  DEMANGLE_COMPONENT_CHARACTER,

  DEMANGLE_COMPONENT_NUMBER,

  DEMANGLE_COMPONENT_DECLTYPE,

  DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS,

  DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS,

  DEMANGLE_COMPONENT_LAMBDA,

  DEMANGLE_COMPONENT_DEFAULT_ARG,

  DEMANGLE_COMPONENT_UNNAMED_TYPE,


  DEMANGLE_COMPONENT_TRANSACTION_CLONE,



  DEMANGLE_COMPONENT_NONTRANSACTION_CLONE,

  DEMANGLE_COMPONENT_PACK_EXPANSION,

  DEMANGLE_COMPONENT_TAGGED_NAME,

  DEMANGLE_COMPONENT_TRANSACTION_SAFE,

  DEMANGLE_COMPONENT_CLONE,
  DEMANGLE_COMPONENT_NOEXCEPT,
  DEMANGLE_COMPONENT_THROW_SPEC,

  DEMANGLE_COMPONENT_STRUCTURED_BINDING,

  DEMANGLE_COMPONENT_MODULE_NAME,
  DEMANGLE_COMPONENT_MODULE_PARTITION,
  DEMANGLE_COMPONENT_MODULE_ENTITY,
  DEMANGLE_COMPONENT_MODULE_INIT,

  DEMANGLE_COMPONENT_TEMPLATE_HEAD,
  DEMANGLE_COMPONENT_TEMPLATE_TYPE_PARM,
  DEMANGLE_COMPONENT_TEMPLATE_NON_TYPE_PARM,
  DEMANGLE_COMPONENT_TEMPLATE_TEMPLATE_PARM,
  DEMANGLE_COMPONENT_TEMPLATE_PACK_PARM,



  DEMANGLE_COMPONENT_EXTENDED_BUILTIN_TYPE

};



struct demangle_operator_info;
struct demangle_builtin_type_info;






struct demangle_component
{

  enum demangle_component_type type;




  int d_printing;
  int d_counting;

  union
  {

    struct
    {


      const char *s;
      int len;
    } s_name;


    struct
    {

      const struct demangle_operator_info *op;
    } s_operator;


    struct
    {

      int args;

      struct demangle_component *name;
    } s_extended_operator;


    struct
    {

      struct demangle_component *length;

      short accum;

      short sat;
    } s_fixed;


    struct
    {

      enum gnu_v3_ctor_kinds kind;

      struct demangle_component *name;
    } s_ctor;


    struct
    {

      enum gnu_v3_dtor_kinds kind;

      struct demangle_component *name;
    } s_dtor;


    struct
    {

      const struct demangle_builtin_type_info *type;
    } s_builtin;


    struct
    {

      const struct demangle_builtin_type_info *type;
      short arg;
      char suffix;
    } s_extended_builtin;


    struct
    {

      const char* string;

      int len;
    } s_string;


    struct
    {

      long number;
    } s_number;


    struct
    {
      int character;
    } s_character;


    struct
    {

      struct demangle_component *left;

      struct demangle_component *right;
    } s_binary;

    struct
    {

      struct demangle_component *sub;

      int num;
    } s_unary_num;

  } u;
};
# 616 "./../include/demangle.h"
extern int
cplus_demangle_fill_component (struct demangle_component *fill,
                               enum demangle_component_type,
                               struct demangle_component *left,
                               struct demangle_component *right);




extern int
cplus_demangle_fill_name (struct demangle_component *fill,
                          const char *, int);





extern int
cplus_demangle_fill_builtin_type (struct demangle_component *fill,
                                  const char *type_name);







extern int
cplus_demangle_fill_operator (struct demangle_component *fill,
                              const char *opname, int args);





extern int
cplus_demangle_fill_extended_operator (struct demangle_component *fill,
                                       int numargs,
                                       struct demangle_component *nm);




extern int
cplus_demangle_fill_ctor (struct demangle_component *fill,
                          enum gnu_v3_ctor_kinds kind,
                          struct demangle_component *name);




extern int
cplus_demangle_fill_dtor (struct demangle_component *fill,
                          enum gnu_v3_dtor_kinds kind,
                          struct demangle_component *name);
# 680 "./../include/demangle.h"
extern struct demangle_component *
cplus_demangle_v3_components (const char *mangled, int options, void **mem);
# 695 "./../include/demangle.h"
extern char *
cplus_demangle_print (int options,
                      struct demangle_component *tree,
                      int estimated_length,
                      size_t *p_allocated_size);
# 715 "./../include/demangle.h"
extern int
cplus_demangle_print_callback (int options,
                               struct demangle_component *tree,
                               demangle_callbackref callback, void *opaque);
# 68 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2

# 1 "./../include/elf/common.h" 1
# 70 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/external.h" 1
# 52 "./../include/elf/external.h"
typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[4];
  unsigned char e_phoff[4];
  unsigned char e_shoff[4];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf32_External_Ehdr;

typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[8];
  unsigned char e_phoff[8];
  unsigned char e_shoff[8];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf64_External_Ehdr;



typedef struct {
  unsigned char p_type[4];
  unsigned char p_offset[4];
  unsigned char p_vaddr[4];
  unsigned char p_paddr[4];
  unsigned char p_filesz[4];
  unsigned char p_memsz[4];
  unsigned char p_flags[4];
  unsigned char p_align[4];
} Elf32_External_Phdr;

typedef struct {
  unsigned char p_type[4];
  unsigned char p_flags[4];
  unsigned char p_offset[8];
  unsigned char p_vaddr[8];
  unsigned char p_paddr[8];
  unsigned char p_filesz[8];
  unsigned char p_memsz[8];
  unsigned char p_align[8];
} Elf64_External_Phdr;



typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[4];
  unsigned char sh_addr[4];
  unsigned char sh_offset[4];
  unsigned char sh_size[4];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[4];
  unsigned char sh_entsize[4];
} Elf32_External_Shdr;

typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[8];
  unsigned char sh_addr[8];
  unsigned char sh_offset[8];
  unsigned char sh_size[8];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[8];
  unsigned char sh_entsize[8];
} Elf64_External_Shdr;



typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_size[4];
  unsigned char ch_addralign[4];
} Elf32_External_Chdr;

typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_reserved[4];
  unsigned char ch_size[8];
  unsigned char ch_addralign[8];
} Elf64_External_Chdr;



typedef struct {
  unsigned char st_name[4];
  unsigned char st_value[4];
  unsigned char st_size[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
} Elf32_External_Sym;

typedef struct {
  unsigned char st_name[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
  unsigned char st_value[8];
  unsigned char st_size[8];
} Elf64_External_Sym;

typedef struct {
  unsigned char est_shndx[4];
} Elf_External_Sym_Shndx;



typedef struct {
  unsigned char namesz[4];
  unsigned char descsz[4];
  unsigned char type[4];
  char name[1];
} Elf_External_Note;
# 203 "./../include/elf/external.h"
typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
} Elf32_External_Rel;

typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
  unsigned char r_addend[4];
} Elf32_External_Rela;

typedef struct {
  unsigned char r_data[4];
} Elf32_External_Relr;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
} Elf64_External_Rel;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
  unsigned char r_addend[8];
} Elf64_External_Rela;

typedef struct {
  unsigned char r_data[8];
} Elf64_External_Relr;



typedef struct {
  unsigned char d_tag[4];
  union {
    unsigned char d_val[4];
    unsigned char d_ptr[4];
  } d_un;
} Elf32_External_Dyn;

typedef struct {
  unsigned char d_tag[8];
  union {
    unsigned char d_val[8];
    unsigned char d_ptr[8];
  } d_un;
} Elf64_External_Dyn;







typedef struct {
  unsigned char vd_version[2];
  unsigned char vd_flags[2];
  unsigned char vd_ndx[2];
  unsigned char vd_cnt[2];
  unsigned char vd_hash[4];
  unsigned char vd_aux[4];
  unsigned char vd_next[4];
} Elf_External_Verdef;



typedef struct {
  unsigned char vda_name[4];
  unsigned char vda_next[4];
} Elf_External_Verdaux;



typedef struct {
  unsigned char vn_version[2];
  unsigned char vn_cnt[2];
  unsigned char vn_file[4];
  unsigned char vn_aux[4];
  unsigned char vn_next[4];
} Elf_External_Verneed;



typedef struct {
  unsigned char vna_hash[4];
  unsigned char vna_flags[2];
  unsigned char vna_other[2];
  unsigned char vna_name[4];
  unsigned char vna_next[4];
} Elf_External_Vernaux;




typedef struct {
  unsigned char vs_vers[2];
} __attribute__ ((packed)) Elf_External_Versym;


typedef struct
{
  unsigned char si_boundto[2];
  unsigned char si_flags[2];
} Elf_External_Syminfo;



typedef struct
{
  unsigned char a_type[4];
  unsigned char a_val[4];
} Elf32_External_Auxv;

typedef struct
{
  unsigned char a_type[8];
  unsigned char a_val[8];
} Elf64_External_Auxv;
# 71 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/internal.h" 1
# 67 "./../include/elf/internal.h"
typedef struct elf_internal_ehdr {
  unsigned char e_ident[16];
  bfd_vma e_entry;
  bfd_size_type e_phoff;
  bfd_size_type e_shoff;
  unsigned long e_version;
  unsigned long e_flags;
  unsigned short e_type;
  unsigned short e_machine;
  unsigned int e_ehsize;
  unsigned int e_phentsize;
  unsigned int e_phnum;
  unsigned int e_shentsize;
  unsigned int e_shnum;
  unsigned int e_shstrndx;
} Elf_Internal_Ehdr;



struct elf_internal_phdr {
  unsigned long p_type;
  unsigned long p_flags;
  bfd_vma p_offset;
  bfd_vma p_vaddr;
  bfd_vma p_paddr;
  bfd_vma p_filesz;
  bfd_vma p_memsz;
  bfd_vma p_align;

};

typedef struct elf_internal_phdr Elf_Internal_Phdr;



typedef struct elf_internal_shdr {
  unsigned int sh_name;
  unsigned int sh_type;
  bfd_vma sh_flags;
  bfd_vma sh_addr;

  file_ptr sh_offset;
  bfd_size_type sh_size;
  unsigned int sh_link;
  unsigned int sh_info;
  bfd_vma sh_addralign;
  bfd_size_type sh_entsize;


  asection * bfd_section;
  unsigned char *contents;
} Elf_Internal_Shdr;



typedef struct elf_internal_chdr {
  unsigned int ch_type;
  bfd_size_type ch_size;
  bfd_vma ch_addralign;
} Elf_Internal_Chdr;



struct elf_internal_sym {
  bfd_vma st_value;
  bfd_vma st_size;
  unsigned long st_name;
  unsigned char st_info;
  unsigned char st_other;
  unsigned char st_target_internal;
  unsigned int st_shndx;
};

typedef struct elf_internal_sym Elf_Internal_Sym;



typedef struct elf_internal_note {
  unsigned long namesz;
  unsigned long descsz;
  unsigned long type;
  char * namedata;
  char * descdata;
  bfd_vma descpos;
} Elf_Internal_Note;



typedef struct elf_internal_rela {
  bfd_vma r_offset;
  bfd_vma r_info;
  bfd_vma r_addend;
} Elf_Internal_Rela;



typedef struct elf_internal_dyn {

  bfd_vma d_tag;
  union {

    bfd_vma d_val;
    bfd_vma d_ptr;
  } d_un;
} Elf_Internal_Dyn;



typedef struct elf_internal_verdef {
  unsigned short vd_version;
  unsigned short vd_flags;
  unsigned short vd_ndx;
  unsigned short vd_cnt;
  unsigned long vd_hash;
  unsigned long vd_aux;
  unsigned long vd_next;



  bfd *vd_bfd;
  const char *vd_nodename;
  struct elf_internal_verdef *vd_nextdef;
  struct elf_internal_verdaux *vd_auxptr;
  unsigned int vd_exp_refno;
} Elf_Internal_Verdef;



typedef struct elf_internal_verdaux {
  unsigned long vda_name;
  unsigned long vda_next;



  const char *vda_nodename;
  struct elf_internal_verdaux *vda_nextptr;
} Elf_Internal_Verdaux;



typedef struct elf_internal_verneed {
  unsigned short vn_version;
  unsigned short vn_cnt;
  unsigned long vn_file;
  unsigned long vn_aux;
  unsigned long vn_next;



  bfd *vn_bfd;
  const char *vn_filename;
  struct elf_internal_vernaux *vn_auxptr;
  struct elf_internal_verneed *vn_nextref;
} Elf_Internal_Verneed;



typedef struct elf_internal_vernaux {
  unsigned long vna_hash;
  unsigned short vna_flags;
  unsigned short vna_other;
  unsigned long vna_name;
  unsigned long vna_next;



  const char *vna_nodename;
  struct elf_internal_vernaux *vna_nextptr;
} Elf_Internal_Vernaux;




typedef struct elf_internal_versym {
  unsigned short vs_vers;
} Elf_Internal_Versym;


typedef struct
{
  unsigned short int si_boundto;
  unsigned short int si_flags;
} Elf_Internal_Syminfo;


typedef struct
{
  bfd_vma a_type;
  bfd_vma a_val;
} Elf_Internal_Auxv;





struct elf_segment_map
{

  struct elf_segment_map *next;

  unsigned long p_type;

  unsigned long p_flags;

  bfd_vma p_paddr;

  bfd_vma p_vaddr_offset;

  bfd_vma p_align;

  bfd_vma p_size;


  unsigned int p_flags_valid : 1;


  unsigned int p_paddr_valid : 1;


  unsigned int p_align_valid : 1;


  unsigned int p_size_valid : 1;

  unsigned int includes_filehdr : 1;

  unsigned int includes_phdrs : 1;




  unsigned int no_sort_lma : 1;

  unsigned int idx;

  unsigned int count;

  asection *sections[1];
};
# 72 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2







# 1 "./../include/elf/h8.h" 1
# 23 "./../include/elf/h8.h"
# 1 "./../include/elf/reloc-macros.h" 1
# 24 "./../include/elf/h8.h" 2



enum elf_h8_reloc_type {
  R_H8_NONE = 0,
  R_H8_DIR32 = 1,
  R_H8_DIR32_28 = 2,
  R_H8_DIR32_24 = 3,
  R_H8_DIR32_16 = 4,
  R_H8_DIR32U = 6,
  R_H8_DIR32U_28 = 7,
  R_H8_DIR32U_24 = 8,
  R_H8_DIR32U_20 = 9,
  R_H8_DIR32U_16 = 10,
  R_H8_DIR24 = 11,
  R_H8_DIR24_20 = 12,
  R_H8_DIR24_16 = 13,
  R_H8_DIR24U = 14,
  R_H8_DIR24U_20 = 15,
  R_H8_DIR24U_16 = 16,
  R_H8_DIR16 = 17,
  R_H8_DIR16U = 18,
  R_H8_DIR16S_32 = 19,
  R_H8_DIR16S_28 = 20,
  R_H8_DIR16S_24 = 21,
  R_H8_DIR16S_20 = 22,
  R_H8_DIR16S = 23,
  R_H8_DIR8 = 24,
  R_H8_DIR8U = 25,
  R_H8_DIR8Z_32 = 26,
  R_H8_DIR8Z_28 = 27,
  R_H8_DIR8Z_24 = 28,
  R_H8_DIR8Z_20 = 29,
  R_H8_DIR8Z_16 = 30,
  R_H8_PCREL16 = 31,
  R_H8_PCREL8 = 32,
  R_H8_BPOS = 33,
  R_H8_FIRST_INVALID_DIR_RELOC = 34,
  R_H8_LAST_INVALID_DIR_RELOC = 58,
  R_H8_DIR16A8 = 59,
  R_H8_DIR16R8 = 60,
  R_H8_DIR24A8 = 61,
  R_H8_DIR24R8 = 62,
  R_H8_DIR32A16 = 63,
  R_H8_DISP32A16 = 64,
  R_H8_ABS32 = 65,
  R_H8_ABS32A16 = 127,
  R_H8_SYM = 128,
  R_H8_OPneg = 129,
  R_H8_OPadd = 130,
  R_H8_OPsub = 131,
  R_H8_OPmul = 132,
  R_H8_OPdiv = 133,
  R_H8_OPshla = 134,
  R_H8_OPshra = 135,
  R_H8_OPsctsize = 136,
  R_H8_OPhword = 137,
  R_H8_OPlword = 138,
  R_H8_OPhigh = 139,
  R_H8_OPlow = 140,
  R_H8_OPscttop = 141,
R_H8_max };
# 80 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 97 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
# 1 "./../include/elf/aarch64.h" 1
# 25 "./../include/elf/aarch64.h"
# 1 "./../include/elf/reloc-macros.h" 1
# 26 "./../include/elf/aarch64.h" 2
# 52 "./../include/elf/aarch64.h"
static const char *elf_aarch64_reloc_type (unsigned long rtype); static const char * elf_aarch64_reloc_type (unsigned long rtype) { switch (rtype) {


case 0: return "R_AARCH64_NONE";




case 1: return "R_AARCH64_P32_ABS32";


case 2: return "R_AARCH64_P32_ABS16";


case 3: return "R_AARCH64_P32_PREL32";


case 4: return "R_AARCH64_P32_PREL16";





case 5: return "R_AARCH64_P32_MOVW_UABS_G0";


case 6: return "R_AARCH64_P32_MOVW_UABS_G0_NC";


case 7: return "R_AARCH64_P32_MOVW_UABS_G1";






case 8: return "R_AARCH64_P32_MOVW_SABS_G0";





case 9: return "R_AARCH64_P32_LD_PREL_LO19";


case 10: return "R_AARCH64_P32_ADR_PREL_LO21";


case 11: return "R_AARCH64_P32_ADR_PREL_PG_HI21";


case 12: return "R_AARCH64_P32_ADD_ABS_LO12_NC";


case 13: return "R_AARCH64_P32_LDST8_ABS_LO12_NC";


case 14: return "R_AARCH64_P32_LDST16_ABS_LO12_NC";


case 15: return "R_AARCH64_P32_LDST32_ABS_LO12_NC";


case 16: return "R_AARCH64_P32_LDST64_ABS_LO12_NC";


case 17: return "R_AARCH64_P32_LDST128_ABS_LO12_NC";




case 18: return "R_AARCH64_P32_TSTBR14";


case 19: return "R_AARCH64_P32_CONDBR19";


case 20: return "R_AARCH64_P32_JUMP26";


case 21: return "R_AARCH64_P32_CALL26";


case 22: return "R_AARCH64_P32_MOVW_PREL_G0";
case 23: return "R_AARCH64_P32_MOVW_PREL_G0_NC";
case 24: return "R_AARCH64_P32_MOVW_PREL_G1";

case 25: return "R_AARCH64_P32_GOT_LD_PREL19";
case 26: return "R_AARCH64_P32_ADR_GOT_PAGE";
case 27: return "R_AARCH64_P32_LD32_GOT_LO12_NC";
case 28: return "R_AARCH64_P32_LD32_GOTPAGE_LO14";

case 80: return "R_AARCH64_P32_TLSGD_ADR_PREL21";
case 81: return "R_AARCH64_P32_TLSGD_ADR_PAGE21";
case 82: return "R_AARCH64_P32_TLSGD_ADD_LO12_NC";
case 83: return "R_AARCH64_P32_TLSLD_ADR_PREL21";
case 84: return "R_AARCH64_P32_TLSLD_ADR_PAGE21";
case 85: return "R_AARCH64_P32_TLSLD_ADD_LO12_NC";
case 87: return "R_AARCH64_P32_TLSLD_MOVW_DTPREL_G1";
case 88: return "R_AARCH64_P32_TLSLD_MOVW_DTPREL_G0";
case 89: return "R_AARCH64_P32_TLSLD_MOVW_DTPREL_G0_NC";
case 90: return "R_AARCH64_P32_TLSLD_ADD_DTPREL_HI12";
case 91: return "R_AARCH64_P32_TLSLD_ADD_DTPREL_LO12";
case 92: return "R_AARCH64_P32_TLSLD_ADD_DTPREL_LO12_NC";
case 103: return "R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21";
case 104: return "R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC";
case 105: return "R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19";
case 106: return "R_AARCH64_P32_TLSLE_MOVW_TPREL_G1";
case 107: return "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0";
case 108: return "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC";
case 109: return "R_AARCH64_P32_TLSLE_ADD_TPREL_HI12";
case 110: return "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12";
case 111: return "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC";
case 112: return "R_AARCH64_P32_TLSLE_LDST8_TPREL_LO12";
case 113: return "R_AARCH64_P32_TLSLE_LDST8_TPREL_LO12_NC";
case 114: return "R_AARCH64_P32_TLSLE_LDST16_TPREL_LO12";
case 115: return "R_AARCH64_P32_TLSLE_LDST16_TPREL_LO12_NC";
case 116: return "R_AARCH64_P32_TLSLE_LDST32_TPREL_LO12";
case 117: return "R_AARCH64_P32_TLSLE_LDST32_TPREL_LO12_NC";
case 118: return "R_AARCH64_P32_TLSLE_LDST64_TPREL_LO12";
case 119: return "R_AARCH64_P32_TLSLE_LDST64_TPREL_LO12_NC";

case 122: return "R_AARCH64_P32_TLSDESC_LD_PREL19";
case 123: return "R_AARCH64_P32_TLSDESC_ADR_PREL21";
case 124: return "R_AARCH64_P32_TLSDESC_ADR_PAGE21";
case 125: return "R_AARCH64_P32_TLSDESC_LD32_LO12_NC";
case 126: return "R_AARCH64_P32_TLSDESC_ADD_LO12_NC";
case 127: return "R_AARCH64_P32_TLSDESC_CALL";




case 180: return "R_AARCH64_P32_COPY";


case 181: return "R_AARCH64_P32_GLOB_DAT";


case 182: return "R_AARCH64_P32_JUMP_SLOT";


case 183: return "R_AARCH64_P32_RELATIVE";
case 184: return "R_AARCH64_P32_TLS_DTPMOD";
case 185: return "R_AARCH64_P32_TLS_DTPREL";
case 186: return "R_AARCH64_P32_TLS_TPREL";
case 187: return "R_AARCH64_P32_TLSDESC";
case 188: return "R_AARCH64_P32_IRELATIVE";

case 256: return "R_AARCH64_NULL";




case 257: return "R_AARCH64_ABS64";


case 258: return "R_AARCH64_ABS32";


case 259: return "R_AARCH64_ABS16";


case 260: return "R_AARCH64_PREL64";


case 261: return "R_AARCH64_PREL32";


case 262: return "R_AARCH64_PREL16";





case 263: return "R_AARCH64_MOVW_UABS_G0";


case 264: return "R_AARCH64_MOVW_UABS_G0_NC";


case 265: return "R_AARCH64_MOVW_UABS_G1";


case 266: return "R_AARCH64_MOVW_UABS_G1_NC";


case 267: return "R_AARCH64_MOVW_UABS_G2";


case 268: return "R_AARCH64_MOVW_UABS_G2_NC";


case 269: return "R_AARCH64_MOVW_UABS_G3";






case 270: return "R_AARCH64_MOVW_SABS_G0";


case 271: return "R_AARCH64_MOVW_SABS_G1";


case 272: return "R_AARCH64_MOVW_SABS_G2";





case 273: return "R_AARCH64_LD_PREL_LO19";


case 274: return "R_AARCH64_ADR_PREL_LO21";


case 275: return "R_AARCH64_ADR_PREL_PG_HI21";


case 276: return "R_AARCH64_ADR_PREL_PG_HI21_NC";


case 277: return "R_AARCH64_ADD_ABS_LO12_NC";


case 278: return "R_AARCH64_LDST8_ABS_LO12_NC";




case 279: return "R_AARCH64_TSTBR14";


case 280: return "R_AARCH64_CONDBR19";




case 282: return "R_AARCH64_JUMP26";


case 283: return "R_AARCH64_CALL26";


case 284: return "R_AARCH64_LDST16_ABS_LO12_NC";


case 285: return "R_AARCH64_LDST32_ABS_LO12_NC";


case 286: return "R_AARCH64_LDST64_ABS_LO12_NC";




case 287: return "R_AARCH64_MOVW_PREL_G0";
case 288: return "R_AARCH64_MOVW_PREL_G0_NC";
case 289: return "R_AARCH64_MOVW_PREL_G1";
case 290: return "R_AARCH64_MOVW_PREL_G1_NC";
case 291: return "R_AARCH64_MOVW_PREL_G2";
case 292: return "R_AARCH64_MOVW_PREL_G2_NC";
case 293: return "R_AARCH64_MOVW_PREL_G3";


case 299: return "R_AARCH64_LDST128_ABS_LO12_NC";




case 300: return "R_AARCH64_MOVW_GOTOFF_G0";
case 301: return "R_AARCH64_MOVW_GOTOFF_G0_NC";
case 302: return "R_AARCH64_MOVW_GOTOFF_G1";
case 303: return "R_AARCH64_MOVW_GOTOFF_G1_NC";
case 304: return "R_AARCH64_MOVW_GOTOFF_G2";
case 305: return "R_AARCH64_MOVW_GOTOFF_G2_NC";
case 306: return "R_AARCH64_MOVW_GOTOFF_G3";



case 307: return "R_AARCH64_GOTREL64";
case 308: return "R_AARCH64_GOTREL32";



case 309: return "R_AARCH64_GOT_LD_PREL19";
case 310: return "R_AARCH64_LD64_GOTOFF_LO15";
case 311: return "R_AARCH64_ADR_GOT_PAGE";
case 312: return "R_AARCH64_LD64_GOT_LO12_NC";
case 313: return "R_AARCH64_LD64_GOTPAGE_LO15";



case 512: return "R_AARCH64_TLSGD_ADR_PREL21";
case 513: return "R_AARCH64_TLSGD_ADR_PAGE21";
case 514: return "R_AARCH64_TLSGD_ADD_LO12_NC";
case 515: return "R_AARCH64_TLSGD_MOVW_G1";
case 516: return "R_AARCH64_TLSGD_MOVW_G0_NC";



case 517: return "R_AARCH64_TLSLD_ADR_PREL21";
case 518: return "R_AARCH64_TLSLD_ADR_PAGE21";
case 519: return "R_AARCH64_TLSLD_ADD_LO12_NC";
case 520: return "R_AARCH64_TLSLD_MOVW_G1";
case 521: return "R_AARCH64_TLSLD_MOVW_G0_NC";
case 522: return "R_AARCH64_TLSLD_LD_PREL19";
case 523: return "R_AARCH64_TLSLD_MOVW_DTPREL_G2";
case 524: return "R_AARCH64_TLSLD_MOVW_DTPREL_G1";
case 525: return "R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC";
case 526: return "R_AARCH64_TLSLD_MOVW_DTPREL_G0";
case 527: return "R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC";
case 528: return "R_AARCH64_TLSLD_ADD_DTPREL_HI12";
case 529: return "R_AARCH64_TLSLD_ADD_DTPREL_LO12";
case 530: return "R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC";
case 531: return "R_AARCH64_TLSLD_LDST8_DTPREL_LO12";
case 532: return "R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC";
case 533: return "R_AARCH64_TLSLD_LDST16_DTPREL_LO12";
case 534: return "R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC";
case 535: return "R_AARCH64_TLSLD_LDST32_DTPREL_LO12";
case 536: return "R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC";
case 537: return "R_AARCH64_TLSLD_LDST64_DTPREL_LO12";
case 538: return "R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC";



case 539: return "R_AARCH64_TLSIE_MOVW_GOTTPREL_G1";
case 540: return "R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC";
case 541: return "R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21";
case 542: return "R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC";
case 543: return "R_AARCH64_TLSIE_LD_GOTTPREL_PREL19";



case 544: return "R_AARCH64_TLSLE_MOVW_TPREL_G2";
case 545: return "R_AARCH64_TLSLE_MOVW_TPREL_G1";
case 546: return "R_AARCH64_TLSLE_MOVW_TPREL_G1_NC";
case 547: return "R_AARCH64_TLSLE_MOVW_TPREL_G0";
case 548: return "R_AARCH64_TLSLE_MOVW_TPREL_G0_NC";
case 549: return "R_AARCH64_TLSLE_ADD_TPREL_HI12";
case 550: return "R_AARCH64_TLSLE_ADD_TPREL_LO12";
case 551: return "R_AARCH64_TLSLE_ADD_TPREL_LO12_NC";
case 552: return "R_AARCH64_TLSLE_LDST8_TPREL_LO12";
case 553: return "R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC";
case 554: return "R_AARCH64_TLSLE_LDST16_TPREL_LO12";
case 555: return "R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC";
case 556: return "R_AARCH64_TLSLE_LDST32_TPREL_LO12";
case 557: return "R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC";
case 558: return "R_AARCH64_TLSLE_LDST64_TPREL_LO12";
case 559: return "R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC";



case 560: return "R_AARCH64_TLSDESC_LD_PREL19";
case 561: return "R_AARCH64_TLSDESC_ADR_PREL21";
case 562: return "R_AARCH64_TLSDESC_ADR_PAGE21";
case 563: return "R_AARCH64_TLSDESC_LD64_LO12";
case 564: return "R_AARCH64_TLSDESC_ADD_LO12";
case 565: return "R_AARCH64_TLSDESC_OFF_G1";
case 566: return "R_AARCH64_TLSDESC_OFF_G0_NC";
case 567: return "R_AARCH64_TLSDESC_LDR";
case 568: return "R_AARCH64_TLSDESC_ADD";
case 569: return "R_AARCH64_TLSDESC_CALL";

case 570: return "R_AARCH64_TLSLE_LDST128_TPREL_LO12";
case 571: return "R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC";
case 572: return "R_AARCH64_TLSLD_LDST128_DTPREL_LO12";
case 573: return "R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC";




case 1024: return "R_AARCH64_COPY";


case 1025: return "R_AARCH64_GLOB_DAT";


case 1026: return "R_AARCH64_JUMP_SLOT";


case 1027: return "R_AARCH64_RELATIVE";
case 1028: return "R_AARCH64_TLS_DTPMOD64";
case 1029: return "R_AARCH64_TLS_DTPREL64";
case 1030: return "R_AARCH64_TLS_TPREL64";
# 445 "./../include/elf/aarch64.h"
case 1031: return "R_AARCH64_TLSDESC";
case 1032: return "R_AARCH64_IRELATIVE";

default: return 
# 448 "./../include/elf/aarch64.h" 3 4
((void *)0)
# 448 "./../include/elf/aarch64.h"
; } }
# 98 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/alpha.h" 1
# 52 "./../include/elf/alpha.h"
typedef struct
{

  unsigned long ri_gprmask;

  unsigned long ri_cprmask[4];

  long ri_gp_value;
} Elf64_RegInfo;
# 73 "./../include/elf/alpha.h"
static const char *elf_alpha_reloc_type (unsigned long rtype); static const char * elf_alpha_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_ALPHA_NONE";
  case 1: return "R_ALPHA_REFLONG";
  case 2: return "R_ALPHA_REFQUAD";
  case 3: return "R_ALPHA_GPREL32";
  case 4: return "R_ALPHA_LITERAL";
  case 5: return "R_ALPHA_LITUSE";
  case 6: return "R_ALPHA_GPDISP";
  case 7: return "R_ALPHA_BRADDR";
  case 8: return "R_ALPHA_HINT";
  case 9: return "R_ALPHA_SREL16";
  case 10: return "R_ALPHA_SREL32";
  case 11: return "R_ALPHA_SREL64";



  case 17: return "R_ALPHA_GPRELHIGH";
  case 18: return "R_ALPHA_GPRELLOW";
  case 19: return "R_ALPHA_GPREL16";




  case 24: return "R_ALPHA_COPY";
  case 25: return "R_ALPHA_GLOB_DAT";
  case 26: return "R_ALPHA_JMP_SLOT";
  case 27: return "R_ALPHA_RELATIVE";




  case 28: return "R_ALPHA_BRSGP";


  case 29: return "R_ALPHA_TLSGD";
  case 30: return "R_ALPHA_TLSLDM";
  case 31: return "R_ALPHA_DTPMOD64";
  case 32: return "R_ALPHA_GOTDTPREL";
  case 33: return "R_ALPHA_DTPREL64";
  case 34: return "R_ALPHA_DTPRELHI";
  case 35: return "R_ALPHA_DTPRELLO";
  case 36: return "R_ALPHA_DTPREL16";
  case 37: return "R_ALPHA_GOTTPREL";
  case 38: return "R_ALPHA_TPREL64";
  case 39: return "R_ALPHA_TPRELHI";
  case 40: return "R_ALPHA_TPRELLO";
  case 41: return "R_ALPHA_TPREL16";

default: return 
# 121 "./../include/elf/alpha.h" 3 4
((void *)0)
# 121 "./../include/elf/alpha.h"
; } }
# 99 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/amdgpu.h" 1
# 98 "./../include/elf/amdgpu.h"
static const char *elf_amdgpu_reloc_type (unsigned long rtype); static const char * elf_amdgpu_reloc_type (unsigned long rtype) { switch (rtype) {
 case 0: return "R_AMDGPU_NONE";
 case 1: return "R_AMDGPU_ABS32_LO";
 case 2: return "R_AMDGPU_ABS32_HI";
 case 3: return "R_AMDGPU_ABS64";
 case 4: return "R_AMDGPU_REL32";
 case 5: return "R_AMDGPU_REL64";
 case 6: return "R_AMDGPU_ABS32";
 case 7: return "R_AMDGPU_GOTPCREL";
 case 8: return "R_AMDGPU_GOTPCREL32_LO";
 case 9: return "R_AMDGPU_GOTPCREL32_HI";
 case 10: return "R_AMDGPU_REL32_LO";
 case 11: return "R_AMDGPU_REL32_HI";
 case 13: return "R_AMDGPU_RELATIVE64";
 case 16: return "R_AMDGPU_REL16";
default: return 
# 113 "./../include/elf/amdgpu.h" 3 4
((void *)0)
# 113 "./../include/elf/amdgpu.h"
; } }
# 100 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/arc.h" 1
# 34 "./../include/elf/arc.h"
static const char *elf_arc_reloc_type (unsigned long rtype); static const char * elf_arc_reloc_type (unsigned long rtype) { switch (rtype) {
# 1 "./../include/elf/arc-reloc.def" 1
# 32 "./../include/elf/arc-reloc.def"
case 0: return "R_ARC_NONE";






case 1: return "R_ARC_8";






case 2: return "R_ARC_16";






case 3: return "R_ARC_24";






case 4: return "R_ARC_32";






case 8: return "R_ARC_N8";






case 9: return "R_ARC_N16";






case 10: return "R_ARC_N24";






case 11: return "R_ARC_N32";






case 12: return "R_ARC_SDA";






case 13: return "R_ARC_SECTOFF";






case 14: return "R_ARC_S21H_PCREL";






case 15: return "R_ARC_S21W_PCREL";






case 16: return "R_ARC_S25H_PCREL";






case 17: return "R_ARC_S25W_PCREL";






case 18: return "R_ARC_SDA32";






case 19: return "R_ARC_SDA_LDST";






case 20: return "R_ARC_SDA_LDST1";






case 21: return "R_ARC_SDA_LDST2";






case 22: return "R_ARC_SDA16_LD";






case 23: return "R_ARC_SDA16_LD1";






case 24: return "R_ARC_SDA16_LD2";






case 25: return "R_ARC_S13_PCREL";






case 26: return "R_ARC_W";






case 27: return "R_ARC_32_ME";






case 105: return "R_ARC_32_ME_S";






case 28: return "R_ARC_N32_ME";






case 29: return "R_ARC_SECTOFF_ME";






case 30: return "R_ARC_SDA32_ME";






case 31: return "R_ARC_W_ME";






case 35: return "R_AC_SECTOFF_U8";






case 36: return "R_AC_SECTOFF_U8_1";






case 37: return "R_AC_SECTOFF_U8_2";






case 38: return "R_AC_SECTOFF_S9";






case 39: return "R_AC_SECTOFF_S9_1";






case 40: return "R_AC_SECTOFF_S9_2";






case 41: return "R_ARC_SECTOFF_ME_1";






case 42: return "R_ARC_SECTOFF_ME_2";






case 43: return "R_ARC_SECTOFF_1";






case 44: return "R_ARC_SECTOFF_2";






case 45: return "R_ARC_SDA_12";






case 48: return "R_ARC_SDA16_ST2";






case 49: return "R_ARC_32_PCREL";






case 50: return "R_ARC_PC32";






case 59: return "R_ARC_GOT32";






case 51: return "R_ARC_GOTPC32";






case 52: return "R_ARC_PLT32";






case 53: return "R_ARC_COPY";






case 54: return "R_ARC_GLOB_DAT";






case 55: return "R_ARC_JMP_SLOT";






case 56: return "R_ARC_RELATIVE";






case 57: return "R_ARC_GOTOFF";






case 58: return "R_ARC_GOTPC";






case 60: return "R_ARC_S21W_PCREL_PLT";






case 61: return "R_ARC_S25H_PCREL_PLT";






case 63: return "R_ARC_JLI_SECTOFF";






case 66: return "R_ARC_TLS_DTPMOD";






case 68: return "R_ARC_TLS_TPOFF";






case 69: return "R_ARC_TLS_GD_GOT";






case 70: return "R_ARC_TLS_GD_LD";






case 71: return "R_ARC_TLS_GD_CALL";






case 72: return "R_ARC_TLS_IE_GOT";






case 67: return "R_ARC_TLS_DTPOFF";






case 73: return "R_ARC_TLS_DTPOFF_S9";






case 74: return "R_ARC_TLS_LE_S9";






case 75: return "R_ARC_TLS_LE_32";






case 76: return "R_ARC_S25W_PCREL_PLT";






case 77: return "R_ARC_S21H_PCREL_PLT";






case 78: return "R_ARC_NPS_CMEM16";
# 36 "./../include/elf/arc.h" 2
default: return 
# 36 "./../include/elf/arc.h" 3 4
((void *)0)
# 36 "./../include/elf/arc.h"
; } }
# 70 "./../include/elf/arc.h"
enum {

  Tag_ARC_PCS_config = 4,
  Tag_ARC_CPU_base,
  Tag_ARC_CPU_variation,
  Tag_ARC_CPU_name,
  Tag_ARC_ABI_rf16,
  Tag_ARC_ABI_osver,
  Tag_ARC_ABI_sda,
  Tag_ARC_ABI_pic,
  Tag_ARC_ABI_tls,
  Tag_ARC_ABI_enumsize,
  Tag_ARC_ABI_exceptions,
  Tag_ARC_ABI_double_size,
  Tag_ARC_ISA_config,
  Tag_ARC_ISA_apex,
  Tag_ARC_ISA_mpy_option,
  Tag_ARC_ATR_version = 20
};
# 101 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/arm.h" 1
# 126 "./../include/elf/arm.h"
static const char *elf_arm_reloc_type (unsigned long rtype); static const char * elf_arm_reloc_type (unsigned long rtype) { switch (rtype) {

  case 0: return "R_ARM_NONE";
  case 1: return "R_ARM_PC24";
  case 2: return "R_ARM_ABS32";
  case 3: return "R_ARM_REL32";
  case 4: return "R_ARM_LDR_PC_G0";
  case 5: return "R_ARM_ABS16";
  case 6: return "R_ARM_ABS12";
  case 7: return "R_ARM_THM_ABS5";
  case 8: return "R_ARM_ABS8";
  case 9: return "R_ARM_SBREL32";
  case 10: return "R_ARM_THM_CALL";
  case 11: return "R_ARM_THM_PC8";
  case 12: return "R_ARM_BREL_ADJ";
  case 13: return "R_ARM_TLS_DESC";
  case 14: return "R_ARM_THM_SWI8";
  case 15: return "R_ARM_XPC25";
  case 16: return "R_ARM_THM_XPC22";
  case 17: return "R_ARM_TLS_DTPMOD32";
  case 18: return "R_ARM_TLS_DTPOFF32";
  case 19: return "R_ARM_TLS_TPOFF32";
  case 20: return "R_ARM_COPY";
  case 21: return "R_ARM_GLOB_DAT";
  case 22: return "R_ARM_JUMP_SLOT";
  case 23: return "R_ARM_RELATIVE";
  case 24: return "R_ARM_GOTOFF32";
  case 25: return "R_ARM_BASE_PREL";
  case 26: return "R_ARM_GOT_BREL";
  case 27: return "R_ARM_PLT32";
  case 28: return "R_ARM_CALL";
  case 29: return "R_ARM_JUMP24";
  case 30: return "R_ARM_THM_JUMP24";
  case 31: return "R_ARM_BASE_ABS";
  case 32: return "R_ARM_ALU_PCREL7_0";
  case 33: return "R_ARM_ALU_PCREL15_8";
  case 34: return "R_ARM_ALU_PCREL23_15";
  case 35: return "R_ARM_LDR_SBREL_11_0";
  case 36: return "R_ARM_ALU_SBREL_19_12";
  case 37: return "R_ARM_ALU_SBREL_27_20";
  case 38: return "R_ARM_TARGET1";
  case 39: return "R_ARM_SBREL31";
  case 40: return "R_ARM_V4BX";
  case 41: return "R_ARM_TARGET2";
  case 42: return "R_ARM_PREL31";
  case 43: return "R_ARM_MOVW_ABS_NC";
  case 44: return "R_ARM_MOVT_ABS";
  case 45: return "R_ARM_MOVW_PREL_NC";
  case 46: return "R_ARM_MOVT_PREL";
  case 47: return "R_ARM_THM_MOVW_ABS_NC";
  case 48: return "R_ARM_THM_MOVT_ABS";
  case 49: return "R_ARM_THM_MOVW_PREL_NC";
  case 50: return "R_ARM_THM_MOVT_PREL";
  case 51: return "R_ARM_THM_JUMP19";
  case 52: return "R_ARM_THM_JUMP6";
  case 53: return "R_ARM_THM_ALU_PREL_11_0";
  case 54: return "R_ARM_THM_PC12";
  case 55: return "R_ARM_ABS32_NOI";
  case 56: return "R_ARM_REL32_NOI";
  case 57: return "R_ARM_ALU_PC_G0_NC";
  case 58: return "R_ARM_ALU_PC_G0";
  case 59: return "R_ARM_ALU_PC_G1_NC";
  case 60: return "R_ARM_ALU_PC_G1";
  case 61: return "R_ARM_ALU_PC_G2";
  case 62: return "R_ARM_LDR_PC_G1";
  case 63: return "R_ARM_LDR_PC_G2";
  case 64: return "R_ARM_LDRS_PC_G0";
  case 65: return "R_ARM_LDRS_PC_G1";
  case 66: return "R_ARM_LDRS_PC_G2";
  case 67: return "R_ARM_LDC_PC_G0";
  case 68: return "R_ARM_LDC_PC_G1";
  case 69: return "R_ARM_LDC_PC_G2";
  case 70: return "R_ARM_ALU_SB_G0_NC";
  case 71: return "R_ARM_ALU_SB_G0";
  case 72: return "R_ARM_ALU_SB_G1_NC";
  case 73: return "R_ARM_ALU_SB_G1";
  case 74: return "R_ARM_ALU_SB_G2";
  case 75: return "R_ARM_LDR_SB_G0";
  case 76: return "R_ARM_LDR_SB_G1";
  case 77: return "R_ARM_LDR_SB_G2";
  case 78: return "R_ARM_LDRS_SB_G0";
  case 79: return "R_ARM_LDRS_SB_G1";
  case 80: return "R_ARM_LDRS_SB_G2";
  case 81: return "R_ARM_LDC_SB_G0";
  case 82: return "R_ARM_LDC_SB_G1";
  case 83: return "R_ARM_LDC_SB_G2";
  case 84: return "R_ARM_MOVW_BREL_NC";
  case 85: return "R_ARM_MOVT_BREL";
  case 86: return "R_ARM_MOVW_BREL";
  case 87: return "R_ARM_THM_MOVW_BREL_NC";
  case 88: return "R_ARM_THM_MOVT_BREL";
  case 89: return "R_ARM_THM_MOVW_BREL";
  case 90: return "R_ARM_TLS_GOTDESC";
  case 91: return "R_ARM_TLS_CALL";
  case 92: return "R_ARM_TLS_DESCSEQ";
  case 93: return "R_ARM_THM_TLS_CALL";
  case 94: return "R_ARM_PLT32_ABS";
  case 95: return "R_ARM_GOT_ABS";
  case 96: return "R_ARM_GOT_PREL";
  case 97: return "R_ARM_GOT_BREL12";
  case 98: return "R_ARM_GOTOFF12";
  case 99: return "R_ARM_GOTRELAX";
  case 100: return "R_ARM_GNU_VTENTRY";
  case 101: return "R_ARM_GNU_VTINHERIT";
  case 102: return "R_ARM_THM_JUMP11";
  case 103: return "R_ARM_THM_JUMP8";
  case 104: return "R_ARM_TLS_GD32";
  case 105: return "R_ARM_TLS_LDM32";
  case 106: return "R_ARM_TLS_LDO32";
  case 107: return "R_ARM_TLS_IE32";
  case 108: return "R_ARM_TLS_LE32";
  case 109: return "R_ARM_TLS_LDO12";
  case 110: return "R_ARM_TLS_LE12";
  case 111: return "R_ARM_TLS_IE12GP";

  case 128: return "R_ARM_ME_TOO";
  case 129: return "R_ARM_THM_TLS_DESCSEQ";

  case 132: return "R_ARM_THM_ALU_ABS_G0_NC";
  case 133: return "R_ARM_THM_ALU_ABS_G1_NC";
  case 134: return "R_ARM_THM_ALU_ABS_G2_NC";
  case 135: return "R_ARM_THM_ALU_ABS_G3_NC";
  case 136: return "R_ARM_THM_BF16";
  case 137: return "R_ARM_THM_BF12";
  case 138: return "R_ARM_THM_BF18";

  case 160: return "R_ARM_IRELATIVE";
  case 161: return "R_ARM_GOTFUNCDESC";
  case 162: return "R_ARM_GOTOFFFUNCDESC";
  case 163: return "R_ARM_FUNCDESC";
  case 164: return "R_ARM_FUNCDESC_VALUE";
  case 165: return "R_ARM_TLS_GD32_FDPIC";
  case 166: return "R_ARM_TLS_LDM32_FDPIC";
  case 167: return "R_ARM_TLS_IE32_FDPIC";


  case 249: return "R_ARM_RXPC25";
  case 250: return "R_ARM_RSBREL32";
  case 251: return "R_ARM_THM_RPC22";
  case 252: return "R_ARM_RREL32";
  case 253: return "R_ARM_RABS32";
  case 254: return "R_ARM_RPC24";
  case 255: return "R_ARM_RBASE";


 
 
 
 



 
 
 
 

default: return 
# 283 "./../include/elf/arm.h" 3 4
((void *)0)
# 283 "./../include/elf/arm.h"
; } }




enum
{

  Tag_CPU_raw_name = 4,
  Tag_CPU_name,
  Tag_CPU_arch,
  Tag_CPU_arch_profile,
  Tag_ARM_ISA_use,
  Tag_THUMB_ISA_use,
  Tag_FP_arch,
  Tag_WMMX_arch,
  Tag_Advanced_SIMD_arch,
  Tag_PCS_config,
  Tag_ABI_PCS_R9_use,
  Tag_ABI_PCS_RW_data,
  Tag_ABI_PCS_RO_data,
  Tag_ABI_PCS_GOT_use,
  Tag_ABI_PCS_wchar_t,
  Tag_ABI_FP_rounding,
  Tag_ABI_FP_denormal,
  Tag_ABI_FP_exceptions,
  Tag_ABI_FP_user_exceptions,
  Tag_ABI_FP_number_model,
  Tag_ABI_align_needed,
  Tag_ABI_align_preserved,
  Tag_ABI_enum_size,
  Tag_ABI_HardFP_use,
  Tag_ABI_VFP_args,
  Tag_ABI_WMMX_args,
  Tag_ABI_optimization_goals,
  Tag_ABI_FP_optimization_goals,

  Tag_undefined33 = 33,
  Tag_CPU_unaligned_access,
  Tag_undefined35,
  Tag_FP_HP_extension,
  Tag_undefined37,
  Tag_ABI_FP_16bit_format,
  Tag_undefined39,
  Tag_undefined40,
  Tag_undefined41,
  Tag_MPextension_use,
  Tag_undefined_43,
  Tag_DIV_use,
  Tag_DSP_extension = 46,
  Tag_MVE_arch = 48,
  Tag_PAC_extension = 50,
  Tag_BTI_extension = 52,
  Tag_BTI_use = 74,
  Tag_PACRET_use = 76,
  Tag_nodefaults = 64,
  Tag_also_compatible_with,
  Tag_T2EE_use,
  Tag_conformance,
  Tag_Virtualization_use,
  Tag_undefined69,
  Tag_MPextension_use_legacy,


  Tag_VFP_arch = Tag_FP_arch,
  Tag_ABI_align8_needed = Tag_ABI_align_needed,
  Tag_ABI_align8_preserved = Tag_ABI_align_preserved,
  Tag_VFP_HP_extension = Tag_FP_HP_extension
};


enum
{
  AEABI_FP_number_model_none = 0,
  AEABI_FP_number_model_ieee754_number = 1,
  AEABI_FP_number_model_rtabi = 2,
  AEABI_FP_number_model_ieee754_all = 3
};


enum
{
  AEABI_VFP_args_base = 0,
  AEABI_VFP_args_vfp = 1,
  AEABI_VFP_args_toolchain = 2,
  AEABI_VFP_args_compatible = 3
};
# 381 "./../include/elf/arm.h"
enum arm_st_branch_type {
  ST_BRANCH_TO_ARM,
  ST_BRANCH_TO_THUMB,
  ST_BRANCH_LONG,
  ST_BRANCH_UNKNOWN,
  ST_BRANCH_ENUM_SIZE
};
# 102 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/avr.h" 1
# 53 "./../include/elf/avr.h"
static const char *elf_avr_reloc_type (unsigned long rtype); static const char * elf_avr_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_AVR_NONE";
     case 1: return "R_AVR_32";
     case 2: return "R_AVR_7_PCREL";
     case 3: return "R_AVR_13_PCREL";
     case 4: return "R_AVR_16";
     case 5: return "R_AVR_16_PM";
     case 6: return "R_AVR_LO8_LDI";
     case 7: return "R_AVR_HI8_LDI";
     case 8: return "R_AVR_HH8_LDI";
     case 9: return "R_AVR_LO8_LDI_NEG";
     case 10: return "R_AVR_HI8_LDI_NEG";
     case 11: return "R_AVR_HH8_LDI_NEG";
     case 12: return "R_AVR_LO8_LDI_PM";
     case 13: return "R_AVR_HI8_LDI_PM";
     case 14: return "R_AVR_HH8_LDI_PM";
     case 15: return "R_AVR_LO8_LDI_PM_NEG";
     case 16: return "R_AVR_HI8_LDI_PM_NEG";
     case 17: return "R_AVR_HH8_LDI_PM_NEG";
     case 18: return "R_AVR_CALL";
     case 19: return "R_AVR_LDI";
     case 20: return "R_AVR_6";
     case 21: return "R_AVR_6_ADIW";
     case 22: return "R_AVR_MS8_LDI";
     case 23: return "R_AVR_MS8_LDI_NEG";
     case 24: return "R_AVR_LO8_LDI_GS";
     case 25: return "R_AVR_HI8_LDI_GS";
     case 26: return "R_AVR_8";
     case 27: return "R_AVR_8_LO8";
     case 28: return "R_AVR_8_HI8";
     case 29: return "R_AVR_8_HLO8";
     case 30: return "R_AVR_DIFF8";
     case 31: return "R_AVR_DIFF16";
     case 32: return "R_AVR_DIFF32";
     case 33: return "R_AVR_LDS_STS_16";
     case 34: return "R_AVR_PORT6";
     case 35: return "R_AVR_PORT5";
     case 36: return "R_AVR_32_PCREL";
default: return 
# 91 "./../include/elf/avr.h" 3 4
((void *)0)
# 91 "./../include/elf/avr.h"
; } }
# 103 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/bfin.h" 1
# 25 "./../include/elf/bfin.h"
static const char *elf_bfin_reloc_type (unsigned long rtype); static const char * elf_bfin_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0x00: return "R_BFIN_UNUSED0";
  case 0x01: return "R_BFIN_PCREL5M2";
  case 0x02: return "R_BFIN_UNUSED1";
  case 0x03: return "R_BFIN_PCREL10";
  case 0x04: return "R_BFIN_PCREL12_JUMP";
  case 0x05: return "R_BFIN_RIMM16";
  case 0x06: return "R_BFIN_LUIMM16";
  case 0x07: return "R_BFIN_HUIMM16";
  case 0x08: return "R_BFIN_PCREL12_JUMP_S";
  case 0x09: return "R_BFIN_PCREL24_JUMP_X";
  case 0x0a: return "R_BFIN_PCREL24";
  case 0x0b: return "R_BFIN_UNUSEDB";
  case 0x0c: return "R_BFIN_UNUSEDC";
  case 0x0d: return "R_BFIN_PCREL24_JUMP_L";
  case 0x0e: return "R_BFIN_PCREL24_CALL_X";
  case 0x0f: return "R_BFIN_VAR_EQ_SYMB";
  case 0x10: return "R_BFIN_BYTE_DATA";
  case 0x11: return "R_BFIN_BYTE2_DATA";
  case 0x12: return "R_BFIN_BYTE4_DATA";
  case 0x13: return "R_BFIN_PCREL11";
  case 0x14: return "R_BFIN_GOT17M4";
  case 0x15: return "R_BFIN_GOTHI";
  case 0x16: return "R_BFIN_GOTLO";
  case 0x17: return "R_BFIN_FUNCDESC";
  case 0x18: return "R_BFIN_FUNCDESC_GOT17M4";
  case 0x19: return "R_BFIN_FUNCDESC_GOTHI";
  case 0x1a: return "R_BFIN_FUNCDESC_GOTLO";
  case 0x1b: return "R_BFIN_FUNCDESC_VALUE";
  case 0x1c: return "R_BFIN_FUNCDESC_GOTOFF17M4";
  case 0x1d: return "R_BFIN_FUNCDESC_GOTOFFHI";
  case 0x1e: return "R_BFIN_FUNCDESC_GOTOFFLO";
  case 0x1f: return "R_BFIN_GOTOFF17M4";
  case 0x20: return "R_BFIN_GOTOFFHI";
  case 0x21: return "R_BFIN_GOTOFFLO";

  case 0xE0: return "R_BFIN_PUSH";
  case 0xE1: return "R_BFIN_CONST";
  case 0xE2: return "R_BFIN_ADD";
  case 0xE3: return "R_BFIN_SUB";
  case 0xE4: return "R_BFIN_MULT";
  case 0xE5: return "R_BFIN_DIV";
  case 0xE6: return "R_BFIN_MOD";
  case 0xE7: return "R_BFIN_LSHIFT";
  case 0xE8: return "R_BFIN_RSHIFT";
  case 0xE9: return "R_BFIN_AND";
  case 0xEA: return "R_BFIN_OR";
  case 0xEB: return "R_BFIN_XOR";
  case 0xEC: return "R_BFIN_LAND";
  case 0xED: return "R_BFIN_LOR";
  case 0xEE: return "R_BFIN_LEN";
  case 0xEF: return "R_BFIN_NEG";
  case 0xF0: return "R_BFIN_COMP";
  case 0xF1: return "R_BFIN_PAGE";
  case 0xF2: return "R_BFIN_HWPAGE";
  case 0xF3: return "R_BFIN_ADDR";
  case 0x40: return "R_BFIN_PLTPC";
  case 0x41: return "R_BFIN_GOT";
  case 0x42: return "R_BFIN_GNU_VTINHERIT";
  case 0x43: return "R_BFIN_GNU_VTENTRY";
default: return 
# 85 "./../include/elf/bfin.h" 3 4
((void *)0)
# 85 "./../include/elf/bfin.h"
; } }
# 104 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/cr16.h" 1
# 27 "./../include/elf/cr16.h"
static const char *elf_cr16_reloc_type (unsigned long rtype); static const char * elf_cr16_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_CR16_NONE";
  case 1: return "R_CR16_NUM8";
  case 2: return "R_CR16_NUM16";
  case 3: return "R_CR16_NUM32";
  case 4: return "R_CR16_NUM32a";
  case 5: return "R_CR16_REGREL4";
  case 6: return "R_CR16_REGREL4a";
  case 7: return "R_CR16_REGREL14";
  case 8: return "R_CR16_REGREL14a";
  case 9: return "R_CR16_REGREL16";
  case 10: return "R_CR16_REGREL20";
  case 11: return "R_CR16_REGREL20a";
  case 12: return "R_CR16_ABS20";
  case 13: return "R_CR16_ABS24";
  case 14: return "R_CR16_IMM4";
  case 15: return "R_CR16_IMM8";
  case 16: return "R_CR16_IMM16";
  case 17: return "R_CR16_IMM20";
  case 18: return "R_CR16_IMM24";
  case 19: return "R_CR16_IMM32";
  case 20: return "R_CR16_IMM32a";
  case 21: return "R_CR16_DISP4";
  case 22: return "R_CR16_DISP8";
  case 23: return "R_CR16_DISP16";
  case 24: return "R_CR16_DISP24";
  case 25: return "R_CR16_DISP24a";
  case 26: return "R_CR16_SWITCH8";
  case 27: return "R_CR16_SWITCH16";
  case 28: return "R_CR16_SWITCH32";
  case 29: return "R_CR16_GOT_REGREL20";
  case 30: return "R_CR16_GOTC_REGREL20";
  case 31: return "R_CR16_GLOB_DAT";
default: return 
# 60 "./../include/elf/cr16.h" 3 4
((void *)0)
# 60 "./../include/elf/cr16.h"
; } }
# 105 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/cris.h" 1
# 28 "./../include/elf/cris.h"
static const char *elf_cris_reloc_type (unsigned long rtype); static const char * elf_cris_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_CRIS_NONE";
  case 1: return "R_CRIS_8";
  case 2: return "R_CRIS_16";
  case 3: return "R_CRIS_32";


  case 4: return "R_CRIS_8_PCREL";
  case 5: return "R_CRIS_16_PCREL";
  case 6: return "R_CRIS_32_PCREL";

  case 7: return "R_CRIS_GNU_VTINHERIT";
  case 8: return "R_CRIS_GNU_VTENTRY";



  case 9: return "R_CRIS_COPY";



  case 10: return "R_CRIS_GLOB_DAT";



  case 11: return "R_CRIS_JUMP_SLOT";



  case 12: return "R_CRIS_RELATIVE";




  case 13: return "R_CRIS_16_GOT";




  case 14: return "R_CRIS_32_GOT";




  case 15: return "R_CRIS_16_GOTPLT";




  case 16: return "R_CRIS_32_GOTPLT";




  case 17: return "R_CRIS_32_GOTREL";




  case 18: return "R_CRIS_32_PLT_GOTREL";





  case 19: return "R_CRIS_32_PLT_PCREL";






  case 20: return "R_CRIS_32_GOT_GD";







  case 21: return "R_CRIS_16_GOT_GD";




  case 22: return "R_CRIS_32_GD";





  case 23: return "R_CRIS_DTP";
# 127 "./../include/elf/cris.h"
  case 24: return "R_CRIS_32_DTPREL";






  case 25: return "R_CRIS_16_DTPREL";






  case 26: return "R_CRIS_32_GOT_TPREL";




  case 27: return "R_CRIS_16_GOT_TPREL";






  case 28: return "R_CRIS_32_TPREL";
# 162 "./../include/elf/cris.h"
  case 29: return "R_CRIS_16_TPREL";




  case 30: return "R_CRIS_DTPMOD";




  case 31: return "R_CRIS_32_IE";



default: return 
# 176 "./../include/elf/cris.h" 3 4
((void *)0)
# 176 "./../include/elf/cris.h"
; } }
# 106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/crx.h" 1
# 29 "./../include/elf/crx.h"
static const char *elf_crx_reloc_type (unsigned long rtype); static const char * elf_crx_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_CRX_NONE";
  case 1: return "R_CRX_REL4";
  case 2: return "R_CRX_REL8";
  case 3: return "R_CRX_REL8_CMP";
  case 4: return "R_CRX_REL16";
  case 5: return "R_CRX_REL24";
  case 6: return "R_CRX_REL32";
  case 7: return "R_CRX_REGREL12";
  case 8: return "R_CRX_REGREL22";
  case 9: return "R_CRX_REGREL28";
  case 10: return "R_CRX_REGREL32";
  case 11: return "R_CRX_ABS16";
  case 12: return "R_CRX_ABS32";
  case 13: return "R_CRX_NUM8";
  case 14: return "R_CRX_NUM16";
  case 15: return "R_CRX_NUM32";
  case 16: return "R_CRX_IMM16";
  case 17: return "R_CRX_IMM32";
  case 18: return "R_CRX_SWITCH8";
  case 19: return "R_CRX_SWITCH16";
  case 20: return "R_CRX_SWITCH32";
default: return 
# 51 "./../include/elf/crx.h" 3 4
((void *)0)
# 51 "./../include/elf/crx.h"
; } }
# 107 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/csky.h" 1
# 29 "./../include/elf/csky.h"
static const char *elf_csky_reloc_type (unsigned long rtype); static const char * elf_csky_reloc_type (unsigned long rtype) { switch (rtype) {
    case 0: return "R_CKCORE_NONE";
    case 1: return "R_CKCORE_ADDR32";
    case 2: return "R_CKCORE_PCREL_IMM8BY4";
    case 3: return "R_CKCORE_PCREL_IMM11BY2";
    case 4: return "R_CKCORE_PCREL_IMM4BY2";
    case 5: return "R_CKCORE_PCREL32";
    case 6: return "R_CKCORE_PCREL_JSR_IMM11BY2";
    case 7: return "R_CKCORE_GNU_VTINHERIT";
    case 8: return "R_CKCORE_GNU_VTENTRY";
    case 9: return "R_CKCORE_RELATIVE";
    case 10: return "R_CKCORE_COPY";
    case 11: return "R_CKCORE_GLOB_DAT";
    case 12: return "R_CKCORE_JUMP_SLOT";
    case 13: return "R_CKCORE_GOTOFF";
    case 14: return "R_CKCORE_GOTPC";
    case 15: return "R_CKCORE_GOT32";
    case 16: return "R_CKCORE_PLT32";
    case 17: return "R_CKCORE_ADDRGOT";
    case 18: return "R_CKCORE_ADDRPLT";
    case 19: return "R_CKCORE_PCREL_IMM26BY2";
    case 20: return "R_CKCORE_PCREL_IMM16BY2";
    case 21: return "R_CKCORE_PCREL_IMM16BY4";
    case 22: return "R_CKCORE_PCREL_IMM10BY2";
    case 23: return "R_CKCORE_PCREL_IMM10BY4";
    case 24: return "R_CKCORE_ADDR_HI16";
    case 25: return "R_CKCORE_ADDR_LO16";
    case 26: return "R_CKCORE_GOTPC_HI16";
    case 27: return "R_CKCORE_GOTPC_LO16";
    case 28: return "R_CKCORE_GOTOFF_HI16";
    case 29: return "R_CKCORE_GOTOFF_LO16";
    case 30: return "R_CKCORE_GOT12";
    case 31: return "R_CKCORE_GOT_HI16";
    case 32: return "R_CKCORE_GOT_LO16";
    case 33: return "R_CKCORE_PLT12";
    case 34: return "R_CKCORE_PLT_HI16";
    case 35: return "R_CKCORE_PLT_LO16";
    case 36: return "R_CKCORE_ADDRGOT_HI16";
    case 37: return "R_CKCORE_ADDRGOT_LO16";
    case 38: return "R_CKCORE_ADDRPLT_HI16";
    case 39: return "R_CKCORE_ADDRPLT_LO16";
    case 40: return "R_CKCORE_PCREL_JSR_IMM26BY2";
    case 41: return "R_CKCORE_TOFFSET_LO16";
    case 42: return "R_CKCORE_DOFFSET_LO16";
    case 43: return "R_CKCORE_PCREL_IMM18BY2";
    case 44: return "R_CKCORE_DOFFSET_IMM18";
    case 45: return "R_CKCORE_DOFFSET_IMM18BY2";
    case 46: return "R_CKCORE_DOFFSET_IMM18BY4";
    case 47: return "R_CKCORE_GOTOFF_IMM18";
    case 48: return "R_CKCORE_GOT_IMM18BY4";
    case 49: return "R_CKCORE_PLT_IMM18BY4";
    case 50: return "R_CKCORE_PCREL_IMM7BY4";
    case 51: return "R_CKCORE_TLS_LE32";
    case 52: return "R_CKCORE_TLS_IE32";
    case 53: return "R_CKCORE_TLS_GD32";
    case 54: return "R_CKCORE_TLS_LDM32";
    case 55: return "R_CKCORE_TLS_LDO32";
    case 56: return "R_CKCORE_TLS_DTPMOD32";
    case 57: return "R_CKCORE_TLS_DTPOFF32";
    case 58: return "R_CKCORE_TLS_TPOFF32";
    case 59: return "R_CKCORE_PCREL_FLRW_IMM8BY4";
    case 60: return "R_CKCORE_NOJSRI";
    case 61: return "R_CKCORE_CALLGRAPH";
    case 62: return "R_CKCORE_IRELATIVE";
    case 63: return "R_CKCORE_PCREL_BLOOP_IMM4BY4";
    case 64: return "R_CKCORE_PCREL_BLOOP_IMM12BY4";
default: return 
# 95 "./../include/elf/csky.h" 3 4
((void *)0)
# 95 "./../include/elf/csky.h"
; } }





enum
{


  Tag_CSKY_ARCH_NAME = 4,
  Tag_CSKY_CPU_NAME = 5,


  Tag_CSKY_ISA_FLAGS,
  Tag_CSKY_ISA_EXT_FLAGS,


  Tag_CSKY_DSP_VERSION,


  Tag_CSKY_VDSP_VERSION,


  Tag_CSKY_FPU_VERSION = 0x10,

  Tag_CSKY_FPU_ABI,

  Tag_CSKY_FPU_ROUNDING,

  Tag_CSKY_FPU_DENORMAL,

  Tag_CSKY_FPU_Exception,

  Tag_CSKY_FPU_NUMBER_MODULE,

  Tag_CSKY_FPU_HARDFP,

  Tag_CSKY_MAX,
};


enum
{

  VAL_CSKY_DSP_VERSION_EXTENSION = 1,
  VAL_CSKY_DSP_VERSION_2 = 2,
};

enum
{

  VAL_CSKY_VDSP_VERSION_1 = 1,
  VAL_CSKY_VDSP_VERSION_2
};

enum
{

  VAL_CSKY_FPU_VERSION_1 = 1,
  VAL_CSKY_FPU_VERSION_2,
};

enum
{
  VAL_CSKY_FPU_ABI_SOFT = 1,
  VAL_CSKY_FPU_ABI_SOFTFP,
  VAL_CSKY_FPU_ABI_HARD,
};

enum
{
  VAL_CSKY_FPU_HARDFP_HALF = 1,
  VAL_CSKY_FPU_HARDFP_SINGLE = 2,
  VAL_CSKY_FPU_HARDFP_DOUBLE = 4,
};
# 108 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/d10v.h" 1
# 26 "./../include/elf/d10v.h"
static const char *elf_d10v_reloc_type (unsigned long rtype); static const char * elf_d10v_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_D10V_NONE";
  case 1: return "R_D10V_10_PCREL_R";
  case 2: return "R_D10V_10_PCREL_L";
  case 3: return "R_D10V_16";
  case 4: return "R_D10V_18";
  case 5: return "R_D10V_18_PCREL";
  case 6: return "R_D10V_32";
  case 7: return "R_D10V_GNU_VTINHERIT";
  case 8: return "R_D10V_GNU_VTENTRY";
default: return 
# 36 "./../include/elf/d10v.h" 3 4
((void *)0)
# 36 "./../include/elf/d10v.h"
; } }
# 109 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/d30v.h" 1
# 26 "./../include/elf/d30v.h"
static const char *elf_d30v_reloc_type (unsigned long rtype); static const char * elf_d30v_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_D30V_NONE";
  case 1: return "R_D30V_6";
  case 2: return "R_D30V_9_PCREL";
  case 3: return "R_D30V_9_PCREL_R";
  case 4: return "R_D30V_15";
  case 5: return "R_D30V_15_PCREL";
  case 6: return "R_D30V_15_PCREL_R";
  case 7: return "R_D30V_21";
  case 8: return "R_D30V_21_PCREL";
  case 9: return "R_D30V_21_PCREL_R";
  case 10: return "R_D30V_32";
  case 11: return "R_D30V_32_PCREL";
  case 12: return "R_D30V_32_NORMAL";
default: return 
# 40 "./../include/elf/d30v.h" 3 4
((void *)0)
# 40 "./../include/elf/d30v.h"
; } }
# 110 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/dlx.h" 1
# 43 "./../include/elf/dlx.h"
static const char *elf_dlx_reloc_type (unsigned long rtype); static const char * elf_dlx_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_DLX_NONE";
     case 1: return "R_DLX_RELOC_8";
     case 2: return "R_DLX_RELOC_16";
     case 3: return "R_DLX_RELOC_32";
     case 4: return "R_DLX_GNU_VTINHERIT";
     case 5: return "R_DLX_GNU_VTENTRY";
     case 6: return "R_DLX_RELOC_16_HI";
     case 7: return "R_DLX_RELOC_16_LO";
     case 8: return "R_DLX_RELOC_16_PCREL";
     case 9: return "R_DLX_RELOC_26_PCREL";
default: return 
# 54 "./../include/elf/dlx.h" 3 4
((void *)0)
# 54 "./../include/elf/dlx.h"
; } }
# 111 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/bpf.h" 1
# 28 "./../include/elf/bpf.h"
static const char *elf_bpf_reloc_type (unsigned long rtype); static const char * elf_bpf_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_BPF_NONE";
  case 1: return "R_BPF_64_64";
  case 2: return "R_BPF_64_ABS64";
  case 3: return "R_BPF_64_ABS32";


  case 4: return "R_BPF_64_NODYLD32";
  case 10: return "R_BPF_64_32";
  case 256: return "R_BPF_GNU_64_16";
default: return 
# 38 "./../include/elf/bpf.h" 3 4
((void *)0)
# 38 "./../include/elf/bpf.h"
; } }
# 112 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/epiphany.h" 1
# 27 "./../include/elf/epiphany.h"
static const char *elf_epiphany_reloc_type (unsigned long rtype); static const char * elf_epiphany_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_EPIPHANY_NONE";


  case 1: return "R_EPIPHANY_8";
  case 2: return "R_EPIPHANY_16";
  case 3: return "R_EPIPHANY_32";


  case 4: return "R_EPIPHANY_8_PCREL";
  case 5: return "R_EPIPHANY_16_PCREL";
  case 6: return "R_EPIPHANY_32_PCREL";


  case 7: return "R_EPIPHANY_SIMM8";
  case 8: return "R_EPIPHANY_SIMM24";



  case 9: return "R_EPIPHANY_HIGH";
  case 10: return "R_EPIPHANY_LOW";


  case 11: return "R_EPIPHANY_SIMM11";

  case 12: return "R_EPIPHANY_IMM11";


  case 13: return "R_EPIPHANY_IMM8";

default: return 
# 57 "./../include/elf/epiphany.h" 3 4
((void *)0)
# 57 "./../include/elf/epiphany.h"
; } }
# 113 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/fr30.h" 1
# 26 "./../include/elf/fr30.h"
static const char *elf_fr30_reloc_type (unsigned long rtype); static const char * elf_fr30_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_FR30_NONE";
  case 1: return "R_FR30_8";
  case 2: return "R_FR30_20";
  case 3: return "R_FR30_32";
  case 4: return "R_FR30_48";
  case 5: return "R_FR30_6_IN_4";
  case 6: return "R_FR30_8_IN_8";
  case 7: return "R_FR30_9_IN_8";
  case 8: return "R_FR30_10_IN_8";
  case 9: return "R_FR30_9_PCREL";
  case 10: return "R_FR30_12_PCREL";
  case 11: return "R_FR30_GNU_VTINHERIT";
  case 12: return "R_FR30_GNU_VTENTRY";
default: return 
# 40 "./../include/elf/fr30.h" 3 4
((void *)0)
# 40 "./../include/elf/fr30.h"
; } }
# 114 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/frv.h" 1
# 26 "./../include/elf/frv.h"
static const char *elf_frv_reloc_type (unsigned long rtype); static const char * elf_frv_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_FRV_NONE";
  case 1: return "R_FRV_32";
  case 2: return "R_FRV_LABEL16";
  case 3: return "R_FRV_LABEL24";
  case 4: return "R_FRV_LO16";
  case 5: return "R_FRV_HI16";
  case 6: return "R_FRV_GPREL12";
  case 7: return "R_FRV_GPRELU12";
  case 8: return "R_FRV_GPREL32";
  case 9: return "R_FRV_GPRELHI";
  case 10: return "R_FRV_GPRELLO";
  case 11: return "R_FRV_GOT12";
  case 12: return "R_FRV_GOTHI";
  case 13: return "R_FRV_GOTLO";
  case 14: return "R_FRV_FUNCDESC";
  case 15: return "R_FRV_FUNCDESC_GOT12";
  case 16: return "R_FRV_FUNCDESC_GOTHI";
  case 17: return "R_FRV_FUNCDESC_GOTLO";
  case 18: return "R_FRV_FUNCDESC_VALUE";
  case 19: return "R_FRV_FUNCDESC_GOTOFF12";
  case 20: return "R_FRV_FUNCDESC_GOTOFFHI";
  case 21: return "R_FRV_FUNCDESC_GOTOFFLO";
  case 22: return "R_FRV_GOTOFF12";
  case 23: return "R_FRV_GOTOFFHI";
  case 24: return "R_FRV_GOTOFFLO";
  case 25: return "R_FRV_GETTLSOFF";
  case 26: return "R_FRV_TLSDESC_VALUE";
  case 27: return "R_FRV_GOTTLSDESC12";
  case 28: return "R_FRV_GOTTLSDESCHI";
  case 29: return "R_FRV_GOTTLSDESCLO";
  case 30: return "R_FRV_TLSMOFF12";
  case 31: return "R_FRV_TLSMOFFHI";
  case 32: return "R_FRV_TLSMOFFLO";
  case 33: return "R_FRV_GOTTLSOFF12";
  case 34: return "R_FRV_GOTTLSOFFHI";
  case 35: return "R_FRV_GOTTLSOFFLO";
  case 36: return "R_FRV_TLSOFF";
  case 37: return "R_FRV_TLSDESC_RELAX";
  case 38: return "R_FRV_GETTLSOFF_RELAX";
  case 39: return "R_FRV_TLSOFF_RELAX";
  case 40: return "R_FRV_TLSMOFF";
  case 200: return "R_FRV_GNU_VTINHERIT";
  case 201: return "R_FRV_GNU_VTENTRY";
default: return 
# 70 "./../include/elf/frv.h" 3 4
((void *)0)
# 70 "./../include/elf/frv.h"
; } }
# 115 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/ft32.h" 1
# 26 "./../include/elf/ft32.h"
static const char *elf_ft32_reloc_type (unsigned long rtype); static const char * elf_ft32_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_FT32_NONE";
  case 1: return "R_FT32_32";
  case 2: return "R_FT32_16";
  case 3: return "R_FT32_8";
  case 4: return "R_FT32_10";
  case 5: return "R_FT32_20";
  case 6: return "R_FT32_17";
  case 7: return "R_FT32_18";
  case 8: return "R_FT32_RELAX";
  case 9: return "R_FT32_SC0";
  case 10: return "R_FT32_SC1";
  case 11: return "R_FT32_15";
  case 12: return "R_FT32_DIFF32";
default: return 
# 40 "./../include/elf/ft32.h" 3 4
((void *)0)
# 40 "./../include/elf/ft32.h"
; } }
# 116 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/h8.h" 1
# 27 "./../include/elf/h8.h"
static const char *elf_h8_reloc_type (unsigned long rtype); static const char * elf_h8_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_H8_NONE";
  case 1: return "R_H8_DIR32";
  case 2: return "R_H8_DIR32_28";
  case 3: return "R_H8_DIR32_24";
  case 4: return "R_H8_DIR32_16";
  case 6: return "R_H8_DIR32U";
  case 7: return "R_H8_DIR32U_28";
  case 8: return "R_H8_DIR32U_24";
  case 9: return "R_H8_DIR32U_20";
  case 10: return "R_H8_DIR32U_16";
  case 11: return "R_H8_DIR24";
  case 12: return "R_H8_DIR24_20";
  case 13: return "R_H8_DIR24_16";
  case 14: return "R_H8_DIR24U";
  case 15: return "R_H8_DIR24U_20";
  case 16: return "R_H8_DIR24U_16";
  case 17: return "R_H8_DIR16";
  case 18: return "R_H8_DIR16U";
  case 19: return "R_H8_DIR16S_32";
  case 20: return "R_H8_DIR16S_28";
  case 21: return "R_H8_DIR16S_24";
  case 22: return "R_H8_DIR16S_20";
  case 23: return "R_H8_DIR16S";
  case 24: return "R_H8_DIR8";
  case 25: return "R_H8_DIR8U";
  case 26: return "R_H8_DIR8Z_32";
  case 27: return "R_H8_DIR8Z_28";
  case 28: return "R_H8_DIR8Z_24";
  case 29: return "R_H8_DIR8Z_20";
  case 30: return "R_H8_DIR8Z_16";
  case 31: return "R_H8_PCREL16";
  case 32: return "R_H8_PCREL8";
  case 33: return "R_H8_BPOS";
 
 
  case 59: return "R_H8_DIR16A8";
  case 60: return "R_H8_DIR16R8";
  case 61: return "R_H8_DIR24A8";
  case 62: return "R_H8_DIR24R8";
  case 63: return "R_H8_DIR32A16";
  case 64: return "R_H8_DISP32A16";
  case 65: return "R_H8_ABS32";
  case 127: return "R_H8_ABS32A16";
  case 128: return "R_H8_SYM";
  case 129: return "R_H8_OPneg";
  case 130: return "R_H8_OPadd";
  case 131: return "R_H8_OPsub";
  case 132: return "R_H8_OPmul";
  case 133: return "R_H8_OPdiv";
  case 134: return "R_H8_OPshla";
  case 135: return "R_H8_OPshra";
  case 136: return "R_H8_OPsctsize";
  case 137: return "R_H8_OPhword";
  case 138: return "R_H8_OPlword";
  case 139: return "R_H8_OPhigh";
  case 140: return "R_H8_OPlow";
  case 141: return "R_H8_OPscttop";
default: return 
# 85 "./../include/elf/h8.h" 3 4
((void *)0)
# 85 "./../include/elf/h8.h"
; } }
# 117 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/hppa.h" 1
# 110 "./../include/elf/hppa.h"
static const char *elf_hppa_reloc_type (unsigned long rtype); static const char * elf_hppa_reloc_type (unsigned long rtype) { switch (rtype) {
case 0: return "R_PARISC_NONE";



case 1: return "R_PARISC_DIR32";


case 2: return "R_PARISC_DIR21L";


case 3: return "R_PARISC_DIR17R";


case 4: return "R_PARISC_DIR17F";


case 6: return "R_PARISC_DIR14R";


case 7: return "R_PARISC_DIR14F";
# 147 "./../include/elf/hppa.h"
case 8: return "R_PARISC_PCREL12F";


case 9: return "R_PARISC_PCREL32";


case 10: return "R_PARISC_PCREL21L";


case 11: return "R_PARISC_PCREL17R";


case 12: return "R_PARISC_PCREL17F";


case 13: return "R_PARISC_PCREL17C";


case 14: return "R_PARISC_PCREL14R";


case 15: return "R_PARISC_PCREL14F";




case 18: return "R_PARISC_DPREL21L";


case 19: return "R_PARISC_DPREL14WR";


case 20: return "R_PARISC_DPREL14DR";


case 22: return "R_PARISC_DPREL14R";


case 23: return "R_PARISC_DPREL14F";
# 195 "./../include/elf/hppa.h"
case 26: return "R_PARISC_DLTREL21L";


case 30: return "R_PARISC_DLTREL14R";


case 31: return "R_PARISC_DLTREL14F";




case 34: return "R_PARISC_DLTIND21L";


case 38: return "R_PARISC_DLTIND14R";


case 39: return "R_PARISC_DLTIND14F";




case 40: return "R_PARISC_SETBASE";


case 41: return "R_PARISC_SECREL32";


case 42: return "R_PARISC_BASEREL21L";


case 43: return "R_PARISC_BASEREL17R";


case 44: return "R_PARISC_BASEREL17F";


case 46: return "R_PARISC_BASEREL14R";


case 47: return "R_PARISC_BASEREL14F";




case 48: return "R_PARISC_SEGBASE";


case 49: return "R_PARISC_SEGREL32";




case 50: return "R_PARISC_PLTOFF21L";


case 54: return "R_PARISC_PLTOFF14R";


case 55: return "R_PARISC_PLTOFF14F";



case 57: return "R_PARISC_LTOFF_FPTR32";


case 58: return "R_PARISC_LTOFF_FPTR21L";


case 62: return "R_PARISC_LTOFF_FPTR14R";



case 64: return "R_PARISC_FPTR64";




case 65: return "R_PARISC_PLABEL32";


case 66: return "R_PARISC_PLABEL21L";


case 70: return "R_PARISC_PLABEL14R";




case 72: return "R_PARISC_PCREL64";


case 73: return "R_PARISC_PCREL22C";


case 74: return "R_PARISC_PCREL22F";


case 75: return "R_PARISC_PCREL14WR";


case 76: return "R_PARISC_PCREL14DR";


case 77: return "R_PARISC_PCREL16F";


case 78: return "R_PARISC_PCREL16WF";


case 79: return "R_PARISC_PCREL16DF";



case 80: return "R_PARISC_DIR64";


case 83: return "R_PARISC_DIR14WR";


case 84: return "R_PARISC_DIR14DR";


case 85: return "R_PARISC_DIR16F";


case 86: return "R_PARISC_DIR16WF";


case 87: return "R_PARISC_DIR16DF";


case 88: return "R_PARISC_GPREL64";


case 91: return "R_PARISC_DLTREL14WR";


case 92: return "R_PARISC_DLTREL14DR";


case 93: return "R_PARISC_GPREL16F";


case 94: return "R_PARISC_GPREL16WF";


case 95: return "R_PARISC_GPREL16DF";



case 96: return "R_PARISC_LTOFF64";


case 99: return "R_PARISC_DLTIND14WR";


case 100: return "R_PARISC_DLTIND14DR";


case 101: return "R_PARISC_LTOFF16F";


case 102: return "R_PARISC_LTOFF16WF";


case 103: return "R_PARISC_LTOFF16DF";



case 104: return "R_PARISC_SECREL64";


case 107: return "R_PARISC_BASEREL14WR";


case 108: return "R_PARISC_BASEREL14DR";



case 112: return "R_PARISC_SEGREL64";


case 115: return "R_PARISC_PLTOFF14WR";


case 116: return "R_PARISC_PLTOFF14DR";


case 117: return "R_PARISC_PLTOFF16F";


case 118: return "R_PARISC_PLTOFF16WF";


case 119: return "R_PARISC_PLTOFF16DF";



case 120: return "R_PARISC_LTOFF_FPTR64";


case 123: return "R_PARISC_LTOFF_FPTR14WR";


case 124: return "R_PARISC_LTOFF_FPTR14DR";


case 125: return "R_PARISC_LTOFF_FPTR16F";


case 126: return "R_PARISC_LTOFF_FPTR16WF";


case 127: return "R_PARISC_LTOFF_FPTR16DF";



case 128: return "R_PARISC_COPY";


case 129: return "R_PARISC_IPLT";


case 130: return "R_PARISC_EPLT";



case 153: return "R_PARISC_TPREL32";


case 154: return "R_PARISC_TPREL21L";


case 158: return "R_PARISC_TPREL14R";



case 162: return "R_PARISC_LTOFF_TP21L";


case 166: return "R_PARISC_LTOFF_TP14R";


case 167: return "R_PARISC_LTOFF_TP14F";



case 216: return "R_PARISC_TPREL64";


case 219: return "R_PARISC_TPREL14WR";


case 220: return "R_PARISC_TPREL14DR";


case 221: return "R_PARISC_TPREL16F";


case 222: return "R_PARISC_TPREL16WF";


case 223: return "R_PARISC_TPREL16DF";



case 224: return "R_PARISC_LTOFF_TP64";


case 227: return "R_PARISC_LTOFF_TP14WR";


case 228: return "R_PARISC_LTOFF_TP14DR";


case 229: return "R_PARISC_LTOFF_TP16F";


case 230: return "R_PARISC_LTOFF_TP16WF";


case 231: return "R_PARISC_LTOFF_TP16DF";


case 232: return "R_PARISC_GNU_VTENTRY";
case 233: return "R_PARISC_GNU_VTINHERIT";

case 234: return "R_PARISC_TLS_GD21L";
case 235: return "R_PARISC_TLS_GD14R";
case 236: return "R_PARISC_TLS_GDCALL";
case 237: return "R_PARISC_TLS_LDM21L";
case 238: return "R_PARISC_TLS_LDM14R";
case 239: return "R_PARISC_TLS_LDMCALL";
case 240: return "R_PARISC_TLS_LDO21L";
case 241: return "R_PARISC_TLS_LDO14R";
case 242: return "R_PARISC_TLS_DTPMOD32";
case 243: return "R_PARISC_TLS_DTPMOD64";
case 244: return "R_PARISC_TLS_DTPOFF32";
case 245: return "R_PARISC_TLS_DTPOFF64";

default: return 
# 496 "./../include/elf/hppa.h" 3 4
((void *)0)
# 496 "./../include/elf/hppa.h"
; } }
# 118 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/i386.h" 1
# 25 "./../include/elf/i386.h"
static const char *elf_i386_reloc_type (unsigned long rtype); static const char * elf_i386_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_386_NONE";
     case 1: return "R_386_32";
     case 2: return "R_386_PC32";
     case 3: return "R_386_GOT32";
     case 4: return "R_386_PLT32";
     case 5: return "R_386_COPY";
     case 6: return "R_386_GLOB_DAT";
     case 7: return "R_386_JUMP_SLOT";
     case 8: return "R_386_RELATIVE";
     case 9: return "R_386_GOTOFF";
     case 10: return "R_386_GOTPC";
     case 11: return "R_386_32PLT";
    
    
     case 14: return "R_386_TLS_TPOFF";
     case 15: return "R_386_TLS_IE";
     case 16: return "R_386_TLS_GOTIE";
     case 17: return "R_386_TLS_LE";
     case 18: return "R_386_TLS_GD";
     case 19: return "R_386_TLS_LDM";
     case 20: return "R_386_16";
     case 21: return "R_386_PC16";
     case 22: return "R_386_8";
     case 23: return "R_386_PC8";
     case 24: return "R_386_TLS_GD_32";
     case 25: return "R_386_TLS_GD_PUSH";
     case 26: return "R_386_TLS_GD_CALL";
     case 27: return "R_386_TLS_GD_POP";
     case 28: return "R_386_TLS_LDM_32";
     case 29: return "R_386_TLS_LDM_PUSH";
     case 30: return "R_386_TLS_LDM_CALL";
     case 31: return "R_386_TLS_LDM_POP";
     case 32: return "R_386_TLS_LDO_32";
     case 33: return "R_386_TLS_IE_32";
     case 34: return "R_386_TLS_LE_32";
     case 35: return "R_386_TLS_DTPMOD32";
     case 36: return "R_386_TLS_DTPOFF32";
     case 37: return "R_386_TLS_TPOFF32";
     case 38: return "R_386_SIZE32";
     case 39: return "R_386_TLS_GOTDESC";
     case 40: return "R_386_TLS_DESC_CALL";
     case 41: return "R_386_TLS_DESC";
     case 42: return "R_386_IRELATIVE";

     case 43: return "R_386_GOT32X";


     case 200: return "R_386_USED_BY_INTEL_200";


     case 250: return "R_386_GNU_VTINHERIT";
     case 251: return "R_386_GNU_VTENTRY";
default: return 
# 78 "./../include/elf/i386.h" 3 4
((void *)0)
# 78 "./../include/elf/i386.h"
; } }
# 119 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/i370.h" 1
# 46 "./../include/elf/i370.h"
static const char *i370_reloc_type (unsigned long rtype); static const char * i370_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_I370_NONE";
  case 1: return "R_I370_ADDR31";
  case 2: return "R_I370_ADDR32";
  case 3: return "R_I370_ADDR16";
  case 4: return "R_I370_REL31";
  case 5: return "R_I370_REL32";
  case 6: return "R_I370_ADDR12";
  case 7: return "R_I370_REL12";
  case 8: return "R_I370_ADDR8";
  case 9: return "R_I370_REL8";
  case 10: return "R_I370_COPY";
  case 11: return "R_I370_RELATIVE";
default: return 
# 59 "./../include/elf/i370.h" 3 4
((void *)0)
# 59 "./../include/elf/i370.h"
; } }
# 120 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/i860.h" 1
# 29 "./../include/elf/i860.h"
static const char *elf_i860_reloc_type (unsigned long rtype); static const char * elf_i860_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0x00: return "R_860_NONE";
     case 0x01: return "R_860_32";
     case 0x02: return "R_860_COPY";
     case 0x03: return "R_860_GLOB_DAT";
     case 0x04: return "R_860_JUMP_SLOT";
     case 0x05: return "R_860_RELATIVE";
     case 0x30: return "R_860_PC26";
     case 0x31: return "R_860_PLT26";
     case 0x32: return "R_860_PC16";
     case 0x40: return "R_860_LOW0";
     case 0x42: return "R_860_SPLIT0";
     case 0x44: return "R_860_LOW1";
     case 0x46: return "R_860_SPLIT1";
     case 0x48: return "R_860_LOW2";
     case 0x4A: return "R_860_SPLIT2";
     case 0x4C: return "R_860_LOW3";
     case 0x50: return "R_860_LOGOT0";
     case 0x52: return "R_860_SPGOT0";
     case 0x54: return "R_860_LOGOT1";
     case 0x56: return "R_860_SPGOT1";
     case 0x60: return "R_860_LOGOTOFF0";
     case 0x62: return "R_860_SPGOTOFF0";
     case 0x64: return "R_860_LOGOTOFF1";
     case 0x66: return "R_860_SPGOTOFF1";
     case 0x68: return "R_860_LOGOTOFF2";
     case 0x6C: return "R_860_LOGOTOFF3";
     case 0x70: return "R_860_LOPC";
     case 0x80: return "R_860_HIGHADJ";
     case 0x90: return "R_860_HAGOT";
     case 0xA0: return "R_860_HAGOTOFF";
     case 0xB0: return "R_860_HAPC";
     case 0xC0: return "R_860_HIGH";
     case 0xD0: return "R_860_HIGOT";
     case 0xE0: return "R_860_HIGOTOFF";
default: return 
# 64 "./../include/elf/i860.h" 3 4
((void *)0)
# 64 "./../include/elf/i860.h"
; } }
# 121 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/i960.h" 1
# 26 "./../include/elf/i960.h"
static const char *elf_i960_reloc_type (unsigned long rtype); static const char * elf_i960_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_960_NONE";
     case 1: return "R_960_12";
     case 2: return "R_960_32";
     case 3: return "R_960_IP24";
     case 4: return "R_960_SUB";
     case 5: return "R_960_OPTCALL";
     case 6: return "R_960_OPTCALLX";
     case 7: return "R_960_OPTCALLXA";
default: return 
# 35 "./../include/elf/i960.h" 3 4
((void *)0)
# 35 "./../include/elf/i960.h"
; } }
# 122 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/ia64.h" 1
# 217 "./../include/elf/ia64.h"
typedef struct
{
  unsigned char fixup_offset[8];
  unsigned char type[4];
  unsigned char fixup_seg[4];
  unsigned char addend[8];
  unsigned char symvec_index[4];
  unsigned char data_type[4];
} Elf64_External_VMS_IMAGE_FIXUP;

typedef struct
{
  unsigned char rela_offset[8];
  unsigned char type[4];
  unsigned char rela_seg[4];
  unsigned char addend[8];
  unsigned char sym_offset[8];
  unsigned char sym_seg[4];
  unsigned char fill_1[4];
} Elf64_External_VMS_IMAGE_RELA;



typedef struct {
  unsigned char namesz[8];
  unsigned char descsz[8];
  unsigned char type[8];
  char name[1];
} Elf64_External_VMS_Note;
# 264 "./../include/elf/ia64.h"
typedef struct {
  unsigned char major_id[4];
  unsigned char minor_id[4];
  unsigned char manipulation_date[8];
  unsigned char link_flags[8];
  unsigned char elf_flags[4];
  unsigned char _pad[4];
  unsigned char imgid[1];
} Elf64_External_VMS_ORIG_DYN_Note;
# 287 "./../include/elf/ia64.h"
static const char *elf_ia64_reloc_type (unsigned long rtype); static const char * elf_ia64_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0x00: return "R_IA64_NONE";

  case 0x21: return "R_IA64_IMM14";
  case 0x22: return "R_IA64_IMM22";
  case 0x23: return "R_IA64_IMM64";
  case 0x24: return "R_IA64_DIR32MSB";
  case 0x25: return "R_IA64_DIR32LSB";
  case 0x26: return "R_IA64_DIR64MSB";
  case 0x27: return "R_IA64_DIR64LSB";

  case 0x2a: return "R_IA64_GPREL22";
  case 0x2b: return "R_IA64_GPREL64I";
  case 0x2c: return "R_IA64_GPREL32MSB";
  case 0x2d: return "R_IA64_GPREL32LSB";
  case 0x2e: return "R_IA64_GPREL64MSB";
  case 0x2f: return "R_IA64_GPREL64LSB";

  case 0x32: return "R_IA64_LTOFF22";
  case 0x33: return "R_IA64_LTOFF64I";

  case 0x3a: return "R_IA64_PLTOFF22";
  case 0x3b: return "R_IA64_PLTOFF64I";
  case 0x3e: return "R_IA64_PLTOFF64MSB";
  case 0x3f: return "R_IA64_PLTOFF64LSB";

  case 0x43: return "R_IA64_FPTR64I";
  case 0x44: return "R_IA64_FPTR32MSB";
  case 0x45: return "R_IA64_FPTR32LSB";
  case 0x46: return "R_IA64_FPTR64MSB";
  case 0x47: return "R_IA64_FPTR64LSB";

  case 0x48: return "R_IA64_PCREL60B";
  case 0x49: return "R_IA64_PCREL21B";
  case 0x4a: return "R_IA64_PCREL21M";
  case 0x4b: return "R_IA64_PCREL21F";
  case 0x4c: return "R_IA64_PCREL32MSB";
  case 0x4d: return "R_IA64_PCREL32LSB";
  case 0x4e: return "R_IA64_PCREL64MSB";
  case 0x4f: return "R_IA64_PCREL64LSB";

  case 0x52: return "R_IA64_LTOFF_FPTR22";
  case 0x53: return "R_IA64_LTOFF_FPTR64I";
  case 0x54: return "R_IA64_LTOFF_FPTR32MSB";
  case 0x55: return "R_IA64_LTOFF_FPTR32LSB";
  case 0x56: return "R_IA64_LTOFF_FPTR64MSB";
  case 0x57: return "R_IA64_LTOFF_FPTR64LSB";

  case 0x5c: return "R_IA64_SEGREL32MSB";
  case 0x5d: return "R_IA64_SEGREL32LSB";
  case 0x5e: return "R_IA64_SEGREL64MSB";
  case 0x5f: return "R_IA64_SEGREL64LSB";

  case 0x64: return "R_IA64_SECREL32MSB";
  case 0x65: return "R_IA64_SECREL32LSB";
  case 0x66: return "R_IA64_SECREL64MSB";
  case 0x67: return "R_IA64_SECREL64LSB";

  case 0x6c: return "R_IA64_REL32MSB";
  case 0x6d: return "R_IA64_REL32LSB";
  case 0x6e: return "R_IA64_REL64MSB";
  case 0x6f: return "R_IA64_REL64LSB";

  case 0x74: return "R_IA64_LTV32MSB";
  case 0x75: return "R_IA64_LTV32LSB";
  case 0x76: return "R_IA64_LTV64MSB";
  case 0x77: return "R_IA64_LTV64LSB";

  case 0x79: return "R_IA64_PCREL21BI";
  case 0x7a: return "R_IA64_PCREL22";
  case 0x7b: return "R_IA64_PCREL64I";

  case 0x80: return "R_IA64_IPLTMSB";
  case 0x81: return "R_IA64_IPLTLSB";
  case 0x84: return "R_IA64_COPY";
  case 0x86: return "R_IA64_LTOFF22X";
  case 0x87: return "R_IA64_LDXMOV";

  case 0x91: return "R_IA64_TPREL14";
  case 0x92: return "R_IA64_TPREL22";
  case 0x93: return "R_IA64_TPREL64I";
  case 0x96: return "R_IA64_TPREL64MSB";
  case 0x97: return "R_IA64_TPREL64LSB";

  case 0x9a: return "R_IA64_LTOFF_TPREL22";

  case 0xa6: return "R_IA64_DTPMOD64MSB";
  case 0xa7: return "R_IA64_DTPMOD64LSB";
  case 0xaa: return "R_IA64_LTOFF_DTPMOD22";

  case 0xb1: return "R_IA64_DTPREL14";
  case 0xb2: return "R_IA64_DTPREL22";
  case 0xb3: return "R_IA64_DTPREL64I";
  case 0xb4: return "R_IA64_DTPREL32MSB";
  case 0xb5: return "R_IA64_DTPREL32LSB";
  case 0xb6: return "R_IA64_DTPREL64MSB";
  case 0xb7: return "R_IA64_DTPREL64LSB";

  case 0xba: return "R_IA64_LTOFF_DTPREL22";

 


  case 0x70000000: return "R_IA64_VMS_DIR8";
  case 0x70000001: return "R_IA64_VMS_DIR16LSB";
  case 0x70000002: return "R_IA64_VMS_CALL_SIGNATURE";
  case 0x70000003: return "R_IA64_VMS_EXECLET_FUNC";
  case 0x70000004: return "R_IA64_VMS_EXECLET_DATA";
  case 0x70000005: return "R_IA64_VMS_FIX8";
  case 0x70000006: return "R_IA64_VMS_FIX16";
  case 0x70000007: return "R_IA64_VMS_FIX32";
  case 0x70000008: return "R_IA64_VMS_FIX64";
  case 0x70000009: return "R_IA64_VMS_FIXFD";
  case 0x7000000a: return "R_IA64_VMS_ACC_LOAD";
  case 0x7000000b: return "R_IA64_VMS_ACC_ADD";
  case 0x7000000c: return "R_IA64_VMS_ACC_SUB";
  case 0x7000000d: return "R_IA64_VMS_ACC_MUL";
  case 0x7000000e: return "R_IA64_VMS_ACC_DIV";
  case 0x7000000f: return "R_IA64_VMS_ACC_AND";
  case 0x70000010: return "R_IA64_VMS_ACC_IOR";
  case 0x70000011: return "R_IA64_VMS_ACC_EOR";
  case 0x70000012: return "R_IA64_VMS_ACC_ASH";
  case 0x70000014: return "R_IA64_VMS_ACC_STO8";
  case 0x70000015: return "R_IA64_VMS_ACC_STO16LSH";
  case 0x70000016: return "R_IA64_VMS_ACC_STO32LSH";
  case 0x70000017: return "R_IA64_VMS_ACC_STO64LSH";
default: return 
# 413 "./../include/elf/ia64.h" 3 4
((void *)0)
# 413 "./../include/elf/ia64.h"
; } }
# 123 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/ip2k.h" 1
# 26 "./../include/elf/ip2k.h"
static const char *elf_ip2k_reloc_type (unsigned long rtype); static const char * elf_ip2k_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_IP2K_NONE";
  case 1: return "R_IP2K_16";
  case 2: return "R_IP2K_32";
  case 3: return "R_IP2K_FR9";
  case 4: return "R_IP2K_BANK";
  case 5: return "R_IP2K_ADDR16CJP";
  case 6: return "R_IP2K_PAGE3";
  case 7: return "R_IP2K_LO8DATA";
  case 8: return "R_IP2K_HI8DATA";
  case 9: return "R_IP2K_LO8INSN";
  case 10: return "R_IP2K_HI8INSN";
  case 11: return "R_IP2K_PC_SKIP";
  case 12: return "R_IP2K_TEXT";
  case 13: return "R_IP2K_FR_OFFSET";
  case 14: return "R_IP2K_EX8DATA";
default: return 
# 42 "./../include/elf/ip2k.h" 3 4
((void *)0)
# 42 "./../include/elf/ip2k.h"
; } }
# 124 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/lm32.h" 1
# 27 "./../include/elf/lm32.h"
static const char *elf_lm32_reloc_type (unsigned long rtype); static const char * elf_lm32_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_LM32_NONE";
     case 1: return "R_LM32_8";
     case 2: return "R_LM32_16";
     case 3: return "R_LM32_32";
     case 4: return "R_LM32_HI16";
     case 5: return "R_LM32_LO16";
     case 6: return "R_LM32_GPREL16";
     case 7: return "R_LM32_CALL";
     case 8: return "R_LM32_BRANCH";
     case 9: return "R_LM32_GNU_VTINHERIT";
     case 10: return "R_LM32_GNU_VTENTRY";
     case 11: return "R_LM32_16_GOT";
     case 12: return "R_LM32_GOTOFF_HI16";
     case 13: return "R_LM32_GOTOFF_LO16";
     case 14: return "R_LM32_COPY";
     case 15: return "R_LM32_GLOB_DAT";
     case 16: return "R_LM32_JMP_SLOT";
     case 17: return "R_LM32_RELATIVE";
default: return 
# 46 "./../include/elf/lm32.h" 3 4
((void *)0)
# 46 "./../include/elf/lm32.h"
; } }
# 125 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/iq2000.h" 1
# 26 "./../include/elf/iq2000.h"
static const char *elf_iq2000_reloc_type (unsigned long rtype); static const char * elf_iq2000_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_IQ2000_NONE";
  case 1: return "R_IQ2000_16";
  case 2: return "R_IQ2000_32";
  case 3: return "R_IQ2000_26";
  case 4: return "R_IQ2000_PC16";
  case 5: return "R_IQ2000_HI16";
  case 6: return "R_IQ2000_LO16";
  case 7: return "R_IQ2000_OFFSET_16";
  case 8: return "R_IQ2000_OFFSET_21";
  case 9: return "R_IQ2000_UHI16";
  case 10: return "R_IQ2000_32_DEBUG";
  case 200: return "R_IQ2000_GNU_VTINHERIT";
  case 201: return "R_IQ2000_GNU_VTENTRY";
default: return 
# 40 "./../include/elf/iq2000.h" 3 4
((void *)0)
# 40 "./../include/elf/iq2000.h"
; } }
# 126 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/m32c.h" 1
# 26 "./../include/elf/m32c.h"
  static const char *elf_m32c_reloc_type (unsigned long rtype); static const char * elf_m32c_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_M32C_NONE";
     case 1: return "R_M32C_16";
     case 2: return "R_M32C_24";
     case 3: return "R_M32C_32";
     case 4: return "R_M32C_8_PCREL";
     case 5: return "R_M32C_16_PCREL";


     case 6: return "R_M32C_8";

     case 7: return "R_M32C_LO16";

     case 8: return "R_M32C_HI8";

     case 9: return "R_M32C_HI16";



     case 10: return "R_M32C_RL_JUMP";

     case 11: return "R_M32C_RL_1ADDR";

     case 12: return "R_M32C_RL_2ADDR";

     default: return 
# 51 "./../include/elf/m32c.h" 3 4
    ((void *)0)
# 51 "./../include/elf/m32c.h"
    ; } }
# 127 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/m32r.h" 1
# 26 "./../include/elf/m32r.h"
static const char *elf_m32r_reloc_type (unsigned long rtype); static const char * elf_m32r_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_M32R_NONE";

  case 1: return "R_M32R_16";
  case 2: return "R_M32R_32";
  case 3: return "R_M32R_24";
  case 4: return "R_M32R_10_PCREL";
  case 5: return "R_M32R_18_PCREL";
  case 6: return "R_M32R_26_PCREL";
  case 7: return "R_M32R_HI16_ULO";
  case 8: return "R_M32R_HI16_SLO";
  case 9: return "R_M32R_LO16";
  case 10: return "R_M32R_SDA16";
  case 11: return "R_M32R_GNU_VTINHERIT";
  case 12: return "R_M32R_GNU_VTENTRY";


  case 33: return "R_M32R_16_RELA";
  case 34: return "R_M32R_32_RELA";
  case 35: return "R_M32R_24_RELA";
  case 36: return "R_M32R_10_PCREL_RELA";
  case 37: return "R_M32R_18_PCREL_RELA";
  case 38: return "R_M32R_26_PCREL_RELA";
  case 39: return "R_M32R_HI16_ULO_RELA";
  case 40: return "R_M32R_HI16_SLO_RELA";
  case 41: return "R_M32R_LO16_RELA";
  case 42: return "R_M32R_SDA16_RELA";
  case 43: return "R_M32R_RELA_GNU_VTINHERIT";
  case 44: return "R_M32R_RELA_GNU_VTENTRY";

  case 45: return "R_M32R_REL32";

  case 48: return "R_M32R_GOT24";
  case 49: return "R_M32R_26_PLTREL";
  case 50: return "R_M32R_COPY";
  case 51: return "R_M32R_GLOB_DAT";
  case 52: return "R_M32R_JMP_SLOT";
  case 53: return "R_M32R_RELATIVE";
  case 54: return "R_M32R_GOTOFF";
  case 55: return "R_M32R_GOTPC24";
  case 56: return "R_M32R_GOT16_HI_ULO";
  case 57: return "R_M32R_GOT16_HI_SLO";
  case 58: return "R_M32R_GOT16_LO";
  case 59: return "R_M32R_GOTPC_HI_ULO";
  case 60: return "R_M32R_GOTPC_HI_SLO";
  case 61: return "R_M32R_GOTPC_LO";
  case 62: return "R_M32R_GOTOFF_HI_ULO";
  case 63: return "R_M32R_GOTOFF_HI_SLO";
  case 64: return "R_M32R_GOTOFF_LO";

default: return 
# 76 "./../include/elf/m32r.h" 3 4
((void *)0)
# 76 "./../include/elf/m32r.h"
; } }
# 128 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/m68k.h" 1
# 26 "./../include/elf/m68k.h"
static const char *elf_m68k_reloc_type (unsigned long rtype); static const char * elf_m68k_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_68K_NONE";
  case 1: return "R_68K_32";
  case 2: return "R_68K_16";
  case 3: return "R_68K_8";
  case 4: return "R_68K_PC32";
  case 5: return "R_68K_PC16";
  case 6: return "R_68K_PC8";
  case 7: return "R_68K_GOT32";
  case 8: return "R_68K_GOT16";
  case 9: return "R_68K_GOT8";
  case 10: return "R_68K_GOT32O";
  case 11: return "R_68K_GOT16O";
  case 12: return "R_68K_GOT8O";
  case 13: return "R_68K_PLT32";
  case 14: return "R_68K_PLT16";
  case 15: return "R_68K_PLT8";
  case 16: return "R_68K_PLT32O";
  case 17: return "R_68K_PLT16O";
  case 18: return "R_68K_PLT8O";
  case 19: return "R_68K_COPY";
  case 20: return "R_68K_GLOB_DAT";
  case 21: return "R_68K_JMP_SLOT";
  case 22: return "R_68K_RELATIVE";

  case 23: return "R_68K_GNU_VTINHERIT";
  case 24: return "R_68K_GNU_VTENTRY";

  case 25: return "R_68K_TLS_GD32";
  case 26: return "R_68K_TLS_GD16";
  case 27: return "R_68K_TLS_GD8";
  case 28: return "R_68K_TLS_LDM32";
  case 29: return "R_68K_TLS_LDM16";
  case 30: return "R_68K_TLS_LDM8";
  case 31: return "R_68K_TLS_LDO32";
  case 32: return "R_68K_TLS_LDO16";
  case 33: return "R_68K_TLS_LDO8";
  case 34: return "R_68K_TLS_IE32";
  case 35: return "R_68K_TLS_IE16";
  case 36: return "R_68K_TLS_IE8";
  case 37: return "R_68K_TLS_LE32";
  case 38: return "R_68K_TLS_LE16";
  case 39: return "R_68K_TLS_LE8";
  case 40: return "R_68K_TLS_DTPMOD32";
  case 41: return "R_68K_TLS_DTPREL32";
  case 42: return "R_68K_TLS_TPREL32";
default: return 
# 72 "./../include/elf/m68k.h" 3 4
((void *)0)
# 72 "./../include/elf/m68k.h"
; } }
# 102 "./../include/elf/m68k.h"
enum
{






  Tag_GNU_M68K_ABI_FP = 4,
};
# 129 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/m68hc11.h" 1
# 26 "./../include/elf/m68hc11.h"
static const char *elf_m68hc11_reloc_type (unsigned long rtype); static const char * elf_m68hc11_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_M68HC11_NONE";
  case 1: return "R_M68HC11_8";
  case 2: return "R_M68HC11_HI8";
  case 3: return "R_M68HC11_LO8";
  case 4: return "R_M68HC11_PCREL_8";
  case 5: return "R_M68HC11_16";
  case 6: return "R_M68HC11_32";
  case 7: return "R_M68HC11_3B";
  case 8: return "R_M68HC11_PCREL_16";


  case 9: return "R_M68HC11_GNU_VTINHERIT";
  case 10: return "R_M68HC11_GNU_VTENTRY";

  case 11: return "R_M68HC11_24";
  case 12: return "R_M68HC11_LO16";
  case 13: return "R_M68HC11_PAGE";

  case 15: return "R_M68HC12_16B";
  case 16: return "R_M68HC12_PCREL_9";
  case 17: return "R_M68HC12_PCREL_10";
  case 18: return "R_M68HC12_HI8XG";
  case 19: return "R_M68HC12_LO8XG";



  case 20: return "R_M68HC11_RL_JUMP";


  case 21: return "R_M68HC11_RL_GROUP";
default: return 
# 57 "./../include/elf/m68hc11.h" 3 4
((void *)0)
# 57 "./../include/elf/m68hc11.h"
; } }
# 130 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/s12z.h" 1
# 26 "./../include/elf/s12z.h"
static const char *elf_s12z_reloc_type (unsigned long rtype); static const char * elf_s12z_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_S12Z_NONE";
  case 1: return "R_S12Z_OPR";
  case 2: return "R_S12Z_UKNWN_2";
  case 3: return "R_S12Z_PCREL_7_15";
  case 4: return "R_S12Z_EXT24";
  case 5: return "R_S12Z_EXT18";
  case 6: return "R_S12Z_CW32";
  case 7: return "R_S12Z_EXT32";
default: return 
# 35 "./../include/elf/s12z.h" 3 4
((void *)0)
# 35 "./../include/elf/s12z.h"
; } }
# 131 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/mcore.h" 1
# 28 "./../include/elf/mcore.h"
static const char *elf_mcore_reloc_type (unsigned long rtype); static const char * elf_mcore_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MCORE_NONE";
  case 1: return "R_MCORE_ADDR32";
  case 2: return "R_MCORE_PCRELIMM8BY4";
  case 3: return "R_MCORE_PCRELIMM11BY2";
  case 4: return "R_MCORE_PCRELIMM4BY2";
  case 5: return "R_MCORE_PCREL32";
  case 6: return "R_MCORE_PCRELJSR_IMM11BY2";
  case 7: return "R_MCORE_GNU_VTINHERIT";
  case 8: return "R_MCORE_GNU_VTENTRY";
  case 9: return "R_MCORE_RELATIVE";
  case 10: return "R_MCORE_COPY";
  case 11: return "R_MCORE_GLOB_DAT";
  case 12: return "R_MCORE_JUMP_SLOT";
default: return 
# 42 "./../include/elf/mcore.h" 3 4
((void *)0)
# 42 "./../include/elf/mcore.h"
; } }
# 132 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/mep.h" 1
# 33 "./../include/elf/mep.h"
static const char *elf_mep_reloc_type (unsigned long rtype); static const char * elf_mep_reloc_type (unsigned long rtype) { switch (rtype) {


  case 0: return "R_MEP_NONE";
  case 1: return "R_RELC";

  case 2: return "R_MEP_8";
  case 3: return "R_MEP_16";
  case 4: return "R_MEP_32";

  case 5: return "R_MEP_PCREL8A2";
  case 6: return "R_MEP_PCREL12A2";
  case 7: return "R_MEP_PCREL17A2";
  case 8: return "R_MEP_PCREL24A2";
  case 9: return "R_MEP_PCABS24A2";

  case 10: return "R_MEP_LOW16";
  case 11: return "R_MEP_HI16U";
  case 12: return "R_MEP_HI16S";
  case 13: return "R_MEP_GPREL";
  case 14: return "R_MEP_TPREL";

  case 15: return "R_MEP_TPREL7";
  case 16: return "R_MEP_TPREL7A2";
  case 17: return "R_MEP_TPREL7A4";

  case 18: return "R_MEP_UIMM24";
  case 19: return "R_MEP_ADDR24A4";

  case 20: return "R_MEP_GNU_VTINHERIT";
  case 21: return "R_MEP_GNU_VTENTRY";

default: return 
# 65 "./../include/elf/mep.h" 3 4
((void *)0)
# 65 "./../include/elf/mep.h"
; } }
# 133 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/metag.h" 1
# 28 "./../include/elf/metag.h"
static const char *elf_metag_reloc_type (unsigned long rtype); static const char * elf_metag_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_METAG_HIADDR16";
     case 1: return "R_METAG_LOADDR16";
     case 2: return "R_METAG_ADDR32";
     case 3: return "R_METAG_NONE";
     case 4: return "R_METAG_RELBRANCH";
     case 5: return "R_METAG_GETSETOFF";


     case 6: return "R_METAG_REG32OP1";
     case 7: return "R_METAG_REG32OP2";
     case 8: return "R_METAG_REG32OP3";
     case 9: return "R_METAG_REG16OP1";
     case 10: return "R_METAG_REG16OP2";
     case 11: return "R_METAG_REG16OP3";
     case 12: return "R_METAG_REG32OP4";

     case 13: return "R_METAG_HIOG";
     case 14: return "R_METAG_LOOG";

     case 15: return "R_METAG_REL8";
     case 16: return "R_METAG_REL16";


     case 30: return "R_METAG_GNU_VTINHERIT";
     case 31: return "R_METAG_GNU_VTENTRY";


     case 32: return "R_METAG_HI16_GOTOFF";
     case 33: return "R_METAG_LO16_GOTOFF";
     case 34: return "R_METAG_GETSET_GOTOFF";
     case 35: return "R_METAG_GETSET_GOT";
     case 36: return "R_METAG_HI16_GOTPC";
     case 37: return "R_METAG_LO16_GOTPC";
     case 38: return "R_METAG_HI16_PLT";
     case 39: return "R_METAG_LO16_PLT";
     case 40: return "R_METAG_RELBRANCH_PLT";
     case 41: return "R_METAG_GOTOFF";
     case 42: return "R_METAG_PLT";
     case 43: return "R_METAG_COPY";
     case 44: return "R_METAG_JMP_SLOT";
     case 45: return "R_METAG_RELATIVE";
     case 46: return "R_METAG_GLOB_DAT";


     case 47: return "R_METAG_TLS_GD";
     case 48: return "R_METAG_TLS_LDM";
     case 49: return "R_METAG_TLS_LDO_HI16";
     case 50: return "R_METAG_TLS_LDO_LO16";
     case 51: return "R_METAG_TLS_LDO";
     case 52: return "R_METAG_TLS_IE";
     case 53: return "R_METAG_TLS_IENONPIC";
     case 54: return "R_METAG_TLS_IENONPIC_HI16";
     case 55: return "R_METAG_TLS_IENONPIC_LO16";
     case 56: return "R_METAG_TLS_TPOFF";
     case 57: return "R_METAG_TLS_DTPMOD";
     case 58: return "R_METAG_TLS_DTPOFF";
     case 59: return "R_METAG_TLS_LE";
     case 60: return "R_METAG_TLS_LE_HI16";
     case 61: return "R_METAG_TLS_LE_LO16";

default: return 
# 89 "./../include/elf/metag.h" 3 4
((void *)0)
# 89 "./../include/elf/metag.h"
; } }
# 134 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/microblaze.h" 1
# 30 "./../include/elf/microblaze.h"
static const char *elf_microblaze_reloc_type (unsigned long rtype); static const char * elf_microblaze_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MICROBLAZE_NONE";
  case 1: return "R_MICROBLAZE_32";
  case 2: return "R_MICROBLAZE_32_PCREL";
  case 3: return "R_MICROBLAZE_64_PCREL";
  case 4: return "R_MICROBLAZE_32_PCREL_LO";
  case 5: return "R_MICROBLAZE_64";
  case 6: return "R_MICROBLAZE_32_LO";
  case 7: return "R_MICROBLAZE_SRO32";
  case 8: return "R_MICROBLAZE_SRW32";
  case 9: return "R_MICROBLAZE_64_NONE";
  case 10: return "R_MICROBLAZE_32_SYM_OP_SYM";
  case 11: return "R_MICROBLAZE_GNU_VTINHERIT";
  case 12: return "R_MICROBLAZE_GNU_VTENTRY";
  case 13: return "R_MICROBLAZE_GOTPC_64";
  case 14: return "R_MICROBLAZE_GOT_64";
  case 15: return "R_MICROBLAZE_PLT_64";
  case 16: return "R_MICROBLAZE_REL";
  case 17: return "R_MICROBLAZE_JUMP_SLOT";
  case 18: return "R_MICROBLAZE_GLOB_DAT";
  case 19: return "R_MICROBLAZE_GOTOFF_64";
  case 20: return "R_MICROBLAZE_GOTOFF_32";
  case 21: return "R_MICROBLAZE_COPY";
  case 22: return "R_MICROBLAZE_TLS";
  case 23: return "R_MICROBLAZE_TLSGD";
  case 24: return "R_MICROBLAZE_TLSLD";
  case 25: return "R_MICROBLAZE_TLSDTPMOD32";
  case 26: return "R_MICROBLAZE_TLSDTPREL32";
  case 27: return "R_MICROBLAZE_TLSDTPREL64";
  case 28: return "R_MICROBLAZE_TLSGOTTPREL32";
  case 29: return "R_MICROBLAZE_TLSTPREL32";
  case 30: return "R_MICROBLAZE_TEXTPCREL_64";
  case 31: return "R_MICROBLAZE_TEXTREL_64";
  case 32: return "R_MICROBLAZE_TEXTREL_32_LO";
default: return 
# 64 "./../include/elf/microblaze.h" 3 4
((void *)0)
# 64 "./../include/elf/microblaze.h"
; } }
# 135 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/mips.h" 1
# 38 "./../include/elf/mips.h"
static const char *elf_mips_reloc_type (unsigned long rtype); static const char * elf_mips_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MIPS_NONE";
  case 1: return "R_MIPS_16";
  case 2: return "R_MIPS_32";
  case 3: return "R_MIPS_REL32";
  case 4: return "R_MIPS_26";
  case 5: return "R_MIPS_HI16";
  case 6: return "R_MIPS_LO16";
  case 7: return "R_MIPS_GPREL16";
  case 8: return "R_MIPS_LITERAL";
  case 9: return "R_MIPS_GOT16";
  case 10: return "R_MIPS_PC16";
  case 11: return "R_MIPS_CALL16";
  case 12: return "R_MIPS_GPREL32";


  case 13: return "R_MIPS_UNUSED1";
  case 14: return "R_MIPS_UNUSED2";
  case 15: return "R_MIPS_UNUSED3";
  case 16: return "R_MIPS_SHIFT5";
  case 17: return "R_MIPS_SHIFT6";
  case 18: return "R_MIPS_64";
  case 19: return "R_MIPS_GOT_DISP";
  case 20: return "R_MIPS_GOT_PAGE";
  case 21: return "R_MIPS_GOT_OFST";
  case 22: return "R_MIPS_GOT_HI16";
  case 23: return "R_MIPS_GOT_LO16";
  case 24: return "R_MIPS_SUB";
  case 25: return "R_MIPS_INSERT_A";
  case 26: return "R_MIPS_INSERT_B";
  case 27: return "R_MIPS_DELETE";
  case 28: return "R_MIPS_HIGHER";
  case 29: return "R_MIPS_HIGHEST";
  case 30: return "R_MIPS_CALL_HI16";
  case 31: return "R_MIPS_CALL_LO16";
  case 32: return "R_MIPS_SCN_DISP";
  case 33: return "R_MIPS_REL16";
  case 34: return "R_MIPS_ADD_IMMEDIATE";
  case 35: return "R_MIPS_PJUMP";
  case 36: return "R_MIPS_RELGOT";
  case 37: return "R_MIPS_JALR";

  case 38: return "R_MIPS_TLS_DTPMOD32";
  case 39: return "R_MIPS_TLS_DTPREL32";
  case 40: return "R_MIPS_TLS_DTPMOD64";
  case 41: return "R_MIPS_TLS_DTPREL64";
  case 42: return "R_MIPS_TLS_GD";
  case 43: return "R_MIPS_TLS_LDM";
  case 44: return "R_MIPS_TLS_DTPREL_HI16";
  case 45: return "R_MIPS_TLS_DTPREL_LO16";
  case 46: return "R_MIPS_TLS_GOTTPREL";
  case 47: return "R_MIPS_TLS_TPREL32";
  case 48: return "R_MIPS_TLS_TPREL64";
  case 49: return "R_MIPS_TLS_TPREL_HI16";
  case 50: return "R_MIPS_TLS_TPREL_LO16";
  case 51: return "R_MIPS_GLOB_DAT";

  case 60: return "R_MIPS_PC21_S2";
  case 61: return "R_MIPS_PC26_S2";
  case 62: return "R_MIPS_PC18_S3";
  case 63: return "R_MIPS_PC19_S2";
  case 64: return "R_MIPS_PCHI16";
  case 65: return "R_MIPS_PCLO16";
 

 
  case 100: return "R_MIPS16_26";
  case 101: return "R_MIPS16_GPREL";
  case 102: return "R_MIPS16_GOT16";
  case 103: return "R_MIPS16_CALL16";
  case 104: return "R_MIPS16_HI16";
  case 105: return "R_MIPS16_LO16";
  case 106: return "R_MIPS16_TLS_GD";
  case 107: return "R_MIPS16_TLS_LDM";
  case 108: return "R_MIPS16_TLS_DTPREL_HI16";
  case 109: return "R_MIPS16_TLS_DTPREL_LO16";
  case 110: return "R_MIPS16_TLS_GOTTPREL";
  case 111: return "R_MIPS16_TLS_TPREL_HI16";
  case 112: return "R_MIPS16_TLS_TPREL_LO16";
  case 113: return "R_MIPS16_PC16_S1";
 

  case 126: return "R_MIPS_COPY";
  case 127: return "R_MIPS_JUMP_SLOT";


 
  case 133: return "R_MICROMIPS_26_S1";
  case 134: return "R_MICROMIPS_HI16";
  case 135: return "R_MICROMIPS_LO16";
  case 136: return "R_MICROMIPS_GPREL16";

  case 137: return "R_MICROMIPS_LITERAL";
  case 138: return "R_MICROMIPS_GOT16";

  case 139: return "R_MICROMIPS_PC7_S1";
  case 140: return "R_MICROMIPS_PC10_S1";
  case 141: return "R_MICROMIPS_PC16_S1";
  case 142: return "R_MICROMIPS_CALL16";

  case 145: return "R_MICROMIPS_GOT_DISP";
  case 146: return "R_MICROMIPS_GOT_PAGE";
  case 147: return "R_MICROMIPS_GOT_OFST";
  case 148: return "R_MICROMIPS_GOT_HI16";
  case 149: return "R_MICROMIPS_GOT_LO16";
  case 150: return "R_MICROMIPS_SUB";
  case 151: return "R_MICROMIPS_HIGHER";
  case 152: return "R_MICROMIPS_HIGHEST";
  case 153: return "R_MICROMIPS_CALL_HI16";
  case 154: return "R_MICROMIPS_CALL_LO16";
  case 155: return "R_MICROMIPS_SCN_DISP";
  case 156: return "R_MICROMIPS_JALR";
  case 157: return "R_MICROMIPS_HI0_LO16";

  case 162: return "R_MICROMIPS_TLS_GD";
  case 163: return "R_MICROMIPS_TLS_LDM";
  case 164: return "R_MICROMIPS_TLS_DTPREL_HI16";
  case 165: return "R_MICROMIPS_TLS_DTPREL_LO16";
  case 166: return "R_MICROMIPS_TLS_GOTTPREL";
  case 169: return "R_MICROMIPS_TLS_TPREL_HI16";
  case 170: return "R_MICROMIPS_TLS_TPREL_LO16";

  case 172: return "R_MICROMIPS_GPREL7_S2";
  case 173: return "R_MICROMIPS_PC23_S2";
 




  case 248: return "R_MIPS_PC32";
  case 249: return "R_MIPS_EH";

  case 250: return "R_MIPS_GNU_REL16_S2";

  case 253: return "R_MIPS_GNU_VTINHERIT";
  case 254: return "R_MIPS_GNU_VTENTRY";
default: return 
# 174 "./../include/elf/mips.h" 3 4
((void *)0)
# 174 "./../include/elf/mips.h"
; } }
# 463 "./../include/elf/mips.h"
typedef struct
{

  unsigned long l_name;

  unsigned long l_time_stamp;

  unsigned long l_checksum;

  unsigned long l_version;

  unsigned long l_flags;
} Elf32_Lib;


typedef struct
{
  unsigned char l_name[4];
  unsigned char l_time_stamp[4];
  unsigned char l_checksum[4];
  unsigned char l_version[4];
  unsigned char l_flags[4];
} Elf32_External_Lib;
# 511 "./../include/elf/mips.h"
typedef unsigned long Elf32_Conflict;
typedef unsigned char Elf32_External_Conflict[4];

typedef unsigned long Elf64_Conflict;
typedef unsigned char Elf64_External_Conflict[8];
# 525 "./../include/elf/mips.h"
typedef union
{
  struct
    {

      unsigned long gt_current_g_value;

      unsigned long gt_unused;
    } gt_header;
  struct
    {

      unsigned long gt_g_value;

      unsigned long gt_bytes;
    } gt_entry;
} Elf32_gptab;



typedef union
{
  struct
    {
      unsigned char gt_current_g_value[4];
      unsigned char gt_unused[4];
    } gt_header;
  struct
    {
      unsigned char gt_g_value[4];
      unsigned char gt_bytes[4];
    } gt_entry;
} Elf32_External_gptab;



typedef struct
{

  uint32_t ri_gprmask;

  uint32_t ri_cprmask[4];

  uint32_t ri_gp_value;
} Elf32_RegInfo;


typedef struct
{
  unsigned char ri_gprmask[4];
  unsigned char ri_cprmask[4][4];
  unsigned char ri_gp_value[4];
} Elf32_External_RegInfo;


extern void bfd_mips_elf32_swap_reginfo_in
  (bfd *, const Elf32_External_RegInfo *, Elf32_RegInfo *);
extern void bfd_mips_elf32_swap_reginfo_out
  (bfd *, const Elf32_RegInfo *, Elf32_External_RegInfo *);
# 900 "./../include/elf/mips.h"
typedef struct
{

  unsigned char r_offset[8];

  unsigned char r_sym[4];

  unsigned char r_ssym[1];

  unsigned char r_type3[1];

  unsigned char r_type2[1];

  unsigned char r_type[1];
} Elf64_Mips_External_Rel;

typedef struct
{

  bfd_vma r_offset;

  unsigned long r_sym;

  unsigned char r_ssym;

  unsigned char r_type3;

  unsigned char r_type2;

  unsigned char r_type;
} Elf64_Mips_Internal_Rel;



typedef struct
{

  unsigned char r_offset[8];

  unsigned char r_sym[4];

  unsigned char r_ssym[1];

  unsigned char r_type3[1];

  unsigned char r_type2[1];

  unsigned char r_type[1];

  unsigned char r_addend[8];
} Elf64_Mips_External_Rela;

typedef struct
{

  bfd_vma r_offset;

  unsigned long r_sym;

  unsigned char r_ssym;

  unsigned char r_type3;

  unsigned char r_type2;

  unsigned char r_type;

  bfd_signed_vma r_addend;
} Elf64_Mips_Internal_Rela;
# 993 "./../include/elf/mips.h"
typedef struct
{

  unsigned char kind[1];

  unsigned char size[1];

  unsigned char section[2];

  unsigned char info[4];
} Elf_External_Options;

typedef struct
{

  unsigned char kind;

  unsigned char size;

  uint16_t section;

  uint32_t info;
} Elf_Internal_Options;


extern void bfd_mips_elf_swap_options_in
  (bfd *, const Elf_External_Options *, Elf_Internal_Options *);
extern void bfd_mips_elf_swap_options_out
  (bfd *, const Elf_Internal_Options *, Elf_External_Options *);
# 1063 "./../include/elf/mips.h"
typedef struct
{

  unsigned char ri_gprmask[4];

  unsigned char ri_pad[4];

  unsigned char ri_cprmask[4][4];

  unsigned char ri_gp_value[8];
} Elf64_External_RegInfo;

typedef struct
{

  uint32_t ri_gprmask;

  uint32_t ri_pad;

  uint32_t ri_cprmask[4];

  uint64_t ri_gp_value;
} Elf64_Internal_RegInfo;



typedef struct
{

  unsigned char version[2];

  unsigned char isa_level[1];

  unsigned char isa_rev[1];

  unsigned char gpr_size[1];

  unsigned char cpr1_size[1];

  unsigned char cpr2_size[1];

  unsigned char fp_abi[1];

  unsigned char isa_ext[4];

  unsigned char ases[4];

  unsigned char flags1[4];
  unsigned char flags2[4];
} Elf_External_ABIFlags_v0;

typedef struct elf_internal_abiflags_v0
{

  unsigned short version;

  unsigned char isa_level;

  unsigned char isa_rev;

  unsigned char gpr_size;

  unsigned char cpr1_size;

  unsigned char cpr2_size;

  unsigned char fp_abi;

  unsigned long isa_ext;

  unsigned long ases;

  unsigned long flags1;
  unsigned long flags2;
} Elf_Internal_ABIFlags_v0;

typedef struct
{


  unsigned char ms_hash_value[4];







  unsigned char ms_info[4];
} Elf32_External_Msym;

typedef struct
{


  unsigned long ms_hash_value;







  unsigned long ms_info;
} Elf32_Internal_Msym;






extern void bfd_mips_elf64_swap_reginfo_in
  (bfd *, const Elf64_External_RegInfo *, Elf64_Internal_RegInfo *);
extern void bfd_mips_elf64_swap_reginfo_out
  (bfd *, const Elf64_Internal_RegInfo *, Elf64_External_RegInfo *);


extern void bfd_mips_elf_swap_abiflags_v0_in
  (bfd *, const Elf_External_ABIFlags_v0 *, Elf_Internal_ABIFlags_v0 *);
extern void bfd_mips_elf_swap_abiflags_v0_out
  (bfd *, const Elf_Internal_ABIFlags_v0 *, Elf_External_ABIFlags_v0 *);
# 1281 "./../include/elf/mips.h"
extern unsigned int bfd_mips_isa_ext (bfd *);



enum
{



  Tag_GNU_MIPS_ABI_FP = 4,


  Tag_GNU_MIPS_ABI_MSA = 8,
};


enum
{



  Val_GNU_MIPS_ABI_FP_ANY = 0,


  Val_GNU_MIPS_ABI_FP_DOUBLE = 1,


  Val_GNU_MIPS_ABI_FP_SINGLE = 2,


  Val_GNU_MIPS_ABI_FP_SOFT = 3,


  Val_GNU_MIPS_ABI_FP_OLD_64 = 4,


  Val_GNU_MIPS_ABI_FP_XX = 5,


  Val_GNU_MIPS_ABI_FP_64 = 6,


  Val_GNU_MIPS_ABI_FP_64A = 7,



  Val_GNU_MIPS_ABI_FP_NAN2008 = 8,




  Val_GNU_MIPS_ABI_MSA_ANY = 0,


  Val_GNU_MIPS_ABI_MSA_128 = 1,
};
# 136 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/mmix.h" 1
# 29 "./../include/elf/mmix.h"
static const char *elf_mmix_reloc_type (unsigned long rtype); static const char * elf_mmix_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MMIX_NONE";


  case 1: return "R_MMIX_8";
  case 2: return "R_MMIX_16";
  case 3: return "R_MMIX_24";
  case 4: return "R_MMIX_32";
  case 5: return "R_MMIX_64";


  case 6: return "R_MMIX_PC_8";
  case 7: return "R_MMIX_PC_16";
  case 8: return "R_MMIX_PC_24";
  case 9: return "R_MMIX_PC_32";
  case 10: return "R_MMIX_PC_64";


  case 11: return "R_MMIX_GNU_VTINHERIT";
  case 12: return "R_MMIX_GNU_VTENTRY";


  case 13: return "R_MMIX_GETA";
  case 14: return "R_MMIX_GETA_1";
  case 15: return "R_MMIX_GETA_2";
  case 16: return "R_MMIX_GETA_3";


  case 17: return "R_MMIX_CBRANCH";
  case 18: return "R_MMIX_CBRANCH_J";
  case 19: return "R_MMIX_CBRANCH_1";
  case 20: return "R_MMIX_CBRANCH_2";
  case 21: return "R_MMIX_CBRANCH_3";


  case 22: return "R_MMIX_PUSHJ";
  case 23: return "R_MMIX_PUSHJ_1";
  case 24: return "R_MMIX_PUSHJ_2";
  case 25: return "R_MMIX_PUSHJ_3";


  case 26: return "R_MMIX_JMP";
  case 27: return "R_MMIX_JMP_1";
  case 28: return "R_MMIX_JMP_2";
  case 29: return "R_MMIX_JMP_3";


  case 30: return "R_MMIX_ADDR19";


  case 31: return "R_MMIX_ADDR27";


  case 32: return "R_MMIX_REG_OR_BYTE";


  case 33: return "R_MMIX_REG";





  case 34: return "R_MMIX_BASE_PLUS_OFFSET";


  case 35: return "R_MMIX_LOCAL";


  case 36: return "R_MMIX_PUSHJ_STUBBABLE";
default: return 
# 98 "./../include/elf/mmix.h" 3 4
((void *)0)
# 98 "./../include/elf/mmix.h"
; } }
# 165 "./../include/elf/mmix.h"
extern 
# 165 "./../include/elf/mmix.h" 3 4
      _Bool 
# 165 "./../include/elf/mmix.h"
           _bfd_mmix_before_linker_allocation
  (bfd *, struct bfd_link_info *);
extern 
# 167 "./../include/elf/mmix.h" 3 4
      _Bool 
# 167 "./../include/elf/mmix.h"
           _bfd_mmix_after_linker_allocation
  (bfd *, struct bfd_link_info *);
extern 
# 169 "./../include/elf/mmix.h" 3 4
      _Bool 
# 169 "./../include/elf/mmix.h"
           _bfd_mmix_check_all_relocs
  (bfd *, struct bfd_link_info *);
# 137 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/mn10200.h" 1
# 29 "./../include/elf/mn10200.h"
static const char *elf_mn10200_reloc_type (unsigned long rtype); static const char * elf_mn10200_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MN10200_NONE";
  case 1: return "R_MN10200_32";
  case 2: return "R_MN10200_16";
  case 3: return "R_MN10200_8";
  case 4: return "R_MN10200_24";
  case 5: return "R_MN10200_PCREL8";
  case 6: return "R_MN10200_PCREL16";
  case 7: return "R_MN10200_PCREL24";
default: return 
# 38 "./../include/elf/mn10200.h" 3 4
((void *)0)
# 38 "./../include/elf/mn10200.h"
; } }
# 138 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/mn10300.h" 1
# 29 "./../include/elf/mn10300.h"
static const char *elf_mn10300_reloc_type (unsigned long rtype); static const char * elf_mn10300_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MN10300_NONE";
  case 1: return "R_MN10300_32";
  case 2: return "R_MN10300_16";
  case 3: return "R_MN10300_8";
  case 4: return "R_MN10300_PCREL32";
  case 5: return "R_MN10300_PCREL16";
  case 6: return "R_MN10300_PCREL8";
  case 7: return "R_MN10300_GNU_VTINHERIT";
  case 8: return "R_MN10300_GNU_VTENTRY";
  case 9: return "R_MN10300_24";
  case 10: return "R_MN10300_GOTPC32";
  case 11: return "R_MN10300_GOTPC16";
  case 12: return "R_MN10300_GOTOFF32";
  case 13: return "R_MN10300_GOTOFF24";
  case 14: return "R_MN10300_GOTOFF16";
  case 15: return "R_MN10300_PLT32";
  case 16: return "R_MN10300_PLT16";
  case 17: return "R_MN10300_GOT32";
  case 18: return "R_MN10300_GOT24";
  case 19: return "R_MN10300_GOT16";
  case 20: return "R_MN10300_COPY";
  case 21: return "R_MN10300_GLOB_DAT";
  case 22: return "R_MN10300_JMP_SLOT";
  case 23: return "R_MN10300_RELATIVE";
  case 24: return "R_MN10300_TLS_GD";
  case 25: return "R_MN10300_TLS_LD";
  case 26: return "R_MN10300_TLS_LDO";
  case 27: return "R_MN10300_TLS_GOTIE";
  case 28: return "R_MN10300_TLS_IE";
  case 29: return "R_MN10300_TLS_LE";
  case 30: return "R_MN10300_TLS_DTPMOD";
  case 31: return "R_MN10300_TLS_DTPOFF";
  case 32: return "R_MN10300_TLS_TPOFF";
  case 33: return "R_MN10300_SYM_DIFF";
  case 34: return "R_MN10300_ALIGN";
default: return 
# 65 "./../include/elf/mn10300.h" 3 4
((void *)0)
# 65 "./../include/elf/mn10300.h"
; } }
# 139 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/moxie.h" 1
# 26 "./../include/elf/moxie.h"
static const char *elf_moxie_reloc_type (unsigned long rtype); static const char * elf_moxie_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MOXIE_NONE";
  case 1: return "R_MOXIE_32";
  case 2: return "R_MOXIE_PCREL10";
default: return 
# 30 "./../include/elf/moxie.h" 3 4
((void *)0)
# 30 "./../include/elf/moxie.h"
; } }
# 140 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/mt.h" 1
# 26 "./../include/elf/mt.h"
static const char *elf_mt_reloc_type (unsigned long rtype); static const char * elf_mt_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_MT_NONE";
  case 1: return "R_MT_16";
  case 2: return "R_MT_32";
  case 3: return "R_MT_32_PCREL";
  case 4: return "R_MT_PC16";
  case 5: return "R_MT_HI16";
  case 6: return "R_MT_LO16";
default: return 
# 34 "./../include/elf/mt.h" 3 4
((void *)0)
# 34 "./../include/elf/mt.h"
; } }
# 141 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/msp430.h" 1
# 64 "./../include/elf/msp430.h"
enum
{






  Tag_GNU_MSP430_Data_Region = 4,
};


enum
{

  OFBA_MSPABI_Val_ISA_NONE = 0,
  OFBA_MSPABI_Val_ISA_MSP430 = 1,
  OFBA_MSPABI_Val_ISA_MSP430X = 2,


  OFBA_MSPABI_Val_Code_Model_NONE = 0,
  OFBA_MSPABI_Val_Code_Model_SMALL = 1,
  OFBA_MSPABI_Val_Code_Model_LARGE = 2,


  OFBA_MSPABI_Val_Data_Model_NONE = 0,
  OFBA_MSPABI_Val_Data_Model_SMALL = 1,
  OFBA_MSPABI_Val_Data_Model_LARGE = 2,
  OFBA_MSPABI_Val_Data_Model_RESTRICTED = 3,


  Val_GNU_MSP430_Data_Region_NONE = 0,

  Val_GNU_MSP430_Data_Region_Lower = 1,


  Val_GNU_MSP430_Data_Region_Any = 2,
};


static const char *elf_msp430_reloc_type (unsigned long rtype); static const char * elf_msp430_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_MSP430_NONE";
     case 1: return "R_MSP430_32";
     case 2: return "R_MSP430_10_PCREL";
     case 3: return "R_MSP430_16";
     case 4: return "R_MSP430_16_PCREL";
     case 5: return "R_MSP430_16_BYTE";
     case 6: return "R_MSP430_16_PCREL_BYTE";
     case 7: return "R_MSP430_2X_PCREL";
     case 8: return "R_MSP430_RL_PCREL";
     case 9: return "R_MSP430_8";
     case 10: return "R_MSP430_SYM_DIFF";
     case 11: return "R_MSP430_GNU_SET_ULEB128";
     case 12: return "R_MSP430_GNU_SUB_ULEB128";
default: return 
# 118 "./../include/elf/msp430.h" 3 4
((void *)0)
# 118 "./../include/elf/msp430.h"
; } }

static const char *elf_msp430x_reloc_type (unsigned long rtype); static const char * elf_msp430x_reloc_type (unsigned long rtype) { switch (rtype) {
     case 1: return "R_MSP430_ABS32";
     case 2: return "R_MSP430_ABS16";
     case 3: return "R_MSP430_ABS8";
     case 4: return "R_MSP430_PCR16";
     case 5: return "R_MSP430X_PCR20_EXT_SRC";
     case 6: return "R_MSP430X_PCR20_EXT_DST";
     case 7: return "R_MSP430X_PCR20_EXT_ODST";
     case 8: return "R_MSP430X_ABS20_EXT_SRC";
     case 9: return "R_MSP430X_ABS20_EXT_DST";
     case 10: return "R_MSP430X_ABS20_EXT_ODST";
     case 11: return "R_MSP430X_ABS20_ADR_SRC";
     case 12: return "R_MSP430X_ABS20_ADR_DST";
     case 13: return "R_MSP430X_PCR16";
     case 14: return "R_MSP430X_PCR20_CALL";
     case 15: return "R_MSP430X_ABS16";
     case 16: return "R_MSP430_ABS_HI16";
     case 17: return "R_MSP430_PREL31";
     case 18: return "R_MSP430_EHTYPE";
     case 19: return "R_MSP430X_10_PCREL";
     case 20: return "R_MSP430X_2X_PCREL";
     case 21: return "R_MSP430X_SYM_DIFF";
     case 22: return "R_MSP430X_GNU_SET_ULEB128";
     case 23: return "R_MSP430X_GNU_SUB_ULEB128";
default: return 
# 144 "./../include/elf/msp430.h" 3 4
((void *)0)
# 144 "./../include/elf/msp430.h"
; } }
# 142 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/nds32.h" 1
# 27 "./../include/elf/nds32.h"
static const char *elf_nds32_reloc_type (unsigned long rtype); static const char * elf_nds32_reloc_type (unsigned long rtype) { switch (rtype) {

  case 0: return "R_NDS32_NONE";

  case 1: return "R_NDS32_16";
  case 2: return "R_NDS32_32";
  case 3: return "R_NDS32_20";
  case 4: return "R_NDS32_9_PCREL";
  case 5: return "R_NDS32_15_PCREL";
  case 6: return "R_NDS32_17_PCREL";
  case 7: return "R_NDS32_25_PCREL";
  case 8: return "R_NDS32_HI20";
  case 9: return "R_NDS32_LO12S3";
  case 10: return "R_NDS32_LO12S2";
  case 11: return "R_NDS32_LO12S1";
  case 12: return "R_NDS32_LO12S0";
  case 13: return "R_NDS32_SDA15S3";
  case 14: return "R_NDS32_SDA15S2";
  case 15: return "R_NDS32_SDA15S1";
  case 16: return "R_NDS32_SDA15S0";
  case 17: return "R_NDS32_GNU_VTINHERIT";
  case 18: return "R_NDS32_GNU_VTENTRY";

  case 19: return "R_NDS32_16_RELA";
  case 20: return "R_NDS32_32_RELA";
  case 21: return "R_NDS32_20_RELA";
  case 22: return "R_NDS32_9_PCREL_RELA";
  case 23: return "R_NDS32_15_PCREL_RELA";
  case 24: return "R_NDS32_17_PCREL_RELA";
  case 25: return "R_NDS32_25_PCREL_RELA";
  case 26: return "R_NDS32_HI20_RELA";
  case 27: return "R_NDS32_LO12S3_RELA";
  case 28: return "R_NDS32_LO12S2_RELA";
  case 29: return "R_NDS32_LO12S1_RELA";
  case 30: return "R_NDS32_LO12S0_RELA";
  case 31: return "R_NDS32_SDA15S3_RELA";
  case 32: return "R_NDS32_SDA15S2_RELA";
  case 33: return "R_NDS32_SDA15S1_RELA";
  case 34: return "R_NDS32_SDA15S0_RELA";
  case 35: return "R_NDS32_RELA_GNU_VTINHERIT";
  case 36: return "R_NDS32_RELA_GNU_VTENTRY";

  case 37: return "R_NDS32_GOT20";
  case 38: return "R_NDS32_25_PLTREL";
  case 39: return "R_NDS32_COPY";
  case 40: return "R_NDS32_GLOB_DAT";
  case 41: return "R_NDS32_JMP_SLOT";
  case 42: return "R_NDS32_RELATIVE";
  case 43: return "R_NDS32_GOTOFF";
  case 44: return "R_NDS32_GOTPC20";
  case 45: return "R_NDS32_GOT_HI20";
  case 46: return "R_NDS32_GOT_LO12";
  case 47: return "R_NDS32_GOTPC_HI20";
  case 48: return "R_NDS32_GOTPC_LO12";
  case 49: return "R_NDS32_GOTOFF_HI20";
  case 50: return "R_NDS32_GOTOFF_LO12";

  case 51: return "R_NDS32_INSN16";

  case 52: return "R_NDS32_LABEL";
  case 53: return "R_NDS32_LONGCALL1";
  case 54: return "R_NDS32_LONGCALL2";
  case 55: return "R_NDS32_LONGCALL3";
  case 56: return "R_NDS32_LONGJUMP1";
  case 57: return "R_NDS32_LONGJUMP2";
  case 58: return "R_NDS32_LONGJUMP3";
  case 59: return "R_NDS32_LOADSTORE";
  case 60: return "R_NDS32_9_FIXED_RELA";
  case 61: return "R_NDS32_15_FIXED_RELA";
  case 62: return "R_NDS32_17_FIXED_RELA";
  case 63: return "R_NDS32_25_FIXED_RELA";
  case 64: return "R_NDS32_PLTREL_HI20";
  case 65: return "R_NDS32_PLTREL_LO12";
  case 66: return "R_NDS32_PLT_GOTREL_HI20";
  case 67: return "R_NDS32_PLT_GOTREL_LO12";
  case 68: return "R_NDS32_SDA12S2_DP_RELA";
  case 69: return "R_NDS32_SDA12S2_SP_RELA";
  case 70: return "R_NDS32_LO12S2_DP_RELA";
  case 71: return "R_NDS32_LO12S2_SP_RELA";
  case 72: return "R_NDS32_LO12S0_ORI_RELA";
  case 73: return "R_NDS32_SDA16S3_RELA";
  case 74: return "R_NDS32_SDA17S2_RELA";
  case 75: return "R_NDS32_SDA18S1_RELA";
  case 76: return "R_NDS32_SDA19S0_RELA";
  case 77: return "R_NDS32_DWARF2_OP1_RELA";
  case 78: return "R_NDS32_DWARF2_OP2_RELA";
  case 79: return "R_NDS32_DWARF2_LEB_RELA";
  case 80: return "R_NDS32_UPDATE_TA_RELA";
  case 81: return "R_NDS32_9_PLTREL";
  case 82: return "R_NDS32_PLT_GOTREL_LO20";
  case 83: return "R_NDS32_PLT_GOTREL_LO15";
  case 84: return "R_NDS32_PLT_GOTREL_LO19";
  case 85: return "R_NDS32_GOT_LO15";
  case 86: return "R_NDS32_GOT_LO19";
  case 87: return "R_NDS32_GOTOFF_LO15";
  case 88: return "R_NDS32_GOTOFF_LO19";
  case 89: return "R_NDS32_GOT15S2_RELA";
  case 90: return "R_NDS32_GOT17S2_RELA";
  case 91: return "R_NDS32_5_RELA";
  case 92: return "R_NDS32_10_UPCREL_RELA";
  case 93: return "R_NDS32_SDA_FP7U2_RELA";
  case 94: return "R_NDS32_WORD_9_PCREL_RELA";
  case 95: return "R_NDS32_25_ABS_RELA";
  case 96: return "R_NDS32_17IFC_PCREL_RELA";
  case 97: return "R_NDS32_10IFCU_PCREL_RELA";

  case 98: return "R_NDS32_TLS_LE_HI20";
  case 99: return "R_NDS32_TLS_LE_LO12";
  case 100: return "R_NDS32_TLS_IE_HI20";
  case 101: return "R_NDS32_TLS_IE_LO12S2";
  case 102: return "R_NDS32_TLS_TPOFF";
  case 103: return "R_NDS32_TLS_LE_20";
  case 104: return "R_NDS32_TLS_LE_15S0";
  case 105: return "R_NDS32_TLS_LE_15S1";
  case 106: return "R_NDS32_TLS_LE_15S2";
  case 107: return "R_NDS32_LONGCALL4";
  case 108: return "R_NDS32_LONGCALL5";
  case 109: return "R_NDS32_LONGCALL6";
  case 110: return "R_NDS32_LONGJUMP4";
  case 111: return "R_NDS32_LONGJUMP5";
  case 112: return "R_NDS32_LONGJUMP6";
  case 113: return "R_NDS32_LONGJUMP7";


  case 115: return "R_NDS32_TLS_IE_LO12";
  case 116: return "R_NDS32_TLS_IEGP_HI20";
  case 117: return "R_NDS32_TLS_IEGP_LO12";
  case 118: return "R_NDS32_TLS_IEGP_LO12S2";
  case 119: return "R_NDS32_TLS_DESC";
  case 120: return "R_NDS32_TLS_DESC_HI20";
  case 121: return "R_NDS32_TLS_DESC_LO12";
  case 122: return "R_NDS32_TLS_DESC_20";
  case 123: return "R_NDS32_TLS_DESC_SDA17S2";



  case 192: return "R_NDS32_RELAX_ENTRY";
  case 193: return "R_NDS32_GOT_SUFF";
  case 194: return "R_NDS32_GOTOFF_SUFF";
  case 195: return "R_NDS32_PLT_GOT_SUFF";
  case 196: return "R_NDS32_MULCALL_SUFF";
  case 197: return "R_NDS32_PTR";
  case 198: return "R_NDS32_PTR_COUNT";
  case 199: return "R_NDS32_PTR_RESOLVED";
  case 200: return "R_NDS32_PLTBLOCK";
  case 201: return "R_NDS32_RELAX_REGION_BEGIN";
  case 202: return "R_NDS32_RELAX_REGION_END";
  case 203: return "R_NDS32_MINUEND";
  case 204: return "R_NDS32_SUBTRAHEND";
  case 205: return "R_NDS32_DIFF8";
  case 206: return "R_NDS32_DIFF16";
  case 207: return "R_NDS32_DIFF32";
  case 208: return "R_NDS32_DIFF_ULEB128";
  case 209: return "R_NDS32_DATA";
  case 210: return "R_NDS32_TRAN";

  case 211: return "R_NDS32_TLS_LE_ADD";
  case 212: return "R_NDS32_TLS_LE_LS";
  case 213: return "R_NDS32_EMPTY";
  case 214: return "R_NDS32_TLS_DESC_ADD";
  case 215: return "R_NDS32_TLS_DESC_FUNC";
  case 216: return "R_NDS32_TLS_DESC_CALL";
  case 217: return "R_NDS32_TLS_DESC_MEM";
  case 218: return "R_NDS32_RELAX_REMOVE";
  case 219: return "R_NDS32_RELAX_GROUP";
  case 220: return "R_NDS32_TLS_IEGP_LW";
  case 221: return "R_NDS32_LSI";


default: return 
# 196 "./../include/elf/nds32.h" 3 4
((void *)0)
# 196 "./../include/elf/nds32.h"
; } }
# 143 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/nfp.h" 1
# 206 "./../include/elf/nfp.h"
typedef struct
{
  uint32_t w0;
  uint32_t cpp_offset_lo;
  uint32_t val;
  uint32_t mask;
} Elf_Nfp_InitRegEntry;

typedef struct
{
  uint32_t ctx_enables;
  uint32_t entry;
  uint32_t misc_control;
  uint32_t reserved;
} Elf_Nfp_MeConfig;


static const char *elf_nfp3200_reloc_type (unsigned long rtype); static const char * elf_nfp3200_reloc_type (unsigned long rtype) { switch (rtype) {
    case 0: return "R_NFP3200_NOTYPE";
    case 1: return "R_NFP3200_W32LE";
    case 2: return "R_NFP3200_SRC8_A";
    case 3: return "R_NFP3200_SRC8_B";
    case 4: return "R_NFP3200_IMMED8_I";
    case 5: return "R_NFP3200_SC";
    case 6: return "R_NFP3200_IMMED_LO16_I_A";
    case 7: return "R_NFP3200_IMMED_LO16_I_B";
    case 8: return "R_NFP3200_SRC7_B";
    case 9: return "R_NFP3200_SRC7_A";
    case 10: return "R_NFP3200_SRC8_I_B";
    case 11: return "R_NFP3200_SRC8_I_A";
    case 12: return "R_NFP3200_IMMED_HI16_I_A";
    case 13: return "R_NFP3200_IMMED_HI16_I_B";
    case 14: return "R_NFP3200_RSVD_0";
    case 15: return "R_NFP3200_RSVD_1";
    case 16: return "R_NFP3200_RSVD_2";
    case 17: return "R_NFP3200_RSVD_3";
    case 18: return "R_NFP3200_RSVD_4";
    case 19: return "R_NFP3200_RSVD_5";
    case 20: return "R_NFP3200_RSVD_6";
    case 21: return "R_NFP3200_W64LE";
    case 22: return "R_NFP3200_W32BE";
    case 23: return "R_NFP3200_W64BE";
    case 24: return "R_NFP3200_W32LE_AND";
    case 25: return "R_NFP3200_W32BE_AND";
    case 26: return "R_NFP3200_W32LE_OR";
    case 27: return "R_NFP3200_W32BE_OR";
    case 28: return "R_NFP3200_W64LE_AND";
    case 29: return "R_NFP3200_W64BE_AND";
    case 30: return "R_NFP3200_W64LE_OR";
    case 31: return "R_NFP3200_W64BE_OR";
default: return 
# 256 "./../include/elf/nfp.h" 3 4
((void *)0)
# 256 "./../include/elf/nfp.h"
; } }

static const char *elf_nfp_reloc_type (unsigned long rtype); static const char * elf_nfp_reloc_type (unsigned long rtype) { switch (rtype) {
    case 0: return "R_NFP_NOTYPE";
    case 1: return "R_NFP_W32LE";
    case 2: return "R_NFP_SRC8_A";
    case 3: return "R_NFP_SRC8_B";
    case 4: return "R_NFP_IMMED8_I";
    case 5: return "R_NFP_SC";
    case 6: return "R_NFP_IMMED_LO16_I_A";
    case 7: return "R_NFP_IMMED_LO16_I_B";
    case 8: return "R_NFP_SRC7_B";
    case 9: return "R_NFP_SRC7_A";
    case 10: return "R_NFP_SRC8_I_B";
    case 11: return "R_NFP_SRC8_I_A";
    case 12: return "R_NFP_IMMED_HI16_I_A";
    case 13: return "R_NFP_IMMED_HI16_I_B";
    case 14: return "R_NFP_W64LE";
    case 15: return "R_NFP_SH_INFO";
    case 16: return "R_NFP_W32BE";
    case 17: return "R_NFP_W64BE";
    case 18: return "R_NFP_W32_29_24";
    case 19: return "R_NFP_W32LE_AND";
    case 20: return "R_NFP_W32BE_AND";
    case 21: return "R_NFP_W32LE_OR";
    case 22: return "R_NFP_W32BE_OR";
    case 23: return "R_NFP_W64LE_AND";
    case 24: return "R_NFP_W64BE_AND";
    case 25: return "R_NFP_W64LE_OR";
    case 26: return "R_NFP_W64BE_OR";
default: return 
# 286 "./../include/elf/nfp.h" 3 4
((void *)0)
# 286 "./../include/elf/nfp.h"
; } }
# 144 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/nios2.h" 1
# 36 "./../include/elf/nios2.h"
static const char *elf_nios2_reloc_type (unsigned long rtype); static const char * elf_nios2_reloc_type (unsigned long rtype) { switch (rtype) {


  case 0: return "R_NIOS2_NONE";
  case 1: return "R_NIOS2_S16";
  case 2: return "R_NIOS2_U16";
  case 3: return "R_NIOS2_PCREL16";
  case 4: return "R_NIOS2_CALL26";
  case 5: return "R_NIOS2_IMM5";
  case 6: return "R_NIOS2_CACHE_OPX";
  case 7: return "R_NIOS2_IMM6";
  case 8: return "R_NIOS2_IMM8";
  case 9: return "R_NIOS2_HI16";
  case 10: return "R_NIOS2_LO16";
  case 11: return "R_NIOS2_HIADJ16";
  case 12: return "R_NIOS2_BFD_RELOC_32";
  case 13: return "R_NIOS2_BFD_RELOC_16";
  case 14: return "R_NIOS2_BFD_RELOC_8";
  case 15: return "R_NIOS2_GPREL";
  case 16: return "R_NIOS2_GNU_VTINHERIT";
  case 17: return "R_NIOS2_GNU_VTENTRY";
  case 18: return "R_NIOS2_UJMP";
  case 19: return "R_NIOS2_CJMP";
  case 20: return "R_NIOS2_CALLR";
  case 21: return "R_NIOS2_ALIGN";
  case 22: return "R_NIOS2_GOT16";
  case 23: return "R_NIOS2_CALL16";
  case 24: return "R_NIOS2_GOTOFF_LO";
  case 25: return "R_NIOS2_GOTOFF_HA";
  case 26: return "R_NIOS2_PCREL_LO";
  case 27: return "R_NIOS2_PCREL_HA";
  case 28: return "R_NIOS2_TLS_GD16";
  case 29: return "R_NIOS2_TLS_LDM16";
  case 30: return "R_NIOS2_TLS_LDO16";
  case 31: return "R_NIOS2_TLS_IE16";
  case 32: return "R_NIOS2_TLS_LE16";
  case 33: return "R_NIOS2_TLS_DTPMOD";
  case 34: return "R_NIOS2_TLS_DTPREL";
  case 35: return "R_NIOS2_TLS_TPREL";
  case 36: return "R_NIOS2_COPY";
  case 37: return "R_NIOS2_GLOB_DAT";
  case 38: return "R_NIOS2_JUMP_SLOT";
  case 39: return "R_NIOS2_RELATIVE";
  case 40: return "R_NIOS2_GOTOFF";
  case 41: return "R_NIOS2_CALL26_NOAT";
  case 42: return "R_NIOS2_GOT_LO";
  case 43: return "R_NIOS2_GOT_HA";
  case 44: return "R_NIOS2_CALL_LO";
  case 45: return "R_NIOS2_CALL_HA";


  case 64: return "R_NIOS2_R2_S12";
  case 65: return "R_NIOS2_R2_I10_1_PCREL";
  case 66: return "R_NIOS2_R2_T1I7_1_PCREL";
  case 67: return "R_NIOS2_R2_T1I7_2";
  case 68: return "R_NIOS2_R2_T2I4";
  case 69: return "R_NIOS2_R2_T2I4_1";
  case 70: return "R_NIOS2_R2_T2I4_2";
  case 71: return "R_NIOS2_R2_X1I7_2";
  case 72: return "R_NIOS2_R2_X2L5";
  case 73: return "R_NIOS2_R2_F1I5_2";
  case 74: return "R_NIOS2_R2_L5I4X1";
  case 75: return "R_NIOS2_R2_T1X1I6";
  case 76: return "R_NIOS2_R2_T1X1I6_2";


  case 77: return "R_NIOS2_ILLEGAL";
default: return 
# 103 "./../include/elf/nios2.h" 3 4
((void *)0)
# 103 "./../include/elf/nios2.h"
; } }
# 145 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/or1k.h" 1
# 25 "./../include/elf/or1k.h"
static const char *elf_or1k_reloc_type (unsigned long rtype); static const char * elf_or1k_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_OR1K_NONE";
  case 1: return "R_OR1K_32";
  case 2: return "R_OR1K_16";
  case 3: return "R_OR1K_8";
  case 4: return "R_OR1K_LO_16_IN_INSN";
  case 5: return "R_OR1K_HI_16_IN_INSN";
  case 6: return "R_OR1K_INSN_REL_26";
  case 7: return "R_OR1K_GNU_VTENTRY";
  case 8: return "R_OR1K_GNU_VTINHERIT";
  case 9: return "R_OR1K_32_PCREL";
  case 10: return "R_OR1K_16_PCREL";
  case 11: return "R_OR1K_8_PCREL";
  case 12: return "R_OR1K_GOTPC_HI16";
  case 13: return "R_OR1K_GOTPC_LO16";
  case 14: return "R_OR1K_GOT16";
  case 15: return "R_OR1K_PLT26";
  case 16: return "R_OR1K_GOTOFF_HI16";
  case 17: return "R_OR1K_GOTOFF_LO16";
  case 18: return "R_OR1K_COPY";
  case 19: return "R_OR1K_GLOB_DAT";
  case 20: return "R_OR1K_JMP_SLOT";
  case 21: return "R_OR1K_RELATIVE";
  case 22: return "R_OR1K_TLS_GD_HI16";
  case 23: return "R_OR1K_TLS_GD_LO16";
  case 24: return "R_OR1K_TLS_LDM_HI16";
  case 25: return "R_OR1K_TLS_LDM_LO16";
  case 26: return "R_OR1K_TLS_LDO_HI16";
  case 27: return "R_OR1K_TLS_LDO_LO16";
  case 28: return "R_OR1K_TLS_IE_HI16";
  case 29: return "R_OR1K_TLS_IE_LO16";
  case 30: return "R_OR1K_TLS_LE_HI16";
  case 31: return "R_OR1K_TLS_LE_LO16";
  case 32: return "R_OR1K_TLS_TPOFF";
  case 33: return "R_OR1K_TLS_DTPOFF";
  case 34: return "R_OR1K_TLS_DTPMOD";
  case 35: return "R_OR1K_AHI16";
  case 36: return "R_OR1K_GOTOFF_AHI16";
  case 37: return "R_OR1K_TLS_IE_AHI16";
  case 38: return "R_OR1K_TLS_LE_AHI16";
  case 39: return "R_OR1K_SLO16";
  case 40: return "R_OR1K_GOTOFF_SLO16";
  case 41: return "R_OR1K_TLS_LE_SLO16";
  case 42: return "R_OR1K_PCREL_PG21";
  case 43: return "R_OR1K_GOT_PG21";
  case 44: return "R_OR1K_TLS_GD_PG21";
  case 45: return "R_OR1K_TLS_LDM_PG21";
  case 46: return "R_OR1K_TLS_IE_PG21";
  case 47: return "R_OR1K_LO13";
  case 48: return "R_OR1K_GOT_LO13";
  case 49: return "R_OR1K_TLS_GD_LO13";
  case 50: return "R_OR1K_TLS_LDM_LO13";
  case 51: return "R_OR1K_TLS_IE_LO13";
  case 52: return "R_OR1K_SLO13";
  case 53: return "R_OR1K_PLTA26";
  case 54: return "R_OR1K_GOT_AHI16";
default: return 
# 81 "./../include/elf/or1k.h" 3 4
((void *)0)
# 81 "./../include/elf/or1k.h"
; } }
# 146 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/pj.h" 1
# 27 "./../include/elf/pj.h"
static const char *elf_pj_reloc_type (unsigned long rtype); static const char * elf_pj_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_PJ_NONE";
  case 1: return "R_PJ_DATA_DIR32";
  case 2: return "R_PJ_CODE_REL32";
  case 3: return "R_PJ_CODE_REL16";
  case 6: return "R_PJ_CODE_DIR32";
  case 7: return "R_PJ_CODE_DIR16";
  case 13: return "R_PJ_CODE_LO16";
  case 14: return "R_PJ_CODE_HI16";
  case 15: return "R_PJ_GNU_VTINHERIT";
  case 16: return "R_PJ_GNU_VTENTRY";
default: return 
# 38 "./../include/elf/pj.h" 3 4
((void *)0)
# 38 "./../include/elf/pj.h"
; } }
# 147 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/ppc.h" 1
# 35 "./../include/elf/ppc.h"
static const char *elf_ppc_reloc_type (unsigned long rtype); static const char * elf_ppc_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_PPC_NONE";
  case 1: return "R_PPC_ADDR32";
  case 2: return "R_PPC_ADDR24";
  case 3: return "R_PPC_ADDR16";
  case 4: return "R_PPC_ADDR16_LO";
  case 5: return "R_PPC_ADDR16_HI";
  case 6: return "R_PPC_ADDR16_HA";
  case 7: return "R_PPC_ADDR14";
  case 8: return "R_PPC_ADDR14_BRTAKEN";
  case 9: return "R_PPC_ADDR14_BRNTAKEN";
  case 10: return "R_PPC_REL24";
  case 11: return "R_PPC_REL14";
  case 12: return "R_PPC_REL14_BRTAKEN";
  case 13: return "R_PPC_REL14_BRNTAKEN";
  case 14: return "R_PPC_GOT16";
  case 15: return "R_PPC_GOT16_LO";
  case 16: return "R_PPC_GOT16_HI";
  case 17: return "R_PPC_GOT16_HA";
  case 18: return "R_PPC_PLTREL24";
  case 19: return "R_PPC_COPY";
  case 20: return "R_PPC_GLOB_DAT";
  case 21: return "R_PPC_JMP_SLOT";
  case 22: return "R_PPC_RELATIVE";
  case 23: return "R_PPC_LOCAL24PC";
  case 24: return "R_PPC_UADDR32";
  case 25: return "R_PPC_UADDR16";
  case 26: return "R_PPC_REL32";
  case 27: return "R_PPC_PLT32";
  case 28: return "R_PPC_PLTREL32";
  case 29: return "R_PPC_PLT16_LO";
  case 30: return "R_PPC_PLT16_HI";
  case 31: return "R_PPC_PLT16_HA";
  case 32: return "R_PPC_SDAREL16";
  case 33: return "R_PPC_SECTOFF";
  case 34: return "R_PPC_SECTOFF_LO";
  case 35: return "R_PPC_SECTOFF_HI";
  case 36: return "R_PPC_SECTOFF_HA";
  case 37: return "R_PPC_ADDR30";
# 87 "./../include/elf/ppc.h"
  case 67: return "R_PPC_TLS";
  case 68: return "R_PPC_DTPMOD32";
  case 69: return "R_PPC_TPREL16";
  case 70: return "R_PPC_TPREL16_LO";
  case 71: return "R_PPC_TPREL16_HI";
  case 72: return "R_PPC_TPREL16_HA";
  case 73: return "R_PPC_TPREL32";
  case 74: return "R_PPC_DTPREL16";
  case 75: return "R_PPC_DTPREL16_LO";
  case 76: return "R_PPC_DTPREL16_HI";
  case 77: return "R_PPC_DTPREL16_HA";
  case 78: return "R_PPC_DTPREL32";
  case 79: return "R_PPC_GOT_TLSGD16";
  case 80: return "R_PPC_GOT_TLSGD16_LO";
  case 81: return "R_PPC_GOT_TLSGD16_HI";
  case 82: return "R_PPC_GOT_TLSGD16_HA";
  case 83: return "R_PPC_GOT_TLSLD16";
  case 84: return "R_PPC_GOT_TLSLD16_LO";
  case 85: return "R_PPC_GOT_TLSLD16_HI";
  case 86: return "R_PPC_GOT_TLSLD16_HA";
  case 87: return "R_PPC_GOT_TPREL16";
  case 88: return "R_PPC_GOT_TPREL16_LO";
  case 89: return "R_PPC_GOT_TPREL16_HI";
  case 90: return "R_PPC_GOT_TPREL16_HA";
  case 91: return "R_PPC_GOT_DTPREL16";
  case 92: return "R_PPC_GOT_DTPREL16_LO";
  case 93: return "R_PPC_GOT_DTPREL16_HI";
  case 94: return "R_PPC_GOT_DTPREL16_HA";
  case 95: return "R_PPC_TLSGD";
  case 96: return "R_PPC_TLSLD";



  case 101: return "R_PPC_EMB_NADDR32";
  case 102: return "R_PPC_EMB_NADDR16";
  case 103: return "R_PPC_EMB_NADDR16_LO";
  case 104: return "R_PPC_EMB_NADDR16_HI";
  case 105: return "R_PPC_EMB_NADDR16_HA";
  case 106: return "R_PPC_EMB_SDAI16";
  case 107: return "R_PPC_EMB_SDA2I16";
  case 108: return "R_PPC_EMB_SDA2REL";
  case 109: return "R_PPC_EMB_SDA21";
  case 110: return "R_PPC_EMB_MRKREF";
  case 111: return "R_PPC_EMB_RELSEC16";
  case 112: return "R_PPC_EMB_RELST_LO";
  case 113: return "R_PPC_EMB_RELST_HI";
  case 114: return "R_PPC_EMB_RELST_HA";
  case 115: return "R_PPC_EMB_BIT_FLD";
  case 116: return "R_PPC_EMB_RELSDA";


  case 119: return "R_PPC_PLTSEQ";
  case 120: return "R_PPC_PLTCALL";


  case 216: return "R_PPC_VLE_REL8";
  case 217: return "R_PPC_VLE_REL15";
  case 218: return "R_PPC_VLE_REL24";
  case 219: return "R_PPC_VLE_LO16A";
  case 220: return "R_PPC_VLE_LO16D";
  case 221: return "R_PPC_VLE_HI16A";
  case 222: return "R_PPC_VLE_HI16D";
  case 223: return "R_PPC_VLE_HA16A";
  case 224: return "R_PPC_VLE_HA16D";
  case 225: return "R_PPC_VLE_SDA21";
  case 226: return "R_PPC_VLE_SDA21_LO";
  case 227: return "R_PPC_VLE_SDAREL_LO16A";
  case 228: return "R_PPC_VLE_SDAREL_LO16D";
  case 229: return "R_PPC_VLE_SDAREL_HI16A";
  case 230: return "R_PPC_VLE_SDAREL_HI16D";
  case 231: return "R_PPC_VLE_SDAREL_HA16A";
  case 232: return "R_PPC_VLE_SDAREL_HA16D";
  case 233: return "R_PPC_VLE_ADDR20";


  case 246: return "R_PPC_REL16DX_HA";


  case 248: return "R_PPC_IRELATIVE";


  case 249: return "R_PPC_REL16";
  case 250: return "R_PPC_REL16_LO";
  case 251: return "R_PPC_REL16_HI";
  case 252: return "R_PPC_REL16_HA";


  case 253: return "R_PPC_GNU_VTINHERIT";
  case 254: return "R_PPC_GNU_VTENTRY";



  case 255: return "R_PPC_TOC16";

default: return 
# 181 "./../include/elf/ppc.h" 3 4
((void *)0)
# 181 "./../include/elf/ppc.h"
; } }
# 228 "./../include/elf/ppc.h"
enum
{
# 242 "./../include/elf/ppc.h"
  Tag_GNU_Power_ABI_FP = 4,




  Tag_GNU_Power_ABI_Vector = 8,




  Tag_GNU_Power_ABI_Struct_Return = 12
};
# 148 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/ppc64.h" 1
# 27 "./../include/elf/ppc64.h"
static const char *elf_ppc64_reloc_type (unsigned long rtype); static const char * elf_ppc64_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_PPC64_NONE";
  case 1: return "R_PPC64_ADDR32";
  case 2: return "R_PPC64_ADDR24";
  case 3: return "R_PPC64_ADDR16";
  case 4: return "R_PPC64_ADDR16_LO";
  case 5: return "R_PPC64_ADDR16_HI";
  case 6: return "R_PPC64_ADDR16_HA";
  case 7: return "R_PPC64_ADDR14";
  case 8: return "R_PPC64_ADDR14_BRTAKEN";
  case 9: return "R_PPC64_ADDR14_BRNTAKEN";
  case 10: return "R_PPC64_REL24";
  case 11: return "R_PPC64_REL14";
  case 12: return "R_PPC64_REL14_BRTAKEN";
  case 13: return "R_PPC64_REL14_BRNTAKEN";
  case 14: return "R_PPC64_GOT16";
  case 15: return "R_PPC64_GOT16_LO";
  case 16: return "R_PPC64_GOT16_HI";
  case 17: return "R_PPC64_GOT16_HA";

  case 19: return "R_PPC64_COPY";
  case 20: return "R_PPC64_GLOB_DAT";
  case 21: return "R_PPC64_JMP_SLOT";
  case 22: return "R_PPC64_RELATIVE";

  case 24: return "R_PPC64_UADDR32";
  case 25: return "R_PPC64_UADDR16";
  case 26: return "R_PPC64_REL32";
  case 27: return "R_PPC64_PLT32";
  case 28: return "R_PPC64_PLTREL32";
  case 29: return "R_PPC64_PLT16_LO";
  case 30: return "R_PPC64_PLT16_HI";
  case 31: return "R_PPC64_PLT16_HA";

  case 33: return "R_PPC64_SECTOFF";
  case 34: return "R_PPC64_SECTOFF_LO";
  case 35: return "R_PPC64_SECTOFF_HI";
  case 36: return "R_PPC64_SECTOFF_HA";
  case 37: return "R_PPC64_REL30";
  case 38: return "R_PPC64_ADDR64";
  case 39: return "R_PPC64_ADDR16_HIGHER";
  case 40: return "R_PPC64_ADDR16_HIGHERA";
  case 41: return "R_PPC64_ADDR16_HIGHEST";
  case 42: return "R_PPC64_ADDR16_HIGHESTA";
  case 43: return "R_PPC64_UADDR64";
  case 44: return "R_PPC64_REL64";
  case 45: return "R_PPC64_PLT64";
  case 46: return "R_PPC64_PLTREL64";
  case 47: return "R_PPC64_TOC16";
  case 48: return "R_PPC64_TOC16_LO";
  case 49: return "R_PPC64_TOC16_HI";
  case 50: return "R_PPC64_TOC16_HA";
  case 51: return "R_PPC64_TOC";
  case 52: return "R_PPC64_PLTGOT16";
  case 53: return "R_PPC64_PLTGOT16_LO";
  case 54: return "R_PPC64_PLTGOT16_HI";
  case 55: return "R_PPC64_PLTGOT16_HA";



  case 56: return "R_PPC64_ADDR16_DS";
  case 57: return "R_PPC64_ADDR16_LO_DS";
  case 58: return "R_PPC64_GOT16_DS";
  case 59: return "R_PPC64_GOT16_LO_DS";
  case 60: return "R_PPC64_PLT16_LO_DS";
  case 61: return "R_PPC64_SECTOFF_DS";
  case 62: return "R_PPC64_SECTOFF_LO_DS";
  case 63: return "R_PPC64_TOC16_DS";
  case 64: return "R_PPC64_TOC16_LO_DS";
  case 65: return "R_PPC64_PLTGOT16_DS";
  case 66: return "R_PPC64_PLTGOT16_LO_DS";


  case 67: return "R_PPC64_TLS";
  case 68: return "R_PPC64_DTPMOD64";
  case 69: return "R_PPC64_TPREL16";
  case 70: return "R_PPC64_TPREL16_LO";
  case 71: return "R_PPC64_TPREL16_HI";
  case 72: return "R_PPC64_TPREL16_HA";
  case 73: return "R_PPC64_TPREL64";
  case 74: return "R_PPC64_DTPREL16";
  case 75: return "R_PPC64_DTPREL16_LO";
  case 76: return "R_PPC64_DTPREL16_HI";
  case 77: return "R_PPC64_DTPREL16_HA";
  case 78: return "R_PPC64_DTPREL64";
  case 79: return "R_PPC64_GOT_TLSGD16";
  case 80: return "R_PPC64_GOT_TLSGD16_LO";
  case 81: return "R_PPC64_GOT_TLSGD16_HI";
  case 82: return "R_PPC64_GOT_TLSGD16_HA";
  case 83: return "R_PPC64_GOT_TLSLD16";
  case 84: return "R_PPC64_GOT_TLSLD16_LO";
  case 85: return "R_PPC64_GOT_TLSLD16_HI";
  case 86: return "R_PPC64_GOT_TLSLD16_HA";
  case 87: return "R_PPC64_GOT_TPREL16_DS";
  case 88: return "R_PPC64_GOT_TPREL16_LO_DS";
  case 89: return "R_PPC64_GOT_TPREL16_HI";
  case 90: return "R_PPC64_GOT_TPREL16_HA";
  case 91: return "R_PPC64_GOT_DTPREL16_DS";
  case 92: return "R_PPC64_GOT_DTPREL16_LO_DS";
  case 93: return "R_PPC64_GOT_DTPREL16_HI";
  case 94: return "R_PPC64_GOT_DTPREL16_HA";
  case 95: return "R_PPC64_TPREL16_DS";
  case 96: return "R_PPC64_TPREL16_LO_DS";
  case 97: return "R_PPC64_TPREL16_HIGHER";
  case 98: return "R_PPC64_TPREL16_HIGHERA";
  case 99: return "R_PPC64_TPREL16_HIGHEST";
  case 100: return "R_PPC64_TPREL16_HIGHESTA";
  case 101: return "R_PPC64_DTPREL16_DS";
  case 102: return "R_PPC64_DTPREL16_LO_DS";
  case 103: return "R_PPC64_DTPREL16_HIGHER";
  case 104: return "R_PPC64_DTPREL16_HIGHERA";
  case 105: return "R_PPC64_DTPREL16_HIGHEST";
  case 106: return "R_PPC64_DTPREL16_HIGHESTA";
  case 107: return "R_PPC64_TLSGD";
  case 108: return "R_PPC64_TLSLD";
  case 109: return "R_PPC64_TOCSAVE";


  case 110: return "R_PPC64_ADDR16_HIGH";
  case 111: return "R_PPC64_ADDR16_HIGHA";
  case 112: return "R_PPC64_TPREL16_HIGH";
  case 113: return "R_PPC64_TPREL16_HIGHA";
  case 114: return "R_PPC64_DTPREL16_HIGH";
  case 115: return "R_PPC64_DTPREL16_HIGHA";


  case 116: return "R_PPC64_REL24_NOTOC";
  case 117: return "R_PPC64_ADDR64_LOCAL";
  case 118: return "R_PPC64_ENTRY";


  case 119: return "R_PPC64_PLTSEQ";
  case 120: return "R_PPC64_PLTCALL";


  case 121: return "R_PPC64_PLTSEQ_NOTOC";
  case 122: return "R_PPC64_PLTCALL_NOTOC";
  case 123: return "R_PPC64_PCREL_OPT";
  case 124: return "R_PPC64_REL24_P9NOTOC";

  case 128: return "R_PPC64_D34";
  case 129: return "R_PPC64_D34_LO";
  case 130: return "R_PPC64_D34_HI30";
  case 131: return "R_PPC64_D34_HA30";
  case 132: return "R_PPC64_PCREL34";
  case 133: return "R_PPC64_GOT_PCREL34";
  case 134: return "R_PPC64_PLT_PCREL34";
  case 135: return "R_PPC64_PLT_PCREL34_NOTOC";
  case 136: return "R_PPC64_ADDR16_HIGHER34";
  case 137: return "R_PPC64_ADDR16_HIGHERA34";
  case 138: return "R_PPC64_ADDR16_HIGHEST34";
  case 139: return "R_PPC64_ADDR16_HIGHESTA34";
  case 140: return "R_PPC64_REL16_HIGHER34";
  case 141: return "R_PPC64_REL16_HIGHERA34";
  case 142: return "R_PPC64_REL16_HIGHEST34";
  case 143: return "R_PPC64_REL16_HIGHESTA34";
  case 144: return "R_PPC64_D28";
  case 145: return "R_PPC64_PCREL28";
  case 146: return "R_PPC64_TPREL34";
  case 147: return "R_PPC64_DTPREL34";
  case 148: return "R_PPC64_GOT_TLSGD_PCREL34";
  case 149: return "R_PPC64_GOT_TLSLD_PCREL34";
  case 150: return "R_PPC64_GOT_TPREL_PCREL34";
  case 151: return "R_PPC64_GOT_DTPREL_PCREL34";
# 200 "./../include/elf/ppc64.h"
  case 240: return "R_PPC64_REL16_HIGH";
  case 241: return "R_PPC64_REL16_HIGHA";
  case 242: return "R_PPC64_REL16_HIGHER";
  case 243: return "R_PPC64_REL16_HIGHERA";
  case 244: return "R_PPC64_REL16_HIGHEST";
  case 245: return "R_PPC64_REL16_HIGHESTA";


  case 246: return "R_PPC64_REL16DX_HA";


  case 247: return "R_PPC64_JMP_IREL";
  case 248: return "R_PPC64_IRELATIVE";


  case 249: return "R_PPC64_REL16";
  case 250: return "R_PPC64_REL16_LO";
  case 251: return "R_PPC64_REL16_HI";
  case 252: return "R_PPC64_REL16_HA";


  case 253: return "R_PPC64_GNU_VTINHERIT";
  case 254: return "R_PPC64_GNU_VTENTRY";

default: return 
# 224 "./../include/elf/ppc64.h" 3 4
((void *)0)
# 224 "./../include/elf/ppc64.h"
; } }
# 261 "./../include/elf/ppc64.h"
static inline unsigned int
ppc64_decode_local_entry(unsigned int other)
{
  return ((1 << other) >> 2) << 2;
}


static inline unsigned int
ppc64_encode_local_entry(unsigned int val)
{
  return (val >= 4 * 4
   ? (val >= 8 * 4
      ? (val >= 16 * 4 ? 6 : 5)
      : 4)
   : (val >= 2 * 4
      ? 3
      : (val >= 1 * 4 ? 2 : 0)));
}
# 149 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/pru.h" 1
# 31 "./../include/elf/pru.h"
static const char *elf_pru_reloc_type (unsigned long rtype); static const char * elf_pru_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_PRU_NONE";
  case 5: return "R_PRU_16_PMEM";
  case 6: return "R_PRU_U16_PMEMIMM";
  case 8: return "R_PRU_BFD_RELOC_16";
  case 9: return "R_PRU_U16";
  case 10: return "R_PRU_32_PMEM";
  case 11: return "R_PRU_BFD_RELOC_32";
  case 14: return "R_PRU_S10_PCREL";
  case 15: return "R_PRU_U8_PCREL";
  case 18: return "R_PRU_LDI32";


  case 64: return "R_PRU_GNU_BFD_RELOC_8";
  case 65: return "R_PRU_GNU_DIFF8";
  case 66: return "R_PRU_GNU_DIFF16";
  case 67: return "R_PRU_GNU_DIFF32";
  case 68: return "R_PRU_GNU_DIFF16_PMEM";
  case 69: return "R_PRU_GNU_DIFF32_PMEM";
  case 70: return "R_PRU_ILLEGAL";
default: return 
# 51 "./../include/elf/pru.h" 3 4
((void *)0)
# 51 "./../include/elf/pru.h"
; } }
# 150 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/riscv.h" 1
# 30 "./../include/elf/riscv.h"
# 1 "./../include/libiberty.h" 1
# 31 "./../include/elf/riscv.h" 2


static const char *elf_riscv_reloc_type (unsigned long rtype); static const char * elf_riscv_reloc_type (unsigned long rtype) { switch (rtype) {

  case 0: return "R_RISCV_NONE";
  case 1: return "R_RISCV_32";
  case 2: return "R_RISCV_64";
  case 3: return "R_RISCV_RELATIVE";
  case 4: return "R_RISCV_COPY";
  case 5: return "R_RISCV_JUMP_SLOT";
  case 6: return "R_RISCV_TLS_DTPMOD32";
  case 7: return "R_RISCV_TLS_DTPMOD64";
  case 8: return "R_RISCV_TLS_DTPREL32";
  case 9: return "R_RISCV_TLS_DTPREL64";
  case 10: return "R_RISCV_TLS_TPREL32";
  case 11: return "R_RISCV_TLS_TPREL64";


  case 16: return "R_RISCV_BRANCH";
  case 17: return "R_RISCV_JAL";
  case 18: return "R_RISCV_CALL";
  case 19: return "R_RISCV_CALL_PLT";
  case 20: return "R_RISCV_GOT_HI20";
  case 21: return "R_RISCV_TLS_GOT_HI20";
  case 22: return "R_RISCV_TLS_GD_HI20";
  case 23: return "R_RISCV_PCREL_HI20";
  case 24: return "R_RISCV_PCREL_LO12_I";
  case 25: return "R_RISCV_PCREL_LO12_S";
  case 26: return "R_RISCV_HI20";
  case 27: return "R_RISCV_LO12_I";
  case 28: return "R_RISCV_LO12_S";
  case 29: return "R_RISCV_TPREL_HI20";
  case 30: return "R_RISCV_TPREL_LO12_I";
  case 31: return "R_RISCV_TPREL_LO12_S";
  case 32: return "R_RISCV_TPREL_ADD";
  case 33: return "R_RISCV_ADD8";
  case 34: return "R_RISCV_ADD16";
  case 35: return "R_RISCV_ADD32";
  case 36: return "R_RISCV_ADD64";
  case 37: return "R_RISCV_SUB8";
  case 38: return "R_RISCV_SUB16";
  case 39: return "R_RISCV_SUB32";
  case 40: return "R_RISCV_SUB64";
  case 43: return "R_RISCV_ALIGN";
  case 44: return "R_RISCV_RVC_BRANCH";
  case 45: return "R_RISCV_RVC_JUMP";
  case 46: return "R_RISCV_RVC_LUI";
  case 47: return "R_RISCV_GPREL_I";
  case 48: return "R_RISCV_GPREL_S";
  case 49: return "R_RISCV_TPREL_I";
  case 50: return "R_RISCV_TPREL_S";
  case 51: return "R_RISCV_RELAX";
  case 52: return "R_RISCV_SUB6";
  case 53: return "R_RISCV_SET6";
  case 54: return "R_RISCV_SET8";
  case 55: return "R_RISCV_SET16";
  case 56: return "R_RISCV_SET32";
  case 57: return "R_RISCV_32_PCREL";
  case 58: return "R_RISCV_IRELATIVE";

  case 60: return "R_RISCV_SET_ULEB128";
  case 61: return "R_RISCV_SUB_ULEB128";
default: return 
# 93 "./../include/elf/riscv.h" 3 4
((void *)0)
# 93 "./../include/elf/riscv.h"
; } }
# 139 "./../include/elf/riscv.h"
enum
{

  Tag_RISCV_stack_align = 4,
  Tag_RISCV_arch = 5,
  Tag_RISCV_unaligned_access = 6,
  Tag_RISCV_priv_spec = 8,
  Tag_RISCV_priv_spec_minor = 10,
  Tag_RISCV_priv_spec_revision = 12
};
# 151 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/rl78.h" 1
# 31 "./../include/elf/rl78.h"
static const char *elf_rl78_reloc_type (unsigned long rtype); static const char * elf_rl78_reloc_type (unsigned long rtype) { switch (rtype) {

  case 0x00: return "R_RL78_NONE";

  case 0x01: return "R_RL78_DIR32";
  case 0x02: return "R_RL78_DIR24S";
  case 0x03: return "R_RL78_DIR16";
  case 0x04: return "R_RL78_DIR16U";
  case 0x05: return "R_RL78_DIR16S";
  case 0x06: return "R_RL78_DIR8";
  case 0x07: return "R_RL78_DIR8U";
  case 0x08: return "R_RL78_DIR8S";


  case 0x09: return "R_RL78_DIR24S_PCREL";
  case 0x0a: return "R_RL78_DIR16S_PCREL";
  case 0x0b: return "R_RL78_DIR8S_PCREL";


  case 0x0c: return "R_RL78_DIR16UL";
  case 0x0d: return "R_RL78_DIR16UW";
  case 0x0e: return "R_RL78_DIR8UL";
  case 0x0f: return "R_RL78_DIR8UW";
  case 0x10: return "R_RL78_DIR32_REV";
  case 0x11: return "R_RL78_DIR16_REV";
  case 0x12: return "R_RL78_DIR3U_PCREL";


  case 0x2d: return "R_RL78_RH_RELAX";
  case 0x2e: return "R_RL78_RH_SFR";
  case 0x2f: return "R_RL78_RH_SADDR";


  case 0x41: return "R_RL78_ABS32";
  case 0x42: return "R_RL78_ABS24S";
  case 0x43: return "R_RL78_ABS16";
  case 0x44: return "R_RL78_ABS16U";
  case 0x45: return "R_RL78_ABS16S";
  case 0x46: return "R_RL78_ABS8";
  case 0x47: return "R_RL78_ABS8U";
  case 0x48: return "R_RL78_ABS8S";
  case 0x49: return "R_RL78_ABS24S_PCREL";
  case 0x4a: return "R_RL78_ABS16S_PCREL";
  case 0x4b: return "R_RL78_ABS8S_PCREL";
  case 0x4c: return "R_RL78_ABS16UL";
  case 0x4d: return "R_RL78_ABS16UW";
  case 0x4e: return "R_RL78_ABS8UL";
  case 0x4f: return "R_RL78_ABS8UW";
  case 0x50: return "R_RL78_ABS32_REV";
  case 0x51: return "R_RL78_ABS16_REV";

  case 0x80: return "R_RL78_SYM";
  case 0x81: return "R_RL78_OPneg";
  case 0x82: return "R_RL78_OPadd";
  case 0x83: return "R_RL78_OPsub";
  case 0x84: return "R_RL78_OPmul";
  case 0x85: return "R_RL78_OPdiv";
  case 0x86: return "R_RL78_OPshla";
  case 0x87: return "R_RL78_OPshra";
  case 0x88: return "R_RL78_OPsctsize";
  case 0x8d: return "R_RL78_OPscttop";
  case 0x90: return "R_RL78_OPand";
  case 0x91: return "R_RL78_OPor";
  case 0x92: return "R_RL78_OPxor";
  case 0x93: return "R_RL78_OPnot";
  case 0x94: return "R_RL78_OPmod";
  case 0x95: return "R_RL78_OPromtop";
  case 0x96: return "R_RL78_OPramtop";

default: return 
# 100 "./../include/elf/rl78.h" 3 4
((void *)0)
# 100 "./../include/elf/rl78.h"
; } }
# 152 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/rx.h" 1
# 31 "./../include/elf/rx.h"
static const char *elf_rx_reloc_type (unsigned long rtype); static const char * elf_rx_reloc_type (unsigned long rtype) { switch (rtype) {

  case 0x00: return "R_RX_NONE";

  case 0x01: return "R_RX_DIR32";
  case 0x02: return "R_RX_DIR24S";
  case 0x03: return "R_RX_DIR16";
  case 0x04: return "R_RX_DIR16U";
  case 0x05: return "R_RX_DIR16S";
  case 0x06: return "R_RX_DIR8";
  case 0x07: return "R_RX_DIR8U";
  case 0x08: return "R_RX_DIR8S";


  case 0x09: return "R_RX_DIR24S_PCREL";
  case 0x0a: return "R_RX_DIR16S_PCREL";
  case 0x0b: return "R_RX_DIR8S_PCREL";


  case 0x0c: return "R_RX_DIR16UL";
  case 0x0d: return "R_RX_DIR16UW";
  case 0x0e: return "R_RX_DIR8UL";
  case 0x0f: return "R_RX_DIR8UW";
  case 0x10: return "R_RX_DIR32_REV";
  case 0x11: return "R_RX_DIR16_REV";
  case 0x12: return "R_RX_DIR3U_PCREL";


  case 0x20: return "R_RX_RH_3_PCREL";
  case 0x21: return "R_RX_RH_16_OP";
  case 0x22: return "R_RX_RH_24_OP";
  case 0x23: return "R_RX_RH_32_OP";
  case 0x24: return "R_RX_RH_24_UNS";
  case 0x25: return "R_RX_RH_8_NEG";
  case 0x26: return "R_RX_RH_16_NEG";
  case 0x27: return "R_RX_RH_24_NEG";
  case 0x28: return "R_RX_RH_32_NEG";
  case 0x29: return "R_RX_RH_DIFF";
  case 0x2a: return "R_RX_RH_GPRELB";
  case 0x2b: return "R_RX_RH_GPRELW";
  case 0x2c: return "R_RX_RH_GPRELL";
  case 0x2d: return "R_RX_RH_RELAX";


  case 0x41: return "R_RX_ABS32";
  case 0x42: return "R_RX_ABS24S";
  case 0x43: return "R_RX_ABS16";
  case 0x44: return "R_RX_ABS16U";
  case 0x45: return "R_RX_ABS16S";
  case 0x46: return "R_RX_ABS8";
  case 0x47: return "R_RX_ABS8U";
  case 0x48: return "R_RX_ABS8S";
  case 0x49: return "R_RX_ABS24S_PCREL";
  case 0x4a: return "R_RX_ABS16S_PCREL";
  case 0x4b: return "R_RX_ABS8S_PCREL";
  case 0x4c: return "R_RX_ABS16UL";
  case 0x4d: return "R_RX_ABS16UW";
  case 0x4e: return "R_RX_ABS8UL";
  case 0x4f: return "R_RX_ABS8UW";
  case 0x50: return "R_RX_ABS32_REV";
  case 0x51: return "R_RX_ABS16_REV";

  case 0x80: return "R_RX_SYM";
  case 0x81: return "R_RX_OPneg";
  case 0x82: return "R_RX_OPadd";
  case 0x83: return "R_RX_OPsub";
  case 0x84: return "R_RX_OPmul";
  case 0x85: return "R_RX_OPdiv";
  case 0x86: return "R_RX_OPshla";
  case 0x87: return "R_RX_OPshra";
  case 0x88: return "R_RX_OPsctsize";
  case 0x8d: return "R_RX_OPscttop";
  case 0x90: return "R_RX_OPand";
  case 0x91: return "R_RX_OPor";
  case 0x92: return "R_RX_OPxor";
  case 0x93: return "R_RX_OPnot";
  case 0x94: return "R_RX_OPmod";
  case 0x95: return "R_RX_OPromtop";
  case 0x96: return "R_RX_OPramtop";

default: return 
# 111 "./../include/elf/rx.h" 3 4
((void *)0)
# 111 "./../include/elf/rx.h"
; } }
# 153 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/s390.h" 1
# 45 "./../include/elf/s390.h"
static const char *elf_s390_reloc_type (unsigned long rtype); static const char * elf_s390_reloc_type (unsigned long rtype) { switch (rtype) {
    case 0: return "R_390_NONE";
    case 1: return "R_390_8";
    case 2: return "R_390_12";
    case 3: return "R_390_16";
    case 4: return "R_390_32";
    case 5: return "R_390_PC32";
    case 6: return "R_390_GOT12";
    case 7: return "R_390_GOT32";
    case 8: return "R_390_PLT32";
    case 9: return "R_390_COPY";
    case 10: return "R_390_GLOB_DAT";
    case 11: return "R_390_JMP_SLOT";
    case 12: return "R_390_RELATIVE";
    case 13: return "R_390_GOTOFF32";
    case 14: return "R_390_GOTPC";
    case 15: return "R_390_GOT16";
    case 16: return "R_390_PC16";
    case 62: return "R_390_PC12DBL";
    case 63: return "R_390_PLT12DBL";
    case 17: return "R_390_PC16DBL";
    case 18: return "R_390_PLT16DBL";
    case 64: return "R_390_PC24DBL";
    case 65: return "R_390_PLT24DBL";
    case 19: return "R_390_PC32DBL";
    case 20: return "R_390_PLT32DBL";
    case 21: return "R_390_GOTPCDBL";
    case 22: return "R_390_64";
    case 23: return "R_390_PC64";
    case 24: return "R_390_GOT64";
    case 25: return "R_390_PLT64";
    case 26: return "R_390_GOTENT";
    case 27: return "R_390_GOTOFF16";
    case 28: return "R_390_GOTOFF64";
    case 29: return "R_390_GOTPLT12";
    case 30: return "R_390_GOTPLT16";
    case 31: return "R_390_GOTPLT32";
    case 32: return "R_390_GOTPLT64";
    case 33: return "R_390_GOTPLTENT";
    case 34: return "R_390_PLTOFF16";
    case 35: return "R_390_PLTOFF32";
    case 36: return "R_390_PLTOFF64";
    case 37: return "R_390_TLS_LOAD";
    case 38: return "R_390_TLS_GDCALL";

    case 39: return "R_390_TLS_LDCALL";

    case 40: return "R_390_TLS_GD32";

    case 41: return "R_390_TLS_GD64";

    case 42: return "R_390_TLS_GOTIE12";

    case 43: return "R_390_TLS_GOTIE32";

    case 44: return "R_390_TLS_GOTIE64";

    case 45: return "R_390_TLS_LDM32";

    case 46: return "R_390_TLS_LDM64";

    case 47: return "R_390_TLS_IE32";

    case 48: return "R_390_TLS_IE64";

    case 49: return "R_390_TLS_IEENT";

    case 50: return "R_390_TLS_LE32";

    case 51: return "R_390_TLS_LE64";

    case 52: return "R_390_TLS_LDO32";

    case 53: return "R_390_TLS_LDO64";

    case 54: return "R_390_TLS_DTPMOD";
    case 55: return "R_390_TLS_DTPOFF";
    case 56: return "R_390_TLS_TPOFF";

    case 57: return "R_390_20";
    case 58: return "R_390_GOT20";
    case 59: return "R_390_GOTPLT20";
    case 60: return "R_390_TLS_GOTIE20";

    case 61: return "R_390_IRELATIVE";

    case 250: return "R_390_GNU_VTINHERIT";
    case 251: return "R_390_GNU_VTENTRY";
default: return 
# 133 "./../include/elf/s390.h" 3 4
((void *)0)
# 133 "./../include/elf/s390.h"
; } }


enum
{







  Tag_GNU_S390_ABI_Vector = 8,
};
# 154 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/score.h" 1
# 106 "./../include/elf/score.h"
static const char *elf_score_reloc_type (unsigned long rtype); static const char * elf_score_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_SCORE_NONE";
  case 1: return "R_SCORE_HI16";
  case 2: return "R_SCORE_LO16";
  case 3: return "R_SCORE_BCMP";
  case 4: return "R_SCORE_24";
  case 5: return "R_SCORE_PC19";
  case 6: return "R_SCORE16_11";
  case 7: return "R_SCORE16_PC8";
  case 8: return "R_SCORE_ABS32";
  case 9: return "R_SCORE_ABS16";
  case 10: return "R_SCORE_DUMMY2";
  case 11: return "R_SCORE_GP15";
  case 12: return "R_SCORE_GNU_VTINHERIT";
  case 13: return "R_SCORE_GNU_VTENTRY";
  case 14: return "R_SCORE_GOT15";
  case 15: return "R_SCORE_GOT_LO16";
  case 16: return "R_SCORE_CALL15";
  case 17: return "R_SCORE_GPREL32";
  case 18: return "R_SCORE_REL32";
  case 19: return "R_SCORE_DUMMY_HI16";
  case 20: return "R_SCORE_IMM30";
  case 21: return "R_SCORE_IMM32";
default: return 
# 129 "./../include/elf/score.h" 3 4
((void *)0)
# 129 "./../include/elf/score.h"
; } }
# 155 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/sh.h" 1
# 87 "./../include/elf/sh.h"
int sh_find_elf_flags (unsigned int arch_set);


int sh_elf_get_flags_from_mach (unsigned long mach);
# 103 "./../include/elf/sh.h"
static const char *elf_sh_reloc_type (unsigned long rtype); static const char * elf_sh_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_SH_NONE";
  case 1: return "R_SH_DIR32";
  case 2: return "R_SH_REL32";
  case 3: return "R_SH_DIR8WPN";
  case 4: return "R_SH_IND12W";
  case 5: return "R_SH_DIR8WPL";
  case 6: return "R_SH_DIR8WPZ";
  case 7: return "R_SH_DIR8BP";
  case 8: return "R_SH_DIR8W";
  case 9: return "R_SH_DIR8L";

  case 10: return "R_SH_LOOP_START";
  case 11: return "R_SH_LOOP_END";

 
 

  case 22: return "R_SH_GNU_VTINHERIT";
  case 23: return "R_SH_GNU_VTENTRY";
  case 24: return "R_SH_SWITCH8";
  case 25: return "R_SH_SWITCH16";
  case 26: return "R_SH_SWITCH32";
  case 27: return "R_SH_USES";
  case 28: return "R_SH_COUNT";
  case 29: return "R_SH_ALIGN";
  case 30: return "R_SH_CODE";
  case 31: return "R_SH_DATA";
  case 32: return "R_SH_LABEL";

  case 33: return "R_SH_DIR16";
  case 34: return "R_SH_DIR8";
  case 35: return "R_SH_DIR8UL";
  case 36: return "R_SH_DIR8UW";
  case 37: return "R_SH_DIR8U";
  case 38: return "R_SH_DIR8SW";
  case 39: return "R_SH_DIR8S";
  case 40: return "R_SH_DIR4UL";
  case 41: return "R_SH_DIR4UW";
  case 42: return "R_SH_DIR4U";
  case 43: return "R_SH_PSHA";
  case 44: return "R_SH_PSHL";
  case 45: return "R_SH_DIR5U";
  case 46: return "R_SH_DIR6U";
  case 47: return "R_SH_DIR6S";
  case 48: return "R_SH_DIR10S";
  case 49: return "R_SH_DIR10SW";
  case 50: return "R_SH_DIR10SL";
  case 51: return "R_SH_DIR10SQ";
 
 
  case 53: return "R_SH_DIR16S";
 
 
  case 144: return "R_SH_TLS_GD_32";
  case 145: return "R_SH_TLS_LD_32";
  case 146: return "R_SH_TLS_LDO_32";
  case 147: return "R_SH_TLS_IE_32";
  case 148: return "R_SH_TLS_LE_32";
  case 149: return "R_SH_TLS_DTPMOD32";
  case 150: return "R_SH_TLS_DTPOFF32";
  case 151: return "R_SH_TLS_TPOFF32";
 
 
  case 160: return "R_SH_GOT32";
  case 161: return "R_SH_PLT32";
  case 162: return "R_SH_COPY";
  case 163: return "R_SH_GLOB_DAT";
  case 164: return "R_SH_JMP_SLOT";
  case 165: return "R_SH_RELATIVE";
  case 166: return "R_SH_GOTOFF";
  case 167: return "R_SH_GOTPC";
  case 168: return "R_SH_GOTPLT32";
  case 169: return "R_SH_GOT_LOW16";
  case 170: return "R_SH_GOT_MEDLOW16";
  case 171: return "R_SH_GOT_MEDHI16";
  case 172: return "R_SH_GOT_HI16";
  case 173: return "R_SH_GOTPLT_LOW16";
  case 174: return "R_SH_GOTPLT_MEDLOW16";
  case 175: return "R_SH_GOTPLT_MEDHI16";
  case 176: return "R_SH_GOTPLT_HI16";
  case 177: return "R_SH_PLT_LOW16";
  case 178: return "R_SH_PLT_MEDLOW16";
  case 179: return "R_SH_PLT_MEDHI16";
  case 180: return "R_SH_PLT_HI16";
  case 181: return "R_SH_GOTOFF_LOW16";
  case 182: return "R_SH_GOTOFF_MEDLOW16";
  case 183: return "R_SH_GOTOFF_MEDHI16";
  case 184: return "R_SH_GOTOFF_HI16";
  case 185: return "R_SH_GOTPC_LOW16";
  case 186: return "R_SH_GOTPC_MEDLOW16";
  case 187: return "R_SH_GOTPC_MEDHI16";
  case 188: return "R_SH_GOTPC_HI16";
  case 189: return "R_SH_GOT10BY4";
  case 190: return "R_SH_GOTPLT10BY4";
  case 191: return "R_SH_GOT10BY8";
  case 192: return "R_SH_GOTPLT10BY8";
  case 193: return "R_SH_COPY64";
  case 194: return "R_SH_GLOB_DAT64";
  case 195: return "R_SH_JMP_SLOT64";
  case 196: return "R_SH_RELATIVE64";
 
 
  case 201: return "R_SH_GOT20";
  case 202: return "R_SH_GOTOFF20";
  case 203: return "R_SH_GOTFUNCDESC";
  case 204: return "R_SH_GOTFUNCDESC20";
  case 205: return "R_SH_GOTOFFFUNCDESC";
  case 206: return "R_SH_GOTOFFFUNCDESC20";
  case 207: return "R_SH_FUNCDESC";
  case 208: return "R_SH_FUNCDESC_VALUE";
 
 
  case 242: return "R_SH_SHMEDIA_CODE";
  case 243: return "R_SH_PT_16";
  case 244: return "R_SH_IMMS16";
  case 245: return "R_SH_IMMU16";
  case 246: return "R_SH_IMM_LOW16";
  case 247: return "R_SH_IMM_LOW16_PCREL";
  case 248: return "R_SH_IMM_MEDLOW16";
  case 249: return "R_SH_IMM_MEDLOW16_PCREL";
  case 250: return "R_SH_IMM_MEDHI16";
  case 251: return "R_SH_IMM_MEDHI16_PCREL";
  case 252: return "R_SH_IMM_HI16";
  case 253: return "R_SH_IMM_HI16_PCREL";
  case 254: return "R_SH_64";
  case 255: return "R_SH_64_PCREL";
default: return 
# 230 "./../include/elf/sh.h" 3 4
((void *)0)
# 230 "./../include/elf/sh.h"
; } }
# 156 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/sparc.h" 1
# 62 "./../include/elf/sparc.h"
static const char *elf_sparc_reloc_type (unsigned long rtype); static const char * elf_sparc_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_SPARC_NONE";
  case 1: return "R_SPARC_8";
  case 2: return "R_SPARC_16";
  case 3: return "R_SPARC_32";
  case 4: return "R_SPARC_DISP8";
  case 5: return "R_SPARC_DISP16";
  case 6: return "R_SPARC_DISP32";
  case 7: return "R_SPARC_WDISP30";
  case 8: return "R_SPARC_WDISP22";
  case 9: return "R_SPARC_HI22";
  case 10: return "R_SPARC_22";
  case 11: return "R_SPARC_13";
  case 12: return "R_SPARC_LO10";
  case 13: return "R_SPARC_GOT10";
  case 14: return "R_SPARC_GOT13";
  case 15: return "R_SPARC_GOT22";
  case 16: return "R_SPARC_PC10";
  case 17: return "R_SPARC_PC22";
  case 18: return "R_SPARC_WPLT30";
  case 19: return "R_SPARC_COPY";
  case 20: return "R_SPARC_GLOB_DAT";
  case 21: return "R_SPARC_JMP_SLOT";
  case 22: return "R_SPARC_RELATIVE";
  case 23: return "R_SPARC_UA32";






  case 24: return "R_SPARC_PLT32";
  case 25: return "R_SPARC_HIPLT22";
  case 26: return "R_SPARC_LOPLT10";
  case 27: return "R_SPARC_PCPLT32";
  case 28: return "R_SPARC_PCPLT22";
  case 29: return "R_SPARC_PCPLT10";



  case 30: return "R_SPARC_10";
  case 31: return "R_SPARC_11";
  case 32: return "R_SPARC_64";
  case 33: return "R_SPARC_OLO10";
  case 34: return "R_SPARC_HH22";
  case 35: return "R_SPARC_HM10";
  case 36: return "R_SPARC_LM22";
  case 37: return "R_SPARC_PC_HH22";
  case 38: return "R_SPARC_PC_HM10";
  case 39: return "R_SPARC_PC_LM22";
  case 40: return "R_SPARC_WDISP16";
  case 41: return "R_SPARC_WDISP19";
  case 42: return "R_SPARC_UNUSED_42";
  case 43: return "R_SPARC_7";
  case 44: return "R_SPARC_5";
  case 45: return "R_SPARC_6";
  case 46: return "R_SPARC_DISP64";
  case 47: return "R_SPARC_PLT64";
  case 48: return "R_SPARC_HIX22";
  case 49: return "R_SPARC_LOX10";
  case 50: return "R_SPARC_H44";
  case 51: return "R_SPARC_M44";
  case 52: return "R_SPARC_L44";
  case 53: return "R_SPARC_REGISTER";
  case 54: return "R_SPARC_UA64";
  case 55: return "R_SPARC_UA16";

  case 56: return "R_SPARC_TLS_GD_HI22";
  case 57: return "R_SPARC_TLS_GD_LO10";
  case 58: return "R_SPARC_TLS_GD_ADD";
  case 59: return "R_SPARC_TLS_GD_CALL";
  case 60: return "R_SPARC_TLS_LDM_HI22";
  case 61: return "R_SPARC_TLS_LDM_LO10";
  case 62: return "R_SPARC_TLS_LDM_ADD";
  case 63: return "R_SPARC_TLS_LDM_CALL";
  case 64: return "R_SPARC_TLS_LDO_HIX22";
  case 65: return "R_SPARC_TLS_LDO_LOX10";
  case 66: return "R_SPARC_TLS_LDO_ADD";
  case 67: return "R_SPARC_TLS_IE_HI22";
  case 68: return "R_SPARC_TLS_IE_LO10";
  case 69: return "R_SPARC_TLS_IE_LD";
  case 70: return "R_SPARC_TLS_IE_LDX";
  case 71: return "R_SPARC_TLS_IE_ADD";
  case 72: return "R_SPARC_TLS_LE_HIX22";
  case 73: return "R_SPARC_TLS_LE_LOX10";
  case 74: return "R_SPARC_TLS_DTPMOD32";
  case 75: return "R_SPARC_TLS_DTPMOD64";
  case 76: return "R_SPARC_TLS_DTPOFF32";
  case 77: return "R_SPARC_TLS_DTPOFF64";
  case 78: return "R_SPARC_TLS_TPOFF32";
  case 79: return "R_SPARC_TLS_TPOFF64";

  case 80: return "R_SPARC_GOTDATA_HIX22";
  case 81: return "R_SPARC_GOTDATA_LOX10";
  case 82: return "R_SPARC_GOTDATA_OP_HIX22";
  case 83: return "R_SPARC_GOTDATA_OP_LOX10";
  case 84: return "R_SPARC_GOTDATA_OP";

  case 85: return "R_SPARC_H34";
  case 86: return "R_SPARC_SIZE32";
  case 87: return "R_SPARC_SIZE64";
  case 88: return "R_SPARC_WDISP10";

 

  case 248: return "R_SPARC_JMP_IREL";
  case 249: return "R_SPARC_IRELATIVE";
  case 250: return "R_SPARC_GNU_VTINHERIT";
  case 251: return "R_SPARC_GNU_VTENTRY";
  case 252: return "R_SPARC_REV32";

default: return 
# 173 "./../include/elf/sparc.h" 3 4
((void *)0)
# 173 "./../include/elf/sparc.h"
; } }
# 189 "./../include/elf/sparc.h"
enum
{

  Tag_GNU_Sparc_HWCAPS = 4,
  Tag_GNU_Sparc_HWCAPS2 = 8
};
# 157 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/spu.h" 1
# 27 "./../include/elf/spu.h"
static const char *elf_spu_reloc_type (unsigned long rtype); static const char * elf_spu_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_SPU_NONE";
     case 1: return "R_SPU_ADDR10";
     case 2: return "R_SPU_ADDR16";
     case 3: return "R_SPU_ADDR16_HI";
     case 4: return "R_SPU_ADDR16_LO";
     case 5: return "R_SPU_ADDR18";
     case 6: return "R_SPU_ADDR32";
     case 7: return "R_SPU_REL16";
     case 8: return "R_SPU_ADDR7";
     case 9: return "R_SPU_REL9";
     case 10: return "R_SPU_REL9I";
     case 11: return "R_SPU_ADDR10I";
     case 12: return "R_SPU_ADDR16I";
     case 13: return "R_SPU_REL32";
     case 14: return "R_SPU_ADDR16X";
     case 15: return "R_SPU_PPU32";
     case 16: return "R_SPU_PPU64";
     case 17: return "R_SPU_ADD_PIC";
default: return 
# 46 "./../include/elf/spu.h" 3 4
((void *)0)
# 46 "./../include/elf/spu.h"
; } }
# 158 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/tic6x.h" 1
# 27 "./../include/elf/tic6x.h"
static const char *elf_tic6x_reloc_type (unsigned long rtype); static const char * elf_tic6x_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_C6000_NONE";
  case 1: return "R_C6000_ABS32";
  case 2: return "R_C6000_ABS16";
  case 3: return "R_C6000_ABS8";
  case 4: return "R_C6000_PCR_S21";
  case 5: return "R_C6000_PCR_S12";
  case 6: return "R_C6000_PCR_S10";
  case 7: return "R_C6000_PCR_S7";
  case 8: return "R_C6000_ABS_S16";
  case 9: return "R_C6000_ABS_L16";
  case 10: return "R_C6000_ABS_H16";
  case 11: return "R_C6000_SBR_U15_B";
  case 12: return "R_C6000_SBR_U15_H";
  case 13: return "R_C6000_SBR_U15_W";
  case 14: return "R_C6000_SBR_S16";
  case 15: return "R_C6000_SBR_L16_B";
  case 16: return "R_C6000_SBR_L16_H";
  case 17: return "R_C6000_SBR_L16_W";
  case 18: return "R_C6000_SBR_H16_B";
  case 19: return "R_C6000_SBR_H16_H";
  case 20: return "R_C6000_SBR_H16_W";
  case 21: return "R_C6000_SBR_GOT_U15_W";
  case 22: return "R_C6000_SBR_GOT_L16_W";
  case 23: return "R_C6000_SBR_GOT_H16_W";
  case 24: return "R_C6000_DSBT_INDEX";
  case 25: return "R_C6000_PREL31";
  case 26: return "R_C6000_COPY";
  case 27: return "R_C6000_JUMP_SLOT";
  case 28: return "R_C6000_EHTYPE";
  case 29: return "R_C6000_PCR_H16";
  case 30: return "R_C6000_PCR_L16";
  case 253: return "R_C6000_ALIGN";
  case 254: return "R_C6000_FPHEAD";
  case 255: return "R_C6000_NOCMP";
default: return 
# 62 "./../include/elf/tic6x.h" 3 4
((void *)0)
# 62 "./../include/elf/tic6x.h"
; } }
# 139 "./../include/elf/tic6x.h"
enum
  {

# 1 "./../include/elf/tic6x-attrs.h" 1
# 24 "./../include/elf/tic6x-attrs.h"
Tag_ISA = 4,
Tag_ABI_wchar_t = 6,
Tag_ABI_stack_align_needed = 8,
Tag_ABI_stack_align_preserved = 10,
Tag_ABI_DSBT = 12,
Tag_ABI_PID = 14,
Tag_ABI_PIC = 16,
Tag_ABI_array_object_alignment = 18,
Tag_ABI_array_object_align_expected = 20,
Tag_ABI_compatibility = 32,
Tag_ABI_conformance = 67,
# 143 "./../include/elf/tic6x.h" 2

    Tag_C6XABI_last
  };



enum
  {
    C6XABI_Tag_ISA_none = 0,
    C6XABI_Tag_ISA_C62X = 1,
    C6XABI_Tag_ISA_C67X = 3,
    C6XABI_Tag_ISA_C67XP = 4,
    C6XABI_Tag_ISA_C64X = 6,
    C6XABI_Tag_ISA_C64XP = 7,
    C6XABI_Tag_ISA_C674X = 8
  };
# 159 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/tilegx.h" 1
# 27 "./../include/elf/tilegx.h"
static const char *elf_tilegx_reloc_type (unsigned long rtype); static const char * elf_tilegx_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_TILEGX_NONE";


  case 1: return "R_TILEGX_64";
  case 2: return "R_TILEGX_32";
  case 3: return "R_TILEGX_16";
  case 4: return "R_TILEGX_8";
  case 5: return "R_TILEGX_64_PCREL";
  case 6: return "R_TILEGX_32_PCREL";
  case 7: return "R_TILEGX_16_PCREL";
  case 8: return "R_TILEGX_8_PCREL";



  case 9: return "R_TILEGX_HW0";
  case 10: return "R_TILEGX_HW1";
  case 11: return "R_TILEGX_HW2";
  case 12: return "R_TILEGX_HW3";
  case 13: return "R_TILEGX_HW0_LAST";
  case 14: return "R_TILEGX_HW1_LAST";
  case 15: return "R_TILEGX_HW2_LAST";

  case 16: return "R_TILEGX_COPY";
  case 17: return "R_TILEGX_GLOB_DAT";
  case 18: return "R_TILEGX_JMP_SLOT";
  case 19: return "R_TILEGX_RELATIVE";


  case 20: return "R_TILEGX_BROFF_X1";
  case 21: return "R_TILEGX_JUMPOFF_X1";
  case 22: return "R_TILEGX_JUMPOFF_X1_PLT";


  case 23: return "R_TILEGX_IMM8_X0";
  case 24: return "R_TILEGX_IMM8_Y0";
  case 25: return "R_TILEGX_IMM8_X1";
  case 26: return "R_TILEGX_IMM8_Y1";
  case 27: return "R_TILEGX_DEST_IMM8_X1";
  case 28: return "R_TILEGX_MT_IMM14_X1";
  case 29: return "R_TILEGX_MF_IMM14_X1";
  case 30: return "R_TILEGX_MMSTART_X0";
  case 31: return "R_TILEGX_MMEND_X0";
  case 32: return "R_TILEGX_SHAMT_X0";
  case 33: return "R_TILEGX_SHAMT_X1";
  case 34: return "R_TILEGX_SHAMT_Y0";
  case 35: return "R_TILEGX_SHAMT_Y1";

  case 36: return "R_TILEGX_IMM16_X0_HW0";
  case 37: return "R_TILEGX_IMM16_X1_HW0";
  case 38: return "R_TILEGX_IMM16_X0_HW1";
  case 39: return "R_TILEGX_IMM16_X1_HW1";
  case 40: return "R_TILEGX_IMM16_X0_HW2";
  case 41: return "R_TILEGX_IMM16_X1_HW2";
  case 42: return "R_TILEGX_IMM16_X0_HW3";
  case 43: return "R_TILEGX_IMM16_X1_HW3";
  case 44: return "R_TILEGX_IMM16_X0_HW0_LAST";
  case 45: return "R_TILEGX_IMM16_X1_HW0_LAST";
  case 46: return "R_TILEGX_IMM16_X0_HW1_LAST";
  case 47: return "R_TILEGX_IMM16_X1_HW1_LAST";
  case 48: return "R_TILEGX_IMM16_X0_HW2_LAST";
  case 49: return "R_TILEGX_IMM16_X1_HW2_LAST";

  case 50: return "R_TILEGX_IMM16_X0_HW0_PCREL";
  case 51: return "R_TILEGX_IMM16_X1_HW0_PCREL";
  case 52: return "R_TILEGX_IMM16_X0_HW1_PCREL";
  case 53: return "R_TILEGX_IMM16_X1_HW1_PCREL";
  case 54: return "R_TILEGX_IMM16_X0_HW2_PCREL";
  case 55: return "R_TILEGX_IMM16_X1_HW2_PCREL";
  case 56: return "R_TILEGX_IMM16_X0_HW3_PCREL";
  case 57: return "R_TILEGX_IMM16_X1_HW3_PCREL";
  case 58: return "R_TILEGX_IMM16_X0_HW0_LAST_PCREL";
  case 59: return "R_TILEGX_IMM16_X1_HW0_LAST_PCREL";
  case 60: return "R_TILEGX_IMM16_X0_HW1_LAST_PCREL";
  case 61: return "R_TILEGX_IMM16_X1_HW1_LAST_PCREL";
  case 62: return "R_TILEGX_IMM16_X0_HW2_LAST_PCREL";
  case 63: return "R_TILEGX_IMM16_X1_HW2_LAST_PCREL";

  case 64: return "R_TILEGX_IMM16_X0_HW0_GOT";
  case 65: return "R_TILEGX_IMM16_X1_HW0_GOT";

  case 66: return "R_TILEGX_IMM16_X0_HW0_PLT_PCREL";
  case 67: return "R_TILEGX_IMM16_X1_HW0_PLT_PCREL";
  case 68: return "R_TILEGX_IMM16_X0_HW1_PLT_PCREL";
  case 69: return "R_TILEGX_IMM16_X1_HW1_PLT_PCREL";
  case 70: return "R_TILEGX_IMM16_X0_HW2_PLT_PCREL";
  case 71: return "R_TILEGX_IMM16_X1_HW2_PLT_PCREL";

  case 72: return "R_TILEGX_IMM16_X0_HW0_LAST_GOT";
  case 73: return "R_TILEGX_IMM16_X1_HW0_LAST_GOT";
  case 74: return "R_TILEGX_IMM16_X0_HW1_LAST_GOT";
  case 75: return "R_TILEGX_IMM16_X1_HW1_LAST_GOT";

  case 76: return "R_TILEGX_IMM16_X0_HW3_PLT_PCREL";
  case 77: return "R_TILEGX_IMM16_X1_HW3_PLT_PCREL";

  case 78: return "R_TILEGX_IMM16_X0_HW0_TLS_GD";
  case 79: return "R_TILEGX_IMM16_X1_HW0_TLS_GD";
  case 80: return "R_TILEGX_IMM16_X0_HW0_TLS_LE";
  case 81: return "R_TILEGX_IMM16_X1_HW0_TLS_LE";
  case 82: return "R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE";
  case 83: return "R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE";
  case 84: return "R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE";
  case 85: return "R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE";
  case 86: return "R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD";
  case 87: return "R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD";
  case 88: return "R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD";
  case 89: return "R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD";


  case 92: return "R_TILEGX_IMM16_X0_HW0_TLS_IE";
  case 93: return "R_TILEGX_IMM16_X1_HW0_TLS_IE";

  case 94: return "R_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL";
  case 95: return "R_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL";
  case 96: return "R_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL";
  case 97: return "R_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL";
  case 98: return "R_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL";
  case 99: return "R_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL";

  case 100: return "R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE";
  case 101: return "R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE";
  case 102: return "R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE";
  case 103: return "R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE";


  case 106: return "R_TILEGX_TLS_DTPMOD64";
  case 107: return "R_TILEGX_TLS_DTPOFF64";
  case 108: return "R_TILEGX_TLS_TPOFF64";
  case 109: return "R_TILEGX_TLS_DTPMOD32";
  case 110: return "R_TILEGX_TLS_DTPOFF32";
  case 111: return "R_TILEGX_TLS_TPOFF32";

  case 112: return "R_TILEGX_TLS_GD_CALL";
  case 113: return "R_TILEGX_IMM8_X0_TLS_GD_ADD";
  case 114: return "R_TILEGX_IMM8_X1_TLS_GD_ADD";
  case 115: return "R_TILEGX_IMM8_Y0_TLS_GD_ADD";
  case 116: return "R_TILEGX_IMM8_Y1_TLS_GD_ADD";
  case 117: return "R_TILEGX_TLS_IE_LOAD";
  case 118: return "R_TILEGX_IMM8_X0_TLS_ADD";
  case 119: return "R_TILEGX_IMM8_X1_TLS_ADD";
  case 120: return "R_TILEGX_IMM8_Y0_TLS_ADD";
  case 121: return "R_TILEGX_IMM8_Y1_TLS_ADD";


  case 128: return "R_TILEGX_GNU_VTINHERIT";
  case 129: return "R_TILEGX_GNU_VTENTRY";
default: return 
# 174 "./../include/elf/tilegx.h" 3 4
((void *)0)
# 174 "./../include/elf/tilegx.h"
; } }
# 160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/tilepro.h" 1
# 27 "./../include/elf/tilepro.h"
static const char *elf_tilepro_reloc_type (unsigned long rtype); static const char * elf_tilepro_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_TILEPRO_NONE";


  case 1: return "R_TILEPRO_32";
  case 2: return "R_TILEPRO_16";
  case 3: return "R_TILEPRO_8";
  case 4: return "R_TILEPRO_32_PCREL";
  case 5: return "R_TILEPRO_16_PCREL";
  case 6: return "R_TILEPRO_8_PCREL";

  case 7: return "R_TILEPRO_LO16";
  case 8: return "R_TILEPRO_HI16";
  case 9: return "R_TILEPRO_HA16";

  case 10: return "R_TILEPRO_COPY";
  case 11: return "R_TILEPRO_GLOB_DAT";
  case 12: return "R_TILEPRO_JMP_SLOT";
  case 13: return "R_TILEPRO_RELATIVE";


  case 14: return "R_TILEPRO_BROFF_X1";
  case 15: return "R_TILEPRO_JOFFLONG_X1";
  case 16: return "R_TILEPRO_JOFFLONG_X1_PLT";


  case 17: return "R_TILEPRO_IMM8_X0";
  case 18: return "R_TILEPRO_IMM8_Y0";
  case 19: return "R_TILEPRO_IMM8_X1";
  case 20: return "R_TILEPRO_IMM8_Y1";
  case 21: return "R_TILEPRO_MT_IMM15_X1";
  case 22: return "R_TILEPRO_MF_IMM15_X1";

  case 23: return "R_TILEPRO_IMM16_X0";
  case 24: return "R_TILEPRO_IMM16_X1";
  case 25: return "R_TILEPRO_IMM16_X0_LO";
  case 26: return "R_TILEPRO_IMM16_X1_LO";
  case 27: return "R_TILEPRO_IMM16_X0_HI";
  case 28: return "R_TILEPRO_IMM16_X1_HI";
  case 29: return "R_TILEPRO_IMM16_X0_HA";
  case 30: return "R_TILEPRO_IMM16_X1_HA";

  case 31: return "R_TILEPRO_IMM16_X0_PCREL";
  case 32: return "R_TILEPRO_IMM16_X1_PCREL";
  case 33: return "R_TILEPRO_IMM16_X0_LO_PCREL";
  case 34: return "R_TILEPRO_IMM16_X1_LO_PCREL";
  case 35: return "R_TILEPRO_IMM16_X0_HI_PCREL";
  case 36: return "R_TILEPRO_IMM16_X1_HI_PCREL";
  case 37: return "R_TILEPRO_IMM16_X0_HA_PCREL";
  case 38: return "R_TILEPRO_IMM16_X1_HA_PCREL";

  case 39: return "R_TILEPRO_IMM16_X0_GOT";
  case 40: return "R_TILEPRO_IMM16_X1_GOT";
  case 41: return "R_TILEPRO_IMM16_X0_GOT_LO";
  case 42: return "R_TILEPRO_IMM16_X1_GOT_LO";
  case 43: return "R_TILEPRO_IMM16_X0_GOT_HI";
  case 44: return "R_TILEPRO_IMM16_X1_GOT_HI";
  case 45: return "R_TILEPRO_IMM16_X0_GOT_HA";
  case 46: return "R_TILEPRO_IMM16_X1_GOT_HA";

  case 47: return "R_TILEPRO_MMSTART_X0";
  case 48: return "R_TILEPRO_MMEND_X0";
  case 49: return "R_TILEPRO_MMSTART_X1";
  case 50: return "R_TILEPRO_MMEND_X1";

  case 51: return "R_TILEPRO_SHAMT_X0";
  case 52: return "R_TILEPRO_SHAMT_X1";
  case 53: return "R_TILEPRO_SHAMT_Y0";
  case 54: return "R_TILEPRO_SHAMT_Y1";

  case 55: return "R_TILEPRO_DEST_IMM8_X1";



  case 60: return "R_TILEPRO_TLS_GD_CALL";
  case 61: return "R_TILEPRO_IMM8_X0_TLS_GD_ADD";
  case 62: return "R_TILEPRO_IMM8_X1_TLS_GD_ADD";
  case 63: return "R_TILEPRO_IMM8_Y0_TLS_GD_ADD";
  case 64: return "R_TILEPRO_IMM8_Y1_TLS_GD_ADD";
  case 65: return "R_TILEPRO_TLS_IE_LOAD";

  case 66: return "R_TILEPRO_IMM16_X0_TLS_GD";
  case 67: return "R_TILEPRO_IMM16_X1_TLS_GD";
  case 68: return "R_TILEPRO_IMM16_X0_TLS_GD_LO";
  case 69: return "R_TILEPRO_IMM16_X1_TLS_GD_LO";
  case 70: return "R_TILEPRO_IMM16_X0_TLS_GD_HI";
  case 71: return "R_TILEPRO_IMM16_X1_TLS_GD_HI";
  case 72: return "R_TILEPRO_IMM16_X0_TLS_GD_HA";
  case 73: return "R_TILEPRO_IMM16_X1_TLS_GD_HA";

  case 74: return "R_TILEPRO_IMM16_X0_TLS_IE";
  case 75: return "R_TILEPRO_IMM16_X1_TLS_IE";
  case 76: return "R_TILEPRO_IMM16_X0_TLS_IE_LO";
  case 77: return "R_TILEPRO_IMM16_X1_TLS_IE_LO";
  case 78: return "R_TILEPRO_IMM16_X0_TLS_IE_HI";
  case 79: return "R_TILEPRO_IMM16_X1_TLS_IE_HI";
  case 80: return "R_TILEPRO_IMM16_X0_TLS_IE_HA";
  case 81: return "R_TILEPRO_IMM16_X1_TLS_IE_HA";

  case 82: return "R_TILEPRO_TLS_DTPMOD32";
  case 83: return "R_TILEPRO_TLS_DTPOFF32";
  case 84: return "R_TILEPRO_TLS_TPOFF32";

  case 85: return "R_TILEPRO_IMM16_X0_TLS_LE";
  case 86: return "R_TILEPRO_IMM16_X1_TLS_LE";
  case 87: return "R_TILEPRO_IMM16_X0_TLS_LE_LO";
  case 88: return "R_TILEPRO_IMM16_X1_TLS_LE_LO";
  case 89: return "R_TILEPRO_IMM16_X0_TLS_LE_HI";
  case 90: return "R_TILEPRO_IMM16_X1_TLS_LE_HI";
  case 91: return "R_TILEPRO_IMM16_X0_TLS_LE_HA";
  case 92: return "R_TILEPRO_IMM16_X1_TLS_LE_HA";


  case 128: return "R_TILEPRO_GNU_VTINHERIT";
  case 129: return "R_TILEPRO_GNU_VTENTRY";
default: return 
# 142 "./../include/elf/tilepro.h" 3 4
((void *)0)
# 142 "./../include/elf/tilepro.h"
; } }
# 161 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/v850.h" 1
# 60 "./../include/elf/v850.h"
static const char *v850_reloc_type (unsigned long rtype); static const char * v850_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_V850_NONE";
     case 1: return "R_V850_9_PCREL";
     case 2: return "R_V850_22_PCREL";
     case 3: return "R_V850_HI16_S";
     case 4: return "R_V850_HI16";
     case 5: return "R_V850_LO16";
     case 6: return "R_V850_ABS32";
     case 7: return "R_V850_16";
     case 8: return "R_V850_8";
     case 9: return "R_V850_SDA_16_16_OFFSET";
     case 10: return "R_V850_SDA_15_16_OFFSET";
     case 11: return "R_V850_ZDA_16_16_OFFSET";
     case 12: return "R_V850_ZDA_15_16_OFFSET";
     case 13: return "R_V850_TDA_6_8_OFFSET";
     case 14: return "R_V850_TDA_7_8_OFFSET";
     case 15: return "R_V850_TDA_7_7_OFFSET";
     case 16: return "R_V850_TDA_16_16_OFFSET";
     case 17: return "R_V850_TDA_4_5_OFFSET";
     case 18: return "R_V850_TDA_4_4_OFFSET";
     case 19: return "R_V850_SDA_16_16_SPLIT_OFFSET";
     case 20: return "R_V850_ZDA_16_16_SPLIT_OFFSET";
     case 21: return "R_V850_CALLT_6_7_OFFSET";
     case 22: return "R_V850_CALLT_16_16_OFFSET";
     case 23: return "R_V850_GNU_VTINHERIT";
     case 24: return "R_V850_GNU_VTENTRY";
     case 25: return "R_V850_LONGCALL";
     case 26: return "R_V850_LONGJUMP";
     case 27: return "R_V850_ALIGN";
     case 28: return "R_V850_REL32";
     case 29: return "R_V850_LO16_SPLIT_OFFSET";
     case 30: return "R_V850_16_PCREL";
     case 31: return "R_V850_17_PCREL";
     case 32: return "R_V850_23";
     case 33: return "R_V850_32_PCREL";
     case 34: return "R_V850_32_ABS";
     case 35: return "R_V850_16_SPLIT_OFFSET";
     case 36: return "R_V850_16_S1";
     case 37: return "R_V850_LO16_S1";
     case 38: return "R_V850_CALLT_15_16_OFFSET";
     case 39: return "R_V850_32_GOTPCREL";
     case 40: return "R_V850_16_GOT";
     case 41: return "R_V850_32_GOT";
     case 42: return "R_V850_22_PLT";
     case 43: return "R_V850_32_PLT";
     case 44: return "R_V850_COPY";
     case 45: return "R_V850_GLOB_DAT";
     case 46: return "R_V850_JMP_SLOT";
     case 47: return "R_V850_RELATIVE";
     case 48: return "R_V850_16_GOTOFF";
     case 49: return "R_V850_32_GOTOFF";
     case 50: return "R_V850_CODE";
     case 51: return "R_V850_DATA";

default: return 
# 114 "./../include/elf/v850.h" 3 4
((void *)0)
# 114 "./../include/elf/v850.h"
; } }
# 179 "./../include/elf/v850.h"
static const char *v800_reloc_type (unsigned long rtype); static const char * v800_reloc_type (unsigned long rtype) { switch (rtype) {

     case 0x00: return "R_V800_NONE";
     case 0x30: return "R_V810_NONE";
     case 0x31: return "R_V810_BYTE";
     case 0x32: return "R_V810_HWORD";
     case 0x33: return "R_V810_WORD";
     case 0x34: return "R_V810_WLO";
     case 0x35: return "R_V810_WHI";
     case 0x36: return "R_V810_WHI1";
     case 0x37: return "R_V810_GPBYTE";
     case 0x38: return "R_V810_GPHWORD";
     case 0x39: return "R_V810_GPWORD";
     case 0x3a: return "R_V810_GPWLO";
     case 0x3b: return "R_V810_GPWHI";
     case 0x3c: return "R_V810_GPWHI1";
     case 0x3d: return "R_V850_HWLO";
    
     case 0x3f: return "R_V850_EP7BIT";
     case 0x40: return "R_V850_EPHBYTE";
     case 0x41: return "R_V850_EPWBYTE";
     case 0x42: return "R_V850_REGHWLO";
    
     case 0x44: return "R_V850_GPHWLO";
    
     case 0x46: return "R_V850_PCR22";
     case 0x47: return "R_V850_BLO";
     case 0x48: return "R_V850_EP4BIT";
     case 0x49: return "R_V850_EP5BIT";
     case 0x4a: return "R_V850_REGBLO";
     case 0x4b: return "R_V850_GPBLO";
     case 0x4c: return "R_V810_WLO_1";
     case 0x4d: return "R_V810_GPWLO_1";
     case 0x4e: return "R_V850_BLO_1";
     case 0x4f: return "R_V850_HWLO_1";
    
     case 0x51: return "R_V850_GPBLO_1";
     case 0x52: return "R_V850_GPHWLO_1";
    
     case 0x54: return "R_V850_EPBLO";
     case 0x55: return "R_V850_EPHWLO";
    
     case 0x57: return "R_V850_EPWLO_N";
     case 0x58: return "R_V850_PC32";
     case 0x59: return "R_V850_W23BIT";
     case 0x5a: return "R_V850_GPW23BIT";
     case 0x5b: return "R_V850_EPW23BIT";
     case 0x5c: return "R_V850_B23BIT";
     case 0x5d: return "R_V850_GPB23BIT";
     case 0x5e: return "R_V850_EPB23BIT";
     case 0x5f: return "R_V850_PC16U";
     case 0x60: return "R_V850_PC17";
     case 0x61: return "R_V850_DW8";
     case 0x62: return "R_V850_GPDW8";
     case 0x63: return "R_V850_EPDW8";
     case 0x64: return "R_V850_PC9";
     case 0x65: return "R_V810_REGBYTE";
     case 0x66: return "R_V810_REGHWORD";
     case 0x67: return "R_V810_REGWORD";
     case 0x68: return "R_V810_REGWLO";
     case 0x69: return "R_V810_REGWHI";
     case 0x6a: return "R_V810_REGWHI1";
     case 0x6b: return "R_V850_REGW23BIT";
     case 0x6c: return "R_V850_REGB23BIT";
     case 0x6d: return "R_V850_REGDW8";
     case 0x6e: return "R_V810_EPBYTE";
     case 0x6f: return "R_V810_EPHWORD";
     case 0x70: return "R_V810_EPWORD";
     case 0x71: return "R_V850_WLO23";
     case 0x72: return "R_V850_WORD_E";
     case 0x73: return "R_V850_REGWORD_E";
     case 0x74: return "R_V850_WORD";
     case 0x75: return "R_V850_GPWORD";
     case 0x76: return "R_V850_REGWORD";
     case 0x77: return "R_V850_EPWORD";
     case 0x78: return "R_V810_TPBYTE";
     case 0x79: return "R_V810_TPHWORD";
     case 0x7a: return "R_V810_TPWORD";
     case 0x7b: return "R_V810_TPWLO";
     case 0x7c: return "R_V810_TPWHI";
     case 0x7d: return "R_V810_TPWHI1";
     case 0x7e: return "R_V850_TPHWLO";
     case 0x7f: return "R_V850_TPBLO";
     case 0x80: return "R_V810_TPWLO_1";
     case 0x81: return "R_V850_TPBLO_1";
     case 0x82: return "R_V850_TPHWLO_1";
     case 0x83: return "R_V850_TP23BIT";
     case 0x84: return "R_V850_TPW23BIT";
     case 0x85: return "R_V850_TPDW8";


     case 0xa0: return "R_V810_ABS32";
     case 0xe0: return "R_V850_SYM";
     case 0xe1: return "R_V850_OPadd";
     case 0xe2: return "R_V850_OPsub";
     case 0xe3: return "R_V850_OPsctsize";
     case 0xe4: return "R_V850_OPscttop";

default: return 
# 277 "./../include/elf/v850.h" 3 4
((void *)0)
# 277 "./../include/elf/v850.h"
; } }
# 303 "./../include/elf/v850.h"
enum v850_notes
{
  V850_NOTE_ALIGNMENT = 1,



  V850_NOTE_DATA_SIZE = 2,



  V850_NOTE_FPU_INFO = 3,



  V850_NOTE_SIMD_INFO = 4,


  V850_NOTE_CACHE_INFO = 5,


  V850_NOTE_MMU_INFO = 6

};
# 162 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/vax.h" 1
# 27 "./../include/elf/vax.h"
static const char *elf_vax_reloc_type (unsigned long rtype); static const char * elf_vax_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_VAX_NONE";
  case 1: return "R_VAX_32";
  case 2: return "R_VAX_16";
  case 3: return "R_VAX_8";
  case 4: return "R_VAX_PC32";
  case 5: return "R_VAX_PC16";
  case 6: return "R_VAX_PC8";
  case 7: return "R_VAX_GOT32";
  case 13: return "R_VAX_PLT32";
  case 19: return "R_VAX_COPY";
  case 20: return "R_VAX_GLOB_DAT";
  case 21: return "R_VAX_JMP_SLOT";
  case 22: return "R_VAX_RELATIVE";

  case 23: return "R_VAX_GNU_VTINHERIT";
  case 24: return "R_VAX_GNU_VTENTRY";
default: return 
# 44 "./../include/elf/vax.h" 3 4
((void *)0)
# 44 "./../include/elf/vax.h"
; } }
# 163 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/visium.h" 1
# 32 "./../include/elf/visium.h"
static const char *elf_visium_reloc_type (unsigned long rtype); static const char * elf_visium_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_VISIUM_NONE";
  case 1: return "R_VISIUM_8";
  case 2: return "R_VISIUM_16";
  case 3: return "R_VISIUM_32";
  case 4: return "R_VISIUM_8_PCREL";
  case 5: return "R_VISIUM_16_PCREL";
  case 6: return "R_VISIUM_32_PCREL";
  case 7: return "R_VISIUM_PC16";
  case 8: return "R_VISIUM_HI16";
  case 9: return "R_VISIUM_LO16";
  case 10: return "R_VISIUM_IM16";
  case 11: return "R_VISIUM_HI16_PCREL";
  case 12: return "R_VISIUM_LO16_PCREL";
  case 13: return "R_VISIUM_IM16_PCREL";
  case 200: return "R_VISIUM_GNU_VTINHERIT";
  case 201: return "R_VISIUM_GNU_VTENTRY";
default: return 
# 49 "./../include/elf/visium.h" 3 4
((void *)0)
# 49 "./../include/elf/visium.h"
; } }
# 164 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/wasm32.h" 1
# 25 "./../include/elf/wasm32.h"
static const char *elf_wasm32_reloc_type (unsigned long rtype); static const char * elf_wasm32_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_WASM32_NONE";
  case 1: return "R_WASM32_32";
default: return 
# 28 "./../include/elf/wasm32.h" 3 4
((void *)0)
# 28 "./../include/elf/wasm32.h"
; } }
# 165 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/x86-64.h" 1
# 26 "./../include/elf/x86-64.h"
static const char *elf_x86_64_reloc_type (unsigned long rtype); static const char * elf_x86_64_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_X86_64_NONE";
     case 1: return "R_X86_64_64";
     case 2: return "R_X86_64_PC32";
     case 3: return "R_X86_64_GOT32";
     case 4: return "R_X86_64_PLT32";
     case 5: return "R_X86_64_COPY";
     case 6: return "R_X86_64_GLOB_DAT";
     case 7: return "R_X86_64_JUMP_SLOT";
     case 8: return "R_X86_64_RELATIVE";
     case 9: return "R_X86_64_GOTPCREL";

     case 10: return "R_X86_64_32";
     case 11: return "R_X86_64_32S";
     case 12: return "R_X86_64_16";
     case 13: return "R_X86_64_PC16";
     case 14: return "R_X86_64_8";
     case 15: return "R_X86_64_PC8";
     case 16: return "R_X86_64_DTPMOD64";
     case 17: return "R_X86_64_DTPOFF64";
     case 18: return "R_X86_64_TPOFF64";
     case 19: return "R_X86_64_TLSGD";
     case 20: return "R_X86_64_TLSLD";
     case 21: return "R_X86_64_DTPOFF32";
     case 22: return "R_X86_64_GOTTPOFF";
     case 23: return "R_X86_64_TPOFF32";
     case 24: return "R_X86_64_PC64";
     case 25: return "R_X86_64_GOTOFF64";
     case 26: return "R_X86_64_GOTPC32";

     case 27: return "R_X86_64_GOT64";
     case 28: return "R_X86_64_GOTPCREL64";

     case 29: return "R_X86_64_GOTPC64";

     case 30: return "R_X86_64_GOTPLT64";
     case 31: return "R_X86_64_PLTOFF64";

     case 32: return "R_X86_64_SIZE32";
     case 33: return "R_X86_64_SIZE64";
     case 34: return "R_X86_64_GOTPC32_TLSDESC";



     case 35: return "R_X86_64_TLSDESC_CALL";

     case 36: return "R_X86_64_TLSDESC";
     case 37: return "R_X86_64_IRELATIVE";
     case 38: return "R_X86_64_RELATIVE64";
     case 39: return "R_X86_64_PC32_BND";

     case 40: return "R_X86_64_PLT32_BND";



     case 41: return "R_X86_64_GOTPCRELX";


     case 42: return "R_X86_64_REX_GOTPCRELX";
     case 250: return "R_X86_64_GNU_VTINHERIT";
     case 251: return "R_X86_64_GNU_VTENTRY";
default: return 
# 87 "./../include/elf/x86-64.h" 3 4
((void *)0)
# 87 "./../include/elf/x86-64.h"
; } }
# 166 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/xgate.h" 1
# 26 "./../include/elf/xgate.h"
static const char *elf_xgate_reloc_type (unsigned long rtype); static const char * elf_xgate_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_XGATE_NONE";
  case 1: return "R_XGATE_8";
  case 2: return "R_XGATE_PCREL_8";
  case 3: return "R_XGATE_16";
  case 4: return "R_XGATE_32";
  case 5: return "R_XGATE_PCREL_16";

  case 6: return "R_XGATE_GNU_VTINHERIT";
  case 7: return "R_XGATE_GNU_VTENTRY";

  case 8: return "R_XGATE_24";
  case 9: return "R_XGATE_LO16";
  case 10: return "R_XGATE_GPAGE";
  case 11: return "R_XGATE_PCREL_9";
  case 12: return "R_XGATE_PCREL_10";
  case 13: return "R_XGATE_IMM8_LO";
  case 14: return "R_XGATE_IMM8_HI";
  case 15: return "R_XGATE_IMM3";
  case 16: return "R_XGATE_IMM4";
  case 17: return "R_XGATE_IMM5";



  case 18: return "R_XGATE_RL_JUMP";


  case 19: return "R_XGATE_RL_GROUP";
default: return 
# 54 "./../include/elf/xgate.h" 3 4
((void *)0)
# 54 "./../include/elf/xgate.h"
; } }
# 167 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/xstormy16.h" 1
# 26 "./../include/elf/xstormy16.h"
static const char *elf_xstormy16_reloc_type (unsigned long rtype); static const char * elf_xstormy16_reloc_type (unsigned long rtype) { switch (rtype) {
  case 0: return "R_XSTORMY16_NONE";

  case 1: return "R_XSTORMY16_32";
  case 2: return "R_XSTORMY16_16";
  case 3: return "R_XSTORMY16_8";
  case 4: return "R_XSTORMY16_PC32";
  case 5: return "R_XSTORMY16_PC16";
  case 6: return "R_XSTORMY16_PC8";

  case 7: return "R_XSTORMY16_REL_12";
  case 8: return "R_XSTORMY16_24";
  case 9: return "R_XSTORMY16_FPTR16";

  case 10: return "R_XSTORMY16_LO16";
  case 11: return "R_XSTORMY16_HI16";
  case 12: return "R_XSTORMY16_12";

  case 128: return "R_XSTORMY16_GNU_VTINHERIT";
  case 129: return "R_XSTORMY16_GNU_VTENTRY";
default: return 
# 46 "./../include/elf/xstormy16.h" 3 4
((void *)0)
# 46 "./../include/elf/xstormy16.h"
; } }
# 168 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/xtensa.h" 1
# 34 "./../include/elf/xtensa.h"
static const char *elf_xtensa_reloc_type (unsigned long rtype); static const char * elf_xtensa_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_XTENSA_NONE";
     case 1: return "R_XTENSA_32";
     case 2: return "R_XTENSA_RTLD";
     case 3: return "R_XTENSA_GLOB_DAT";
     case 4: return "R_XTENSA_JMP_SLOT";
     case 5: return "R_XTENSA_RELATIVE";
     case 6: return "R_XTENSA_PLT";
     case 8: return "R_XTENSA_OP0";
     case 9: return "R_XTENSA_OP1";
     case 10: return "R_XTENSA_OP2";
     case 11: return "R_XTENSA_ASM_EXPAND";
     case 12: return "R_XTENSA_ASM_SIMPLIFY";
     case 14: return "R_XTENSA_32_PCREL";
     case 15: return "R_XTENSA_GNU_VTINHERIT";
     case 16: return "R_XTENSA_GNU_VTENTRY";
     case 17: return "R_XTENSA_DIFF8";
     case 18: return "R_XTENSA_DIFF16";
     case 19: return "R_XTENSA_DIFF32";
     case 20: return "R_XTENSA_SLOT0_OP";
     case 21: return "R_XTENSA_SLOT1_OP";
     case 22: return "R_XTENSA_SLOT2_OP";
     case 23: return "R_XTENSA_SLOT3_OP";
     case 24: return "R_XTENSA_SLOT4_OP";
     case 25: return "R_XTENSA_SLOT5_OP";
     case 26: return "R_XTENSA_SLOT6_OP";
     case 27: return "R_XTENSA_SLOT7_OP";
     case 28: return "R_XTENSA_SLOT8_OP";
     case 29: return "R_XTENSA_SLOT9_OP";
     case 30: return "R_XTENSA_SLOT10_OP";
     case 31: return "R_XTENSA_SLOT11_OP";
     case 32: return "R_XTENSA_SLOT12_OP";
     case 33: return "R_XTENSA_SLOT13_OP";
     case 34: return "R_XTENSA_SLOT14_OP";
     case 35: return "R_XTENSA_SLOT0_ALT";
     case 36: return "R_XTENSA_SLOT1_ALT";
     case 37: return "R_XTENSA_SLOT2_ALT";
     case 38: return "R_XTENSA_SLOT3_ALT";
     case 39: return "R_XTENSA_SLOT4_ALT";
     case 40: return "R_XTENSA_SLOT5_ALT";
     case 41: return "R_XTENSA_SLOT6_ALT";
     case 42: return "R_XTENSA_SLOT7_ALT";
     case 43: return "R_XTENSA_SLOT8_ALT";
     case 44: return "R_XTENSA_SLOT9_ALT";
     case 45: return "R_XTENSA_SLOT10_ALT";
     case 46: return "R_XTENSA_SLOT11_ALT";
     case 47: return "R_XTENSA_SLOT12_ALT";
     case 48: return "R_XTENSA_SLOT13_ALT";
     case 49: return "R_XTENSA_SLOT14_ALT";
     case 50: return "R_XTENSA_TLSDESC_FN";
     case 51: return "R_XTENSA_TLSDESC_ARG";
     case 52: return "R_XTENSA_TLS_DTPOFF";
     case 53: return "R_XTENSA_TLS_TPOFF";
     case 54: return "R_XTENSA_TLS_FUNC";
     case 55: return "R_XTENSA_TLS_ARG";
     case 56: return "R_XTENSA_TLS_CALL";
     case 57: return "R_XTENSA_PDIFF8";
     case 58: return "R_XTENSA_PDIFF16";
     case 59: return "R_XTENSA_PDIFF32";
     case 60: return "R_XTENSA_NDIFF8";
     case 61: return "R_XTENSA_NDIFF16";
     case 62: return "R_XTENSA_NDIFF32";
default: return 
# 96 "./../include/elf/xtensa.h" 3 4
((void *)0)
# 96 "./../include/elf/xtensa.h"
; } }
# 134 "./../include/elf/xtensa.h"
typedef struct property_table_entry_t
{
  bfd_vma address;
  bfd_vma size;
  flagword flags;
} property_table_entry;
# 218 "./../include/elf/xtensa.h"
extern asection *xtensa_make_property_section (asection *, const char *);
extern int
xtensa_read_table_entries (bfd *abfd,
      asection *section,
      property_table_entry **table_p,
      const char *sec_name,
      
# 224 "./../include/elf/xtensa.h" 3 4
     _Bool 
# 224 "./../include/elf/xtensa.h"
          output_addr);
extern int
xtensa_compute_fill_extra_space (property_table_entry *entry);

extern int
xtensa_abi_choice (void);
# 169 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/z80.h" 1
# 37 "./../include/elf/z80.h"
static const char *elf_z80_reloc_type (unsigned long rtype); static const char * elf_z80_reloc_type (unsigned long rtype) { switch (rtype) {
     case 0: return "R_Z80_NONE";
     case 1: return "R_Z80_8";
     case 2: return "R_Z80_8_DIS";
     case 3: return "R_Z80_8_PCREL";
     case 4: return "R_Z80_16";
     case 5: return "R_Z80_24";
     case 6: return "R_Z80_32";
     case 7: return "R_Z80_BYTE0";
     case 8: return "R_Z80_BYTE1";
     case 9: return "R_Z80_BYTE2";
     case 10: return "R_Z80_BYTE3";
     case 11: return "R_Z80_WORD0";
     case 12: return "R_Z80_WORD1";
     case 13: return "R_Z80_16_BE";
default: return 
# 52 "./../include/elf/z80.h" 3 4
((void *)0)
# 52 "./../include/elf/z80.h"
; } }
# 170 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/elf/loongarch.h" 1
# 26 "./../include/elf/loongarch.h"
static const char *elf_loongarch_reloc_type (unsigned long rtype); static const char * elf_loongarch_reloc_type (unsigned long rtype) { switch (rtype) {

case 0: return "R_LARCH_NONE";
case 1: return "R_LARCH_32";
case 2: return "R_LARCH_64";
case 3: return "R_LARCH_RELATIVE";
case 4: return "R_LARCH_COPY";
case 5: return "R_LARCH_JUMP_SLOT";
case 6: return "R_LARCH_TLS_DTPMOD32";
case 7: return "R_LARCH_TLS_DTPMOD64";
case 8: return "R_LARCH_TLS_DTPREL32";
case 9: return "R_LARCH_TLS_DTPREL64";
case 10: return "R_LARCH_TLS_TPREL32";
case 11: return "R_LARCH_TLS_TPREL64";
case 12: return "R_LARCH_IRELATIVE";




case 20: return "R_LARCH_MARK_LA";
case 21: return "R_LARCH_MARK_PCREL";

case 22: return "R_LARCH_SOP_PUSH_PCREL";

case 23: return "R_LARCH_SOP_PUSH_ABSOLUTE";

case 24: return "R_LARCH_SOP_PUSH_DUP";
case 25: return "R_LARCH_SOP_PUSH_GPREL";
case 26: return "R_LARCH_SOP_PUSH_TLS_TPREL";
case 27: return "R_LARCH_SOP_PUSH_TLS_GOT";
case 28: return "R_LARCH_SOP_PUSH_TLS_GD";
case 29: return "R_LARCH_SOP_PUSH_PLT_PCREL";

case 30: return "R_LARCH_SOP_ASSERT";
case 31: return "R_LARCH_SOP_NOT";
case 32: return "R_LARCH_SOP_SUB";
case 33: return "R_LARCH_SOP_SL";
case 34: return "R_LARCH_SOP_SR";
case 35: return "R_LARCH_SOP_ADD";
case 36: return "R_LARCH_SOP_AND";
case 37: return "R_LARCH_SOP_IF_ELSE";
case 38: return "R_LARCH_SOP_POP_32_S_10_5";
case 39: return "R_LARCH_SOP_POP_32_U_10_12";
case 40: return "R_LARCH_SOP_POP_32_S_10_12";
case 41: return "R_LARCH_SOP_POP_32_S_10_16";
case 42: return "R_LARCH_SOP_POP_32_S_10_16_S2";
case 43: return "R_LARCH_SOP_POP_32_S_5_20";
case 44: return "R_LARCH_SOP_POP_32_S_0_5_10_16_S2";
case 45: return "R_LARCH_SOP_POP_32_S_0_10_10_16_S2";
case 46: return "R_LARCH_SOP_POP_32_U";


case 47: return "R_LARCH_ADD8";
case 48: return "R_LARCH_ADD16";
case 49: return "R_LARCH_ADD24";
case 50: return "R_LARCH_ADD32";
case 51: return "R_LARCH_ADD64";
case 52: return "R_LARCH_SUB8";
case 53: return "R_LARCH_SUB16";
case 54: return "R_LARCH_SUB24";
case 55: return "R_LARCH_SUB32";
case 56: return "R_LARCH_SUB64";


case 57: return "R_LARCH_GNU_VTINHERIT";
case 58: return "R_LARCH_GNU_VTENTRY";





case 64: return "R_LARCH_B16";



case 65: return "R_LARCH_B21";



case 66: return "R_LARCH_B26";




case 67: return "R_LARCH_ABS_HI20";



case 68: return "R_LARCH_ABS_LO12";




case 69: return "R_LARCH_ABS64_LO20";



case 70: return "R_LARCH_ABS64_HI12";




case 71: return "R_LARCH_PCALA_HI20";



case 72: return "R_LARCH_PCALA_LO12";



case 73: return "R_LARCH_PCALA64_LO20";



case 74: return "R_LARCH_PCALA64_HI12";




case 75: return "R_LARCH_GOT_PC_HI20";



case 76: return "R_LARCH_GOT_PC_LO12";



case 77: return "R_LARCH_GOT64_PC_LO20";



case 78: return "R_LARCH_GOT64_PC_HI12";



case 79: return "R_LARCH_GOT_HI20";



case 80: return "R_LARCH_GOT_LO12";



case 81: return "R_LARCH_GOT64_LO20";



case 82: return "R_LARCH_GOT64_HI12";




case 83: return "R_LARCH_TLS_LE_HI20";



case 84: return "R_LARCH_TLS_LE_LO12";



case 85: return "R_LARCH_TLS_LE64_LO20";



case 86: return "R_LARCH_TLS_LE64_HI12";




case 87: return "R_LARCH_TLS_IE_PC_HI20";
case 88: return "R_LARCH_TLS_IE_PC_LO12";
case 89: return "R_LARCH_TLS_IE64_PC_LO20";
case 90: return "R_LARCH_TLS_IE64_PC_HI12";




case 91: return "R_LARCH_TLS_IE_HI20";
case 92: return "R_LARCH_TLS_IE_LO12";
case 93: return "R_LARCH_TLS_IE64_LO20";
case 94: return "R_LARCH_TLS_IE64_HI12";




case 95: return "R_LARCH_TLS_LD_PC_HI20";



case 96: return "R_LARCH_TLS_LD_HI20";




case 97: return "R_LARCH_TLS_GD_PC_HI20";



case 98: return "R_LARCH_TLS_GD_HI20";


case 99: return "R_LARCH_32_PCREL";


case 100: return "R_LARCH_RELAX";


case 101: return "R_LARCH_DELETE";


case 102: return "R_LARCH_ALIGN";


case 103: return "R_LARCH_PCREL20_S2";


case 104: return "R_LARCH_CFA";


case 105: return "R_LARCH_ADD6";
case 106: return "R_LARCH_SUB6";


case 107: return "R_LARCH_ADD_ULEB128";
case 108: return "R_LARCH_SUB_ULEB128";

case 109: return "R_LARCH_64_PCREL";

default: return 
# 254 "./../include/elf/loongarch.h" 3 4
((void *)0)
# 254 "./../include/elf/loongarch.h"
; } }
# 171 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2

# 1 "./../include/getopt.h" 1
# 35 "./../include/getopt.h"
extern char *optarg;
# 49 "./../include/getopt.h"
extern int optind;




extern int opterr;



extern int optopt;
# 81 "./../include/getopt.h"
struct option
{

  const char *name;





  int has_arg;
  int *flag;
  int val;
};
# 120 "./../include/getopt.h"
extern int getopt_long (int argc, char *const *argv, const char *shortopts,
          const struct option *longopts, int *longind);
extern int getopt_long_only (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind);


extern int _getopt_internal (int argc, char *const *argv,
        const char *shortopts,
               const struct option *longopts, int *longind,
        int long_only);
# 173 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2

# 1 "./../include/safe-ctype.h" 1
# 57 "./../include/safe-ctype.h"
enum {

  _sch_isblank = 0x0001,
  _sch_iscntrl = 0x0002,
  _sch_isdigit = 0x0004,
  _sch_islower = 0x0008,
  _sch_isprint = 0x0010,
  _sch_ispunct = 0x0020,
  _sch_isspace = 0x0040,
  _sch_isupper = 0x0080,
  _sch_isxdigit = 0x0100,


  _sch_isidst = 0x0200,
  _sch_isvsp = 0x0400,
  _sch_isnvsp = 0x0800,


  _sch_isalpha = _sch_isupper|_sch_islower,
  _sch_isalnum = _sch_isalpha|_sch_isdigit,
  _sch_isidnum = _sch_isidst|_sch_isdigit,
  _sch_isgraph = _sch_isalnum|_sch_ispunct,
  _sch_iscppsp = _sch_isvsp|_sch_isnvsp,
  _sch_isbasic = _sch_isprint|_sch_iscppsp

};


extern const unsigned short _sch_istable[256];
# 110 "./../include/safe-ctype.h"
extern const unsigned char _sch_toupper[256];
extern const unsigned char _sch_tolower[256];
# 122 "./../include/safe-ctype.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 123 "./../include/safe-ctype.h" 2
# 175 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2
# 1 "./../include/filenames.h" 1
# 29 "./../include/filenames.h"
# 1 "./../include/hashtab.h" 1
# 42 "./../include/hashtab.h"

# 42 "./../include/hashtab.h"
typedef unsigned int hashval_t;




typedef hashval_t (*htab_hash) (const void *);






typedef int (*htab_eq) (const void *, const void *);



typedef void (*htab_del) (void *);





typedef int (*htab_trav) (void **, void *);





typedef void *(*htab_alloc) (size_t, size_t);


typedef void (*htab_free) (void *);



typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);
typedef void (*htab_free_with_arg) (void *, void *);
# 95 "./../include/hashtab.h"
struct htab {

  htab_hash hash_f;


  htab_eq eq_f;


  htab_del del_f;


  void **entries;


  size_t size;


  size_t n_elements;


  size_t n_deleted;



  unsigned int searches;



  unsigned int collisions;


  htab_alloc alloc_f;
  htab_free free_f;


  void *alloc_arg;
  htab_alloc_with_arg alloc_with_arg_f;
  htab_free_with_arg free_with_arg_f;



  unsigned int size_prime_index;
};

typedef struct htab *htab_t;


enum insert_option {NO_INSERT, INSERT};



extern htab_t htab_create_alloc (size_t, htab_hash,
                                    htab_eq, htab_del,
                                    htab_alloc, htab_free);

extern htab_t htab_create_alloc_ex (size_t, htab_hash,
                                      htab_eq, htab_del,
                                      void *, htab_alloc_with_arg,
                                      htab_free_with_arg);

extern htab_t htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,
     htab_alloc, htab_alloc, htab_free);


extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);
extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);

extern void htab_set_functions_ex (htab_t, htab_hash,
                                       htab_eq, htab_del,
                                       void *, htab_alloc_with_arg,
                                       htab_free_with_arg);

extern void htab_delete (htab_t);
extern void htab_empty (htab_t);

extern void * htab_find (htab_t, const void *);
extern void ** htab_find_slot (htab_t, const void *, enum insert_option);
extern void * htab_find_with_hash (htab_t, const void *, hashval_t);
extern void ** htab_find_slot_with_hash (htab_t, const void *,
       hashval_t, enum insert_option);
extern void htab_clear_slot (htab_t, void **);
extern void htab_remove_elt (htab_t, const void *);
extern void htab_remove_elt_with_hash (htab_t, const void *, hashval_t);

extern void htab_traverse (htab_t, htab_trav, void *);
extern void htab_traverse_noresize (htab_t, htab_trav, void *);

extern size_t htab_size (htab_t);
extern size_t htab_elements (htab_t);
extern double htab_collisions (htab_t);


extern htab_hash htab_hash_pointer;


extern htab_eq htab_eq_pointer;


extern hashval_t htab_hash_string (const void *);


extern int htab_eq_string (const void *, const void *);


extern hashval_t iterative_hash (const void *, size_t, hashval_t);
# 30 "./../include/filenames.h" 2
# 84 "./../include/filenames.h"
extern int filename_cmp (const char *s1, const char *s2);


extern int filename_ncmp (const char *s1, const char *s2,
     size_t n);

extern hashval_t filename_hash (const void *s);

extern int filename_eq (const void *s1, const void *s2);

extern int canonical_filename_eq (const char *a, const char *b);
# 176 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2





typedef struct elf_section_list
{
  Elf_Internal_Shdr * hdr;
  struct elf_section_list * next;
} elf_section_list;
# 196 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
typedef unsigned char dump_type;


struct dump_list_entry
{
  char * name;
  dump_type type;
  struct dump_list_entry * next;
};



struct dump_data
{
  dump_type * dump_sects;
  unsigned int num_dump_sects;
};

static struct dump_data cmdline;

static struct dump_list_entry * dump_sects_byname;

char * program_name = "readelf";

static 
# 220 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 220 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           show_name = 
# 220 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       0
# 220 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
static 
# 221 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 221 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_dynamic = 
# 221 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        0
# 221 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;
static 
# 222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_syms = 
# 222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     0
# 222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
static 
# 223 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 223 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_dyn_syms = 
# 223 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         0
# 223 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              ;
static 
# 224 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 224 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_lto_syms = 
# 224 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         0
# 224 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              ;
static 
# 225 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 225 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_reloc = 
# 225 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      0
# 225 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
static 
# 226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_sections = 
# 226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         0
# 226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              ;
static 
# 227 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 227 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_section_groups = 
# 227 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               0
# 227 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    ;
static 
# 228 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 228 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_section_details = 
# 228 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                0
# 228 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ;
static 
# 229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_segments = 
# 229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         0
# 229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              ;
static 
# 230 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 230 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_unwind = 
# 230 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       0
# 230 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
static 
# 231 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 231 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_using_dynamic = 
# 231 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              0
# 231 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ;
static 
# 232 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 232 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_header = 
# 232 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       0
# 232 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
static 
# 233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_dump = 
# 233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     0
# 233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
static 
# 234 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 234 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_version = 
# 234 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        0
# 234 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;
static 
# 235 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 235 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_histogram = 
# 235 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          0
# 235 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
static 
# 236 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 236 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_debugging = 
# 236 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          0
# 236 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
static 
# 237 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 237 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_ctf = 
# 237 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    0
# 237 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
static 
# 238 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 238 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_sframe = 
# 238 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       0
# 238 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
static 
# 239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_arch = 
# 239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     0
# 239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
static 
# 240 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 240 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_notes = 
# 240 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      0
# 240 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
static 
# 241 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 241 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_archive_index = 
# 241 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              0
# 241 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ;
static 
# 242 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 242 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           check_all = 
# 242 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       0
# 242 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
static 
# 243 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 243 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           is_32bit_elf = 
# 243 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          0
# 243 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
static 
# 244 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 244 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           decompress_dumps = 
# 244 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              0
# 244 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ;
static 
# 245 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 245 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_not_show_symbol_truncation = 
# 245 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           0
# 245 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                ;
static 
# 246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           do_demangle = 
# 246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         0
# 246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              ;
static 
# 247 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 247 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           process_links = 
# 247 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           0
# 247 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                ;
static 
# 248 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 248 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           dump_any_debugging = 
# 248 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                0
# 248 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ;
static int demangle_flags = (1 << 1) | (1 << 0);
static int sym_base = 0;

static char *dump_ctf_parent_name;
static char *dump_ctf_symtab_name;
static char *dump_ctf_strtab_name;

struct group_list
{
  struct group_list * next;
  unsigned int section_index;
};

struct group
{
  struct group_list * root;
  unsigned int group_index;
};

typedef struct filedata
{
  const char * file_name;
  
# 271 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 271 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      is_separate;
  FILE * handle;
  uint64_t file_size;
  Elf_Internal_Ehdr file_header;
  uint64_t archive_file_offset;
  uint64_t archive_file_size;

  Elf_Internal_Shdr * section_headers;
  Elf_Internal_Phdr * program_headers;
  char * string_table;
  uint64_t string_table_length;
  uint64_t dynamic_addr;
  uint64_t dynamic_size;
  uint64_t dynamic_nent;
  Elf_Internal_Dyn * dynamic_section;
  Elf_Internal_Shdr * dynamic_strtab_section;
  char * dynamic_strings;
  uint64_t dynamic_strings_length;
  Elf_Internal_Shdr * dynamic_symtab_section;
  uint64_t num_dynamic_syms;
  Elf_Internal_Sym * dynamic_symbols;
  uint64_t version_info[16];
  unsigned int dynamic_syminfo_nent;
  Elf_Internal_Syminfo * dynamic_syminfo;
  uint64_t dynamic_syminfo_offset;
  uint64_t nbuckets;
  uint64_t nchains;
  uint64_t * buckets;
  uint64_t * chains;
  uint64_t ngnubuckets;
  uint64_t ngnuchains;
  uint64_t * gnubuckets;
  uint64_t * gnuchains;
  uint64_t * mipsxlat;
  uint64_t gnusymidx;
  char * program_interpreter;
  uint64_t dynamic_info[37 + 1];
  uint64_t dynamic_info_DT_GNU_HASH;
  uint64_t dynamic_info_DT_MIPS_XHASH;
  elf_section_list * symtab_shndx_list;
  size_t group_count;
  struct group * section_groups;
  struct group ** section_headers_groups;





  struct dump_data dump;
} Filedata;


typedef enum print_mode
{
  HEX,
  HEX_5,
  DEC,
  DEC_5,
  UNSIGNED,
  UNSIGNED_5,
  PREFIX_HEX,
  PREFIX_HEX_5,
  FULL_HEX,
  LONG_HEX,
  OCTAL,
  OCTAL_5
}
print_mode;

typedef enum unicode_display_type
{
  unicode_default = 0,
  unicode_locale,
  unicode_escape,
  unicode_hex,
  unicode_highlight,
  unicode_invalid
} unicode_display_type;

static unicode_display_type unicode_display = unicode_default;

typedef enum
{
  reltype_unknown,
  reltype_rel,
  reltype_rela,
  reltype_relr
} relocation_type;


enum versioned_symbol_info
{
  symbol_undefined,
  symbol_hidden,
  symbol_public
};

static int
fseek64 (FILE *stream, int64_t offset, int whence)
{

  off64_t o = offset;
  if (o != offset)
    {
      
# 375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     (*__errno_location ()) 
# 375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           = 
# 375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             22
# 375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
      return -1;
    }
  return fseeko64 (stream, o, whence);
# 396 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
}

static const char * get_symbol_version_string
  (Filedata *, 
# 399 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              _Bool
# 399 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  , const char *, size_t, unsigned,
   Elf_Internal_Sym *, enum versioned_symbol_info *, unsigned short *);



static inline const char *
section_name (const Filedata *filedata, const Elf_Internal_Shdr *hdr)
{
  return filedata->string_table + hdr->sh_name;
}

static inline 
# 410 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             _Bool

# 411 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
section_name_valid (const Filedata *filedata, const Elf_Internal_Shdr *hdr)
{
  return (hdr != 
# 413 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
   
# 414 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  && filedata->string_table != 
# 414 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
   
# 415 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  && hdr->sh_name < filedata->string_table_length);
}

static inline const char *
section_name_print (const Filedata *filedata, const Elf_Internal_Shdr *hdr)
{
  if (hdr == 
# 421 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 421 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                )
    return gettext ("<none>");
  if (filedata->string_table == 
# 423 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 423 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   )
    return gettext ("<no-strings>");
  if (hdr->sh_name >= filedata->string_table_length)
    return gettext ("<corrupt>");
  return section_name (filedata, hdr);
}



static inline 
# 432 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             _Bool

# 433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
valid_symbol_name (const char *strtab, size_t strtab_size, uint64_t offset)
{
  return strtab != 
# 435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0) 
# 435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       && offset < strtab_size;
}

static inline 
# 438 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             _Bool

# 439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
valid_dynamic_name (const Filedata *filedata, uint64_t offset)
{
  return valid_symbol_name (filedata->dynamic_strings,
       filedata->dynamic_strings_length, offset);
}



static inline const char *
get_dynamic_name (const Filedata *filedata, size_t offset)
{
  return filedata->dynamic_strings + offset;
}
# 473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static void *
get_data (void *var,
   Filedata *filedata,
   uint64_t offset,
   uint64_t size,
   uint64_t nmemb,
   const char *reason)
{
  void * mvar;
  uint64_t amt = size * nmemb;

  if (size == 0 || nmemb == 0)
    return 
# 485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;




  if ((size_t) size != size
      || (size_t) nmemb != nmemb
      || (size_t) amt != amt
      || amt / size != nmemb
      || (size_t) amt + 1 == 0)
    {
      if (reason)
 error (gettext ("Size overflow prevents reading %" 
# 497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       "l" "u" 
# 497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       " elements of size %" 
# 497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       "l" "u" 
# 497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       " for %s\n")
                                            ,
        nmemb, size, reason);
      return 
# 500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }



  if (filedata->archive_file_offset > filedata->file_size
      || offset > filedata->file_size - filedata->archive_file_offset
      || amt > filedata->file_size - filedata->archive_file_offset - offset)
    {
      if (reason)
 error (gettext ("Reading %" 
# 510 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       "l" "u" 
# 510 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       " bytes extends past end of file for %s\n"),
        amt, reason);
      return 
# 512 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 512 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  if (fseek64 (filedata->handle, filedata->archive_file_offset + offset,
        
# 516 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 516 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ))
    {
      if (reason)
 error (gettext ("Unable to seek to %#" 
# 519 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       "l" "x" 
# 519 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       " for %s\n"),
        filedata->archive_file_offset + offset, reason);
      return 
# 521 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 521 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  mvar = var;
  if (mvar == 
# 525 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 525 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 )
    {

      mvar = malloc ((size_t) amt + 1);

      if (mvar == 
# 530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
 {
   if (reason)
     error (gettext ("Out of memory allocating %" 
# 533 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           "l" "u" 
# 533 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           " bytes for %s\n"),
     amt, reason);
   return 
# 535 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         ((void *)0)
# 535 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
 }

      ((char *) mvar)[amt] = '\0';
    }

  if (fread (mvar, (size_t) size, (size_t) nmemb, filedata->handle) != nmemb)
    {
      if (reason)
 error (gettext ("Unable to read in %" 
# 544 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       "l" "u" 
# 544 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       " bytes of %s\n"),
        amt, reason);
      if (mvar != var)
 free (mvar);
      return 
# 548 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 548 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  return mvar;
}




static unsigned int
print_vma (uint64_t vma, print_mode mode)
{
  unsigned int nc = 0;

  switch (mode)
    {
    case FULL_HEX:
      nc = printf ("0x");

    case LONG_HEX:
      if (!is_32bit_elf)
 return nc + printf ("%16.16" 
# 569 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             "l" "x"
# 569 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   , vma);
      return nc + printf ("%8.8" 
# 570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                "l" "x"
# 570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      , vma);

    case DEC_5:
      if (vma <= 99999)
 return printf ("%5" 
# 574 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    "l" "d"
# 574 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          , vma);

    case PREFIX_HEX:
      nc = printf ("0x");

    case HEX:
      return nc + printf ("%" 
# 580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             "l" "x"
# 580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   , vma);

    case PREFIX_HEX_5:
      nc = printf ("0x");

    case HEX_5:
      return nc + printf ("%05" 
# 586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               "l" "x"
# 586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     , vma);

    case DEC:
      return printf ("%" 
# 589 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        "l" "d"
# 589 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              , vma);

    case UNSIGNED:
      return printf ("%" 
# 592 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        "l" "u"
# 592 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              , vma);

    case UNSIGNED_5:
      return printf ("%5" 
# 595 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         "l" "u"
# 595 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               , vma);

    case OCTAL:
      return printf ("%" 
# 598 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        "l" "o"
# 598 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              , vma);

    case OCTAL_5:
      return printf ("%5" 
# 601 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         "l" "o"
# 601 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               , vma);

    default:

      return 0;
    }
}
# 623 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static unsigned int
print_symbol (signed int width, const char * symbol)
{
  
# 626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      extra_padding = 
# 626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      0
# 626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
  
# 627 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 627 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      do_dots = 
# 627 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                0
# 627 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;
  signed int num_printed = 0;

  mbstate_t state;

  unsigned int width_remaining;
  const void * alloced_symbol = 
# 633 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 633 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ;

  if (width < 0)
    {

      width = - width;
      extra_padding = 
# 639 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     1
# 639 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
    }
  else if (width == 0)
    return 0;

  if (do_wide)


    width_remaining = 0x7fffffff;
  else
    {
      width_remaining = width;
      if (! do_not_show_symbol_truncation
   && (int) strlen (symbol) > width)
 {
   width_remaining -= 5;
   if ((int) width_remaining < 0)
     width_remaining = 0;
   do_dots = 
# 657 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 657 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
 }
    }



  memset (& state, 0, sizeof (state));


  if (do_demangle && *symbol)
    {
      const char * res = cplus_demangle (symbol, demangle_flags);

      if (res != 
# 670 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 670 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
 alloced_symbol = symbol = res;
    }

  while (width_remaining)
    {
      size_t n;
      const char c = *symbol++;

      if (c == 0)
 break;

      if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_isprint)))
 {
   putchar (c);
   width_remaining --;
   num_printed ++;
 }
      else if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_iscntrl)))
 {




   if (width_remaining < 2)
     break;

   printf ("^%c", c + 0x40);
   width_remaining -= 2;
   num_printed += 2;
 }
      else if (c == 0x7f)
 {
   if (width_remaining < 5)
     break;
   printf ("<DEL>");
   width_remaining -= 5;
   num_printed += 5;
 }
      else if (unicode_display != unicode_locale
        && unicode_display != unicode_default)
 {

   unsigned char bytes[4];
   
# 714 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  _Bool 
# 714 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                is_utf8;
   unsigned int nbytes;

   bytes[0] = c;

   if (bytes[0] < 0xc0)
     {
       nbytes = 1;
       is_utf8 = 
# 722 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                0
# 722 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;
     }
   else
     {
       bytes[1] = *symbol++;

       if ((bytes[1] & 0xc0) != 0x80)
  {
    is_utf8 = 
# 730 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 730 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;



    --symbol;
    nbytes = 1;
  }
       else if ((bytes[0] & 0x20) == 0)
  {
    is_utf8 = 
# 739 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 739 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    nbytes = 2;
  }
       else
  {
    bytes[2] = *symbol++;

    if ((bytes[2] & 0xc0) != 0x80)
      {
        is_utf8 = 
# 748 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 0
# 748 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;
        symbol -= 2;
        nbytes = 1;
      }
    else if ((bytes[0] & 0x10) == 0)
      {
        is_utf8 = 
# 754 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 1
# 754 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;
        nbytes = 3;
      }
    else
      {
        bytes[3] = *symbol++;

        nbytes = 4;

        if ((bytes[3] & 0xc0) != 0x80)
   {
     is_utf8 = 
# 765 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              0
# 765 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
     symbol -= 3;
     nbytes = 1;
   }
        else
   is_utf8 = 
# 770 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 770 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
      }
  }
     }

   if (unicode_display == unicode_invalid)
     is_utf8 = 
# 776 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              0
# 776 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;

   if (unicode_display == unicode_hex || ! is_utf8)
     {
       unsigned int i;

       if (width_remaining < (nbytes * 2) + 2)
  break;

       putchar (is_utf8 ? '<' : '{');
       printf ("0x");
       for (i = 0; i < nbytes; i++)
  printf ("%02x", bytes[i]);
       putchar (is_utf8 ? '>' : '}');
     }
   else
     {
       if (unicode_display == unicode_highlight && isatty (1))
  printf ("\x1B[31;47m");

       switch (nbytes)
  {
  case 2:
    if (width_remaining < 6)
      break;
    printf ("\\u%02x%02x",
     (bytes[0] & 0x1c) >> 2,
     ((bytes[0] & 0x03) << 6) | (bytes[1] & 0x3f));
    break;
  case 3:
    if (width_remaining < 6)
      break;
    printf ("\\u%02x%02x",
     ((bytes[0] & 0x0f) << 4) | ((bytes[1] & 0x3c) >> 2),
     ((bytes[1] & 0x03) << 6) | (bytes[2] & 0x3f));
    break;
  case 4:
    if (width_remaining < 8)
      break;
    printf ("\\u%02x%02x%02x",
     ((bytes[0] & 0x07) << 6) | ((bytes[1] & 0x3c) >> 2),
     ((bytes[1] & 0x03) << 6) | ((bytes[2] & 0x3c) >> 2),
     ((bytes[2] & 0x03) << 6) | (bytes[3] & 0x3f));

    break;
  default:

    break;
  }

       if (unicode_display == unicode_highlight && isatty (1))
  printf ("\033[0m");
     }

   if (bytes[nbytes - 1] == 0)
     break;
 }
      else
 {

   wchar_t w;


   printf ("%.1s", symbol - 1);
   width_remaining --;
   num_printed ++;





   n = mbrtowc (& w, symbol - 1, 
# 847 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                (__ctype_get_mb_cur_max ())
# 847 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          , & state);



   if (n != (size_t) -1 && n != (size_t) -2 && n > 0)
     symbol += (n - 1);
 }
    }

  if (do_dots)
    num_printed += printf ("[...]");

  if (extra_padding && num_printed < width)
    {

      printf ("%-*s", width - num_printed, " ");
      num_printed = width;
    }

  free ((void *) alloced_symbol);
  return num_printed;
}





static const char *
printable_section_name (Filedata * filedata, const Elf_Internal_Shdr * sec)
{

  static char sec_name_buf [256 + 1];
  const char * name = section_name_print (filedata, sec);
  char * buf = sec_name_buf;
  char c;
  unsigned int remaining = 256;

  while ((c = * name ++) != 0)
    {
      if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_iscntrl)))
 {
   if (remaining < 2)
     break;

   * buf ++ = '^';
   * buf ++ = c + 0x40;
   remaining -= 2;
 }
      else if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_isprint)))
 {
   * buf ++ = c;
   remaining -= 1;
 }
      else
 {
   static char hex[17] = "0123456789ABCDEF";

   if (remaining < 4)
     break;
   * buf ++ = '<';
   * buf ++ = hex[(c & 0xf0) >> 4];
   * buf ++ = hex[c & 0x0f];
   * buf ++ = '>';
   remaining -= 4;
 }

      if (remaining == 0)
 break;
    }

  * buf = 0;
  return sec_name_buf;
}

static const char *
printable_section_name_from_index (Filedata *filedata, size_t ndx)
{
  if (ndx >= filedata->file_header.e_shnum)
    return gettext ("<corrupt>");

  return printable_section_name (filedata, filedata->section_headers + ndx);
}



static Elf_Internal_Shdr *
find_section (Filedata * filedata, const char * name)
{
  unsigned int i;

  if (filedata->section_headers == 
# 937 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 937 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    return 
# 938 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 938 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  for (i = 0; i < filedata->file_header.e_shnum; i++)
    if (section_name_valid (filedata, filedata->section_headers + i)
 && (strcmp ((section_name (filedata, filedata->section_headers + i)), (name)) == 0)
         )
      return filedata->section_headers + i;

  return 
# 946 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 946 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}




static Elf_Internal_Shdr *
find_section_by_address (Filedata * filedata, uint64_t addr)
{
  unsigned int i;

  if (filedata->section_headers == 
# 957 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 957 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    return 
# 958 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 958 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  for (i = 0; i < filedata->file_header.e_shnum; i++)
    {
      Elf_Internal_Shdr *sec = filedata->section_headers + i;

      if (addr >= sec->sh_addr && addr < sec->sh_addr + sec->sh_size)
 return sec;
    }

  return 
# 968 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 968 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static Elf_Internal_Shdr *
find_section_by_type (Filedata * filedata, unsigned int type)
{
  unsigned int i;

  if (filedata->section_headers == 
# 976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    return 
# 977 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 977 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  for (i = 0; i < filedata->file_header.e_shnum; i++)
    {
      Elf_Internal_Shdr *sec = filedata->section_headers + i;

      if (sec->sh_type == type)
 return sec;
    }

  return 
# 987 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 987 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}




static Elf_Internal_Shdr *
find_section_in_set (Filedata * filedata, const char * name, unsigned int * set)
{
  unsigned int i;

  if (filedata->section_headers == 
# 998 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 998 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    return 
# 999 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 999 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (set != 
# 1001 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 1001 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                )
    {
      while ((i = *set++) > 0)
 {

   if (i >= filedata->file_header.e_shnum)
     continue;

   if (section_name_valid (filedata, filedata->section_headers + i)
       && (strcmp ((section_name (filedata, filedata->section_headers + i)), (name)) == 0)
        )
     return filedata->section_headers + i;
 }
    }

  return find_section (filedata, name);
}





static inline 
# 1023 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             _Bool

# 1024 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_ia64_vms (Filedata * filedata)
{
  return filedata->file_header.e_machine == 50
    && filedata->file_header.e_ident[7] == 13;
}



static 
# 1032 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 1033 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
guess_is_rela (unsigned int e_machine)
{
  switch (e_machine)
    {

    case 3:
    case 6:
    case 19:
    case 40:
    case 85:
    case 0x7650:
    case 0x5aa5:
    case 8:
    case 10:
    case 0x9041:
    case 135:
    case 115:
    case 250:
    case 247:
      return 
# 1052 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 1052 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;


    case 4:
    case 7:
    case 183:
    case 0x1223:
    case 0x9026:
    case 113:
    case 45:
    case 93:
    case 195:
    case 255:
    case 253:
    case 83:
    case 0x1057:
    case 106:
    case 177:
    case 76:
    case 114:
    case 252:
    case 86:
    case 0x7676:
    case 84:
    case 222:
    case 0x3330:
    case 0x5441:
    case 48:
    case 46:
    case 47:
    case 50:
    case 101:
    case 0x8217:
    case 0xFEBA:
    case 138:
    case 0xFEB0:
    case 120:
    case 88:
    case 39:
    case 0xF00D:
    case 174:
    case 80:
    case 90:
    case 0xdead:
    case 89:
    case 0xbeef:
    case 223:
    case 105:
    case 0x1059:
    case 0x2530:
    case 167:
    case 0xFEBB:
    case 92:
    case 21:
    case 20:
    case 144:
    case 243:
    case 197:
    case 173:
    case 22:
    case 0xa390:
    case 42:
    case 2:
    case 18:
    case 43:
    case 23:
    case 140:
    case 191:
    case 188:
    case 36:
    case 87:
    case 0x9080:
    case 75:
    case 221:
    case 62:
    case 180:
    case 181:
    case 0xad45:
    case 94:
    case 0xabc7:
    case 189:
    case 0xbaab:
    case 0x4157:
      return 
# 1135 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 1135 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

    case 72:
    case 71:
    case 70:
    case 69:
    case 66:
    case 59:
    case 54:
    case 56:
    case 57:
    case 55:
    case 60:
    case 74:
    case 68:
    case 67:
    case 58:
    case 73:
    case 61:
    default:
      warn (gettext ("Don't know about relocations on this machine architecture\n"));
      return 
# 1156 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 1156 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}







static 
# 1166 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 1167 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
slurp_rela_relocs (Filedata *filedata,
     uint64_t rel_offset,
     uint64_t rel_size,
     Elf_Internal_Rela **relasp,
     uint64_t *nrelasp)
{
  Elf_Internal_Rela * relas;
  uint64_t nrelas;
  unsigned int i;

  if (is_32bit_elf)
    {
      Elf32_External_Rela * erelas;

      erelas = (Elf32_External_Rela *) get_data (
# 1181 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                ((void *)0)
# 1181 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    , filedata, rel_offset, 1,
                                                 rel_size, gettext ("32-bit relocation data"));
      if (!erelas)
 return 
# 1184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 1184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      nrelas = rel_size / sizeof (Elf32_External_Rela);

      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
                                             sizeof (Elf_Internal_Rela));

      if (relas == 
# 1191 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 1191 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
 {
   free (erelas);
   error (gettext ("out of memory parsing relocs\n"));
   return 
# 1195 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 1195 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      for (i = 0; i < nrelas; i++)
 {
   relas[i].r_offset = byte_get (erelas[i].r_offset, sizeof (erelas[i].r_offset));
   relas[i].r_info = byte_get (erelas[i].r_info, sizeof (erelas[i].r_info));
   relas[i].r_addend = byte_get_signed (erelas[i].r_addend, sizeof (erelas[i].r_addend));
 }

      free (erelas);
    }
  else
    {
      Elf64_External_Rela * erelas;

      erelas = (Elf64_External_Rela *) get_data (
# 1211 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                ((void *)0)
# 1211 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    , filedata, rel_offset, 1,
                                                 rel_size, gettext ("64-bit relocation data"));
      if (!erelas)
 return 
# 1214 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 1214 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      nrelas = rel_size / sizeof (Elf64_External_Rela);

      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
                                             sizeof (Elf_Internal_Rela));

      if (relas == 
# 1221 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 1221 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
 {
   free (erelas);
   error (gettext ("out of memory parsing relocs\n"));
   return 
# 1225 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 1225 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      for (i = 0; i < nrelas; i++)
 {
   relas[i].r_offset = byte_get (erelas[i].r_offset, sizeof (erelas[i].r_offset));
   relas[i].r_info = byte_get (erelas[i].r_info, sizeof (erelas[i].r_info));
   relas[i].r_addend = byte_get_signed (erelas[i].r_addend, sizeof (erelas[i].r_addend));

   if (filedata->file_header.e_machine == 8
       && filedata->file_header.e_ident[5] != 2)
     {





       uint64_t inf = relas[i].r_info;
       inf = (((inf & 0xffffffff) << 32)
        | ((inf >> 56) & 0xff)
        | ((inf >> 40) & 0xff00)
        | ((inf >> 24) & 0xff0000)
        | ((inf >> 8) & 0xff000000));
       relas[i].r_info = inf;
     }
 }

      free (erelas);
    }

  *relasp = relas;
  *nrelasp = nrelas;
  return 
# 1257 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 1257 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}







static 
# 1266 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 1267 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
slurp_rel_relocs (Filedata *filedata,
    uint64_t rel_offset,
    uint64_t rel_size,
    Elf_Internal_Rela **relsp,
    uint64_t *nrelsp)
{
  Elf_Internal_Rela * rels;
  uint64_t nrels;
  unsigned int i;

  if (is_32bit_elf)
    {
      Elf32_External_Rel * erels;

      erels = (Elf32_External_Rel *) get_data (
# 1281 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              ((void *)0)
# 1281 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  , filedata, rel_offset, 1,
                                               rel_size, gettext ("32-bit relocation data"));
      if (!erels)
 return 
# 1284 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 1284 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      nrels = rel_size / sizeof (Elf32_External_Rel);

      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));

      if (rels == 
# 1290 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 1290 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
 {
   free (erels);
   error (gettext ("out of memory parsing relocs\n"));
   return 
# 1294 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 1294 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      for (i = 0; i < nrels; i++)
 {
   rels[i].r_offset = byte_get (erels[i].r_offset, sizeof (erels[i].r_offset));
   rels[i].r_info = byte_get (erels[i].r_info, sizeof (erels[i].r_info));
   rels[i].r_addend = 0;
 }

      free (erels);
    }
  else
    {
      Elf64_External_Rel * erels;

      erels = (Elf64_External_Rel *) get_data (
# 1310 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              ((void *)0)
# 1310 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  , filedata, rel_offset, 1,
                                               rel_size, gettext ("64-bit relocation data"));
      if (!erels)
 return 
# 1313 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 1313 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      nrels = rel_size / sizeof (Elf64_External_Rel);

      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));

      if (rels == 
# 1319 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 1319 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
 {
   free (erels);
   error (gettext ("out of memory parsing relocs\n"));
   return 
# 1323 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 1323 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      for (i = 0; i < nrels; i++)
 {
   rels[i].r_offset = byte_get (erels[i].r_offset, sizeof (erels[i].r_offset));
   rels[i].r_info = byte_get (erels[i].r_info, sizeof (erels[i].r_info));
   rels[i].r_addend = 0;

   if (filedata->file_header.e_machine == 8
       && filedata->file_header.e_ident[5] != 2)
     {





       uint64_t inf = rels[i].r_info;
       inf = (((inf & 0xffffffff) << 32)
       | ((inf >> 56) & 0xff)
       | ((inf >> 40) & 0xff00)
       | ((inf >> 24) & 0xff0000)
       | ((inf >> 8) & 0xff000000));
       rels[i].r_info = inf;
     }
 }

      free (erels);
    }

  *relsp = rels;
  *nrelsp = nrels;
  return 
# 1355 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 1355 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 1358 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 1359 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
slurp_relr_relocs (Filedata *filedata,
     uint64_t relr_offset,
     uint64_t relr_size,
     uint64_t **relrsp,
     uint64_t *nrelrsp)
{
  void *relrs;
  size_t size = 0, nentries, i;
  uint64_t base = 0, addr, entry;

  relrs = get_data (
# 1369 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 1369 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       , filedata, relr_offset, 1, relr_size,
      gettext ("RELR relocation data"));
  if (!relrs)
    return 
# 1372 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 1372 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (is_32bit_elf)
    nentries = relr_size / sizeof (Elf32_External_Relr);
  else
    nentries = relr_size / sizeof (Elf64_External_Relr);
  for (i = 0; i < nentries; i++)
    {
      if (is_32bit_elf)
 entry = byte_get (((Elf32_External_Relr *)relrs)[i].r_data, sizeof (((Elf32_External_Relr *)relrs)[i].r_data));
      else
 entry = byte_get (((Elf64_External_Relr *)relrs)[i].r_data, sizeof (((Elf64_External_Relr *)relrs)[i].r_data));
      if ((entry & 1) == 0)
 size++;
      else
 while ((entry >>= 1) != 0)
   if ((entry & 1) == 1)
     size++;
    }

  *relrsp = malloc (size * sizeof (**relrsp));
  if (*relrsp == 
# 1393 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 1393 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
    {
      free (relrs);
      error (gettext ("out of memory parsing relocs\n"));
      return 
# 1397 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 1397 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  size = 0;
  for (i = 0; i < nentries; i++)
    {
      const uint64_t entry_bytes = is_32bit_elf ? 4 : 8;

      if (is_32bit_elf)
 entry = byte_get (((Elf32_External_Relr *)relrs)[i].r_data, sizeof (((Elf32_External_Relr *)relrs)[i].r_data));
      else
 entry = byte_get (((Elf64_External_Relr *)relrs)[i].r_data, sizeof (((Elf64_External_Relr *)relrs)[i].r_data));
      if ((entry & 1) == 0)
 {
   (*relrsp)[size++] = entry;
   base = entry + entry_bytes;
 }
      else
 {
   for (addr = base; (entry >>= 1) != 0; addr += entry_bytes)
     if ((entry & 1) != 0)
       (*relrsp)[size++] = addr;
   base += entry_bytes * (entry_bytes * 8 - 1);
 }
    }

  *nrelrsp = size;
  free (relrs);
  return 
# 1425 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 1425 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}



static unsigned int
get_reloc_type (Filedata * filedata, uint64_t reloc_info)
{
  if (is_32bit_elf)
    return ((reloc_info) & 0xff);

  switch (filedata->file_header.e_machine)
    {
    case 8:

      return ((reloc_info) & 0xff);

    case 43:
      return ((reloc_info) & 0xff);

    default:
      return ((reloc_info) & 0xffffffff);
    }
}



static uint64_t
get_reloc_symindex (uint64_t reloc_info)
{
  return is_32bit_elf ? ((reloc_info) >> 8) : ((reloc_info) >> 32);
}

static inline 
# 1458 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             _Bool

# 1459 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
uses_msp430x_relocs (Filedata * filedata)
{
  return
    filedata->file_header.e_machine == 105

    && (((filedata->file_header.e_flags & 0xff) == 45)

 || (filedata->file_header.e_ident[7] == 0));
}




static 
# 1472 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 1473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_relocations (Filedata *filedata,
    uint64_t rel_offset,
    uint64_t rel_size,
    Elf_Internal_Sym *symtab,
    uint64_t nsyms,
    char *strtab,
    uint64_t strtablen,
    relocation_type rel_type,
    
# 1481 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
   _Bool 
# 1481 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        is_dynsym)
{
  size_t i;
  Elf_Internal_Rela * rels;
  
# 1485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 1485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 1485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 1485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (rel_type == reltype_unknown)
    rel_type = guess_is_rela (filedata->file_header.e_machine) ? reltype_rela : reltype_rel;

  if (rel_type == reltype_rela)
    {
      if (!slurp_rela_relocs (filedata, rel_offset, rel_size, &rels, &rel_size))
 return 
# 1493 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 1493 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
    }
  else if (rel_type == reltype_rel)
    {
      if (!slurp_rel_relocs (filedata, rel_offset, rel_size, &rels, &rel_size))
 return 
# 1498 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 1498 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
    }
  else if (rel_type == reltype_relr)
    {
      uint64_t * relrs;
      const char *format
 = is_32bit_elf ? "%08" 
# 1504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       "l" "x" 
# 1504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              "\n" : "%016" 
# 1504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                            "l" "x" 
# 1504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   "\n";

      if (!slurp_relr_relocs (filedata, rel_offset, rel_size, &relrs,
         &rel_size))
 return 
# 1508 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 1508 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      printf (ngettext ("  %" 
# 1510 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             "l" "u" 
# 1510 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    " offset\n",
   "  %" 
# 1511 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        "l" "u" 
# 1511 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               " offsets\n", rel_size),
       rel_size);
      for (i = 0; i < rel_size; i++)
 printf (format, relrs[i]);
      free (relrs);
      return 
# 1516 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 1516 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  if (is_32bit_elf)
    {
      if (rel_type == reltype_rela)
 {
   if (do_wide)
     printf (gettext (" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"));
   else
     printf (gettext (" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"));
 }
      else
 {
   if (do_wide)
     printf (gettext (" Offset     Info    Type                Sym. Value  Symbol's Name\n"));
   else
     printf (gettext (" Offset     Info    Type            Sym.Value  Sym. Name\n"));
 }
    }
  else
    {
      if (rel_type == reltype_rela)
 {
   if (do_wide)
     printf (gettext ("    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"));
   else
     printf (gettext ("  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"));
 }
      else
 {
   if (do_wide)
     printf (gettext ("    Offset             Info             Type               Symbol's Value  Symbol's Name\n"));
   else
     printf (gettext ("  Offset          Info           Type           Sym. Value    Sym. Name\n"));
 }
    }

  for (i = 0; i < rel_size; i++)
    {
      const char * rtype;
      uint64_t offset;
      uint64_t inf;
      uint64_t symtab_index;
      uint64_t type;

      offset = rels[i].r_offset;
      inf = rels[i].r_info;

      type = get_reloc_type (filedata, inf);
      symtab_index = get_reloc_symindex (inf);

      if (is_32bit_elf)
 {
   printf ("%8.8lx  %8.8lx ",
    (unsigned long) offset & 0xffffffff,
    (unsigned long) inf & 0xffffffff);
 }
      else
 {
   printf (do_wide
    ? "%16.16" 
# 1577 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              "l" "x" 
# 1577 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     "  %16.16" 
# 1577 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                "l" "x" 
# 1577 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       " "
    : "%12.12" 
# 1578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              "l" "x" 
# 1578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     "  %12.12" 
# 1578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                "l" "x" 
# 1578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       " ",
    offset, inf);
 }

      switch (filedata->file_header.e_machine)
 {
 default:
   rtype = 
# 1585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 1585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
   break;

 case 183:
   rtype = elf_aarch64_reloc_type (type);
   break;

 case 88:
 case 0x9041:
   rtype = elf_m32r_reloc_type (type);
   break;

 case 3:
 case 6:
   rtype = elf_i386_reloc_type (type);
   break;

 case 70:
 case 53:
   rtype = elf_m68hc11_reloc_type (type);
   break;

 case 0x4DEF:
   rtype = elf_s12z_reloc_type (type);
   break;

 case 4:
   rtype = elf_m68k_reloc_type (type);
   break;

 case 19:
   rtype = elf_i960_reloc_type (type);
   break;

 case 83:
 case 0x1057:
   rtype = elf_avr_reloc_type (type);
   break;

 case 11:
 case 18:
 case 43:
 case 2:
   rtype = elf_sparc_reloc_type (type);
   break;

 case 23:
   rtype = elf_spu_reloc_type (type);
   break;

 case 36:
   rtype = v800_reloc_type (type);
   break;
 case 87:
 case 0x9080:
   rtype = v850_reloc_type (type);
   break;

 case 85:
 case 0x7650:
   rtype = elf_d10v_reloc_type (type);
   break;

 case 86:
 case 0x7676:
   rtype = elf_d30v_reloc_type (type);
   break;

 case 0x5aa5:
   rtype = elf_dlx_reloc_type (type);
   break;

 case 42:
   rtype = elf_sh_reloc_type (type);
   break;

 case 89:
 case 0xbeef:
   rtype = elf_mn10300_reloc_type (type);
   break;

 case 90:
 case 0xdead:
   rtype = elf_mn10200_reloc_type (type);
   break;

 case 84:
 case 0x3330:
   rtype = elf_fr30_reloc_type (type);
   break;

 case 0x5441:
   rtype = elf_frv_reloc_type (type);
   break;

 case 252:
   rtype = elf_csky_reloc_type (type);
   break;

 case 222:
   rtype = elf_ft32_reloc_type (type);
   break;

 case 39:
   rtype = elf_mcore_reloc_type (type);
   break;

 case 80:
   rtype = elf_mmix_reloc_type (type);
   break;

 case 223:
   rtype = elf_moxie_reloc_type (type);
   break;

 case 105:
   if (uses_msp430x_relocs (filedata))
     {
       rtype = elf_msp430x_reloc_type (type);
       break;
     }

 case 0x1059:
   rtype = elf_msp430_reloc_type (type);
   break;

 case 167:
   rtype = elf_nds32_reloc_type (type);
   break;

 case 20:
   rtype = elf_ppc_reloc_type (type);
   break;

 case 21:
   rtype = elf_ppc64_reloc_type (type);
   break;

 case 8:
 case 10:
   rtype = elf_mips_reloc_type (type);
   break;

 case 243:
   rtype = elf_riscv_reloc_type (type);
   break;

 case 0x9026:
   rtype = elf_alpha_reloc_type (type);
   break;

 case 40:
   rtype = elf_arm_reloc_type (type);
   break;

 case 45:
 case 93:
 case 195:
 case 255:
 case 253:
   rtype = elf_arc_reloc_type (type);
   break;

 case 15:
   rtype = elf_hppa_reloc_type (type);
   break;

 case 46:
 case 47:
 case 48:
   rtype = elf_h8_reloc_type (type);
   break;

 case 92:
   rtype = elf_or1k_reloc_type (type);
   break;

 case 91:
 case 99:
   rtype = elf_pj_reloc_type (type);
   break;
 case 50:
   rtype = elf_ia64_reloc_type (type);
   break;

 case 76:
   rtype = elf_cris_reloc_type (type);
   break;

 case 7:
   rtype = elf_i860_reloc_type (type);
   break;

 case 62:
 case 180:
 case 181:
   rtype = elf_x86_64_reloc_type (type);
   break;

 case 9:
   rtype = i370_reloc_type (type);
   break;

 case 0xa390:
 case 22:
   rtype = elf_s390_reloc_type (type);
   break;

 case 135:
   rtype = elf_score_reloc_type (type);
   break;

 case 0xad45:
   rtype = elf_xstormy16_reloc_type (type);
   break;

 case 114:
   rtype = elf_crx_reloc_type (type);
   break;

 case 75:
   rtype = elf_vax_reloc_type (type);
   break;

 case 221:
   rtype = elf_visium_reloc_type (type);
   break;

        case 247:
          rtype = elf_bpf_reloc_type (type);
          break;

 case 0x1223:
   rtype = elf_epiphany_reloc_type (type);
   break;

 case 101:
 case 0x8217:
   rtype = elf_ip2k_reloc_type (type);
   break;

 case 0xFEBA:
   rtype = elf_iq2000_reloc_type (type);
   break;

 case 0xabc7:
 case 94:
   rtype = elf_xtensa_reloc_type (type);
   break;

 case 138:
   rtype = elf_lm32_reloc_type (type);
   break;

 case 0xFEB0:
 case 120:
   rtype = elf_m32c_reloc_type (type);
   break;

 case 0x2530:
   rtype = elf_mt_reloc_type (type);
   break;

 case 106:
   rtype = elf_bfin_reloc_type (type);
   break;

 case 0xF00D:
   rtype = elf_mep_reloc_type (type);
   break;

 case 177:
   rtype = elf_cr16_reloc_type (type);
   break;

 case 189:
 case 0xbaab:
   rtype = elf_microblaze_reloc_type (type);
   break;

 case 197:
   rtype = elf_rl78_reloc_type (type);
   break;

 case 173:
   rtype = elf_rx_reloc_type (type);
   break;

 case 174:
   rtype = elf_metag_reloc_type (type);
   break;

 case 140:
   rtype = elf_tic6x_reloc_type (type);
   break;

 case 191:
   rtype = elf_tilegx_reloc_type (type);
   break;

 case 188:
   rtype = elf_tilepro_reloc_type (type);
   break;

 case 0x4157:
   rtype = elf_wasm32_reloc_type (type);
   break;

 case 115:
   rtype = elf_xgate_reloc_type (type);
   break;

 case 113:
   rtype = elf_nios2_reloc_type (type);
   break;

 case 144:
   rtype = elf_pru_reloc_type (type);
   break;

 case 250:
   if ((((filedata->file_header.e_flags) >> 8) & 0xFFFF) == 0x3200)
     rtype = elf_nfp3200_reloc_type (type);
   else
     rtype = elf_nfp_reloc_type (type);
   break;

 case 220:
   rtype = elf_z80_reloc_type (type);
   break;

 case 258:
   rtype = elf_loongarch_reloc_type (type);
   break;

 case 224:
   rtype = elf_amdgpu_reloc_type (type);
   break;
 }

      if (rtype == 
# 1925 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 1925 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
 printf (gettext ("unrecognized: %-7lx"), (unsigned long) type & 0xffffffff);
      else
 printf (do_wide ? "%-22s" : "%-17.17s", rtype);

      if (filedata->file_header.e_machine == 0x9026
   && rtype != 
# 1931 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
   
# 1932 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  && (strcmp ((rtype), ("R_ALPHA_LITUSE")) == 0)
   && rel_type == reltype_rela)
 {
   switch (rels[i].r_addend)
     {
     case 0: rtype = "ADDR"; break;
     case 1: rtype = "BASE"; break;
     case 2: rtype = "BYTOFF"; break;
     case 3: rtype = "JSR"; break;
     case 4: rtype = "TLSGD"; break;
     case 5: rtype = "TLSLDM"; break;
     case 6: rtype = "JSRDIRECT"; break;
     default: rtype = 
# 1944 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 1944 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
     }

   if (rtype)
     printf (" (%s)", rtype);
   else
     {
       putchar (' ');
       printf (gettext ("<unknown addend: %" 
# 1952 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              "l" "x" 
# 1952 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ">"),
        rels[i].r_addend);
       res = 
# 1954 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 1954 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
     }
 }
      else if (symtab_index)
 {
   if (symtab == 
# 1959 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0) 
# 1959 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     || symtab_index >= nsyms)
     {
       error (gettext (" bad symbol index: %08lx in reloc\n"),
       (unsigned long) symtab_index);
       res = 
# 1963 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 1963 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
     }
   else
     {
       Elf_Internal_Sym * psym;
       const char * version_string;
       enum versioned_symbol_info sym_info;
       unsigned short vna_other;

       psym = symtab + symtab_index;

       version_string
  = get_symbol_version_string (filedata, is_dynsym,
          strtab, strtablen,
          symtab_index,
          psym,
          &sym_info,
          &vna_other);

       printf (" ");

       if (((psym->st_info) & 0xF) == 10)
  {
    const char * name;
    unsigned int len;
    unsigned int width = is_32bit_elf ? 8 : 14;
# 2000 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
    if (strtab == 
# 2000 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
        
# 2001 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       || psym->st_name == 0
        || psym->st_name >= strtablen)
      name = "??";
    else
      name = strtab + psym->st_name;

    len = print_symbol (width, name);
    if (version_string)
      printf (sym_info == symbol_public ? "@@%s" : "@%s",
       version_string);
    printf ("()%-*s", len <= width ? (width + 1) - len : 1, " ");
  }
       else
  {
    print_vma (psym->st_value, LONG_HEX);

    printf (is_32bit_elf ? "   " : " ");
  }

       if (psym->st_name == 0)
  {
    const char * sec_name = "<null>";
    char name_buf[40];

    if (((psym->st_info) & 0xF) == 3)
      {
        if (psym->st_shndx < filedata->file_header.e_shnum
     && filedata->section_headers != 
# 2028 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    ((void *)0)
# 2028 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        )
   sec_name = section_name_print (filedata,
             filedata->section_headers
             + psym->st_shndx);
        else if (psym->st_shndx == (-0xFu))
   sec_name = "ABS";
        else if (psym->st_shndx == (-0xEu))
   sec_name = "COMMON";
        else if ((filedata->file_header.e_machine == 8
    && psym->st_shndx == ((-0x100u) + 3))
          || (filedata->file_header.e_machine == 140
       && psym->st_shndx == (-0x100u)))
   sec_name = "SCOMMON";
        else if (filedata->file_header.e_machine == 8
          && psym->st_shndx == ((-0x100u) + 4))
   sec_name = "SUNDEF";
        else if ((filedata->file_header.e_machine == 62
    || filedata->file_header.e_machine == 180
    || filedata->file_header.e_machine == 181)
          && psym->st_shndx == ((-0x100u) + 2))
   sec_name = "LARGE_COMMON";
        else if (filedata->file_header.e_machine == 50
          && filedata->file_header.e_ident[7] == 1
          && psym->st_shndx == (-0x100u))
   sec_name = "ANSI_COM";
        else if (is_ia64_vms (filedata)
          && psym->st_shndx == (-0xE0u))
   sec_name = "VMS_SYMVEC";
        else
   {
     sprintf (name_buf, "<section 0x%x>",
       (unsigned int) psym->st_shndx);
     sec_name = name_buf;
   }
      }
    print_symbol (22, sec_name);
  }
       else if (strtab == 
# 2065 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 2065 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             )
  printf (gettext ("<string table index: %3ld>"), psym->st_name);
       else if (psym->st_name >= strtablen)
  {
    error (gettext ("<corrupt string table index: %3ld>\n"),
    psym->st_name);
    res = 
# 2071 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 2071 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
  }
       else
  {
    print_symbol (22, strtab + psym->st_name);
    if (version_string)
      printf (sym_info == symbol_public ? "@@%s" : "@%s",
       version_string);
  }

       if (rel_type == reltype_rela)
  {
    uint64_t off = rels[i].r_addend;

    if ((int64_t) off < 0)
      printf (" - %" 
# 2086 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    "l" "x"
# 2086 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          , -off);
    else
      printf (" + %" 
# 2088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    "l" "x"
# 2088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          , off);
  }
     }
 }
      else if (rel_type == reltype_rela)
 {
   uint64_t off = rels[i].r_addend;

   printf ("%*c", is_32bit_elf ? 12 : 20, ' ');
   if ((int64_t) off < 0)
     printf ("-%" 
# 2098 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 "l" "x"
# 2098 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       , -off);
   else
     printf ("%" 
# 2100 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                "l" "x"
# 2100 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      , off);
 }

      if (filedata->file_header.e_machine == 43
   && rtype != 
# 2104 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
   
# 2105 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  && (strcmp ((rtype), ("R_SPARC_OLO10")) == 0))
 printf (" + %" 
# 2106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               "l" "x"
# 2106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     , (((bfd_signed_vma)(((inf) & 0xffffffff) >> 8) ^ 0x800000) - 0x800000));

      putchar ('\n');

      if (! is_32bit_elf && filedata->file_header.e_machine == 8)
 {
   uint64_t type2 = (((inf) >> 8) & 0xff);
   uint64_t type3 = (((inf) >> 16) & 0xff);
   const char * rtype2 = elf_mips_reloc_type (type2);
   const char * rtype3 = elf_mips_reloc_type (type3);

   printf ("                    Type2: ");

   if (rtype2 == 
# 2119 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 2119 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     printf (gettext ("unrecognized: %-7lx"),
      (unsigned long) type2 & 0xffffffff);
   else
     printf ("%-17.17s", rtype2);

   printf ("\n                    Type3: ");

   if (rtype3 == 
# 2127 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 2127 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     printf (gettext ("unrecognized: %-7lx"),
      (unsigned long) type3 & 0xffffffff);
   else
     printf ("%-17.17s", rtype3);

   putchar ('\n');
 }
    }

  free (rels);

  return res;
}

static const char *
get_aarch64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 1): return "AARCH64_BTI_PLT";
    case (0x70000000 + 3): return "AARCH64_PAC_PLT";
    case (0x70000000 + 5): return "AARCH64_VARIANT_PCS";
    default:
      return 
# 2151 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 2151 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
}

static const char *
get_mips_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000001: return "MIPS_RLD_VERSION";
    case 0x70000002: return "MIPS_TIME_STAMP";
    case 0x70000003: return "MIPS_ICHECKSUM";
    case 0x70000004: return "MIPS_IVERSION";
    case 0x70000005: return "MIPS_FLAGS";
    case 0x70000006: return "MIPS_BASE_ADDRESS";
    case 0x70000007: return "MIPS_MSYM";
    case 0x70000008: return "MIPS_CONFLICT";
    case 0x70000009: return "MIPS_LIBLIST";
    case 0x7000000a: return "MIPS_LOCAL_GOTNO";
    case 0x7000000b: return "MIPS_CONFLICTNO";
    case 0x70000010: return "MIPS_LIBLISTNO";
    case 0x70000011: return "MIPS_SYMTABNO";
    case 0x70000012: return "MIPS_UNREFEXTNO";
    case 0x70000013: return "MIPS_GOTSYM";
    case 0x70000014: return "MIPS_HIPAGENO";
    case 0x70000016: return "MIPS_RLD_MAP";
    case 0x70000035: return "MIPS_RLD_MAP_REL";
    case 0x70000017: return "MIPS_DELTA_CLASS";
    case 0x70000018: return "MIPS_DELTA_CLASS_NO";
    case 0x70000019: return "MIPS_DELTA_INSTANCE";
    case 0x7000001a: return "MIPS_DELTA_INSTANCE_NO";
    case 0x7000001b: return "MIPS_DELTA_RELOC";
    case 0x7000001c: return "MIPS_DELTA_RELOC_NO";
    case 0x7000001d: return "MIPS_DELTA_SYM";
    case 0x7000001e: return "MIPS_DELTA_SYM_NO";
    case 0x70000020: return "MIPS_DELTA_CLASSSYM";
    case 0x70000021: return "MIPS_DELTA_CLASSSYM_NO";
    case 0x70000022: return "MIPS_CXX_FLAGS";
    case 0x70000023: return "MIPS_PIXIE_INIT";
    case 0x70000024: return "MIPS_SYMBOL_LIB";
    case 0x70000025: return "MIPS_LOCALPAGE_GOTIDX";
    case 0x70000026: return "MIPS_LOCAL_GOTIDX";
    case 0x70000027: return "MIPS_HIDDEN_GOTIDX";
    case 0x70000028: return "MIPS_PROTECTED_GOTIDX";
    case 0x70000029: return "MIPS_OPTIONS";
    case 0x7000002a: return "MIPS_INTERFACE";
    case 0x7000002b: return "MIPS_DYNSTR_ALIGN";
    case 0x7000002c: return "MIPS_INTERFACE_SIZE";
    case 0x7000002d: return "MIPS_RLD_TEXT_RESOLVE_ADDR";
    case 0x7000002e: return "MIPS_PERF_SUFFIX";
    case 0x7000002f: return "MIPS_COMPACT_SIZE";
    case 0x70000030: return "MIPS_GP_VALUE";
    case 0x70000031: return "MIPS_AUX_DYNAMIC";
    case 0x70000032: return "MIPS_PLTGOT";
    case 0x70000034: return "MIPS_RWPLT";
    case 0x70000036: return "MIPS_XHASH";
    default:
      return 
# 2208 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 2208 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
}

static const char *
get_sparc64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000001: return "SPARC_REGISTER";
    default:
      return 
# 2219 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 2219 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
}

static const char *
get_ppc_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000): return "PPC_GOT";
    case (0x70000000 + 1): return "PPC_OPT";
    default:
      return 
# 2231 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 2231 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
}

static const char *
get_ppc64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000000: return "PPC64_GLINK";
    case (0x70000000 + 1): return "PPC64_OPD";
    case (0x70000000 + 2): return "PPC64_OPDSZ";
    case (0x70000000 + 3): return "PPC64_OPT";
    default:
      return 
# 2245 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 2245 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
}

static const char *
get_parisc_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case (0x60000000 + 0x0): return "HP_LOAD_MAP";
    case (0x60000000 + 0x1): return "HP_DLD_FLAGS";
    case (0x60000000 + 0x2): return "HP_DLD_HOOK";
    case (0x60000000 + 0x3): return "HP_UX10_INIT";
    case (0x60000000 + 0x4): return "HP_UX10_INITSZ";
    case (0x60000000 + 0x5): return "HP_PREINIT";
    case (0x60000000 + 0x6): return "HP_PREINITSZ";
    case (0x60000000 + 0x7): return "HP_NEEDED";
    case (0x60000000 + 0x8): return "HP_TIME_STAMP";
    case (0x60000000 + 0x9): return "HP_CHECKSUM";
    case (0x60000000 + 0xa): return "HP_GST_SIZE";
    case (0x60000000 + 0xb): return "HP_GST_VERSION";
    case (0x60000000 + 0xc): return "HP_GST_HASHVAL";
    case (0x60000000 + 0xd): return "HP_GST_EPLTREL";
    case (0x60000000 + 0xe): return "HP_GST_EPLTRELSZ";
    case (0x60000000 + 0xf): return "HP_FILTERED";
    case (0x60000000 + 0x10): return "HP_FILTER_TLS";
    case (0x60000000 + 0x11): return "HP_COMPAT_FILTERED";
    case (0x60000000 + 0x12): return "HP_LAZYLOAD";
    case (0x60000000 + 0x13): return "HP_BIND_NOW_COUNT";
    case (0x60000000 + 0x14): return "PLT";
    case (0x60000000 + 0x15): return "PLT_SIZE";
    case (0x60000000 + 0x16): return "DLT";
    case (0x60000000 + 0x17): return "DLT_SIZE";
    default:
      return 
# 2279 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 2279 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
}

static const char *
get_ia64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 0): return "IA_64_PLT_RESERVE";
    case (0x6000000d + 0): return "VMS_SUBTYPE";
    case (0x6000000d + 2): return "VMS_IMGIOCNT";
    case (0x6000000d + 8): return "VMS_LNKFLAGS";
    case (0x6000000d + 10): return "VMS_VIR_MEM_BLK_SIZ";
    case (0x6000000d + 12): return "VMS_IDENT";
    case (0x6000000d + 16): return "VMS_NEEDED_IDENT";
    case (0x6000000d + 18): return "VMS_IMG_RELA_CNT";
    case (0x6000000d + 20): return "VMS_SEG_RELA_CNT";
    case (0x6000000d + 22): return "VMS_FIXUP_RELA_CNT";
    case (0x6000000d + 24): return "VMS_FIXUP_NEEDED";
    case (0x6000000d + 26): return "VMS_SYMVEC_CNT";
    case (0x6000000d + 30): return "VMS_XLATED";
    case (0x6000000d + 32): return "VMS_STACKSIZE";
    case (0x6000000d + 34): return "VMS_UNWINDSZ";
    case (0x6000000d + 36): return "VMS_UNWIND_CODSEG";
    case (0x6000000d + 38): return "VMS_UNWIND_INFOSEG";
    case (0x6000000d + 40): return "VMS_LINKTIME";
    case (0x6000000d + 42): return "VMS_SEG_NO";
    case (0x6000000d + 44): return "VMS_SYMVEC_OFFSET";
    case (0x6000000d + 46): return "VMS_SYMVEC_SEG";
    case (0x6000000d + 48): return "VMS_UNWIND_OFFSET";
    case (0x6000000d + 50): return "VMS_UNWIND_SEG";
    case (0x6000000d + 52): return "VMS_STRTAB_OFFSET";
    case (0x6000000d + 54): return "VMS_SYSVER_OFFSET";
    case (0x6000000d + 56): return "VMS_IMG_RELA_OFF";
    case (0x6000000d + 58): return "VMS_SEG_RELA_OFF";
    case (0x6000000d + 60): return "VMS_FIXUP_RELA_OFF";
    case (0x6000000d + 62): return "VMS_PLTGOT_OFFSET";
    case (0x6000000d + 64): return "VMS_PLTGOT_SEG";
    case (0x6000000d + 66): return "VMS_FPMODE";
    default:
      return 
# 2320 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 2320 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
}

static const char *
get_solaris_section_type (unsigned long type)
{
  switch (type)
    {
    case 0x6fffffee: return "SUNW_ancillary";
    case 0x6fffffef: return "SUNW_capchain";
    case 0x6ffffff0: return "SUNW_capinfo";
    case 0x6ffffff1: return "SUNW_symsort";
    case 0x6ffffff2: return "SUNW_tlssort";
    case 0x6ffffff3: return "SUNW_LDYNSYM";
    case 0x6ffffff4: return "SUNW_dof";
    case 0x6ffffff5: return "SUNW_cap";
    case 0x6ffffff6: return "SUNW_SIGNATURE";
    case 0x6ffffff7: return "SUNW_ANNOTATE";
    case 0x6ffffff8: return "SUNW_DEBUGSTR";
    case 0x6ffffff9: return "SUNW_DEBUG";
    case 0x6ffffffa: return "SUNW_move";
    case 0x6ffffffb: return "SUNW_COMDAT";
    case 0x6ffffffc: return "SUNW_syminfo";
    case 0x6ffffffd: return "SUNW_verdef";
    case 0x6ffffffe: return "SUNW_verneed";
    case 0x6fffffff: return "SUNW_versym";
    case 0x70000000: return "SPARC_GOTDATA";
    default: return 
# 2348 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 2348 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
    }
}

static const char *
get_alpha_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000000: return "ALPHA_PLTRO";
    default: return 
# 2358 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 2358 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
    }
}

static const char *
get_score_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000001: return "SCORE_BASE_ADDRESS";
    case 0x70000002: return "SCORE_LOCAL_GOTNO";
    case 0x70000003: return "SCORE_SYMTABNO";
    case 0x70000004: return "SCORE_GOTSYM";
    case 0x70000005: return "SCORE_UNREFEXTNO";
    case 0x70000006: return "SCORE_HIPAGENO";
    default: return 
# 2373 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 2373 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ;
    }
}

static const char *
get_tic6x_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x6000000D: return "C6000_GSYM_OFFSET";
    case 0x6000000F: return "C6000_GSTR_OFFSET";
    case 0x70000000: return "C6000_DSBT_BASE";
    case 0x70000001: return "C6000_DSBT_SIZE";
    case 0x70000002: return "C6000_PREEMPTMAP";
    case 0x70000003: return "C6000_DSBT_INDEX";
    default: return 
# 2388 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
# 2388 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         ;
    }
}

static const char *
get_nios2_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000002: return "NIOS2_GP";
    default: return 
# 2398 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            ((void *)0)
# 2398 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                ;
    }
}

static const char *
get_solaris_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case 0x6000000d: return "SUNW_AUXILIARY";
    case 0x6000000e: return "SUNW_RTLDINF";
    case 0x6000000f: return "SUNW_FILTER";
    case 0x60000010: return "SUNW_CAP";
    case 0x60000011: return "SUNW_SYMTAB";
    case 0x60000012: return "SUNW_SYMSZ";
    case 0x60000013: return "SUNW_SORTENT";
    case 0x60000014: return "SUNW_SYMSORT";
    case 0x60000015: return "SUNW_SYMSORTSZ";
    case 0x60000016: return "SUNW_TLSSORT";
    case 0x60000017: return "SUNW_TLSSORTSZ";
    case 0x60000018: return "SUNW_CAPINFO";
    case 0x60000019: return "SUNW_STRPAD";
    case 0x6000001a: return "SUNW_CAPCHAIN";
    case 0x6000001b: return "SUNW_LDMACH";
    case 0x6000001d: return "SUNW_CAPCHAINENT";
    case 0x6000001f: return "SUNW_CAPCHAINSZ";
    case 0x60000021: return "SUNW_PARENT";
    case 0x60000023: return "SUNW_ASLR";
    case 0x60000025: return "SUNW_RELAX";
    case 0x60000029: return "SUNW_NXHEAP";
    case 0x6000002b: return "SUNW_NXSTACK";

    case 0x70000001: return "SPARC_REGISTER";
    case 0x7ffffffd: return "AUXILIARY";
    case 0x7ffffffe: return "USED";
    case 0x7fffffff: return "FILTER";

    default: return 
# 2435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 2435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
    }
}

static const char *
get_riscv_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 1): return "RISCV_VARIANT_CC";
    default:
      return 
# 2446 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 2446 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
}

static const char *
get_dynamic_type (Filedata * filedata, unsigned long type)
{
  static char buff[64];

  switch (type)
    {
    case 0: return "NULL";
    case 1: return "NEEDED";
    case 2: return "PLTRELSZ";
    case 3: return "PLTGOT";
    case 4: return "HASH";
    case 5: return "STRTAB";
    case 6: return "SYMTAB";
    case 7: return "RELA";
    case 8: return "RELASZ";
    case 9: return "RELAENT";
    case 10: return "STRSZ";
    case 11: return "SYMENT";
    case 12: return "INIT";
    case 13: return "FINI";
    case 14: return "SONAME";
    case 15: return "RPATH";
    case 16: return "SYMBOLIC";
    case 17: return "REL";
    case 18: return "RELSZ";
    case 19: return "RELENT";
    case 36: return "RELR";
    case 35: return "RELRSZ";
    case 37: return "RELRENT";
    case 20: return "PLTREL";
    case 21: return "DEBUG";
    case 22: return "TEXTREL";
    case 23: return "JMPREL";
    case 24: return "BIND_NOW";
    case 25: return "INIT_ARRAY";
    case 26: return "FINI_ARRAY";
    case 27: return "INIT_ARRAYSZ";
    case 28: return "FINI_ARRAYSZ";
    case 29: return "RUNPATH";
    case 30: return "FLAGS";

    case 32: return "PREINIT_ARRAY";
    case 33: return "PREINIT_ARRAYSZ";
    case 34: return "SYMTAB_SHNDX";

    case 0x6ffffdf8: return "CHECKSUM";
    case 0x6ffffdf9: return "PLTPADSZ";
    case 0x6ffffdfa: return "MOVEENT";
    case 0x6ffffdfb: return "MOVESZ";
    case 0x6ffffdfc: return "FEATURE";
    case 0x6ffffdfd: return "POSFLAG_1";
    case 0x6ffffdfe: return "SYMINSZ";
    case 0x6ffffdff: return "SYMINENT";

    case 0x6ffffe00: return "ADDRRNGLO";
    case 0x6ffffefa: return "CONFIG";
    case 0x6ffffefb: return "DEPAUDIT";
    case 0x6ffffefc: return "AUDIT";
    case 0x6ffffefd: return "PLTPAD";
    case 0x6ffffefe: return "MOVETAB";
    case 0x6ffffeff: return "SYMINFO";

    case 0x6ffffff0: return "VERSYM";

    case 0x6ffffef7: return "TLSDESC_GOT";
    case 0x6ffffef6: return "TLSDESC_PLT";
    case 0x6ffffff9: return "RELACOUNT";
    case 0x6ffffffa: return "RELCOUNT";
    case 0x6ffffffb: return "FLAGS_1";
    case 0x6ffffffc: return "VERDEF";
    case 0x6ffffffd: return "VERDEFNUM";
    case 0x6ffffffe: return "VERNEED";
    case 0x6fffffff: return "VERNEEDNUM";

    case 0x7ffffffd: return "AUXILIARY";
    case 0x7ffffffe: return "USED";
    case 0x7fffffff: return "FILTER";

    case 0x6ffffdf5: return "GNU_PRELINKED";
    case 0x6ffffef8: return "GNU_CONFLICT";
    case 0x6ffffdf6: return "GNU_CONFLICTSZ";
    case 0x6ffffef9: return "GNU_LIBLIST";
    case 0x6ffffdf7: return "GNU_LIBLISTSZ";
    case 0x6ffffef5: return "GNU_HASH";
    case 0x6ffffdf4: return "GNU_FLAGS_1";

    default:
      if ((type >= 0x70000000) && (type <= 0x7fffffff))
 {
   const char * result;

   switch (filedata->file_header.e_machine)
     {
     case 183:
       result = get_aarch64_dynamic_type (type);
       break;
     case 8:
     case 10:
       result = get_mips_dynamic_type (type);
       break;
     case 43:
       result = get_sparc64_dynamic_type (type);
       break;
     case 20:
       result = get_ppc_dynamic_type (type);
       break;
     case 21:
       result = get_ppc64_dynamic_type (type);
       break;
     case 50:
       result = get_ia64_dynamic_type (type);
       break;
     case 0x9026:
       result = get_alpha_dynamic_type (type);
       break;
     case 135:
       result = get_score_dynamic_type (type);
       break;
     case 140:
       result = get_tic6x_dynamic_type (type);
       break;
     case 113:
       result = get_nios2_dynamic_type (type);
       break;
     case 243:
       result = get_riscv_dynamic_type (type);
       break;
     default:
       if (filedata->file_header.e_ident[7] == 6)
  result = get_solaris_dynamic_type (type);
       else
  result = 
# 2582 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 2582 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
       break;
     }

   if (result != 
# 2586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 2586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     return result;

   snprintf (buff, sizeof (buff), gettext ("Processor Specific: %lx"), type);
 }
      else if (((type >= 0x6000000d) && (type <= 0x6ffff000))
        || (filedata->file_header.e_machine == 15
     && (type >= 0x60000000) && (type <= 0x6fffffff)))
 {
   const char * result;

   switch (filedata->file_header.e_machine)
     {
     case 15:
       result = get_parisc_dynamic_type (type);
       break;
     case 50:
       result = get_ia64_dynamic_type (type);
       break;
     default:
       if (filedata->file_header.e_ident[7] == 6)
  result = get_solaris_dynamic_type (type);
       else
  result = 
# 2609 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 2609 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
       break;
     }

   if (result != 
# 2613 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 2613 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     return result;

   snprintf (buff, sizeof (buff), gettext ("Operating System specific: %lx"),
      type);
 }
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %lx"), type);

      return buff;
    }
}

static 
# 2626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 2626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           get_program_headers (Filedata *);
static 
# 2627 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 2627 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           get_dynamic_section (Filedata *);

static void
locate_dynamic_section (Filedata *filedata)
{
  uint64_t dynamic_addr = 0;
  uint64_t dynamic_size = 0;

  if (filedata->file_header.e_phnum != 0
      && get_program_headers (filedata))
    {
      Elf_Internal_Phdr *segment;
      unsigned int i;

      for (i = 0, segment = filedata->program_headers;
    i < filedata->file_header.e_phnum;
    i++, segment++)
 {
   if (segment->p_type == 2)
     {
       dynamic_addr = segment->p_offset;
       dynamic_size = segment->p_filesz;

       if (filedata->section_headers != 
# 2650 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       ((void *)0)
# 2650 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           )
  {
    Elf_Internal_Shdr *sec;

    sec = find_section (filedata, ".dynamic");
    if (sec != 
# 2655 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 2655 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )
      {
        if (sec->sh_size == 0
     || sec->sh_type == 8)
   {
     dynamic_addr = 0;
     dynamic_size = 0;
   }
        else
   {
     dynamic_addr = sec->sh_offset;
     dynamic_size = sec->sh_size;
   }
      }
  }

       if (dynamic_addr > filedata->file_size
    || (dynamic_size > filedata->file_size - dynamic_addr))
  {
    dynamic_addr = 0;
    dynamic_size = 0;
  }
       break;
     }
 }
    }
  filedata->dynamic_addr = dynamic_addr;
  filedata->dynamic_size = dynamic_size ? dynamic_size : 1;
}

static 
# 2685 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 2686 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_pie (Filedata *filedata)
{
  Elf_Internal_Dyn *entry;

  if (filedata->dynamic_size == 0)
    locate_dynamic_section (filedata);
  if (filedata->dynamic_size <= 1)
    return 
# 2693 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 2693 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (!get_dynamic_section (filedata))
    return 
# 2696 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 2696 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  for (entry = filedata->dynamic_section;
       entry < filedata->dynamic_section + filedata->dynamic_nent;
       entry++)
    {
      if (entry->d_tag == 0x6ffffffb)
 {
   if ((entry->d_un.d_val & 0x08000000) != 0)
     return 
# 2705 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 2705 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   break;
 }
    }
  return 
# 2709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 2709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}

static char *
get_file_type (Filedata *filedata)
{
  unsigned e_type = filedata->file_header.e_type;
  static char buff[64];

  switch (e_type)
    {
    case 0: return gettext ("NONE (None)");
    case 1: return gettext ("REL (Relocatable file)");
    case 2: return gettext ("EXEC (Executable file)");
    case 3:
      if (is_pie (filedata))
 return gettext ("DYN (Position-Independent Executable file)");
      else
 return gettext ("DYN (Shared object file)");
    case 4: return gettext ("CORE (Core file)");

    default:
      if ((e_type >= 0xFF00) && (e_type <= 0xFFFF))
 snprintf (buff, sizeof (buff), gettext ("Processor Specific: (%x)"), e_type);
      else if ((e_type >= 0xFE00) && (e_type <= 0xFEFF))
 snprintf (buff, sizeof (buff), gettext ("OS Specific: (%x)"), e_type);
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %x"), e_type);
      return buff;
    }
}

static char *
get_machine_name (unsigned e_machine)
{
  static char buff[64];

  switch (e_machine)
    {


    case 0: return gettext ("None");
    case 1: return "WE32100";
    case 2: return "Sparc";
    case 3: return "Intel 80386";
    case 4: return "MC68000";
    case 5: return "MC88000";
    case 6: return "Intel MCU";
    case 7: return "Intel 80860";
    case 8: return "MIPS R3000";
    case 9: return "IBM System/370";

    case 10: return "MIPS R4000 big-endian";
    case 11: return "Sparc v9 (old)";
    case 15: return "HPPA";
    case 17: return "Fujitsu VPP500";
    case 18: return "Sparc v8+" ;
    case 19: return "Intel 80960";
    case 20: return "PowerPC";

    case 21: return "PowerPC64";
    case 0xa390:
    case 22: return "IBM S/390";
    case 23: return "SPU";

    case 36: return "Renesas V850 (using RH850 ABI)";
    case 37: return "Fujitsu FR20";
    case 38: return "TRW RH32";
    case 39: return "MCORE";

    case 40: return "ARM";
    case 41: return "Digital Alpha (old)";
    case 42: return "Renesas / SuperH SH";
    case 43: return "Sparc v9";
    case 44: return "Siemens Tricore";
    case 45: return "ARC";
    case 46: return "Renesas H8/300";
    case 47: return "Renesas H8/300H";
    case 48: return "Renesas H8S";
    case 49: return "Renesas H8/500";

    case 50: return "Intel IA-64";
    case 51: return "Stanford MIPS-X";
    case 52: return "Motorola Coldfire";
    case 53: return "Motorola MC68HC12 Microcontroller";
    case 54: return "Fujitsu Multimedia Accelerator";
    case 55: return "Siemens PCP";
    case 56: return "Sony nCPU embedded RISC processor";
    case 57: return "Denso NDR1 microprocesspr";
    case 58: return "Motorola Star*Core processor";
    case 59: return "Toyota ME16 processor";

    case 60: return "STMicroelectronics ST100 processor";
    case 61: return "Advanced Logic Corp. TinyJ embedded processor";
    case 62: return "Advanced Micro Devices X86-64";
    case 63: return "Sony DSP processor";
    case 64: return "Digital Equipment Corp. PDP-10";
    case 65: return "Digital Equipment Corp. PDP-11";
    case 66: return "Siemens FX66 microcontroller";
    case 67: return "STMicroelectronics ST9+ 8/16 bit microcontroller";
    case 68: return "STMicroelectronics ST7 8-bit microcontroller";
    case 69: return "Motorola MC68HC16 Microcontroller";

    case 70: return "Motorola MC68HC11 Microcontroller";
    case 71: return "Motorola MC68HC08 Microcontroller";
    case 72: return "Motorola MC68HC05 Microcontroller";
    case 73: return "Silicon Graphics SVx";
    case 74: return "STMicroelectronics ST19 8-bit microcontroller";
    case 75: return "Digital VAX";
    case 76: return "Axis Communications 32-bit embedded processor";
    case 77: return "Infineon Technologies 32-bit embedded cpu";
    case 78: return "Element 14 64-bit DSP processor";
    case 79: return "LSI Logic's 16-bit DSP processor";

    case 80: return "Donald Knuth's educational 64-bit processor";
    case 81: return "Harvard Universitys's machine-independent object format";
    case 82: return "Vitesse Prism";
    case 0x1057:
    case 83: return "Atmel AVR 8-bit microcontroller";
    case 0x3330:
    case 84: return "Fujitsu FR30";
    case 0x7650:
    case 85: return "d10v";
    case 0x7676:
    case 86: return "d30v";
    case 0x9080:
    case 87: return "Renesas V850";
    case 0x9041:
    case 88: return "Renesas M32R (formerly Mitsubishi M32r)";
    case 0xbeef:
    case 89: return "mn10300";

    case 0xdead:
    case 90: return "mn10200";
    case 91: return "picoJava";
    case 92: return "OpenRISC 1000";
    case 93: return "ARCompact";
    case 0xabc7:
    case 94: return "Tensilica Xtensa Processor";
    case 95: return "Alphamosaic VideoCore processor";
    case 96: return "Thompson Multimedia General Purpose Processor";
    case 97: return "National Semiconductor 32000 series";
    case 98: return "Tenor Network TPC processor";
    case 99: return "Trebia SNP 1000 processor";

    case 100: return "STMicroelectronics ST200 microcontroller";
    case 0x8217:
    case 101: return "Ubicom IP2xxx 8-bit microcontrollers";
    case 102: return "MAX Processor";
    case 103: return "National Semiconductor CompactRISC";
    case 104: return "Fujitsu F2MC16";
    case 105: return "Texas Instruments msp430 microcontroller";
    case 106: return "Analog Devices Blackfin";
    case 107: return "S1C33 Family of Seiko Epson processors";
    case 108: return "Sharp embedded microprocessor";
    case 109: return "Arca RISC microprocessor";

    case 110: return "Unicore";
    case 111: return "eXcess 16/32/64-bit configurable embedded CPU";
    case 112: return "Icera Semiconductor Inc. Deep Execution Processor";
    case 113: return "Altera Nios II";
    case 114: return "National Semiconductor CRX microprocessor";
    case 115: return "Motorola XGATE embedded processor";
    case 116:
    case 0x4688: return "Infineon Technologies xc16x";
    case 117: return "Renesas M16C series microprocessors";
    case 118: return "Microchip Technology dsPIC30F Digital Signal Controller";
    case 119: return "Freescale Communication Engine RISC core";

    case 120: return "Renesas M32c";

    case 131: return "Altium TSK3000 core";
    case 132: return "Freescale RS08 embedded processor";
    case 134: return "Cyan Technology eCOG2 microprocessor";
    case 135: return "SUNPLUS S+Core";
    case 136: return "New Japan Radio (NJR) 24-bit DSP Processor";
    case 137: return "Broadcom VideoCore III processor";
    case 138: return "Lattice Mico32";
    case 139: return "Seiko Epson C17 family";

    case 140: return "Texas Instruments TMS320C6000 DSP family";
    case 141: return "Texas Instruments TMS320C2000 DSP family";
    case 142: return "Texas Instruments TMS320C55x DSP family";
    case 144: return "TI PRU I/O processor";

    case 160: return "STMicroelectronics 64bit VLIW Data Signal Processor";
    case 161: return "Cypress M8C microprocessor";
    case 162: return "Renesas R32C series microprocessors";
    case 163: return "NXP Semiconductors TriMedia architecture family";
    case 164: return "QUALCOMM DSP6 Processor";
    case 165: return "Intel 8051 and variants";
    case 166: return "STMicroelectronics STxP7x family";
    case 167: return "Andes Technology compact code size embedded RISC processor family";
    case 168: return "Cyan Technology eCOG1X family";
    case 169: return "Dallas Semiconductor MAXQ30 Core microcontrollers";

    case 170: return "New Japan Radio (NJR) 16-bit DSP Processor";
    case 171: return "M2000 Reconfigurable RISC Microprocessor";
    case 172: return "Cray Inc. NV2 vector architecture";
    case 173: return "Renesas RX";
    case 174: return "Imagination Technologies Meta processor architecture";
    case 175: return "MCST Elbrus general purpose hardware architecture";
    case 176: return "Cyan Technology eCOG16 family";
    case 177:
    case 189:
    case 0xbaab: return "Xilinx MicroBlaze";
    case 178: return "Freescale Extended Time Processing Unit";
    case 179: return "Infineon Technologies SLE9X core";

    case 180: return "Intel L1OM";
    case 181: return "Intel K1OM";
    case 182: return "Intel (reserved)";
    case 183: return "AArch64";
    case 184: return "ARM (reserved)";
    case 185: return "Atmel Corporation 32-bit microprocessor";
    case 186: return "STMicroeletronics STM8 8-bit microcontroller";
    case 187: return "Tilera TILE64 multicore architecture family";
    case 188: return "Tilera TILEPro multicore architecture family";

    case 190: return "NVIDIA CUDA architecture";
    case 191: return "Tilera TILE-Gx multicore architecture family";
    case 192: return "CloudShield architecture family";
    case 193: return "KIPO-KAIST Core-A 1st generation processor family";
    case 194: return "KIPO-KAIST Core-A 2nd generation processor family";
    case 195: return "ARCv2";
    case 196: return "Open8 8-bit RISC soft processor core";
    case 197: return "Renesas RL78";
    case 198: return "Broadcom VideoCore V processor";
    case 199: return "Renesas 78K0R";

    case 200: return "Freescale 56800EX Digital Signal Controller (DSC)";
    case 201: return "Beyond BA1 CPU architecture";
    case 202: return "Beyond BA2 CPU architecture";
    case 203: return "XMOS xCORE processor family";
    case 204: return "Microchip 8-bit PIC(r) family";
    case 205: return "Intel Graphics Technology";

    case 210: return "KM211 KM32 32-bit processor";
    case 211: return "KM211 KMX32 32-bit processor";
    case 212: return "KM211 KMX16 16-bit processor";
    case 213: return "KM211 KMX8 8-bit processor";
    case 214: return "KM211 KVARC processor";
    case 215: return "Paneve CDP architecture family";
    case 216: return "Cognitive Smart Memory Processor";
    case 217: return "Bluechip Systems CoolEngine";
    case 218: return "Nanoradio Optimized RISC";
    case 219: return "CSR Kalimba architecture family";

    case 220: return "Zilog Z80";
    case 221: return "CDS VISIUMcore processor";
    case 222: return "FTDI Chip FT32";
    case 223: return "Moxie";
    case 224: return "AMD GPU";


    case 243: return "RISC-V";
    case 244: return "Lanai 32-bit processor";
    case 245: return "CEVA Processor Architecture Family";
    case 246: return "CEVA X2 Processor Family";
    case 247: return "Linux BPF";
    case 248: return "Graphcore Intelligent Processing Unit";
    case 249: return "Imagination Technologies";

    case 250: return "Netronome Flow Processor";
    case 251: return "NEC Vector Engine";
    case 252: return "C-SKY";
    case 253: return "Synopsys ARCv3 64-bit processor";
    case 254: return "MOS Technology MCS 6502 processor";
    case 255: return "Synopsys ARCv3 32-bit processor";
    case 256: return "Kalray VLIW core of the MPPA processor family";
    case 257: return "WDC 65816/65C816";
    case 258: return "LoongArch";
    case 259: return "ChipON KungFu32";


    case 0x2530: return "Morpho Techologies MT processor";
    case 0x9026: return "Alpha";
    case 0x4157: return "Web Assembly";
    case 0x5aa5: return "OpenDLX";
    case 0xad45: return "Sanyo XStormy16 CPU core";
    case 0xFEBA: return "Vitesse IQ2000";
    case 0xFEB0:
    case 0xFEBB: return "Altera Nios";
    case 0xF00D: return "Toshiba MeP Media Engine";
    case 0x1223: return "Adapteva EPIPHANY";
    case 0x5441: return "Fujitsu FR-V";
    case 0x4DEF: return "Freescale S12Z";

    default:
      snprintf (buff, sizeof (buff), gettext ("<unknown>: 0x%x"), e_machine);
      return buff;
    }
}

static void
decode_ARC_machine_flags (unsigned e_flags, unsigned e_machine, char buf[])
{
# 3019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  switch (e_flags & 0x000000ff)
    {

    case 0x00000005:
      strcat (buf, ", ARC EM");
      break;
    case 0x00000006:
      strcat (buf, ", ARC HS");
      break;


    case 0x00000002:
      strcat (buf, ", ARC600");
      break;
    case 0x00000004:
      strcat (buf, ", ARC601");
      break;
    case 0x00000003:
      strcat (buf, ", ARC700");
      break;





    default:
      if (e_machine == 93)
        strcat (buf, ", Unknown ARCompact");
      else
        strcat (buf, ", Unknown ARC");
      break;
    }

  switch (e_flags & 0x00000f00)
    {
    case 0x00000000:
      strcat (buf, ", (ABI:legacy)");
      break;
    case 0x00000200:
      strcat (buf, ", (ABI:v2)");
      break;

    case 0x00000300:
      strcat (buf, ", v3 no-legacy-syscalls ABI");
      break;
    case 0x00000400:
      strcat (buf, ", v4 ABI");
      break;
    default:
      strcat (buf, ", unrecognised ARC OSABI flag");
      break;
    }
}

static void
decode_ARM_machine_flags (unsigned e_flags, char buf[])
{
  unsigned eabi;
  
# 3077 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 3077 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      unknown = 
# 3077 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                0
# 3077 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;

  eabi = ((e_flags) & 0xFF000000);
  e_flags &= ~ 0xFF000000;


  if (e_flags & 0x01)
    {
      strcat (buf, ", relocatable executable");
      e_flags &= ~ 0x01;
    }

  if (e_flags & 0x20)
    {
      strcat (buf, ", position independent");
      e_flags &= ~ 0x20;
    }


  switch (eabi)
    {
    default:
      strcat (buf, ", <unrecognized EABI>");
      if (e_flags)
 unknown = 
# 3101 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 3101 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
      break;

    case 0x01000000:
      strcat (buf, ", Version1 EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x04:
       strcat (buf, ", sorted symbol tables");
       break;

     default:
       unknown = 
# 3121 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 3121 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
       break;
     }
 }
      break;

    case 0x02000000:
      strcat (buf, ", Version2 EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x04:
       strcat (buf, ", sorted symbol tables");
       break;

     case 0x08:
       strcat (buf, ", dynamic symbols use segment index");
       break;

     case 0x10:
       strcat (buf, ", mapping symbols precede others");
       break;

     default:
       unknown = 
# 3152 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 3152 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
       break;
     }
 }
      break;

    case 0x03000000:
      strcat (buf, ", Version3 EABI");
      break;

    case 0x04000000:
      strcat (buf, ", Version4 EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x00800000:
       strcat (buf, ", BE8");
       break;

     case 0x00400000:
       strcat (buf, ", LE8");
       break;

     default:
       unknown = 
# 3183 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 3183 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
       break;
     }
 }
      break;

    case 0x05000000:
      strcat (buf, ", Version5 EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x00800000:
       strcat (buf, ", BE8");
       break;

     case 0x00400000:
       strcat (buf, ", LE8");
       break;

     case 0x200:
       strcat (buf, ", soft-float ABI");
       break;

     case 0x400:
       strcat (buf, ", hard-float ABI");
       break;

     default:
       unknown = 
# 3218 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 3218 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
       break;
     }
 }
      break;

    case 0x00000000:
      strcat (buf, ", GNU EABI");
      while (e_flags)
 {
   unsigned flag;


   flag = e_flags & - e_flags;
   e_flags &= ~ flag;

   switch (flag)
     {
     case 0x04:
       strcat (buf, ", interworking enabled");
       break;

     case 0x08:
       strcat (buf, ", uses APCS/26");
       break;

     case 0x10:
       strcat (buf, ", uses APCS/float");
       break;

     case 0x20:
       strcat (buf, ", position independent");
       break;

     case 0x40:
       strcat (buf, ", 8 bit structure alignment");
       break;

     case 0x80:
       strcat (buf, ", uses new ABI");
       break;

     case 0x100:
       strcat (buf, ", uses old ABI");
       break;

     case 0x200:
       strcat (buf, ", software FP");
       break;

     case 0x400:
       strcat (buf, ", VFP");
       break;

     case 0x800:
       strcat (buf, ", Maverick FP");
       break;

     default:
       unknown = 
# 3277 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 3277 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
       break;
     }
 }
    }

  if (unknown)
    strcat (buf,gettext (", <unknown>"));
}

static void
decode_AVR_machine_flags (unsigned e_flags, char buf[], size_t size)
{
  --size;

  switch (e_flags & 0x7F)
    {
    case 1:
      strncat (buf, ", avr:1", size);
      break;
    case 2:
      strncat (buf, ", avr:2", size);
      break;
    case 25:
      strncat (buf, ", avr:25", size);
      break;
    case 3:
      strncat (buf, ", avr:3", size);
      break;
    case 31:
      strncat (buf, ", avr:31", size);
      break;
    case 35:
      strncat (buf, ", avr:35", size);
      break;
    case 4:
      strncat (buf, ", avr:4", size);
      break;
    case 5:
      strncat (buf, ", avr:5", size);
      break;
    case 51:
      strncat (buf, ", avr:51", size);
      break;
    case 6:
      strncat (buf, ", avr:6", size);
      break;
    case 100:
      strncat (buf, ", avr:100", size);
      break;
    case 101:
      strncat (buf, ", avr:101", size);
      break;
    case 102:
      strncat (buf, ", avr:102", size);
      break;
    case 103:
      strncat (buf, ", avr:103", size);
      break;
    case 104:
      strncat (buf, ", avr:104", size);
      break;
    case 105:
      strncat (buf, ", avr:105", size);
      break;
    case 106:
      strncat (buf, ", avr:106", size);
      break;
    case 107:
      strncat (buf, ", avr:107", size);
      break;
    default:
      strncat (buf, ", avr:<unknown>", size);
      break;
    }

  size -= strlen (buf);
  if (e_flags & 0x80)
    strncat (buf, ", link-relax", size);
}

static void
decode_NDS32_machine_flags (unsigned e_flags, char buf[], size_t size)
{
  unsigned abi;
  unsigned arch;
  unsigned config;
  unsigned version;
  
# 3365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 3365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      has_fpu = 
# 3365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                0
# 3365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;
  unsigned int r = 0;

  static const char *ABI_STRINGS[] =
  {
    "ABI v0",
    "ABI v1",
    "ABI v2",
    "ABI v2fp",
    "AABI",
    "ABI2 FP+"
  };
  static const char *VER_STRINGS[] =
  {
    "Andes ELF V1.3 or older",
    "Andes ELF V1.3.1",
    "Andes ELF V1.4"
  };
  static const char *ARCH_STRINGS[] =
  {
    "",
    "Andes Star v1.0",
    "Andes Star v2.0",
    "Andes Star v3.0",
    "Andes Star v3.0m"
  };

  abi = 0x000000F0 & e_flags;
  arch = 0xF0000000 & e_flags;
  config = 0x0FFFFF00 & e_flags;
  version = 0x0000000F & e_flags;

  memset (buf, 0, size);

  switch (abi)
    {
    case 0x00000000:
    case 0x00000010:
    case 0x00000020:
    case 0x00000030:
    case 0x00000040:
    case 0x00000050:

      r += snprintf (buf + r, size - r, ", %s", ABI_STRINGS[abi >> 4]);
      break;

    default:
      r += snprintf (buf + r, size - r, ", <unrecognized ABI>");
      break;
    }

  switch (version)
    {
    case 0x0:
    case 0x1:
    case 0x2:
      r += snprintf (buf + r, size - r, ", %s", VER_STRINGS[version >> 0]);
      break;

    default:
      r += snprintf (buf + r, size - r, ", <unrecognized ELF version number>");
      break;
    }

  if (0x00000000 == abi)
    {

      r += snprintf (buf + r, size - r, ", Andes Star v1.0, N1213HC, MAC, PERF1");
      if (arch == 0x10000000)
 r += snprintf (buf + r, size -r, ", 16b");
      return;
    }

  switch (arch)
    {
    case 0x10000000:
    case 0x20000000:
    case 0x30000000:
    case 0x40000000:
      r += snprintf (buf + r, size - r, ", %s", ARCH_STRINGS[arch >> 28]);
      break;

    default:
      r += snprintf (buf + r, size - r, ", <unrecognized architecture>");


      return;
    }


  if (arch == 0x10000000)
    {
      if (config & 0x00000100)
 r += snprintf (buf + r, size -r, ", MFUSR_PC");

      if (!(config & 0x00100000))
 r += snprintf (buf + r, size -r, ", MAC");

      if (config & 0x00002000)
 r += snprintf (buf + r, size -r, ", DIV");

      if (config & 0x00004000)
 r += snprintf (buf + r, size -r, ", 16b");
    }
  else
    {
      if (config & 0x00000100)
 {
   if (version <= 0x1)
     r += snprintf (buf + r, size -r, ", [B8]");
   else
     r += snprintf (buf + r, size -r, ", EX9");
 }

      if (config & 0x00100000)
 r += snprintf (buf + r, size -r, ", MAC_DX");

      if (config & 0x00002000)
 r += snprintf (buf + r, size -r, ", DIV_DX");

      if (config & 0x00004000)
 {
   if (version <= 0x1)
     r += snprintf (buf + r, size -r, ", 16b");
   else
     r += snprintf (buf + r, size -r, ", IFC");
 }
    }

  if (config & 0x00000200)
    r += snprintf (buf + r, size -r, ", PERF1");

  if (config & 0x00000400)
    r += snprintf (buf + r, size -r, ", PERF2");

  if (config & 0x00000800)
    {
      has_fpu = 
# 3502 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 3502 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
      r += snprintf (buf + r, size -r, ", FPU_SP");
    }

  if (config & 0x00080000)
    {
      has_fpu = 
# 3508 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 3508 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
      r += snprintf (buf + r, size -r, ", FPU_DP");
    }

  if (config & 0x01000000)
    {
      has_fpu = 
# 3514 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 3514 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
      r += snprintf (buf + r, size -r, ", FPU_MAC");
    }

  if (has_fpu)
    {
      switch ((config & (0x3 << 22)) >> 22)
 {
 case 0x0:
   r += snprintf (buf + r, size -r, ", FPU_REG:8/4");
   break;
 case 0x1:
   r += snprintf (buf + r, size -r, ", FPU_REG:16/8");
   break;
 case 0x2:
   r += snprintf (buf + r, size -r, ", FPU_REG:32/16");
   break;
 case 0x3:
   r += snprintf (buf + r, size -r, ", FPU_REG:32/32");
   break;
 }
    }

  if (config & 0x00001000)
    r += snprintf (buf + r, size -r, ", AUDIO");

  if (config & 0x00008000)
    r += snprintf (buf + r, size -r, ", STR");

  if (config & 0x00010000)
    r += snprintf (buf + r, size -r, ", 16REG");

  if (config & 0x00020000)
    {
      if (version <= 0x1)
 r += snprintf (buf + r, size -r, ", VIDEO");
      else
 r += snprintf (buf + r, size -r, ", SATURATION");
    }

  if (config & 0x00040000)
    r += snprintf (buf + r, size -r, ", ENCRP");

  if (config & 0x00200000)
    r += snprintf (buf + r, size -r, ", L2C");
}

static void
decode_AMDGPU_machine_flags (Filedata *filedata, unsigned int e_flags,
        char *buf)
{
  unsigned char *e_ident = filedata->file_header.e_ident;
  unsigned char osabi = e_ident[7];
  unsigned char abiversion = e_ident[8];
  unsigned int mach;







  if (osabi == 64 && abiversion < 1)
    return;

  mach = e_flags & 0x0ff;
  switch (mach)
    {


    case 0x020: strcat (buf, ", " "gfx600"); break;
    case 0x021: strcat (buf, ", " "gfx601"); break;
    case 0x022: strcat (buf, ", " "gfx700"); break;
    case 0x023: strcat (buf, ", " "gfx701"); break;
    case 0x024: strcat (buf, ", " "gfx702"); break;
    case 0x025: strcat (buf, ", " "gfx703"); break;
    case 0x026: strcat (buf, ", " "gfx704"); break;
    case 0x028: strcat (buf, ", " "gfx801"); break;
    case 0x029: strcat (buf, ", " "gfx802"); break;
    case 0x02a: strcat (buf, ", " "gfx803"); break;
    case 0x02b: strcat (buf, ", " "gfx810"); break;
    case 0x02c: strcat (buf, ", " "gfx900"); break;
    case 0x02d: strcat (buf, ", " "gfx902"); break;
    case 0x02e: strcat (buf, ", " "gfx904"); break;
    case 0x02f: strcat (buf, ", " "gfx906"); break;
    case 0x030: strcat (buf, ", " "gfx908"); break;
    case 0x031: strcat (buf, ", " "gfx909"); break;
    case 0x032: strcat (buf, ", " "gfx90c"); break;
    case 0x033: strcat (buf, ", " "gfx1010"); break;
    case 0x034: strcat (buf, ", " "gfx1011"); break;
    case 0x035: strcat (buf, ", " "gfx1012"); break;
    case 0x036: strcat (buf, ", " "gfx1030"); break;
    case 0x037: strcat (buf, ", " "gfx1031"); break;
    case 0x038: strcat (buf, ", " "gfx1032"); break;
    case 0x039: strcat (buf, ", " "gfx1033"); break;
    case 0x03a: strcat (buf, ", " "gfx602"); break;
    case 0x03b: strcat (buf, ", " "gfx705"); break;
    case 0x03c: strcat (buf, ", " "gfx805"); break;
    case 0x03d: strcat (buf, ", " "gfx1035"); break;
    case 0x03e: strcat (buf, ", " "gfx1034"); break;
    case 0x03f: strcat (buf, ", " "gfx90a"); break;
    case 0x040: strcat (buf, ", " "gfx940"); break;
    case 0x042: strcat (buf, ", " "gfx1013"); break;
    case 0x045: strcat (buf, ", " "gfx1036"); break;
    default:
      sprintf (buf, gettext (", <unknown AMDGPU GPU type: %#x>"), mach);
      break;

    }

  buf += strlen (buf);
  e_flags &= ~0x0ff;

  if ((osabi == 64
       && abiversion == 1)
      || osabi != 64)
    {

      if (e_flags & 0x100)
 {
   strcat (buf, ", xnack on");
   buf += strlen (buf);
   e_flags &= ~0x100;
 }

      if (e_flags & 0x200)
 {
   strcat (buf, ", sramecc on");
   buf += strlen (buf);
   e_flags &= ~0x200;
 }
    }
  else
    {

      int xnack, sramecc;

      xnack = e_flags & 0x300;
      switch (xnack)
 {
 case 0x000:
   break;

 case 0x100:
   strcat (buf, ", xnack any");
   break;

 case 0x200:
   strcat (buf, ", xnack off");
   break;

 case 0x300:
   strcat (buf, ", xnack on");
   break;

 default:
   sprintf (buf, gettext (", <unknown xnack value: %#x>"), xnack);
   break;
 }

      buf += strlen (buf);
      e_flags &= ~0x300;

      sramecc = e_flags & 0xc00;
      switch (sramecc)
 {
 case 0x000:
   break;

 case 0x400:
   strcat (buf, ", sramecc any");
   break;

 case 0x800:
   strcat (buf, ", sramecc off");
   break;

 case 0xc00:
   strcat (buf, ", sramecc on");
   break;

 default:
   sprintf (buf, gettext (", <unknown sramecc value: %#x>"), sramecc);
   break;
 }

      buf += strlen (buf);
      e_flags &= ~0xc00;
    }

  if (e_flags != 0)
    sprintf (buf, gettext (", unknown flags bits: %#x"), e_flags);
}

static char *
get_machine_flags (Filedata * filedata, unsigned e_flags, unsigned e_machine)
{
  static char buf[1024];

  buf[0] = '\0';

  if (e_flags)
    {
      switch (e_machine)
 {
 default:
   break;

 case 255:
   strcat (buf, ", HS5x");
   break;

 case 253:
   strcat (buf, ", HS6x");
   break;

 case 195:
 case 93:
          decode_ARC_machine_flags (e_flags, e_machine, buf);
          break;

 case 40:
   decode_ARM_machine_flags (e_flags, buf);
   break;

        case 83:
          decode_AVR_machine_flags (e_flags, buf, sizeof buf);
          break;

 case 106:
   if (e_flags & 0x00000001)
     strcat (buf, ", PIC");

   if (e_flags & 0x00000002)
     strcat (buf, ", FDPIC");

   if (e_flags & 0x00000010)
     strcat (buf, ", code in L1");

   if (e_flags & 0x00000020)
     strcat (buf, ", data in L1");

   break;

 case 0x5441:
   switch (e_flags & 0xff000000)
     {
     case 0x00000000:
       break;

     default:
       strcat (buf, ", fr???");
       break;

     case 0x02000000:
       strcat (buf, ", fr300");
       break;

     case 0x05000000:
       strcat (buf, ", fr400");
       break;
     case 0x07000000:
       strcat (buf, ", fr405");
       break;

     case 0x08000000:
       strcat (buf, ", fr450");
       break;

     case 0x01000000:
       strcat (buf, ", fr500");
       break;
     case 0x06000000:
       strcat (buf, ", fr550");
       break;

     case 0x03000000:
       strcat (buf, ", simple");
       break;
     case 0x04000000:
       strcat (buf, ", tomcat");
       break;
     }
   break;

 case 4:
   if ((e_flags & (0x01000000 | 0x00810000 | 0x00008000 | 0x02000000)) == 0x01000000)
     strcat (buf, ", m68000");
   else if ((e_flags & (0x01000000 | 0x00810000 | 0x00008000 | 0x02000000)) == 0x00810000)
     strcat (buf, ", cpu32");
   else if ((e_flags & (0x01000000 | 0x00810000 | 0x00008000 | 0x02000000)) == 0x02000000)
     strcat (buf, ", fido_a");
   else
     {
       char const * isa = gettext ("unknown");
       char const * mac = gettext ("unknown mac");
       char const * additional = 
# 3810 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 3810 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    ;

       switch (e_flags & 0x0F)
  {
  case 0x01:
    isa = "A";
    additional = ", nodiv";
    break;
  case 0x02:
    isa = "A";
    break;
  case 0x03:
    isa = "A+";
    break;
  case 0x04:
    isa = "B";
    additional = ", nousp";
    break;
  case 0x05:
    isa = "B";
    break;
  case 0x06:
    isa = "C";
    break;
  case 0x07:
    isa = "C";
    additional = ", nodiv";
    break;
  }
       strcat (buf, ", cf, isa ");
       strcat (buf, isa);
       if (additional)
  strcat (buf, additional);
       if (e_flags & 0x40)
  strcat (buf, ", float");
       switch (e_flags & 0x30)
  {
  case 0:
    mac = 
# 3848 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         ((void *)0)
# 3848 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
    break;
  case 0x10:
    mac = "mac";
    break;
  case 0x20:
    mac = "emac";
    break;
  case 0x30:
    mac = "emac_b";
    break;
  }
       if (mac)
  {
    strcat (buf, ", ");
    strcat (buf, mac);
  }
     }
   break;

 case 224:
   decode_AMDGPU_machine_flags (filedata, e_flags, buf);
   break;

 case 0xF00D:
   switch (e_flags & 0xff000000)
     {
     case 0x00000000: strcat (buf, ", generic MeP"); break;
     case 0x01000000: strcat (buf, ", MeP C2"); break;
     case 0x02000000: strcat (buf, ", MeP C3"); break;
     case 0x04000000: strcat (buf, ", MeP C4"); break;
     case 0x08000000: strcat (buf, ", MeP C5"); break;
     case 0x10000000: strcat (buf, ", MeP H1"); break;
     default: strcat (buf, gettext (", <unknown MeP cpu type>")); break;
     }

   switch (e_flags & 0x00ff0000)
     {
     case 0x00000000: break;
     case 0x00010000: strcat (buf, ", AVC coprocessor"); break;
     case 0x00020000: strcat (buf, ", AVC2 coprocessor"); break;
     case 0x00030000: strcat (buf, ", FMAX coprocessor"); break;
     case 0x00060000: strcat (buf, ", IVC2 coprocessor"); break;
     default: strcat (buf, gettext ("<unknown MeP copro type>")); break;
     }

   if (e_flags & 0x00000100)
     strcat (buf, ", Built for Library");

   if (e_flags & 0x000000ff)
     sprintf (buf + strlen (buf), ", Configuration Index: %#x",
       e_flags & 0x000000ff);

   if (e_flags & ~ 0xffff01ff)
     sprintf (buf + strlen (buf), gettext (", unknown flags bits: %#x"),
       e_flags & ~ 0xffff01ff);
   break;

 case 20:
   if (e_flags & 0x80000000)
     strcat (buf, ", emb");

   if (e_flags & 0x00010000)
     strcat (buf, gettext (", relocatable"));

   if (e_flags & 0x00008000)
     strcat (buf, gettext (", relocatable-lib"));
   break;

 case 21:
   if (e_flags & 3)
     {
       char abi[] = ", abiv0";

       abi[6] += e_flags & 3;
       strcat (buf, abi);
     }
   break;

 case 36:
   if ((e_flags & 0xF0000000) == 0xF0000000)
     strcat (buf, ", RH850 ABI");

   if (e_flags & 0x00100000)
     strcat (buf, ", V3 architecture");

   if ((e_flags & (0x00000001 | 0x00000002)) == 0)
     strcat (buf, ", FPU not used");

   if ((e_flags & (0x00000020 | 0x00000040)) == 0)
     strcat (buf, ", regmode: COMMON");

   if ((e_flags & (0x00000100 | 0x00000200)) == 0)
     strcat (buf, ", r4 not used");

   if ((e_flags & (0x00000400 | 0x00000800)) == 0)
     strcat (buf, ", r30 not used");

   if ((e_flags & (0x00001000 | 0x00002000)) == 0)
     strcat (buf, ", r5 not used");

   if ((e_flags & (0x00004000 | 0x00008000)) == 0)
     strcat (buf, ", r2 not used");

   for (e_flags &= 0xFFFF; e_flags; e_flags &= ~ (e_flags & - e_flags))
     {
       switch (e_flags & - e_flags)
  {
  case 0x00000001: strcat (buf, ", double precision FPU"); break;
  case 0x00000002: strcat (buf, ", single precision FPU"); break;
  case 0x00000020: strcat (buf, ", regmode:22"); break;
  case 0x00000040: strcat (buf, ", regmode:23"); break;
  case 0x00000100: strcat (buf, ", r4 fixed"); break;
  case 0x00000200: strcat (buf, ", r4 free"); break;
  case 0x00000400: strcat (buf, ", r30 fixed"); break;
  case 0x00000800: strcat (buf, ", r30 free"); break;
  case 0x00001000: strcat (buf, ", r5 fixed"); break;
  case 0x00002000: strcat (buf, ", r5 free"); break;
  case 0x00004000: strcat (buf, ", r2 fixed"); break;
  case 0x00008000: strcat (buf, ", r2 free"); break;
  default: break;
  }
     }
   break;

 case 87:
 case 0x9080:
   switch (e_flags & 0xf0000000)
     {
     case 0x60000000:
       strcat (buf, ", v850e3v5");
       break;
     case 0x40000000:
       strcat (buf, ", v850e2v3");
       break;
     case 0x30000000:
       strcat (buf, ", v850e2");
       break;
            case 0x20000000:
              strcat (buf, ", v850e1");
       break;
     case 0x10000000:
       strcat (buf, ", v850e");
       break;
     case 0x00000000:
       strcat (buf, ", v850");
       break;
     default:
       strcat (buf, gettext (", unknown v850 architecture variant"));
       break;
     }
   break;

 case 88:
 case 0x9041:
   if ((e_flags & 0x30000000) == 0x00000000)
     strcat (buf, ", m32r");
   break;

 case 8:
 case 10:
   if (e_flags & 0x00000001)
     strcat (buf, ", noreorder");

   if (e_flags & 0x00000002)
     strcat (buf, ", pic");

   if (e_flags & 0x00000004)
     strcat (buf, ", cpic");

   if (e_flags & 0x00000010)
     strcat (buf, ", ugen_reserved");

   if (e_flags & 0x00000020)
     strcat (buf, ", abi2");

   if (e_flags & 0x00000080)
     strcat (buf, ", odk first");

   if (e_flags & 0x00000100)
     strcat (buf, ", 32bitmode");

   if (e_flags & 0x00000400)
     strcat (buf, ", nan2008");

   if (e_flags & 0x00000200)
     strcat (buf, ", fp64");

   switch ((e_flags & 0x00FF0000))
     {
     case 0x00810000: strcat (buf, ", 3900"); break;
     case 0x00820000: strcat (buf, ", 4010"); break;
     case 0x00830000: strcat (buf, ", 4100"); break;
     case 0x00880000: strcat (buf, ", 4111"); break;
     case 0x00870000: strcat (buf, ", 4120"); break;
     case 0x00850000: strcat (buf, ", 4650"); break;
     case 0x00910000: strcat (buf, ", 5400"); break;
     case 0x00980000: strcat (buf, ", 5500"); break;
     case 0x00920000: strcat (buf, ", 5900"); break;
     case 0x008a0000: strcat (buf, ", sb1"); break;
     case 0x00990000: strcat (buf, ", 9000"); break;
       case 0x00A00000: strcat (buf, ", loongson-2e"); break;
       case 0x00A10000: strcat (buf, ", loongson-2f"); break;
     case 0x00A20000: strcat (buf, ", gs464"); break;
     case 0x00A30000: strcat (buf, ", gs464e"); break;
     case 0x00A40000: strcat (buf, ", gs264e"); break;
     case 0x008b0000: strcat (buf, ", octeon"); break;
     case 0x008d0000: strcat (buf, ", octeon2"); break;
     case 0x008e0000: strcat (buf, ", octeon3"); break;
     case 0x008c0000: strcat (buf, ", xlr"); break;
     case 0x00930000: strcat (buf, ", interaptiv-mr2"); break;
     case 0x00840000: strcat(buf, ", allegrex"); break;
     case 0:



       break;
     default: strcat (buf, gettext (", unknown CPU")); break;
     }

   switch ((e_flags & 0x0000F000))
     {
     case 0x00001000: strcat (buf, ", o32"); break;
     case 0x00002000: strcat (buf, ", o64"); break;
     case 0x00003000: strcat (buf, ", eabi32"); break;
     case 0x00004000: strcat (buf, ", eabi64"); break;
     case 0:




       break;
     default: strcat (buf, gettext (", unknown ABI")); break;
     }

   if (e_flags & 0x08000000)
     strcat (buf, ", mdmx");

   if (e_flags & 0x04000000)
     strcat (buf, ", mips16");

   if (e_flags & 0x02000000)
     strcat (buf, ", micromips");

   switch ((e_flags & 0xf0000000))
     {
     case 0x00000000: strcat (buf, ", mips1"); break;
     case 0x10000000: strcat (buf, ", mips2"); break;
     case 0x20000000: strcat (buf, ", mips3"); break;
     case 0x30000000: strcat (buf, ", mips4"); break;
     case 0x40000000: strcat (buf, ", mips5"); break;
     case 0x50000000: strcat (buf, ", mips32"); break;
     case 0x70000000: strcat (buf, ", mips32r2"); break;
     case 0x90000000: strcat (buf, ", mips32r6"); break;
     case 0x60000000: strcat (buf, ", mips64"); break;
     case 0x80000000: strcat (buf, ", mips64r2"); break;
     case 0xa0000000: strcat (buf, ", mips64r6"); break;
     default: strcat (buf, gettext (", unknown ISA")); break;
     }
   break;

 case 167:
   decode_NDS32_machine_flags (e_flags, buf, sizeof buf);
   break;

 case 250:
   switch ((((e_flags) >> 8) & 0xFFFF))
     {
     case 0x3200:
       strcat (buf, ", NFP-32xx");
       break;
     case 0x6000:
       strcat (buf, ", NFP-6xxx");
       break;
     }
   break;

 case 243:
   if (e_flags & 0x0001)
     strcat (buf, ", RVC");

   if (e_flags & 0x0008)
     strcat (buf, ", RVE");

   if (e_flags & 0x0010)
     strcat (buf, ", TSO");

   switch (e_flags & 0x0006)
     {
     case 0x0000:
       strcat (buf, ", soft-float ABI");
       break;

     case 0x0002:
       strcat (buf, ", single-float ABI");
       break;

     case 0x0004:
       strcat (buf, ", double-float ABI");
       break;

     case 0x0006:
       strcat (buf, ", quad-float ABI");
       break;
     }
   break;

 case 42:
   switch ((e_flags & 0x1f))
     {
     case 1: strcat (buf, ", sh1"); break;
     case 2: strcat (buf, ", sh2"); break;
     case 3: strcat (buf, ", sh3"); break;
     case 4: strcat (buf, ", sh-dsp"); break;
     case 5: strcat (buf, ", sh3-dsp"); break;
     case 6: strcat (buf, ", sh4al-dsp"); break;
     case 8: strcat (buf, ", sh3e"); break;
     case 9: strcat (buf, ", sh4"); break;
     case 10: strcat (buf, ", sh5"); break;
     case 11: strcat (buf, ", sh2e"); break;
     case 12: strcat (buf, ", sh4a"); break;
     case 13: strcat (buf, ", sh2a"); break;
     case 16: strcat (buf, ", sh4-nofpu"); break;
     case 17: strcat (buf, ", sh4a-nofpu"); break;
     case 19: strcat (buf, ", sh2a-nofpu"); break;
     case 20: strcat (buf, ", sh3-nommu"); break;
     case 18: strcat (buf, ", sh4-nommu-nofpu"); break;
     case 21: strcat (buf, ", sh2a-nofpu-or-sh4-nommu-nofpu"); break;
     case 22: strcat (buf, ", sh2a-nofpu-or-sh3-nommu"); break;
     case 23: strcat (buf, ", sh2a-or-sh4"); break;
     case 24: strcat (buf, ", sh2a-or-sh3e"); break;
     default: strcat (buf, gettext (", unknown ISA")); break;
     }

   if (e_flags & 0x100)
     strcat (buf, ", pic");

   if (e_flags & 0x8000)
     strcat (buf, ", fdpic");
   break;

        case 92:
          if (e_flags & (1UL << 0))
            strcat (buf, ", no delay");
          break;

 case 43:
   if (e_flags & 0x000100)
     strcat (buf, ", v8+");

   if (e_flags & 0x000200)
     strcat (buf, ", ultrasparcI");

   if (e_flags & 0x000800)
     strcat (buf, ", ultrasparcIII");

   if (e_flags & 0x000400)
     strcat (buf, ", halr1");

   if (e_flags & 0x800000)
     strcat (buf, ", ledata");

   if ((e_flags & 0x3) == 0x0)
     strcat (buf, ", tso");

   if ((e_flags & 0x3) == 0x1)
     strcat (buf, ", pso");

   if ((e_flags & 0x3) == 0x2)
     strcat (buf, ", rmo");
   break;

 case 15:
   switch (e_flags & 0x0000ffff)
     {
     case 0x020b:
       strcpy (buf, ", PA-RISC 1.0");
       break;
     case 0x0210:
       strcpy (buf, ", PA-RISC 1.1");
       break;
     case 0x0214:
       strcpy (buf, ", PA-RISC 2.0");
       break;
     default:
       break;
     }
   if (e_flags & 0x00010000)
     strcat (buf, ", trapnil");
   if (e_flags & 0x00020000)
     strcat (buf, ", ext");
   if (e_flags & 0x00040000)
     strcat (buf, ", lsb");
   if (e_flags & 0x00080000)
     strcat (buf, ", wide");
   if (e_flags & 0x00100000)
     strcat (buf, ", no kabp");
   if (e_flags & 0x00400000)
     strcat (buf, ", lazyswap");
   break;

 case 91:
 case 99:
   if ((e_flags & 0x00000010) == 0x00000010)
     strcat (buf, ", new calling convention");

   if ((e_flags & 0x00000020) == 0x00000020)
     strcat (buf, ", gnu calling convention");
   break;

 case 50:
   if ((e_flags & (1 << 4)))
     strcat (buf, ", 64-bit");
   else
     strcat (buf, ", 32-bit");
   if ((e_flags & (1 << 5)))
     strcat (buf, ", reduced fp model");
   if ((e_flags & (1 << 7)))
     strcat (buf, ", no function descriptors, constant gp");
   else if ((e_flags & (1 << 6)))
     strcat (buf, ", constant gp");
   if ((e_flags & (1 << 8)))
     strcat (buf, ", absolute");
          if (filedata->file_header.e_ident[7] == 13)
            {
              if ((e_flags & 0x04))
                strcat (buf, ", vms_linkages");
              switch ((e_flags & 0x03))
                {
                case 0:
                  break;
                case 1:
                  strcat (buf, ", warning");
                  break;
                case 2:
                  strcat (buf, ", error");
                  break;
                case 3:
                  strcat (buf, ", abort");
                  break;
                default:
    warn (gettext ("Unrecognised IA64 VMS Command Code: %x\n"),
   e_flags & 0x03);
    strcat (buf, ", <unknown>");
                }
            }
   break;

 case 75:
   if ((e_flags & 0x0001))
     strcat (buf, ", non-PIC");
   if ((e_flags & 0x0100))
     strcat (buf, ", D-Float");
   if ((e_flags & 0x0200))
     strcat (buf, ", G-Float");
   break;

        case 221:
   if (e_flags & 0x01)
     strcat (buf, ", mcm");
   else if (e_flags & 0x02)
     strcat (buf, ", mcm24");
   if (e_flags & 0x04)
     strcat (buf, ", gr6");
   break;

 case 197:
   switch (e_flags & 0x0c)
     {
     case 0x00: break;
     case 0x04: strcat (buf, ", G10"); break;
     case 0x08: strcat (buf, ", G13"); break;
     case 0x0c: strcat (buf, ", G14"); break;
     }
   if (e_flags & (1 << 0))
     strcat (buf, ", 64-bit doubles");
   break;

 case 173:
   if (e_flags & (1 << 0))
     strcat (buf, ", 64-bit doubles");
   if (e_flags & (1 << 1))
     strcat (buf, ", dsp");
   if (e_flags & (1 << 2))
     strcat (buf, ", pid");
   if (e_flags & (1 << 3))
     strcat (buf, ", RX ABI");
   if (e_flags & (1 << 6))
     strcat (buf, e_flags & (1 << 7)
      ? ", uses String instructions" : ", bans String instructions");
   if (e_flags & (1 << 8))
     strcat (buf, ", V2");
   if (e_flags & (1 << 9))
     strcat (buf, ", V3");
   break;

 case 22:
   if (e_flags & 0x00000001)
     strcat (buf, ", highgprs");
   break;

 case 140:
   if ((e_flags & 0x1))
     strcat (buf, ", relocatable module");
   break;

 case 105:
   strcat (buf, gettext (": architecture variant: "));
   switch (e_flags & 0xff)
     {
     case 11: strcat (buf, "MSP430x11"); break;
     case 110 : strcat (buf, "MSP430x11x1 "); break;
     case 12: strcat (buf, "MSP430x12"); break;
     case 13: strcat (buf, "MSP430x13"); break;
     case 14: strcat (buf, "MSP430x14"); break;
     case 15: strcat (buf, "MSP430x15"); break;
     case 16: strcat (buf, "MSP430x16"); break;
     case 31: strcat (buf, "MSP430x31"); break;
     case 32: strcat (buf, "MSP430x32"); break;
     case 33: strcat (buf, "MSP430x33"); break;
     case 41: strcat (buf, "MSP430x41"); break;
     case 42: strcat (buf, "MSP430x42"); break;
     case 43: strcat (buf, "MSP430x43"); break;
     case 44: strcat (buf, "MSP430x44"); break;
     case 45 : strcat (buf, "MSP430X"); break;
     default:
       strcat (buf, gettext (": unknown")); break;
     }

   if (e_flags & ~ 0xff)
     strcat (buf, gettext (": unknown extra flag bits also present"));
   break;

 case 220:
   switch (e_flags & 0xff)
     {
     case 0x01: strcat (buf, ", Z80"); break;
     case 0x02: strcat (buf, ", Z180"); break;
     case 0x03: strcat (buf, ", R800"); break;
     case 0x04: strcat (buf, ", EZ80"); break;
     case 0x84: strcat (buf, ", EZ80, ADL"); break;
     case 0x05: strcat (buf, ", GBZ80"); break;
     case 0x06: strcat (buf, ", Z80N"); break;
     default:
       strcat (buf, gettext (", unknown")); break;
     }
   break;
 case 258:
   if (((0x7 & (e_flags)) == 0x1))
     strcat (buf, ", SOFT-FLOAT");
   else if (((0x7 & (e_flags)) == 0x2))
     strcat (buf, ", SINGLE-FLOAT");
   else if (((0x7 & (e_flags)) == 0x3))
     strcat (buf, ", DOUBLE-FLOAT");

   if ((!(0xC0 & (e_flags))))
     strcat (buf, ", OBJ-v0");
   else if (((0xC0 & (e_flags)) == 0x40))
     strcat (buf, ", OBJ-v1");

   break;
 }
    }

  return buf;
}

static const char *
get_osabi_name (Filedata * filedata, unsigned int osabi)
{
  static char buff[32];

  switch (osabi)
    {
    case 0: return "UNIX - System V";
    case 1: return "UNIX - HP-UX";
    case 2: return "UNIX - NetBSD";
    case 3: return "UNIX - GNU";
    case 6: return "UNIX - Solaris";
    case 7: return "UNIX - AIX";
    case 8: return "UNIX - IRIX";
    case 9: return "UNIX - FreeBSD";
    case 10: return "UNIX - TRU64";
    case 11: return "Novell - Modesto";
    case 12: return "UNIX - OpenBSD";
    case 13: return "VMS - OpenVMS";
    case 14: return "HP - Non-Stop Kernel";
    case 15: return "AROS";
    case 16: return "FenixOS";
    case 17: return "Nuxi CloudABI";
    case 18: return "Stratus Technologies OpenVOS";
    default:
      if (osabi >= 64)
 switch (filedata->file_header.e_machine)
   {
   case 224:
     switch (osabi)
       {
       case 64: return "AMD HSA";
       case 65: return "AMD PAL";
       case 66: return "AMD Mesa3D";
       default:
  break;
       }
     break;

   case 40:
     switch (osabi)
       {
       case 97: return "ARM";
       case 65: return "ARM FDPIC";
       default:
  break;
       }
     break;

   case 105:
   case 0x1059:
   case 221:
     switch (osabi)
       {
       case 255: return gettext ("Standalone App");
       default:
  break;
       }
     break;

   case 140:
     switch (osabi)
       {
       case 64: return gettext ("Bare-metal C6000");
       case 65: return "Linux C6000";
       default:
  break;
       }
     break;

   default:
     break;
   }
      snprintf (buff, sizeof (buff), gettext ("<unknown: %x>"), osabi);
      return buff;
    }
}

static const char *
get_aarch64_segment_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 0): return "AARCH64_ARCHEXT";
    case (0x70000000 + 0x2): return "AARCH64_MEMTAG_MTE";
    default: return 
# 4500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    ((void *)0)
# 4500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        ;
    }
}

static const char *
get_arm_segment_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 1): return "EXIDX";
    default: return 
# 4510 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             ((void *)0)
# 4510 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 ;
    }
}

static const char *
get_s390_segment_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 0): return "S390_PGSTE";
    default: return 
# 4520 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 4520 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  ;
    }
}

static const char *
get_mips_segment_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000000: return "REGINFO";
    case 0x70000001: return "RTPROC";
    case 0x70000002: return "OPTIONS";
    case 0x70000003: return "ABIFLAGS";
    default: return 
# 4533 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 4533 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      ;
    }
}

static const char *
get_parisc_segment_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000000: return "PARISC_ARCHEXT";
    case 0x70000001: return "PARISC_UNWIND";
    case 0x70000002: return "PARISC_WEAKORDER";
    default: return 
# 4545 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 4545 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ;
    }
}

static const char *
get_ia64_segment_type (unsigned long type)
{
  switch (type)
    {
    case (0x70000000 + 0): return "IA_64_ARCHEXT";
    case (0x70000000 + 1): return "IA_64_UNWIND";
    default: return 
# 4556 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 4556 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ;
    }
}

static const char *
get_tic6x_segment_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000000: return "C6000_PHATTR";
    default: return 
# 4566 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 ((void *)0)
# 4566 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ;
    }
}

static const char *
get_riscv_segment_type (unsigned long type)
{
  switch (type)
    {
    case 0x70000003: return "RISCV_ATTRIBUTES";
    default: return 
# 4576 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    ((void *)0)
# 4576 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        ;
    }
}

static const char *
get_hpux_segment_type (unsigned long type, unsigned e_machine)
{
  if (e_machine == 15)
    switch (type)
      {
      case (0x60000000 + 0x0): return "HP_TLS";
      case (0x60000000 + 0x1): return "HP_CORE_NONE";
      case (0x60000000 + 0x2): return "HP_CORE_VERSION";
      case (0x60000000 + 0x3): return "HP_CORE_KERNEL";
      case (0x60000000 + 0x4): return "HP_CORE_COMM";
      case (0x60000000 + 0x5): return "HP_CORE_PROC";
      case (0x60000000 + 0x6): return "HP_CORE_LOADABLE";
      case (0x60000000 + 0x7): return "HP_CORE_STACK";
      case (0x60000000 + 0x8): return "HP_CORE_SHM";
      case (0x60000000 + 0x9): return "HP_CORE_MMF";
      case (0x60000000 + 0x10): return "HP_PARALLEL";
      case (0x60000000 + 0x11): return "HP_FASTBIND";
      case (0x60000000 + 0x12): return "HP_OPT_ANNOT";
      case (0x60000000 + 0x13): return "HP_HSL_ANNOT";
      case (0x60000000 + 0x14): return "HP_STACK";
      case (0x60000000 + 0x15): return "HP_CORE_UTSNAME";
      default: return 
# 4602 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 4602 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
      }

  if (e_machine == 50)
    switch (type)
      {
      case (0x60000000 + 0x0): return "HP_TLS";
      case (0x60000000 + 0x12): return "HP_OPT_ANNOT";
      case (0x60000000 + 0x13): return "HP_HSL_ANNOT";
      case (0x60000000 + 0x14): return "HP_STACK";
      default: return 
# 4612 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 4612 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
      }

  return 
# 4615 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 4615 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_solaris_segment_type (unsigned long type)
{
  switch (type)
    {
    case 0x6464e550: return "PT_SUNW_UNWIND";
    case 0x6474e550: return "PT_SUNW_EH_FRAME";
    case 0x6ffffff7: return "PT_LOSUNW";
    case 0x6ffffffa: return "PT_SUNWBSS";
    case 0x6ffffffb: return "PT_SUNWSTACK";
    case 0x6ffffffc: return "PT_SUNWDTRACE";
    case 0x6ffffffd: return "PT_SUNWCAP";
    case 0x6fffffff: return "PT_HISUNW";
    default: return 
# 4631 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 4631 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
    }
}

static const char *
get_segment_type (Filedata * filedata, unsigned long p_type)
{
  static char buff[32];

  switch (p_type)
    {
    case 0: return "NULL";
    case 1: return "LOAD";
    case 2: return "DYNAMIC";
    case 3: return "INTERP";
    case 4: return "NOTE";
    case 5: return "SHLIB";
    case 6: return "PHDR";
    case 7: return "TLS";
    case (0x60000000 + 0x474e550): return "GNU_EH_FRAME";
    case (0x60000000 + 0x474e551): return "GNU_STACK";
    case (0x60000000 + 0x474e552): return "GNU_RELRO";
    case (0x60000000 + 0x474e553): return "GNU_PROPERTY";
    case (0x60000000 + 0x474e554): return "GNU_SFRAME";

    case (0x60000000 + 0x5a3dbe5): return "OPENBSD_MUTABLE";
    case (0x60000000 + 0x5a3dbe6): return "OPENBSD_RANDOMIZE";
    case (0x60000000 + 0x5a3dbe7): return "OPENBSD_WXNEEDED";
    case (0x60000000 + 0x5a41be6): return "OPENBSD_BOOTDATA";

    default:
      if ((p_type >= 0x70000000) && (p_type <= 0x7FFFFFFF))
 {
   const char * result;

   switch (filedata->file_header.e_machine)
     {
     case 183:
       result = get_aarch64_segment_type (p_type);
       break;
     case 40:
       result = get_arm_segment_type (p_type);
       break;
     case 8:
     case 10:
       result = get_mips_segment_type (p_type);
       break;
     case 15:
       result = get_parisc_segment_type (p_type);
       break;
     case 50:
       result = get_ia64_segment_type (p_type);
       break;
     case 140:
       result = get_tic6x_segment_type (p_type);
       break;
     case 22:
     case 0xa390:
       result = get_s390_segment_type (p_type);
       break;
     case 243:
       result = get_riscv_segment_type (p_type);
       break;
     default:
       result = 
# 4695 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 4695 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
       break;
     }

   if (result != 
# 4699 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 4699 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     return result;

   sprintf (buff, "LOPROC+%#lx", p_type - 0x70000000);
 }
      else if ((p_type >= 0x60000000) && (p_type <= 0x6fffffff))
 {
   const char * result = 
# 4706 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 4706 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;

   switch (filedata->file_header.e_ident[7])
     {
     case 3:
     case 9:
       if (p_type >= (0x60000000 + 0x474e555) && p_type <= ((0x60000000 + 0x474e555) + 4096 - 1))
  {
    sprintf (buff, "GNU_MBIND+%#lx", p_type - (0x60000000 + 0x474e555));
    result = buff;
  }
       break;
     case 1:
       result = get_hpux_segment_type (p_type,
           filedata->file_header.e_machine);
       break;
     case 6:
       result = get_solaris_segment_type (p_type);
       break;
     default:
       break;
     }
   if (result != 
# 4728 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 4728 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     return result;

   sprintf (buff, "LOOS+%#lx", p_type - 0x60000000);
 }
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %lx"), p_type);

      return buff;
    }
}

static const char *
get_arc_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000001: return "ARC_ATTRIBUTES";
    default:
      break;
    }
  return 
# 4749 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 4749 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_mips_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000000: return "MIPS_LIBLIST";
    case 0x70000001: return "MIPS_MSYM";
    case 0x70000002: return "MIPS_CONFLICT";
    case 0x70000003: return "MIPS_GPTAB";
    case 0x70000004: return "MIPS_UCODE";
    case 0x70000005: return "MIPS_DEBUG";
    case 0x70000006: return "MIPS_REGINFO";
    case 0x70000007: return "MIPS_PACKAGE";
    case 0x70000008: return "MIPS_PACKSYM";
    case 0x70000009: return "MIPS_RELD";
    case 0x7000000b: return "MIPS_IFACE";
    case 0x7000000c: return "MIPS_CONTENT";
    case 0x7000000d: return "MIPS_OPTIONS";
    case 0x70000010: return "MIPS_SHDR";
    case 0x70000011: return "MIPS_FDESC";
    case 0x70000012: return "MIPS_EXTSYM";
    case 0x70000013: return "MIPS_DENSE";
    case 0x70000014: return "MIPS_PDESC";
    case 0x70000015: return "MIPS_LOCSYM";
    case 0x70000016: return "MIPS_AUXSYM";
    case 0x70000017: return "MIPS_OPTSYM";
    case 0x70000018: return "MIPS_LOCSTR";
    case 0x70000019: return "MIPS_LINE";
    case 0x7000001a: return "MIPS_RFDESC";
    case 0x7000001b: return "MIPS_DELTASYM";
    case 0x7000001c: return "MIPS_DELTAINST";
    case 0x7000001d: return "MIPS_DELTACLASS";
    case 0x7000001e: return "MIPS_DWARF";
    case 0x7000001f: return "MIPS_DELTADECL";
    case 0x70000020: return "MIPS_SYMBOL_LIB";
    case 0x70000021: return "MIPS_EVENTS";
    case 0x70000022: return "MIPS_TRANSLATE";
    case 0x70000023: return "MIPS_PIXIE";
    case 0x70000024: return "MIPS_XLATE";
    case 0x70000025: return "MIPS_XLATE_DEBUG";
    case 0x70000026: return "MIPS_WHIRL";
    case 0x70000027: return "MIPS_EH_REGION";
    case 0x70000028: return "MIPS_XLATE_OLD";
    case 0x70000029: return "MIPS_PDR_EXCEPTION";
    case 0x7000002a: return "MIPS_ABIFLAGS";
    case 0x7000002b: return "MIPS_XHASH";
    default:
      break;
    }
  return 
# 4801 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 4801 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_parisc_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000000: return "PARISC_EXT";
    case 0x70000001: return "PARISC_UNWIND";
    case 0x70000002: return "PARISC_DOC";
    case 0x70000003: return "PARISC_ANNOT";
    case 0x70000000 + 8: return "PARISC_SYMEXTN";
    case 0x70000000 + 9: return "PARISC_STUBS";
    case 0x70000004: return "PARISC_DLKM";
    default: return 
# 4816 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 4816 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    ;
    }
}

static const char *
get_ia64_section_type_name (Filedata * filedata, unsigned int sh_type)
{

  if ((sh_type & 0xFF000000) == (0x70000000 + 0x8000000))
    return get_osabi_name (filedata, (sh_type & 0x00FF0000) >> 16);

  switch (sh_type)
    {
    case (0x70000000 + 0): return "IA_64_EXT";
    case (0x70000000 + 1): return "IA_64_UNWIND";
    case (0x70000000 + 0x9000000): return "IA_64_PRIORITY_INIT";
    case 0x60000000: return "VMS_TRACE";
    case 0x60000001: return "VMS_TIE_SIGNATURES";
    case 0x60000002: return "VMS_DEBUG";
    case 0x60000003: return "VMS_DEBUG_STR";
    case 0x60000004: return "VMS_LINKAGES";
    case 0x60000005: return "VMS_SYMBOL_VECTOR";
    case 0x60000006: return "VMS_FIXUP";
    default:
      break;
    }
  return 
# 4842 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 4842 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_x86_64_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000001: return "X86_64_UNWIND";
    default: return 
# 4851 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 4851 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
    }
}

static const char *
get_aarch64_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000003: return "AARCH64_ATTRIBUTES";
    default: return 
# 4861 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 4861 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
    }
}

static const char *
get_arm_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000001: return "ARM_EXIDX";
    case 0x70000002: return "ARM_PREEMPTMAP";
    case 0x70000003: return "ARM_ATTRIBUTES";
    case 0x70000004: return "ARM_DEBUGOVERLAY";
    case 0x70000005: return "ARM_OVERLAYSECTION";
    default: return 
# 4875 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 4875 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
    }
}

static const char *
get_tic6x_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000001: return "C6000_UNWIND";
    case 0x70000002: return "C6000_PREEMPTMAP";
    case 0x70000003: return "C6000_ATTRIBUTES";
    case 0x7F000000: return "TI_ICODE";
    case 0x7F000001: return "TI_XREF";
    case 0x7F000002: return "TI_HANDLER";
    case 0x7F000003: return "TI_INITINFO";
    case 0x7F000004: return "TI_PHATTRS";
    default: return 
# 4892 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 4892 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ;
    }
}

static const char *
get_msp430_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x7f000005: return "MSP430_SEC_FLAGS";
    case 0x7f000006: return "MSP430_SYM_ALIASES";
    case 0x70000003: return "MSP430_ATTRIBUTES";
    default: return 
# 4904 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                        ((void *)0)
# 4904 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                            ;
    }
}

static const char *
get_nfp_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case (0x70000000 + 1): return "NFP_MECONFIG";
    case (0x70000000 + 2): return "NFP_INITREG";
    case 0x80000000: return "NFP_UDEBUG";
    default: return 
# 4916 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 4916 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
    }
}

static const char *
get_v850_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000000: return "V850 Small Common";
    case 0x70000001: return "V850 Tiny Common";
    case 0x70000002: return "V850 Zero Common";
    case 0x80000000: return "RENESAS IOP";
    case 0xa0000000: return "RENESAS INFO";
    default: return 
# 4930 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 4930 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      ;
    }
}

static const char *
get_riscv_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000003: return "RISCV_ATTRIBUTES";
    default: return 
# 4940 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 4940 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
    }
}

static const char *
get_csky_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case 0x70000001: return "CSKY_ATTRIBUTES";
    default: return 
# 4950 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 4950 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;
    }
}

static const char *
get_section_type_name (Filedata * filedata, unsigned int sh_type)
{
  static char buff[32];
  const char * result;

  switch (sh_type)
    {
    case 0: return "NULL";
    case 1: return "PROGBITS";
    case 2: return "SYMTAB";
    case 3: return "STRTAB";
    case 4: return "RELA";
    case 19: return "RELR";
    case 5: return "HASH";
    case 6: return "DYNAMIC";
    case 7: return "NOTE";
    case 8: return "NOBITS";
    case 9: return "REL";
    case 10: return "SHLIB";
    case 11: return "DYNSYM";
    case 14: return "INIT_ARRAY";
    case 15: return "FINI_ARRAY";
    case 16: return "PREINIT_ARRAY";
    case 0x6ffffff6: return "GNU_HASH";
    case 17: return "GROUP";
    case 18: return "SYMTAB SECTION INDICES";
    case 0x6ffffffd: return "VERDEF";
    case 0x6ffffffe: return "VERNEED";
    case 0x6fffffff: return "VERSYM";
    case 0x6ffffff0: return "VERSYM";
    case 0x6ffffffc: return "VERDEF";
    case 0x7ffffffd: return "AUXILIARY";
    case 0x7fffffff: return "FILTER";
    case 0x6ffffff7: return "GNU_LIBLIST";

    default:
      if ((sh_type >= 0x70000000) && (sh_type <= 0x7FFFFFFF))
 {
   switch (filedata->file_header.e_machine)
     {
     case 45:
     case 93:
     case 195:
     case 255:
     case 253:
       result = get_arc_section_type_name (sh_type);
       break;
     case 8:
     case 10:
       result = get_mips_section_type_name (sh_type);
       break;
     case 15:
       result = get_parisc_section_type_name (sh_type);
       break;
     case 50:
       result = get_ia64_section_type_name (filedata, sh_type);
       break;
     case 62:
     case 180:
     case 181:
       result = get_x86_64_section_type_name (sh_type);
       break;
     case 183:
       result = get_aarch64_section_type_name (sh_type);
       break;
     case 40:
       result = get_arm_section_type_name (sh_type);
       break;
     case 140:
       result = get_tic6x_section_type_name (sh_type);
       break;
     case 105:
       result = get_msp430_section_type_name (sh_type);
       break;
     case 250:
       result = get_nfp_section_type_name (sh_type);
       break;
     case 36:
     case 87:
     case 0x9080:
       result = get_v850_section_type_name (sh_type);
       break;
     case 243:
       result = get_riscv_section_type_name (sh_type);
       break;
     case 252:
       result = get_csky_section_type_name (sh_type);
       break;
     default:
       result = 
# 5044 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 5044 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
       break;
     }

   if (result != 
# 5048 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5048 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     return result;

   sprintf (buff, "LOPROC+%#x", sh_type - 0x70000000);
 }
      else if ((sh_type >= 0x60000000) && (sh_type <= 0x6fffffff))
 {
   switch (filedata->file_header.e_machine)
     {
     case 50:
       result = get_ia64_section_type_name (filedata, sh_type);
       break;
     default:
       if (filedata->file_header.e_ident[7] == 6)
  result = get_solaris_section_type (sh_type);
       else
  {
    switch (sh_type)
      {
      case 0x6fff4700: result = "GNU_INCREMENTAL_INPUTS"; break;
      case 0x6ffffff5: result = "GNU_ATTRIBUTES"; break;
      case 0x6ffffff6: result = "GNU_HASH"; break;
      case 0x6ffffff7: result = "GNU_LIBLIST"; break;
      default:
        result = 
# 5072 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5072 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
        break;
      }
  }
       break;
     }

   if (result != 
# 5079 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5079 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     return result;

   sprintf (buff, "LOOS+%#x", sh_type - 0x60000000);
 }
      else if ((sh_type >= 0x80000000) && (sh_type <= 0xFFFFFFFF))
 {
   switch (filedata->file_header.e_machine)
     {
     case 36:
     case 87:
     case 0x9080:
       result = get_v850_section_type_name (sh_type);
       break;
     default:
       result = 
# 5094 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 5094 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
       break;
     }

   if (result != 
# 5098 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5098 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     return result;

   sprintf (buff, "LOUSER+%#x", sh_type - 0x80000000);
 }
      else


 snprintf (buff, sizeof (buff), gettext ("%08x: <unknown>"), sh_type);

      return buff;
    }
}

enum long_option_values
{
  OPTION_DEBUG_DUMP = 512,
  OPTION_DYN_SYMS,
  OPTION_LTO_SYMS,
  OPTION_DWARF_DEPTH,
  OPTION_DWARF_START,
  OPTION_DWARF_CHECK,
  OPTION_CTF_DUMP,
  OPTION_CTF_PARENT,
  OPTION_CTF_SYMBOLS,
  OPTION_CTF_STRINGS,
  OPTION_SFRAME_DUMP,
  OPTION_WITH_SYMBOL_VERSIONS,
  OPTION_RECURSE_LIMIT,
  OPTION_NO_RECURSE_LIMIT,
  OPTION_NO_DEMANGLING,
  OPTION_SYM_BASE
};

static struct option options[] =
{


  {"arch-specific", 0, 0, 'A'},
  {"all", 0, 0, 'a'},
  {"demangle", 2, 0, 'C'},
  {"archive-index", 0, 0, 'c'},
  {"use-dynamic", 0, 0, 'D'},
  {"dynamic", 0, 0, 'd'},
  {"headers", 0, 0, 'e'},
  {"section-groups", 0, 0, 'g'},
  {"help", 0, 0, 'H'},
  {"file-header", 0, 0, 'h'},
  {"histogram", 0, 0, 'I'},
  {"lint", 0, 0, 'L'},
  {"enable-checks", 0, 0, 'L'},
  {"program-headers", 0, 0, 'l'},
  {"segments", 0, 0, 'l'},
  {"full-section-name",0, 0, 'N'},
  {"notes", 0, 0, 'n'},
  {"process-links", 0, 0, 'P'},
  {"string-dump", 1, 0, 'p'},
  {"relocated-dump", 1, 0, 'R'},
  {"relocs", 0, 0, 'r'},
  {"section-headers", 0, 0, 'S'},
  {"sections", 0, 0, 'S'},
  {"symbols", 0, 0, 's'},
  {"syms", 0, 0, 's'},
  {"silent-truncation",0, 0, 'T'},
  {"section-details", 0, 0, 't'},
  {"unicode", 1, 
# 5163 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         ((void *)0)
# 5163 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             , 'U'},
  {"unwind", 0, 0, 'u'},
  {"version-info", 0, 0, 'V'},
  {"version", 0, 0, 'v'},
  {"wide", 0, 0, 'W'},
  {"hex-dump", 1, 0, 'x'},
  {"decompress", 0, 0, 'z'},

  {"no-demangle", 0, 0, OPTION_NO_DEMANGLING},
  {"recurse-limit", 0, 
# 5172 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   ((void *)0)
# 5172 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       , OPTION_RECURSE_LIMIT},
  {"no-recurse-limit", 0, 
# 5173 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   ((void *)0)
# 5173 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       , OPTION_NO_RECURSE_LIMIT},
  {"no-recursion-limit", 0, 
# 5174 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
# 5174 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         , OPTION_NO_RECURSE_LIMIT},
  {"dyn-syms", 0, 0, OPTION_DYN_SYMS},
  {"lto-syms", 0, 0, OPTION_LTO_SYMS},
  {"debug-dump", 2, 0, OPTION_DEBUG_DUMP},
  {"dwarf-depth", 1, 0, OPTION_DWARF_DEPTH},
  {"dwarf-start", 1, 0, OPTION_DWARF_START},
  {"dwarf-check", 0, 0, OPTION_DWARF_CHECK},

  {"ctf", 1, 0, OPTION_CTF_DUMP},
  {"ctf-symbols", 1, 0, OPTION_CTF_SYMBOLS},
  {"ctf-strings", 1, 0, OPTION_CTF_STRINGS},
  {"ctf-parent", 1, 0, OPTION_CTF_PARENT},

  {"sframe", 2, 0, OPTION_SFRAME_DUMP},
  {"sym-base", 2, 0, OPTION_SYM_BASE},

  {0, 0, 0, 0}
};

static void
usage (FILE * stream)
{
  fprintf (stream, gettext ("Usage: readelf <option(s)> elf-file(s)\n"));
  fprintf (stream, gettext (" Display information about the contents of ELF format files\n"));
  fprintf (stream, gettext (" Options are:\n"));
  fprintf (stream, gettext ("  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n")
                                                                      );
  fprintf (stream, gettext ("  -h --file-header       Display the ELF file header\n")
                                                        );
  fprintf (stream, gettext ("  -l --program-headers   Display the program headers\n")
                                                        );
  fprintf (stream, gettext ("     --segments          An alias for --program-headers\n")
                                                           );
  fprintf (stream, gettext ("  -S --section-headers   Display the sections' header\n")
                                                         );
  fprintf (stream, gettext ("     --sections          An alias for --section-headers\n")
                                                           );
  fprintf (stream, gettext ("  -g --section-groups    Display the section groups\n")
                                                       );
  fprintf (stream, gettext ("  -t --section-details   Display the section details\n")
                                                        );
  fprintf (stream, gettext ("  -e --headers           Equivalent to: -h -l -S\n")
                                                    );
  fprintf (stream, gettext ("  -s --syms              Display the symbol table\n")
                                                     );
  fprintf (stream, gettext ("     --symbols           An alias for --syms\n")
                                                );
  fprintf (stream, gettext ("     --dyn-syms          Display the dynamic symbol table\n")
                                                             );
  fprintf (stream, gettext ("     --lto-syms          Display LTO symbol tables\n")
                                                      );
  fprintf (stream, gettext ("     --sym-base=[0|8|10|16] \n                         Force base for symbol sizes.  The options are \n                         mixed (the default), octal, decimal, hexadecimal.\n")


                                                                              );
  fprintf (stream, gettext ("  -C --demangle[=STYLE]  Decode mangled/processed symbol names\n")
                                                                  );
  display_demangler_styles (stream, gettext ("                           STYLE can be ")
                                          );
  fprintf (stream, gettext ("     --no-demangle       Do not demangle low-level symbol names.  (default)\n")
                                                                               );
  fprintf (stream, gettext ("     --recurse-limit     Enable a demangling recursion limit.  (default)\n")
                                                                            );
  fprintf (stream, gettext ("     --no-recurse-limit  Disable a demangling recursion limit\n")
                                                                 );
  fprintf (stream, gettext ("     -U[dlexhi] --unicode=[default|locale|escape|hex|highlight|invalid]\n                         Display unicode characters as determined by the current locale\n                          (default), escape sequences, \"<hex sequences>\", highlighted\n                          escape sequences, or treat them as invalid and display as\n                          \"{hex sequences}\"\n")




                                                 );
  fprintf (stream, gettext ("  -n --notes             Display the core notes (if present)\n")
                                                                );
  fprintf (stream, gettext ("  -r --relocs            Display the relocations (if present)\n")
                                                                 );
  fprintf (stream, gettext ("  -u --unwind            Display the unwind info (if present)\n")
                                                                 );
  fprintf (stream, gettext ("  -d --dynamic           Display the dynamic section (if present)\n")
                                                                     );
  fprintf (stream, gettext ("  -V --version-info      Display the version sections (if present)\n")
                                                                      );
  fprintf (stream, gettext ("  -A --arch-specific     Display architecture specific information (if any)\n")
                                                                               );
  fprintf (stream, gettext ("  -c --archive-index     Display the symbol/file index in an archive\n")
                                                                        );
  fprintf (stream, gettext ("  -D --use-dynamic       Use the dynamic section info when displaying symbols\n")
                                                                                 );
  fprintf (stream, gettext ("  -L --lint|--enable-checks\n                         Display warning messages for possible problems\n")

                                                                           );
  fprintf (stream, gettext ("  -x --hex-dump=<number|name>\n                         Dump the contents of section <number|name> as bytes\n")

                                                                                );
  fprintf (stream, gettext ("  -p --string-dump=<number|name>\n                         Dump the contents of section <number|name> as strings\n")

                                                                                  );
  fprintf (stream, gettext ("  -R --relocated-dump=<number|name>\n                         Dump the relocated contents of section <number|name>\n")

                                                                                 );
  fprintf (stream, gettext ("  -z --decompress        Decompress section before dumping it\n")
                                                                 );
  fprintf (stream, gettext ("  -w --debug-dump[a/=abbrev, A/=addr, r/=aranges, c/=cu_index, L/=decodedline,\n                  f/=frames, F/=frames-interp, g/=gdb_index, i/=info, o/=loc,\n                  m/=macro, p/=pubnames, t/=pubtypes, R/=Ranges, l/=rawline,\n                  s/=str, O/=str-offsets, u/=trace_abbrev, T/=trace_aranges,\n                  U/=trace_info]\n                         Display the contents of DWARF debug sections\n")





                                                                         );
  fprintf (stream, gettext ("  -wk --debug-dump=links Display the contents of sections that link to separate\n                          debuginfo files\n")

                                             );
  fprintf (stream, gettext ("  -P --process-links     Display the contents of non-debug sections in separate\n                          debuginfo files.  (Implies -wK)\n")

                                                             );

  fprintf (stream, gettext ("  -wK --debug-dump=follow-links\n                         Follow links to separate debug info files (default)\n")

                                                                                );
  fprintf (stream, gettext ("  -wN --debug-dump=no-follow-links\n                         Do not follow links to separate debug info files\n")

                                                                             );
# 5312 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  fprintf (stream, gettext ("  --dwarf-depth=N        Do not display DIEs at depth N or greater\n")
                                                                      );
  fprintf (stream, gettext ("  --dwarf-start=N        Display DIEs starting at offset N\n")
                                                              );

  fprintf (stream, gettext ("  --ctf=<number|name>    Display CTF info from section <number|name>\n")
                                                                        );
  fprintf (stream, gettext ("  --ctf-parent=<name>    Use CTF archive member <name> as the CTF parent\n")
                                                                            );
  fprintf (stream, gettext ("  --ctf-symbols=<number|name>\n                         Use section <number|name> as the CTF external symtab\n")

                                                                                 );
  fprintf (stream, gettext ("  --ctf-strings=<number|name>\n                         Use section <number|name> as the CTF external strtab\n")

                                                                                 );

  fprintf (stream, gettext ("  --sframe[=NAME]        Display SFrame info from section NAME, (default '.sframe')\n")
                                                                                       );






  fprintf (stream, gettext ("  -I --histogram         Display histogram of bucket list lengths\n")
                                                                     );
  fprintf (stream, gettext ("  -W --wide              Allow output width to exceed 80 characters\n")
                                                                       );
  fprintf (stream, gettext ("  -T --silent-truncation If a symbol name is truncated, do not add [...] suffix\n")
                                                                                   );
  fprintf (stream, gettext ("  @<file>                Read options from <file>\n")
                                                     );
  fprintf (stream, gettext ("  -H --help              Display this information\n")
                                                     );
  fprintf (stream, gettext ("  -v --version           Display the version number of readelf\n")
                                                                  );

  if ("<https://sourceware.org/bugzilla/>"[0] && stream == 
# 5349 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    stdout
# 5349 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          )
    fprintf (
# 5350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            stdout
# 5350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  , gettext ("Report bugs to %s\n"), "<https://sourceware.org/bugzilla/>");

  exit (stream == 
# 5352 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout 
# 5352 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ? 0 : 1);
}






static void
request_dump_bynumber (struct dump_data *dumpdata,
         unsigned int section, dump_type type)
{
  if (section >= dumpdata->num_dump_sects)
    {
      dump_type * new_dump_sects;

      new_dump_sects = (dump_type *) calloc (section + 1,
                                             sizeof (* new_dump_sects));

      if (new_dump_sects == 
# 5371 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 5371 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               )
 error (gettext ("Out of memory allocating dump request table.\n"));
      else
 {
   if (dumpdata->dump_sects)
     {

       memcpy (new_dump_sects, dumpdata->dump_sects,
        dumpdata->num_dump_sects * sizeof (* new_dump_sects));

       free (dumpdata->dump_sects);
     }

   dumpdata->dump_sects = new_dump_sects;
   dumpdata->num_dump_sects = section + 1;
 }
    }

  if (dumpdata->dump_sects)
    dumpdata->dump_sects[section] |= type;
}



static void
request_dump_byname (const char * section, dump_type type)
{
  struct dump_list_entry * new_request;

  new_request = (struct dump_list_entry *)
      malloc (sizeof (struct dump_list_entry));
  if (!new_request)
    error (gettext ("Out of memory allocating dump request table.\n"));

  new_request->name = strdup (section);
  if (!new_request->name)
    error (gettext ("Out of memory allocating dump request table.\n"));

  new_request->type = type;

  new_request->next = dump_sects_byname;
  dump_sects_byname = new_request;
}

static inline void
request_dump (struct dump_data *dumpdata, dump_type type)
{
  int section;
  char * cp;

  do_dump = 
# 5421 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 5421 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
  section = strtoul (optarg, & cp, 0);

  if (! *cp && section >= 0)
    request_dump_bynumber (dumpdata, section, type);
  else
    request_dump_byname (optarg, type);
}

static void
parse_args (struct dump_data *dumpdata, int argc, char ** argv)
{
  int c;

  if (argc < 2)
    usage (
# 5436 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          stderr
# 5436 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                );

  while ((c = getopt_long
   (argc, argv, "ACDHILNPR:STU:VWacdeghi:lnp:rstuvw::x:z", options, 
# 5439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                   ((void *)0)
# 5439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                       )) != 
# 5439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                             (-1)
# 5439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                )
    {
      switch (c)
 {
 case 0:

   break;
 case 'H':
   usage (
# 5447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         stdout
# 5447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               );
   break;

 case 'a':
   do_syms = 
# 5451 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 5451 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
   do_reloc = 
# 5452 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 5452 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
   do_unwind = 
# 5453 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 5453 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
   do_dynamic = 
# 5454 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 5454 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
   do_header = 
# 5455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 5455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
   do_sections = 
# 5456 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5456 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   do_section_groups = 
# 5457 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      1
# 5457 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
   do_segments = 
# 5458 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5458 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   do_version = 
# 5459 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 5459 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
   do_histogram = 
# 5460 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 1
# 5460 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;
   do_arch = 
# 5461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 5461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
   do_notes = 
# 5462 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 5462 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
   break;

 case 'g':
   do_section_groups = 
# 5466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      1
# 5466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
   break;
 case 't':
 case 'N':
   do_sections = 
# 5470 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5470 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   do_section_details = 
# 5471 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       1
# 5471 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
   break;
 case 'e':
   do_header = 
# 5474 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 5474 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
   do_sections = 
# 5475 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5475 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   do_segments = 
# 5476 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5476 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   break;
 case 'A':
   do_arch = 
# 5479 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 5479 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
   break;
 case 'D':
   do_using_dynamic = 
# 5482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     1
# 5482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
   break;
 case 'r':
   do_reloc = 
# 5485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 5485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
   break;
 case 'u':
   do_unwind = 
# 5488 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 5488 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
   break;
 case 'h':
   do_header = 
# 5491 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 5491 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
   break;
 case 'l':
   do_segments = 
# 5494 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5494 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   break;
 case 's':
   do_syms = 
# 5497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 5497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
   break;
 case 'S':
   do_sections = 
# 5500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   break;
 case 'd':
   do_dynamic = 
# 5503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 5503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
   break;
 case 'I':
   do_histogram = 
# 5506 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 1
# 5506 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;
   break;
 case 'n':
   do_notes = 
# 5509 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 5509 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
   break;
 case 'c':
   do_archive_index = 
# 5512 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     1
# 5512 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
   break;
 case 'L':
   do_checks = 
# 5515 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 5515 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
   break;
 case 'P':
   process_links = 
# 5518 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  1
# 5518 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;
   do_follow_links = 
# 5519 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    1
# 5519 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;
   dump_any_debugging = 
# 5520 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       1
# 5520 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
   break;
 case 'x':
   request_dump (dumpdata, (1 << 0));
   break;
 case 'p':
   request_dump (dumpdata, (1 << 3));
   break;
 case 'R':
   request_dump (dumpdata, (1 << 4));
   break;
 case 'z':
   decompress_dumps = 
# 5532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     1
# 5532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
   break;
 case 'w':
   if (optarg == 
# 5535 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5535 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     {
       do_debugging = 
# 5537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     1
# 5537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
       do_dump = 
# 5538 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5538 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
       dump_any_debugging = 
# 5539 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           1
# 5539 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
       dwarf_select_sections_all ();
     }
   else
     {
       do_debugging = 
# 5544 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     0
# 5544 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
       if (dwarf_select_sections_by_letters (optarg))
  {
    do_dump = 
# 5547 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 5547 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    dump_any_debugging = 
# 5548 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        1
# 5548 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
  }
     }
   break;
 case OPTION_DEBUG_DUMP:
   if (optarg == 
# 5553 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5553 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     {
       do_dump = 
# 5555 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5555 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
       do_debugging = 
# 5556 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     1
# 5556 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
       dump_any_debugging = 
# 5557 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           1
# 5557 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
       dwarf_select_sections_all ();
     }
   else
     {
       do_debugging = 
# 5562 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     0
# 5562 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
       if (dwarf_select_sections_by_names (optarg))
  {
    do_dump = 
# 5565 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 5565 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    dump_any_debugging = 
# 5566 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        1
# 5566 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
  }
     }
   break;
 case OPTION_DWARF_DEPTH:
   {
     char *cp;

     dwarf_cutoff_level = strtoul (optarg, & cp, 0);
   }
   break;
 case OPTION_DWARF_START:
   {
     char *cp;

     dwarf_start_die = strtoul (optarg, & cp, 0);
   }
   break;
 case OPTION_DWARF_CHECK:
   dwarf_check = 
# 5585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   break;
 case OPTION_CTF_DUMP:
   do_ctf = 
# 5588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 5588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   request_dump (dumpdata, (1 << 5));
   break;
 case OPTION_CTF_SYMBOLS:
   free (dump_ctf_symtab_name);
   dump_ctf_symtab_name = strdup (optarg);
   break;
 case OPTION_CTF_STRINGS:
   free (dump_ctf_strtab_name);
   dump_ctf_strtab_name = strdup (optarg);
   break;
 case OPTION_CTF_PARENT:
   free (dump_ctf_parent_name);
   dump_ctf_parent_name = strdup (optarg);
   break;
 case OPTION_SFRAME_DUMP:
   do_sframe = 
# 5604 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 5604 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;


   if (optarg != 
# 5607 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5607 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     request_dump (dumpdata, (1 << 6));
   else
     {
       do_dump = 
# 5611 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5611 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
       const char *sframe_sec_name = strdup (".sframe");
       request_dump_byname (sframe_sec_name, (1 << 6));
     }
   break;
 case OPTION_DYN_SYMS:
   do_dyn_syms = 
# 5617 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5617 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   break;
 case OPTION_LTO_SYMS:
   do_lto_syms = 
# 5620 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5620 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   break;





 case 'v':
   print_version (program_name);
   break;
 case 'V':
   do_version = 
# 5631 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 5631 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
   break;
 case 'W':
   do_wide = 
# 5634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 5634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
   break;
 case 'T':
   do_not_show_symbol_truncation = 
# 5637 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  1
# 5637 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      ;
   break;
 case 'C':
   do_demangle = 
# 5640 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5640 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
   if (optarg != 
# 5641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     {
       enum demangling_styles style;

       style = cplus_demangle_name_to_style (optarg);
       if (style == unknown_demangling)
  error (gettext ("unknown demangling style `%s'"), optarg);

       cplus_demangle_set_style (style);
     }
   break;
 case OPTION_NO_DEMANGLING:
   do_demangle = 
# 5653 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                0
# 5653 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;
   break;
 case OPTION_RECURSE_LIMIT:
   demangle_flags &= ~ (1 << 18);
   break;
 case OPTION_NO_RECURSE_LIMIT:
   demangle_flags |= (1 << 18);
   break;
 case OPTION_WITH_SYMBOL_VERSIONS:

   break;

 case 'U':
   if (optarg == 
# 5666 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5666 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     error (gettext ("Missing arg to -U/--unicode"));
   else if ((strcmp ((optarg), ("default")) == 0) || (strcmp ((optarg), ("d")) == 0))
     unicode_display = unicode_default;
   else if ((strcmp ((optarg), ("locale")) == 0) || (strcmp ((optarg), ("l")) == 0))
     unicode_display = unicode_locale;
   else if ((strcmp ((optarg), ("escape")) == 0) || (strcmp ((optarg), ("e")) == 0))
     unicode_display = unicode_escape;
   else if ((strcmp ((optarg), ("invalid")) == 0) || (strcmp ((optarg), ("i")) == 0))
     unicode_display = unicode_invalid;
   else if ((strcmp ((optarg), ("hex")) == 0) || (strcmp ((optarg), ("x")) == 0))
     unicode_display = unicode_hex;
   else if ((strcmp ((optarg), ("highlight")) == 0) || (strcmp ((optarg), ("h")) == 0))
     unicode_display = unicode_highlight;
   else
     error (gettext ("invalid argument to -U/--unicode: %s"), optarg);
   break;

 case OPTION_SYM_BASE:
   sym_base = 0;
   if (optarg != 
# 5686 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 5686 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     {
       sym_base = strtoul (optarg, 
# 5688 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 5688 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      , 0);
       switch (sym_base)
  {
    case 0:
    case 8:
    case 10:
    case 16:
      break;

    default:
      sym_base = 0;
      break;
  }
     }
   break;

 default:

   error (gettext ("Invalid option '-%c'\n"), c);

 case '?':
   usage (
# 5709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         stderr
# 5709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               );
 }
    }

  if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
      && !do_segments && !do_header && !do_dump && !do_version
      && !do_histogram && !do_debugging && !do_arch && !do_notes
      && !do_section_groups && !do_archive_index
      && !do_dyn_syms && !do_lto_syms)
    {
      if (do_checks)
 {
   check_all = 
# 5721 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 5721 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
   do_dynamic = do_syms = do_reloc = do_unwind = do_sections = 
# 5722 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                              1
# 5722 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                  ;
   do_segments = do_header = do_dump = do_version = 
# 5723 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                   1
# 5723 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                       ;
   do_histogram = do_debugging = do_arch = do_notes = 
# 5724 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                     1
# 5724 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                         ;
   do_section_groups = do_archive_index = do_dyn_syms = 
# 5725 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                       1
# 5725 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                           ;
   do_lto_syms = 
# 5726 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                1
# 5726 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
 }
      else
 usage (
# 5729 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       stderr
# 5729 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             );
    }
}

static const char *
get_elf_class (unsigned int elf_class)
{
  static char buff[32];

  switch (elf_class)
    {
    case 0: return gettext ("none");
    case 1: return "ELF32";
    case 2: return "ELF64";
    default:
      snprintf (buff, sizeof (buff), gettext ("<unknown: %x>"), elf_class);
      return buff;
    }
}

static const char *
get_data_encoding (unsigned int encoding)
{
  static char buff[32];

  switch (encoding)
    {
    case 0: return gettext ("none");
    case 1: return gettext ("2's complement, little endian");
    case 2: return gettext ("2's complement, big endian");
    default:
      snprintf (buff, sizeof (buff), gettext ("<unknown: %x>"), encoding);
      return buff;
    }
}

static 
# 5765 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 5766 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
check_magic_number (Filedata * filedata, Elf_Internal_Ehdr * header)
{
  if (header->e_ident[0] == 0x7F
      && header->e_ident[1] == 'E'
      && header->e_ident[2] == 'L'
      && header->e_ident[3] == 'F')
    return 
# 5772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 5772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
# 5782 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  static struct
  {
    unsigned char magic[4];
    const char * obj_message;
    const char * ar_message;
  }
  known_magic[] =
  {
    { { 'B', 'C', 0xc0, 0xde },
      ("This is a LLVM bitcode file - try using llvm-bcanalyzer\n"),
      ("This is a LLVM bitcode file - try extracing and then using llvm-bcanalyzer\n")
    },
    { { 'g', 'o', ' ', 'o' },
      ("This is a GO binary file - try using 'go tool objdump' or 'go tool nm'\n"),
      
# 5796 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ((void *)0)
    
# 5797 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
   }
  };
  int i;

  for (i = (sizeof (known_magic) / sizeof ((known_magic)[0])); i--;)
    {
      if (header->e_ident[0] == known_magic[i].magic[0]
   && header->e_ident[1] == known_magic[i].magic[1]
   && header->e_ident[2] == known_magic[i].magic[2]
   && header->e_ident[3] == known_magic[i].magic[3])
 {


   if (filedata->archive_file_size > 0
       && known_magic[i].ar_message != 
# 5811 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 5811 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          )
     error ("%s", known_magic[i].ar_message);
   else
     error ("%s", known_magic[i].obj_message);
   return 
# 5815 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 5815 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }
    }

  error (gettext ("Not an ELF file - it has the wrong magic bytes at the start\n"));
  return 
# 5820 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 5820 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}



static 
# 5825 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 5826 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_file_header (Filedata * filedata)
{
  Elf_Internal_Ehdr * header = & filedata->file_header;

  if (! check_magic_number (filedata, header))
    return 
# 5831 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 5831 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (! filedata->is_separate)
    init_dwarf_regnames_by_elf_machine_code (header->e_machine);

  if (do_header)
    {
      unsigned i;

      if (filedata->is_separate)
 printf (gettext ("ELF Header in linked file '%s':\n"), filedata->file_name);
      else
 printf (gettext ("ELF Header:\n"));
      printf (gettext ("  Magic:   "));
      for (i = 0; i < 16; i++)
 printf ("%2.2x ", header->e_ident[i]);
      printf ("\n");
      printf (gettext ("  Class:                             %s\n"),
       get_elf_class (header->e_ident[4]));
      printf (gettext ("  Data:                              %s\n"),
       get_data_encoding (header->e_ident[5]));
      printf (gettext ("  Version:                           %d%s\n"),
       header->e_ident[6],
       (header->e_ident[6] == 1
        ? gettext (" (current)")
        : (header->e_ident[6] != 0
    ? gettext (" <unknown>")
    : "")));
      printf (gettext ("  OS/ABI:                            %s\n"),
       get_osabi_name (filedata, header->e_ident[7]));
      printf (gettext ("  ABI Version:                       %d\n"),
       header->e_ident[8]);
      printf (gettext ("  Type:                              %s\n"),
       get_file_type (filedata));
      printf (gettext ("  Machine:                           %s\n"),
       get_machine_name (header->e_machine));
      printf (gettext ("  Version:                           0x%lx\n"),
       header->e_version);

      printf (gettext ("  Entry point address:               "));
      print_vma (header->e_entry, PREFIX_HEX);
      printf (gettext ("\n  Start of program headers:          "));
      print_vma (header->e_phoff, DEC);
      printf (gettext (" (bytes into file)\n  Start of section headers:          "));
      print_vma (header->e_shoff, DEC);
      printf (gettext (" (bytes into file)\n"));

      printf (gettext ("  Flags:                             0x%lx%s\n"),
       header->e_flags,
       get_machine_flags (filedata, header->e_flags, header->e_machine));
      printf (gettext ("  Size of this header:               %u (bytes)\n"),
       header->e_ehsize);
      printf (gettext ("  Size of program headers:           %u (bytes)\n"),
       header->e_phentsize);
      printf (gettext ("  Number of program headers:         %u"),
       header->e_phnum);
      if (filedata->section_headers != 
# 5887 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
   
# 5888 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  && header->e_phnum == 0xffff
   && filedata->section_headers[0].sh_info != 0)
 printf (" (%u)", filedata->section_headers[0].sh_info);
      putc ('\n', 
# 5891 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout
# 5891 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
      printf (gettext ("  Size of section headers:           %u (bytes)\n"),
       header->e_shentsize);
      printf (gettext ("  Number of section headers:         %u"),
       header->e_shnum);
      if (filedata->section_headers != 
# 5896 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0) 
# 5896 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           && header->e_shnum == 0)
 {
   header->e_shnum = filedata->section_headers[0].sh_size;
   printf (" (%u)", header->e_shnum);
 }
      putc ('\n', 
# 5901 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout
# 5901 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
      printf (gettext ("  Section header string table index: %u"),
       header->e_shstrndx);
      if (filedata->section_headers != 
# 5904 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
   
# 5905 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  && header->e_shstrndx == ((-0x1u) & 0xffff))
 {
   header->e_shstrndx = filedata->section_headers[0].sh_link;
   printf (" (%u)", header->e_shstrndx);
 }
      if (header->e_shstrndx != 0
   && header->e_shstrndx >= header->e_shnum)
 {
   header->e_shstrndx = 0;
   printf (gettext (" <corrupt: out of range>"));
 }
      putc ('\n', 
# 5916 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout
# 5916 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
    }

  if (filedata->section_headers != 
# 5919 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 5919 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    {
      if (header->e_phnum == 0xffff
   && filedata->section_headers[0].sh_info != 0)
 {

   free (filedata->program_headers);
   filedata->program_headers = 
# 5926 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 5926 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  ;
   header->e_phnum = filedata->section_headers[0].sh_info;
 }
      if (header->e_shnum == 0)
 header->e_shnum = filedata->section_headers[0].sh_size;
      if (header->e_shstrndx == ((-0x1u) & 0xffff))
 header->e_shstrndx = filedata->section_headers[0].sh_link;
      if (header->e_shstrndx >= header->e_shnum)
 header->e_shstrndx = 0;
    }

  return 
# 5937 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 5937 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}




static 
# 5943 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 5944 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_32bit_program_headers (Filedata * filedata, Elf_Internal_Phdr * pheaders)
{
  Elf32_External_Phdr * phdrs;
  Elf32_External_Phdr * external;
  Elf_Internal_Phdr * internal;
  unsigned int i;
  unsigned int size = filedata->file_header.e_phentsize;
  unsigned int num = filedata->file_header.e_phnum;


  if (size == 0 || num == 0)
    return 
# 5955 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 5955 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
  if (size < sizeof * phdrs)
    {
      error (gettext ("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
      return 
# 5959 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 5959 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
  if (size > sizeof * phdrs)
    warn (gettext ("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));

  phdrs = (Elf32_External_Phdr *) get_data (
# 5964 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           ((void *)0)
# 5964 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                               , filedata, filedata->file_header.e_phoff,
                                            size, num, gettext ("program headers"));
  if (phdrs == 
# 5966 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 5966 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )
    return 
# 5967 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 5967 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  for (i = 0, internal = pheaders, external = phdrs;
       i < filedata->file_header.e_phnum;
       i++, internal++, external++)
    {
      internal->p_type = byte_get (external->p_type, sizeof (external->p_type));
      internal->p_offset = byte_get (external->p_offset, sizeof (external->p_offset));
      internal->p_vaddr = byte_get (external->p_vaddr, sizeof (external->p_vaddr));
      internal->p_paddr = byte_get (external->p_paddr, sizeof (external->p_paddr));
      internal->p_filesz = byte_get (external->p_filesz, sizeof (external->p_filesz));
      internal->p_memsz = byte_get (external->p_memsz, sizeof (external->p_memsz));
      internal->p_flags = byte_get (external->p_flags, sizeof (external->p_flags));
      internal->p_align = byte_get (external->p_align, sizeof (external->p_align));
    }

  free (phdrs);
  return 
# 5984 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 5984 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}




static 
# 5990 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 5991 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_64bit_program_headers (Filedata * filedata, Elf_Internal_Phdr * pheaders)
{
  Elf64_External_Phdr * phdrs;
  Elf64_External_Phdr * external;
  Elf_Internal_Phdr * internal;
  unsigned int i;
  unsigned int size = filedata->file_header.e_phentsize;
  unsigned int num = filedata->file_header.e_phnum;


  if (size == 0 || num == 0)
    return 
# 6002 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 6002 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
  if (size < sizeof * phdrs)
    {
      error (gettext ("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
      return 
# 6006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 6006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
  if (size > sizeof * phdrs)
    warn (gettext ("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));

  phdrs = (Elf64_External_Phdr *) get_data (
# 6011 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           ((void *)0)
# 6011 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                               , filedata, filedata->file_header.e_phoff,
                                            size, num, gettext ("program headers"));
  if (!phdrs)
    return 
# 6014 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 6014 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  for (i = 0, internal = pheaders, external = phdrs;
       i < filedata->file_header.e_phnum;
       i++, internal++, external++)
    {
      internal->p_type = byte_get (external->p_type, sizeof (external->p_type));
      internal->p_flags = byte_get (external->p_flags, sizeof (external->p_flags));
      internal->p_offset = byte_get (external->p_offset, sizeof (external->p_offset));
      internal->p_vaddr = byte_get (external->p_vaddr, sizeof (external->p_vaddr));
      internal->p_paddr = byte_get (external->p_paddr, sizeof (external->p_paddr));
      internal->p_filesz = byte_get (external->p_filesz, sizeof (external->p_filesz));
      internal->p_memsz = byte_get (external->p_memsz, sizeof (external->p_memsz));
      internal->p_align = byte_get (external->p_align, sizeof (external->p_align));
    }

  free (phdrs);
  return 
# 6031 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 6031 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}



static 
# 6036 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 6037 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_program_headers (Filedata * filedata)
{
  Elf_Internal_Phdr * phdrs;


  if (filedata->program_headers != 
# 6042 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 6042 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    return 
# 6043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 6043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;



  if (filedata->file_header.e_phnum
      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
      >= filedata->file_size)
    {
      error (gettext ("Too many program headers - %#x - the file is not that big\n"),
      filedata->file_header.e_phnum);
      return 
# 6053 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 6053 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  phdrs = (Elf_Internal_Phdr *) cmalloc (filedata->file_header.e_phnum,
      sizeof (Elf_Internal_Phdr));
  if (phdrs == 
# 6058 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 6058 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )
    {
      error (gettext ("Out of memory reading %u program headers\n"),
      filedata->file_header.e_phnum);
      return 
# 6062 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 6062 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  if (is_32bit_elf
      ? get_32bit_program_headers (filedata, phdrs)
      : get_64bit_program_headers (filedata, phdrs))
    {
      filedata->program_headers = phdrs;
      return 
# 6070 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 6070 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  free (phdrs);
  return 
# 6074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 6074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}



static void
process_program_headers (Filedata * filedata)
{
  Elf_Internal_Phdr * segment;
  unsigned int i;
  Elf_Internal_Phdr * previous_load = 
# 6084 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
# 6084 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         ;

  if (filedata->file_header.e_phnum == 0)
    {

      if (filedata->file_header.e_phoff != 0)
 warn (gettext ("possibly corrupt ELF header - it has a non-zero program" " header offset, but no program headers\n")
                                             );
      else if (do_segments)
 {
   if (filedata->is_separate)
     printf (gettext ("\nThere are no program headers in linked file '%s'.\n"),
      filedata->file_name);
   else
     printf (gettext ("\nThere are no program headers in this file.\n"));
 }
      goto no_headers;
    }

  if (do_segments && !do_header)
    {
      if (filedata->is_separate)
 printf ("\nIn linked file '%s' the ELF file type is %s\n",
  filedata->file_name, get_file_type (filedata));
      else
 printf (gettext ("\nElf file type is %s\n"), get_file_type (filedata));
      printf (gettext ("Entry point 0x%" 
# 6110 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "x" 
# 6110 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             "\n"),
       filedata->file_header.e_entry);
      printf (ngettext ("There is %d program header,"
   " starting at offset %" 
# 6113 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          "l" "u" 
# 6113 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 "\n",
   "There are %d program headers,"
   " starting at offset %" 
# 6115 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          "l" "u" 
# 6115 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 "\n",
   filedata->file_header.e_phnum),
       filedata->file_header.e_phnum,
       filedata->file_header.e_phoff);
    }

  if (! get_program_headers (filedata))
    goto no_headers;

  if (do_segments)
    {
      if (filedata->file_header.e_phnum > 1)
 printf (gettext ("\nProgram Headers:\n"));
      else
 printf (gettext ("\nProgram Headers:\n"));

      if (is_32bit_elf)
 printf
   (gettext ("  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"));
      else if (do_wide)
 printf
   (gettext ("  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n"));
      else
 {
   printf
     (gettext ("  Type           Offset             VirtAddr           PhysAddr\n"));
   printf
     (gettext ("                 FileSiz            MemSiz              Flags  Align\n"));
 }
    }

  uint64_t dynamic_addr = 0;
  uint64_t dynamic_size = 0;
  for (i = 0, segment = filedata->program_headers;
       i < filedata->file_header.e_phnum;
       i++, segment++)
    {
      if (do_segments)
 {
   printf ("  %-14.14s ", get_segment_type (filedata, segment->p_type));

   if (is_32bit_elf)
     {
       printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
       printf ("0x%8.8lx ", (unsigned long) segment->p_vaddr);
       printf ("0x%8.8lx ", (unsigned long) segment->p_paddr);
       printf ("0x%5.5lx ", (unsigned long) segment->p_filesz);
       printf ("0x%5.5lx ", (unsigned long) segment->p_memsz);
       printf ("%c%c%c ",
        (segment->p_flags & (1 << 2) ? 'R' : ' '),
        (segment->p_flags & (1 << 1) ? 'W' : ' '),
        (segment->p_flags & (1 << 0) ? 'E' : ' '));
       printf ("%#lx", (unsigned long) segment->p_align);
     }
   else if (do_wide)
     {
       if ((unsigned long) segment->p_offset == segment->p_offset)
  printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
       else
  {
    print_vma (segment->p_offset, FULL_HEX);
    putchar (' ');
  }

       print_vma (segment->p_vaddr, FULL_HEX);
       putchar (' ');
       print_vma (segment->p_paddr, FULL_HEX);
       putchar (' ');

       if ((unsigned long) segment->p_filesz == segment->p_filesz)
  printf ("0x%6.6lx ", (unsigned long) segment->p_filesz);
       else
  {
    print_vma (segment->p_filesz, FULL_HEX);
    putchar (' ');
  }

       if ((unsigned long) segment->p_memsz == segment->p_memsz)
  printf ("0x%6.6lx", (unsigned long) segment->p_memsz);
       else
  {
    print_vma (segment->p_memsz, FULL_HEX);
  }

       printf (" %c%c%c ",
        (segment->p_flags & (1 << 2) ? 'R' : ' '),
        (segment->p_flags & (1 << 1) ? 'W' : ' '),
        (segment->p_flags & (1 << 0) ? 'E' : ' '));

       if ((unsigned long) segment->p_align == segment->p_align)
  printf ("%#lx", (unsigned long) segment->p_align);
       else
  {
    print_vma (segment->p_align, PREFIX_HEX);
  }
     }
   else
     {
       print_vma (segment->p_offset, FULL_HEX);
       putchar (' ');
       print_vma (segment->p_vaddr, FULL_HEX);
       putchar (' ');
       print_vma (segment->p_paddr, FULL_HEX);
       printf ("\n                 ");
       print_vma (segment->p_filesz, FULL_HEX);
       putchar (' ');
       print_vma (segment->p_memsz, FULL_HEX);
       printf ("  %c%c%c    ",
        (segment->p_flags & (1 << 2) ? 'R' : ' '),
        (segment->p_flags & (1 << 1) ? 'W' : ' '),
        (segment->p_flags & (1 << 0) ? 'E' : ' '));
       print_vma (segment->p_align, PREFIX_HEX);
     }

   putc ('\n', 
# 6229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              stdout
# 6229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    );
 }

      switch (segment->p_type)
 {
 case 1:







   if (segment->p_memsz < segment->p_filesz)
     error (gettext ("the segment's file size is larger than its memory size\n"));
   previous_load = segment;
   break;

 case 6:

   if (i > 0 && previous_load != 
# 6249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 6249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    )
     error (gettext ("the PHDR segment must occur before any LOAD segment\n"));
   if (filedata->file_header.e_machine != 15)
     {
       unsigned int j;

       for (j = 1; j < filedata->file_header.e_phnum; j++)
  {
    Elf_Internal_Phdr *load = filedata->program_headers + j;
    if (load->p_type == 1
        && load->p_offset <= segment->p_offset
        && (load->p_offset + load->p_filesz
     >= segment->p_offset + segment->p_filesz)
        && load->p_vaddr <= segment->p_vaddr
        && (load->p_vaddr + load->p_filesz
     >= segment->p_vaddr + segment->p_filesz))
      break;
  }
       if (j == filedata->file_header.e_phnum)
  error (gettext ("the PHDR segment is not covered by a LOAD segment\n"));
     }
   break;

 case 2:
   if (dynamic_addr)
     error (gettext ("more than one dynamic segment\n"));



   dynamic_addr = segment->p_offset;
   dynamic_size = segment->p_filesz;



   if (filedata->section_headers != 
# 6283 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   ((void *)0)
# 6283 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       )
     {
       Elf_Internal_Shdr * sec;

       sec = find_section (filedata, ".dynamic");
       if (sec == 
# 6288 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0) 
# 6288 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      || sec->sh_size == 0)
  {


    if (!is_ia64_vms (filedata))
      error (gettext ("no .dynamic section in the dynamic segment\n"));
    break;
  }

       if (sec->sh_type == 8)
  {
    dynamic_addr = 0;
    dynamic_size = 0;
    break;
  }

       dynamic_addr = sec->sh_offset;
       dynamic_size = sec->sh_size;



       if (do_checks
    && (dynamic_addr != segment->p_offset
        || dynamic_size != segment->p_filesz))
  warn (gettext ("the .dynamic section is not the same as the dynamic segment\n")
                                                               );
     }





   if (dynamic_addr > filedata->file_size
       || (dynamic_size > filedata->file_size - dynamic_addr))
     {
       error (gettext ("the dynamic segment offset + size exceeds the size of the file\n"));
       dynamic_addr = 0;
       dynamic_size = 0;
     }
   break;

 case 3:
   if (segment->p_offset >= filedata->file_size
       || segment->p_filesz > filedata->file_size - segment->p_offset
       || segment->p_filesz - 1 >= (size_t) -2
       || fseek64 (filedata->handle,
     filedata->archive_file_offset + segment->p_offset,
     
# 6335 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    0
# 6335 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ))
     error (gettext ("Unable to find program interpreter name\n"));
   else
     {
       size_t len = segment->p_filesz;
       free (filedata->program_interpreter);
       filedata->program_interpreter = xmalloc (len + 1);
       len = fread (filedata->program_interpreter, 1, len,
      filedata->handle);
       filedata->program_interpreter[len] = 0;

       if (do_segments)
  printf (gettext ("      [Requesting program interpreter: %s]\n"),
      filedata->program_interpreter);
     }
   break;
 }
    }

  if (do_segments
      && filedata->section_headers != 
# 6355 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
      
# 6356 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     && filedata->string_table != 
# 6356 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 6356 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    {
      printf (gettext ("\n Section to Segment mapping:\n"));
      printf (gettext ("  Segment Sections...\n"));

      for (i = 0; i < filedata->file_header.e_phnum; i++)
 {
   unsigned int j;
   Elf_Internal_Shdr * section;

   segment = filedata->program_headers + i;
   section = filedata->section_headers + 1;

   printf ("   %2.2d     ", i);

   for (j = 1; j < filedata->file_header.e_shnum; j++, section++)
     {
       if (!(((section)->sh_flags & (1 << 10)) != 0 && (section)->sh_type == 8 && (segment)->p_type != 7)
    && ((( ((((section)->sh_flags & (1 << 10)) != 0) && ((segment)->p_type == 7 || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == 1)) || (((section)->sh_flags & (1 << 10)) == 0 && (segment)->p_type != 7 && (segment)->p_type != 6)) && !(((section)->sh_flags & (1 << 1)) == 0 && ((segment)->p_type == 1 || (segment)->p_type == 2 || (segment)->p_type == (0x60000000 + 0x474e550) || (segment)->p_type == (0x60000000 + 0x474e551) || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == (0x60000000 + 0x474e554) || ((segment)->p_type >= (0x60000000 + 0x474e555) && (segment)->p_type <= ((0x60000000 + 0x474e555) + 4096 - 1)))) && ((section)->sh_type == 8 || ((bfd_vma) (section)->sh_offset >= (segment)->p_offset && (!(1) || ((section)->sh_offset - (segment)->p_offset <= (segment)->p_filesz - 1)) && (((section)->sh_offset - (segment)->p_offset + ((((section)->sh_flags & (1 << 10)) != 0 && (section)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (section)->sh_size)) <= (segment)->p_filesz))) && (!(1) || ((section)->sh_flags & (1 << 1)) == 0 || ((section)->sh_addr >= (segment)->p_vaddr && (!(1) || ((section)->sh_addr - (segment)->p_vaddr <= (segment)->p_memsz - 1)) && (((section)->sh_addr - (segment)->p_vaddr + ((((section)->sh_flags & (1 << 10)) != 0 && (section)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (section)->sh_size)) <= (segment)->p_memsz))) && (((segment)->p_type != 2 && (segment)->p_type != 4) || (section)->sh_size != 0 || (segment)->p_memsz == 0 || (((section)->sh_type == 8 || ((bfd_vma) (section)->sh_offset > (segment)->p_offset && ((section)->sh_offset - (segment)->p_offset < (segment)->p_filesz))) && (((section)->sh_flags & (1 << 1)) == 0 || ((section)->sh_addr > (segment)->p_vaddr && ((section)->sh_addr - (segment)->p_vaddr < (segment)->p_memsz))))))))
  printf ("%s ", printable_section_name (filedata, section));
     }

   putc ('\n',
# 6378 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             stdout
# 6378 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   );
 }
    }

  filedata->dynamic_addr = dynamic_addr;
  filedata->dynamic_size = dynamic_size ? dynamic_size : 1;
  return;

 no_headers:
  filedata->dynamic_addr = 0;
  filedata->dynamic_size = 1;
}




static int64_t
offset_from_vma (Filedata * filedata, uint64_t vma, uint64_t size)
{
  Elf_Internal_Phdr * seg;

  if (! get_program_headers (filedata))
    {
      warn (gettext ("Cannot interpret virtual addresses without program headers.\n"));
      return (long) vma;
    }

  for (seg = filedata->program_headers;
       seg < filedata->program_headers + filedata->file_header.e_phnum;
       ++seg)
    {
      if (seg->p_type != 1)
 continue;

      if (vma >= (seg->p_vaddr & -seg->p_align)
   && vma + size <= seg->p_vaddr + seg->p_filesz)
 return vma - seg->p_vaddr + seg->p_offset;
    }

  warn (gettext ("Virtual address %#" 
# 6417 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       "l" "x" 
# 6417 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       " not located in any PT_LOAD segment.\n")
                                            , vma);
  return vma;
}






static 
# 6427 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 6428 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_32bit_section_headers (Filedata * filedata, 
# 6428 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               _Bool 
# 6428 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    probe)
{
  Elf32_External_Shdr * shdrs;
  Elf_Internal_Shdr * internal;
  unsigned int i;
  unsigned int size = filedata->file_header.e_shentsize;
  unsigned int num = probe ? 1 : filedata->file_header.e_shnum;


  if (size == 0 || num == 0)
    return 
# 6438 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 6438 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;




  if (filedata->file_header.e_shoff == 0)
    return 
# 6444 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 6444 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (size < sizeof * shdrs)
    {
      if (! probe)
 error (gettext ("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
      return 
# 6450 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 6450 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
  if (!probe && size > sizeof * shdrs)
    warn (gettext ("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));

  shdrs = (Elf32_External_Shdr *) get_data (
# 6455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           ((void *)0)
# 6455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                               , filedata, filedata->file_header.e_shoff,
                                            size, num,
         probe ? 
# 6457 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0) 
# 6457 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     : gettext ("section headers"));
  if (shdrs == 
# 6458 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 6458 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )
    return 
# 6459 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 6459 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  filedata->section_headers = (Elf_Internal_Shdr *)
    cmalloc (num, sizeof (Elf_Internal_Shdr));
  if (filedata->section_headers == 
# 6463 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 6463 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    {
      if (!probe)
 error (gettext ("Out of memory reading %u section headers\n"), num);
      free (shdrs);
      return 
# 6468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 6468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  for (i = 0, internal = filedata->section_headers;
       i < num;
       i++, internal++)
    {
      internal->sh_name = byte_get (shdrs[i].sh_name, sizeof (shdrs[i].sh_name));
      internal->sh_type = byte_get (shdrs[i].sh_type, sizeof (shdrs[i].sh_type));
      internal->sh_flags = byte_get (shdrs[i].sh_flags, sizeof (shdrs[i].sh_flags));
      internal->sh_addr = byte_get (shdrs[i].sh_addr, sizeof (shdrs[i].sh_addr));
      internal->sh_offset = byte_get (shdrs[i].sh_offset, sizeof (shdrs[i].sh_offset));
      internal->sh_size = byte_get (shdrs[i].sh_size, sizeof (shdrs[i].sh_size));
      internal->sh_link = byte_get (shdrs[i].sh_link, sizeof (shdrs[i].sh_link));
      internal->sh_info = byte_get (shdrs[i].sh_info, sizeof (shdrs[i].sh_info));
      internal->sh_addralign = byte_get (shdrs[i].sh_addralign, sizeof (shdrs[i].sh_addralign));
      internal->sh_entsize = byte_get (shdrs[i].sh_entsize, sizeof (shdrs[i].sh_entsize));
      if (!probe && internal->sh_link > num)
 warn (gettext ("Section %u has an out of range sh_link value of %u\n"), i, internal->sh_link);
      if (!probe && internal->sh_flags & (1 << 6) && internal->sh_info > num)
 warn (gettext ("Section %u has an out of range sh_info value of %u\n"), i, internal->sh_info);
    }

  free (shdrs);
  return 
# 6492 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 6492 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}



static 
# 6497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 6498 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_64bit_section_headers (Filedata * filedata, 
# 6498 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               _Bool 
# 6498 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    probe)
{
  Elf64_External_Shdr * shdrs;
  Elf_Internal_Shdr * internal;
  unsigned int i;
  unsigned int size = filedata->file_header.e_shentsize;
  unsigned int num = probe ? 1 : filedata->file_header.e_shnum;


  if (size == 0 || num == 0)
    return 
# 6508 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 6508 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;




  if (filedata->file_header.e_shoff == 0)
    return 
# 6514 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 6514 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (size < sizeof * shdrs)
    {
      if (! probe)
 error (gettext ("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
      return 
# 6520 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 6520 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  if (! probe && size > sizeof * shdrs)
    warn (gettext ("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));

  shdrs = (Elf64_External_Shdr *) get_data (
# 6526 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           ((void *)0)
# 6526 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                               , filedata,
         filedata->file_header.e_shoff,
                                            size, num,
         probe ? 
# 6529 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0) 
# 6529 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     : gettext ("section headers"));
  if (shdrs == 
# 6530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 6530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )
    return 
# 6531 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 6531 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  filedata->section_headers = (Elf_Internal_Shdr *)
    cmalloc (num, sizeof (Elf_Internal_Shdr));
  if (filedata->section_headers == 
# 6535 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 6535 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    {
      if (! probe)
 error (gettext ("Out of memory reading %u section headers\n"), num);
      free (shdrs);
      return 
# 6540 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 6540 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  for (i = 0, internal = filedata->section_headers;
       i < num;
       i++, internal++)
    {
      internal->sh_name = byte_get (shdrs[i].sh_name, sizeof (shdrs[i].sh_name));
      internal->sh_type = byte_get (shdrs[i].sh_type, sizeof (shdrs[i].sh_type));
      internal->sh_flags = byte_get (shdrs[i].sh_flags, sizeof (shdrs[i].sh_flags));
      internal->sh_addr = byte_get (shdrs[i].sh_addr, sizeof (shdrs[i].sh_addr));
      internal->sh_size = byte_get (shdrs[i].sh_size, sizeof (shdrs[i].sh_size));
      internal->sh_entsize = byte_get (shdrs[i].sh_entsize, sizeof (shdrs[i].sh_entsize));
      internal->sh_link = byte_get (shdrs[i].sh_link, sizeof (shdrs[i].sh_link));
      internal->sh_info = byte_get (shdrs[i].sh_info, sizeof (shdrs[i].sh_info));
      internal->sh_offset = byte_get (shdrs[i].sh_offset, sizeof (shdrs[i].sh_offset));
      internal->sh_addralign = byte_get (shdrs[i].sh_addralign, sizeof (shdrs[i].sh_addralign));
      if (!probe && internal->sh_link > num)
 warn (gettext ("Section %u has an out of range sh_link value of %u\n"), i, internal->sh_link);
      if (!probe && internal->sh_flags & (1 << 6) && internal->sh_info > num)
 warn (gettext ("Section %u has an out of range sh_info value of %u\n"), i, internal->sh_info);
    }

  free (shdrs);
  return 
# 6564 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 6564 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 6567 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 6568 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_section_headers (Filedata *filedata, 
# 6568 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                        _Bool 
# 6568 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             probe)
{
  if (filedata->section_headers != 
# 6570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 6570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    return 
# 6571 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 6571 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (is_32bit_elf)
    return get_32bit_section_headers (filedata, probe);
  else
    return get_64bit_section_headers (filedata, probe);
}

static Elf_Internal_Sym *
get_32bit_elf_symbols (Filedata *filedata,
         Elf_Internal_Shdr *section,
         uint64_t *num_syms_return)
{
  uint64_t number = 0;
  Elf32_External_Sym * esyms = 
# 6585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 6585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  ;
  Elf_External_Sym_Shndx * shndx = 
# 6586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 6586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      ;
  Elf_Internal_Sym * isyms = 
# 6587 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            ((void *)0)
# 6587 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                ;
  Elf_Internal_Sym * psym;
  unsigned int j;
  elf_section_list * entry;

  if (section->sh_size == 0)
    {
      if (num_syms_return != 
# 6594 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            ((void *)0)
# 6594 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                )
 * num_syms_return = 0;
      return 
# 6596 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 6596 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }


  if (section->sh_entsize == 0 || section->sh_entsize > section->sh_size)
    {
      error (gettext ("Section %s has an invalid sh_entsize of %#" 
# 6602 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 6602 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n"),
      printable_section_name (filedata, section),
      section->sh_entsize);
      goto exit_point;
    }

  if (section->sh_size > filedata->file_size)
    {
      error (gettext ("Section %s has an invalid sh_size of %#" 
# 6610 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 6610 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n"),
      printable_section_name (filedata, section),
      section->sh_size);
      goto exit_point;
    }

  number = section->sh_size / section->sh_entsize;

  if (number * sizeof (Elf32_External_Sym) > section->sh_size + 1)
    {
      error (gettext ("Size (%#" 
# 6620 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 6620 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ") of section %s " "is not a multiple of its sh_entsize (%#" 
# 6620 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 6620 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ")\n")
                                                               ,
      section->sh_size,
      printable_section_name (filedata, section),
      section->sh_entsize);
      goto exit_point;
    }

  esyms = (Elf32_External_Sym *) get_data (
# 6628 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
# 6628 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              , filedata, section->sh_offset, 1,
                                           section->sh_size, gettext ("symbols"));
  if (esyms == 
# 6630 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 6630 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )
    goto exit_point;

  shndx = 
# 6633 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         ((void *)0)
# 6633 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
  for (entry = filedata->symtab_shndx_list; entry != 
# 6634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                    ((void *)0)
# 6634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                        ; entry = entry->next)
    {
      if (entry->hdr->sh_link != (size_t) (section - filedata->section_headers))
 continue;

      if (shndx != 
# 6639 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 6639 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
 {
   error (gettext ("Multiple symbol table index sections associated with the same symbol section\n"));
   free (shndx);
 }

      shndx = (Elf_External_Sym_Shndx *) get_data (
# 6645 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                  ((void *)0)
# 6645 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                      , filedata,
         entry->hdr->sh_offset,
         1, entry->hdr->sh_size,
         gettext ("symbol table section indices"));
      if (shndx == 
# 6649 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 6649 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
 goto exit_point;


      if (entry->hdr->sh_size / sizeof (Elf_External_Sym_Shndx) < number)
 {
   error (gettext ("Index section %s has an sh_size of %#" 
# 6655 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "x" 
# 6655 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         " - expected %#" 
# 6655 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "x" 
# 6655 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         "\n"),
   printable_section_name (filedata, entry->hdr),
   entry->hdr->sh_size,
   section->sh_size);
   goto exit_point;
 }
    }

  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));

  if (isyms == 
# 6665 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 6665 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )
    {
      error (gettext ("Out of memory reading %" 
# 6667 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 6667 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " symbols\n"), number);
      goto exit_point;
    }

  for (j = 0, psym = isyms; j < number; j++, psym++)
    {
      psym->st_name = byte_get (esyms[j].st_name, sizeof (esyms[j].st_name));
      psym->st_value = byte_get (esyms[j].st_value, sizeof (esyms[j].st_value));
      psym->st_size = byte_get (esyms[j].st_size, sizeof (esyms[j].st_size));
      psym->st_shndx = byte_get (esyms[j].st_shndx, sizeof (esyms[j].st_shndx));
      if (psym->st_shndx == ((-0x1u) & 0xffff) && shndx != 
# 6677 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                             ((void *)0)
# 6677 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                 )
 psym->st_shndx
   = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
      else if (psym->st_shndx >= ((-0x100u) & 0xffff))
 psym->st_shndx += (-0x100u) - ((-0x100u) & 0xffff);
      psym->st_info = byte_get (esyms[j].st_info, sizeof (esyms[j].st_info));
      psym->st_other = byte_get (esyms[j].st_other, sizeof (esyms[j].st_other));
    }

 exit_point:
  free (shndx);
  free (esyms);

  if (num_syms_return != 
# 6690 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 6690 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            )
    * num_syms_return = isyms == 
# 6691 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0) 
# 6691 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ? 0 : number;

  return isyms;
}

static Elf_Internal_Sym *
get_64bit_elf_symbols (Filedata *filedata,
         Elf_Internal_Shdr *section,
         uint64_t *num_syms_return)
{
  uint64_t number = 0;
  Elf64_External_Sym * esyms = 
# 6702 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 6702 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  ;
  Elf_External_Sym_Shndx * shndx = 
# 6703 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 6703 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      ;
  Elf_Internal_Sym * isyms = 
# 6704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            ((void *)0)
# 6704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                ;
  Elf_Internal_Sym * psym;
  unsigned int j;
  elf_section_list * entry;

  if (section->sh_size == 0)
    {
      if (num_syms_return != 
# 6711 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            ((void *)0)
# 6711 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                )
 * num_syms_return = 0;
      return 
# 6713 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 6713 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }


  if (section->sh_entsize == 0 || section->sh_entsize > section->sh_size)
    {
      error (gettext ("Section %s has an invalid sh_entsize of %#" 
# 6719 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 6719 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n"),
      printable_section_name (filedata, section),
      section->sh_entsize);
      goto exit_point;
    }

  if (section->sh_size > filedata->file_size)
    {
      error (gettext ("Section %s has an invalid sh_size of %#" 
# 6727 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 6727 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n"),
      printable_section_name (filedata, section),
      section->sh_size);
      goto exit_point;
    }

  number = section->sh_size / section->sh_entsize;

  if (number * sizeof (Elf64_External_Sym) > section->sh_size + 1)
    {
      error (gettext ("Size (%#" 
# 6737 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 6737 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ") of section %s " "is not a multiple of its sh_entsize (%#" 
# 6737 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 6737 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ")\n")
                                                               ,
      section->sh_size,
      printable_section_name (filedata, section),
      section->sh_entsize);
      goto exit_point;
    }

  esyms = (Elf64_External_Sym *) get_data (
# 6745 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
# 6745 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              , filedata, section->sh_offset, 1,
                                           section->sh_size, gettext ("symbols"));
  if (!esyms)
    goto exit_point;

  shndx = 
# 6750 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         ((void *)0)
# 6750 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
  for (entry = filedata->symtab_shndx_list; entry != 
# 6751 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                    ((void *)0)
# 6751 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                        ; entry = entry->next)
    {
      if (entry->hdr->sh_link != (size_t) (section - filedata->section_headers))
 continue;

      if (shndx != 
# 6756 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 6756 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
 {
   error (gettext ("Multiple symbol table index sections associated with the same symbol section\n"));
   free (shndx);
 }

      shndx = (Elf_External_Sym_Shndx *) get_data (
# 6762 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                  ((void *)0)
# 6762 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                      , filedata,
         entry->hdr->sh_offset,
         1, entry->hdr->sh_size,
         gettext ("symbol table section indices"));
      if (shndx == 
# 6766 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 6766 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
 goto exit_point;


      if (entry->hdr->sh_size / sizeof (Elf_External_Sym_Shndx) < number)
 {
   error (gettext ("Index section %s has an sh_size of %#" 
# 6772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "x" 
# 6772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         " - expected %#" 
# 6772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "x" 
# 6772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         "\n"),
   printable_section_name (filedata, entry->hdr),
   entry->hdr->sh_size,
   section->sh_size);
   goto exit_point;
 }
    }

  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));

  if (isyms == 
# 6782 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 6782 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )
    {
      error (gettext ("Out of memory reading %" 
# 6784 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 6784 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " symbols\n"), number);
      goto exit_point;
    }

  for (j = 0, psym = isyms; j < number; j++, psym++)
    {
      psym->st_name = byte_get (esyms[j].st_name, sizeof (esyms[j].st_name));
      psym->st_info = byte_get (esyms[j].st_info, sizeof (esyms[j].st_info));
      psym->st_other = byte_get (esyms[j].st_other, sizeof (esyms[j].st_other));
      psym->st_shndx = byte_get (esyms[j].st_shndx, sizeof (esyms[j].st_shndx));

      if (psym->st_shndx == ((-0x1u) & 0xffff) && shndx != 
# 6795 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                             ((void *)0)
# 6795 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                 )
 psym->st_shndx
   = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
      else if (psym->st_shndx >= ((-0x100u) & 0xffff))
 psym->st_shndx += (-0x100u) - ((-0x100u) & 0xffff);

      psym->st_value = byte_get (esyms[j].st_value, sizeof (esyms[j].st_value));
      psym->st_size = byte_get (esyms[j].st_size, sizeof (esyms[j].st_size));
    }

 exit_point:
  free (shndx);
  free (esyms);

  if (num_syms_return != 
# 6809 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 6809 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            )
    * num_syms_return = isyms == 
# 6810 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0) 
# 6810 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ? 0 : number;

  return isyms;
}

static Elf_Internal_Sym *
get_elf_symbols (Filedata *filedata,
   Elf_Internal_Shdr *section,
   uint64_t *num_syms_return)
{
  if (is_32bit_elf)
    return get_32bit_elf_symbols (filedata, section, num_syms_return);
  else
    return get_64bit_elf_symbols (filedata, section, num_syms_return);
}

static const char *
get_elf_section_flags (Filedata * filedata, uint64_t sh_flags)
{
  static char buff[1024];
  char * p = buff;
  unsigned int field_size = is_32bit_elf ? 8 : 16;
  signed int sindex;
  unsigned int size = sizeof (buff) - (field_size + 4 + 1);
  uint64_t os_flags = 0;
  uint64_t proc_flags = 0;
  uint64_t unknown_flags = 0;
  static const struct
    {
      const char * str;
      unsigned int len;
    }
  flags [] =
    {
               { ("WRITE"), (sizeof ("WRITE") - 1) },
               { ("ALLOC"), (sizeof ("ALLOC") - 1) },
               { ("EXEC"), (sizeof ("EXEC") - 1) },
               { ("MERGE"), (sizeof ("MERGE") - 1) },
               { ("STRINGS"), (sizeof ("STRINGS") - 1) },
               { ("INFO LINK"), (sizeof ("INFO LINK") - 1) },
               { ("LINK ORDER"), (sizeof ("LINK ORDER") - 1) },
               { ("OS NONCONF"), (sizeof ("OS NONCONF") - 1) },
               { ("GROUP"), (sizeof ("GROUP") - 1) },
               { ("TLS"), (sizeof ("TLS") - 1) },

               { ("SHORT"), (sizeof ("SHORT") - 1) },
               { ("NORECOV"), (sizeof ("NORECOV") - 1) },

               { ("VMS_GLOBAL"), (sizeof ("VMS_GLOBAL") - 1) },
               { ("VMS_OVERLAID"), (sizeof ("VMS_OVERLAID") - 1) },
               { ("VMS_SHARED"), (sizeof ("VMS_SHARED") - 1) },
               { ("VMS_VECTOR"), (sizeof ("VMS_VECTOR") - 1) },
               { ("VMS_ALLOC_64BIT"), (sizeof ("VMS_ALLOC_64BIT") - 1) },
               { ("VMS_PROTECTED"), (sizeof ("VMS_PROTECTED") - 1) },

               { ("EXCLUDE"), (sizeof ("EXCLUDE") - 1) },

               { ("ORDERED"), (sizeof ("ORDERED") - 1) },
               { ("COMPRESSED"), (sizeof ("COMPRESSED") - 1) },

               { ("ENTRYSECT"), (sizeof ("ENTRYSECT") - 1) },
               { ("ARM_PURECODE"), (sizeof ("ARM_PURECODE") - 1) },
               { ("COMDEF"), (sizeof ("COMDEF") - 1) },

               { ("GNU_MBIND"), (sizeof ("GNU_MBIND") - 1) },

               { ("VLE"), (sizeof ("VLE") - 1) },

               { ("GNU_RETAIN"), (sizeof ("GNU_RETAIN") - 1) },
    };

  if (do_section_details)
    {
      sprintf (buff, "[%*.*lx]: ",
        field_size, field_size, (unsigned long) sh_flags);
      p += field_size + 4;
    }

  while (sh_flags)
    {
      uint64_t flag;

      flag = sh_flags & - sh_flags;
      sh_flags &= ~ flag;

      if (do_section_details)
 {
   switch (flag)
     {
     case (1 << 0): sindex = 0; break;
     case (1 << 1): sindex = 1; break;
     case (1 << 2): sindex = 2; break;
     case (1 << 4): sindex = 3; break;
     case (1 << 5): sindex = 4; break;
     case (1 << 6): sindex = 5; break;
     case (1 << 7): sindex = 6; break;
     case (1 << 8): sindex = 7; break;
     case (1 << 9): sindex = 8; break;
     case (1 << 10): sindex = 9; break;
     case 0x80000000: sindex = 18; break;
     case (1 << 11): sindex = 20; break;

     default:
       sindex = -1;
       switch (filedata->file_header.e_machine)
  {
  case 50:
    if (flag == 0x10000000)
      sindex = 10;
    else if (flag == 0x20000000)
      sindex = 11;
    else if (filedata->file_header.e_ident[7] == 13)
      switch (flag)
        {
        case 0x0100000000ULL: sindex = 12; break;
        case 0x0200000000ULL: sindex = 13; break;
        case 0x0400000000ULL: sindex = 14; break;
        case 0x0800000000ULL: sindex = 15; break;
        case 0x1000000000ULL: sindex = 16; break;
        case 0x2000000000ULL: sindex = 17; break;
        default: break;
        }
    break;

  case 3:
  case 6:
  case 62:
  case 180:
  case 181:
  case 11:
  case 18:
  case 43:
  case 2:
    if (flag == 0x40000000)
      sindex = 19;
    break;

  case 40:
    switch (flag)
      {
      case 0x10000000: sindex = 21; break;
      case 0x20000000: sindex = 22; break;
      case 0x80000000: sindex = 23; break;
      default: break;
      }
    break;
  case 20:
    if (flag == 0x10000000)
      sindex = 25;
    break;
  default:
    break;
  }

       switch (filedata->file_header.e_ident[7])
  {
  case 3:
  case 9:
    if (flag == (1 << 21))
      sindex = 26;

  case 0:
    if (flag == 0x01000000)



      sindex = 24;
    break;
  default:
    break;
  }
       break;
     }

   if (sindex != -1)
     {
       if (p != buff + field_size + 4)
  {
    if (size < (10 + 2))
      {
        warn (gettext ("Internal error: not enough buffer room for section flag info"));
        return gettext ("<unknown>");
      }
    size -= 2;
    *p++ = ',';
    *p++ = ' ';
  }

       size -= flags [sindex].len;
       p = stpcpy (p, flags [sindex].str);
     }
   else if (flag & 0x0FF00000)
     os_flags |= flag;
   else if (flag & 0xF0000000)
     proc_flags |= flag;
   else
     unknown_flags |= flag;
 }
      else
 {
   switch (flag)
     {
     case (1 << 0): *p = 'W'; break;
     case (1 << 1): *p = 'A'; break;
     case (1 << 2): *p = 'X'; break;
     case (1 << 4): *p = 'M'; break;
     case (1 << 5): *p = 'S'; break;
     case (1 << 6): *p = 'I'; break;
     case (1 << 7): *p = 'L'; break;
     case (1 << 8): *p = 'O'; break;
     case (1 << 9): *p = 'G'; break;
     case (1 << 10): *p = 'T'; break;
     case 0x80000000: *p = 'E'; break;
     case (1 << 11): *p = 'C'; break;

     default:
       if ((filedata->file_header.e_machine == 62
     || filedata->file_header.e_machine == 180
     || filedata->file_header.e_machine == 181)
    && flag == 0x10000000)
  *p = 'l';
       else if (filedata->file_header.e_machine == 40
         && flag == 0x20000000)
  *p = 'y';
       else if (filedata->file_header.e_machine == 20
         && flag == 0x10000000)
  *p = 'v';
       else if (flag & 0x0FF00000)
  {
    switch (filedata->file_header.e_ident[7])
      {
      case 3:
      case 9:
        if (flag == (1 << 21))
   {
     *p = 'R';
     break;
   }

      case 0:
        if (flag == 0x01000000)
   {



     *p = 'D';
     break;
   }

      default:
        *p = 'o';
        sh_flags &= ~0x0FF00000;
        break;
      }
  }
       else if (flag & 0xF0000000)
  {
    *p = 'p';
    sh_flags &= ~ 0xF0000000;
  }
       else
  *p = 'x';
       break;
     }
   p++;
 }
    }

  if (do_section_details)
    {
      if (os_flags)
 {
   size -= 5 + field_size;
   if (p != buff + field_size + 4)
     {
       if (size < (2 + 1))
  {
    warn (gettext ("Internal error: not enough buffer room for section flag info"));
    return gettext ("<unknown>");
  }
       size -= 2;
       *p++ = ',';
       *p++ = ' ';
     }
   sprintf (p, "OS (%*.*lx)", field_size, field_size,
     (unsigned long) os_flags);
   p += 5 + field_size;
 }
      if (proc_flags)
 {
   size -= 7 + field_size;
   if (p != buff + field_size + 4)
     {
       if (size < (2 + 1))
  {
    warn (gettext ("Internal error: not enough buffer room for section flag info"));
    return gettext ("<unknown>");
  }
       size -= 2;
       *p++ = ',';
       *p++ = ' ';
     }
   sprintf (p, "PROC (%*.*lx)", field_size, field_size,
     (unsigned long) proc_flags);
   p += 7 + field_size;
 }
      if (unknown_flags)
 {
   size -= 10 + field_size;
   if (p != buff + field_size + 4)
     {
       if (size < (2 + 1))
  {
    warn (gettext ("Internal error: not enough buffer room for section flag info"));
    return gettext ("<unknown>");
  }
       size -= 2;
       *p++ = ',';
       *p++ = ' ';
     }
   sprintf (p, gettext ("UNKNOWN (%*.*lx)"), field_size, field_size,
     (unsigned long) unknown_flags);
   p += 10 + field_size;
 }
    }

  *p = '\0';
  return buff;
}

static unsigned int __attribute__ ((warn_unused_result))
get_compression_header (Elf_Internal_Chdr *chdr, unsigned char *buf,
   uint64_t size)
{
  if (is_32bit_elf)
    {
      Elf32_External_Chdr *echdr = (Elf32_External_Chdr *) buf;

      if (size < sizeof (* echdr))
 {
   error (gettext ("Compressed section is too small even for a compression header\n"));
   return 0;
 }

      chdr->ch_type = byte_get (echdr->ch_type, sizeof (echdr->ch_type));
      chdr->ch_size = byte_get (echdr->ch_size, sizeof (echdr->ch_size));
      chdr->ch_addralign = byte_get (echdr->ch_addralign, sizeof (echdr->ch_addralign));
      return sizeof (*echdr);
    }
  else
    {
      Elf64_External_Chdr *echdr = (Elf64_External_Chdr *) buf;

      if (size < sizeof (* echdr))
 {
   error (gettext ("Compressed section is too small even for a compression header\n"));
   return 0;
 }

      chdr->ch_type = byte_get (echdr->ch_type, sizeof (echdr->ch_type));
      chdr->ch_size = byte_get (echdr->ch_size, sizeof (echdr->ch_size));
      chdr->ch_addralign = byte_get (echdr->ch_addralign, sizeof (echdr->ch_addralign));
      return sizeof (*echdr);
    }
}

static 
# 7176 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 7177 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_section_headers (Filedata * filedata)
{
  Elf_Internal_Shdr * section;
  unsigned int i;

  if (filedata->file_header.e_shnum == 0)
    {

      if (filedata->file_header.e_shoff != 0)
 {
   warn (gettext ("possibly corrupt ELF file header - it has a non-zero" " section header offset, but no section headers\n")
                                                       );
   return 
# 7189 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 7189 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }
      else if (do_sections)
 printf (gettext ("\nThere are no sections in this file.\n"));

      return 
# 7194 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 7194 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  if (do_sections && !do_header)
    {
      if (filedata->is_separate && process_links)
 printf (gettext ("In linked file '%s': "), filedata->file_name);
      if (! filedata->is_separate || process_links)
 printf (ngettext ("There is %d section header, "
     "starting at offset %#" 
# 7203 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            "l" "x" 
# 7203 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ":\n",
     "There are %d section headers, "
     "starting at offset %#" 
# 7205 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            "l" "x" 
# 7205 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ":\n",
     filedata->file_header.e_shnum),
  filedata->file_header.e_shnum,
  filedata->file_header.e_shoff);
    }

  if (!get_section_headers (filedata, 
# 7211 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     0
# 7211 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ))
    return 
# 7212 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 7212 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;


  if (filedata->file_header.e_shstrndx != 0
       && filedata->file_header.e_shstrndx < filedata->file_header.e_shnum)
    {
      section = filedata->section_headers + filedata->file_header.e_shstrndx;

      if (section->sh_size != 0)
 {
   filedata->string_table = (char *) get_data (
# 7222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              ((void *)0)
# 7222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  , filedata, section->sh_offset,
            1, section->sh_size,
            gettext ("string table"));

   filedata->string_table_length = filedata->string_table != 
# 7226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                            ((void *)0) 
# 7226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                 ? section->sh_size : 0;
 }
    }



  eh_addr_size = is_32bit_elf ? 4 : 8;
  switch (filedata->file_header.e_machine)
    {
    case 8:
    case 10:
# 7246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      if ((filedata->file_header.e_flags & 0x0000F000) == 0x00004000
   && find_section (filedata, ".gcc_compiled_long32") == 
# 7247 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                        ((void *)0)
# 7247 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                            )
 eh_addr_size = 8;
      break;

    case 46:
    case 47:
      switch (filedata->file_header.e_flags & 0x00FF0000)
 {
 case 0x00800000:
 case 0x00830000:
 case 0x00840000:
 case 0x00860000:
   eh_addr_size = 2;
   break;
 case 0x00810000:
 case 0x00820000:
 case 0x00850000:
   eh_addr_size = 4;
   break;
 }
      break;

    case 0xFEB0:
    case 120:
      switch (filedata->file_header.e_flags & 0x0000007F)
 {
 case 0x00000075:
   eh_addr_size = 2;
   break;
 }
      break;
    }
# 7299 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  for (i = 0, section = filedata->section_headers;
       i < filedata->file_header.e_shnum;
       i++, section++)
    {
      const char *name = section_name_print (filedata, section);



      switch (section->sh_type)
 {
 case 11:
   if (filedata->dynamic_symbols != 
# 7310 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   ((void *)0)
# 7310 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       )
     {
       error (gettext ("File contains multiple dynamic symbol tables\n"));
       continue;
     }

   do { uint64_t expected_entsize = is_32bit_elf ? sizeof (Elf32_External_Sym) : sizeof (Elf64_External_Sym); if (section->sh_entsize != expected_entsize) { error (gettext ("Section %d has invalid sh_entsize of %" 
# 7316 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7316 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  "\n"), i, section->sh_entsize); error (gettext ("(Using the expected size of %" 
# 7316 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7316 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  " for the rest of this dump)\n"), expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
   filedata->dynamic_symbols
     = get_elf_symbols (filedata, section, &filedata->num_dynamic_syms);
   filedata->dynamic_symtab_section = section;
   break;

 case 3:
   if ((strcmp ((name), (".dynstr")) == 0))
     {
       if (filedata->dynamic_strings != 
# 7325 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       ((void *)0)
# 7325 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           )
  {
    error (gettext ("File contains multiple dynamic string tables\n"));
    continue;
  }

       filedata->dynamic_strings
  = (char *) get_data (
# 7332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 7332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          , filedata, section->sh_offset,
         1, section->sh_size, gettext ("dynamic strings"));
       filedata->dynamic_strings_length
  = filedata->dynamic_strings == 
# 7335 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0) 
# 7335 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ? 0 : section->sh_size;
       filedata->dynamic_strtab_section = section;
     }
   break;

 case 18:
   {
     elf_section_list * entry = xmalloc (sizeof * entry);

     entry->hdr = section;
     entry->next = filedata->symtab_shndx_list;
     filedata->symtab_shndx_list = entry;
   }
   break;

 case 2:
   do { uint64_t expected_entsize = is_32bit_elf ? sizeof (Elf32_External_Sym) : sizeof (Elf64_External_Sym); if (section->sh_entsize != expected_entsize) { error (gettext ("Section %d has invalid sh_entsize of %" 
# 7351 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7351 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  "\n"), i, section->sh_entsize); error (gettext ("(Using the expected size of %" 
# 7351 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7351 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  " for the rest of this dump)\n"), expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
   break;

 case 17:
   do { uint64_t expected_entsize = is_32bit_elf ? 4 : 4; if (section->sh_entsize != expected_entsize) { error (gettext ("Section %d has invalid sh_entsize of %" 
# 7355 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7355 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  "\n"), i, section->sh_entsize); error (gettext ("(Using the expected size of %" 
# 7355 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7355 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  " for the rest of this dump)\n"), expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
   break;

 case 9:
   do { uint64_t expected_entsize = is_32bit_elf ? sizeof (Elf32_External_Rel) : sizeof (Elf64_External_Rel); if (section->sh_entsize != expected_entsize) { error (gettext ("Section %d has invalid sh_entsize of %" 
# 7359 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7359 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  "\n"), i, section->sh_entsize); error (gettext ("(Using the expected size of %" 
# 7359 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7359 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  " for the rest of this dump)\n"), expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
   if (do_checks && section->sh_size == 0)
     warn (gettext ("Section '%s': zero-sized relocation section\n"), name);
   break;

 case 4:
   do { uint64_t expected_entsize = is_32bit_elf ? sizeof (Elf32_External_Rela) : sizeof (Elf64_External_Rela); if (section->sh_entsize != expected_entsize) { error (gettext ("Section %d has invalid sh_entsize of %" 
# 7365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  "\n"), i, section->sh_entsize); error (gettext ("(Using the expected size of %" 
# 7365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  " for the rest of this dump)\n"), expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
   if (do_checks && section->sh_size == 0)
     warn (gettext ("Section '%s': zero-sized relocation section\n"), name);
   break;

 case 19:
   do { uint64_t expected_entsize = is_32bit_elf ? sizeof (Elf32_External_Relr) : sizeof (Elf64_External_Relr); if (section->sh_entsize != expected_entsize) { error (gettext ("Section %d has invalid sh_entsize of %" 
# 7371 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7371 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  "\n"), i, section->sh_entsize); error (gettext ("(Using the expected size of %" 
# 7371 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  "l" "x" 
# 7371 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  " for the rest of this dump)\n"), expected_entsize); section->sh_entsize = expected_entsize; } } while (0);
   break;

 case 7:
 case 1:



   if (do_checks && section->sh_size == 0)
     warn (gettext ("Section '%s': has a size of zero - is this intended ?\n"), name);
   break;

 default:
   break;
 }

      if ((do_debugging || do_debug_info || do_debug_abbrevs
    || do_debug_lines || do_debug_pubnames || do_debug_pubtypes
    || do_debug_aranges || do_debug_frames || do_debug_macinfo
    || do_debug_str || do_debug_str_offsets || do_debug_loc
    || do_debug_ranges
    || do_debug_addr || do_debug_cu_index || do_debug_links)
   && (startswith (name, ".debug_")
       || startswith (name, ".zdebug_")))
 {
          if (name[1] == 'z')
            name += sizeof (".zdebug_") - 1;
          else
            name += sizeof (".debug_") - 1;

   if (do_debugging
       || (do_debug_info && startswith (name, "info"))
       || (do_debug_info && startswith (name, "types"))
       || (do_debug_abbrevs && startswith (name, "abbrev"))
       || (do_debug_lines && strcmp (name, "line") == 0)
       || (do_debug_lines && startswith (name, "line."))
       || (do_debug_pubnames && startswith (name, "pubnames"))
       || (do_debug_pubtypes && startswith (name, "pubtypes"))
       || (do_debug_pubnames && startswith (name, "gnu_pubnames"))
       || (do_debug_pubtypes && startswith (name, "gnu_pubtypes"))
       || (do_debug_aranges && startswith (name, "aranges"))
       || (do_debug_ranges && startswith (name, "ranges"))
       || (do_debug_ranges && startswith (name, "rnglists"))
       || (do_debug_frames && startswith (name, "frame"))
       || (do_debug_macinfo && startswith (name, "macinfo"))
       || (do_debug_macinfo && startswith (name, "macro"))
       || (do_debug_str && startswith (name, "str"))
       || (do_debug_links && startswith (name, "sup"))
       || (do_debug_str_offsets && startswith (name, "str_offsets"))
       || (do_debug_loc && startswith (name, "loc"))
       || (do_debug_loc && startswith (name, "loclists"))
       || (do_debug_addr && startswith (name, "addr"))
       || (do_debug_cu_index && startswith (name, "cu_index"))
       || (do_debug_cu_index && startswith (name, "tu_index"))
       )
     request_dump_bynumber (&filedata->dump, i, (1 << 2));
 }

      else if ((do_debugging || do_debug_info)
        && startswith (name, ".gnu.linkonce.wi."))
 request_dump_bynumber (&filedata->dump, i, (1 << 2));
      else if (do_debug_frames && (strcmp ((name), (".eh_frame")) == 0))
 request_dump_bynumber (&filedata->dump, i, (1 << 2));
      else if (do_gdb_index && ((strcmp ((name), (".gdb_index")) == 0)
    || (strcmp ((name), (".debug_names")) == 0)))
 request_dump_bynumber (&filedata->dump, i, (1 << 2));

      else if ((do_debugging || do_trace_info || do_trace_abbrevs
                || do_trace_aranges)
        && startswith (name, ".trace_"))
 {
          name += sizeof (".trace_") - 1;

   if (do_debugging
       || (do_trace_info && (strcmp ((name), ("info")) == 0))
       || (do_trace_abbrevs && (strcmp ((name), ("abbrev")) == 0))
       || (do_trace_aranges && (strcmp ((name), ("aranges")) == 0))
       )
     request_dump_bynumber (&filedata->dump, i, (1 << 2));
 }
      else if ((do_debugging || do_debug_links)
        && (startswith (name, ".gnu_debuglink")
     || startswith (name, ".gnu_debugaltlink")))
 request_dump_bynumber (&filedata->dump, i, (1 << 2));
    }

  if (! do_sections)
    return 
# 7458 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 7458 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (filedata->is_separate && ! process_links)
    return 
# 7461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 7461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (filedata->is_separate)
    printf (gettext ("\nSection Headers in linked file '%s':\n"), filedata->file_name);
  else if (filedata->file_header.e_shnum > 1)
    printf (gettext ("\nSection Headers:\n"));
  else
    printf (gettext ("\nSection Header:\n"));

  if (is_32bit_elf)
    {
      if (do_section_details)
 {
   printf (gettext ("  [Nr] Name\n"));
   printf (gettext ("       Type            Addr     Off    Size   ES   Lk Inf Al\n"));
 }
      else
 printf
   (gettext ("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"));
    }
  else if (do_wide)
    {
      if (do_section_details)
 {
   printf (gettext ("  [Nr] Name\n"));
   printf (gettext ("       Type            Address          Off    Size   ES   Lk Inf Al\n"));
 }
      else
 printf
   (gettext ("  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"));
    }
  else
    {
      if (do_section_details)
 {
   printf (gettext ("  [Nr] Name\n"));
   printf (gettext ("       Type              Address          Offset            Link\n"));
   printf (gettext ("       Size              EntSize          Info              Align\n"));
 }
      else
 {
   printf (gettext ("  [Nr] Name              Type             Address           Offset\n"));
   printf (gettext ("       Size              EntSize          Flags  Link  Info  Align\n"));
 }
    }

  if (do_section_details)
    printf (gettext ("       Flags\n"));

  for (i = 0, section = filedata->section_headers;
       i < filedata->file_header.e_shnum;
       i++, section++)
    {



      switch (section->sh_type)
 {
 case 9:
 case 4:
   if (section->sh_link == 0
       && (filedata->file_header.e_type == 2
    || filedata->file_header.e_type == 3))


     break;

 case 18:
 case 17:
 case 5:
 case 0x6ffffff6:
 case 0x6fffffff:
   if (section->sh_link == 0
       || section->sh_link >= filedata->file_header.e_shnum
       || (filedata->section_headers[section->sh_link].sh_type != 2
    && filedata->section_headers[section->sh_link].sh_type != 11))
     warn (gettext ("[%2u]: Link field (%u) should index a symtab section.\n"),
    i, section->sh_link);
   break;

 case 6:
 case 2:
 case 11:
 case 0x6ffffffe:
 case 0x6ffffffd:
 case 0x6ffffff7:
   if (section->sh_link == 0
       || section->sh_link >= filedata->file_header.e_shnum
       || filedata->section_headers[section->sh_link].sh_type != 3)
     warn (gettext ("[%2u]: Link field (%u) should index a string section.\n"),
    i, section->sh_link);
   break;

 case 14:
 case 15:
 case 16:
   if (section->sh_type < 0x60000000 && section->sh_link != 0)
     warn (gettext ("[%2u]: Unexpected value (%u) in link field.\n"),
    i, section->sh_link);
   break;

 default:
# 7572 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
   break;
 }


      switch (section->sh_type)
 {
 case 9:
 case 4:
   if (section->sh_info == 0
       && (filedata->file_header.e_type == 2
    || filedata->file_header.e_type == 3))


     break;
   if (section->sh_info == 0
       || section->sh_info >= filedata->file_header.e_shnum
       || (filedata->section_headers[section->sh_info].sh_type != 1
    && filedata->section_headers[section->sh_info].sh_type != 8
    && filedata->section_headers[section->sh_info].sh_type != 7
    && filedata->section_headers[section->sh_info].sh_type != 14
    && filedata->section_headers[section->sh_info].sh_type != 15
    && filedata->section_headers[section->sh_info].sh_type != 16

    && filedata->section_headers[section->sh_info].sh_type < 0x60000000))
     warn (gettext ("[%2u]: Info field (%u) should index a relocatable section.\n"),
    i, section->sh_info);
   break;

 case 6:
 case 5:
 case 18:
 case 14:
 case 15:
 case 16:
   if (section->sh_info != 0)
     warn (gettext ("[%2u]: Unexpected value (%u) in info field.\n"),
    i, section->sh_info);
   break;

 case 17:
 case 2:
 case 11:

   break;

 default:

   if (section->sh_type == 8)





     ;
   else if (section->sh_flags & (1 << 6))
     {
       if (section->sh_info < 1 || section->sh_info >= filedata->file_header.e_shnum)
  warn (gettext ("[%2u]: Expected link to another section in info field"), i);
     }
   else if (section->sh_type < 0x60000000
     && (section->sh_flags & 0x01000000) == 0
     && section->sh_info != 0)
     warn (gettext ("[%2u]: Unexpected value (%u) in info field.\n"),
    i, section->sh_info);
   break;
 }


      if (section->sh_size > filedata->file_size
   && section->sh_type != 8
   && section->sh_type != 0
   && section->sh_type < 0x60000000)
 warn (gettext ("Size of section %u is larger than the entire file!\n"), i);

      printf ("  [%2u] ", i);
      if (do_section_details)
 printf ("%s\n      ", printable_section_name (filedata, section));
      else
 print_symbol (-17, section_name_print (filedata, section));

      printf (do_wide ? " %-15s " : " %-15.15s ",
       get_section_type_name (filedata, section->sh_type));

      if (is_32bit_elf)
 {
   const char * link_too_big = 
# 7657 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 7657 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  ;

   print_vma (section->sh_addr, LONG_HEX);

   printf ( " %6.6lx %6.6lx %2.2lx",
     (unsigned long) section->sh_offset,
     (unsigned long) section->sh_size,
     (unsigned long) section->sh_entsize);

   if (do_section_details)
     fputs ("  ", 
# 7667 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout
# 7667 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
   else
     printf (" %3s ", get_elf_section_flags (filedata, section->sh_flags));

   if (section->sh_link >= filedata->file_header.e_shnum)
     {
       link_too_big = "";


       switch (filedata->file_header.e_machine)
  {
  case 3:
  case 6:
  case 62:
  case 180:
  case 181:
  case 11:
  case 18:
  case 43:
  case 2:
    if (section->sh_link == ((-0x100u) & 0xffff))
      link_too_big = "BEFORE";
    else if (section->sh_link == (((-0x100u) + 1) & 0xffff))
      link_too_big = "AFTER";
    break;
  default:
    break;
  }
     }

   if (do_section_details)
     {
       if (link_too_big != 
# 7699 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          ((void *)0) 
# 7699 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               && * link_too_big)
  printf ("<%s> ", link_too_big);
       else
  printf ("%2u ", section->sh_link);
       printf ("%3u %2lu\n", section->sh_info,
        (unsigned long) section->sh_addralign);
     }
   else
     printf ("%2u %3u %2lu\n",
      section->sh_link,
      section->sh_info,
      (unsigned long) section->sh_addralign);

   if (link_too_big && ! * link_too_big)
     warn (gettext ("section %u: sh_link value of %u is larger than the number of sections\n"),
    i, section->sh_link);
 }
      else if (do_wide)
 {
   print_vma (section->sh_addr, LONG_HEX);

   if ((long) section->sh_offset == section->sh_offset)
     printf (" %6.6lx", (unsigned long) section->sh_offset);
   else
     {
       putchar (' ');
       print_vma (section->sh_offset, LONG_HEX);
     }

   if ((unsigned long) section->sh_size == section->sh_size)
     printf (" %6.6lx", (unsigned long) section->sh_size);
   else
     {
       putchar (' ');
       print_vma (section->sh_size, LONG_HEX);
     }

   if ((unsigned long) section->sh_entsize == section->sh_entsize)
     printf (" %2.2lx", (unsigned long) section->sh_entsize);
   else
     {
       putchar (' ');
       print_vma (section->sh_entsize, LONG_HEX);
     }

   if (do_section_details)
     fputs ("  ", 
# 7745 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout
# 7745 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
   else
     printf (" %3s ", get_elf_section_flags (filedata, section->sh_flags));

   printf ("%2u %3u ", section->sh_link, section->sh_info);

   if ((unsigned long) section->sh_addralign == section->sh_addralign)
     printf ("%2lu\n", (unsigned long) section->sh_addralign);
   else
     {
       print_vma (section->sh_addralign, DEC);
       putchar ('\n');
     }
 }
      else if (do_section_details)
 {
   putchar (' ');
   print_vma (section->sh_addr, LONG_HEX);
   if ((long) section->sh_offset == section->sh_offset)
     printf ("  %16.16lx", (unsigned long) section->sh_offset);
   else
     {
       printf ("  ");
       print_vma (section->sh_offset, LONG_HEX);
     }
   printf ("  %u\n       ", section->sh_link);
   print_vma (section->sh_size, LONG_HEX);
   putchar (' ');
   print_vma (section->sh_entsize, LONG_HEX);

   printf ("  %-16u  %lu\n",
    section->sh_info,
    (unsigned long) section->sh_addralign);
 }
      else
 {
   putchar (' ');
   print_vma (section->sh_addr, LONG_HEX);
   if ((long) section->sh_offset == section->sh_offset)
     printf ("  %8.8lx", (unsigned long) section->sh_offset);
   else
     {
       printf ("  ");
       print_vma (section->sh_offset, LONG_HEX);
     }
   printf ("\n       ");
   print_vma (section->sh_size, LONG_HEX);
   printf ("  ");
   print_vma (section->sh_entsize, LONG_HEX);

   printf (" %3s ", get_elf_section_flags (filedata, section->sh_flags));

   printf ("     %2u   %3u     %lu\n",
    section->sh_link,
    section->sh_info,
    (unsigned long) section->sh_addralign);
 }

      if (do_section_details)
 {
   printf ("       %s\n", get_elf_section_flags (filedata, section->sh_flags));
   if ((section->sh_flags & (1 << 11)) != 0)
     {


       unsigned char buf[24];

       
# 7812 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      ((void) sizeof ((
# 7812 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      sizeof (buf) >= sizeof (Elf64_External_Chdr)
# 7812 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      ) ? 1 : 0), __extension__ ({ if (
# 7812 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      sizeof (buf) >= sizeof (Elf64_External_Chdr)
# 7812 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      ) ; else __assert_fail (
# 7812 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      "sizeof (buf) >= sizeof (Elf64_External_Chdr)"
# 7812 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 7812, __extension__ __PRETTY_FUNCTION__); }))
# 7812 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                           ;
       if (get_data (&buf, filedata, section->sh_offset, 1,
       sizeof (buf), gettext ("compression header")))
  {
    Elf_Internal_Chdr chdr;

    if (get_compression_header (&chdr, buf, sizeof (buf)) == 0)
      printf (gettext ("       [<corrupt>]\n"));
    else
      {
        if (chdr.ch_type == ch_compress_zlib)
   printf ("       ZLIB, ");
        else if (chdr.ch_type == ch_compress_zstd)
   printf ("       ZSTD, ");
        else
   printf (gettext ("       [<unknown>: 0x%x], "),
    chdr.ch_type);
        print_vma (chdr.ch_size, LONG_HEX);
        printf (", %lu\n", (unsigned long) chdr.ch_addralign);
      }
  }
     }
 }
    }

  if (!do_section_details)
    {



      printf (gettext ("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  ")


                                                                  );
      switch (filedata->file_header.e_ident[7])
 {
 case 3:
 case 9:
   printf (gettext ("R (retain), "));

 case 0:
   printf (gettext ("D (mbind), "));
   break;
 default:
   break;
 }
      if (filedata->file_header.e_machine == 62
   || filedata->file_header.e_machine == 180
   || filedata->file_header.e_machine == 181)
 printf (gettext ("l (large), "));
      else if (filedata->file_header.e_machine == 40)
 printf (gettext ("y (purecode), "));
      else if (filedata->file_header.e_machine == 20)
 printf (gettext ("v (VLE), "));
      printf ("p (processor specific)\n");
    }

  return 
# 7869 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 7869 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 7872 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 7873 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_symtab (Filedata *filedata, Elf_Internal_Shdr *symsec,
     Elf_Internal_Sym **symtab, uint64_t *nsyms,
     char **strtab, uint64_t *strtablen)
{
  *strtab = 
# 7877 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           ((void *)0)
# 7877 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
  *strtablen = 0;
  *symtab = get_elf_symbols (filedata, symsec, nsyms);

  if (*symtab == 
# 7881 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 7881 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
    return 
# 7882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 7882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (symsec->sh_link != 0)
    {
      Elf_Internal_Shdr *strsec;

      if (symsec->sh_link >= filedata->file_header.e_shnum)
 {
   error (gettext ("Bad sh_link in symbol table section\n"));
   free (*symtab);
   *symtab = 
# 7892 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 7892 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
   *nsyms = 0;
   return 
# 7894 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 7894 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      strsec = filedata->section_headers + symsec->sh_link;

      *strtab = (char *) get_data (
# 7899 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 7899 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      , filedata, strsec->sh_offset,
       1, strsec->sh_size, gettext ("string table"));
      if (*strtab == 
# 7901 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 7901 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        )
 {
   free (*symtab);
   *symtab = 
# 7904 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 7904 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
   *nsyms = 0;
   return 
# 7906 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 7906 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }
      *strtablen = strsec->sh_size;
    }
  return 
# 7910 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 7910 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_group_flags (unsigned int flags)
{
  static char buff[128];

  if (flags == 0)
    return "";
  else if (flags == 0x1)
    return "COMDAT ";

  snprintf (buff, sizeof buff, "[0x%x: %s%s%s]",
     flags,
     flags & 0x0ff00000 ? gettext ("<OS specific>") : "",
     flags & 0xf0000000 ? gettext ("<PROC specific>") : "",
     (flags & ~(0x1 | 0x0ff00000 | 0xf0000000)
      ? gettext ("<unknown>") : ""));

  return buff;
}

static 
# 7933 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 7934 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_section_groups (Filedata * filedata)
{
  Elf_Internal_Shdr * section;
  unsigned int i;
  struct group * group;
  Elf_Internal_Shdr * symtab_sec;
  Elf_Internal_Shdr * strtab_sec;
  Elf_Internal_Sym * symtab;
  uint64_t num_syms;
  char * strtab;
  size_t strtab_size;


  if (!do_unwind && !do_section_groups)
    return 
# 7948 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 7948 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (filedata->file_header.e_shnum == 0)
    {
      if (do_section_groups)
 {
   if (filedata->is_separate)
     printf (gettext ("\nThere are no sections group in linked file '%s'.\n"),
      filedata->file_name);
   else
     printf (gettext ("\nThere are no section groups in this file.\n"));
 }
      return 
# 7960 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 7960 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  if (filedata->section_headers == 
# 7963 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 7963 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    {
      error (gettext ("Section headers are not available!\n"));

      return 
# 7967 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 7967 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  filedata->section_headers_groups
    = (struct group **) calloc (filedata->file_header.e_shnum,
    sizeof (struct group *));

  if (filedata->section_headers_groups == 
# 7974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         ((void *)0)
# 7974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             )
    {
      error (gettext ("Out of memory reading %u section group headers\n"),
      filedata->file_header.e_shnum);
      return 
# 7978 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 7978 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }


  filedata->group_count = 0;
  for (i = 0, section = filedata->section_headers;
       i < filedata->file_header.e_shnum;
       i++, section++)
    if (section->sh_type == 17)
      filedata->group_count++;

  if (filedata->group_count == 0)
    {
      if (do_section_groups)
 {
   if (filedata->is_separate)
     printf (gettext ("\nThere are no section groups in linked file '%s'.\n"),
      filedata->file_name);
   else
     printf (gettext ("\nThere are no section groups in this file.\n"));
 }

      return 
# 8000 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 8000 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  filedata->section_groups = (struct group *) calloc (filedata->group_count,
            sizeof (struct group));

  if (filedata->section_groups == 
# 8006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 ((void *)0)
# 8006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     )
    {
      error (gettext ("Out of memory reading %zu groups\n"), filedata->group_count);
      return 
# 8009 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 8009 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  symtab_sec = 
# 8012 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 8012 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
  strtab_sec = 
# 8013 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 8013 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
  symtab = 
# 8014 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 8014 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
  num_syms = 0;
  strtab = 
# 8016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 8016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
  strtab_size = 0;

  if (filedata->is_separate)
    printf (gettext ("Section groups in linked file '%s'\n"), filedata->file_name);

  for (i = 0, section = filedata->section_headers, group = filedata->section_groups;
       i < filedata->file_header.e_shnum;
       i++, section++)
    {
      if (section->sh_type == 17)
 {
   const char * name = printable_section_name (filedata, section);
   const char * group_name;
   unsigned char * start;
   unsigned char * indices;
   unsigned int entry, j, size;
   Elf_Internal_Shdr * sec;
   Elf_Internal_Sym * sym;


   if (section->sh_link >= filedata->file_header.e_shnum
       || ((sec = filedata->section_headers + section->sh_link)->sh_type
    != 2))
     {
       error (gettext ("Bad sh_link in group section `%s'\n"), name);
       continue;
     }

   if (symtab_sec != sec)
     {
       symtab_sec = sec;
       free (symtab);
       symtab = get_elf_symbols (filedata, symtab_sec, & num_syms);
     }

   if (symtab == 
# 8052 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 8052 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     {
       error (gettext ("Corrupt header in group section `%s'\n"), name);
       continue;
     }

   if (section->sh_info >= num_syms)
     {
       error (gettext ("Bad sh_info in group section `%s'\n"), name);
       continue;
     }

   sym = symtab + section->sh_info;

   if (((sym->st_info) & 0xF) == 3)
     {
       if (sym->st_shndx == 0
    || sym->st_shndx >= filedata->file_header.e_shnum)
  {
    error (gettext ("Bad sh_info in group section `%s'\n"), name);
    continue;
  }

       group_name = section_name_print (filedata,
            filedata->section_headers
            + sym->st_shndx);
       strtab_sec = 
# 8078 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 8078 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
       free (strtab);
       strtab = 
# 8080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 8080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
       strtab_size = 0;
     }
   else
     {

       if (symtab_sec->sh_link >= filedata->file_header.e_shnum)
  {
    strtab_sec = 
# 8088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 8088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
    free (strtab);
    strtab = 
# 8090 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 8090 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    strtab_size = 0;
  }
       else if (strtab_sec
         != (sec = filedata->section_headers + symtab_sec->sh_link))
  {
    strtab_sec = sec;
    free (strtab);

    strtab = (char *) get_data (
# 8099 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 8099 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   , filedata, strtab_sec->sh_offset,
           1, strtab_sec->sh_size,
           gettext ("string table"));
    strtab_size = strtab != 
# 8102 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0) 
# 8102 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                ? strtab_sec->sh_size : 0;
  }
       group_name = sym->st_name < strtab_size
  ? strtab + sym->st_name : gettext ("<corrupt>");
     }


   if (section->sh_entsize > section->sh_size)
     {
       error (gettext ("Section %s has sh_entsize (%#" 
# 8111 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "x" 
# 8111 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ")" " which is larger than its size (%#" 
# 8111 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "x" 
# 8111 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ")\n")
                                                           ,
       printable_section_name (filedata, section),
       section->sh_entsize,
       section->sh_size);
       continue;
     }

   start = (unsigned char *) get_data (
# 8119 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 8119 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          , filedata, section->sh_offset,
                                              1, section->sh_size,
                                              gettext ("section data"));
   if (start == 
# 8122 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 8122 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   )
     continue;

   indices = start;
   size = (section->sh_size / section->sh_entsize) - 1;
   entry = byte_get (indices, 4);
   indices += 4;

   if (do_section_groups)
     {
       printf (gettext ("\n%sgroup section [%5u] `%s' [%s] contains %u sections:\n"),
        get_group_flags (entry), i, name, group_name, size);

       printf (gettext ("   [Index]    Name\n"));
     }

   group->group_index = i;

   for (j = 0; j < size; j++)
     {
       struct group_list * g;

       entry = byte_get (indices, 4);
       indices += 4;

       if (entry >= filedata->file_header.e_shnum)
  {
    static unsigned num_group_errors = 0;

    if (num_group_errors ++ < 10)
      {
        error (gettext ("section [%5u] in group section [%5u] > maximum section [%5u]\n"),
        entry, i, filedata->file_header.e_shnum - 1);
        if (num_group_errors == 10)
   warn (gettext ("Further error messages about overlarge group section indices suppressed\n"));
      }
    continue;
  }

       if (filedata->section_headers_groups [entry] != 
# 8161 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                      ((void *)0)
# 8161 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                          )
  {
    if (entry)
      {
        static unsigned num_errs = 0;

        if (num_errs ++ < 10)
   {
     error (gettext ("section [%5u] in group section [%5u] already in group section [%5u]\n"),
     entry, i,
     filedata->section_headers_groups [entry]->group_index);
     if (num_errs == 10)
       warn (gettext ("Further error messages about already contained group sections suppressed\n"));
   }
        continue;
      }
    else
      {



        static 
# 8182 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              _Bool 
# 8182 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   warned = 
# 8182 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            0
# 8182 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 ;
        if (!warned)
   {
     error (gettext ("section 0 in group section [%5u]\n"),
     filedata->section_headers_groups [entry]->group_index);
     warned = 
# 8187 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 8187 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
   }
      }
  }

       filedata->section_headers_groups [entry] = group;

       if (do_section_groups)
  {
    sec = filedata->section_headers + entry;
    printf ("   [%5u]   %s\n", entry, printable_section_name (filedata, sec));
  }

       g = (struct group_list *) xmalloc (sizeof (struct group_list));
       g->section_index = entry;
       g->next = group->root;
       group->root = g;
     }

   free (start);

   group++;
 }
    }

  free (symtab);
  free (strtab);
  return 
# 8214 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 8214 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}



struct ia64_vms_dynfixup
{
  uint64_t needed_ident;
  uint64_t needed;
  uint64_t fixup_needed;
  uint64_t fixup_rela_cnt;
  uint64_t fixup_rela_off;
};



struct ia64_vms_dynimgrela
{
  uint64_t img_rela_cnt;
  uint64_t img_rela_off;
};




static 
# 8239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 8240 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_ia64_vms_dynamic_fixups (Filedata * filedata,
         struct ia64_vms_dynfixup * fixup,
                              const char * strtab,
         unsigned int strtab_sz)
{
  Elf64_External_VMS_IMAGE_FIXUP * imfs;
  size_t i;
  const char * lib_name;

  imfs = get_data (
# 8249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 8249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      , filedata,
     filedata->dynamic_addr + fixup->fixup_rela_off,
     sizeof (*imfs), fixup->fixup_rela_cnt,
     gettext ("dynamic section image fixups"));
  if (!imfs)
    return 
# 8254 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 8254 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (fixup->needed < strtab_sz)
    lib_name = strtab + fixup->needed;
  else
    {
      warn (gettext ("corrupt library name index of %#" 
# 8260 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           "l" "x" 
# 8260 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           " found in dynamic entry")
                                 , fixup->needed);
      lib_name = "???";
    }

  printf (gettext ("\nImage fixups for needed library #%" 
# 8265 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "d" 
# 8265 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         ": %s - ident: %" 
# 8265 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "x" 
# 8265 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         "\n")
                                   ,
   fixup->fixup_needed, lib_name, fixup->needed_ident);
  printf
    (gettext ("Seg Offset           Type                             SymVec DataType\n"));

  for (i = 0; i < (size_t) fixup->fixup_rela_cnt; i++)
    {
      unsigned int type;
      const char *rtype;

      printf ("%3u ", (unsigned) byte_get (imfs [i].fixup_seg, sizeof (imfs [i].fixup_seg)));
      printf ("%016" 
# 8277 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    "l" "x" 
# 8277 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           " ", byte_get (imfs [i].fixup_offset, sizeof (imfs [i].fixup_offset)));
      type = byte_get (imfs [i].type, sizeof (imfs [i].type));
      rtype = elf_ia64_reloc_type (type);
      if (rtype == 
# 8280 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 8280 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
 printf ("0x%08x                       ", type);
      else
 printf ("%-32s ", rtype);
      printf ("%6u ", (unsigned) byte_get (imfs [i].symvec_index, sizeof (imfs [i].symvec_index)));
      printf ("0x%08x\n", (unsigned) byte_get (imfs [i].data_type, sizeof (imfs [i].data_type)));
    }

  free (imfs);
  return 
# 8289 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 8289 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}



static 
# 8294 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 8295 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_ia64_vms_dynamic_relocs (Filedata * filedata, struct ia64_vms_dynimgrela *imgrela)
{
  Elf64_External_VMS_IMAGE_RELA *imrs;
  size_t i;

  imrs = get_data (
# 8300 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 8300 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      , filedata,
     filedata->dynamic_addr + imgrela->img_rela_off,
     sizeof (*imrs), imgrela->img_rela_cnt,
     gettext ("dynamic section image relocations"));
  if (!imrs)
    return 
# 8305 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 8305 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  printf (gettext ("\nImage relocs\n"));
  printf
    (gettext ("Seg Offset   Type                            Addend            Seg Sym Off\n"));

  for (i = 0; i < (size_t) imgrela->img_rela_cnt; i++)
    {
      unsigned int type;
      const char *rtype;

      printf ("%3u ", (unsigned) byte_get (imrs [i].rela_seg, sizeof (imrs [i].rela_seg)));
      printf ("%08" 
# 8317 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   "l" "x" 
# 8317 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          " ", byte_get (imrs [i].rela_offset, sizeof (imrs [i].rela_offset)));
      type = byte_get (imrs [i].type, sizeof (imrs [i].type));
      rtype = elf_ia64_reloc_type (type);
      if (rtype == 
# 8320 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 8320 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
        printf ("0x%08x                      ", type);
      else
        printf ("%-31s ", rtype);
      print_vma (byte_get (imrs [i].addend, sizeof (imrs [i].addend)), FULL_HEX);
      printf ("%3u ", (unsigned) byte_get (imrs [i].sym_seg, sizeof (imrs [i].sym_seg)));
      printf ("%08" 
# 8326 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   "l" "x" 
# 8326 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          "\n", byte_get (imrs [i].sym_offset, sizeof (imrs [i].sym_offset)));
    }

  free (imrs);
  return 
# 8330 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 8330 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}



static 
# 8335 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 8336 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_ia64_vms_dynamic_relocs (Filedata * filedata)
{
  struct ia64_vms_dynfixup fixup;
  struct ia64_vms_dynimgrela imgrela;
  Elf_Internal_Dyn *entry;
  uint64_t strtab_off = 0;
  uint64_t strtab_sz = 0;
  char *strtab = 
# 8343 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 8343 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
  
# 8344 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 8344 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 8344 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 8344 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  memset (&fixup, 0, sizeof (fixup));
  memset (&imgrela, 0, sizeof (imgrela));


  for (entry = filedata->dynamic_section;
       entry < filedata->dynamic_section + filedata->dynamic_nent;
       entry++)
    {
      switch (entry->d_tag)
        {
        case (0x6000000d + 52):
          strtab_off = entry->d_un.d_val;
          break;
        case 10:
          strtab_sz = entry->d_un.d_val;
          if (strtab == 
# 8361 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 8361 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           )
     strtab = get_data (
# 8362 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 8362 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           , filedata,
          filedata->dynamic_addr + strtab_off,
                               1, strtab_sz, gettext ("dynamic string section"));
   if (strtab == 
# 8365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 8365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     strtab_sz = 0;
          break;

        case (0x6000000d + 16):
          fixup.needed_ident = entry->d_un.d_val;
          break;
        case 1:
          fixup.needed = entry->d_un.d_val;
          break;
        case (0x6000000d + 24):
          fixup.fixup_needed = entry->d_un.d_val;
          break;
        case (0x6000000d + 22):
          fixup.fixup_rela_cnt = entry->d_un.d_val;
          break;
        case (0x6000000d + 60):
          fixup.fixup_rela_off = entry->d_un.d_val;
          if (! dump_ia64_vms_dynamic_fixups (filedata, &fixup, strtab, strtab_sz))
     res = 
# 8384 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 8384 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
          break;
        case (0x6000000d + 18):
   imgrela.img_rela_cnt = entry->d_un.d_val;
          break;
        case (0x6000000d + 56):
   imgrela.img_rela_off = entry->d_un.d_val;
          if (! dump_ia64_vms_dynamic_relocs (filedata, &imgrela))
     res = 
# 8392 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 8392 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
          break;

        default:
          break;
 }
    }

  free (strtab);

  return res;
}

static struct
{
  const char * name;
  int reloc;
  int size;
  relocation_type rel_type;
}
  dynamic_relocations [] =
{
  { "REL", 17, 18, reltype_rel },
  { "RELA", 7, 8, reltype_rela },
  { "RELR", 36, 35, reltype_relr },
  { "PLT", 23, 2, reltype_unknown }
};



static 
# 8422 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 8423 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_relocs (Filedata * filedata)
{
  uint64_t rel_size;
  uint64_t rel_offset;

  if (!do_reloc)
    return 
# 8429 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 8429 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (do_using_dynamic)
    {
      relocation_type rel_type;
      const char * name;
      
# 8435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 8435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           has_dynamic_reloc;
      unsigned int i;

      has_dynamic_reloc = 
# 8438 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         0
# 8438 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              ;

      for (i = 0; i < (sizeof (dynamic_relocations) / sizeof ((dynamic_relocations)[0])); i++)
 {
   rel_type = dynamic_relocations [i].rel_type;
   name = dynamic_relocations [i].name;
   rel_size = filedata->dynamic_info[dynamic_relocations [i].size];
   rel_offset = filedata->dynamic_info[dynamic_relocations [i].reloc];

   if (rel_size)
     has_dynamic_reloc = 
# 8448 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        1
# 8448 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;

   if (rel_type == reltype_unknown)
     {
       if (dynamic_relocations [i].reloc == 23)
  switch (filedata->dynamic_info[20])
    {
    case 17:
      rel_type = reltype_rel;
      break;
    case 7:
      rel_type = reltype_rela;
      break;
    }
     }

   if (rel_size)
     {
       if (filedata->is_separate)
  printf
    (gettext ("\nIn linked file '%s' section '%s' at offset %#" 
# 8468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    "l" "x" 
# 8468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
    " contains %" 
# 8468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    "l" "d" 
# 8468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
    " bytes:\n")
                                        ,
     filedata->file_name, name, rel_offset, rel_size);
       else
  printf
    (gettext ("\n'%s' relocation section at offset %#" 
# 8473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    "l" "x" 
# 8473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
    " contains %" 
# 8473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    "l" "d" 
# 8473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
    " bytes:\n")
                                        ,
     name, rel_offset, rel_size);

       dump_relocations (filedata,
    offset_from_vma (filedata, rel_offset, rel_size),
    rel_size,
    filedata->dynamic_symbols,
    filedata->num_dynamic_syms,
    filedata->dynamic_strings,
    filedata->dynamic_strings_length,
    rel_type, 
# 8484 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1 
# 8484 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  );
     }
 }

      if (is_ia64_vms (filedata))
        if (process_ia64_vms_dynamic_relocs (filedata))
   has_dynamic_reloc = 
# 8490 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      1
# 8490 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;

      if (! has_dynamic_reloc)
 {
   if (filedata->is_separate)
     printf (gettext ("\nThere are no dynamic relocations in linked file '%s'.\n"),
      filedata->file_name);
   else
     printf (gettext ("\nThere are no dynamic relocations in this file.\n"));
 }
    }
  else
    {
      Elf_Internal_Shdr * section;
      size_t i;
      
# 8505 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 8505 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          found = 
# 8505 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  0
# 8505 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;

      for (i = 0, section = filedata->section_headers;
    i < filedata->file_header.e_shnum;
    i++, section++)
 {
   if ( section->sh_type != 4
       && section->sh_type != 9
       && section->sh_type != 19)
     continue;

   rel_offset = section->sh_offset;
   rel_size = section->sh_size;

   if (rel_size)
     {
       relocation_type rel_type;
       uint64_t num_rela;

       if (filedata->is_separate)
  printf (gettext ("\nIn linked file '%s' relocation section "),
   filedata->file_name);
       else
  printf (gettext ("\nRelocation section "));

       if (filedata->string_table == 
# 8530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    ((void *)0)
# 8530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        )
  printf ("%d", section->sh_name);
       else
  printf ("'%s'", printable_section_name (filedata, section));

       num_rela = rel_size / section->sh_entsize;
       printf (ngettext (" at offset %#" 
# 8536 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                        "l" "x"
    
# 8537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
   " contains %" 
# 8537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 "l" "u" 
# 8537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        " entry:\n",
    " at offset %#" 
# 8538 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   "l" "x"
    
# 8539 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
   " contains %" 
# 8539 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 "l" "d" 
# 8539 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        " entries:\n",
    num_rela),
        rel_offset, num_rela);

       rel_type = section->sh_type == 4 ? reltype_rela :
  section->sh_type == 9 ? reltype_rel : reltype_relr;

       if (section->sh_link != 0
    && section->sh_link < filedata->file_header.e_shnum)
  {
    Elf_Internal_Shdr *symsec;
    Elf_Internal_Sym *symtab;
    uint64_t nsyms;
    uint64_t strtablen = 0;
    char *strtab = 
# 8553 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 8553 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;

    symsec = filedata->section_headers + section->sh_link;
    if (symsec->sh_type != 2
        && symsec->sh_type != 11)
                    continue;

    if (!get_symtab (filedata, symsec,
       &symtab, &nsyms, &strtab, &strtablen))
      continue;

    dump_relocations (filedata, rel_offset, rel_size,
        symtab, nsyms, strtab, strtablen,
        rel_type,
        symsec->sh_type == 11);
    free (strtab);
    free (symtab);
  }
       else
  dump_relocations (filedata, rel_offset, rel_size,
      
# 8573 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ((void *)0)
# 8573 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         , 0, 
# 8573 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 8573 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  , 0, rel_type, 
# 8573 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 0 
# 8573 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                       );

       found = 
# 8575 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 8575 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }
 }

      if (! found)
 {

   for (i = 0; i < (sizeof (dynamic_relocations) / sizeof ((dynamic_relocations)[0])); i++)
     {
       if (filedata->dynamic_info[dynamic_relocations [i].size])
  {
    if (filedata->is_separate)
      printf (gettext ("\nThere are no static relocations in linked file '%s'."),
       filedata->file_name);
    else
      printf (gettext ("\nThere are no static relocations in this file."));
    printf (gettext ("\nTo see the dynamic relocations add --use-dynamic to the command line.\n"));

    break;
  }
     }
   if (i == (sizeof (dynamic_relocations) / sizeof ((dynamic_relocations)[0])))
     {
       if (filedata->is_separate)
  printf (gettext ("\nThere are no relocations in linked file '%s'.\n"),
   filedata->file_name);
       else
  printf (gettext ("\nThere are no relocations in this file.\n"));
     }
 }
    }

  return 
# 8607 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 8607 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}





struct absaddr
{
  unsigned short section;
  uint64_t offset;
};




static void
find_symbol_for_address (Filedata *filedata,
    Elf_Internal_Sym *symtab,
    uint64_t nsyms,
    const char *strtab,
    uint64_t strtab_size,
    struct absaddr addr,
    const char **symname,
    uint64_t *offset)
{
  uint64_t dist = 0x100000;
  Elf_Internal_Sym * sym;
  Elf_Internal_Sym * beg;
  Elf_Internal_Sym * end;
  Elf_Internal_Sym * best = 
# 8637 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 8637 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;

  do { if (filedata->file_header.e_machine == 40) (addr.offset) &= ~1; } while (0);
  beg = symtab;
  end = symtab + nsyms;

  while (beg < end)
    {
      uint64_t value;

      sym = beg + (end - beg) / 2;

      value = sym->st_value;
      do { if (filedata->file_header.e_machine == 40) (value) &= ~1; } while (0);

      if (sym->st_name != 0
   && (addr.section == 0 || addr.section == sym->st_shndx)
   && addr.offset >= value
   && addr.offset - value < dist)
 {
   best = sym;
   dist = addr.offset - value;
   if (!dist)
     break;
 }

      if (addr.offset < value)
 end = sym;
      else
 beg = sym + 1;
    }

  if (best)
    {
      *symname = (best->st_name >= strtab_size
    ? gettext ("<corrupt>") : strtab + best->st_name);
      *offset = dist;
      return;
    }

  *symname = 
# 8677 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 8677 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
  *offset = addr.offset;
}

static int
symcmp (const void *p, const void *q)
{
  Elf_Internal_Sym *sp = (Elf_Internal_Sym *) p;
  Elf_Internal_Sym *sq = (Elf_Internal_Sym *) q;

  return sp->st_value > sq->st_value ? 1 : (sp->st_value < sq->st_value ? -1 : 0);
}



# 1 "/doner/binutils/binutils-515f23e/binutils/./unwind-ia64.h" 1
# 32 "/doner/binutils/binutils-515f23e/binutils/./unwind-ia64.h"
extern const unsigned char *unw_decode (const unsigned char *, int, void *, const unsigned char *);
# 8693 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 2

struct ia64_unw_table_entry
{
  struct absaddr start;
  struct absaddr end;
  struct absaddr info;
};

struct ia64_unw_aux_info
{
  struct ia64_unw_table_entry * table;
  uint64_t table_len;
  unsigned char * info;
  uint64_t info_size;
  uint64_t info_addr;
  uint64_t seg_base;
  Elf_Internal_Sym * symtab;
  uint64_t nsyms;
  Elf_Internal_Sym * funtab;
  uint64_t nfuns;
  char * strtab;
  uint64_t strtab_size;
};

static 
# 8717 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 8718 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_ia64_unwind (Filedata * filedata, struct ia64_unw_aux_info * aux)
{
  struct ia64_unw_table_entry * tp;
  size_t j, nfuns;
  int in_body;
  
# 8723 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 8723 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 8723 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 8723 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
    if (aux->symtab[j].st_value && ((aux->symtab[j].st_info) & 0xF) == 2)
      aux->funtab[nfuns++] = aux->symtab[j];
  aux->nfuns = nfuns;
  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);

  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
    {
      uint64_t stamp;
      uint64_t offset;
      const unsigned char * dp;
      const unsigned char * head;
      const unsigned char * end;
      const char * procname;

      find_symbol_for_address (filedata, aux->funtab, aux->nfuns, aux->strtab,
          aux->strtab_size, tp->start, &procname, &offset);

      fputs ("\n<", 
# 8744 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   stdout
# 8744 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         );

      if (procname)
 {
   fputs (procname, 
# 8748 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   stdout
# 8748 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         );

   if (offset)
     printf ("+%" 
# 8751 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 "l" "x"
# 8751 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       , offset);
 }

      fputs (">: [", 
# 8754 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    stdout
# 8754 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          );
      print_vma (tp->start.offset, PREFIX_HEX);
      fputc ('-', 
# 8756 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout
# 8756 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
      print_vma (tp->end.offset, PREFIX_HEX);
      printf ("], info at +0x%" 
# 8758 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               "l" "x" 
# 8758 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      "\n",
       tp->info.offset - aux->seg_base);


      if (aux->info == 
# 8762 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 8762 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          )
 continue;

      offset = tp->info.offset;
      if (tp->info.section)
 {
   if (tp->info.section >= filedata->file_header.e_shnum)
     {
       warn (gettext ("Invalid section %u in table entry %td\n"),
      tp->info.section, tp - aux->table);
       res = 
# 8772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 8772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
       continue;
     }
   offset += filedata->section_headers[tp->info.section].sh_addr;
 }
      offset -= aux->info_addr;

      if (offset >= aux->info_size
   || aux->info_size - offset < 8)
 {
   warn (gettext ("Invalid offset %" 
# 8782 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        "l" "x" 
# 8782 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        " in table entry %td\n"),
  tp->info.offset, tp - aux->table);
   res = 
# 8784 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 8784 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
   continue;
 }

      head = aux->info + offset;
      stamp = byte_get ((unsigned char *) head, sizeof (stamp));

      printf ("  v%u, flags=0x%lx (%s%s), len=%lu bytes\n",
       (unsigned) ((stamp) >> 48),
       (unsigned long) ((stamp & 0x0000ffff00000000LL) >> 32),
       ((stamp) & 0x0000000100000000LL) ? " ehandler" : "",
       ((stamp) & 0x0000000200000000LL) ? " uhandler" : "",
       (unsigned long) (eh_addr_size * ((stamp) & 0x00000000ffffffffLL)));

      if (((stamp) >> 48) != 1)
 {
   printf (gettext ("\tUnknown version.\n"));
   continue;
 }

      in_body = 0;
      end = head + 8 + eh_addr_size * ((stamp) & 0x00000000ffffffffLL);

      if (end > aux->info + aux->info_size)
 end = aux->info + aux->info_size;
      for (dp = head + 8; dp < end;)
 dp = unw_decode (dp, in_body, & in_body, end);
    }

  free (aux->funtab);

  return res;
}

static 
# 8818 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 8819 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
slurp_ia64_unwind_table (Filedata * filedata,
    struct ia64_unw_aux_info * aux,
    Elf_Internal_Shdr * sec)
{
  uint64_t size, nrelas, i;
  Elf_Internal_Phdr * seg;
  struct ia64_unw_table_entry * tep;
  Elf_Internal_Shdr * relsec;
  Elf_Internal_Rela * rela;
  Elf_Internal_Rela * rp;
  unsigned char * table;
  unsigned char * tp;
  Elf_Internal_Sym * sym;
  const char * relname;

  aux->table_len = 0;




  if (filedata->file_header.e_phnum)
    {
      if (! get_program_headers (filedata))
   return 
# 8842 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 8842 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

      for (seg = filedata->program_headers;
    seg < filedata->program_headers + filedata->file_header.e_phnum;
    ++seg)
 {
   if (seg->p_type != 1)
     continue;

   if (sec->sh_addr >= seg->p_vaddr
       && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
     {
       aux->seg_base = seg->p_vaddr;
       break;
     }
 }
    }


  size = sec->sh_size;
  table = (unsigned char *) get_data (
# 8862 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
# 8862 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         , filedata, sec->sh_offset, 1, size,
                                      gettext ("unwind table"));
  if (!table)
    return 
# 8865 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 8865 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  aux->table_len = size / (3 * eh_addr_size);
  aux->table = (struct ia64_unw_table_entry *)
    xcmalloc (aux->table_len, sizeof (aux->table[0]));
  tep = aux->table;

  for (tp = table; tp <= table + size - (3 * eh_addr_size); ++tep)
    {
      tep->start.section = 0;
      tep->end.section = 0;
      tep->info.section = 0;
      tep->start.offset = byte_get (tp, eh_addr_size); tp += eh_addr_size;
      tep->end.offset = byte_get (tp, eh_addr_size); tp += eh_addr_size;
      tep->info.offset = byte_get (tp, eh_addr_size); tp += eh_addr_size;
      tep->start.offset += aux->seg_base;
      tep->end.offset += aux->seg_base;
      tep->info.offset += aux->seg_base;
    }
  free (table);


  for (relsec = filedata->section_headers;
       relsec < filedata->section_headers + filedata->file_header.e_shnum;
       ++relsec)
    {
      if (relsec->sh_type != 4
   || relsec->sh_info >= filedata->file_header.e_shnum
   || filedata->section_headers + relsec->sh_info != sec)
 continue;

      if (!slurp_rela_relocs (filedata, relsec->sh_offset, relsec->sh_size,
         & rela, & nrelas))
 {
   free (aux->table);
   aux->table = 
# 8900 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 8900 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
   aux->table_len = 0;
   return 
# 8902 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 8902 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      for (rp = rela; rp < rela + nrelas; ++rp)
 {
   unsigned int sym_ndx;
   unsigned int r_type = get_reloc_type (filedata, rp->r_info);
   relname = elf_ia64_reloc_type (r_type);


   if (relname == 
# 8912 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 8912 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
     {
       warn (gettext ("Skipping unknown relocation type: %u\n"), r_type);
       continue;
     }

   if (! startswith (relname, "R_IA64_SEGREL"))
     {
       warn (gettext ("Skipping unexpected relocation type: %s\n"), relname);
       continue;
     }

   i = rp->r_offset / (3 * eh_addr_size);


   if (i >= aux->table_len)
     {
       warn (gettext ("Skipping reloc with overlarge offset: %#" 
# 8929 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 8929 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n"),
      i);
       continue;
     }

   sym_ndx = get_reloc_symindex (rp->r_info);
   if (sym_ndx >= aux->nsyms)
     {
       warn (gettext ("Skipping reloc with invalid symbol index: %u\n"),
      sym_ndx);
       continue;
     }
   sym = aux->symtab + sym_ndx;

   switch (rp->r_offset / eh_addr_size % 3)
     {
     case 0:
       aux->table[i].start.section = sym->st_shndx;
       aux->table[i].start.offset = rp->r_addend + sym->st_value;
       break;
     case 1:
       aux->table[i].end.section = sym->st_shndx;
       aux->table[i].end.offset = rp->r_addend + sym->st_value;
       break;
     case 2:
       aux->table[i].info.section = sym->st_shndx;
       aux->table[i].info.offset = rp->r_addend + sym->st_value;
       break;
     default:
       break;
     }
 }

      free (rela);
    }

  return 
# 8965 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 8965 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 8968 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 8969 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
ia64_process_unwind (Filedata * filedata)
{
  Elf_Internal_Shdr * sec;
  Elf_Internal_Shdr * unwsec = 
# 8972 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 8972 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  ;
  uint64_t i, unwcount = 0, unwstart = 0;
  struct ia64_unw_aux_info aux;
  
# 8975 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 8975 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 8975 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 8975 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  memset (& aux, 0, sizeof (aux));

  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == 2)
 {
   if (aux.symtab)
     {
       error (gettext ("Multiple symbol tables encountered\n"));
       free (aux.symtab);
       aux.symtab = 
# 8987 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 8987 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
       free (aux.strtab);
       aux.strtab = 
# 8989 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 8989 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
     }
   if (!get_symtab (filedata, sec, &aux.symtab, &aux.nsyms,
      &aux.strtab, &aux.strtab_size))
     return 
# 8993 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 8993 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
 }
      else if (sec->sh_type == (0x70000000 + 1))
 unwcount++;
    }

  if (!unwcount)
    printf (gettext ("\nThere are no unwind sections in this file.\n"));

  while (unwcount-- > 0)
    {
      const char *suffix;
      size_t len, len2;

      for (i = unwstart, sec = filedata->section_headers + unwstart, unwsec = 
# 9007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                             ((void *)0)
# 9007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                 ;
    i < filedata->file_header.e_shnum; ++i, ++sec)
 if (sec->sh_type == (0x70000000 + 1))
   {
     unwsec = sec;
     break;
   }


      
# 9016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ((void) sizeof ((
# 9016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     unwsec != 
# 9016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ((void *)0)) ? 1 : 0), __extension__ ({ if (
# 9016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     unwsec != 
# 9016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ((void *)0)) ; else __assert_fail (
# 9016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     "unwsec != NULL"
# 9016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 9016, __extension__ __PRETTY_FUNCTION__); }))
# 9016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;

      unwstart = i + 1;
      len = sizeof (".gnu.linkonce.ia64unw.") - 1;

      if ((unwsec->sh_flags & (1 << 9)) != 0)
 {

   struct group_list * g;

   if (filedata->section_headers_groups == 
# 9026 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
       
# 9027 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      || filedata->section_headers_groups[i] == 
# 9027 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                ((void *)0)
# 9027 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    )
     i = filedata->file_header.e_shnum;
   else
     {
       g = filedata->section_headers_groups[i]->root;

       for (; g != 
# 9033 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 9033 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ; g = g->next)
  {
    sec = filedata->section_headers + g->section_index;

    if (section_name_valid (filedata, sec)
        && (strcmp ((section_name (filedata, sec)), (".IA_64.unwind_info")) == 0)
                                )
      break;
  }

       if (g == 
# 9043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 9043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   )
  i = filedata->file_header.e_shnum;
     }
 }
      else if (section_name_valid (filedata, unwsec)
        && startswith (section_name (filedata, unwsec),
         ".gnu.linkonce.ia64unw."))
 {

   len2 = sizeof (".gnu.linkonce.ia64unwi.") - 1;
   suffix = section_name (filedata, unwsec) + len;
   for (i = 0, sec = filedata->section_headers;
        i < filedata->file_header.e_shnum;
        ++i, ++sec)
     if (section_name_valid (filedata, sec)
  && startswith (section_name (filedata, sec),
          ".gnu.linkonce.ia64unwi.")
  && (strcmp ((section_name (filedata, sec) + len2), (suffix)) == 0))
       break;
 }
      else
 {


   len = sizeof (".IA_64.unwind") - 1;
   len2 = sizeof (".IA_64.unwind_info") - 1;
   suffix = "";
   if (section_name_valid (filedata, unwsec)
       && startswith (section_name (filedata, unwsec),
        ".IA_64.unwind"))
     suffix = section_name (filedata, unwsec) + len;
   for (i = 0, sec = filedata->section_headers;
        i < filedata->file_header.e_shnum;
        ++i, ++sec)
     if (section_name_valid (filedata, sec)
  && startswith (section_name (filedata, sec),
          ".IA_64.unwind_info")
  && (strcmp ((section_name (filedata, sec) + len2), (suffix)) == 0))
       break;
 }

      if (i == filedata->file_header.e_shnum)
 {
   printf (gettext ("\nCould not find unwind info section for "));

   if (filedata->string_table == 
# 9088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 9088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    )
     printf ("%d", unwsec->sh_name);
   else
     printf ("'%s'", printable_section_name (filedata, unwsec));
 }
      else
 {
   aux.info_addr = sec->sh_addr;
   aux.info = (unsigned char *) get_data (
# 9096 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         ((void *)0)
# 9096 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             , filedata, sec->sh_offset, 1,
       sec->sh_size,
       gettext ("unwind info"));
   aux.info_size = aux.info == 
# 9099 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0) 
# 9099 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ? 0 : sec->sh_size;

   printf (gettext ("\nUnwind section "));

   if (filedata->string_table == 
# 9103 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 9103 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    )
     printf ("%d", unwsec->sh_name);
   else
     printf ("'%s'", printable_section_name (filedata, unwsec));

   printf (gettext (" at offset %#" 
# 9108 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "x" 
# 9108 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          " contains %" 
# 9108 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "u" 
# 9108 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          " entries:\n"),
    unwsec->sh_offset,
    unwsec->sh_size / (3 * eh_addr_size));

   if (slurp_ia64_unwind_table (filedata, & aux, unwsec)
       && aux.table_len > 0)
     dump_ia64_unwind (filedata, & aux);

   free ((char *) aux.table);
   free ((char *) aux.info);
   aux.table = 
# 9118 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 9118 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
   aux.info = 
# 9119 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 9119 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
 }
    }

  free (aux.symtab);
  free ((char *) aux.strtab);

  return res;
}

struct hppa_unw_table_entry
{
  struct absaddr start;
  struct absaddr end;
  unsigned int Cannot_unwind:1;
  unsigned int Millicode:1;
  unsigned int Millicode_save_sr0:1;
  unsigned int Region_description:2;
  unsigned int reserved1:1;
  unsigned int Entry_SR:1;
  unsigned int Entry_FR:4;
  unsigned int Entry_GR:5;
  unsigned int Args_stored:1;
  unsigned int Variable_Frame:1;
  unsigned int Separate_Package_Body:1;
  unsigned int Frame_Extension_Millicode:1;
  unsigned int Stack_Overflow_Check:1;
  unsigned int Two_Instruction_SP_Increment:1;
  unsigned int Ada_Region:1;
  unsigned int cxx_info:1;
  unsigned int cxx_try_catch:1;
  unsigned int sched_entry_seq:1;
  unsigned int reserved2:1;
  unsigned int Save_SP:1;
  unsigned int Save_RP:1;
  unsigned int Save_MRP_in_frame:1;
  unsigned int extn_ptr_defined:1;
  unsigned int Cleanup_defined:1;

  unsigned int MPE_XL_interrupt_marker:1;
  unsigned int HP_UX_interrupt_marker:1;
  unsigned int Large_frame:1;
  unsigned int Pseudo_SP_Set:1;
  unsigned int reserved4:1;
  unsigned int Total_frame_size:27;
};

struct hppa_unw_aux_info
{
  struct hppa_unw_table_entry * table;
  uint64_t table_len;
  uint64_t seg_base;
  Elf_Internal_Sym * symtab;
  uint64_t nsyms;
  Elf_Internal_Sym * funtab;
  uint64_t nfuns;
  char * strtab;
  uint64_t strtab_size;
};

static 
# 9179 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 9180 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_hppa_unwind (Filedata * filedata, struct hppa_unw_aux_info * aux)
{
  struct hppa_unw_table_entry * tp;
  uint64_t j, nfuns;
  
# 9184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 9184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 9184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 9184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
    if (aux->symtab[j].st_value && ((aux->symtab[j].st_info) & 0xF) == 2)
      aux->funtab[nfuns++] = aux->symtab[j];
  aux->nfuns = nfuns;
  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);

  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
    {
      uint64_t offset;
      const char * procname;

      find_symbol_for_address (filedata, aux->funtab, aux->nfuns, aux->strtab,
          aux->strtab_size, tp->start, &procname,
          &offset);

      fputs ("\n<", 
# 9202 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   stdout
# 9202 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         );

      if (procname)
 {
   fputs (procname, 
# 9206 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   stdout
# 9206 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         );

   if (offset)
     printf ("+%" 
# 9209 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 "l" "x"
# 9209 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       , offset);
 }

      fputs (">: [", 
# 9212 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    stdout
# 9212 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          );
      print_vma (tp->start.offset, PREFIX_HEX);
      fputc ('-', 
# 9214 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout
# 9214 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
      print_vma (tp->end.offset, PREFIX_HEX);
      printf ("]\n\t");



      if (tp->Cannot_unwind) printf ("Cannot_unwind" " ");;
      if (tp->Millicode) printf ("Millicode" " ");;
      if (tp->Millicode_save_sr0) printf ("Millicode_save_sr0" " ");;

      if (tp->Entry_SR) printf ("Entry_SR" " ");;
      if (tp->Entry_FR) printf ("Entry_FR" "=%d ", tp->Entry_FR);;
      if (tp->Entry_GR) printf ("Entry_GR" "=%d ", tp->Entry_GR);;
      if (tp->Args_stored) printf ("Args_stored" " ");;
      if (tp->Variable_Frame) printf ("Variable_Frame" " ");;
      if (tp->Separate_Package_Body) printf ("Separate_Package_Body" " ");;
      if (tp->Frame_Extension_Millicode) printf ("Frame_Extension_Millicode" " ");;
      if (tp->Stack_Overflow_Check) printf ("Stack_Overflow_Check" " ");;
      if (tp->Two_Instruction_SP_Increment) printf ("Two_Instruction_SP_Increment" " ");;
      if (tp->Ada_Region) printf ("Ada_Region" " ");;
      if (tp->cxx_info) printf ("cxx_info" " ");;
      if (tp->cxx_try_catch) printf ("cxx_try_catch" " ");;
      if (tp->sched_entry_seq) printf ("sched_entry_seq" " ");;
      if (tp->Save_SP) printf ("Save_SP" " ");;
      if (tp->Save_RP) printf ("Save_RP" " ");;
      if (tp->Save_MRP_in_frame) printf ("Save_MRP_in_frame" " ");;
      if (tp->extn_ptr_defined) printf ("extn_ptr_defined" " ");;
      if (tp->Cleanup_defined) printf ("Cleanup_defined" " ");;
      if (tp->MPE_XL_interrupt_marker) printf ("MPE_XL_interrupt_marker" " ");;
      if (tp->HP_UX_interrupt_marker) printf ("HP_UX_interrupt_marker" " ");;
      if (tp->Large_frame) printf ("Large_frame" " ");;
      if (tp->Pseudo_SP_Set) printf ("Pseudo_SP_Set" " ");;
      if (tp->Total_frame_size) printf ("Total_frame_size" "=%d ", tp->Total_frame_size);;


    }

  printf ("\n");

  free (aux->funtab);

  return res;
}

static 
# 9258 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 9259 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
slurp_hppa_unwind_table (Filedata * filedata,
    struct hppa_unw_aux_info * aux,
    Elf_Internal_Shdr * sec)
{
  uint64_t size, unw_ent_size, nentries, nrelas, i;
  Elf_Internal_Phdr * seg;
  struct hppa_unw_table_entry * tep;
  Elf_Internal_Shdr * relsec;
  Elf_Internal_Rela * rela;
  Elf_Internal_Rela * rp;
  unsigned char * table;
  unsigned char * tp;
  Elf_Internal_Sym * sym;
  const char * relname;



  if (filedata->file_header.e_phnum)
    {
      if (! get_program_headers (filedata))
 return 
# 9279 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 9279 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      for (seg = filedata->program_headers;
    seg < filedata->program_headers + filedata->file_header.e_phnum;
    ++seg)
 {
   if (seg->p_type != 1)
     continue;

   if (sec->sh_addr >= seg->p_vaddr
       && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
     {
       aux->seg_base = seg->p_vaddr;
       break;
     }
 }
    }



  size = sec->sh_size;
  table = (unsigned char *) get_data (
# 9300 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
# 9300 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         , filedata, sec->sh_offset, 1, size,
                                      gettext ("unwind table"));
  if (!table)
    return 
# 9303 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 9303 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  unw_ent_size = 16;
  nentries = size / unw_ent_size;
  size = unw_ent_size * nentries;

  aux->table_len = nentries;
  tep = aux->table = (struct hppa_unw_table_entry *)
      xcmalloc (nentries, sizeof (aux->table[0]));

  for (tp = table; tp < table + size; tp += unw_ent_size, ++tep)
    {
      unsigned int tmp1, tmp2;

      tep->start.section = 0;
      tep->end.section = 0;

      tep->start.offset = byte_get ((unsigned char *) tp + 0, 4);
      tep->end.offset = byte_get ((unsigned char *) tp + 4, 4);
      tmp1 = byte_get ((unsigned char *) tp + 8, 4);
      tmp2 = byte_get ((unsigned char *) tp + 12, 4);

      tep->start.offset += aux->seg_base;
      tep->end.offset += aux->seg_base;

      tep->Cannot_unwind = (tmp1 >> 31) & 0x1;
      tep->Millicode = (tmp1 >> 30) & 0x1;
      tep->Millicode_save_sr0 = (tmp1 >> 29) & 0x1;
      tep->Region_description = (tmp1 >> 27) & 0x3;
      tep->reserved1 = (tmp1 >> 26) & 0x1;
      tep->Entry_SR = (tmp1 >> 25) & 0x1;
      tep->Entry_FR = (tmp1 >> 21) & 0xf;
      tep->Entry_GR = (tmp1 >> 16) & 0x1f;
      tep->Args_stored = (tmp1 >> 15) & 0x1;
      tep->Variable_Frame = (tmp1 >> 14) & 0x1;
      tep->Separate_Package_Body = (tmp1 >> 13) & 0x1;
      tep->Frame_Extension_Millicode = (tmp1 >> 12) & 0x1;
      tep->Stack_Overflow_Check = (tmp1 >> 11) & 0x1;
      tep->Two_Instruction_SP_Increment = (tmp1 >> 10) & 0x1;
      tep->Ada_Region = (tmp1 >> 9) & 0x1;
      tep->cxx_info = (tmp1 >> 8) & 0x1;
      tep->cxx_try_catch = (tmp1 >> 7) & 0x1;
      tep->sched_entry_seq = (tmp1 >> 6) & 0x1;
      tep->reserved2 = (tmp1 >> 5) & 0x1;
      tep->Save_SP = (tmp1 >> 4) & 0x1;
      tep->Save_RP = (tmp1 >> 3) & 0x1;
      tep->Save_MRP_in_frame = (tmp1 >> 2) & 0x1;
      tep->extn_ptr_defined = (tmp1 >> 1) & 0x1;
      tep->Cleanup_defined = tmp1 & 0x1;

      tep->MPE_XL_interrupt_marker = (tmp2 >> 31) & 0x1;
      tep->HP_UX_interrupt_marker = (tmp2 >> 30) & 0x1;
      tep->Large_frame = (tmp2 >> 29) & 0x1;
      tep->Pseudo_SP_Set = (tmp2 >> 28) & 0x1;
      tep->reserved4 = (tmp2 >> 27) & 0x1;
      tep->Total_frame_size = tmp2 & 0x7ffffff;
    }
  free (table);


  for (relsec = filedata->section_headers;
       relsec < filedata->section_headers + filedata->file_header.e_shnum;
       ++relsec)
    {
      if (relsec->sh_type != 4
   || relsec->sh_info >= filedata->file_header.e_shnum
   || filedata->section_headers + relsec->sh_info != sec)
 continue;

      if (!slurp_rela_relocs (filedata, relsec->sh_offset, relsec->sh_size,
         & rela, & nrelas))
 return 
# 9374 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 9374 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      for (rp = rela; rp < rela + nrelas; ++rp)
 {
   unsigned int sym_ndx;
   unsigned int r_type = get_reloc_type (filedata, rp->r_info);
   relname = elf_hppa_reloc_type (r_type);

   if (relname == 
# 9382 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 9382 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
     {
       warn (gettext ("Skipping unknown relocation type: %u\n"), r_type);
       continue;
     }


   if (! startswith (relname, "R_PARISC_SEGREL"))
     {
       warn (gettext ("Skipping unexpected relocation type: %s\n"), relname);
       continue;
     }

   i = rp->r_offset / unw_ent_size;
   if (i >= aux->table_len)
     {
       warn (gettext ("Skipping reloc with overlarge offset: %#" 
# 9398 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 9398 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n"),
      i);
       continue;
     }

   sym_ndx = get_reloc_symindex (rp->r_info);
   if (sym_ndx >= aux->nsyms)
     {
       warn (gettext ("Skipping reloc with invalid symbol index: %u\n"),
      sym_ndx);
       continue;
     }
   sym = aux->symtab + sym_ndx;

   switch ((rp->r_offset % unw_ent_size) / 4)
     {
     case 0:
       aux->table[i].start.section = sym->st_shndx;
       aux->table[i].start.offset = sym->st_value + rp->r_addend;
       break;
     case 1:
       aux->table[i].end.section = sym->st_shndx;
       aux->table[i].end.offset = sym->st_value + rp->r_addend;
       break;
     default:
       break;
     }
 }

      free (rela);
    }

  return 
# 9430 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 9430 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 9433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 9434 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
hppa_process_unwind (Filedata * filedata)
{
  struct hppa_unw_aux_info aux;
  Elf_Internal_Shdr * unwsec = 
# 9437 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 9437 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  ;
  Elf_Internal_Shdr * sec;
  size_t i;
  
# 9440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 9440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 9440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 9440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (filedata->string_table == 
# 9442 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 9442 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   )
    return 
# 9443 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 9443 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  memset (& aux, 0, sizeof (aux));

  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == 2)
 {
   if (aux.symtab)
     {
       error (gettext ("Multiple symbol tables encountered\n"));
       free (aux.symtab);
       aux.symtab = 
# 9455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 9455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
       free (aux.strtab);
       aux.strtab = 
# 9457 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 9457 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
     }
   if (!get_symtab (filedata, sec, &aux.symtab, &aux.nsyms,
      &aux.strtab, &aux.strtab_size))
     return 
# 9461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 9461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
 }
      else if (section_name_valid (filedata, sec)
        && (strcmp ((section_name (filedata, sec)), (".PARISC.unwind")) == 0))
 unwsec = sec;
    }

  if (!unwsec)
    printf (gettext ("\nThere are no unwind sections in this file.\n"));

  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
    {
      if (section_name_valid (filedata, sec)
   && (strcmp ((section_name (filedata, sec)), (".PARISC.unwind")) == 0))
 {
   uint64_t num_unwind = sec->sh_size / 16;

   printf (ngettext ("\nUnwind section '%s' at offset %#" 
# 9478 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                         "l" "x" 
# 9478 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                " "
       "contains %" 
# 9479 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   "l" "u" 
# 9479 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          " entry:\n",
       "\nUnwind section '%s' at offset %#" 
# 9480 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           "l" "x" 
# 9480 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  " "
       "contains %" 
# 9481 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   "l" "u" 
# 9481 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          " entries:\n",
       num_unwind),
    printable_section_name (filedata, sec),
    sec->sh_offset,
    num_unwind);

          if (! slurp_hppa_unwind_table (filedata, &aux, sec))
     res = 
# 9488 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 9488 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

   if (res && aux.table_len > 0)
     {
       if (! dump_hppa_unwind (filedata, &aux))
  res = 
# 9493 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 9493 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
     }

   free ((char *) aux.table);
   aux.table = 
# 9497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 9497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
 }
    }

  free (aux.symtab);
  free ((char *) aux.strtab);

  return res;
}

struct arm_section
{
  unsigned char * data;
  Elf_Internal_Shdr * sec;
  Elf_Internal_Rela * rela;
  uint64_t nrelas;
  unsigned int rel_type;
  Elf_Internal_Rela * next_rela;
};

struct arm_unw_aux_info
{
  Filedata * filedata;
  Elf_Internal_Sym * symtab;
  uint64_t nsyms;
  Elf_Internal_Sym * funtab;
  uint64_t nfuns;
  char * strtab;
  uint64_t strtab_size;
};

static const char *
arm_print_vma_and_name (Filedata * filedata,
   struct arm_unw_aux_info * aux,
   uint64_t fn,
   struct absaddr addr)
{
  const char *procname;
  uint64_t sym_offset;

  if (addr.section == 0)
    addr.offset = fn;

  find_symbol_for_address (filedata, aux->funtab, aux->nfuns, aux->strtab,
      aux->strtab_size, addr, &procname,
      &sym_offset);

  print_vma (fn, PREFIX_HEX);

  if (procname)
    {
      fputs (" <", 
# 9548 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  stdout
# 9548 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        );
      fputs (procname, 
# 9549 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      stdout
# 9549 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            );

      if (sym_offset)
 printf ("+0x%" 
# 9552 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               "l" "x"
# 9552 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     , sym_offset);
      fputc ('>', 
# 9553 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout
# 9553 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
    }

  return procname;
}

static void
arm_free_section (struct arm_section *arm_sec)
{
  free (arm_sec->data);
  free (arm_sec->rela);
}
# 9577 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static 
# 9577 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 9578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_unwind_section_word (Filedata * filedata,
    struct arm_unw_aux_info * aux,
    struct arm_section * arm_sec,
    Elf_Internal_Shdr * sec,
    uint64_t word_offset,
    unsigned int * wordp,
    struct absaddr * addr,
    uint64_t * sym_name)
{
  Elf_Internal_Rela *rp;
  Elf_Internal_Sym *sym;
  const char * relname;
  unsigned int word;
  
# 9591 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 9591 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      wrapped;

  if (sec == 
# 9593 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0) 
# 9593 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 || arm_sec == 
# 9593 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 9593 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   )
    return 
# 9594 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 9594 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  addr->section = 0;
  addr->offset = 0;

  if (sym_name != 
# 9599 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 9599 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
    *sym_name = (uint64_t) -1;


  if (sec != arm_sec->sec)
    {
      Elf_Internal_Shdr *relsec;

      arm_free_section (arm_sec);

      arm_sec->sec = sec;
      arm_sec->data = get_data (
# 9610 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 9610 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   , aux->filedata, sec->sh_offset, 1,
    sec->sh_size, gettext ("unwind data"));
      arm_sec->rela = 
# 9612 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 9612 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
      arm_sec->nrelas = 0;

      for (relsec = filedata->section_headers;
    relsec < filedata->section_headers + filedata->file_header.e_shnum;
    ++relsec)
 {
   if (relsec->sh_info >= filedata->file_header.e_shnum
       || filedata->section_headers + relsec->sh_info != sec

       || (relsec->sh_type != 9
    && relsec->sh_type != 4))
     continue;

   arm_sec->rel_type = relsec->sh_type;
   if (relsec->sh_type == 9)
     {
       if (!slurp_rel_relocs (aux->filedata, relsec->sh_offset,
         relsec->sh_size,
         & arm_sec->rela, & arm_sec->nrelas))
  return 
# 9632 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 9632 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
     }
   else
     {
       if (!slurp_rela_relocs (aux->filedata, relsec->sh_offset,
          relsec->sh_size,
          & arm_sec->rela, & arm_sec->nrelas))
  return 
# 9639 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 9639 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
     }
   break;
 }

      arm_sec->next_rela = arm_sec->rela;
    }


  if (arm_sec->data == 
# 9648 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 9648 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          )
    return 
# 9649 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 9649 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;


  if (
      sec->sh_size < 4
      || word_offset > sec->sh_size - 4)
    return 
# 9655 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 9655 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;


  word = byte_get (arm_sec->data + word_offset, 4);


  if (arm_sec->rela == 
# 9661 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 9661 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          )
    {
      * wordp = word;
      return 
# 9664 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 9664 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }


  wrapped = 
# 9668 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 9668 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
  for (rp = arm_sec->next_rela; rp != arm_sec->rela + arm_sec->nrelas; rp++)
    {
      uint64_t prelval, offset;

      if (rp->r_offset > word_offset && !wrapped)
 {
   rp = arm_sec->rela;
   wrapped = 
# 9676 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 9676 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
 }
      if (rp->r_offset > word_offset)
 break;

      if (rp->r_offset & 3)
 {
   warn (gettext ("Skipping unexpected relocation at offset %#" 
# 9683 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        "l" "x" 
# 9683 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        "\n"),
  rp->r_offset);
   continue;
 }

      if (rp->r_offset < word_offset)
 continue;


      if (aux->symtab == 
# 9692 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 9692 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            )
 continue;

      if (arm_sec->rel_type == 9)
 {
   offset = word & 0x7fffffff;
   if (offset & 0x40000000)
     offset |= ~ (uint64_t) 0x7fffffff;
 }
      else if (arm_sec->rel_type == 4)
 offset = rp->r_addend;
      else
 {
   error (gettext ("Unknown section relocation type %d encountered\n"),
   arm_sec->rel_type);
   break;
 }


      if (((rp->r_info) >> 8) >= aux->nsyms)
 {
   error (gettext ("Bad symbol index in unwind relocation " "(%" 
# 9713 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "u" 
# 9713 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         " > %" 
# 9713 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "u" 
# 9713 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         ")\n")
                                     ,
   ((rp->r_info) >> 8), aux->nsyms);
   break;
 }

      sym = aux->symtab + ((rp->r_info) >> 8);
      offset += sym->st_value;
      prelval = offset - (arm_sec->sec->sh_addr + rp->r_offset);


      if (filedata->file_header.e_machine == 40)
 {
   relname = elf_arm_reloc_type (((rp->r_info) & 0xff));
   if (relname == 
# 9727 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 9727 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
     {
       warn (gettext ("Skipping unknown ARM relocation type: %d\n"),
      (int) ((rp->r_info) & 0xff));
       continue;
     }

   if ((strcmp ((relname), ("R_ARM_NONE")) == 0))
       continue;

   if (! (strcmp ((relname), ("R_ARM_PREL31")) == 0))
     {
       warn (gettext ("Skipping unexpected ARM relocation type %s\n"), relname);
       continue;
     }
 }
      else if (filedata->file_header.e_machine == 140)
 {
   relname = elf_tic6x_reloc_type (((rp->r_info) & 0xff));
   if (relname == 
# 9746 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 9746 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
     {
       warn (gettext ("Skipping unknown C6000 relocation type: %d\n"),
      (int) ((rp->r_info) & 0xff));
       continue;
     }

   if ((strcmp ((relname), ("R_C6000_NONE")) == 0))
     continue;

   if (! (strcmp ((relname), ("R_C6000_PREL31")) == 0))
     {
       warn (gettext ("Skipping unexpected C6000 relocation type %s\n"), relname);
       continue;
     }

   prelval >>= 1;
 }
      else
 {

   warn (gettext ("Only TI and ARM unwinders are currently supported\n"));
   break;
 }

      word = (word & ~ (uint64_t) 0x7fffffff) | (prelval & 0x7fffffff);
      addr->section = sym->st_shndx;
      addr->offset = offset;

      if (sym_name)
 * sym_name = sym->st_name;
      break;
    }

  *wordp = word;
  arm_sec->next_rela = rp;

  return 
# 9783 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 9783 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *tic6x_unwind_regnames[16] =
{
  "A15", "B15", "B14", "B13", "B12", "B11", "B10", "B3",
  "A14", "A13", "A12", "A11", "A10",
  "[invalid reg 13]", "[invalid reg 14]", "[invalid reg 15]"
};

static void
decode_tic6x_unwind_regmask (unsigned int mask)
{
  int i;

  for (i = 12; mask; mask >>= 1, i--)
    {
      if (mask & 1)
 {
   fputs (tic6x_unwind_regnames[i], 
# 9802 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   stdout
# 9802 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         );
   if (mask > 1)
     fputs (", ", 
# 9804 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 stdout
# 9804 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
 }
    }
}
# 9835 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static 
# 9835 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 9836 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
decode_arm_unwind_bytecode (Filedata * filedata,
       struct arm_unw_aux_info * aux,
       unsigned int word,
       unsigned int remaining,
       unsigned int more_words,
       uint64_t data_offset,
       Elf_Internal_Shdr * data_sec,
       struct arm_section * data_arm_sec)
{
  struct absaddr addr;
  
# 9846 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 9846 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 9846 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 9846 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;


  while (1)
    {
      unsigned int op, op2;

      if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 9853 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ((void *)0)
# 9853 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     )) return 
# 9853 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 9853 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     ; remaining = 4; more_words--; };
      if (remaining == 0)
 break;
      remaining--;
      op = word >> 24;
      word <<= 8;

      printf ("  0x%02x ", op);

      if ((op & 0xc0) == 0x00)
 {
   int offset = ((op & 0x3f) << 2) + 4;

   printf ("     vsp = vsp + %d", offset);
 }
      else if ((op & 0xc0) == 0x40)
 {
   int offset = ((op & 0x3f) << 2) + 4;

   printf ("     vsp = vsp - %d", offset);
 }
      else if ((op & 0xf0) == 0x80)
 {
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 9876 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ((void *)0)
# 9876 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  )) return 
# 9876 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 9876 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 
# 9876 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 9876 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; } printf ("0x%02x ", op2);
   if (op == 0x80 && op2 == 0)
     printf (gettext ("Refuse to unwind"));
   else
     {
       unsigned int mask = ((op & 0x0f) << 8) | op2;
       
# 9882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 9882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           first = 
# 9882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   1
# 9882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
       int i;

       printf ("pop {");
       for (i = 0; i < 12; i++)
  if (mask & (1 << i))
    {
      if (first)
        first = 
# 9890 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               0
# 9890 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
      else
        printf (", ");
      printf ("r%d", 4 + i);
    }
       printf ("}");
     }
 }
      else if ((op & 0xf0) == 0x90)
 {
   if (op == 0x9d || op == 0x9f)
     printf (gettext ("     [Reserved]"));
   else
     printf ("     vsp = r%d", op & 0x0f);
 }
      else if ((op & 0xf0) == 0xa0)
 {
   int end = 4 + (op & 0x07);
   
# 9908 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  _Bool 
# 9908 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       first = 
# 9908 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 9908 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
   int i;

   printf ("     pop {");
   for (i = 4; i <= end; i++)
     {
       if (first)
  first = 
# 9915 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 9915 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
       else
  printf (", ");
       printf ("r%d", i);
     }
   if (op & 0x08)
     {
       if (!first)
  printf (", ");
       printf ("r14");
     }
   printf ("}");
 }
      else if (op == 0xb0)
 printf (gettext ("     finish"));
      else if (op == 0xb1)
 {
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 9932 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ((void *)0)
# 9932 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  )) return 
# 9932 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 9932 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 
# 9932 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 9932 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; } printf ("0x%02x ", op2);
   if (op2 == 0 || (op2 & 0xf0) != 0)
     printf (gettext ("[Spare]"));
   else
     {
       unsigned int mask = op2 & 0x0f;
       
# 9938 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 9938 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           first = 
# 9938 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   1
# 9938 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
       int i;

       printf ("pop {");
       for (i = 0; i < 12; i++)
  if (mask & (1 << i))
    {
      if (first)
        first = 
# 9946 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               0
# 9946 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
      else
        printf (", ");
      printf ("r%d", i);
    }
       printf ("}");
     }
 }
      else if (op == 0xb2)
 {
   unsigned char buf[9];
   unsigned int i, len;
   uint64_t offset;

   for (i = 0; i < sizeof (buf); i++)
     {
       if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 9962 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      ((void *)0)
# 9962 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      )) return 
# 9962 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 9962 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ; remaining = 4; more_words--; }; if (remaining) { remaining--; (buf[i]) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 
# 9962 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 9962 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ; } printf ("0x%02x ", buf[i]);
       if ((buf[i] & 0x80) == 0)
  break;
     }
   if (i == sizeof (buf))
     {
       error (gettext ("corrupt change to vsp\n"));
       res = 
# 9969 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 9969 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
     }
   else
     {
       offset = read_leb128 (buf, buf + i + 1, 
# 9973 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              0
# 9973 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   , &len, 
# 9973 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                           ((void *)0)
# 9973 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                               );
       
# 9974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      ((void) sizeof ((
# 9974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      len == i + 1
# 9974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      ) ? 1 : 0), __extension__ ({ if (
# 9974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      len == i + 1
# 9974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      ) ; else __assert_fail (
# 9974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      "len == i + 1"
# 9974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 9974, __extension__ __PRETTY_FUNCTION__); }))
# 9974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
       offset = offset * 4 + 0x204;
       printf ("vsp = vsp + %" 
# 9976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              "l" "d"
# 9976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    , offset);
     }
 }
      else if (op == 0xb3 || op == 0xc8 || op == 0xc9)
 {
   unsigned int first, last;

   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 9983 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ((void *)0)
# 9983 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  )) return 
# 9983 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 9983 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 
# 9983 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 9983 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; } printf ("0x%02x ", op2);
   first = op2 >> 4;
   last = op2 & 0x0f;
   if (op == 0xc8)
     first = first + 16;
   printf ("pop {D%d", first);
   if (last)
     printf ("-D%d", first + last);
   printf ("}");
 }
      else if (op == 0xb4)
 printf (gettext ("     pop {ra_auth_code}"));
      else if (op == 0xb5)
 printf (gettext ("     vsp as modifier for PAC validation"));
      else if ((op & 0xf8) == 0xb8 || (op & 0xf8) == 0xd0)
 {
   unsigned int count = op & 0x07;

   printf ("pop {D8");
   if (count)
     printf ("-D%d", 8 + count);
   printf ("}");
 }
      else if (op >= 0xc0 && op <= 0xc5)
 {
   unsigned int count = op & 0x07;

   printf ("     pop {wR10");
   if (count)
     printf ("-wR%d", 10 + count);
   printf ("}");
 }
      else if (op == 0xc6)
 {
   unsigned int first, last;

   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 10019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ((void *)0)
# 10019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  )) return 
# 10019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 10019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 
# 10019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 10019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; } printf ("0x%02x ", op2);
   first = op2 >> 4;
   last = op2 & 0x0f;
   printf ("pop {wR%d", first);
   if (last)
     printf ("-wR%d", first + last);
   printf ("}");
 }
      else if (op == 0xc7)
 {
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 10029 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ((void *)0)
# 10029 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  )) return 
# 10029 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 10029 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 
# 10029 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 10029 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; } printf ("0x%02x ", op2);
   if (op2 == 0 || (op2 & 0xf0) != 0)
     printf (gettext ("[Spare]"));
   else
     {
       unsigned int mask = op2 & 0x0f;
       
# 10035 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 10035 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           first = 
# 10035 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   1
# 10035 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
       int i;

       printf ("pop {");
       for (i = 0; i < 4; i++)
  if (mask & (1 << i))
    {
      if (first)
        first = 
# 10043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               0
# 10043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
      else
        printf (", ");
      printf ("wCGR%d", i);
    }
       printf ("}");
     }
 }
      else
 {
   printf (gettext ("     [unsupported opcode]"));
   res = 
# 10054 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 10054 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
 }

      printf ("\n");
    }

  return res;
}

static 
# 10063 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 10064 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
decode_tic6x_unwind_bytecode (Filedata * filedata,
         struct arm_unw_aux_info * aux,
         unsigned int word,
         unsigned int remaining,
         unsigned int more_words,
         uint64_t data_offset,
         Elf_Internal_Shdr * data_sec,
         struct arm_section * data_arm_sec)
{
  struct absaddr addr;


  while (1)
    {
      unsigned int op, op2;

      if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 10080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ((void *)0)
# 10080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     )) return 
# 10080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 10080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     ; remaining = 4; more_words--; };
      if (remaining == 0)
 break;
      remaining--;
      op = word >> 24;
      word <<= 8;

      printf ("  0x%02x ", op);

      if ((op & 0xc0) == 0x00)
 {
   int offset = ((op & 0x3f) << 3) + 8;
   printf ("     sp = sp + %d", offset);
 }
      else if ((op & 0xc0) == 0x80)
 {
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 10096 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ((void *)0)
# 10096 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  )) return 
# 10096 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 10096 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 
# 10096 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 10096 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; } printf ("0x%02x ", op2);
   if (op == 0x80 && op2 == 0)
     printf (gettext ("Refuse to unwind"));
   else
     {
       unsigned int mask = ((op & 0x1f) << 8) | op2;
       if (op & 0x20)
  printf ("pop compact {");
       else
  printf ("pop {");

       decode_tic6x_unwind_regmask (mask);
       printf("}");
     }
 }
      else if ((op & 0xf0) == 0xc0)
 {
   unsigned int reg;
   unsigned int nregs;
   unsigned int i;
   const char *name;
   struct
   {
     unsigned int offset;
     unsigned int reg;
   } regpos[16];



   nregs = 0;
   for (i = 0; nregs < (op & 0xf); i++)
     {
       if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 10128 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      ((void *)0)
# 10128 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      )) return 
# 10128 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 10128 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ; remaining = 4; more_words--; }; if (remaining) { remaining--; (op2) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 
# 10128 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 10128 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ; } printf ("0x%02x ", op2);
       reg = op2 >> 4;
       if (reg != 0xf)
  {
    regpos[nregs].offset = i * 2;
    regpos[nregs].reg = reg;
    nregs++;
  }

       reg = op2 & 0xf;
       if (reg != 0xf)
  {
    regpos[nregs].offset = i * 2 + 1;
    regpos[nregs].reg = reg;
    nregs++;
  }
     }

   printf (gettext ("pop frame {"));
   if (nregs == 0)
     {
       printf (gettext ("*corrupt* - no registers specified"));
     }
   else
     {
       reg = nregs - 1;
       for (i = i * 2; i > 0; i--)
  {
    if (regpos[reg].offset == i - 1)
      {
        name = tic6x_unwind_regnames[regpos[reg].reg];
        if (reg > 0)
   reg--;
      }
    else
      name = gettext ("[pad]");

    fputs (name, 
# 10165 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                stdout
# 10165 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      );
    if (i > 1)
      printf (", ");
  }
     }

   printf ("}");
 }
      else if (op == 0xd0)
 printf ("     MOV FP, SP");
      else if (op == 0xd1)
 printf ("     __c6xabi_pop_rts");
      else if (op == 0xd2)
 {
   unsigned char buf[9];
   unsigned int i, len;
   uint64_t offset;

   for (i = 0; i < sizeof (buf); i++)
     {
       if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 10185 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      ((void *)0)
# 10185 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      )) return 
# 10185 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 10185 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ; remaining = 4; more_words--; }; if (remaining) { remaining--; (buf[i]) = word >> 24; word <<= 8; } else { printf (gettext ("[Truncated opcode]\n")); return 
# 10185 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 10185 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ; } printf ("0x%02x ", buf[i]);
       if ((buf[i] & 0x80) == 0)
  break;
     }

   if (i == sizeof (buf))
     {
       warn (gettext ("Corrupt stack pointer adjustment detected\n"));
       return 
# 10193 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 10193 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }

   offset = read_leb128 (buf, buf + i + 1, 
# 10196 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          0
# 10196 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                               , &len, 
# 10196 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                       ((void *)0)
# 10196 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                           );
   
# 10197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ((void) sizeof ((
# 10197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  len == i + 1
# 10197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ) ? 1 : 0), __extension__ ({ if (
# 10197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  len == i + 1
# 10197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ) ; else __assert_fail (
# 10197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  "len == i + 1"
# 10197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 10197, __extension__ __PRETTY_FUNCTION__); }))
# 10197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
   offset = offset * 8 + 0x408;
   printf (gettext ("sp = sp + %" 
# 10199 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "d"
# 10199 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          ), offset);
 }
      else if ((op & 0xf0) == 0xe0)
 {
   if ((op & 0x0f) == 7)
     printf ("     RETURN");
   else
     printf ("     MV %s, B3", tic6x_unwind_regnames[op & 0x0f]);
 }
      else
 {
   printf (gettext ("     [unsupported opcode]"));
 }
      putchar ('\n');
    }

  return 
# 10215 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 10215 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static uint64_t
arm_expand_prel31 (Filedata * filedata, uint64_t word, uint64_t where)
{
  uint64_t offset;

  offset = word & 0x7fffffff;
  if (offset & 0x40000000)
    offset |= ~ (uint64_t) 0x7fffffff;

  if (filedata->file_header.e_machine == 140)
    offset <<= 1;

  return offset + where;
}

static 
# 10233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 10234 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
decode_arm_unwind (Filedata * filedata,
     struct arm_unw_aux_info * aux,
     unsigned int word,
     unsigned int remaining,
     uint64_t data_offset,
     Elf_Internal_Shdr * data_sec,
     struct arm_section * data_arm_sec)
{
  int per_index;
  unsigned int more_words = 0;
  struct absaddr addr;
  uint64_t sym_name = (uint64_t) -1;
  
# 10246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 10246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 10246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 10246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (remaining == 0)
    {





      if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset,
         & word, & addr, & sym_name))
 return 
# 10257 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 10257 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      remaining = 4;
    }
  else
    {
      addr.section = 0;
      addr.offset = 0;
    }

  if ((word & 0x80000000) == 0)
    {

      uint64_t fn;
      const char *procname;

      fn = arm_expand_prel31 (filedata, word, data_sec->sh_addr + data_offset);
      printf (gettext ("  Personality routine: "));
      if (fn == 0
   && addr.section == 0 && addr.offset == 0
   && sym_name != (uint64_t) -1 && sym_name < aux->strtab_size)
 {
   procname = aux->strtab + sym_name;
   print_vma (fn, PREFIX_HEX);
   if (procname)
     {
       fputs (" <", 
# 10283 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   stdout
# 10283 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         );
       fputs (procname, 
# 10284 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       stdout
# 10284 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             );
       fputc ('>', 
# 10285 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  stdout
# 10285 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        );
     }
 }
      else
 procname = arm_print_vma_and_name (filedata, aux, fn, addr);
      fputc ('\n', 
# 10290 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  stdout
# 10290 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        );




      if (procname != 
# 10295 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
   
# 10296 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  && (startswith (procname, "__gcc_personality_v0")
       || startswith (procname, "__gxx_personality_v0")
       || startswith (procname, "__gcj_personality_v0")
       || startswith (procname, "__gnu_objc_personality_v0")))
 {
   remaining = 0;
   more_words = 1;
   if (remaining == 0 && more_words) { data_offset += 4; if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset, & word, & addr, 
# 10303 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ((void *)0)
# 10303 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  )) return 
# 10303 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 10303 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  ; remaining = 4; more_words--; };
   if (!remaining)
     {
       printf (gettext ("  [Truncated data]\n"));
       return 
# 10307 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 10307 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }
   more_words = word >> 24;
   word <<= 8;
   remaining--;
   per_index = -1;
 }
      else
 return 
# 10315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       1
# 10315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ;
    }
  else
    {
# 10327 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      if (filedata->file_header.e_machine == 40
   && (word & 0x70000000))
 {
   warn (gettext ("Corrupt ARM compact model table entry: %x \n"), word);
   res = 
# 10331 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 10331 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
 }

      per_index = (word >> 24) & 0x7f;
      printf (gettext ("  Compact model index: %d\n"), per_index);
      if (per_index == 0)
 {
   more_words = 0;
   word <<= 8;
   remaining--;
 }
      else if (per_index < 3)
 {
   more_words = (word >> 16) & 0xff;
   word <<= 16;
   remaining -= 2;
 }
    }

  switch (filedata->file_header.e_machine)
    {
    case 40:
      if (per_index < 3)
 {
   if (! decode_arm_unwind_bytecode (filedata, aux, word, remaining, more_words,
         data_offset, data_sec, data_arm_sec))
     res = 
# 10357 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 10357 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }
      else
 {
   warn (gettext ("Unknown ARM compact model index encountered\n"));
   printf (gettext ("  [reserved]\n"));
   res = 
# 10363 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 10363 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
 }
      break;

    case 140:
      if (per_index < 3)
 {
   if (! decode_tic6x_unwind_bytecode (filedata, aux, word, remaining, more_words,
           data_offset, data_sec, data_arm_sec))
     res = 
# 10372 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 10372 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }
      else if (per_index < 5)
 {
   if (((word >> 17) & 0x7f) == 0x7f)
     printf (gettext ("  Restore stack from frame pointer\n"));
   else
     printf (gettext ("  Stack increment %d\n"), (word >> 14) & 0x1fc);
   printf (gettext ("  Registers restored: "));
   if (per_index == 4)
     printf (" (compact) ");
   decode_tic6x_unwind_regmask ((word >> 4) & 0x1fff);
   putchar ('\n');
   printf (gettext ("  Return register: %s\n"),
    tic6x_unwind_regnames[word & 0xf]);
 }
      else
 printf (gettext ("  [reserved (%d)]\n"), per_index);
      break;

    default:
      error (gettext ("Unsupported architecture type %d encountered when decoding unwind table\n"),
      filedata->file_header.e_machine);
      res = 
# 10395 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 10395 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }



  return res;
}

static 
# 10403 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 10404 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_arm_unwind (Filedata * filedata,
   struct arm_unw_aux_info * aux,
   Elf_Internal_Shdr * exidx_sec)
{
  struct arm_section exidx_arm_sec, extab_arm_sec;
  unsigned int i, exidx_len;
  uint64_t j, nfuns;
  
# 10411 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 10411 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 10411 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 10411 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  memset (&exidx_arm_sec, 0, sizeof (exidx_arm_sec));
  memset (&extab_arm_sec, 0, sizeof (extab_arm_sec));
  exidx_len = exidx_sec->sh_size / 8;

  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
    if (aux->symtab[j].st_value && ((aux->symtab[j].st_info) & 0xF) == 2)
      aux->funtab[nfuns++] = aux->symtab[j];
  aux->nfuns = nfuns;
  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);

  for (i = 0; i < exidx_len; i++)
    {
      unsigned int exidx_fn, exidx_entry;
      struct absaddr fn_addr, entry_addr;
      uint64_t fn;

      fputc ('\n', 
# 10430 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  stdout
# 10430 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        );

      if (! get_unwind_section_word (filedata, aux, & exidx_arm_sec, exidx_sec,
         8 * i, & exidx_fn, & fn_addr, 
# 10433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 10433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          )
   || ! get_unwind_section_word (filedata, aux, & exidx_arm_sec, exidx_sec,
     8 * i + 4, & exidx_entry, & entry_addr, 
# 10435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                            ((void *)0)
# 10435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                ))
 {
   free (aux->funtab);
   arm_free_section (& exidx_arm_sec);
   arm_free_section (& extab_arm_sec);
   return 
# 10440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 10440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }




      if (exidx_fn & 0x80000000)
 {
   warn (gettext ("corrupt index table entry: %x\n"), exidx_fn);
   res = 
# 10449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 10449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
 }

      fn = arm_expand_prel31 (filedata, exidx_fn, exidx_sec->sh_addr + 8 * i);

      arm_print_vma_and_name (filedata, aux, fn, fn_addr);
      fputs (": ", 
# 10455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  stdout
# 10455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        );

      if (exidx_entry == 1)
 {
   print_vma (exidx_entry, PREFIX_HEX);
   fputs (" [cantunwind]\n", 
# 10460 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            stdout
# 10460 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  );
 }
      else if (exidx_entry & 0x80000000)
 {
   print_vma (exidx_entry, PREFIX_HEX);
   fputc ('\n', 
# 10465 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               stdout
# 10465 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     );
   decode_arm_unwind (filedata, aux, exidx_entry, 4, 0, 
# 10466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                       ((void *)0)
# 10466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                           , 
# 10466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                             ((void *)0)
# 10466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                 );
 }
      else
 {
   uint64_t table, table_offset = 0;
   Elf_Internal_Shdr *table_sec;

   fputs ("@", 
# 10473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              stdout
# 10473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    );
   table = arm_expand_prel31 (filedata, exidx_entry, exidx_sec->sh_addr + 8 * i + 4);
   print_vma (table, PREFIX_HEX);
   printf ("\n");


   if (entry_addr.section != 0
       && entry_addr.section < filedata->file_header.e_shnum)
     {
       table_sec = filedata->section_headers + entry_addr.section;
       table_offset = entry_addr.offset;

       if (table_offset > table_sec->sh_size)
  {
    warn (gettext ("Unwind entry contains corrupt offset (%#" 
# 10487 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "x" 
# 10487 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         ") into section %s\n"),
   table_offset,
   printable_section_name (filedata, table_sec));
    res = 
# 10490 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 10490 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
    continue;
  }
     }
   else
     {
       table_sec = find_section_by_address (filedata, table);
       if (table_sec != 
# 10497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 10497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           )
  table_offset = table - table_sec->sh_addr;
     }

   if (table_sec == 
# 10501 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 10501 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       )
     {
       warn (gettext ("Could not locate .ARM.extab section containing %#" 
# 10503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 10503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ".\n"),
      table);
       res = 
# 10505 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 10505 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
       continue;
     }

   if (! decode_arm_unwind (filedata, aux, 0, 0, table_offset, table_sec,
       &extab_arm_sec))
     res = 
# 10511 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 10511 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }
    }

  printf ("\n");

  free (aux->funtab);
  arm_free_section (&exidx_arm_sec);
  arm_free_section (&extab_arm_sec);

  return res;
}



static 
# 10526 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 10527 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
arm_process_unwind (Filedata * filedata)
{
  struct arm_unw_aux_info aux;
  Elf_Internal_Shdr *unwsec = 
# 10530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             ((void *)0)
# 10530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 ;
  Elf_Internal_Shdr *sec;
  size_t i;
  unsigned int sec_type;
  
# 10534 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 10534 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 10534 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 10534 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  switch (filedata->file_header.e_machine)
    {
    case 40:
      sec_type = 0x70000001;
      break;

    case 140:
      sec_type = 0x70000001;
      break;

    default:
      error (gettext ("Unsupported architecture type %d encountered when processing unwind table\n"),
      filedata->file_header.e_machine);
      return 
# 10549 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 10549 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  if (filedata->string_table == 
# 10552 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 10552 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   )
    return 
# 10553 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 10553 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  memset (& aux, 0, sizeof (aux));
  aux.filedata = filedata;

  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == 2)
 {
   if (aux.symtab)
     {
       error (gettext ("Multiple symbol tables encountered\n"));
       free (aux.symtab);
       aux.symtab = 
# 10566 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 10566 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
       free (aux.strtab);
       aux.strtab = 
# 10568 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 10568 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
     }
   if (!get_symtab (filedata, sec, &aux.symtab, &aux.nsyms,
      &aux.strtab, &aux.strtab_size))
     return 
# 10572 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 10572 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
 }
      else if (sec->sh_type == sec_type)
 unwsec = sec;
    }

  if (unwsec == 
# 10578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 10578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   )
    printf (gettext ("\nThere are no unwind sections in this file.\n"));
  else
    for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
      {
 if (sec->sh_type == sec_type)
   {
     uint64_t num_unwind = sec->sh_size / (2 * eh_addr_size);
     printf (ngettext ("\nUnwind section '%s' at offset %#" 
# 10586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                           "l" "x" 
# 10586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                  " "
         "contains %" 
# 10587 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     "l" "u" 
# 10587 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            " entry:\n",
         "\nUnwind section '%s' at offset %#" 
# 10588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             "l" "x" 
# 10588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    " "
         "contains %" 
# 10589 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     "l" "u" 
# 10589 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            " entries:\n",
         num_unwind),
      printable_section_name (filedata, sec),
      sec->sh_offset,
      num_unwind);

     if (! dump_arm_unwind (filedata, &aux, sec))
       res = 
# 10596 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 10596 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
   }
      }

  free (aux.symtab);
  free ((char *) aux.strtab);

  return res;
}

static 
# 10606 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 10607 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
no_processor_specific_unwind (Filedata * filedata __attribute__ ((__unused__)))
{
  printf (gettext ("No processor specific unwind information to decode\n"));
  return 
# 10610 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 10610 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 10613 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 10614 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_unwind (Filedata * filedata)
{
  struct unwind_handler
  {
    unsigned int machtype;
    
# 10619 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
   _Bool 
# 10619 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        (* handler)(Filedata *);
  } handlers[] =
  {
    { 40, arm_process_unwind },
    { 50, ia64_process_unwind },
    { 15, hppa_process_unwind },
    { 140, arm_process_unwind },
    { 3, no_processor_specific_unwind },
    { 62, no_processor_specific_unwind },
    { 0, 
# 10628 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0) 
# 10628 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             }
  };
  int i;

  if (!do_unwind)
    return 
# 10633 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 10633 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  for (i = 0; handlers[i].handler != 
# 10635 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    ((void *)0)
# 10635 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        ; i++)
    if (filedata->file_header.e_machine == handlers[i].machtype)
      return handlers[i].handler (filedata);

  printf (gettext ("\nThe decoding of unwind sections for machine type %s is not currently supported.\n"),
   get_machine_name (filedata->file_header.e_machine));
  return 
# 10641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 10641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static void
dynamic_section_aarch64_val (Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case (0x70000000 + 1):
    case (0x70000000 + 3):
      break;
    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      break;
    }
  putchar ('\n');
}

static void
dynamic_section_mips_val (Filedata * filedata, Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case 0x70000005:
      if (entry->d_un.d_val == 0)
 printf (gettext ("NONE"));
      else
 {
   static const char * opts[] =
   {
     "QUICKSTART", "NOTPOT", "NO_LIBRARY_REPLACEMENT",
     "NO_MOVE", "SGI_ONLY", "GUARANTEE_INIT", "DELTA_C_PLUS_PLUS",
     "GUARANTEE_START_INIT", "PIXIE", "DEFAULT_DELAY_LOAD",
     "REQUICKSTART", "REQUICKSTARTED", "CORD", "NO_UNRES_UNDEF",
     "RLD_ORDER_SAFE"
   };
   unsigned int cnt;
   
# 10678 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  _Bool 
# 10678 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       first = 
# 10678 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 10678 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;

   for (cnt = 0; cnt < (sizeof (opts) / sizeof ((opts)[0])); ++cnt)
     if (entry->d_un.d_val & (1 << cnt))
       {
  printf ("%s%s", first ? "" : " ", opts[cnt]);
  first = 
# 10684 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 10684 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
       }
 }
      break;

    case 0x70000004:
      if (valid_dynamic_name (filedata, entry->d_un.d_val))
 printf (gettext ("Interface Version: %s"),
  get_dynamic_name (filedata, entry->d_un.d_val));
      else
 printf (gettext ("Interface Version: <corrupt: %" 
# 10694 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        "l" "x" 
# 10694 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        ">"),
  entry->d_un.d_ptr);
      break;

    case 0x70000002:
      {
 char timebuf[128];
 struct tm * tmp;
 time_t atime = entry->d_un.d_val;

 tmp = gmtime (&atime);

 if (tmp == 
# 10706 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           ((void *)0)
# 10706 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               )
   snprintf (timebuf, sizeof (timebuf), gettext ("<corrupt>"));
 else
   snprintf (timebuf, sizeof (timebuf), "%04u-%02u-%02uT%02u:%02u:%02u",
      tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
      tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
 printf (gettext ("Time Stamp: %s"), timebuf);
      }
      break;

    case 0x70000001:
    case 0x7000000a:
    case 0x7000000b:
    case 0x70000010:
    case 0x70000011:
    case 0x70000012:
    case 0x70000014:
    case 0x70000018:
    case 0x7000001a:
    case 0x7000001c:
    case 0x7000001e:
    case 0x70000021:
    case 0x7000002f:
      print_vma (entry->d_un.d_val, DEC);
      break;

    case 0x70000036:
      filedata->dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;
      filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;


    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
    }
    putchar ('\n');
}

static void
dynamic_section_parisc_val (Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case (0x60000000 + 0x1):
      {
 static struct
 {
   unsigned int bit;
   const char * str;
 }
 flags[] =
 {
   { 0x00001, "HP_DEBUG_PRIVATE" },
   { 0x00002, "HP_DEBUG_CALLBACK" },
   { 0x00004, "HP_DEBUG_CALLBACK_BOR" },
   { 0x00008, "HP_NO_ENVVAR" },
   { 0x00010, "HP_BIND_NOW" },
   { 0x00020, "HP_BIND_NONFATAL" },
   { 0x00040, "HP_BIND_VERBOSE" },
   { 0x00080, "HP_BIND_RESTRICTED" },
   { 0x00100, "HP_BIND_SYMBOLIC" },
   { 0x00200, "HP_RPATH_FIRST" },
   { 0x00400, "HP_BIND_DEPTH_FIRST" },
   { 0x00800, "HP_GST" },
   { 0x01000, "HP_SHLIB_FIXED" },
   { 0x02000, "HP_MERGE_SHLIB_SEG" },
   { 0x04000, "HP_NODELETE" },
   { 0x08000, "HP_GROUP" },
   { 0x10000, "HP_PROTECT_LINKAGE_TABLE" }
 };
 
# 10775 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
_Bool 
# 10775 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     first = 
# 10775 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 10775 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
 size_t cnt;
 uint64_t val = entry->d_un.d_val;

 for (cnt = 0; cnt < (sizeof (flags) / sizeof ((flags)[0])); ++cnt)
   if (val & flags[cnt].bit)
     {
       if (! first)
  putchar (' ');
       fputs (flags[cnt].str, 
# 10784 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             stdout
# 10784 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   );
       first = 
# 10785 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              0
# 10785 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
       val ^= flags[cnt].bit;
     }

 if (val != 0 || first)
   {
     if (! first)
       putchar (' ');
     print_vma (val, HEX);
   }
      }
      break;

    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      break;
    }
  putchar ('\n');
}
# 10815 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static void
print_vms_time (int64_t vmstime)
{
  struct tm *tm = 
# 10818 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 10818 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;
  time_t unxtime;

  if (vmstime >= 
# 10821 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                (-9223372036854775807L -1) 
# 10821 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          + 35067168000000000LL)
    {
      vmstime = (vmstime - 35067168000000000LL) / 10000000;
      unxtime = vmstime;
      if (unxtime == vmstime)
 tm = gmtime (&unxtime);
    }
  if (tm != 
# 10828 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           ((void *)0)
# 10828 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               )
    printf ("%04u-%02u-%02uT%02u:%02u:%02u",
     tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
     tm->tm_hour, tm->tm_min, tm->tm_sec);
}

static void
dynamic_section_ia64_val (Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case (0x70000000 + 0):

      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      printf (" -- ");
      print_vma (entry->d_un.d_ptr + (3 * 8), PREFIX_HEX);
      break;

    case (0x6000000d + 40):
      print_vms_time (entry->d_un.d_val);
      break;

    case (0x6000000d + 8):
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      if (entry->d_un.d_val & 0x0001)
        printf (" CALL_DEBUG");
      if (entry->d_un.d_val & 0x0002)
        printf (" NOP0BUFS");
      if (entry->d_un.d_val & 0x0004)
        printf (" P0IMAGE");
      if (entry->d_un.d_val & 0x0008)
        printf (" MKTHREADS");
      if (entry->d_un.d_val & 0x0010)
        printf (" UPCALLS");
      if (entry->d_un.d_val & 0x0020)
        printf (" IMGSTA");
      if (entry->d_un.d_val & 0x0040)
        printf (" INITIALIZE");
      if (entry->d_un.d_val & 0x0080)
        printf (" MAIN");
      if (entry->d_un.d_val & 0x0200)
        printf (" EXE_INIT");
      if (entry->d_un.d_val & 0x0400)
        printf (" TBK_IN_IMG");
      if (entry->d_un.d_val & 0x0800)
        printf (" DBG_IN_IMG");
      if (entry->d_un.d_val & 0x1000)
        printf (" TBK_IN_DSF");
      if (entry->d_un.d_val & 0x2000)
        printf (" DBG_IN_DSF");
      if (entry->d_un.d_val & 0x4000)
        printf (" SIGNATURES");
      if (entry->d_un.d_val & 0x8000)
        printf (" REL_SEG_OFF");
      break;

    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      break;
    }
  putchar ('\n');
}

static 
# 10891 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 10892 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_32bit_dynamic_section (Filedata * filedata)
{
  Elf32_External_Dyn * edyn;
  Elf32_External_Dyn * ext;
  Elf_Internal_Dyn * entry;

  edyn = (Elf32_External_Dyn *) get_data (
# 10898 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         ((void *)0)
# 10898 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             , filedata,
       filedata->dynamic_addr, 1,
       filedata->dynamic_size,
       gettext ("dynamic section"));
  if (!edyn)
    return 
# 10903 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 10903 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;




  for (ext = edyn, filedata->dynamic_nent = 0;
       (char *) (ext + 1) <= (char *) edyn + filedata->dynamic_size;
       ext++)
    {
      filedata->dynamic_nent++;
      if (byte_get (ext->d_tag, sizeof (ext->d_tag)) == 0)
 break;
    }

  filedata->dynamic_section
    = (Elf_Internal_Dyn *) cmalloc (filedata->dynamic_nent, sizeof (* entry));
  if (filedata->dynamic_section == 
# 10919 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 10919 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    {
      error (gettext ("Out of memory allocating space for %" 
# 10921 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 10921 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " dynamic entries\n"),
      filedata->dynamic_nent);
      free (edyn);
      return 
# 10924 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 10924 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  for (ext = edyn, entry = filedata->dynamic_section;
       entry < filedata->dynamic_section + filedata->dynamic_nent;
       ext++, entry++)
    {
      entry->d_tag = byte_get (ext->d_tag, sizeof (ext->d_tag));
      entry->d_un.d_val = byte_get (ext->d_un.d_val, sizeof (ext->d_un.d_val));
    }

  free (edyn);

  return 
# 10937 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 10937 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 10940 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 10941 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_64bit_dynamic_section (Filedata * filedata)
{
  Elf64_External_Dyn * edyn;
  Elf64_External_Dyn * ext;
  Elf_Internal_Dyn * entry;


  edyn = (Elf64_External_Dyn *) get_data (
# 10948 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         ((void *)0)
# 10948 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             , filedata,
       filedata->dynamic_addr, 1,
       filedata->dynamic_size,
       gettext ("dynamic section"));
  if (!edyn)
    return 
# 10953 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 10953 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;




  for (ext = edyn, filedata->dynamic_nent = 0;

       (char *) (ext + 1) <= (char *) edyn + filedata->dynamic_size;
       ext++)
    {
      filedata->dynamic_nent++;
      if (byte_get (ext->d_tag, sizeof (ext->d_tag)) == 0)
 break;
    }

  filedata->dynamic_section
    = (Elf_Internal_Dyn *) cmalloc (filedata->dynamic_nent, sizeof (* entry));
  if (filedata->dynamic_section == 
# 10970 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 10970 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    {
      error (gettext ("Out of memory allocating space for %" 
# 10972 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 10972 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " dynamic entries\n"),
      filedata->dynamic_nent);
      free (edyn);
      return 
# 10975 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 10975 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }


  for (ext = edyn, entry = filedata->dynamic_section;
       entry < filedata->dynamic_section + filedata->dynamic_nent;
       ext++, entry++)
    {
      entry->d_tag = byte_get (ext->d_tag, sizeof (ext->d_tag));
      entry->d_un.d_val = byte_get (ext->d_un.d_val, sizeof (ext->d_un.d_val));
    }

  free (edyn);

  return 
# 10989 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 10989 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 10992 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 10993 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_dynamic_section (Filedata *filedata)
{
  if (filedata->dynamic_section)
    return 
# 10996 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 10996 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (is_32bit_elf)
    return get_32bit_dynamic_section (filedata);
  else
    return get_64bit_dynamic_section (filedata);
}

static void
print_dynamic_flags (uint64_t flags)
{
  
# 11007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 11007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      first = 
# 11007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1
# 11007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;

  while (flags)
    {
      uint64_t flag;

      flag = flags & - flags;
      flags &= ~ flag;

      if (first)
 first = 
# 11017 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 11017 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
      else
 putc (' ', 
# 11019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           stdout
# 11019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 );

      switch (flag)
 {
 case (1 << 0): fputs ("ORIGIN", 
# 11023 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  stdout
# 11023 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        ); break;
 case (1 << 1): fputs ("SYMBOLIC", 
# 11024 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     stdout
# 11024 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           ); break;
 case (1 << 2): fputs ("TEXTREL", 
# 11025 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   stdout
# 11025 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         ); break;
 case (1 << 3): fputs ("BIND_NOW", 
# 11026 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     stdout
# 11026 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           ); break;
 case (1 << 4): fputs ("STATIC_TLS", 
# 11027 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         stdout
# 11027 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                               ); break;
 default: fputs (gettext ("unknown"), 
# 11028 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               stdout
# 11028 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ); break;
 }
    }
  puts ("");
}

static uint64_t *
get_dynamic_data (Filedata * filedata, uint64_t number, unsigned int ent_size)
{
  unsigned char * e_data;
  uint64_t * i_data;




  if ((size_t) number != number
      || ent_size * number / ent_size != number)
    {
      error (gettext ("Size overflow prevents reading %" 
# 11046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 11046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " elements of size %u\n")
                                 ,
      number, ent_size);
      return 
# 11049 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 11049 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }



  if (ent_size * number > filedata->file_size)
    {
      error (gettext ("Invalid number of dynamic entries: %" 
# 11056 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 11056 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n"),
      number);
      return 
# 11058 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 11058 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  e_data = (unsigned char *) cmalloc ((size_t) number, ent_size);
  if (e_data == 
# 11062 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 11062 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   )
    {
      error (gettext ("Out of memory reading %" 
# 11064 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 11064 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " dynamic entries\n"),
      number);
      return 
# 11066 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 11066 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  if (fread (e_data, ent_size, (size_t) number, filedata->handle) != number)
    {
      error (gettext ("Unable to read in %" 
# 11071 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 11071 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " bytes of dynamic data\n"),
      number * ent_size);
      free (e_data);
      return 
# 11074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 11074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  i_data = (uint64_t *) cmalloc ((size_t) number, sizeof (*i_data));
  if (i_data == 
# 11078 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 11078 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   )
    {
      error (gettext ("Out of memory allocating space for %" 
# 11080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 11080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " dynamic entries\n"),
      number);
      free (e_data);
      return 
# 11083 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 11083 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  while (number--)
    i_data[number] = byte_get (e_data + number * ent_size, ent_size);

  free (e_data);

  return i_data;
}

static uint64_t
get_num_dynamic_syms (Filedata * filedata)
{
  uint64_t num_of_syms = 0;

  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))
    return num_of_syms;

  if (filedata->dynamic_info[4])
    {
      unsigned char nb[8];
      unsigned char nc[8];
      unsigned int hash_ent_size = 4;

      if ((filedata->file_header.e_machine == 0x9026
    || filedata->file_header.e_machine == 22
    || filedata->file_header.e_machine == 0xa390)
   && filedata->file_header.e_ident[4] == 2)
 hash_ent_size = 8;

      if (fseek64 (filedata->handle,
     (filedata->archive_file_offset
      + offset_from_vma (filedata,
           filedata->dynamic_info[4],
           sizeof nb + sizeof nc)),
     
# 11119 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    0
# 11119 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_hash;
 }

      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)
 {
   error (gettext ("Failed to read in number of buckets\n"));
   goto no_hash;
 }

      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)
 {
   error (gettext ("Failed to read in number of chains\n"));
   goto no_hash;
 }

      filedata->nbuckets = byte_get (nb, hash_ent_size);
      filedata->nchains = byte_get (nc, hash_ent_size);

      if (filedata->nbuckets != 0 && filedata->nchains != 0)
 {
   filedata->buckets = get_dynamic_data (filedata, filedata->nbuckets,
      hash_ent_size);
   filedata->chains = get_dynamic_data (filedata, filedata->nchains,
      hash_ent_size);

   if (filedata->buckets != 
# 11147 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0) 
# 11147 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                && filedata->chains != 
# 11147 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                       ((void *)0)
# 11147 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                           )
     num_of_syms = filedata->nchains;
 }
    no_hash:
      if (num_of_syms == 0)
 {
   free (filedata->buckets);
   filedata->buckets = 
# 11154 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 11154 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
   free (filedata->chains);
   filedata->chains = 
# 11156 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 11156 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
   filedata->nbuckets = 0;
 }
    }

  if (filedata->dynamic_info_DT_GNU_HASH)
    {
      unsigned char nb[16];
      uint64_t i, maxchain = 0xffffffff, bitmaskwords;
      uint64_t buckets_vma;
      uint64_t hn;

      if (fseek64 (filedata->handle,
     (filedata->archive_file_offset
      + offset_from_vma (filedata,
           filedata->dynamic_info_DT_GNU_HASH,
           sizeof nb)),
     
# 11173 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    0
# 11173 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_gnu_hash;
 }

      if (fread (nb, 16, 1, filedata->handle) != 1)
 {
   error (gettext ("Failed to read in number of buckets\n"));
   goto no_gnu_hash;
 }

      filedata->ngnubuckets = byte_get (nb, 4);
      filedata->gnusymidx = byte_get (nb + 4, 4);
      bitmaskwords = byte_get (nb + 8, 4);
      buckets_vma = filedata->dynamic_info_DT_GNU_HASH + 16;
      if (is_32bit_elf)
 buckets_vma += bitmaskwords * 4;
      else
 buckets_vma += bitmaskwords * 8;

      if (fseek64 (filedata->handle,
     (filedata->archive_file_offset
      + offset_from_vma (filedata, buckets_vma, 4)),
     
# 11197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    0
# 11197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_gnu_hash;
 }

      filedata->gnubuckets
 = get_dynamic_data (filedata, filedata->ngnubuckets, 4);

      if (filedata->gnubuckets == 
# 11206 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 ((void *)0)
# 11206 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     )
 goto no_gnu_hash;

      for (i = 0; i < filedata->ngnubuckets; i++)
 if (filedata->gnubuckets[i] != 0)
   {
     if (filedata->gnubuckets[i] < filedata->gnusymidx)
       goto no_gnu_hash;

     if (maxchain == 0xffffffff || filedata->gnubuckets[i] > maxchain)
       maxchain = filedata->gnubuckets[i];
   }

      if (maxchain == 0xffffffff)
 goto no_gnu_hash;

      maxchain -= filedata->gnusymidx;

      if (fseek64 (filedata->handle,
     (filedata->archive_file_offset
      + offset_from_vma (filedata,
           buckets_vma + 4 * (filedata->ngnubuckets
         + maxchain),
           4)),
     
# 11230 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    0
# 11230 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_gnu_hash;
 }

      do
 {
   if (fread (nb, 4, 1, filedata->handle) != 1)
     {
       error (gettext ("Failed to determine last chain length\n"));
       goto no_gnu_hash;
     }

   if (maxchain + 1 == 0)
     goto no_gnu_hash;

   ++maxchain;
 }
      while ((byte_get (nb, 4) & 1) == 0);

      if (fseek64 (filedata->handle,
     (filedata->archive_file_offset
      + offset_from_vma (filedata, (buckets_vma
        + 4 * filedata->ngnubuckets),
           4)),
     
# 11256 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    0
# 11256 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ))
 {
   error (gettext ("Unable to seek to start of dynamic information\n"));
   goto no_gnu_hash;
 }

      filedata->gnuchains = get_dynamic_data (filedata, maxchain, 4);
      filedata->ngnuchains = maxchain;

      if (filedata->gnuchains == 
# 11265 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 11265 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    )
 goto no_gnu_hash;

      if (filedata->dynamic_info_DT_MIPS_XHASH)
 {
   if (fseek64 (filedata->handle,
         (filedata->archive_file_offset
   + offset_from_vma (filedata, (buckets_vma
            + 4 * (filedata->ngnubuckets
            + maxchain)), 4)),
         
# 11275 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 11275 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ))
     {
       error (gettext ("Unable to seek to start of dynamic information\n"));
       goto no_gnu_hash;
     }

   filedata->mipsxlat = get_dynamic_data (filedata, maxchain, 4);
   if (filedata->mipsxlat == 
# 11282 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            ((void *)0)
# 11282 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                )
     goto no_gnu_hash;
 }

      for (hn = 0; hn < filedata->ngnubuckets; ++hn)
 if (filedata->gnubuckets[hn] != 0)
   {
     uint64_t si = filedata->gnubuckets[hn];
     uint64_t off = si - filedata->gnusymidx;

     do
       {
  if (filedata->dynamic_info_DT_MIPS_XHASH)
    {
      if (off < filedata->ngnuchains
   && filedata->mipsxlat[off] >= num_of_syms)
        num_of_syms = filedata->mipsxlat[off] + 1;
    }
  else
    {
      if (si >= num_of_syms)
        num_of_syms = si + 1;
    }
  si++;
       }
     while (off < filedata->ngnuchains
     && (filedata->gnuchains[off++] & 1) == 0);
   }

      if (num_of_syms == 0)
 {
 no_gnu_hash:
   free (filedata->mipsxlat);
   filedata->mipsxlat = 
# 11315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 11315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
   free (filedata->gnuchains);
   filedata->gnuchains = 
# 11317 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 11317 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
   free (filedata->gnubuckets);
   filedata->gnubuckets = 
# 11319 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 11319 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;
   filedata->ngnubuckets = 0;
   filedata->ngnuchains = 0;
 }
    }

  return num_of_syms;
}



static 
# 11330 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 11331 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_dynamic_section (Filedata * filedata)
{
  Elf_Internal_Dyn * entry;

  if (filedata->dynamic_size <= 1)
    {
      if (do_dynamic)
 {
   if (filedata->is_separate)
     printf (gettext ("\nThere is no dynamic section in linked file '%s'.\n"),
      filedata->file_name);
   else
     printf (gettext ("\nThere is no dynamic section in this file.\n"));
 }

      return 
# 11346 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 11346 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  if (!get_dynamic_section (filedata))
    return 
# 11350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 11350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;


  if (filedata->dynamic_symbols == 
# 11353 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0) 
# 11353 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       || do_histogram)
    {
      uint64_t num_of_syms;

      for (entry = filedata->dynamic_section;
    entry < filedata->dynamic_section + filedata->dynamic_nent;
    ++entry)
 if (entry->d_tag == 6)
   filedata->dynamic_info[6] = entry->d_un.d_val;
 else if (entry->d_tag == 11)
   filedata->dynamic_info[11] = entry->d_un.d_val;
 else if (entry->d_tag == 4)
   filedata->dynamic_info[4] = entry->d_un.d_val;
 else if (entry->d_tag == 0x6ffffef5)
   filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
 else if ((filedata->file_header.e_machine == 8
    || filedata->file_header.e_machine == 10)
   && entry->d_tag == 0x70000036)
   {
     filedata->dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;
     filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
   }

      num_of_syms = get_num_dynamic_syms (filedata);

      if (num_of_syms != 0
   && filedata->dynamic_symbols == 
# 11379 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
   
# 11380 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  && filedata->dynamic_info[6]
   && filedata->dynamic_info[11])
 {
   Elf_Internal_Phdr *seg;
   uint64_t vma = filedata->dynamic_info[6];

   if (! get_program_headers (filedata))
     {
       error (gettext ("Cannot interpret virtual addresses " "without program headers.\n")
                                      );
       return 
# 11390 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 11390 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }

   for (seg = filedata->program_headers;
        seg < filedata->program_headers + filedata->file_header.e_phnum;
        ++seg)
     {
       if (seg->p_type != 1)
  continue;

       if (seg->p_offset + seg->p_filesz > filedata->file_size)
  {

    error (gettext ("Invalid PT_LOAD entry\n"));
    return 
# 11404 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 11404 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
  }

       if (vma >= (seg->p_vaddr & -seg->p_align)
    && vma < seg->p_vaddr + seg->p_filesz)
  {




    Elf_Internal_Shdr section;
    section.sh_offset = (vma - seg->p_vaddr
           + seg->p_offset);
    section.sh_size = (num_of_syms
         * filedata->dynamic_info[11]);
    section.sh_entsize = filedata->dynamic_info[11];

    if (do_checks
        && filedata->dynamic_symtab_section != 
# 11422 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              ((void *)0)
        
# 11423 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       && ((filedata->dynamic_symtab_section->sh_offset
      != section.sh_offset)
     || (filedata->dynamic_symtab_section->sh_size
         != section.sh_size)
     || (filedata->dynamic_symtab_section->sh_entsize
         != section.sh_entsize)))
      warn (gettext ("the .dynsym section doesn't match the DT_SYMTAB and DT_SYMENT tags\n")
                                                                      );

    section.sh_name = filedata->string_table_length;
    filedata->dynamic_symbols
      = get_elf_symbols (filedata, &section,
           &filedata->num_dynamic_syms);
    if (filedata->dynamic_symbols == 
# 11436 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    ((void *)0)
        
# 11437 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       || filedata->num_dynamic_syms != num_of_syms)
      {
        error (gettext ("Corrupt DT_SYMTAB dynamic entry\n"));
        return 
# 11440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              0
# 11440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
      }
    break;
  }
     }
 }
    }


  if (filedata->dynamic_strings == 
# 11449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 11449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    for (entry = filedata->dynamic_section;
  entry < filedata->dynamic_section + filedata->dynamic_nent;
  ++entry)
      {
 if (entry->d_tag == 5)
   filedata->dynamic_info[5] = entry->d_un.d_val;

 if (entry->d_tag == 10)
   filedata->dynamic_info[10] = entry->d_un.d_val;

 if (filedata->dynamic_info[5]
     && filedata->dynamic_info[10])
   {
     uint64_t offset;
     uint64_t str_tab_len = filedata->dynamic_info[10];

     offset = offset_from_vma (filedata,
          filedata->dynamic_info[5],
          str_tab_len);
     if (do_checks
  && filedata->dynamic_strtab_section
  && ((filedata->dynamic_strtab_section->sh_offset
       != (file_ptr) offset)
      || (filedata->dynamic_strtab_section->sh_size
   != str_tab_len)))
       warn (gettext ("the .dynstr section doesn't match the DT_STRTAB and DT_STRSZ tags\n")
                                                                     );

     filedata->dynamic_strings
       = (char *) get_data (
# 11479 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 11479 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               , filedata, offset, 1, str_tab_len,
       gettext ("dynamic string table"));
     if (filedata->dynamic_strings == 
# 11481 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
# 11481 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         )
       {
  error (gettext ("Corrupt DT_STRTAB dynamic entry\n"));
  break;
       }

     filedata->dynamic_strings_length = str_tab_len;
     break;
   }
      }


  if (filedata->dynamic_syminfo == 
# 11493 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 11493 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    {
      uint64_t syminsz = 0;

      for (entry = filedata->dynamic_section;
    entry < filedata->dynamic_section + filedata->dynamic_nent;
    ++entry)
 {
   if (entry->d_tag == 0x6ffffdff)
     {




       if (sizeof (Elf_External_Syminfo) != entry->d_un.d_val)
  error (gettext ("Bad value (%d) for SYMINENT entry\n"),
         (int) entry->d_un.d_val);
     }
   else if (entry->d_tag == 0x6ffffdfe)
     syminsz = entry->d_un.d_val;
   else if (entry->d_tag == 0x6ffffeff)
     filedata->dynamic_syminfo_offset
       = offset_from_vma (filedata, entry->d_un.d_val, syminsz);
 }

      if (filedata->dynamic_syminfo_offset != 0 && syminsz != 0)
 {
   Elf_External_Syminfo * extsyminfo;
   Elf_External_Syminfo * extsym;
   Elf_Internal_Syminfo * syminfo;


   extsyminfo = (Elf_External_Syminfo *)
     get_data (
# 11526 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 11526 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  , filedata, filedata->dynamic_syminfo_offset,
        1, syminsz, gettext ("symbol information"));
   if (!extsyminfo)
     return 
# 11529 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 11529 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

   if (filedata->dynamic_syminfo != 
# 11531 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   ((void *)0)
# 11531 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       )
     {
       error (gettext ("Multiple dynamic symbol information sections found\n"));
       free (filedata->dynamic_syminfo);
     }
   filedata->dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);
   if (filedata->dynamic_syminfo == 
# 11537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   ((void *)0)
# 11537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       )
     {
       error (gettext ("Out of memory allocating %" 
# 11539 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "u" 
# 11539 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             " bytes for dynamic symbol info\n")
                                            ,
       syminsz);
       return 
# 11542 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 11542 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }

   filedata->dynamic_syminfo_nent
     = syminsz / sizeof (Elf_External_Syminfo);
   for (syminfo = filedata->dynamic_syminfo, extsym = extsyminfo;
        syminfo < (filedata->dynamic_syminfo
     + filedata->dynamic_syminfo_nent);
        ++syminfo, ++extsym)
     {
       syminfo->si_boundto = byte_get (extsym->si_boundto, sizeof (extsym->si_boundto));
       syminfo->si_flags = byte_get (extsym->si_flags, sizeof (extsym->si_flags));
     }

   free (extsyminfo);
 }
    }

  if (do_dynamic && filedata->dynamic_addr)
    {
      if (filedata->is_separate)
 printf (ngettext ("\nIn linked file '%s' the dynamic section at offset %#" 
# 11563 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                           "l" "x" 
# 11563 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                  " contains %" 
# 11563 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                                                "l" "u" 
# 11563 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                                       " entry:\n",
     "\nIn linked file '%s' the dynamic section at offset %#" 
# 11564 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                             "l" "x" 
# 11564 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                    " contains %" 
# 11564 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                                  "l" "u" 
# 11564 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                         " entries:\n",
     filedata->dynamic_nent),
  filedata->file_name,
  filedata->dynamic_addr,
  filedata->dynamic_nent);
      else
 printf (ngettext ("\nDynamic section at offset %#" 
# 11570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                   "l" "x" 
# 11570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                          " contains %" 
# 11570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                        "l" "u" 
# 11570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                               " entry:\n",
     "\nDynamic section at offset %#" 
# 11571 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     "l" "x" 
# 11571 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                            " contains %" 
# 11571 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                          "l" "u" 
# 11571 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                 " entries:\n",
     filedata->dynamic_nent),
  filedata->dynamic_addr,
  filedata->dynamic_nent);
    }
  if (do_dynamic)
    printf (gettext ("  Tag        Type                         Name/Value\n"));

  for (entry = filedata->dynamic_section;
       entry < filedata->dynamic_section + filedata->dynamic_nent;
       entry++)
    {
      if (do_dynamic)
 {
   const char * dtype;

   putchar (' ');
   print_vma (entry->d_tag, FULL_HEX);
   dtype = get_dynamic_type (filedata, entry->d_tag);
   printf (" (%s)%*s", dtype,
    ((is_32bit_elf ? 27 : 19) - (int) strlen (dtype)), " ");
 }

      switch (entry->d_tag)
 {
 case 30:
   if (do_dynamic)
     print_dynamic_flags (entry->d_un.d_val);
   break;

 case 0x7ffffffd:
 case 0x7fffffff:
 case 0x6ffffefa:
 case 0x6ffffefb:
 case 0x6ffffefc:
   if (do_dynamic)
     {
       switch (entry->d_tag)
  {
  case 0x7ffffffd:
    printf (gettext ("Auxiliary library"));
    break;

  case 0x7fffffff:
    printf (gettext ("Filter library"));
    break;

  case 0x6ffffefa:
    printf (gettext ("Configuration file"));
    break;

  case 0x6ffffefb:
    printf (gettext ("Dependency audit library"));
    break;

  case 0x6ffffefc:
    printf (gettext ("Audit library"));
    break;
  }

       if (valid_dynamic_name (filedata, entry->d_un.d_val))
  printf (": [%s]\n",
   get_dynamic_name (filedata, entry->d_un.d_val));
       else
  {
    printf (": ");
    print_vma (entry->d_un.d_val, PREFIX_HEX);
    putchar ('\n');
  }
     }
   break;

 case 0x6ffffdfc:
   if (do_dynamic)
     {
       printf (gettext ("Flags:"));

       if (entry->d_un.d_val == 0)
  printf (gettext (" None\n"));
       else
  {
    uint64_t val = entry->d_un.d_val;

    if (val & 0x00000001)
      {
        printf (" PARINIT");
        val ^= 0x00000001;
      }
    if (val & 0x00000002)
      {
        printf (" CONFEXP");
        val ^= 0x00000002;
      }
    if (val != 0)
      printf (" %" 
# 11665 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  "l" "x"
# 11665 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        , val);
    puts ("");
  }
     }
   break;

 case 0x6ffffdfd:
   if (do_dynamic)
     {
       printf (gettext ("Flags:"));

       if (entry->d_un.d_val == 0)
  printf (gettext (" None\n"));
       else
  {
    uint64_t val = entry->d_un.d_val;

    if (val & 0x00000001)
      {
        printf (" LAZYLOAD");
        val ^= 0x00000001;
      }
    if (val & 0x00000002)
      {
        printf (" GROUPPERM");
        val ^= 0x00000002;
      }
    if (val != 0)
      printf (" %" 
# 11693 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  "l" "x"
# 11693 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        , val);
    puts ("");
  }
     }
   break;

 case 0x6ffffffb:
   if (do_dynamic)
     {
       printf (gettext ("Flags:"));
       if (entry->d_un.d_val == 0)
  printf (gettext (" None\n"));
       else
  {
    uint64_t val = entry->d_un.d_val;

    if (val & 0x00000001)
      {
        printf (" NOW");
        val ^= 0x00000001;
      }
    if (val & 0x00000002)
      {
        printf (" GLOBAL");
        val ^= 0x00000002;
      }
    if (val & 0x00000004)
      {
        printf (" GROUP");
        val ^= 0x00000004;
      }
    if (val & 0x00000008)
      {
        printf (" NODELETE");
        val ^= 0x00000008;
      }
    if (val & 0x00000010)
      {
        printf (" LOADFLTR");
        val ^= 0x00000010;
      }
    if (val & 0x00000020)
      {
        printf (" INITFIRST");
        val ^= 0x00000020;
      }
    if (val & 0x00000040)
      {
        printf (" NOOPEN");
        val ^= 0x00000040;
      }
    if (val & 0x00000080)
      {
        printf (" ORIGIN");
        val ^= 0x00000080;
      }
    if (val & 0x00000100)
      {
        printf (" DIRECT");
        val ^= 0x00000100;
      }
    if (val & 0x00000200)
      {
        printf (" TRANS");
        val ^= 0x00000200;
      }
    if (val & 0x00000400)
      {
        printf (" INTERPOSE");
        val ^= 0x00000400;
      }
    if (val & 0x00000800)
      {
        printf (" NODEFLIB");
        val ^= 0x00000800;
      }
    if (val & 0x00001000)
      {
        printf (" NODUMP");
        val ^= 0x00001000;
      }
    if (val & 0x00002000)
      {
        printf (" CONFALT");
        val ^= 0x00002000;
      }
    if (val & 0x00004000)
      {
        printf (" ENDFILTEE");
        val ^= 0x00004000;
      }
    if (val & 0x00008000)
      {
        printf (" DISPRELDNE");
        val ^= 0x00008000;
      }
    if (val & 0x00010000)
      {
        printf (" DISPRELPND");
        val ^= 0x00010000;
      }
    if (val & 0x00020000)
      {
        printf (" NODIRECT");
        val ^= 0x00020000;
      }
    if (val & 0x00040000)
      {
        printf (" IGNMULDEF");
        val ^= 0x00040000;
      }
    if (val & 0x00080000)
      {
        printf (" NOKSYMS");
        val ^= 0x00080000;
      }
    if (val & 0x00100000)
      {
        printf (" NOHDR");
        val ^= 0x00100000;
      }
    if (val & 0x00200000)
      {
        printf (" EDITED");
        val ^= 0x00200000;
      }
    if (val & 0x00400000)
      {
        printf (" NORELOC");
        val ^= 0x00400000;
      }
    if (val & 0x00800000)
      {
        printf (" SYMINTPOSE");
        val ^= 0x00800000;
      }
    if (val & 0x01000000)
      {
        printf (" GLOBAUDIT");
        val ^= 0x01000000;
      }
    if (val & 0x02000000)
      {
        printf (" SINGLETON");
        val ^= 0x02000000;
      }
    if (val & 0x04000000)
      {
        printf (" STUB");
        val ^= 0x04000000;
      }
    if (val & 0x08000000)
      {
        printf (" PIE");
        val ^= 0x08000000;
      }
    if (val & 0x10000000)
      {
        printf (" KMOD");
        val ^= 0x10000000;
      }
    if (val & 0x20000000)
      {
        printf (" WEAKFILTER");
        val ^= 0x20000000;
      }
    if (val & 0x40000000)
      {
        printf (" NOCOMMON");
        val ^= 0x40000000;
      }
    if (val != 0)
      printf (" %" 
# 11865 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  "l" "x"
# 11865 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        , val);
    puts ("");
  }
     }
   break;

 case 20:
   filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;
   if (do_dynamic)
     puts (get_dynamic_type (filedata, entry->d_un.d_val));
   break;

 case 0 :
 case 1 :
 case 3 :
 case 4 :
 case 5 :
 case 6 :
 case 7 :
 case 12 :
 case 13 :
 case 14 :
 case 15 :
 case 16:
 case 17 :
 case 36 :
 case 21 :
 case 22 :
 case 23 :
 case 29 :
   filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;

   if (do_dynamic)
     {
       const char *name;

       if (valid_dynamic_name (filedata, entry->d_un.d_val))
  name = get_dynamic_name (filedata, entry->d_un.d_val);
       else
  name = 
# 11904 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 11904 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

       if (name)
  {
    switch (entry->d_tag)
      {
      case 1:
        printf (gettext ("Shared library: [%s]"), name);

        if (filedata->program_interpreter
     && (strcmp ((name), (filedata->program_interpreter)) == 0))
   printf (gettext (" program interpreter"));
        break;

      case 14:
        printf (gettext ("Library soname: [%s]"), name);
        break;

      case 15:
        printf (gettext ("Library rpath: [%s]"), name);
        break;

      case 29:
        printf (gettext ("Library runpath: [%s]"), name);
        break;

      default:
        print_vma (entry->d_un.d_val, PREFIX_HEX);
        break;
      }
  }
       else
  print_vma (entry->d_un.d_val, PREFIX_HEX);

       putchar ('\n');
     }
   break;

 case 2:
 case 8 :
 case 10 :
 case 18 :
 case 9 :
 case 37 :
 case 35 :
 case 11 :
 case 19 :
   filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;

 case 0x6ffffdf9:
 case 0x6ffffdfa :
 case 0x6ffffdfb :
 case 33:
 case 27:
 case 28:
 case 0x6ffffdf6:
 case 0x6ffffdf7:
   if (do_dynamic)
     {
       print_vma (entry->d_un.d_val, UNSIGNED);
       printf (gettext (" (bytes)\n"));
     }
   break;

 case 0x6ffffffd:
 case 0x6fffffff:
 case 0x6ffffff9:
 case 0x6ffffffa:
   if (do_dynamic)
     {
       print_vma (entry->d_un.d_val, UNSIGNED);
       putchar ('\n');
     }
   break;

 case 0x6ffffdfe:
 case 0x6ffffdff:
 case 0x6ffffeff:
 case 0x7ffffffe:
 case 25:
 case 26:
   if (do_dynamic)
     {
       if (entry->d_tag == 0x7ffffffe
    && valid_dynamic_name (filedata, entry->d_un.d_val))
  {
    const char *name
      = get_dynamic_name (filedata, entry->d_un.d_val);

    if (*name)
      {
        printf (gettext ("Not needed object: [%s]\n"), name);
        break;
      }
  }

       print_vma (entry->d_un.d_val, PREFIX_HEX);
       putchar ('\n');
     }
   break;

 case 24:

   if (do_dynamic)
     putchar ('\n');
   break;

 case 0x6ffffdf5:
   if (do_dynamic)
     {
       struct tm * tmp;
       time_t atime = entry->d_un.d_val;

       tmp = gmtime (&atime);

       if (tmp == 
# 12019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 12019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
  printf (gettext ("<corrupt time val: %" 
# 12020 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "x"
# 12020 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         ),
   (uint64_t) atime);
       else
  printf ("%04u-%02u-%02uT%02u:%02u:%02u\n",
   tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
   tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

     }
   break;

 case 0x6ffffef5:
   filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
   if (do_dynamic)
     {
       print_vma (entry->d_un.d_val, PREFIX_HEX);
       putchar ('\n');
     }
   break;

 case 0x6ffffdf4:
   if (do_dynamic)
     {
       printf (gettext ("Flags:"));
       if (entry->d_un.d_val == 0)
  printf (gettext (" None\n"));
       else
  {
    uint64_t val = entry->d_un.d_val;

    if (val & 0x00000001)
      {
        printf (" UNIQUE");
        val ^= 0x00000001;
      }
    if (val != 0)
      printf (" %" 
# 12055 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  "l" "x"
# 12055 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        , val);
    puts ("");
  }
     }
   break;

 default:
   if ((entry->d_tag >= 0x6ffffff0) && (entry->d_tag <= 0x6fffffff))
     filedata->version_info[(0x6fffffff - (entry->d_tag))]
       = entry->d_un.d_val;

   if (do_dynamic)
     {
       switch (filedata->file_header.e_machine)
  {
  case 183:
    dynamic_section_aarch64_val (entry);
    break;
  case 8:
  case 10:
    dynamic_section_mips_val (filedata, entry);
    break;
  case 15:
    dynamic_section_parisc_val (entry);
    break;
  case 50:
    dynamic_section_ia64_val (entry);
    break;
  default:
    print_vma (entry->d_un.d_val, PREFIX_HEX);
    putchar ('\n');
  }
     }
   break;
 }
    }

  return 
# 12092 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 12092 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static char *
get_ver_flags (unsigned int flags)
{
  static char buff[128];

  buff[0] = 0;

  if (flags == 0)
    return gettext ("none");

  if (flags & 0x1)
    strcat (buff, "BASE");

  if (flags & 0x2)
    {
      if (flags & 0x1)
 strcat (buff, " | ");

      strcat (buff, "WEAK");
    }

  if (flags & 0x4)
    {
      if (flags & (0x1|0x2))
 strcat (buff, " | ");

      strcat (buff, "INFO");
    }

  if (flags & ~(0x1 | 0x2 | 0x4))
    {
      if (flags & (0x1 | 0x2 | 0x4))
 strcat (buff, " | ");

      strcat (buff, gettext ("<unknown>"));
    }

  return buff;
}



static 
# 12137 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 12138 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_version_sections (Filedata * filedata)
{
  Elf_Internal_Shdr * section;
  unsigned i;
  
# 12142 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 12142 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      found = 
# 12142 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              0
# 12142 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;

  if (! do_version)
    return 
# 12145 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 12145 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  for (i = 0, section = filedata->section_headers;
       i < filedata->file_header.e_shnum;
       i++, section++)
    {
      switch (section->sh_type)
 {
 case 0x6ffffffd:
   {
     Elf_External_Verdef * edefs;
     size_t idx;
     size_t cnt;
     char * endbuf;

     found = 
# 12160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 12160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

     if (filedata->is_separate)
       printf (ngettext ("\nIn linked file '%s' the version definition section '%s' contains %u entry:\n",
    "\nIn linked file '%s' the version definition section '%s' contains %u entries:\n",
    section->sh_info),
        filedata->file_name,
        printable_section_name (filedata, section),
        section->sh_info);
     else
       printf (ngettext ("\nVersion definition section '%s' "
    "contains %u entry:\n",
    "\nVersion definition section '%s' "
    "contains %u entries:\n",
    section->sh_info),
        printable_section_name (filedata, section),
        section->sh_info);

     printf (gettext (" Addr: 0x%016" 
# 12178 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x"
# 12178 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ), section->sh_addr);
     printf (gettext ("  Offset: 0x%08" 
# 12179 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 12179 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "  Link: %u (%s)\n"),
      section->sh_offset, section->sh_link,
      printable_section_name_from_index (filedata, section->sh_link));

     edefs = (Elf_External_Verdef *)
                get_data (
# 12184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 12184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             , filedata, section->sh_offset, 1,section->sh_size,
                          gettext ("version definition section"));
     if (!edefs)
       break;
     endbuf = (char *) edefs + section->sh_size;

     for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
       {
  char * vstart;
  Elf_External_Verdef * edef;
  Elf_Internal_Verdef ent;
  Elf_External_Verdaux * eaux;
  Elf_Internal_Verdaux aux;
  size_t isum;
  int j;

  vstart = ((char *) edefs) + idx;
  if (vstart + sizeof (*edef) > endbuf)
    break;

  edef = (Elf_External_Verdef *) vstart;

  ent.vd_version = byte_get (edef->vd_version, sizeof (edef->vd_version));
  ent.vd_flags = byte_get (edef->vd_flags, sizeof (edef->vd_flags));
  ent.vd_ndx = byte_get (edef->vd_ndx, sizeof (edef->vd_ndx));
  ent.vd_cnt = byte_get (edef->vd_cnt, sizeof (edef->vd_cnt));
  ent.vd_hash = byte_get (edef->vd_hash, sizeof (edef->vd_hash));
  ent.vd_aux = byte_get (edef->vd_aux, sizeof (edef->vd_aux));
  ent.vd_next = byte_get (edef->vd_next, sizeof (edef->vd_next));

  printf (gettext ("  %#06zx: Rev: %d  Flags: %s"),
   idx, ent.vd_version, get_ver_flags (ent.vd_flags));

  printf (gettext ("  Index: %d  Cnt: %d  "),
   ent.vd_ndx, ent.vd_cnt);


  if (ent.vd_aux > (size_t) (endbuf - vstart))
    break;

  vstart += ent.vd_aux;

  if (vstart + sizeof (*eaux) > endbuf)
    break;
  eaux = (Elf_External_Verdaux *) vstart;

  aux.vda_name = byte_get (eaux->vda_name, sizeof (eaux->vda_name));
  aux.vda_next = byte_get (eaux->vda_next, sizeof (eaux->vda_next));

  if (valid_dynamic_name (filedata, aux.vda_name))
    printf (gettext ("Name: %s\n"),
     get_dynamic_name (filedata, aux.vda_name));
  else
    printf (gettext ("Name index: %ld\n"), aux.vda_name);

  isum = idx + ent.vd_aux;

  for (j = 1; j < ent.vd_cnt; j++)
    {
      if (aux.vda_next < sizeof (*eaux)
   && !(j == ent.vd_cnt - 1 && aux.vda_next == 0))
        {
   warn (gettext ("Invalid vda_next field of %lx\n"),
         aux.vda_next);
   j = ent.vd_cnt;
   break;
        }

      if (aux.vda_next > (size_t) (endbuf - vstart))
        break;

      isum += aux.vda_next;
      vstart += aux.vda_next;

      if (vstart + sizeof (*eaux) > endbuf)
        break;
      eaux = (Elf_External_Verdaux *) vstart;

      aux.vda_name = byte_get (eaux->vda_name, sizeof (eaux->vda_name));
      aux.vda_next = byte_get (eaux->vda_next, sizeof (eaux->vda_next));

      if (valid_dynamic_name (filedata, aux.vda_name))
        printf (gettext ("  %#06zx: Parent %d: %s\n"),
         isum, j,
         get_dynamic_name (filedata, aux.vda_name));
      else
        printf (gettext ("  %#06zx: Parent %d, name index: %ld\n"),
         isum, j, aux.vda_name);
    }

  if (j < ent.vd_cnt)
    printf (gettext ("  Version def aux past end of section\n"));



  if (ent.vd_next < sizeof (*edef)
      && !(cnt == section->sh_info - 1 && ent.vd_next == 0))
    {
      warn (gettext ("Invalid vd_next field of %lx\n"), ent.vd_next);
      cnt = section->sh_info;
      break;
    }
  if (ent.vd_next > (size_t) (endbuf - ((char *) edefs + idx)))
    break;

  idx += ent.vd_next;
       }

     if (cnt < section->sh_info)
       printf (gettext ("  Version definition past end of section\n"));

     free (edefs);
   }
   break;

 case 0x6ffffffe:
   {
     Elf_External_Verneed * eneed;
     size_t idx;
     size_t cnt;
     char * endbuf;

     found = 
# 12306 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 12306 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

     if (filedata->is_separate)
       printf (ngettext ("\nIn linked file '%s' the version needs section '%s' contains %u entry:\n",
    "\nIn linked file '%s' the version needs section '%s' contains %u entries:\n",
    section->sh_info),
        filedata->file_name,
        printable_section_name (filedata, section),
        section->sh_info);
     else
       printf (ngettext ("\nVersion needs section '%s' "
    "contains %u entry:\n",
    "\nVersion needs section '%s' "
    "contains %u entries:\n",
    section->sh_info),
        printable_section_name (filedata, section),
        section->sh_info);

     printf (gettext (" Addr: 0x%016" 
# 12324 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x"
# 12324 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ), section->sh_addr);
     printf (gettext ("  Offset: 0x%08" 
# 12325 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 12325 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "  Link: %u (%s)\n"),
      section->sh_offset, section->sh_link,
      printable_section_name_from_index (filedata, section->sh_link));

     eneed = (Elf_External_Verneed *) get_data (
# 12329 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               ((void *)0)
# 12329 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   , filedata,
                                                       section->sh_offset, 1,
                                                       section->sh_size,
                                                       gettext ("Version Needs section"));
     if (!eneed)
       break;
     endbuf = (char *) eneed + section->sh_size;

     for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
       {
  Elf_External_Verneed * entry;
  Elf_Internal_Verneed ent;
  size_t isum;
  int j;
  char * vstart;

  vstart = ((char *) eneed) + idx;
  if (vstart + sizeof (*entry) > endbuf)
    break;

  entry = (Elf_External_Verneed *) vstart;

  ent.vn_version = byte_get (entry->vn_version, sizeof (entry->vn_version));
  ent.vn_cnt = byte_get (entry->vn_cnt, sizeof (entry->vn_cnt));
  ent.vn_file = byte_get (entry->vn_file, sizeof (entry->vn_file));
  ent.vn_aux = byte_get (entry->vn_aux, sizeof (entry->vn_aux));
  ent.vn_next = byte_get (entry->vn_next, sizeof (entry->vn_next));

  printf (gettext ("  %#06zx: Version: %d"), idx, ent.vn_version);

  if (valid_dynamic_name (filedata, ent.vn_file))
    printf (gettext ("  File: %s"),
     get_dynamic_name (filedata, ent.vn_file));
  else
    printf (gettext ("  File: %lx"), ent.vn_file);

  printf (gettext ("  Cnt: %d\n"), ent.vn_cnt);


  if (ent.vn_aux > (size_t) (endbuf - vstart))
    break;
  vstart += ent.vn_aux;

  for (j = 0, isum = idx + ent.vn_aux; j < ent.vn_cnt; ++j)
    {
      Elf_External_Vernaux * eaux;
      Elf_Internal_Vernaux aux;

      if (vstart + sizeof (*eaux) > endbuf)
        break;
      eaux = (Elf_External_Vernaux *) vstart;

      aux.vna_hash = byte_get (eaux->vna_hash, sizeof (eaux->vna_hash));
      aux.vna_flags = byte_get (eaux->vna_flags, sizeof (eaux->vna_flags));
      aux.vna_other = byte_get (eaux->vna_other, sizeof (eaux->vna_other));
      aux.vna_name = byte_get (eaux->vna_name, sizeof (eaux->vna_name));
      aux.vna_next = byte_get (eaux->vna_next, sizeof (eaux->vna_next));

      if (valid_dynamic_name (filedata, aux.vna_name))
        printf (gettext ("  %#06zx:   Name: %s"),
         isum, get_dynamic_name (filedata, aux.vna_name));
      else
        printf (gettext ("  %#06zx:   Name index: %lx"),
         isum, aux.vna_name);

      printf (gettext ("  Flags: %s  Version: %d\n"),
       get_ver_flags (aux.vna_flags), aux.vna_other);

      if (aux.vna_next < sizeof (*eaux)
   && !(j == ent.vn_cnt - 1 && aux.vna_next == 0))
        {
   warn (gettext ("Invalid vna_next field of %lx\n"),
         aux.vna_next);
   j = ent.vn_cnt;
   break;
        }

      if (aux.vna_next > (size_t) (endbuf - vstart))
        break;
      isum += aux.vna_next;
      vstart += aux.vna_next;
    }

  if (j < ent.vn_cnt)
    warn (gettext ("Missing Version Needs auxiliary information\n"));

  if (ent.vn_next < sizeof (*entry)
      && !(cnt == section->sh_info - 1 && ent.vn_next == 0))
    {
      warn (gettext ("Invalid vn_next field of %lx\n"), ent.vn_next);
      cnt = section->sh_info;
      break;
    }
  if (ent.vn_next > (size_t) (endbuf - ((char *) eneed + idx)))
    break;
  idx += ent.vn_next;
       }

     if (cnt < section->sh_info)
       warn (gettext ("Missing Version Needs information\n"));

     free (eneed);
   }
   break;

 case 0x6fffffff:
   {
     Elf_Internal_Shdr * link_section;
     uint64_t total;
     unsigned int cnt;
     unsigned char * edata;
     unsigned short * data;
     char * strtab;
     Elf_Internal_Sym * symbols;
     Elf_Internal_Shdr * string_sec;
     uint64_t num_syms;
     uint64_t off;

     if (section->sh_link >= filedata->file_header.e_shnum)
       break;

     link_section = filedata->section_headers + section->sh_link;
     total = section->sh_size / sizeof (Elf_External_Versym);

     if (link_section->sh_link >= filedata->file_header.e_shnum)
       break;

     found = 
# 12456 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 12456 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

     symbols = get_elf_symbols (filedata, link_section, & num_syms);
     if (symbols == 
# 12459 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 12459 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       )
       break;

     string_sec = filedata->section_headers + link_section->sh_link;

     strtab = (char *) get_data (
# 12464 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 12464 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    , filedata, string_sec->sh_offset, 1,
                                        string_sec->sh_size,
                                        gettext ("version string table"));
     if (!strtab)
       {
  free (symbols);
  break;
       }

     if (filedata->is_separate)
       printf (ngettext ("\nIn linked file '%s' the version symbols section '%s' contains %" 
# 12474 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                                            "l" "u" 
# 12474 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                                   " entry:\n",
    "\nIn linked file '%s' the version symbols section '%s' contains %" 
# 12475 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                       "l" "u" 
# 12475 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                              " entries:\n",
    total),
        filedata->file_name,
        printable_section_name (filedata, section),
        total);
     else
       printf (ngettext ("\nVersion symbols section '%s' "
    "contains %" 
# 12482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                "l" "u" 
# 12482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       " entry:\n",
    "\nVersion symbols section '%s' "
    "contains %" 
# 12484 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                "l" "u" 
# 12484 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       " entries:\n",
    total),
        printable_section_name (filedata, section),
        total);

     printf (gettext (" Addr: 0x%016" 
# 12489 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x"
# 12489 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ), section->sh_addr);
     printf (gettext ("  Offset: 0x%08" 
# 12490 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 12490 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "  Link: %u (%s)\n"),
      section->sh_offset, section->sh_link,
      printable_section_name (filedata, link_section));

     off = offset_from_vma (filedata,
       filedata->version_info[(0x6fffffff - (0x6ffffff0))],
       total * sizeof (short));
     edata = (unsigned char *) get_data (
# 12497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                        ((void *)0)
# 12497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                            , filedata, off,
      sizeof (short), total,
      gettext ("version symbol data"));
     if (!edata)
       {
  free (strtab);
  free (symbols);
  break;
       }

     data = (short unsigned int *) cmalloc (total, sizeof (short));

     for (cnt = total; cnt --;)
       data[cnt] = byte_get (edata + cnt * sizeof (short),
        sizeof (short));

     free (edata);

     for (cnt = 0; cnt < total; cnt += 4)
       {
  int j, nn;
  char *name;
  char *invalid = gettext ("*invalid*");

  printf ("  %03x:", cnt);

  for (j = 0; (j < 4) && (cnt + j) < total; ++j)
    switch (data[cnt + j])
      {
      case 0:
        fputs (gettext ("   0 (*local*)    "), 
# 12527 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       stdout
# 12527 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             );
        break;

      case 1:
        fputs (gettext ("   1 (*global*)   "), 
# 12531 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       stdout
# 12531 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             );
        break;

      default:
        nn = printf ("%4x%c", data[cnt + j] & 0x7fff,
       data[cnt + j] & 0x8000 ? 'h' : ' ');



        if (cnt + j >= num_syms)
          {
            warn (gettext ("invalid index into symbol array\n"));
            break;
   }

        name = 
# 12546 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 12546 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
        if (filedata->version_info[(0x6fffffff - (0x6ffffffe))])
   {
     Elf_Internal_Verneed ivn;
     uint64_t offset;

     offset = offset_from_vma
       (filedata,
        filedata->version_info[(0x6fffffff - (0x6ffffffe))],
        sizeof (Elf_External_Verneed));

     do
       {
         Elf_Internal_Vernaux ivna;
         Elf_External_Verneed evn;
         Elf_External_Vernaux evna;
         uint64_t a_off;

         if (get_data (&evn, filedata, offset, sizeof (evn), 1,
         gettext ("version need")) == 
# 12565 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 12565 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  )
    break;

         ivn.vn_aux = byte_get (evn.vn_aux, sizeof (evn.vn_aux));
         ivn.vn_next = byte_get (evn.vn_next, sizeof (evn.vn_next));

         a_off = offset + ivn.vn_aux;

         do
    {
      if (get_data (&evna, filedata, a_off, sizeof (evna),
      1, gettext ("version need aux (2)")) == 
# 12576 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 12576 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          )
        {
          ivna.vna_next = 0;
          ivna.vna_other = 0;
        }
      else
        {
          ivna.vna_next = byte_get (evna.vna_next, sizeof (evna.vna_next));
          ivna.vna_other = byte_get (evna.vna_other, sizeof (evna.vna_other));
        }

      a_off += ivna.vna_next;
    }
         while (ivna.vna_other != data[cnt + j]
         && ivna.vna_next != 0);

         if (ivna.vna_other == data[cnt + j])
    {
      ivna.vna_name = byte_get (evna.vna_name, sizeof (evna.vna_name));

      if (ivna.vna_name >= string_sec->sh_size)
        name = invalid;
      else
        name = strtab + ivna.vna_name;
      break;
    }

         offset += ivn.vn_next;
       }
     while (ivn.vn_next);
   }

        if (data[cnt + j] != 0x8001
     && filedata->version_info[(0x6fffffff - (0x6ffffffc))])
   {
     Elf_Internal_Verdef ivd;
     Elf_External_Verdef evd;
     uint64_t offset;

     offset = offset_from_vma
       (filedata,
        filedata->version_info[(0x6fffffff - (0x6ffffffc))],
        sizeof evd);

     do
       {
         if (get_data (&evd, filedata, offset, sizeof (evd), 1,
         gettext ("version def")) == 
# 12623 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             ((void *)0)
# 12623 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 )
    {
      ivd.vd_next = 0;

      ivd.vd_ndx = (data[cnt + j] & 0x7fff) + 1;
      break;
    }
         else
    {
      ivd.vd_next = byte_get (evd.vd_next, sizeof (evd.vd_next));
      ivd.vd_ndx = byte_get (evd.vd_ndx, sizeof (evd.vd_ndx));
    }

         offset += ivd.vd_next;
       }
     while (ivd.vd_ndx != (data[cnt + j] & 0x7fff)
     && ivd.vd_next != 0);

     if (ivd.vd_ndx == (data[cnt + j] & 0x7fff))
       {
         Elf_External_Verdaux evda;
         Elf_Internal_Verdaux ivda;

         ivd.vd_aux = byte_get (evd.vd_aux, sizeof (evd.vd_aux));

         if (get_data (&evda, filedata,
         offset - ivd.vd_next + ivd.vd_aux,
         sizeof (evda), 1,
         gettext ("version def aux")) == 
# 12651 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 ((void *)0)
# 12651 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     )
    break;

         ivda.vda_name = byte_get (evda.vda_name, sizeof (evda.vda_name));

         if (ivda.vda_name >= string_sec->sh_size)
    name = invalid;
         else if (name != 
# 12658 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0) 
# 12658 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              && name != invalid)
    name = gettext ("*both*");
         else
    name = strtab + ivda.vda_name;
       }
   }
        if (name != 
# 12664 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 12664 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       )
   nn += printf ("(%s%-*s",
          name,
          12 - (int) strlen (name),
          ")");

        if (nn < 18)
   printf ("%*c", 18 - nn, ' ');
      }

  putchar ('\n');
       }

     free (data);
     free (strtab);
     free (symbols);
   }
   break;

 default:
   break;
 }
    }

  if (! found)
    {
      if (filedata->is_separate)
 printf (gettext ("\nNo version information found in linked file '%s'.\n"),
  filedata->file_name);
      else
 printf (gettext ("\nNo version information found in this file.\n"));
    }

  return 
# 12697 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 12697 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_symbol_binding (Filedata * filedata, unsigned int binding)
{
  static char buff[64];

  switch (binding)
    {
    case 0: return "LOCAL";
    case 1: return "GLOBAL";
    case 2: return "WEAK";
    default:
      if (binding >= 13 && binding <= 15)
 snprintf (buff, sizeof (buff), gettext ("<processor specific>: %d"),
    binding);
      else if (binding >= 10 && binding <= 12)
 {
   if (binding == 10
       && filedata->file_header.e_ident[7] == 3)
     return "UNIQUE";
   snprintf (buff, sizeof (buff), gettext ("<OS specific>: %d"), binding);
 }
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %d"), binding);
      return buff;
    }
}

static const char *
get_symbol_type (Filedata * filedata, unsigned int type)
{
  static char buff[64];

  switch (type)
    {
    case 0: return "NOTYPE";
    case 1: return "OBJECT";
    case 2: return "FUNC";
    case 3: return "SECTION";
    case 4: return "FILE";
    case 5: return "COMMON";
    case 6: return "TLS";
    case 8: return "RELC";
    case 9: return "SRELC";
    default:
      if (type >= 13 && type <= 15)
 {
   if (filedata->file_header.e_machine == 40 && type == 13)
     return "THUMB_FUNC";

   if (filedata->file_header.e_machine == 43 && type == 13)
     return "REGISTER";

   if (filedata->file_header.e_machine == 15 && type == 13)
     return "PARISC_MILLI";

   snprintf (buff, sizeof (buff), gettext ("<processor specific>: %d"), type);
 }
      else if (type >= 10 && type <= 12)
 {
   if (filedata->file_header.e_machine == 15)
     {
       if (type == (10 + 0x1))
  return "HP_OPAQUE";
       if (type == (10 + 0x2))
  return "HP_STUB";
     }

   if (type == 10
       && (filedata->file_header.e_ident[7] == 3
    || filedata->file_header.e_ident[7] == 9))
     return "IFUNC";

   snprintf (buff, sizeof (buff), gettext ("<OS specific>: %d"), type);
 }
      else
 snprintf (buff, sizeof (buff), gettext ("<unknown>: %d"), type);
      return buff;
    }
}

static const char *
get_symbol_visibility (unsigned int visibility)
{
  switch (visibility)
    {
    case 0: return "DEFAULT";
    case 1: return "INTERNAL";
    case 2: return "HIDDEN";
    case 3: return "PROTECTED";
    default:
      error (gettext ("Unrecognized visibility value: %u\n"), visibility);
      return gettext ("<unknown>");
    }
}

static const char *
get_alpha_symbol_other (unsigned int other)
{
  switch (other)
    {
    case 0x80: return "NOPV";
    case 0x88: return "STD GPLOAD";
    default:
      error (gettext ("Unrecognized alpha specific other value: %u\n"), other);
      return gettext ("<unknown>");
    }
}

static const char *
get_solaris_symbol_visibility (unsigned int visibility)
{
  switch (visibility)
    {
    case 4: return "EXPORTED";
    case 5: return "SINGLETON";
    case 6: return "ELIMINATE";
    default: return get_symbol_visibility (visibility);
    }
}

static const char *
get_aarch64_symbol_other (unsigned int other)
{
  static char buf[32];

  if (other & 0x80)
    {
      other &= ~0x80;
      if (other == 0)
 return "VARIANT_PCS";
      snprintf (buf, sizeof buf, "VARIANT_PCS | %x", other);
      return buf;
    }
  return 
# 12833 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 12833 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_mips_symbol_other (unsigned int other)
{
  switch (other)
    {
    case (1 << 2): return "OPTIONAL";
    case 0x8: return "MIPS PLT";
    case 0x20: return "MIPS PIC";
    case (2 << 6): return "MICROMIPS";
    case (2 << 6) | 0x20: return "MICROMIPS, MIPS PIC";
    case 0xf0: return "MIPS16";
    default: return 
# 12847 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 12847 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ;
    }
}

static const char *
get_ia64_symbol_other (Filedata * filedata, unsigned int other)
{
  if (is_ia64_vms (filedata))
    {
      static char res[32];

      res[0] = 0;


      switch (filedata->file_header.e_type)
        {
        case 3:
        case 2:
          switch ((((other) & 0x30) >> 4))
            {
            case 0:
              strcat (res, " CA");
              break;
            case 1:
              strcat (res, " VEC");
              break;
            case 2:
              strcat (res, " FD");
              break;
            case 3:
              strcat (res, " RSV");
              break;
            default:
       warn (gettext ("Unrecognized IA64 VMS ST Function type: %d\n"),
      (((other) & 0x30) >> 4));
       strcat (res, " <unknown>");
       break;
            }
          break;
        default:
          break;
        }
      switch ((((other) & 0xc0) >> 6))
        {
        case 0:
          strcat (res, " IGN");
          break;
        case 1:
          strcat (res, " RSV");
          break;
        case 2:
          strcat (res, " STD");
          break;
        case 3:
          strcat (res, " LNK");
          break;
        default:
   warn (gettext ("Unrecognized IA64 VMS ST Linkage: %d\n"),
  (((other) & 0xc0) >> 6));
   strcat (res, " <unknown>");
   break;
        }

      if (res[0] != 0)
        return res + 1;
      else
        return res;
    }
  return 
# 12915 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 12915 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_ppc64_symbol_other (unsigned int other)
{
  if ((other & ~(7 << 5)) != 0)
    return 
# 12922 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 12922 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  other >>= 5;
  if (other <= 6)
    {
      static char buf[64];
      if (other >= 2)
 other = ppc64_decode_local_entry (other);
      snprintf (buf, sizeof buf, gettext ("<localentry>: %d"), other);
      return buf;
    }
  return 
# 12933 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 12933 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_riscv_symbol_other (unsigned int other)
{
  static char buf[32];
  buf[0] = 0;

  if (other & 0x80)
    {
      strcat (buf, gettext (" VARIANT_CC"));
      other &= ~0x80;
    }

  if (other != 0)
    snprintf (buf, sizeof buf, " %x", other);


  if (buf[0] != 0)
    return buf + 1;
  else
    return buf;
}

static const char *
get_symbol_other (Filedata * filedata, unsigned int other)
{
  const char * result = 
# 12961 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 12961 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
  static char buff [64];

  if (other == 0)
    return "";

  switch (filedata->file_header.e_machine)
    {
    case 0x9026:
      result = get_alpha_symbol_other (other);
      break;
    case 183:
      result = get_aarch64_symbol_other (other);
      break;
    case 8:
      result = get_mips_symbol_other (other);
      break;
    case 50:
      result = get_ia64_symbol_other (filedata, other);
      break;
    case 21:
      result = get_ppc64_symbol_other (other);
      break;
    case 243:
      result = get_riscv_symbol_other (other);
      break;
    default:
      result = 
# 12988 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 12988 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
      break;
    }

  if (result)
    return result;

  snprintf (buff, sizeof buff, gettext ("<other>: %x"), other);
  return buff;
}

static const char *
get_symbol_index_type (Filedata * filedata, unsigned int type)
{
  static char buff[32];

  switch (type)
    {
    case 0: return "UND";
    case (-0xFu): return "ABS";
    case (-0xEu): return "COM";
    default:
      if (type == (-0x100u)
   && filedata->file_header.e_machine == 50
   && filedata->file_header.e_ident[7] == 1)
 return "ANSI_COM";
      else if ((filedata->file_header.e_machine == 62
  || filedata->file_header.e_machine == 180
  || filedata->file_header.e_machine == 181)
        && type == ((-0x100u) + 2))
 return "LARGE_COM";
      else if ((type == ((-0x100u) + 3)
  && filedata->file_header.e_machine == 8)
        || (type == (-0x100u)
     && filedata->file_header.e_machine == 140))
 return "SCOM";
      else if (type == ((-0x100u) + 4)
        && filedata->file_header.e_machine == 8)
 return "SUND";
      else if (type >= (-0x100u) && type <= (-0xE1u))
 sprintf (buff, "PRC[0x%04x]", type & 0xffff);
      else if (type >= (-0xE0u) && type <= (-0xC1u))
 sprintf (buff, "OS [0x%04x]", type & 0xffff);
      else if (type >= (-0x100u))
 sprintf (buff, "RSV[0x%04x]", type & 0xffff);
      else if (filedata->file_header.e_shnum != 0
        && type >= filedata->file_header.e_shnum)
 sprintf (buff, gettext ("bad section index[%3d]"), type);
      else
 sprintf (buff, "%3d", type);
      break;
    }

  return buff;
}

static const char *
get_symbol_version_string (Filedata *filedata,
      
# 13046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 13046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          is_dynsym,
      const char *strtab,
      size_t strtab_size,
      unsigned int si,
      Elf_Internal_Sym *psym,
      enum versioned_symbol_info *sym_info,
      unsigned short *vna_other)
{
  unsigned char data[2];
  unsigned short vers_data;
  uint64_t offset;
  unsigned short max_vd_ndx;

  if (!is_dynsym
      || filedata->version_info[(0x6fffffff - (0x6ffffff0))] == 0)
    return 
# 13061 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 13061 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  offset = offset_from_vma (filedata,
       filedata->version_info[(0x6fffffff - (0x6ffffff0))],
       sizeof data + si * sizeof (vers_data));

  if (get_data (&data, filedata, offset + si * sizeof (vers_data),
  sizeof (data), 1, gettext ("version data")) == 
# 13068 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         ((void *)0)
# 13068 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             )
    return 
# 13069 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 13069 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  vers_data = byte_get (data, 2);

  if ((vers_data & 0x8000) == 0 && vers_data == 0)
    return 
# 13074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 13074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  *sym_info = (vers_data & 0x8000) != 0 ? symbol_hidden : symbol_public;
  max_vd_ndx = 0;
# 13088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  if (psym->st_shndx != 0
      && vers_data != 0x8001
      && filedata->version_info[(0x6fffffff - (0x6ffffffc))])
    {
      Elf_Internal_Verdef ivd;
      Elf_Internal_Verdaux ivda;
      Elf_External_Verdaux evda;
      uint64_t off;

      off = offset_from_vma (filedata,
        filedata->version_info[(0x6fffffff - (0x6ffffffc))],
        sizeof (Elf_External_Verdef));

      do
 {
   Elf_External_Verdef evd;

   if (get_data (&evd, filedata, off, sizeof (evd), 1,
   gettext ("version def")) == 
# 13106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 13106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           )
     {
       ivd.vd_ndx = 0;
       ivd.vd_aux = 0;
       ivd.vd_next = 0;
       ivd.vd_flags = 0;
     }
   else
     {
       ivd.vd_ndx = byte_get (evd.vd_ndx, sizeof (evd.vd_ndx));
       ivd.vd_aux = byte_get (evd.vd_aux, sizeof (evd.vd_aux));
       ivd.vd_next = byte_get (evd.vd_next, sizeof (evd.vd_next));
       ivd.vd_flags = byte_get (evd.vd_flags, sizeof (evd.vd_flags));
     }

   if ((ivd.vd_ndx & 0x7fff) > max_vd_ndx)
     max_vd_ndx = ivd.vd_ndx & 0x7fff;

   off += ivd.vd_next;
 }
      while (ivd.vd_ndx != (vers_data & 0x7fff) && ivd.vd_next != 0);

      if (ivd.vd_ndx == (vers_data & 0x7fff))
 {
   if (ivd.vd_ndx == 1 && ivd.vd_flags == 0x1)
     return 
# 13131 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           ((void *)0)
# 13131 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

   off -= ivd.vd_next;
   off += ivd.vd_aux;

   if (get_data (&evda, filedata, off, sizeof (evda), 1,
   gettext ("version def aux")) != 
# 13137 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 13137 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               )
     {
       ivda.vda_name = byte_get (evda.vda_name, sizeof (evda.vda_name));

       if (psym->st_name != ivda.vda_name)
  return (ivda.vda_name < strtab_size
   ? strtab + ivda.vda_name : gettext ("<corrupt>"));
     }
 }
    }

  if (filedata->version_info[(0x6fffffff - (0x6ffffffe))])
    {
      Elf_External_Verneed evn;
      Elf_Internal_Verneed ivn;
      Elf_Internal_Vernaux ivna;

      offset = offset_from_vma (filedata,
    filedata->version_info[(0x6fffffff - (0x6ffffffe))],
    sizeof evn);
      do
 {
   uint64_t vna_off;

   if (get_data (&evn, filedata, offset, sizeof (evn), 1,
   gettext ("version need")) == 
# 13162 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 13162 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            )
     {
       ivna.vna_next = 0;
       ivna.vna_other = 0;
       ivna.vna_name = 0;
       break;
     }

   ivn.vn_aux = byte_get (evn.vn_aux, sizeof (evn.vn_aux));
   ivn.vn_next = byte_get (evn.vn_next, sizeof (evn.vn_next));

   vna_off = offset + ivn.vn_aux;

   do
     {
       Elf_External_Vernaux evna;

       if (get_data (&evna, filedata, vna_off, sizeof (evna), 1,
       gettext ("version need aux (3)")) == 
# 13180 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    ((void *)0)
# 13180 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        )
  {
    ivna.vna_next = 0;
    ivna.vna_other = 0;
    ivna.vna_name = 0;
  }
       else
  {
    ivna.vna_other = byte_get (evna.vna_other, sizeof (evna.vna_other));
    ivna.vna_next = byte_get (evna.vna_next, sizeof (evna.vna_next));
    ivna.vna_name = byte_get (evna.vna_name, sizeof (evna.vna_name));
  }

       vna_off += ivna.vna_next;
     }
   while (ivna.vna_other != vers_data && ivna.vna_next != 0);

   if (ivna.vna_other == vers_data)
     break;

   offset += ivn.vn_next;
 }
      while (ivn.vn_next != 0);

      if (ivna.vna_other == vers_data)
 {
   *sym_info = symbol_undefined;
   *vna_other = ivna.vna_other;
   return (ivna.vna_name < strtab_size
    ? strtab + ivna.vna_name : gettext ("<corrupt>"));
 }
      else if ((max_vd_ndx || (vers_data & 0x7fff) != 1)
        && (vers_data & 0x7fff) > max_vd_ndx)
 return gettext ("<corrupt>");
    }
  return 
# 13215 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 13215 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}



static unsigned int
print_dynamic_symbol_size (uint64_t vma, int base)
{
  switch (base)
    {
    case 8:
      return print_vma (vma, OCTAL_5);

    case 10:
      return print_vma (vma, UNSIGNED_5);

    case 16:
      return print_vma (vma, PREFIX_HEX_5);

    case 0:
    default:
      return print_vma (vma, DEC_5);
    }
}

static void
print_dynamic_symbol (Filedata *filedata, uint64_t si,
        Elf_Internal_Sym *symtab,
        Elf_Internal_Shdr *section,
        char *strtab, size_t strtab_size)
{
  const char *version_string;
  enum versioned_symbol_info sym_info;
  unsigned short vna_other;
  
# 13249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 13249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      is_valid;
  const char * sstr;
  Elf_Internal_Sym *psym = symtab + si;

  printf ("%6" 
# 13253 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              "l" "d" 
# 13253 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ": ", si);
  print_vma (psym->st_value, LONG_HEX);
  putchar (' ');
  print_dynamic_symbol_size (psym->st_size, sym_base);
  printf (" %-7s", get_symbol_type (filedata, ((psym->st_info) & 0xF)));
  printf (" %-6s", get_symbol_binding (filedata, (((unsigned int)(psym->st_info)) >> 4)));
  if (filedata->file_header.e_ident[7] == 6)
    printf (" %-7s", get_solaris_symbol_visibility (psym->st_other));
  else
    {
      unsigned int vis = ((psym->st_other) & 0x3);

      printf (" %-7s", get_symbol_visibility (vis));



      if (psym->st_other ^ vis)
 printf (" [%s] ", get_symbol_other (filedata, psym->st_other ^ vis));
    }
  printf (" %4s ", get_symbol_index_type (filedata, psym->st_shndx));

  if (((psym->st_info) & 0xF) == 3
      && psym->st_shndx < filedata->file_header.e_shnum
      && filedata->section_headers != 
# 13276 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
      
# 13277 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     && psym->st_name == 0)
    {
      is_valid
 = section_name_valid (filedata,
         filedata->section_headers + psym->st_shndx);
      sstr = is_valid ?
 section_name_print (filedata,
       filedata->section_headers + psym->st_shndx)
 : gettext ("<corrupt>");
    }
  else
    {
      is_valid = valid_symbol_name (strtab, strtab_size, psym->st_name);
      sstr = is_valid ? strtab + psym->st_name : gettext ("<corrupt>");
    }

  version_string
    = get_symbol_version_string (filedata,
     (section == 
# 13295 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
      
# 13296 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     || section->sh_type == 11),
     strtab, strtab_size, si,
     psym, &sym_info, &vna_other);

  int len_avail = 21;
  if (! do_wide && version_string != 
# 13301 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    ((void *)0)
# 13301 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        )
    {
      char buffer[16];

      len_avail -= 1 + strlen (version_string);

      if (sym_info == symbol_undefined)
 len_avail -= sprintf (buffer," (%d)", vna_other);
      else if (sym_info != symbol_hidden)
 len_avail -= 1;
    }

  print_symbol (len_avail, sstr);

  if (version_string)
    {
      if (sym_info == symbol_undefined)
 printf ("@%s (%d)", version_string, vna_other);
      else
 printf (sym_info == symbol_hidden ? "@%s" : "@@%s",
  version_string);
    }

  putchar ('\n');

  if ((((unsigned int)(psym->st_info)) >> 4) == 0
      && section != 
# 13327 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
      
# 13328 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     && si >= section->sh_info

      && filedata->file_header.e_machine != 8


      && filedata->file_header.e_ident[7] != 6)
    warn (gettext ("local symbol %" 
# 13334 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "u" 
# 13334 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         " found at index >= %s's sh_info value of %u\n"),
   si, printable_section_name (filedata, section), section->sh_info);
}

static const char *
get_lto_kind (unsigned int kind)
{
  switch (kind)
    {
    case 0: return "DEF";
    case 1: return "WEAKDEF";
    case 2: return "UNDEF";
    case 3: return "WEAKUNDEF";
    case 4: return "COMMON";
    default:
      break;
    }

  static char buffer[30];
  error (gettext ("Unknown LTO symbol definition encountered: %u\n"), kind);
  sprintf (buffer, "<unknown: %u>", kind);
  return buffer;
}

static const char *
get_lto_visibility (unsigned int visibility)
{
  switch (visibility)
    {
    case 0: return "DEFAULT";
    case 1: return "PROTECTED";
    case 2: return "INTERNAL";
    case 3: return "HIDDEN";
    default:
      break;
    }

  static char buffer[30];
  error (gettext ("Unknown LTO symbol visibility encountered: %u\n"), visibility);
  sprintf (buffer, "<unknown: %u>", visibility);
  return buffer;
}

static const char *
get_lto_sym_type (unsigned int sym_type)
{
  switch (sym_type)
    {
    case 0: return "UNKNOWN";
    case 1: return "FUNCTION";
    case 2: return "VARIABLE";
    default:
      break;
    }

  static char buffer[30];
  error (gettext ("Unknown LTO symbol type encountered: %u\n"), sym_type);
  sprintf (buffer, "<unknown: %u>", sym_type);
  return buffer;
}





static 
# 13399 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 13400 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
display_lto_symtab (Filedata * filedata,
      Elf_Internal_Shdr * section)
{
  if (section->sh_size == 0)
    {
      if (filedata->is_separate)
 printf (gettext ("\nThe LTO Symbol table section '%s' in linked file '%s' is empty!\n"),
  printable_section_name (filedata, section),
  filedata->file_name);
      else
 printf (gettext ("\nLTO Symbol table '%s' is empty!\n"),
  printable_section_name (filedata, section));

      return 
# 13413 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 13413 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  if (section->sh_size > filedata->file_size)
    {
      error (gettext ("Section %s has an invalid sh_size of %#" 
# 13418 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 13418 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n"),
      printable_section_name (filedata, section),
      section->sh_size);
      return 
# 13421 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 13421 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  void * alloced_data = get_data (
# 13424 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 ((void *)0)
# 13424 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     , filedata, section->sh_offset,
      section->sh_size, 1, gettext ("LTO symbols"));
  if (alloced_data == 
# 13426 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 13426 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         )
    return 
# 13427 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 13427 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;


  Elf_Internal_Shdr * ext;
  void * ext_data_orig = 
# 13431 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 13431 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
  char * ext_data = 
# 13432 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 13432 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
  char * ext_data_end = 
# 13433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 13433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
  char * ext_name = 
# 13434 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 13434 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;

  if (asprintf (& ext_name, ".gnu.lto_.ext_symtab.%s",
  (section_name (filedata, section)
   + sizeof (".gnu.lto_.symtab.") - 1)) > 0
      && ext_name != 
# 13439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
      
# 13440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     && (ext = find_section (filedata, ext_name)) != 
# 13440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                     ((void *)0)
# 13440 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                         )
    {
      if (ext->sh_size < 3)
 error (gettext ("LTO Symbol extension table '%s' is empty!\n"),
        printable_section_name (filedata, ext));
      else
 {
   ext_data_orig = ext_data = get_data (
# 13447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       ((void *)0)
# 13447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           , filedata, ext->sh_offset,
            ext->sh_size, 1,
            gettext ("LTO ext symbol data"));
   if (ext_data != 
# 13450 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 13450 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
     {
       ext_data_end = ext_data + ext->sh_size;
       if (* ext_data++ != 1)
  error (gettext ("Unexpected version number in symbol extension table\n"));
     }
 }
    }

  const unsigned char * data = (const unsigned char *) alloced_data;
  const unsigned char * end = data + section->sh_size;

  if (filedata->is_separate)
    printf (gettext ("\nIn linked file '%s': "), filedata->file_name);
  else
    printf ("\n");

  if (ext_data_orig != 
# 13467 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 13467 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          )
    {
      if (do_wide)
 printf (gettext ("LTO Symbol table '%s' and extension table '%s' contain:\n"),
  printable_section_name (filedata, section),
  printable_section_name (filedata, ext));
      else
 {
   printf (gettext ("LTO Symbol table '%s'\n"),
    printable_section_name (filedata, section));
   printf (gettext (" and extension table '%s' contain:\n"),
    printable_section_name (filedata, ext));
 }
    }
  else
    printf (gettext ("LTO Symbol table '%s' contains:\n"),
     printable_section_name (filedata, section));


  if (ext_data_orig != 
# 13486 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 13486 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          )
    printf (gettext ("  Comdat_Key       Kind  Visibility     Size      Slot      Type  Section Name\n"));
  else
    printf (gettext ("  Comdat_Key       Kind  Visibility     Size      Slot Name\n"));



  while (data < end)
    {
      const unsigned char * sym_name = data;
      data += strnlen ((const char *) sym_name, end - data) + 1;
      if (data >= end)
 goto fail;

      const unsigned char * comdat_key = data;
      data += strnlen ((const char *) comdat_key, end - data) + 1;
      if (data >= end)
 goto fail;

      if (data + 2 + 8 + 4 > end)
 goto fail;

      unsigned int kind = *data++;
      unsigned int visibility = *data++;

      uint64_t size = byte_get (data, 8);
      data += 8;

      uint64_t slot = byte_get (data, 4);
      data += 4;

      if (ext_data != 
# 13517 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 13517 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         )
 {
   if (ext_data < (ext_data_end - 1))
     {
       unsigned int sym_type = * ext_data ++;
       unsigned int sec_kind = * ext_data ++;

       printf ("  %10s %10s %11s %08" 
# 13524 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     "l" "x" 
# 13524 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                            "  %08" 
# 13524 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                    "l" "x" 
# 13524 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                           " %9s %08x _",
        * comdat_key == 0 ? "-" : (char *) comdat_key,
        get_lto_kind (kind),
        get_lto_visibility (visibility),
        size,
        slot,
        get_lto_sym_type (sym_type),
        sec_kind);
       print_symbol (6, (const char *) sym_name);
     }
   else
     {
       error (gettext ("Ran out of LTO symbol extension data\n"));
       ext_data = 
# 13537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 13537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;

     }
 }
      else
 {
   printf ("  %10s %10s %11s %08" 
# 13543 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 "l" "x" 
# 13543 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        "  %08" 
# 13543 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                "l" "x" 
# 13543 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                       " _",
    * comdat_key == 0 ? "-" : (char *) comdat_key,
    get_lto_kind (kind),
    get_lto_visibility (visibility),
    size,
    slot);
   print_symbol (21, (const char *) sym_name);
 }
      putchar ('\n');
    }

  if (ext_data != 
# 13554 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0) 
# 13554 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      && ext_data < ext_data_end)
    {
      error (gettext ("Data remains in the LTO symbol extension table\n"));
      goto fail;
    }

  free (alloced_data);
  free (ext_data_orig);
  free (ext_name);
  return 
# 13563 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 13563 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

 fail:
  error (gettext ("Buffer overrun encountered whilst decoding LTO symbol table\n"));
  free (alloced_data);
  free (ext_data_orig);
  free (ext_name);
  return 
# 13570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 13570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}



static 
# 13575 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 13576 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_lto_symbol_tables (Filedata * filedata)
{
  Elf_Internal_Shdr * section;
  unsigned int i;
  
# 13580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 13580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 13580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 13580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (!do_lto_syms)
    return 
# 13583 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 13583 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (filedata->section_headers == 
# 13585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 13585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    return 
# 13586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 13586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  for (i = 0, section = filedata->section_headers;
       i < filedata->file_header.e_shnum;
       i++, section++)
    if (section_name_valid (filedata, section)
 && startswith (section_name (filedata, section), ".gnu.lto_.symtab."))
      res &= display_lto_symtab (filedata, section);

  return res;
}



static 
# 13600 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 13601 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_symbol_table (Filedata * filedata)
{
  Elf_Internal_Shdr * section;

  if (!do_syms && !do_dyn_syms && !do_histogram)
    return 
# 13606 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 13606 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if ((filedata->dynamic_info[4] || filedata->dynamic_info_DT_GNU_HASH)
      && do_syms
      && do_using_dynamic
      && filedata->dynamic_strings != 
# 13611 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
      
# 13612 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     && filedata->dynamic_symbols != 
# 13612 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
# 13612 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         )
    {
      uint64_t si;

      if (filedata->is_separate)
 {
   printf (ngettext ("\nIn linked file '%s' the dynamic symbol table"
       " contains %" 
# 13619 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    "l" "u" 
# 13619 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           " entry:\n",
       "\nIn linked file '%s' the dynamic symbol table"
       " contains %" 
# 13621 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    "l" "u" 
# 13621 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           " entries:\n",
       filedata->num_dynamic_syms),
    filedata->file_name,
    filedata->num_dynamic_syms);
 }
      else
 {
   printf (ngettext ("\nSymbol table for image contains %" 
# 13628 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                          "l" "u"
       
# 13629 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      " entry:\n",
       "\nSymbol table for image contains %" 
# 13630 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                            "l" "u"
       
# 13631 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      " entries:\n",
       filedata->num_dynamic_syms),
    filedata->num_dynamic_syms);
 }
      if (is_32bit_elf)
 printf (gettext ("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"));
      else
 printf (gettext ("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"));

      for (si = 0; si < filedata->num_dynamic_syms; si++)
 print_dynamic_symbol (filedata, si, filedata->dynamic_symbols, 
# 13641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                               ((void *)0)
# 13641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                   ,
         filedata->dynamic_strings,
         filedata->dynamic_strings_length);
    }
  else if ((do_dyn_syms || (do_syms && !do_using_dynamic))
    && filedata->section_headers != 
# 13646 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   ((void *)0)
# 13646 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       )
    {
      unsigned int i;

      for (i = 0, section = filedata->section_headers;
    i < filedata->file_header.e_shnum;
    i++, section++)
 {
   char * strtab = 
# 13654 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 13654 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;
   uint64_t strtab_size = 0;
   Elf_Internal_Sym * symtab;
   uint64_t si, num_syms;

   if ((section->sh_type != 2
        && section->sh_type != 11)
       || (!do_syms
    && section->sh_type == 2))
     continue;

   if (section->sh_entsize == 0)
     {
       printf (gettext ("\nSymbol table '%s' has a sh_entsize of zero!\n"),
        printable_section_name (filedata, section));
       continue;
     }

   num_syms = section->sh_size / section->sh_entsize;

   if (filedata->is_separate)
     printf (ngettext ("\nIn linked file '%s' symbol section '%s'"
         " contains %" 
# 13676 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      "l" "u" 
# 13676 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             " entry:\n",
         "\nIn linked file '%s' symbol section '%s'"
         " contains %" 
# 13678 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      "l" "u" 
# 13678 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             " entries:\n",
         num_syms),
      filedata->file_name,
      printable_section_name (filedata, section),
      num_syms);
   else
     printf (ngettext ("\nSymbol table '%s' contains %" 
# 13684 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                       "l" "u"
         
# 13685 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        " entry:\n",
         "\nSymbol table '%s' contains %" 
# 13686 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         "l" "u"
         
# 13687 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        " entries:\n",
         num_syms),
      printable_section_name (filedata, section),
      num_syms);

   if (is_32bit_elf)
     printf (gettext ("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"));
   else
     printf (gettext ("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"));

   symtab = get_elf_symbols (filedata, section, & num_syms);
   if (symtab == 
# 13698 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 13698 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
     continue;

   if (section->sh_link == filedata->file_header.e_shstrndx)
     {
       strtab = filedata->string_table;
       strtab_size = filedata->string_table_length;
     }
   else if (section->sh_link < filedata->file_header.e_shnum)
     {
       Elf_Internal_Shdr * string_sec;

       string_sec = filedata->section_headers + section->sh_link;

       strtab = (char *) get_data (
# 13712 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 13712 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      , filedata, string_sec->sh_offset,
                                          1, string_sec->sh_size,
                                          gettext ("string table"));
       strtab_size = strtab != 
# 13715 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0) 
# 13715 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ? string_sec->sh_size : 0;
     }

   for (si = 0; si < num_syms; si++)
     print_dynamic_symbol (filedata, si, symtab, section,
      strtab, strtab_size);

   free (symtab);
   if (strtab != filedata->string_table)
     free (strtab);
 }
    }
  else if (do_syms)
    printf
      (gettext ("\nDynamic symbol information is not available for displaying symbols.\n"));

  if (do_histogram && filedata->buckets != 
# 13731 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
# 13731 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              )
    {
      uint64_t *lengths;
      uint64_t *counts;
      uint64_t hn;
      uint64_t si;
      uint64_t maxlength = 0;
      uint64_t nzero_counts = 0;
      uint64_t nsyms = 0;
      char *visited;

      printf (ngettext ("\nHistogram for bucket list length "
   "(total of %" 
# 13743 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                "l" "u" 
# 13743 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       " bucket):\n",
   "\nHistogram for bucket list length "
   "(total of %" 
# 13745 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                "l" "u" 
# 13745 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       " buckets):\n",
   filedata->nbuckets),
       filedata->nbuckets);

      lengths = calloc (filedata->nbuckets, sizeof (*lengths));
      if (lengths == 
# 13750 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 13750 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        )
 {
   error (gettext ("Out of memory allocating space for histogram buckets\n"));
   goto err_out;
 }
      visited = xcmalloc (filedata->nchains, 1);
      memset (visited, 0, filedata->nchains);

      printf (gettext (" Length  Number     %% of total  Coverage\n"));
      for (hn = 0; hn < filedata->nbuckets; ++hn)
 {
   for (si = filedata->buckets[hn]; si > 0; si = filedata->chains[si])
     {
       ++nsyms;
       if (maxlength < ++lengths[hn])
  ++maxlength;
       if (si >= filedata->nchains || visited[si])
  {
    error (gettext ("histogram chain is corrupt\n"));
    break;
  }
       visited[si] = 1;
     }
 }
      free (visited);

      counts = calloc (maxlength + 1, sizeof (*counts));
      if (counts == 
# 13777 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 13777 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       )
 {
   free (lengths);
   error (gettext ("Out of memory allocating space for histogram counts\n"));
   goto err_out;
 }

      for (hn = 0; hn < filedata->nbuckets; ++hn)
 ++counts[lengths[hn]];

      if (filedata->nbuckets > 0)
 {
   uint64_t i;
   printf ("      0  %-10" 
# 13790 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          "l" "u" 
# 13790 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 " (%5.1f%%)\n",
    counts[0], (counts[0] * 100.0) / filedata->nbuckets);
   for (i = 1; i <= maxlength; ++i)
     {
       nzero_counts += counts[i] * i;
       printf ("%7" 
# 13795 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   "l" "u" 
# 13795 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          "  %-10" 
# 13795 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   "l" "u" 
# 13795 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          " (%5.1f%%)    %5.1f%%\n",
        i, counts[i], (counts[i] * 100.0) / filedata->nbuckets,
        (nzero_counts * 100.0) / nsyms);
     }
 }

      free (counts);
      free (lengths);
    }

  free (filedata->buckets);
  filedata->buckets = 
# 13806 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 13806 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
  filedata->nbuckets = 0;
  free (filedata->chains);
  filedata->chains = 
# 13809 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 13809 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;

  if (do_histogram && filedata->gnubuckets != 
# 13811 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             ((void *)0)
# 13811 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                 )
    {
      uint64_t *lengths;
      uint64_t *counts;
      uint64_t hn;
      uint64_t maxlength = 0;
      uint64_t nzero_counts = 0;
      uint64_t nsyms = 0;

      printf (ngettext ("\nHistogram for `%s' bucket list length "
   "(total of %" 
# 13821 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                "l" "u" 
# 13821 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       " bucket):\n",
   "\nHistogram for `%s' bucket list length "
   "(total of %" 
# 13823 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                "l" "u" 
# 13823 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       " buckets):\n",
   filedata->ngnubuckets),
       filedata->dynamic_info_DT_MIPS_XHASH ? ".MIPS.xhash" : ".gnu.hash",
       filedata->ngnubuckets);

      lengths = calloc (filedata->ngnubuckets, sizeof (*lengths));
      if (lengths == 
# 13829 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 13829 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        )
 {
   error (gettext ("Out of memory allocating space for gnu histogram buckets\n"));
   goto err_out;
 }

      printf (gettext (" Length  Number     %% of total  Coverage\n"));

      for (hn = 0; hn < filedata->ngnubuckets; ++hn)
 if (filedata->gnubuckets[hn] != 0)
   {
     uint64_t off, length = 1;

     for (off = filedata->gnubuckets[hn] - filedata->gnusymidx;

   off < filedata->ngnuchains
     && (filedata->gnuchains[off] & 1) == 0;
   ++off)
       ++length;
     lengths[hn] = length;
     if (length > maxlength)
       maxlength = length;
     nsyms += length;
   }

      counts = calloc (maxlength + 1, sizeof (*counts));
      if (counts == 
# 13855 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 13855 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       )
 {
   free (lengths);
   error (gettext ("Out of memory allocating space for gnu histogram counts\n"));
   goto err_out;
 }

      for (hn = 0; hn < filedata->ngnubuckets; ++hn)
 ++counts[lengths[hn]];

      if (filedata->ngnubuckets > 0)
 {
   uint64_t j;
   printf ("      0  %-10" 
# 13868 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          "l" "u" 
# 13868 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 " (%5.1f%%)\n",
    counts[0], (counts[0] * 100.0) / filedata->ngnubuckets);
   for (j = 1; j <= maxlength; ++j)
     {
       nzero_counts += counts[j] * j;
       printf ("%7" 
# 13873 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   "l" "u" 
# 13873 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          "  %-10" 
# 13873 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   "l" "u" 
# 13873 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          " (%5.1f%%)    %5.1f%%\n",
        j, counts[j], (counts[j] * 100.0) / filedata->ngnubuckets,
        (nzero_counts * 100.0) / nsyms);
     }
 }

      free (counts);
      free (lengths);
    }
  free (filedata->gnubuckets);
  filedata->gnubuckets = 
# 13883 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 13883 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
  filedata->ngnubuckets = 0;
  free (filedata->gnuchains);
  filedata->gnuchains = 
# 13886 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 13886 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
  filedata->ngnuchains = 0;
  free (filedata->mipsxlat);
  filedata->mipsxlat = 
# 13889 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 13889 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
  return 
# 13890 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 13890 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

 err_out:
  free (filedata->gnubuckets);
  filedata->gnubuckets = 
# 13894 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 13894 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
  filedata->ngnubuckets = 0;
  free (filedata->gnuchains);
  filedata->gnuchains = 
# 13897 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 13897 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
  filedata->ngnuchains = 0;
  free (filedata->mipsxlat);
  filedata->mipsxlat = 
# 13900 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 13900 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
  free (filedata->buckets);
  filedata->buckets = 
# 13902 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 13902 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;
  filedata->nbuckets = 0;
  free (filedata->chains);
  filedata->chains = 
# 13905 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 13905 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;
  return 
# 13906 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 13906 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}

static 
# 13909 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 13910 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_syminfo (Filedata * filedata)
{
  unsigned int i;

  if (filedata->dynamic_syminfo == 
# 13914 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
      
# 13915 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     || !do_dynamic)

    return 
# 13917 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 13917 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;


  if (filedata->dynamic_symbols == 
# 13920 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0) 
# 13920 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       || filedata->dynamic_strings == 
# 13920 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                       ((void *)0)
# 13920 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                           )
    return 
# 13921 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 13921 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (filedata->is_separate)
    printf (ngettext ("\nIn linked file '%s: the dynamic info segment at offset %#" 
# 13924 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                                   "l" "x" 
# 13924 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                          " contains %d entry:\n",
        "\nIn linked file '%s: the dynamic info segment at offset %#" 
# 13925 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                     "l" "x" 
# 13925 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                            " contains %d entries:\n",
        filedata->dynamic_syminfo_nent),
     filedata->file_name,
     filedata->dynamic_syminfo_offset,
     filedata->dynamic_syminfo_nent);
  else
    printf (ngettext ("\nDynamic info segment at offset %#" 
# 13931 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                           "l" "x"
        
# 13932 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       " contains %d entry:\n",
        "\nDynamic info segment at offset %#" 
# 13933 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             "l" "x"
        
# 13934 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       " contains %d entries:\n",
        filedata->dynamic_syminfo_nent),
     filedata->dynamic_syminfo_offset,
     filedata->dynamic_syminfo_nent);

  printf (gettext (" Num: Name                           BoundTo     Flags\n"));
  for (i = 0; i < filedata->dynamic_syminfo_nent; ++i)
    {
      unsigned short int flags = filedata->dynamic_syminfo[i].si_flags;

      printf ("%4d: ", i);
      if (i >= filedata->num_dynamic_syms)
 printf (gettext ("<corrupt index>"));
      else if (valid_dynamic_name (filedata, filedata->dynamic_symbols[i].st_name))
 print_symbol (30, get_dynamic_name (filedata,
         filedata->dynamic_symbols[i].st_name));
      else
 printf (gettext ("<corrupt: %19ld>"), filedata->dynamic_symbols[i].st_name);
      putchar (' ');

      switch (filedata->dynamic_syminfo[i].si_boundto)
 {
 case 0xffff:
   fputs ("SELF       ", 
# 13957 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        stdout
# 13957 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              );
   break;
 case 0xfffe:
   fputs ("PARENT     ", 
# 13960 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        stdout
# 13960 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              );
   break;
 default:
   if (filedata->dynamic_syminfo[i].si_boundto > 0
       && filedata->dynamic_syminfo[i].si_boundto < filedata->dynamic_nent
       && valid_dynamic_name (filedata,
         filedata->dynamic_section[filedata->dynamic_syminfo[i].si_boundto].d_un.d_val))
     {
       print_symbol (10, get_dynamic_name (filedata,
        filedata->dynamic_section[filedata->dynamic_syminfo[i].si_boundto].d_un.d_val));
       putchar (' ' );
     }
   else
     printf ("%-10d ", filedata->dynamic_syminfo[i].si_boundto);
   break;
 }

      if (flags & 0x0001)
 printf (" DIRECT");
      if (flags & 0x0002)
 printf (" PASSTHRU");
      if (flags & 0x0004)
 printf (" COPY");
      if (flags & 0x0008)
 printf (" LAZYLOAD");

      puts ("");
    }

  return 
# 13989 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 13989 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}
# 14007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static 
# 14007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14008 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
target_specific_reloc_handling (Filedata *filedata,
    Elf_Internal_Rela *reloc,
    unsigned char *start,
    unsigned char *end,
    Elf_Internal_Sym *symtab,
    uint64_t num_syms)
{
  unsigned int reloc_type = 0;
  uint64_t sym_index = 0;

  if (reloc)
    {
      reloc_type = get_reloc_type (filedata, reloc->r_info);
      sym_index = get_reloc_symindex (reloc->r_info);
    }

  switch (filedata->file_header.e_machine)
    {
    case 258:
      {
 switch (reloc_type)
   {


     case 107:
     case 108:
       {
  uint64_t value = 0;
  unsigned int reloc_size = 0;
  int leb_ret = 0;

  if (reloc->r_offset < (size_t) (end - start))
    value = read_leb128 (start + reloc->r_offset, end, 
# 14040 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                      0
# 14040 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                           ,
           &reloc_size, &leb_ret);
  if (leb_ret != 0 || reloc_size == 0 || reloc_size > 8)
    error (gettext ("LoongArch ULEB128 field at 0x%lx contains invalid " "ULEB128 value\n")
                        ,
    (long) reloc->r_offset);

  else if (sym_index >= num_syms)
    error (gettext ("%s reloc contains invalid symbol index " "%" 
# 14048 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "u" 
# 14048 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          "\n")
                      ,
    (reloc_type == 107
     ? "R_LARCH_ADD_ULEB128"
     : "R_LARCH_SUB_ULEB128"),
    sym_index);
  else
    {
      if (reloc_type == 107)
        value += reloc->r_addend + symtab[sym_index].st_value;
      else
        value -= reloc->r_addend + symtab[sym_index].st_value;


      bfd_byte *p = start + reloc->r_offset;
      do
        {
   bfd_byte c = value & 0x7f;
   value >>= 7;
   if (--reloc_size != 0)
     c |= 0x80;
   *p++ = c;
        }
      while (reloc_size);
    }

  return 
# 14074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 14074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       }
   }
 break;
      }

    case 105:
    case 0x1059:
      {
 static Elf_Internal_Sym * saved_sym = 
# 14083 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 14083 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ;

 if (reloc == 
# 14085 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 14085 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 )
   {
     saved_sym = 
# 14087 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 14087 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
     return 
# 14088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   }

 switch (reloc_type)
   {
   case 10:
   case 12:
     if (uses_msp430x_relocs (filedata))
       break;

   case 21:
   case 23:

     if (sym_index >= num_syms)
       error (gettext ("%s reloc contains invalid symbol index " "%" 
# 14102 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "u" 
# 14102 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             "\n")
                         , "MSP430 SYM_DIFF", sym_index);
     else
       saved_sym = symtab + sym_index;
     return 
# 14106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

   case 1:
   case 3:
     goto handle_sym_diff;

   case 5:
   case 9:
   case 11:
     if (uses_msp430x_relocs (filedata))
       break;
     goto handle_sym_diff;

   case 2:
   case 15:
   case 22:
     if (! uses_msp430x_relocs (filedata))
       break;
     goto handle_sym_diff;

   handle_sym_diff:
     if (saved_sym != 
# 14127 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 14127 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         )
       {
  uint64_t value;
  unsigned int reloc_size = 0;
  int leb_ret = 0;
  switch (reloc_type)
    {
    case 1:
      reloc_size = 4;
      break;
    case 11:
    case 22:
      if (reloc->r_offset < (size_t) (end - start))
        read_leb128 (start + reloc->r_offset, end, 
# 14140 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                  0
# 14140 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                       ,
       &reloc_size, &leb_ret);
      break;
    default:
      reloc_size = 2;
      break;
    }

  if (leb_ret != 0 || reloc_size == 0 || reloc_size > 8)
    error (gettext ("MSP430 ULEB128 field at %#" 
# 14149 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "x" 
# 14149 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          " contains invalid ULEB128 value\n")
                                          ,
    reloc->r_offset);
  else if (sym_index >= num_syms)
    error (gettext ("%s reloc contains invalid symbol index " "%" 
# 14153 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "u" 
# 14153 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          "\n")
                      , "MSP430", sym_index);
  else
    {
      value = reloc->r_addend + (symtab[sym_index].st_value
            - saved_sym->st_value);

      if ((((start + reloc->r_offset) >= (start)) && ((start + reloc->r_offset) < (end)) && ((start + reloc->r_offset) + (reloc_size) <= (end))))
        byte_put (start + reloc->r_offset, value, reloc_size);
      else

        error (gettext ("MSP430 sym diff reloc contains invalid offset: " "%#" 
# 14164 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              "l" "x" 
# 14164 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              "\n")
                           ,
        reloc->r_offset);
    }

  saved_sym = 
# 14169 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 14169 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
  return 
# 14170 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 14170 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       }
     break;

   default:
     if (saved_sym != 
# 14175 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 14175 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         )
       error (gettext ("Unhandled MSP430 reloc type found after SYM_DIFF reloc\n"));
     break;
   }
 break;
      }

    case 89:
    case 0xbeef:
      {
 static Elf_Internal_Sym * saved_sym = 
# 14185 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 14185 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ;

 if (reloc == 
# 14187 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 14187 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 )
   {
     saved_sym = 
# 14189 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 14189 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;
     return 
# 14190 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14190 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   }

 switch (reloc_type)
   {
   case 34:
     return 
# 14196 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14196 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   case 33:
     if (sym_index >= num_syms)
       error (gettext ("%s reloc contains invalid symbol index " "%" 
# 14199 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "u" 
# 14199 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             "\n")
                         , "MN10300_SYM_DIFF", sym_index);
     else
       saved_sym = symtab + sym_index;
     return 
# 14203 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14203 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

   case 1:
   case 2:
     if (saved_sym != 
# 14207 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 14207 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         )
       {
  int reloc_size = reloc_type == 1 ? 4 : 2;
  uint64_t value;

  if (sym_index >= num_syms)
    error (gettext ("%s reloc contains invalid symbol index " "%" 
# 14213 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "u" 
# 14213 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          "\n")
                      , "MN10300", sym_index);
  else
    {
      value = reloc->r_addend + (symtab[sym_index].st_value
            - saved_sym->st_value);

      if ((((start + reloc->r_offset) >= (start)) && ((start + reloc->r_offset) < (end)) && ((start + reloc->r_offset) + (reloc_size) <= (end))))
        byte_put (start + reloc->r_offset, value, reloc_size);
      else
        error (gettext ("MN10300 sym diff reloc contains invalid offset:" " %#" 
# 14223 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              "l" "x" 
# 14223 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              "\n")
                            ,
        reloc->r_offset);
    }

  saved_sym = 
# 14228 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 14228 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
  return 
# 14229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 14229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       }
     break;
   default:
     if (saved_sym != 
# 14233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 14233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         )
       error (gettext ("Unhandled MN10300 reloc type found after SYM_DIFF reloc\n"));
     break;
   }
 break;
      }

    case 197:
      {
 static uint64_t saved_sym1 = 0;
 static uint64_t saved_sym2 = 0;
 static uint64_t value;

 if (reloc == 
# 14246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 14246 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 )
   {
     saved_sym1 = saved_sym2 = 0;
     return 
# 14249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   }

 switch (reloc_type)
   {
   case 0x80:
     saved_sym1 = saved_sym2;
     if (sym_index >= num_syms)
       error (gettext ("%s reloc contains invalid symbol index " "%" 
# 14257 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "u" 
# 14257 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             "\n")
                         , "RL78_SYM", sym_index);
     else
       {
  saved_sym2 = symtab[sym_index].st_value;
  saved_sym2 += reloc->r_addend;
       }
     return 
# 14264 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14264 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

   case 0x83:
     value = saved_sym1 - saved_sym2;
     saved_sym2 = saved_sym1 = 0;
     return 
# 14269 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14269 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
     break;

   case 0x41:
     if ((((start + reloc->r_offset) >= (start)) && ((start + reloc->r_offset) < (end)) && ((start + reloc->r_offset) + (4) <= (end))))
       byte_put (start + reloc->r_offset, value, 4);
     else
       error (gettext ("RL78 sym diff reloc contains invalid offset: " "%#" 
# 14276 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "x" 
# 14276 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             "\n")
                          ,
       reloc->r_offset);
     value = 0;
     return 
# 14280 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14280 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

   case 0x43:
     if ((((start + reloc->r_offset) >= (start)) && ((start + reloc->r_offset) < (end)) && ((start + reloc->r_offset) + (2) <= (end))))
       byte_put (start + reloc->r_offset, value, 2);
     else
       error (gettext ("RL78 sym diff reloc contains invalid offset: " "%#" 
# 14286 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "x" 
# 14286 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             "\n")
                          ,
       reloc->r_offset);
     value = 0;
     return 
# 14290 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 14290 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

   default:
     break;
   }
 break;
      }
    }

  return 
# 14299 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 14299 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}
# 14313 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static 
# 14313 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14314 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_32bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 3:
    case 6:
      return reloc_type == 1;
    case 4:
      return reloc_type == 1;
    case 7:
      return reloc_type == 1;
    case 19:
      return reloc_type == 2;
    case 183:
      return (reloc_type == 258
       || reloc_type == 1);
    case 247:
      return reloc_type == 11;
    case 0x1223:
      return reloc_type == 3;
    case 0x9026:
      return reloc_type == 1;
    case 45:
      return reloc_type == 1;
    case 93:
    case 195:
    case 255:
    case 253:
      return reloc_type == 4;
    case 40:
      return reloc_type == 2;
    case 0x1057:
    case 83:
      return reloc_type == 1;
    case 106:
      return reloc_type == 0x12;
    case 76:
      return reloc_type == 3;
    case 177:
      return reloc_type == 3;
    case 114:
      return reloc_type == 15;
    case 252:
      return reloc_type == 1;
    case 0x5441:
      return reloc_type == 1;
    case 0x7650:
    case 85:
      return reloc_type == 6;
    case 0x7676:
    case 86:
      return reloc_type == 12;
    case 0x5aa5:
      return reloc_type == 3;
    case 0x3330:
    case 84:
      return reloc_type == 3;
    case 222:
      return reloc_type == 1;
    case 48:
    case 46:
    case 47:
      return reloc_type == 1;
    case 50:
      return (reloc_type == 0x64
       || reloc_type == 0x65
       || reloc_type == 0x24
       || reloc_type == 0x25 );
    case 0x8217:
    case 101:
      return reloc_type == 2;
    case 0xFEBA:
      return reloc_type == 2;
    case 138:
      return reloc_type == 3;
    case 258:
      return reloc_type == 1;
    case 0xFEB0:
    case 120:
      return reloc_type == 3;
    case 88:
      return reloc_type == 34;
    case 70:
    case 53:
      return reloc_type == 6;
    case 0x4DEF:
      return reloc_type == 7 ||
 reloc_type == 6;
    case 39:
      return reloc_type == 1;
    case 0xF00D:
      return reloc_type == 4;
    case 174:
      return reloc_type == 2;
    case 189:
      return reloc_type == 1;
    case 8:
      return reloc_type == 2;
    case 80:
      return reloc_type == 4;
    case 0xdead:
    case 90:
      return reloc_type == 1;
    case 0xbeef:
    case 89:
      return reloc_type == 1;
    case 223:
      return reloc_type == 1;
    case 0x1059:
    case 105:
      return reloc_type == 1;
    case 0x2530:
      return reloc_type == 2;
    case 167:
      return reloc_type == 20;
    case 113:
      return reloc_type == 12;
    case 0xFEBB:
      return reloc_type == 1;
    case 92:
      return reloc_type == 1;
    case 15:
      return (reloc_type == 1
       || reloc_type == 2
       || reloc_type == 41);
    case 91:
    case 99:
      return reloc_type == 1;
    case 21:
      return reloc_type == 1;
    case 20:
      return reloc_type == 1;
    case 144:
      return reloc_type == 11;
    case 243:
      return reloc_type == 1;
    case 197:
      return reloc_type == 1;
    case 173:
      return reloc_type == 1;
    case 9:
      return reloc_type == 1;
    case 0xa390:
    case 22:
      return reloc_type == 4;
    case 135:
      return reloc_type == 8;
    case 42:
      return reloc_type == 1;
    case 18:
    case 43:
    case 2:
      return reloc_type == 3
 || reloc_type == 23;
    case 23:
      return reloc_type == 6;
    case 140:
      return reloc_type == 1;
    case 191:
      return reloc_type == 2;
    case 188:
      return reloc_type == 1;
    case 0x9080:
    case 87:
      return reloc_type == 6;
    case 36:
      return reloc_type == 0x33;
    case 75:
      return reloc_type == 1;
    case 221:
      return reloc_type == 3;
    case 0x4157:
      return reloc_type == 1;
    case 62:
    case 180:
    case 181:
      return reloc_type == 10;
    case 115:
      return reloc_type == 4;
    case 0xad45:
      return reloc_type == 1;
    case 0xabc7:
    case 94:
      return reloc_type == 1;
    case 220:
      return reloc_type == 6;
    default:
      {
 static unsigned int prev_warn = 0;


 if (prev_warn != filedata->file_header.e_machine)
   error (gettext ("Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n"),
   filedata->file_header.e_machine);
 prev_warn = filedata->file_header.e_machine;
 return 
# 14510 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 14510 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
      }
    }
}




static 
# 14518 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14519 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_32bit_pcrel_reloc (Filedata * filedata, unsigned int reloc_type)
{
  switch (filedata->file_header.e_machine)

    {
    case 3:
    case 6:
      return reloc_type == 2;
    case 4:
      return reloc_type == 4;
    case 183:
      return reloc_type == 261;
    case 0x1223:
      return reloc_type == 6;
    case 0x9026:
      return reloc_type == 10;
    case 93:
    case 195:
    case 255:
    case 253:
      return reloc_type == 49;
    case 40:
      return reloc_type == 3;
    case 0x1057:
    case 83:
      return reloc_type == 36;
    case 258:
      return reloc_type == 99;
    case 189:
      return reloc_type == 2;
    case 92:
      return reloc_type == 9;
    case 15:
      return reloc_type == 9;
    case 20:
      return reloc_type == 26;
    case 21:
      return reloc_type == 26;
    case 243:
      return reloc_type == 57;
    case 0xa390:
    case 22:
      return reloc_type == 5;
    case 42:
      return reloc_type == 2;
    case 18:
    case 43:
    case 2:
      return reloc_type == 6;
    case 23:
      return reloc_type == 13;
    case 191:
      return reloc_type == 6;
    case 188:
      return reloc_type == 4;
    case 221:
      return reloc_type == 6;
    case 62:
    case 180:
    case 181:
      return reloc_type == 2;
    case 75:
      return reloc_type == 4;
    case 0xabc7:
    case 94:
      return reloc_type == 14;
    default:





      return 
# 14591 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14591 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14598 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14599 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_64bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
{
  switch (filedata->file_header.e_machine)
    {
    case 183:
      return reloc_type == 257;
    case 253:
      return reloc_type == 5;
    case 0x9026:
      return reloc_type == 2;
    case 50:
      return (reloc_type == 0x26
       || reloc_type == 0x27 );
    case 258:
      return reloc_type == 2;
    case 15:
      return reloc_type == 80;
    case 21:
      return reloc_type == 38;
    case 243:
      return reloc_type == 2;
    case 18:
    case 43:
    case 2:
      return reloc_type == 32
 || reloc_type == 54;
    case 62:
    case 180:
    case 181:
      return reloc_type == 1;
    case 0xa390:
    case 22:
      return reloc_type == 22;
    case 191:
      return reloc_type == 1;
    case 8:
      return reloc_type == 18;
    default:
      return 
# 14637 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14637 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14644 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14645 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_64bit_pcrel_reloc (Filedata * filedata, unsigned int reloc_type)
{
  switch (filedata->file_header.e_machine)
    {
    case 183:
      return reloc_type == 260;
    case 0x9026:
      return reloc_type == 11;
    case 50:
      return (reloc_type == 0x4e
       || reloc_type == 0x4f );
    case 15:
      return reloc_type == 72;
    case 21:
      return reloc_type == 44;
    case 18:
    case 43:
    case 2:
      return reloc_type == 46;
    case 62:
    case 180:
    case 181:
      return reloc_type == 24;
    case 0xa390:
    case 22:
      return reloc_type == 23;
    case 191:
      return reloc_type == 5;
    default:
      return 
# 14674 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14674 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14681 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14682 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_24bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
{
  switch (filedata->file_header.e_machine)
    {
    case 0xdead:
    case 90:
      return reloc_type == 4;
    case 222:
      return reloc_type == 5;
    case 220:
      return reloc_type == 5;
    default:
      return 
# 14694 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14694 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14701 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14702 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_16bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 45:
    case 93:
    case 195:
    case 255:
    case 253:
      return reloc_type == 2;
    case 0x1223:
      return reloc_type == 5;
    case 0x1057:
    case 83:
      return reloc_type == 4;
    case 0x7650:
    case 85:
      return reloc_type == 3;
    case 222:
      return reloc_type == 2;
    case 48:
    case 46:
    case 47:
      return reloc_type == R_H8_DIR16;
    case 0x8217:
    case 101:
      return reloc_type == 1;
    case 0xFEB0:
    case 120:
      return reloc_type == 1;
    case 0xdead:
    case 90:
      return reloc_type == 2;
    case 0xbeef:
    case 89:
      return reloc_type == 2;
    case 105:
      if (uses_msp430x_relocs (filedata))
 return reloc_type == 2;

    case 0x1059:
      return reloc_type == 5;
    case 167:
      return reloc_type == 19;
    case 113:
      return reloc_type == 13;
    case 0xFEBB:
      return reloc_type == 9;
    case 92:
      return reloc_type == 2;
    case 243:
      return reloc_type == 55;
    case 144:
      return reloc_type == 8;
    case 140:
      return reloc_type == 2;
    case 221:
      return reloc_type == 2;
    case 115:
      return reloc_type == 3;
    case 220:
      return reloc_type == 4;
    default:
      return 
# 14766 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14766 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14773 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14774 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_8bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
{
  switch (filedata->file_header.e_machine)
    {
    case 243:
      return reloc_type == 54;
    case 220:
      return reloc_type == 1;
    default:
      return 
# 14783 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14783 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14790 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14791 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_6bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
{
  switch (filedata->file_header.e_machine)
    {
    case 243:
      return reloc_type == 53;
    default:
      return 
# 14798 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14798 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14805 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14806 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_32bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 50;
    case 243:
      return reloc_type == 35;
    default:
      return 
# 14816 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14816 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14823 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14824 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_32bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 55;
    case 243:
      return reloc_type == 39;
    default:
      return 
# 14834 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14834 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14841 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14842 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_64bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 51;
    case 243:
      return reloc_type == 36;
    default:
      return 
# 14852 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14852 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14859 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14860 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_64bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 56;
    case 243:
      return reloc_type == 40;
    default:
      return 
# 14870 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14870 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14877 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14878 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_16bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 48;
    case 243:
      return reloc_type == 34;
    default:
      return 
# 14888 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14888 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14895 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14896 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_16bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 53;
    case 243:
      return reloc_type == 38;
    default:
      return 
# 14906 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14906 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14913 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14914 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_8bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 47;
    case 243:
      return reloc_type == 33;
    default:
      return 
# 14924 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14924 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14931 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14932 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_8bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
{

  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 52;
    case 243:
      return reloc_type == 37;
    default:
      return 
# 14942 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14942 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14949 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14950 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_6bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
{
  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 105;
    default:
      return 
# 14957 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14957 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14964 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14965 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_6bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
{
  switch (filedata->file_header.e_machine)
    {
    case 258:
      return reloc_type == 106;
    case 243:
      return reloc_type == 52;
    default:
      return 
# 14974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 14974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }
}




static 
# 14981 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 14982 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
is_none_reloc (Filedata * filedata, unsigned int reloc_type)
{
  switch (filedata->file_header.e_machine)
    {
    case 3:
    case 4:
    case 0x1223:
    case 0x9026:
    case 113:
    case 45:
    case 195:
    case 93:
    case 255:
    case 253:
    case 40:
    case 76:
    case 222:
    case 50:
    case 181:
    case 180:
    case 88:
    case 8:
    case 89:
    case 223:
    case 0xFEBB:
    case 92:
    case 15:
    case 21:
    case 20:
    case 243:
    case 22:
    case 0xa390:
    case 42:
    case 18:
    case 2:
    case 43:
    case 191:
    case 188:
    case 140:
    case 62:
    case 220:
    case 0x4157:
      return reloc_type == 0;

    case 183:
      return reloc_type == 0 || reloc_type == 256;
    case 0x1057:
    case 83:
      return (reloc_type == 0
       || reloc_type == 30
       || reloc_type == 31
       || reloc_type == 32 );
    case 174:
      return reloc_type == 3;
    case 167:
      return (reloc_type == 0
       || reloc_type == 205
       || reloc_type == 206
       || reloc_type == 207
       || reloc_type == 208 );
    case 144:
      return (reloc_type == 0
       || reloc_type == 65
       || reloc_type == 66
       || reloc_type == 67 );
    case 0xabc7:
    case 94:
      return (reloc_type == 0
       || reloc_type == 17
       || reloc_type == 18
       || reloc_type == 19
       || reloc_type == 57
       || reloc_type == 58
       || reloc_type == 59
       || reloc_type == 60
       || reloc_type == 61
       || reloc_type == 62 );
    }
  return 
# 15060 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 15060 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}





# 15066 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
_Bool

# 15067 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
reloc_at (struct dwarf_section * dsec, uint64_t offset)
{
  Elf_Internal_Rela * relocs;
  Elf_Internal_Rela * rp;

  if (dsec == 
# 15072 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0) 
# 15072 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  || dsec->reloc_info == 
# 15072 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         ((void *)0)
# 15072 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             )
    return 
# 15073 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 15073 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  relocs = (Elf_Internal_Rela *) dsec->reloc_info;

  for (rp = relocs; rp < relocs + dsec->num_relocs; ++rp)
    if (rp->r_offset == offset)
      return 
# 15079 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 15079 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

   return 
# 15081 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 15081 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
}
# 15094 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static 
# 15094 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 15095 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
apply_relocations (Filedata *filedata,
     const Elf_Internal_Shdr *section,
     unsigned char *start,
     size_t size,
     void **relocs_return,
     uint64_t *num_relocs_return)
{
  Elf_Internal_Shdr * relsec;
  unsigned char * end = start + size;

  if (relocs_return != 
# 15105 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 15105 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          )
    {
      * (Elf_Internal_Rela **) relocs_return = 
# 15107 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              ((void *)0)
# 15107 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  ;
      * num_relocs_return = 0;
    }

  if (filedata->file_header.e_type != 1)

    return 
# 15113 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 15113 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;


  for (relsec = filedata->section_headers;
       relsec < filedata->section_headers + filedata->file_header.e_shnum;
       ++relsec)
    {
      
# 15120 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 15120 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          is_rela;
      uint64_t num_relocs;
      Elf_Internal_Rela * relocs;
      Elf_Internal_Rela * rp;
      Elf_Internal_Shdr * symsec;
      Elf_Internal_Sym * symtab;
      uint64_t num_syms;
      Elf_Internal_Sym * sym;

      if ((relsec->sh_type != 4 && relsec->sh_type != 9)
   || relsec->sh_info >= filedata->file_header.e_shnum
   || filedata->section_headers + relsec->sh_info != section
   || relsec->sh_size == 0
   || relsec->sh_link >= filedata->file_header.e_shnum)
 continue;

      symsec = filedata->section_headers + relsec->sh_link;
      if (symsec->sh_type != 2
   && symsec->sh_type != 11)
 return 
# 15139 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 15139 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      is_rela = relsec->sh_type == 4;

      if (is_rela)
 {
   if (!slurp_rela_relocs (filedata, relsec->sh_offset,
                                  relsec->sh_size, & relocs, & num_relocs))
     return 
# 15147 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 15147 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
 }
      else
 {
   if (!slurp_rel_relocs (filedata, relsec->sh_offset,
                                 relsec->sh_size, & relocs, & num_relocs))
     return 
# 15153 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 15153 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
 }


      if (filedata->file_header.e_machine == 42)
 is_rela = 
# 15158 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 15158 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

      symtab = get_elf_symbols (filedata, symsec, & num_syms);

      for (rp = relocs; rp < relocs + num_relocs; ++rp)
 {
   uint64_t addend;
   unsigned int reloc_type;
   unsigned int reloc_size;
   
# 15167 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  _Bool 
# 15167 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       reloc_inplace = 
# 15167 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       0
# 15167 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
   
# 15168 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  _Bool 
# 15168 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       reloc_subtract = 
# 15168 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        0
# 15168 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;
   unsigned char *rloc;
   uint64_t sym_index;

   reloc_type = get_reloc_type (filedata, rp->r_info);

   if (target_specific_reloc_handling (filedata, rp, start, end, symtab, num_syms))
     continue;
   else if (is_none_reloc (filedata, reloc_type))
     continue;
   else if (is_32bit_abs_reloc (filedata, reloc_type)
     || is_32bit_pcrel_reloc (filedata, reloc_type))
     reloc_size = 4;
   else if (is_64bit_abs_reloc (filedata, reloc_type)
     || is_64bit_pcrel_reloc (filedata, reloc_type))
     reloc_size = 8;
   else if (is_24bit_abs_reloc (filedata, reloc_type))
     reloc_size = 3;
   else if (is_16bit_abs_reloc (filedata, reloc_type))
     reloc_size = 2;
   else if (is_8bit_abs_reloc (filedata, reloc_type)
     || is_6bit_abs_reloc (filedata, reloc_type))
     reloc_size = 1;
   else if ((reloc_subtract = is_32bit_inplace_sub_reloc (filedata,
         reloc_type))
     || is_32bit_inplace_add_reloc (filedata, reloc_type))
     {
       reloc_size = 4;
       reloc_inplace = 
# 15196 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      1
# 15196 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
     }
   else if ((reloc_subtract = is_64bit_inplace_sub_reloc (filedata,
         reloc_type))
     || is_64bit_inplace_add_reloc (filedata, reloc_type))
     {
       reloc_size = 8;
       reloc_inplace = 
# 15203 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      1
# 15203 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
     }
   else if ((reloc_subtract = is_16bit_inplace_sub_reloc (filedata,
         reloc_type))
     || is_16bit_inplace_add_reloc (filedata, reloc_type))
     {
       reloc_size = 2;
       reloc_inplace = 
# 15210 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      1
# 15210 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
     }
   else if ((reloc_subtract = is_8bit_inplace_sub_reloc (filedata,
        reloc_type))
     || is_8bit_inplace_add_reloc (filedata, reloc_type))
     {
       reloc_size = 1;
       reloc_inplace = 
# 15217 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      1
# 15217 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
     }
   else if ((reloc_subtract = is_6bit_inplace_sub_reloc (filedata,
        reloc_type))
     || is_6bit_inplace_add_reloc (filedata, reloc_type))
     {
       reloc_size = 1;
       reloc_inplace = 
# 15224 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      1
# 15224 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
     }
   else
     {
       static unsigned int prev_reloc = 0;

       if (reloc_type != prev_reloc)
  warn (gettext ("unable to apply unsupported reloc type %d to section %s\n"),
        reloc_type, printable_section_name (filedata, section));
       prev_reloc = reloc_type;
       continue;
     }

   rloc = start + rp->r_offset;
   if (!(((rloc) >= (start)) && ((rloc) < (end)) && ((rloc) + (reloc_size) <= (end))))
     {
       warn (gettext ("skipping invalid relocation offset %#" 
# 15240 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 15240 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " in section %s\n")
                           ,
      rp->r_offset,
      printable_section_name (filedata, section));
       continue;
     }

   sym_index = get_reloc_symindex (rp->r_info);
   if (sym_index >= num_syms)
     {
       warn (gettext ("skipping invalid relocation symbol index %#" 
# 15250 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 15250 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " in section %s\n")
                           ,
      sym_index, printable_section_name (filedata, section));
       continue;
     }
   sym = symtab + sym_index;
# 15270 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
   if (sym != symtab
       && ((sym->st_info) & 0xF) != 5
       && ((sym->st_info) & 0xF) > 3)
     {
       warn (gettext ("skipping unexpected symbol type %s in section %s relocation %tu\n"),
      get_symbol_type (filedata, ((sym->st_info) & 0xF)),
      printable_section_name (filedata, relsec),
      rp - relocs);
       continue;
     }

   addend = 0;
   if (is_rela)
     addend += rp->r_addend;


   if (!is_rela
       || (filedata->file_header.e_machine == 94
    && reloc_type == 1)
       || ((filedata->file_header.e_machine == 91
     || filedata->file_header.e_machine == 99)
    && reloc_type == 1)
       || ((filedata->file_header.e_machine == 86
     || filedata->file_header.e_machine == 0x7676)
    && reloc_type == 12)
       || reloc_inplace)
     {
       if (is_6bit_inplace_sub_reloc (filedata, reloc_type))
  addend += byte_get (rloc, reloc_size) & 0x3f;
       else
  addend += byte_get (rloc, reloc_size);
     }

   if (is_32bit_pcrel_reloc (filedata, reloc_type)
       || is_64bit_pcrel_reloc (filedata, reloc_type))
     {

       if (filedata->file_header.e_machine == 15)
  addend -= 8;
       byte_put (rloc, (addend + sym->st_value) - rp->r_offset,
          reloc_size);
     }
   else if (is_6bit_abs_reloc (filedata, reloc_type)
     || is_6bit_inplace_sub_reloc (filedata, reloc_type)
     || is_6bit_inplace_add_reloc (filedata, reloc_type))
     {
       if (reloc_subtract)
  addend -= sym->st_value;
       else
  addend += sym->st_value;
       addend = (addend & 0x3f) | (byte_get (rloc, reloc_size) & 0xc0);
       byte_put (rloc, addend, reloc_size);
     }
   else if (reloc_subtract)
     byte_put (rloc, addend - sym->st_value, reloc_size);
   else
     byte_put (rloc, addend + sym->st_value, reloc_size);
 }

      free (symtab);


      target_specific_reloc_handling (filedata, 
# 15332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               ((void *)0)
# 15332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   , 
# 15332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                     ((void *)0)
# 15332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                         , 
# 15332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                           ((void *)0)
# 15332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                               , 
# 15332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                 ((void *)0)
# 15332 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                     , 0);

      if (relocs_return)
 {
   * (Elf_Internal_Rela **) relocs_return = relocs;
   * num_relocs_return = num_relocs;
 }
      else
 free (relocs);

      break;
    }

  return 
# 15345 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 15345 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}
# 15363 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static char *
get_section_contents (Elf_Internal_Shdr * section, Filedata * filedata)
{
  uint64_t num_bytes = section->sh_size;

  if (num_bytes == 0 || section->sh_type == 8)
    {
      printf (gettext ("Section '%s' has no data to dump.\n"),
       printable_section_name (filedata, section));
      return 
# 15372 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 15372 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  return (char *) get_data (
# 15375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            ((void *)0)
# 15375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                , filedata, section->sh_offset, 1, num_bytes,
                             gettext ("section contents"));
}



static 
# 15381 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 15382 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
uncompress_section_contents (
# 15382 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            _Bool 
# 15382 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              is_zstd,
        unsigned char ** buffer,
        uint64_t uncompressed_size,
        uint64_t * size,
        uint64_t file_size)
{
  uint64_t compressed_size = *size;
  unsigned char *compressed_buffer = *buffer;
  unsigned char *uncompressed_buffer = 
# 15390 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 15390 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ;
  z_stream strm;
  int rc;




  if (uncompressed_size > file_size * 10)
    {
      error (gettext ("Uncompressed section size is suspiciously large: 0x%" 
# 15399 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 15399 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n"),
        uncompressed_size);
      goto fail;
    }

  uncompressed_buffer = xmalloc (uncompressed_size);

  if (is_zstd)
    {






    }
  else
    {







      memset (&strm, 0, sizeof strm);
      strm.avail_in = compressed_size;
      strm.next_in = (Bytef *)compressed_buffer;
      strm.avail_out = uncompressed_size;

      rc = inflateInit_((&strm), "1.2.12", (int)sizeof(z_stream));
      while (strm.avail_in > 0)
 {
   if (rc != 0)
     break;
   strm.next_out = ((Bytef *)uncompressed_buffer
      + (uncompressed_size - strm.avail_out));
   rc = inflate (&strm, 4);
   if (rc != 1)
     break;
   rc = inflateReset (&strm);
 }
      if (inflateEnd (&strm) != 0 || rc != 0 || strm.avail_out != 0)
 goto fail;
    }

  *buffer = uncompressed_buffer;
  *size = uncompressed_size;
  return 
# 15447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 15447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

 fail:
  free (uncompressed_buffer);

  *buffer = 
# 15452 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           ((void *)0)
# 15452 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
  return 
# 15453 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 15453 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}

static 
# 15456 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 15457 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_section_as_strings (Elf_Internal_Shdr * section, Filedata * filedata)
{
  Elf_Internal_Shdr *relsec;
  uint64_t num_bytes;
  unsigned char *data;
  unsigned char *end;
  unsigned char *real_start;
  unsigned char *start;
  
# 15465 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 15465 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      some_strings_shown;

  real_start = start = (unsigned char *) get_section_contents (section, filedata);
  if (start == 
# 15468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 15468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )

    return section->sh_size == 0 || section->sh_type == 8;

  num_bytes = section->sh_size;

  if (filedata->is_separate)
    printf (gettext ("\nString dump of section '%s' in linked file %s:\n"),
     printable_section_name (filedata, section),
     filedata->file_name);
  else
    printf (gettext ("\nString dump of section '%s':\n"),
     printable_section_name (filedata, section));

  if (decompress_dumps)
    {
      uint64_t new_size = num_bytes;
      uint64_t uncompressed_size = 0;
      
# 15486 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 15486 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          is_zstd = 
# 15486 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    0
# 15486 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;

      if ((section->sh_flags & (1 << 11)) != 0)
 {
   Elf_Internal_Chdr chdr;
   unsigned int compression_header_size
     = get_compression_header (& chdr, (unsigned char *) start,
          num_bytes);
   if (compression_header_size == 0)


     goto error_out;

   if (chdr.ch_type == ch_compress_zlib)
     ;




   else
     {
       warn (gettext ("section '%s' has unsupported compress type: %d\n"),
      printable_section_name (filedata, section), chdr.ch_type);
       goto error_out;
     }
   uncompressed_size = chdr.ch_size;
   start += compression_header_size;
   new_size -= compression_header_size;
 }
      else if (new_size > 12 && (strcmp (((char *) start), ("ZLIB")) == 0))
 {



   uncompressed_size = start[4]; uncompressed_size <<= 8;
   uncompressed_size += start[5]; uncompressed_size <<= 8;
   uncompressed_size += start[6]; uncompressed_size <<= 8;
   uncompressed_size += start[7]; uncompressed_size <<= 8;
   uncompressed_size += start[8]; uncompressed_size <<= 8;
   uncompressed_size += start[9]; uncompressed_size <<= 8;
   uncompressed_size += start[10]; uncompressed_size <<= 8;
   uncompressed_size += start[11];
   start += 12;
   new_size -= 12;
 }

      if (uncompressed_size)
 {
   if (uncompress_section_contents (is_zstd, &start, uncompressed_size,
        &new_size, filedata->file_size))
     num_bytes = new_size;
   else
     {
       error (gettext ("Unable to decompress section %s\n"),
       printable_section_name (filedata, section));
       goto error_out;
     }
 }
      else
 start = real_start;
    }






  for (relsec = filedata->section_headers;
       relsec < filedata->section_headers + filedata->file_header.e_shnum;
       ++relsec)
    {
      if ((relsec->sh_type != 4 && relsec->sh_type != 9)
   || relsec->sh_info >= filedata->file_header.e_shnum
   || filedata->section_headers + relsec->sh_info != section
   || relsec->sh_size == 0
   || relsec->sh_link >= filedata->file_header.e_shnum)
 continue;

      printf (gettext ("  Note: This section has relocations against it, but these have NOT been applied to this dump.\n"));
      break;
    }

  data = start;
  end = start + num_bytes;
  some_strings_shown = 
# 15570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      0
# 15570 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;


  mbstate_t state;

  memset (& state, 0, sizeof (state));


  
# 15578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 15578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      continuing = 
# 15578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   0
# 15578 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;

  while (data < end)
    {
      while (!(_sch_istable[(* data) & 0xff] & (unsigned short)(_sch_isprint)))
 if (++ data >= end)
   break;

      if (data < end)
 {
   size_t maxlen = end - data;

   if (continuing)
     {
       printf ("            ");
       continuing = 
# 15593 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   0
# 15593 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;
     }
   else
     {
       printf ("  [%6tx]  ", data - start);
     }

   if (maxlen > 0)
     {
       char c = 0;

       while (maxlen)
  {
    c = *data++;

    if (c == 0)
      break;


    if (c == '\n')
      {
        printf ("\\n\n");
        if (*data != 0)
   continuing = 
# 15616 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 15616 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
        break;
      }




    if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_iscntrl)))
      {
        printf ("^%c", c + 0x40);
      }
    else if ((_sch_istable[(c) & 0xff] & (unsigned short)(_sch_isprint)))
      {
        putchar (c);
      }
    else
      {
        size_t n;

        wchar_t w;


        printf ("%.1s", data - 1);




        n = mbrtowc (& w, (char *)(data - 1), 
# 15643 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             (__ctype_get_mb_cur_max ())
# 15643 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                       , & state);



        if (n != (size_t) -1 && n != (size_t) -2 && n > 0)
   data += (n - 1);
      }
  }

       if (c != '\n')
  putchar ('\n');
     }
   else
     {
       printf (gettext ("<corrupt>\n"));
       data = end;
     }
   some_strings_shown = 
# 15660 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       1
# 15660 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
 }
    }

  if (! some_strings_shown)
    printf (gettext ("  No strings found in this section."));

  free (real_start);

  putchar ('\n');
  return 
# 15670 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 15670 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

error_out:
  free (real_start);
  return 
# 15674 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 15674 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}

static 
# 15677 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 15678 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_section_as_bytes (Elf_Internal_Shdr *section,
         Filedata *filedata,
         
# 15680 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        _Bool 
# 15680 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             relocate)
{
  Elf_Internal_Shdr *relsec;
  size_t bytes;
  uint64_t section_size;
  uint64_t addr;
  unsigned char *data;
  unsigned char *real_start;
  unsigned char *start;

  real_start = start = (unsigned char *) get_section_contents (section, filedata);
  if (start == 
# 15691 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 15691 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )

    return section->sh_size == 0 || section->sh_type == 8;

  section_size = section->sh_size;

  if (filedata->is_separate)
    printf (gettext ("\nHex dump of section '%s' in linked file %s:\n"),
     printable_section_name (filedata, section),
     filedata->file_name);
  else
    printf (gettext ("\nHex dump of section '%s':\n"),
     printable_section_name (filedata, section));

  if (decompress_dumps)
    {
      uint64_t new_size = section_size;
      uint64_t uncompressed_size = 0;
      
# 15709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 15709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          is_zstd = 
# 15709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    0
# 15709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;

      if ((section->sh_flags & (1 << 11)) != 0)
 {
   Elf_Internal_Chdr chdr;
   unsigned int compression_header_size
     = get_compression_header (& chdr, start, section_size);

   if (compression_header_size == 0)


     goto error_out;

   if (chdr.ch_type == ch_compress_zlib)
     ;




   else
     {
       warn (gettext ("section '%s' has unsupported compress type: %d\n"),
      printable_section_name (filedata, section), chdr.ch_type);
       goto error_out;
     }
   uncompressed_size = chdr.ch_size;
   start += compression_header_size;
   new_size -= compression_header_size;
 }
      else if (new_size > 12 && (strcmp (((char *) start), ("ZLIB")) == 0))
 {



   uncompressed_size = start[4]; uncompressed_size <<= 8;
   uncompressed_size += start[5]; uncompressed_size <<= 8;
   uncompressed_size += start[6]; uncompressed_size <<= 8;
   uncompressed_size += start[7]; uncompressed_size <<= 8;
   uncompressed_size += start[8]; uncompressed_size <<= 8;
   uncompressed_size += start[9]; uncompressed_size <<= 8;
   uncompressed_size += start[10]; uncompressed_size <<= 8;
   uncompressed_size += start[11];
   start += 12;
   new_size -= 12;
 }

      if (uncompressed_size)
 {
   if (uncompress_section_contents (is_zstd, &start, uncompressed_size,
        &new_size, filedata->file_size))
     {
       section_size = new_size;
     }
   else
     {
       error (gettext ("Unable to decompress section %s\n"),
       printable_section_name (filedata, section));

       goto error_out;
     }
 }
      else
 start = real_start;
    }

  if (relocate)
    {
      if (! apply_relocations (filedata, section, start, section_size, 
# 15776 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                      ((void *)0)
# 15776 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                          , 
# 15776 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                            ((void *)0)
# 15776 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                ))
 goto error_out;
    }
  else
    {





      for (relsec = filedata->section_headers;
    relsec < filedata->section_headers + filedata->file_header.e_shnum;
    ++relsec)
 {
   if ((relsec->sh_type != 4 && relsec->sh_type != 9)
       || relsec->sh_info >= filedata->file_header.e_shnum
       || filedata->section_headers + relsec->sh_info != section
       || relsec->sh_size == 0
       || relsec->sh_link >= filedata->file_header.e_shnum)
     continue;

   printf (gettext (" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n"));
   break;
 }
    }

  addr = section->sh_addr;
  bytes = section_size;
  data = start;

  while (bytes)
    {
      int j;
      int k;
      int lbytes;

      lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8" 
# 15814 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        "l" "x" 
# 15814 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               " ", addr);

      for (j = 0; j < 16; j++)
 {
   if (j < lbytes)
     printf ("%2.2x", data[j]);
   else
     printf ("  ");

   if ((j & 3) == 3)
     printf (" ");
 }

      for (j = 0; j < lbytes; j++)
 {
   k = data[j];
   if (k >= ' ' && k < 0x7f)
     printf ("%c", k);
   else
     printf (".");
 }

      putchar ('\n');

      data += lbytes;
      addr += lbytes;
      bytes -= lbytes;
    }

  free (real_start);

  putchar ('\n');
  return 
# 15846 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 15846 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

 error_out:
  free (real_start);
  return 
# 15850 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 15850 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}


static ctf_sect_t *
shdr_to_ctf_sect (ctf_sect_t *buf, Elf_Internal_Shdr *shdr, Filedata *filedata)
{
  buf->cts_name = section_name_print (filedata, shdr);
  buf->cts_size = shdr->sh_size;
  buf->cts_entsize = shdr->sh_entsize;

  return buf;
}





static char *
dump_ctf_indent_lines (ctf_sect_names_t sect __attribute__ ((__unused__)),
         char *s, void *arg)
{
  const char *blanks = arg;
  char *new_s;

  if (asprintf (&new_s, "%s%s", blanks, s) < 0)
    return s;
  return new_s;
}


static void
dump_ctf_errs (ctf_dict_t *fp)
{
  ctf_next_t *it = 
# 15884 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 15884 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;
  char *errtext;
  int is_warning;
  int err;


  while ((errtext = ctf_errwarning_next (fp, &it, &is_warning, &err)) != 
# 15890 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                        ((void *)0)
# 15890 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                            )
    {
      error (gettext ("%s: %s"), is_warning ? gettext ("warning"): gettext ("error"),
      errtext);
      free (errtext);
    }
  if (err != ECTF_NEXT_END)
    error (gettext ("CTF error: cannot get CTF errors: `%s'"), ctf_errmsg (err));
}



static void
dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, ctf_dict_t *parent,
    size_t member)
{
  const char *things[] = {"Header", "Labels", "Data objects",
     "Function objects", "Variables", "Types", "Strings",
     ""};
  const char **thing;
  size_t i;







  if (strcmp (name, ".ctf") != 0 || member != 0)
    printf (gettext ("\nCTF archive member: %s:\n"), name);

  if (ctf_parent_name (ctf) != 
# 15921 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 15921 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  )
    ctf_import (ctf, parent);

  for (i = 0, thing = things; *thing[0]; thing++, i++)
    {
      ctf_dump_state_t *s = 
# 15926 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 15926 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
      char *item;

      printf ("\n  %s:\n", *thing);
      while ((item = ctf_dump (ctf, &s, i, dump_ctf_indent_lines,
          (void *) "    ")) != 
# 15931 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 15931 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  )
 {
   printf ("%s\n", item);
   free (item);
 }

      if (ctf_errno (ctf))
 {
   error (gettext ("Iteration failed: %s, %s\n"), *thing,
   ctf_errmsg (ctf_errno (ctf)));
   break;
 }
    }

  dump_ctf_errs (ctf);
}

static 
# 15948 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 15949 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)
{
  Elf_Internal_Shdr * symtab_sec = 
# 15951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   ((void *)0)
# 15951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       ;
  Elf_Internal_Shdr * strtab_sec = 
# 15952 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   ((void *)0)
# 15952 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       ;
  void * data = 
# 15953 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 15953 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ;
  void * symdata = 
# 15954 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 15954 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;
  void * strdata = 
# 15955 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 15955 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;
  ctf_sect_t ctfsect, symsect, strsect;
  ctf_sect_t * symsectp = 
# 15957 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 15957 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    ;
  ctf_sect_t * strsectp = 
# 15958 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 15958 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    ;
  ctf_archive_t * ctfa = 
# 15959 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             ((void *)0)
# 15959 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 ;
  ctf_dict_t * parent = 
# 15960 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 15960 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ;
  ctf_dict_t * fp;

  ctf_next_t *i = 
# 15963 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 15963 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;
  const char *name;
  size_t member = 0;
  int err;
  
# 15967 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 15967 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ret = 
# 15967 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 15967 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;

  shdr_to_ctf_sect (&ctfsect, section, filedata);
  data = get_section_contents (section, filedata);
  ctfsect.cts_data = data;

  if (!dump_ctf_symtab_name)
    dump_ctf_symtab_name = strdup (".dynsym");

  if (!dump_ctf_strtab_name)
    dump_ctf_strtab_name = strdup (".dynstr");

  if (dump_ctf_symtab_name && dump_ctf_symtab_name[0] != 0)
    {
      if ((symtab_sec = find_section (filedata, dump_ctf_symtab_name)) == 
# 15981 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                         ((void *)0)
# 15981 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                             )
 {
   error (gettext ("No symbol section named %s\n"), dump_ctf_symtab_name);
   goto fail;
 }
      if ((symdata = (void *) get_data (
# 15986 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       ((void *)0)
# 15986 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           , filedata,
     symtab_sec->sh_offset, 1,
     symtab_sec->sh_size,
     gettext ("symbols"))) == 
# 15989 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 15989 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          )
 goto fail;
      symsectp = shdr_to_ctf_sect (&symsect, symtab_sec, filedata);
      symsect.cts_data = symdata;
    }

  if (dump_ctf_strtab_name && dump_ctf_strtab_name[0] != 0)
    {
      if ((strtab_sec = find_section (filedata, dump_ctf_strtab_name)) == 
# 15997 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                         ((void *)0)
# 15997 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                             )
 {
   error (gettext ("No string table section named %s\n"),
   dump_ctf_strtab_name);
   goto fail;
 }
      if ((strdata = (void *) get_data (
# 16003 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       ((void *)0)
# 16003 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           , filedata,
     strtab_sec->sh_offset, 1,
     strtab_sec->sh_size,
     gettext ("strings"))) == 
# 16006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 16006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          )
 goto fail;
      strsectp = shdr_to_ctf_sect (&strsect, strtab_sec, filedata);
      strsect.cts_data = strdata;
    }





  if ((ctfa = ctf_arc_bufopen (&ctfsect, symsectp, strsectp, &err)) == 
# 16016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                      ((void *)0)
# 16016 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                          )
    {
      dump_ctf_errs (
# 16018 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 16018 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        );
      error (gettext ("CTF open failure: %s\n"), ctf_errmsg (err));
      goto fail;
    }

  ctf_arc_symsect_endianness (ctfa, filedata->file_header.e_ident[5]
         != 2);



  if ((parent = ctf_dict_open (ctfa, dump_ctf_parent_name, &err)) == 
# 16028 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                    ((void *)0)
# 16028 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                        )
    {
      dump_ctf_errs (
# 16030 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 16030 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        );
      error (gettext ("CTF open failure: %s\n"), ctf_errmsg (err));
      goto fail;
    }

  ret = 
# 16035 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       1
# 16035 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ;

  if (filedata->is_separate)
    printf (gettext ("\nDump of CTF section '%s' in linked file %s:\n"),
     printable_section_name (filedata, section),
     filedata->file_name);
  else
    printf (gettext ("\nDump of CTF section '%s':\n"),
     printable_section_name (filedata, section));

 while ((fp = ctf_archive_next (ctfa, &i, &name, 0, &err)) != 
# 16045 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                             ((void *)0)
# 16045 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                 )
    dump_ctf_archive_member (fp, name, parent, member++);
 if (err != ECTF_NEXT_END)
   {
     dump_ctf_errs (
# 16049 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 16049 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       );
     error (gettext ("CTF member open failure: %s\n"), ctf_errmsg (err));
     ret = 
# 16051 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16051 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   }

 fail:
  ctf_dict_close (parent);
  ctf_close (ctfa);
  free (data);
  free (symdata);
  free (strdata);
  return ret;
}


static 
# 16064 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 16065 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
dump_section_as_sframe (Elf_Internal_Shdr * section, Filedata * filedata)
{
  void * data = 
# 16067 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 16067 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;
  sframe_decoder_ctx *sfd_ctx = 
# 16068 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 ((void *)0)
# 16068 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ;
  const char *print_name = printable_section_name (filedata, section);

  
# 16071 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 16071 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ret = 
# 16071 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 16071 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
  size_t sf_size;
  int err = 0;

  if (strcmp (print_name, "") == 0)
    {
      error (gettext ("Section name must be provided \n"));
      ret = 
# 16078 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 16078 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
      return ret;
    }

  data = get_section_contents (section, filedata);
  sf_size = section->sh_size;

  sfd_ctx = sframe_decode ((const char*)data, sf_size, &err);
  if (!sfd_ctx)
    {
      ret = 
# 16088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 16088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
      error (gettext ("SFrame decode failure: %s\n"), sframe_errmsg (err));
      goto fail;
    }

  printf (gettext ("Contents of the SFrame section %s:"), print_name);

  dump_sframe (sfd_ctx, section->sh_addr);

 fail:
  free (data);
  return ret;
}

static 
# 16102 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 16103 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
load_specific_debug_section (enum dwarf_section_display_enum debug,
        const Elf_Internal_Shdr * sec,
        void * data)
{
  struct dwarf_section * section = &debug_displays [debug].section;
  char buf [64];
  Filedata * filedata = (Filedata *) data;

  if (section->start != 
# 16111 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 16111 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           )
    {

      if ((strcmp ((section->filename), (filedata->file_name)) == 0))
 return 
# 16115 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       1
# 16115 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ;
      free (section->start);
    }

  snprintf (buf, sizeof (buf), gettext ("%s section data"), section->name);
  section->address = sec->sh_addr;
  section->filename = filedata->file_name;
  section->start = (unsigned char *) get_data (
# 16122 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              ((void *)0)
# 16122 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  , filedata,
                                               sec->sh_offset, 1,
                                               sec->sh_size, buf);
  if (section->start == 
# 16125 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 16125 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           )
    section->size = 0;
  else
    {
      unsigned char *start = section->start;
      uint64_t size = sec->sh_size;
      uint64_t uncompressed_size = 0;
      
# 16132 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 16132 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          is_zstd = 
# 16132 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    0
# 16132 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;

      if ((sec->sh_flags & (1 << 11)) != 0)
 {
   Elf_Internal_Chdr chdr;
   unsigned int compression_header_size;

   if (size < (is_32bit_elf
        ? sizeof (Elf32_External_Chdr)
        : sizeof (Elf64_External_Chdr)))
     {
       warn (gettext ("compressed section %s is too small to contain a compression header\n"),
      section->name);
       return 
# 16145 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 16145 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }

   compression_header_size = get_compression_header (&chdr, start, size);
   if (compression_header_size == 0)


     return 
# 16152 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 16152 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

   if (chdr.ch_type == ch_compress_zlib)
     ;




   else
     {
       warn (gettext ("section '%s' has unsupported compress type: %d\n"),
      section->name, chdr.ch_type);
       return 
# 16164 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 16164 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }
   uncompressed_size = chdr.ch_size;
   start += compression_header_size;
   size -= compression_header_size;
 }
      else if (size > 12 && (strcmp (((char *) start), ("ZLIB")) == 0))
 {



   uncompressed_size = start[4]; uncompressed_size <<= 8;
   uncompressed_size += start[5]; uncompressed_size <<= 8;
   uncompressed_size += start[6]; uncompressed_size <<= 8;
   uncompressed_size += start[7]; uncompressed_size <<= 8;
   uncompressed_size += start[8]; uncompressed_size <<= 8;
   uncompressed_size += start[9]; uncompressed_size <<= 8;
   uncompressed_size += start[10]; uncompressed_size <<= 8;
   uncompressed_size += start[11];
   start += 12;
   size -= 12;
 }

      if (uncompressed_size)
 {
   if (uncompress_section_contents (is_zstd, &start, uncompressed_size,
        &size, filedata->file_size))
     {


       free (section->start);
       section->start = start;
     }
   else
     {
       error (gettext ("Unable to decompress section %s\n"),
       printable_section_name (filedata, sec));
       return 
# 16201 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 16201 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }
 }

      section->size = size;
    }

  if (section->start == 
# 16208 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 16208 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           )
    return 
# 16209 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16209 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (debug_displays [debug].relocate)
    {
      if (! apply_relocations (filedata, sec, section->start, section->size,
          & section->reloc_info, & section->num_relocs))
 return 
# 16215 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 16215 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
    }
  else
    {
      section->reloc_info = 
# 16219 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 16219 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
      section->num_relocs = 0;
    }

  return 
# 16223 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 16223 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}
# 16366 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static unsigned int * section_subset = 
# 16366 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 16366 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ;


# 16368 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
_Bool

# 16369 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
load_debug_section (enum dwarf_section_display_enum debug, void * data)
{
  struct dwarf_section * section = &debug_displays [debug].section;
  Elf_Internal_Shdr * sec;
  Filedata * filedata = (Filedata *) data;

  if (!dump_any_debugging)
    return 
# 16376 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16376 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;


  if (filedata->section_headers == 
# 16379 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 16379 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    return 
# 16380 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16380 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (filedata->string_table == 
# 16382 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
      
# 16383 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     && filedata->file_header.e_shstrndx != 0
      && filedata->file_header.e_shstrndx < filedata->file_header.e_shnum)
    {
      Elf_Internal_Shdr * strs;


      strs = filedata->section_headers + filedata->file_header.e_shstrndx;

      if (strs != 
# 16391 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0) 
# 16391 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      && strs->sh_size != 0)
 {
   filedata->string_table
     = (char *) get_data (
# 16394 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 16394 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             , filedata, strs->sh_offset,
     1, strs->sh_size, gettext ("string table"));

   filedata->string_table_length
     = filedata->string_table != 
# 16398 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0) 
# 16398 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ? strs->sh_size : 0;
 }
    }


  sec = find_section_in_set (filedata, section->uncompressed_name, section_subset);
  if (sec != 
# 16404 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 16404 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                )
    section->name = section->uncompressed_name;
  else
    {
      sec = find_section_in_set (filedata, section->compressed_name, section_subset);
      if (sec != 
# 16409 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 16409 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
 section->name = section->compressed_name;
    }
  if (sec == 
# 16412 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 16412 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                )
    return 
# 16413 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16413 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;




  if (section_subset != 
# 16418 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 16418 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           )
    free_debug_section (debug);

  return load_specific_debug_section (debug, sec, data);
}

void
free_debug_section (enum dwarf_section_display_enum debug)
{
  struct dwarf_section * section = &debug_displays [debug].section;

  if (section->start == 
# 16429 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 16429 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           )
    return;

  free ((char *) section->start);
  section->start = 
# 16433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 16433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;
  section->address = 0;
  section->size = 0;

  free (section->reloc_info);
  section->reloc_info = 
# 16438 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 16438 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
  section->num_relocs = 0;
}

static 
# 16442 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 16443 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
display_debug_section (int shndx, Elf_Internal_Shdr * section, Filedata * filedata)
{
  const char *name = (section_name_valid (filedata, section)
        ? section_name (filedata, section) : "");
  const char *print_name = printable_section_name (filedata, section);
  uint64_t length;
  
# 16449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 16449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      result = 
# 16449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 16449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
  int i;

  length = section->sh_size;
  if (length == 0)
    {
      printf (gettext ("\nSection '%s' has no debugging data.\n"), print_name);
      return 
# 16456 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 16456 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
  if (section->sh_type == 8)
    {




      printf (gettext ("section '%s' has the NOBITS type - its contents are unreliable.\n"),
       print_name);
      return 
# 16466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 16466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  if (startswith (name, ".gnu.linkonce.wi."))
    name = ".debug_info";


  for (i = 0; i < max; i++)
    {
      enum dwarf_section_display_enum id = (enum dwarf_section_display_enum) i;
      struct dwarf_section_display * display = debug_displays + i;
      struct dwarf_section * sec = & display->section;

      if ((strcmp ((sec->uncompressed_name), (name)) == 0)
   || (id == line && startswith (name, ".debug_line."))
   || (strcmp ((sec->compressed_name), (name)) == 0))
 {
   
# 16483 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  _Bool 
# 16483 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       secondary = (section != find_section (filedata, name));

   if (secondary)
     free_debug_section (id);

   if (i == line && startswith (name, ".debug_line."))
     sec->name = name;
   else if ((strcmp ((sec->uncompressed_name), (name)) == 0))
     sec->name = sec->uncompressed_name;
   else
     sec->name = sec->compressed_name;

   if (load_specific_debug_section (id, section, filedata))
     {


       section_subset = find_cu_tu_set (filedata, shndx);

       result &= display->display (sec, filedata);

       section_subset = 
# 16503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 16503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;

       if (secondary || (id != info && id != abbrev && id != debug_addr))
  free_debug_section (id);
     }
   break;
 }
    }

  if (i == max)
    {
      printf (gettext ("Unrecognized debug section: %s\n"), print_name);
      result = 
# 16515 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              0
# 16515 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
    }

  return result;
}




static void
initialise_dumps_byname (Filedata * filedata)
{
  struct dump_list_entry * cur;

  for (cur = dump_sects_byname; cur; cur = cur->next)
    {
      unsigned int i;
      
# 16532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 16532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          any = 
# 16532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                0
# 16532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;

      for (i = 0; i < filedata->file_header.e_shnum; i++)
 if (section_name_valid (filedata, filedata->section_headers + i)
     && (strcmp ((section_name (filedata, filedata->section_headers + i)), (cur->name)) == 0)
                  )
   {
     request_dump_bynumber (&filedata->dump, i, cur->type);
     any = 
# 16540 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 16540 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
   }

      if (!any && !filedata->is_separate)
 warn (gettext ("Section '%s' was not dumped because it does not exist\n"),
       cur->name);
    }
}

static 
# 16549 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 16550 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_section_contents (Filedata * filedata)
{
  Elf_Internal_Shdr * section;
  unsigned int i;
  
# 16554 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 16554 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 16554 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 16554 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (! do_dump)
    return 
# 16557 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 16557 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  initialise_dumps_byname (filedata);

  for (i = 0, section = filedata->section_headers;
       i < filedata->file_header.e_shnum && i < filedata->dump.num_dump_sects;
       i++, section++)
    {
      dump_type dump = filedata->dump.dump_sects[i];

      if (filedata->is_separate && ! process_links)
 dump &= (1 << 2);
# 16577 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      if (dump & (1 << 0))
 {
   if (! dump_section_as_bytes (section, filedata, 
# 16579 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                  0
# 16579 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                       ))
     res = 
# 16580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }

      if (dump & (1 << 4))
 {
   if (! dump_section_as_bytes (section, filedata, 
# 16585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                  1
# 16585 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                      ))
     res = 
# 16586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16586 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }

      if (dump & (1 << 3))
 {
   if (! dump_section_as_strings (section, filedata))
     res = 
# 16592 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16592 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }

      if (dump & (1 << 2))
 {
   if (! display_debug_section (i, section, filedata))
     res = 
# 16598 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16598 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }


      if (dump & (1 << 5))
 {
   if (! dump_section_as_ctf (section, filedata))
     res = 
# 16605 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16605 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }

      if (dump & (1 << 6))
 {
   if (! dump_section_as_sframe (section, filedata))
     res = 
# 16611 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16611 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }
    }

  if (! filedata->is_separate)
    {


      for (; i < filedata->dump.num_dump_sects; i++)
 if (filedata->dump.dump_sects[i])
   {
     warn (gettext ("Section %d was not dumped because it does not exist!\n"), i);
     res = 
# 16623 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 16623 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   }
    }

  return res;
}

static void
process_mips_fpe_exception (int mask)
{
  if (mask)
    {
      
# 16635 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 16635 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          first = 
# 16635 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  1
# 16635 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;

      if (mask & 0x01)
 fputs ("INEX", 
# 16638 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               stdout
# 16638 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ), first = 
# 16638 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                0
# 16638 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ;
      if (mask & 0x02)
 printf ("%sUFLO", first ? "" : "|"), first = 
# 16640 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             0
# 16640 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  ;
      if (mask & 0x04)
 printf ("%sOFLO", first ? "" : "|"), first = 
# 16642 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             0
# 16642 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  ;
      if (mask & 0x08)
 printf ("%sDIV0", first ? "" : "|"), first = 
# 16644 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             0
# 16644 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  ;
      if (mask & 0x10)
 printf ("%sINVAL", first ? "" : "|");
    }
  else
    fputs ("0", 
# 16649 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               stdout
# 16649 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     );
}
# 16666 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static unsigned char *
display_tag_value (signed int tag,
     unsigned char * p,
     const unsigned char * const end)
{
  uint64_t val;

  if (tag > 0)
    printf ("  Tag_unknown_%d: ", tag);

  if (p >= end)
    {
      warn (gettext ("<corrupt tag>\n"));
    }
  else if (tag & 1)
    {

      size_t maxlen = (end - p) - 1;

      putchar ('"');
      if (maxlen > 0)
 {
   print_symbol ((int) maxlen, (const char *) p);
   p += strnlen ((char *) p, maxlen) + 1;
 }
      else
 {
   printf (gettext ("<corrupt string tag>"));
   p = (unsigned char *) end;
 }
      printf ("\"\n");
    }
  else
    {
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16700 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16700 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("%" 
# 16701 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 "l" "d" 
# 16701 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        " (0x%" 
# 16701 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                "l" "x" 
# 16701 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       ")\n", val, val);
    }

  
# 16704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 ((void) sizeof ((
# 16704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 p <= end
# 16704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 16704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 p <= end
# 16704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 ) ; else __assert_fail (
# 16704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 "p <= end"
# 16704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 16704, __extension__ __PRETTY_FUNCTION__); }))
# 16704 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
  return p;
}



static unsigned char *
display_arc_attribute (unsigned char * p,
         const unsigned char * const end)
{
  unsigned int tag;
  unsigned int val;

  do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16717 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 0
# 16717 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 , &_len, &_status); p += _len; (tag) = _val; if ((tag) != _val) _status |= 2; report_leb_status (_status); } while (0);

  switch (tag)
    {
    case Tag_ARC_PCS_config:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16722 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16722 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_PCS_config: ");
      switch (val)
 {
 case 0:
   printf (gettext ("Absent/Non standard\n"));
   break;
 case 1:
   printf (gettext ("Bare metal/mwdt\n"));
   break;
 case 2:
   printf (gettext ("Bare metal/newlib\n"));
   break;
 case 3:
   printf (gettext ("Linux/uclibc\n"));
   break;
 case 4:
   printf (gettext ("Linux/glibc\n"));
   break;
 default:
   printf (gettext ("Unknown\n"));
   break;
 }
      break;

    case Tag_ARC_CPU_base:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16748 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16748 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_CPU_base: ");
      switch (val)
 {
 default:
 case 0:
   printf (gettext ("Absent\n"));
   break;
 case 1:
   printf ("ARC6xx\n");
   break;
 case 2:
   printf ("ARC7xx\n");
   break;
 case 3:
   printf ("ARCEM\n");
   break;
 case 4:
   printf ("ARCHS\n");
   break;
 }
      break;

    case Tag_ARC_CPU_variation:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_CPU_variation: ");
      switch (val)
 {
 default:
   if (val > 0 && val < 16)
       printf ("Core%d\n", val);
   else
       printf ("Unknown\n");
   break;

 case 0:
   printf (gettext ("Absent\n"));
   break;
 }
      break;

    case Tag_ARC_CPU_name:
      printf ("  Tag_ARC_CPU_name: ");
      p = display_tag_value (-1, p, end);
      break;

    case Tag_ARC_ABI_rf16:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16795 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16795 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_ABI_rf16: %s\n", val ? gettext ("yes") : gettext ("no"));
      break;

    case Tag_ARC_ABI_osver:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16800 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16800 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_ABI_osver: v%d\n", val);
      break;

    case Tag_ARC_ABI_pic:
    case Tag_ARC_ABI_sda:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16806 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16806 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf (tag == Tag_ARC_ABI_sda ? "  Tag_ARC_ABI_sda: "
       : "  Tag_ARC_ABI_pic: ");
      switch (val)
 {
 case 0:
   printf (gettext ("Absent\n"));
   break;
 case 1:
   printf ("MWDT\n");
   break;
 case 2:
   printf ("GNU\n");
   break;
 default:
   printf (gettext ("Unknown\n"));
   break;
 }
      break;

    case Tag_ARC_ABI_tls:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16827 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16827 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_ABI_tls: %s\n", val ? "r25": "none");
      break;

    case Tag_ARC_ABI_enumsize:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16832 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16832 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_ABI_enumsize: %s\n", val ? gettext ("default") :
       gettext ("smallest"));
      break;

    case Tag_ARC_ABI_exceptions:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16838 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16838 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_ABI_exceptions: %s\n", val ? gettext ("OPTFP")
       : gettext ("default"));
      break;

    case Tag_ARC_ABI_double_size:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16844 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16844 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_ABI_double_size: %d\n", val);
      break;

    case Tag_ARC_ISA_config:
      printf ("  Tag_ARC_ISA_config: ");
      p = display_tag_value (-1, p, end);
      break;

    case Tag_ARC_ISA_apex:
      printf ("  Tag_ARC_ISA_apex: ");
      p = display_tag_value (-1, p, end);
      break;

    case Tag_ARC_ISA_mpy_option:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16859 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16859 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_ISA_mpy_option: %d\n", val);
      break;

    case Tag_ARC_ATR_version:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 16864 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 16864 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ARC_ATR_version: %d\n", val);
      break;

    default:
      return display_tag_value (tag & 1, p, end);
    }

  return p;
}


typedef struct
{
  unsigned int tag;
  const char * name;

  unsigned int type;
  const char *const *table;
} arm_attr_public_tag;

static const char *const arm_attr_tag_CPU_arch[] =
  {"Pre-v4", "v4", "v4T", "v5T", "v5TE", "v5TEJ", "v6", "v6KZ", "v6T2",
   "v6K", "v7", "v6-M", "v6S-M", "v7E-M", "v8", "v8-R", "v8-M.baseline",
   "v8-M.mainline", "v8.1-A", "v8.2-A", "v8.3-A",
   "v8.1-M.mainline", "v9"};
static const char *const arm_attr_tag_ARM_ISA_use[] = {"No", "Yes"};
static const char *const arm_attr_tag_THUMB_ISA_use[] =
  {"No", "Thumb-1", "Thumb-2", "Yes"};
static const char *const arm_attr_tag_FP_arch[] =
  {"No", "VFPv1", "VFPv2", "VFPv3", "VFPv3-D16", "VFPv4", "VFPv4-D16",
   "FP for ARMv8", "FPv5/FP-D16 for ARMv8"};
static const char *const arm_attr_tag_WMMX_arch[] = {"No", "WMMXv1", "WMMXv2"};
static const char *const arm_attr_tag_Advanced_SIMD_arch[] =
  {"No", "NEONv1", "NEONv1 with Fused-MAC", "NEON for ARMv8",
   "NEON for ARMv8.1"};
static const char *const arm_attr_tag_PCS_config[] =
  {"None", "Bare platform", "Linux application", "Linux DSO", "PalmOS 2004",
   "PalmOS (reserved)", "SymbianOS 2004", "SymbianOS (reserved)"};
static const char *const arm_attr_tag_ABI_PCS_R9_use[] =
  {"V6", "SB", "TLS", "Unused"};
static const char *const arm_attr_tag_ABI_PCS_RW_data[] =
  {"Absolute", "PC-relative", "SB-relative", "None"};
static const char *const arm_attr_tag_ABI_PCS_RO_data[] =
  {"Absolute", "PC-relative", "None"};
static const char *const arm_attr_tag_ABI_PCS_GOT_use[] =
  {"None", "direct", "GOT-indirect"};
static const char *const arm_attr_tag_ABI_PCS_wchar_t[] =
  {"None", "??? 1", "2", "??? 3", "4"};
static const char *const arm_attr_tag_ABI_FP_rounding[] = {"Unused", "Needed"};
static const char *const arm_attr_tag_ABI_FP_denormal[] =
  {"Unused", "Needed", "Sign only"};
static const char *const arm_attr_tag_ABI_FP_exceptions[] = {"Unused", "Needed"};
static const char *const arm_attr_tag_ABI_FP_user_exceptions[] = {"Unused", "Needed"};
static const char *const arm_attr_tag_ABI_FP_number_model[] =
  {"Unused", "Finite", "RTABI", "IEEE 754"};
static const char *const arm_attr_tag_ABI_enum_size[] =
  {"Unused", "small", "int", "forced to int"};
static const char *const arm_attr_tag_ABI_HardFP_use[] =
  {"As Tag_FP_arch", "SP only", "Reserved", "Deprecated"};
static const char *const arm_attr_tag_ABI_VFP_args[] =
  {"AAPCS", "VFP registers", "custom", "compatible"};
static const char *const arm_attr_tag_ABI_WMMX_args[] =
  {"AAPCS", "WMMX registers", "custom"};
static const char *const arm_attr_tag_ABI_optimization_goals[] =
  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
    "Aggressive Size", "Prefer Debug", "Aggressive Debug"};
static const char *const arm_attr_tag_ABI_FP_optimization_goals[] =
  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
    "Aggressive Size", "Prefer Accuracy", "Aggressive Accuracy"};
static const char *const arm_attr_tag_CPU_unaligned_access[] = {"None", "v6"};
static const char *const arm_attr_tag_FP_HP_extension[] =
  {"Not Allowed", "Allowed"};
static const char *const arm_attr_tag_ABI_FP_16bit_format[] =
  {"None", "IEEE 754", "Alternative Format"};
static const char *const arm_attr_tag_DSP_extension[] =
  {"Follow architecture", "Allowed"};
static const char *const arm_attr_tag_MPextension_use[] =
  {"Not Allowed", "Allowed"};
static const char *const arm_attr_tag_DIV_use[] =
  {"Allowed in Thumb-ISA, v7-R or v7-M", "Not allowed",
    "Allowed in v7-A with integer division extension"};
static const char *const arm_attr_tag_T2EE_use[] = {"Not Allowed", "Allowed"};
static const char *const arm_attr_tag_Virtualization_use[] =
  {"Not Allowed", "TrustZone", "Virtualization Extensions",
    "TrustZone and Virtualization Extensions"};
static const char *const arm_attr_tag_MPextension_use_legacy[] =
  {"Not Allowed", "Allowed"};

static const char *const arm_attr_tag_MVE_arch[] =
  {"No MVE", "MVE Integer only", "MVE Integer and FP"};

static const char * arm_attr_tag_PAC_extension[] =
  {"No PAC/AUT instructions",
   "PAC/AUT instructions permitted in the NOP space",
   "PAC/AUT instructions permitted in the NOP and in the non-NOP space"};

static const char * arm_attr_tag_BTI_extension[] =
  {"BTI instructions not permitted",
   "BTI instructions permitted in the NOP space",
   "BTI instructions permitted in the NOP and in the non-NOP space"};

static const char * arm_attr_tag_BTI_use[] =
  {"Compiled without branch target enforcement",
   "Compiled with branch target enforcement"};

static const char * arm_attr_tag_PACRET_use[] =
  {"Compiled without return address signing and authentication",
   "Compiled with return address signing and authentication"};



static arm_attr_public_tag arm_attr_public_tags[] =
{
  {4, "CPU_raw_name", 1, 
# 16978 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 16978 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            },
  {5, "CPU_name", 1, 
# 16979 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 16979 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        },
  {6, "CPU_arch", 0x80 | (sizeof (arm_attr_tag_CPU_arch) / sizeof ((arm_attr_tag_CPU_arch)[0])), arm_attr_tag_CPU_arch},
  {7, "CPU_arch_profile", 0, 
# 16981 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            ((void *)0)
# 16981 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                },
  {8, "ARM_ISA_use", 0x80 | (sizeof (arm_attr_tag_ARM_ISA_use) / sizeof ((arm_attr_tag_ARM_ISA_use)[0])), arm_attr_tag_ARM_ISA_use},
  {9, "THUMB_ISA_use", 0x80 | (sizeof (arm_attr_tag_THUMB_ISA_use) / sizeof ((arm_attr_tag_THUMB_ISA_use)[0])), arm_attr_tag_THUMB_ISA_use},
  {10, "FP_arch", 0x80 | (sizeof (arm_attr_tag_FP_arch) / sizeof ((arm_attr_tag_FP_arch)[0])), arm_attr_tag_FP_arch},
  {11, "WMMX_arch", 0x80 | (sizeof (arm_attr_tag_WMMX_arch) / sizeof ((arm_attr_tag_WMMX_arch)[0])), arm_attr_tag_WMMX_arch},
  {12, "Advanced_SIMD_arch", 0x80 | (sizeof (arm_attr_tag_Advanced_SIMD_arch) / sizeof ((arm_attr_tag_Advanced_SIMD_arch)[0])), arm_attr_tag_Advanced_SIMD_arch},
  {13, "PCS_config", 0x80 | (sizeof (arm_attr_tag_PCS_config) / sizeof ((arm_attr_tag_PCS_config)[0])), arm_attr_tag_PCS_config},
  {14, "ABI_PCS_R9_use", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_R9_use) / sizeof ((arm_attr_tag_ABI_PCS_R9_use)[0])), arm_attr_tag_ABI_PCS_R9_use},
  {15, "ABI_PCS_RW_data", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_RW_data) / sizeof ((arm_attr_tag_ABI_PCS_RW_data)[0])), arm_attr_tag_ABI_PCS_RW_data},
  {16, "ABI_PCS_RO_data", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_RO_data) / sizeof ((arm_attr_tag_ABI_PCS_RO_data)[0])), arm_attr_tag_ABI_PCS_RO_data},
  {17, "ABI_PCS_GOT_use", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_GOT_use) / sizeof ((arm_attr_tag_ABI_PCS_GOT_use)[0])), arm_attr_tag_ABI_PCS_GOT_use},
  {18, "ABI_PCS_wchar_t", 0x80 | (sizeof (arm_attr_tag_ABI_PCS_wchar_t) / sizeof ((arm_attr_tag_ABI_PCS_wchar_t)[0])), arm_attr_tag_ABI_PCS_wchar_t},
  {19, "ABI_FP_rounding", 0x80 | (sizeof (arm_attr_tag_ABI_FP_rounding) / sizeof ((arm_attr_tag_ABI_FP_rounding)[0])), arm_attr_tag_ABI_FP_rounding},
  {20, "ABI_FP_denormal", 0x80 | (sizeof (arm_attr_tag_ABI_FP_denormal) / sizeof ((arm_attr_tag_ABI_FP_denormal)[0])), arm_attr_tag_ABI_FP_denormal},
  {21, "ABI_FP_exceptions", 0x80 | (sizeof (arm_attr_tag_ABI_FP_exceptions) / sizeof ((arm_attr_tag_ABI_FP_exceptions)[0])), arm_attr_tag_ABI_FP_exceptions},
  {22, "ABI_FP_user_exceptions", 0x80 | (sizeof (arm_attr_tag_ABI_FP_user_exceptions) / sizeof ((arm_attr_tag_ABI_FP_user_exceptions)[0])), arm_attr_tag_ABI_FP_user_exceptions},
  {23, "ABI_FP_number_model", 0x80 | (sizeof (arm_attr_tag_ABI_FP_number_model) / sizeof ((arm_attr_tag_ABI_FP_number_model)[0])), arm_attr_tag_ABI_FP_number_model},
  {24, "ABI_align_needed", 0, 
# 16998 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             ((void *)0)
# 16998 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 },
  {25, "ABI_align_preserved", 0, 
# 16999 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                ((void *)0)
# 16999 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    },
  {26, "ABI_enum_size", 0x80 | (sizeof (arm_attr_tag_ABI_enum_size) / sizeof ((arm_attr_tag_ABI_enum_size)[0])), arm_attr_tag_ABI_enum_size},
  {27, "ABI_HardFP_use", 0x80 | (sizeof (arm_attr_tag_ABI_HardFP_use) / sizeof ((arm_attr_tag_ABI_HardFP_use)[0])), arm_attr_tag_ABI_HardFP_use},
  {28, "ABI_VFP_args", 0x80 | (sizeof (arm_attr_tag_ABI_VFP_args) / sizeof ((arm_attr_tag_ABI_VFP_args)[0])), arm_attr_tag_ABI_VFP_args},
  {29, "ABI_WMMX_args", 0x80 | (sizeof (arm_attr_tag_ABI_WMMX_args) / sizeof ((arm_attr_tag_ABI_WMMX_args)[0])), arm_attr_tag_ABI_WMMX_args},
  {30, "ABI_optimization_goals", 0x80 | (sizeof (arm_attr_tag_ABI_optimization_goals) / sizeof ((arm_attr_tag_ABI_optimization_goals)[0])), arm_attr_tag_ABI_optimization_goals},
  {31, "ABI_FP_optimization_goals", 0x80 | (sizeof (arm_attr_tag_ABI_FP_optimization_goals) / sizeof ((arm_attr_tag_ABI_FP_optimization_goals)[0])), arm_attr_tag_ABI_FP_optimization_goals},
  {32, "compatibility", 0, 
# 17006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          ((void *)0)
# 17006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              },
  {34, "CPU_unaligned_access", 0x80 | (sizeof (arm_attr_tag_CPU_unaligned_access) / sizeof ((arm_attr_tag_CPU_unaligned_access)[0])), arm_attr_tag_CPU_unaligned_access},
  {36, "FP_HP_extension", 0x80 | (sizeof (arm_attr_tag_FP_HP_extension) / sizeof ((arm_attr_tag_FP_HP_extension)[0])), arm_attr_tag_FP_HP_extension},
  {38, "ABI_FP_16bit_format", 0x80 | (sizeof (arm_attr_tag_ABI_FP_16bit_format) / sizeof ((arm_attr_tag_ABI_FP_16bit_format)[0])), arm_attr_tag_ABI_FP_16bit_format},
  {42, "MPextension_use", 0x80 | (sizeof (arm_attr_tag_MPextension_use) / sizeof ((arm_attr_tag_MPextension_use)[0])), arm_attr_tag_MPextension_use},
  {44, "DIV_use", 0x80 | (sizeof (arm_attr_tag_DIV_use) / sizeof ((arm_attr_tag_DIV_use)[0])), arm_attr_tag_DIV_use},
  {46, "DSP_extension", 0x80 | (sizeof (arm_attr_tag_DSP_extension) / sizeof ((arm_attr_tag_DSP_extension)[0])), arm_attr_tag_DSP_extension},
  {48, "MVE_arch", 0x80 | (sizeof (arm_attr_tag_MVE_arch) / sizeof ((arm_attr_tag_MVE_arch)[0])), arm_attr_tag_MVE_arch},
  {50, "PAC_extension", 0x80 | (sizeof (arm_attr_tag_PAC_extension) / sizeof ((arm_attr_tag_PAC_extension)[0])), arm_attr_tag_PAC_extension},
  {52, "BTI_extension", 0x80 | (sizeof (arm_attr_tag_BTI_extension) / sizeof ((arm_attr_tag_BTI_extension)[0])), arm_attr_tag_BTI_extension},
  {74, "BTI_use", 0x80 | (sizeof (arm_attr_tag_BTI_use) / sizeof ((arm_attr_tag_BTI_use)[0])), arm_attr_tag_BTI_use},
  {76, "PACRET_use", 0x80 | (sizeof (arm_attr_tag_PACRET_use) / sizeof ((arm_attr_tag_PACRET_use)[0])), arm_attr_tag_PACRET_use},
  {64, "nodefaults", 0, 
# 17018 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 17018 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           },
  {65, "also_compatible_with", 0, 
# 17019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 ((void *)0)
# 17019 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     },
  {66, "T2EE_use", 0x80 | (sizeof (arm_attr_tag_T2EE_use) / sizeof ((arm_attr_tag_T2EE_use)[0])), arm_attr_tag_T2EE_use},
  {67, "conformance", 1, 
# 17021 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 17021 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            },
  {68, "Virtualization_use", 0x80 | (sizeof (arm_attr_tag_Virtualization_use) / sizeof ((arm_attr_tag_Virtualization_use)[0])), arm_attr_tag_Virtualization_use},
  {70, "MPextension_use_legacy", 0x80 | (sizeof (arm_attr_tag_MPextension_use_legacy) / sizeof ((arm_attr_tag_MPextension_use_legacy)[0])), arm_attr_tag_MPextension_use_legacy}
};


static unsigned char *
display_arm_attribute (unsigned char * p,
         const unsigned char * const end)
{
  unsigned int tag;
  unsigned int val;
  arm_attr_public_tag * attr;
  unsigned i;
  unsigned int type;

  do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17037 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 0
# 17037 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 , &_len, &_status); p += _len; (tag) = _val; if ((tag) != _val) _status |= 2; report_leb_status (_status); } while (0);
  attr = 
# 17038 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 17038 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
  for (i = 0; i < (sizeof (arm_attr_public_tags) / sizeof ((arm_attr_public_tags)[0])); i++)
    {
      if (arm_attr_public_tags[i].tag == tag)
 {
   attr = &arm_attr_public_tags[i];
   break;
 }
    }

  if (attr)
    {
      printf ("  Tag_%s: ", attr->name);
      switch (attr->type)
 {
 case 0:
   switch (tag)
     {
     case 7:
       do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17057 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 17057 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
       switch (val)
  {
  case 0: printf (gettext ("None\n")); break;
  case 'A': printf (gettext ("Application\n")); break;
  case 'R': printf (gettext ("Realtime\n")); break;
  case 'M': printf (gettext ("Microcontroller\n")); break;
  case 'S': printf (gettext ("Application or Realtime\n")); break;
  default: printf ("??? (%d)\n", val); break;
  }
       break;

     case 24:
       do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17070 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 17070 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
       switch (val)
  {
  case 0: printf (gettext ("None\n")); break;
  case 1: printf (gettext ("8-byte\n")); break;
  case 2: printf (gettext ("4-byte\n")); break;
  case 3: printf ("??? 3\n"); break;
  default:
    if (val <= 12)
      printf (gettext ("8-byte and up to %d-byte extended\n"),
       1 << val);
    else
      printf ("??? (%d)\n", val);
    break;
  }
       break;

     case 25:
       do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 17088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
       switch (val)
  {
  case 0: printf (gettext ("None\n")); break;
  case 1: printf (gettext ("8-byte, except leaf SP\n")); break;
  case 2: printf (gettext ("8-byte\n")); break;
  case 3: printf ("??? 3\n"); break;
  default:
    if (val <= 12)
      printf (gettext ("8-byte and up to %d-byte extended\n"),
       1 << val);
    else
      printf ("??? (%d)\n", val);
    break;
  }
       break;

     case 32:
       {
  do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17107 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 0
# 17107 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
  printf (gettext ("flag = %d, vendor = "), val);
  if (p < end - 1)
    {
      size_t maxlen = (end - p) - 1;

      print_symbol ((int) maxlen, (const char *) p);
      p += strnlen ((char *) p, maxlen) + 1;
    }
  else
    {
      printf (gettext ("<corrupt>"));
      p = (unsigned char *) end;
    }
  putchar ('\n');
       }
       break;

     case 64:

       if (p < end)
  p++;
       printf (gettext ("True\n"));
       break;

     case 65:
       do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17133 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 17133 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
       if (val == 6 )
  {
    do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17136 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
   0
# 17136 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
   , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
    if ((unsigned int) val >= (sizeof (arm_attr_tag_CPU_arch) / sizeof ((arm_attr_tag_CPU_arch)[0])))
      printf ("??? (%d)\n", val);
    else
      printf ("%s\n", arm_attr_tag_CPU_arch[val]);
  }
       else
  printf ("???\n");
       while (p < end && *(p++) != '\0' )
  ;
       break;

     default:
       printf (gettext ("<unknown: %d>\n"), tag);
       break;
     }
   return p;

 case 1:
   return display_tag_value (-1, p, end);
 case 2:
   return display_tag_value (0, p, end);

 default:
   
# 17160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ((void) sizeof ((
# 17160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  attr->type & 0x80
# 17160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ) ? 1 : 0), __extension__ ({ if (
# 17160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  attr->type & 0x80
# 17160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  ) ; else __assert_fail (
# 17160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  "attr->type & 0x80"
# 17160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 17160, __extension__ __PRETTY_FUNCTION__); }))
# 17160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            ;
   do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17161 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 17161 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
   type = attr->type & 0x7f;
   if (val >= type)
     printf ("??? (%d)\n", val);
   else
     printf ("%s\n", attr->table[val]);
   return p;
 }
    }

  return display_tag_value (tag, p, end);
}

static unsigned char *
display_gnu_attribute (unsigned char * p,
         unsigned char * (* display_proc_gnu_attribute) (unsigned char *, unsigned int, const unsigned char * const),
         const unsigned char * const end)
{
  unsigned int tag;
  unsigned int val;

  do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17182 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 0
# 17182 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 , &_len, &_status); p += _len; (tag) = _val; if ((tag) != _val) _status |= 2; report_leb_status (_status); } while (0);



  if (tag == 32)
    {
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17188 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17188 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);

      printf (gettext ("flag = %d, vendor = "), val);
      if (p == end)
 {
   printf (gettext ("<corrupt>\n"));
   warn (gettext ("corrupt vendor attribute\n"));
 }
      else
 {
   if (p < end - 1)
     {
       size_t maxlen = (end - p) - 1;

       print_symbol ((int) maxlen, (const char *) p);
       p += strnlen ((char *) p, maxlen) + 1;
     }
   else
     {
       printf (gettext ("<corrupt>"));
       p = (unsigned char *) end;
     }
   putchar ('\n');
 }
      return p;
    }

  if ((tag & 2) == 0 && display_proc_gnu_attribute)
    return display_proc_gnu_attribute (p, tag, end);

  return display_tag_value (tag, p, end);
}

static unsigned char *
display_m68k_gnu_attribute (unsigned char * p,
       unsigned int tag,
       const unsigned char * const end)
{
  unsigned int val;

  if (tag == Tag_GNU_M68K_ABI_FP)
    {
      printf ("  Tag_GNU_M68K_ABI_FP: ");
      if (p == end)
 {
   printf (gettext ("<corrupt>\n"));
   return p;
 }
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17236 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17236 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);

      if (val > 3)
 printf ("(%#x), ", val);

      switch (val & 3)
 {
 case 0:
   printf (gettext ("unspecified hard/soft float\n"));
   break;
 case 1:
   printf (gettext ("hard float\n"));
   break;
 case 2:
   printf (gettext ("soft float\n"));
   break;
 }
      return p;
    }

  return display_tag_value (tag & 1, p, end);
}

static unsigned char *
display_power_gnu_attribute (unsigned char * p,
        unsigned int tag,
        const unsigned char * const end)
{
  unsigned int val;

  if (tag == Tag_GNU_Power_ABI_FP)
    {
      printf ("  Tag_GNU_Power_ABI_FP: ");
      if (p == end)
 {
   printf (gettext ("<corrupt>\n"));
   return p;
 }
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17274 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17274 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);

      if (val > 15)
 printf ("(%#x), ", val);

      switch (val & 3)
 {
 case 0:
   printf (gettext ("unspecified hard/soft float, "));
   break;
 case 1:
   printf (gettext ("hard float, "));
   break;
 case 2:
   printf (gettext ("soft float, "));
   break;
 case 3:
   printf (gettext ("single-precision hard float, "));
   break;
 }

      switch (val & 0xC)
 {
 case 0:
   printf (gettext ("unspecified long double\n"));
   break;
 case 4:
   printf (gettext ("128-bit IBM long double\n"));
   break;
 case 8:
   printf (gettext ("64-bit long double\n"));
   break;
 case 12:
   printf (gettext ("128-bit IEEE long double\n"));
   break;
 }
      return p;
    }

  if (tag == Tag_GNU_Power_ABI_Vector)
    {
      printf ("  Tag_GNU_Power_ABI_Vector: ");
      if (p == end)
 {
   printf (gettext ("<corrupt>\n"));
   return p;
 }
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17321 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17321 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);

      if (val > 3)
 printf ("(%#x), ", val);

      switch (val & 3)
 {
 case 0:
   printf (gettext ("unspecified\n"));
   break;
 case 1:
   printf (gettext ("generic\n"));
   break;
 case 2:
   printf ("AltiVec\n");
   break;
 case 3:
   printf ("SPE\n");
   break;
 }
      return p;
    }

  if (tag == Tag_GNU_Power_ABI_Struct_Return)
    {
      printf ("  Tag_GNU_Power_ABI_Struct_Return: ");
      if (p == end)
 {
   printf (gettext ("<corrupt>\n"));
   return p;
 }
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17352 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17352 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);

      if (val > 2)
 printf ("(%#x), ", val);

      switch (val & 3)
 {
 case 0:
   printf (gettext ("unspecified\n"));
   break;
 case 1:
   printf ("r3/r4\n");
   break;
 case 2:
   printf (gettext ("memory\n"));
   break;
 case 3:
   printf ("???\n");
   break;
 }
      return p;
    }

  return display_tag_value (tag & 1, p, end);
}

static unsigned char *
display_s390_gnu_attribute (unsigned char * p,
       unsigned int tag,
       const unsigned char * const end)
{
  unsigned int val;

  if (tag == Tag_GNU_S390_ABI_Vector)
    {
      printf ("  Tag_GNU_S390_ABI_Vector: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17388 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17388 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);

      switch (val)
 {
 case 0:
   printf (gettext ("any\n"));
   break;
 case 1:
   printf (gettext ("software\n"));
   break;
 case 2:
   printf (gettext ("hardware\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;
   }

  return display_tag_value (tag & 1, p, end);
}

static void
display_sparc_hwcaps (unsigned int mask)
{
  if (mask)
    {
      
# 17416 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 17416 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          first = 
# 17416 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  1
# 17416 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;

      if (mask & 0x00000001)
 fputs ("mul32", 
# 17419 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                stdout
# 17419 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ), first = 
# 17419 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 0
# 17419 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      ;
      if (mask & 0x00000002)
 printf ("%sdiv32", first ? "" : "|"), first = 
# 17421 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              0
# 17421 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   ;
      if (mask & 0x00000004)
 printf ("%sfsmuld", first ? "" : "|"), first = 
# 17423 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               0
# 17423 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    ;
      if (mask & 0x00000008)
 printf ("%sv8plus", first ? "" : "|"), first = 
# 17425 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               0
# 17425 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    ;
      if (mask & 0x00000010)
 printf ("%spopc", first ? "" : "|"), first = 
# 17427 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             0
# 17427 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  ;
      if (mask & 0x00000020)
 printf ("%svis", first ? "" : "|"), first = 
# 17429 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                            0
# 17429 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                 ;
      if (mask & 0x00000040)
 printf ("%svis2", first ? "" : "|"), first = 
# 17431 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             0
# 17431 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  ;
      if (mask & 0x00000080)
 printf ("%sASIBlkInit", first ? "" : "|"), first = 
# 17433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                   0
# 17433 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                        ;
      if (mask & 0x00000100)
 printf ("%sfmaf", first ? "" : "|"), first = 
# 17435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             0
# 17435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  ;
      if (mask & 0x00000400)
 printf ("%svis3", first ? "" : "|"), first = 
# 17437 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             0
# 17437 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  ;
      if (mask & 0x00000800)
 printf ("%shpc", first ? "" : "|"), first = 
# 17439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                            0
# 17439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                 ;
      if (mask & 0x00001000)
 printf ("%srandom", first ? "" : "|"), first = 
# 17441 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               0
# 17441 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    ;
      if (mask & 0x00002000)
 printf ("%strans", first ? "" : "|"), first = 
# 17443 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              0
# 17443 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   ;
      if (mask & 0x00004000)
 printf ("%sfjfmau", first ? "" : "|"), first = 
# 17445 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               0
# 17445 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    ;
      if (mask & 0x00008000)
 printf ("%sima", first ? "" : "|"), first = 
# 17447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                            0
# 17447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                 ;
      if (mask & 0x00010000)
 printf ("%scspare", first ? "" : "|"), first = 
# 17449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               0
# 17449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    ;
    }
  else
    fputc ('0', 
# 17452 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               stdout
# 17452 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     );
  fputc ('\n', 
# 17453 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              stdout
# 17453 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    );
}

static void
display_sparc_hwcaps2 (unsigned int mask)
{
  if (mask)
    {
      
# 17461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     _Bool 
# 17461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          first = 
# 17461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  1
# 17461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;

      if (mask & 0x00000001)
 fputs ("fjathplus", 
# 17464 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    stdout
# 17464 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ), first = 
# 17464 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     0
# 17464 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ;
      if (mask & 0x00000002)
 printf ("%svis3b", first ? "" : "|"), first = 
# 17466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              0
# 17466 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   ;
      if (mask & 0x00000004)
 printf ("%sadp", first ? "" : "|"), first = 
# 17468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                            0
# 17468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                 ;
      if (mask & 0x00000008)
 printf ("%ssparc5", first ? "" : "|"), first = 
# 17470 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               0
# 17470 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    ;
      if (mask & 0x00000010)
 printf ("%smwait", first ? "" : "|"), first = 
# 17472 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              0
# 17472 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   ;
      if (mask & 0x00000020)
 printf ("%sxmpmul", first ? "" : "|"), first = 
# 17474 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               0
# 17474 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    ;
      if (mask & 0x00000040)
 printf ("%sxmont2", first ? "" : "|"), first = 
# 17476 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               0
# 17476 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    ;
      if (mask & 0x00000080)
 printf ("%snsec", first ? "" : "|"), first = 
# 17478 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             0
# 17478 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  ;
      if (mask & 0x00001000)
 printf ("%sfjathhpc", first ? "" : "|"), first = 
# 17480 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                 0
# 17480 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                      ;
      if (mask & 0x00002000)
 printf ("%sfjdes", first ? "" : "|"), first = 
# 17482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              0
# 17482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   ;
      if (mask & 0x00010000)
 printf ("%sfjaes", first ? "" : "|"), first = 
# 17484 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              0
# 17484 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   ;
    }
  else
    fputc ('0', 
# 17487 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               stdout
# 17487 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     );
  fputc ('\n', 
# 17488 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              stdout
# 17488 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    );
}

static unsigned char *
display_sparc_gnu_attribute (unsigned char * p,
        unsigned int tag,
        const unsigned char * const end)
{
  unsigned int val;

  if (tag == Tag_GNU_Sparc_HWCAPS)
    {
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_GNU_Sparc_HWCAPS: ");
      display_sparc_hwcaps (val);
      return p;
    }
  if (tag == Tag_GNU_Sparc_HWCAPS2)
    {
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17507 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17507 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_GNU_Sparc_HWCAPS2: ");
      display_sparc_hwcaps2 (val);
      return p;
    }

  return display_tag_value (tag, p, end);
}

static void
print_mips_fp_abi_value (unsigned int val)
{
  switch (val)
    {
    case Val_GNU_MIPS_ABI_FP_ANY:
      printf (gettext ("Hard or soft float\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_DOUBLE:
      printf (gettext ("Hard float (double precision)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_SINGLE:
      printf (gettext ("Hard float (single precision)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_SOFT:
      printf (gettext ("Soft float\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_OLD_64:
      printf (gettext ("Hard float (MIPS32r2 64-bit FPU 12 callee-saved)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_XX:
      printf (gettext ("Hard float (32-bit CPU, Any FPU)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_64:
      printf (gettext ("Hard float (32-bit CPU, 64-bit FPU)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_64A:
      printf (gettext ("Hard float compat (32-bit CPU, 64-bit FPU)\n"));
      break;
    case Val_GNU_MIPS_ABI_FP_NAN2008:
      printf (gettext ("NaN 2008 compatibility\n"));
      break;
    default:
      printf ("??? (%d)\n", val);
      break;
    }
}

static unsigned char *
display_mips_gnu_attribute (unsigned char * p,
       unsigned int tag,
       const unsigned char * const end)
{
  if (tag == Tag_GNU_MIPS_ABI_FP)
    {
      unsigned int val;

      printf ("  Tag_GNU_MIPS_ABI_FP: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17564 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17564 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      print_mips_fp_abi_value (val);
      return p;
   }

  if (tag == Tag_GNU_MIPS_ABI_MSA)
    {
      unsigned int val;

      printf ("  Tag_GNU_MIPS_ABI_MSA: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17574 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17574 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);

      switch (val)
 {
 case Val_GNU_MIPS_ABI_MSA_ANY:
   printf (gettext ("Any MSA or not\n"));
   break;
 case Val_GNU_MIPS_ABI_MSA_128:
   printf (gettext ("128-bit MSA\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;
    }

  return display_tag_value (tag & 1, p, end);
}

static unsigned char *
display_tic6x_attribute (unsigned char * p,
    const unsigned char * const end)
{
  unsigned int tag;
  unsigned int val;

  do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17601 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 0
# 17601 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 , &_len, &_status); p += _len; (tag) = _val; if ((tag) != _val) _status |= 2; report_leb_status (_status); } while (0);

  switch (tag)
    {
    case Tag_ISA:
      printf ("  Tag_ISA: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17607 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17607 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);

      switch (val)
 {
 case C6XABI_Tag_ISA_none:
   printf (gettext ("None\n"));
   break;
 case C6XABI_Tag_ISA_C62X:
   printf ("C62x\n");
   break;
 case C6XABI_Tag_ISA_C67X:
   printf ("C67x\n");
   break;
 case C6XABI_Tag_ISA_C67XP:
   printf ("C67x+\n");
   break;
 case C6XABI_Tag_ISA_C64X:
   printf ("C64x\n");
   break;
 case C6XABI_Tag_ISA_C64XP:
   printf ("C64x+\n");
   break;
 case C6XABI_Tag_ISA_C674X:
   printf ("C674x\n");
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_wchar_t:
      printf ("  Tag_ABI_wchar_t: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17640 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17640 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      switch (val)
 {
 case 0:
   printf (gettext ("Not used\n"));
   break;
 case 1:
   printf (gettext ("2 bytes\n"));
   break;
 case 2:
   printf (gettext ("4 bytes\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_stack_align_needed:
      printf ("  Tag_ABI_stack_align_needed: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17660 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17660 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      switch (val)
 {
 case 0:
   printf (gettext ("8-byte\n"));
   break;
 case 1:
   printf (gettext ("16-byte\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_stack_align_preserved:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17676 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17676 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ABI_stack_align_preserved: ");
      switch (val)
 {
 case 0:
   printf (gettext ("8-byte\n"));
   break;
 case 1:
   printf (gettext ("16-byte\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_DSBT:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17693 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17693 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ABI_DSBT: ");
      switch (val)
 {
 case 0:
   printf (gettext ("DSBT addressing not used\n"));
   break;
 case 1:
   printf (gettext ("DSBT addressing used\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_PID:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17710 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17710 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ABI_PID: ");
      switch (val)
 {
 case 0:
   printf (gettext ("Data addressing position-dependent\n"));
   break;
 case 1:
   printf (gettext ("Data addressing position-independent, GOT near DP\n"));
   break;
 case 2:
   printf (gettext ("Data addressing position-independent, GOT far from DP\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_PIC:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17730 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17730 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ABI_PIC: ");
      switch (val)
 {
 case 0:
   printf (gettext ("Code addressing position-dependent\n"));
   break;
 case 1:
   printf (gettext ("Code addressing position-independent\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_array_object_alignment:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17747 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17747 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ABI_array_object_alignment: ");
      switch (val)
 {
 case 0:
   printf (gettext ("8-byte\n"));
   break;
 case 1:
   printf (gettext ("4-byte\n"));
   break;
 case 2:
   printf (gettext ("16-byte\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_array_object_align_expected:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17767 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17767 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("  Tag_ABI_array_object_align_expected: ");
      switch (val)
 {
 case 0:
   printf (gettext ("8-byte\n"));
   break;
 case 1:
   printf (gettext ("4-byte\n"));
   break;
 case 2:
   printf (gettext ("16-byte\n"));
   break;
 default:
   printf ("??? (%d)\n", val);
   break;
 }
      return p;

    case Tag_ABI_compatibility:
      {
 do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17788 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
0
# 17788 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
, &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
 printf ("  Tag_ABI_compatibility: ");
 printf (gettext ("flag = %d, vendor = "), val);
 if (p < end - 1)
   {
     size_t maxlen = (end - p) - 1;

     print_symbol ((int) maxlen, (const char *) p);
     p += strnlen ((char *) p, maxlen) + 1;
   }
 else
   {
     printf (gettext ("<corrupt>"));
     p = (unsigned char *) end;
   }
 putchar ('\n');
 return p;
      }

    case Tag_ABI_conformance:
      {
 printf ("  Tag_ABI_conformance: \"");
 if (p < end - 1)
   {
     size_t maxlen = (end - p) - 1;

     print_symbol ((int) maxlen, (const char *) p);
     p += strnlen ((char *) p, maxlen) + 1;
   }
 else
   {
     printf (gettext ("<corrupt>"));
     p = (unsigned char *) end;
   }
 printf ("\"\n");
 return p;
      }
    }

  return display_tag_value (tag, p, end);
}

static void
display_raw_attribute (unsigned char * p, unsigned char const * const end)
{
  uint64_t addr = 0;
  size_t bytes = end - p;

  
# 17836 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 ((void) sizeof ((
# 17836 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 end >= p
# 17836 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 17836 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 end >= p
# 17836 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 ) ; else __assert_fail (
# 17836 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 "end >= p"
# 17836 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 17836, __extension__ __PRETTY_FUNCTION__); }))
# 17836 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
  while (bytes)
    {
      int j;
      int k;
      int lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8" 
# 17843 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        "l" "x" 
# 17843 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               " ", addr);

      for (j = 0; j < 16; j++)
 {
   if (j < lbytes)
     printf ("%2.2x", p[j]);
   else
     printf ("  ");

   if ((j & 3) == 3)
     printf (" ");
 }

      for (j = 0; j < lbytes; j++)
 {
   k = p[j];
   if (k >= ' ' && k < 0x7f)
     printf ("%c", k);
   else
     printf (".");
 }

      putchar ('\n');

      p += lbytes;
      bytes -= lbytes;
      addr += lbytes;
    }

  putchar ('\n');
}

static unsigned char *
display_msp430_attribute (unsigned char * p,
     const unsigned char * const end)
{
  uint64_t val;
  uint64_t tag;

  do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 0
# 17882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 , &_len, &_status); p += _len; (tag) = _val; if ((tag) != _val) _status |= 2; report_leb_status (_status); } while (0);

  switch (tag)
    {
    case 4:
      printf ("  Tag_ISA: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17888 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17888 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      switch (val)
 {
 case 0: printf (gettext ("None\n")); break;
 case 1: printf (gettext ("MSP430\n")); break;
 case 2: printf (gettext ("MSP430X\n")); break;
 default: printf ("??? (%" 
# 17894 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          "l" "d" 
# 17894 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 ")\n", val); break;
 }
      break;

    case 6:
      printf ("  Tag_Code_Model: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17900 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17900 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      switch (val)
 {
 case 0: printf (gettext ("None\n")); break;
 case 1: printf (gettext ("Small\n")); break;
 case 2: printf (gettext ("Large\n")); break;
 default: printf ("??? (%" 
# 17906 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          "l" "d" 
# 17906 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 ")\n", val); break;
 }
      break;

    case 8:
      printf ("  Tag_Data_Model: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17912 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17912 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      switch (val)
 {
 case 0: printf (gettext ("None\n")); break;
 case 1: printf (gettext ("Small\n")); break;
 case 2: printf (gettext ("Large\n")); break;
 case 3: printf (gettext ("Restricted Large\n")); break;
 default: printf ("??? (%" 
# 17919 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          "l" "d" 
# 17919 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 ")\n", val); break;
 }
      break;

    default:
      printf (gettext ("  <unknown tag %" 
# 17924 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "d" 
# 17924 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ">: "), tag);

      if (tag & 1)
 {
   putchar ('"');
   if (p < end - 1)
     {
       size_t maxlen = (end - p) - 1;

       print_symbol ((int) maxlen, (const char *) p);
       p += strnlen ((char *) p, maxlen) + 1;
     }
   else
     {
       printf (gettext ("<corrupt>"));
       p = (unsigned char *) end;
     }
   printf ("\"\n");
 }
      else
 {
   do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17945 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  0
# 17945 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
   printf ("%" 
# 17946 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              "l" "d" 
# 17946 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     " (0x%" 
# 17946 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             "l" "x" 
# 17946 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    ")\n", val, val);
 }
      break;
   }

  
# 17951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 ((void) sizeof ((
# 17951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 p <= end
# 17951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 ) ? 1 : 0), __extension__ ({ if (
# 17951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 p <= end
# 17951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 ) ; else __assert_fail (
# 17951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 "p <= end"
# 17951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 17951, __extension__ __PRETTY_FUNCTION__); }))
# 17951 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
  return p;
}

static unsigned char *
display_msp430_gnu_attribute (unsigned char * p,
         unsigned int tag,
         const unsigned char * const end)
{
  if (tag == Tag_GNU_MSP430_Data_Region)
    {
      uint64_t val;

      printf ("  Tag_GNU_MSP430_Data_Region: ");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 17965 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 17965 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);

      switch (val)
 {
 case Val_GNU_MSP430_Data_Region_Any:
   printf (gettext ("Any Region\n"));
   break;
 case Val_GNU_MSP430_Data_Region_Lower:
   printf (gettext ("Lower Region Only\n"));
   break;
 default:
   printf ("??? (%" 
# 17976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   "l" "u" 
# 17976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          ")\n", val);
 }
      return p;
    }
  return display_tag_value (tag & 1, p, end);
}

struct riscv_attr_tag_t {
  const char *name;
  unsigned int tag;
};

static struct riscv_attr_tag_t riscv_attr_tag[] =
{

  {"Tag_RISCV_" "arch", Tag_RISCV_arch},
  {"Tag_RISCV_" "priv_spec", Tag_RISCV_priv_spec},
  {"Tag_RISCV_" "priv_spec_minor", Tag_RISCV_priv_spec_minor},
  {"Tag_RISCV_" "priv_spec_revision", Tag_RISCV_priv_spec_revision},
  {"Tag_RISCV_" "unaligned_access", Tag_RISCV_unaligned_access},
  {"Tag_RISCV_" "stack_align", Tag_RISCV_stack_align},

};

static unsigned char *
display_riscv_attribute (unsigned char *p,
    const unsigned char * const end)
{
  uint64_t val;
  uint64_t tag;
  struct riscv_attr_tag_t *attr = 
# 18006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 ((void *)0)
# 18006 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     ;
  unsigned i;

  do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18009 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 0
# 18009 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 , &_len, &_status); p += _len; (tag) = _val; if ((tag) != _val) _status |= 2; report_leb_status (_status); } while (0);


  for (i = 0; i < (sizeof (riscv_attr_tag) / sizeof ((riscv_attr_tag)[0])); i++)
    {
      if (riscv_attr_tag[i].tag == tag)
 {
   attr = &riscv_attr_tag[i];
   break;
 }
    }

  if (attr)
    printf ("  %s: ", attr->name);
  else
    return display_tag_value (tag, p, end);

  switch (tag)
    {
    case Tag_RISCV_priv_spec:
    case Tag_RISCV_priv_spec_minor:
    case Tag_RISCV_priv_spec_revision:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18031 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18031 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("%" 
# 18032 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 "l" "u" 
# 18032 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        "\n", val);
      break;
    case Tag_RISCV_unaligned_access:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18035 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18035 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      switch (val)
 {
 case 0:
   printf (gettext ("No unaligned access\n"));
   break;
 case 1:
   printf (gettext ("Unaligned access\n"));
   break;
 }
      break;
    case Tag_RISCV_stack_align:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18047 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18047 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf (gettext ("%" 
# 18048 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "u" 
# 18048 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             "-bytes\n"), val);
      break;
    case Tag_RISCV_arch:
      p = display_tag_value (-1, p, end);
      break;
    default:
      return display_tag_value (tag, p, end);
    }

  return p;
}

static unsigned char *
display_csky_attribute (unsigned char * p,
   const unsigned char * const end)
{
  uint64_t tag;
  uint64_t val;
  do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18066 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 0
# 18066 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
 , &_len, &_status); p += _len; (tag) = _val; if ((tag) != _val) _status |= 2; report_leb_status (_status); } while (0);

  if (tag >= Tag_CSKY_MAX)
    {
      return display_tag_value (-1, p, end);
    }

  switch (tag)
    {
    case Tag_CSKY_ARCH_NAME:
      printf ("  Tag_CSKY_ARCH_NAME:\t\t");
      return display_tag_value (-1, p, end);
    case Tag_CSKY_CPU_NAME:
      printf ("  Tag_CSKY_CPU_NAME:\t\t");
      return display_tag_value (-1, p, end);

    case Tag_CSKY_ISA_FLAGS:
      printf ("  Tag_CSKY_ISA_FLAGS:\t\t");
      return display_tag_value (0, p, end);
    case Tag_CSKY_ISA_EXT_FLAGS:
      printf ("  Tag_CSKY_ISA_EXT_FLAGS:\t");
      return display_tag_value (0, p, end);

    case Tag_CSKY_DSP_VERSION:
      printf ("  Tag_CSKY_DSP_VERSION:\t\t");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18091 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18091 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      if (val == VAL_CSKY_DSP_VERSION_EXTENSION)
 printf ("DSP Extension\n");
      else if (val == VAL_CSKY_DSP_VERSION_2)
 printf ("DSP 2.0\n");
      break;

    case Tag_CSKY_VDSP_VERSION:
      printf ("  Tag_CSKY_VDSP_VERSION:\t");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18100 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18100 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      printf ("VDSP Version %" 
# 18101 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              "l" "d" 
# 18101 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     "\n", val);
      break;

    case Tag_CSKY_FPU_VERSION:
      printf ("  Tag_CSKY_FPU_VERSION:\t\t");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      if (val == VAL_CSKY_FPU_VERSION_1)
 printf ("ABIV1 FPU Version 1\n");
      else if (val == VAL_CSKY_FPU_VERSION_2)
 printf ("FPU Version 2\n");
      break;

    case Tag_CSKY_FPU_ABI:
      printf ("  Tag_CSKY_FPU_ABI:\t\t");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18115 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18115 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      if (val == VAL_CSKY_FPU_ABI_HARD)
 printf ("Hard\n");
      else if (val == VAL_CSKY_FPU_ABI_SOFTFP)
 printf ("SoftFP\n");
      else if (val == VAL_CSKY_FPU_ABI_SOFT)
 printf ("Soft\n");
      break;
    case Tag_CSKY_FPU_ROUNDING:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18124 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18124 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      if (val == 1)
 {
   printf ("  Tag_CSKY_FPU_ROUNDING:\t");
   printf ("Needed\n");
 }
      break;
    case Tag_CSKY_FPU_DENORMAL:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18132 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18132 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      if (val == 1)
 {
   printf ("  Tag_CSKY_FPU_DENORMAL:\t");
   printf ("Needed\n");
 }
      break;
    case Tag_CSKY_FPU_Exception:
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18140 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18140 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      if (val == 1)
 {
   printf ("  Tag_CSKY_FPU_Exception:\t");
   printf ("Needed\n");
 }
      break;
    case Tag_CSKY_FPU_NUMBER_MODULE:
      printf ("  Tag_CSKY_FPU_NUMBER_MODULE:\t");
      return display_tag_value (-1, p, end);
    case Tag_CSKY_FPU_HARDFP:
      printf ("  Tag_CSKY_FPU_HARDFP:\t\t");
      do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18152 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     0
# 18152 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
      if (val & VAL_CSKY_FPU_HARDFP_HALF)
 printf (" Half");
      if (val & VAL_CSKY_FPU_HARDFP_SINGLE)
 printf (" Single");
      if (val & VAL_CSKY_FPU_HARDFP_DOUBLE)
 printf (" Double");
      printf ("\n");
      break;
    default:
      return display_tag_value (tag, p, end);
     }
  return p;
}

static 
# 18167 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 18168 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_attributes (Filedata * filedata,
      const char * public_name,
      unsigned int proc_type,
      unsigned char * (* display_pub_attribute) (unsigned char *, const unsigned char * const),
      unsigned char * (* display_proc_gnu_attribute) (unsigned char *, unsigned int, const unsigned char * const))
{
  Elf_Internal_Shdr * sect;
  unsigned i;
  
# 18176 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 18176 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 18176 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 18176 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;


  for (i = 0, sect = filedata->section_headers;
       i < filedata->file_header.e_shnum;
       i++, sect++)
    {
      unsigned char * contents;
      unsigned char * p;

      if (sect->sh_type != proc_type && sect->sh_type != 0x6ffffff5)
 continue;

      contents = (unsigned char *) get_data (
# 18189 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                            ((void *)0)
# 18189 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                , filedata, sect->sh_offset, 1,
                                             sect->sh_size, gettext ("attributes"));
      if (contents == 
# 18191 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 18191 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         )
 {
   res = 
# 18193 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 18193 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
   continue;
 }

      p = contents;


      if (*p != 'A')
 {
   printf (gettext ("Unknown attributes version '%c'(%d) - expecting 'A'\n"), *p, *p);
   res = 
# 18203 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 18203 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
 }
      else
 {
   uint64_t section_len;

   section_len = sect->sh_size - 1;
   p++;

   while (section_len > 0)
     {
       uint64_t attr_len;
       unsigned int namelen;
       
# 18216 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 18216 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           public_section;
       
# 18217 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool 
# 18217 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           gnu_section;

       if (section_len <= 4)
  {
    error (gettext ("Tag section ends prematurely\n"));
    res = 
# 18222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 18222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
    break;
  }
       attr_len = byte_get (p, 4);
       p += 4;

       if (attr_len > section_len)
  {
    error (gettext ("Bad attribute length (%u > %u)\n"),
     (unsigned) attr_len, (unsigned) section_len);
    attr_len = section_len;
    res = 
# 18233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 18233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
  }

       else if (attr_len < 5)
  {
    error (gettext ("Attribute length of %u is too small\n"), (unsigned) attr_len);
    res = 
# 18239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 18239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
    break;
  }

       section_len -= attr_len;
       attr_len -= 4;

       namelen = strnlen ((char *) p, attr_len) + 1;
       if (namelen == 0 || namelen >= attr_len)
  {
    error (gettext ("Corrupt attribute section name\n"));
    res = 
# 18250 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 18250 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
    break;
  }

       printf (gettext ("Attribute Section: "));
       print_symbol (0x7fffffff, (const char *) p);
       putchar ('\n');

       if (public_name && (strcmp (((char *) p), (public_name)) == 0))
  public_section = 
# 18259 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  1
# 18259 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;
       else
  public_section = 
# 18261 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  0
# 18261 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;

       if ((strcmp (((char *) p), ("gnu")) == 0))
  gnu_section = 
# 18264 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 18264 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
       else
  gnu_section = 
# 18266 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               0
# 18266 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;

       p += namelen;
       attr_len -= namelen;

       while (attr_len > 0 && p < contents + sect->sh_size)
  {
    int tag;
    unsigned int val;
    uint64_t size;
    unsigned char * end;


    if (attr_len < 6)
      {
        error (gettext ("Unused bytes at end of section\n"));
        res = 
# 18282 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 18282 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
        section_len = 0;
        break;
      }

    tag = *(p++);
    size = byte_get (p, 4);
    if (size > attr_len)
      {
        error (gettext ("Bad subsection length (%u > %u)\n"),
         (unsigned) size, (unsigned) attr_len);
        res = 
# 18293 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 18293 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
        size = attr_len;
      }

    if (size < 6)
      {
        error (gettext ("Bad subsection length (%u < 6)\n"),
         (unsigned) size);
        res = 
# 18301 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 18301 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
        section_len = 0;
        break;
      }

    attr_len -= size;
    end = p + size - 1;
    
# 18308 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
   ((void) sizeof ((
# 18308 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
   end <= contents + sect->sh_size
# 18308 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 18308 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
   end <= contents + sect->sh_size
# 18308 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
   ) ; else __assert_fail (
# 18308 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
   "end <= contents + sect->sh_size"
# 18308 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
   , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 18308, __extension__ __PRETTY_FUNCTION__); }))
# 18308 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           ;
    p += 4;

    switch (tag)
      {
      case 1:
        printf (gettext ("File Attributes\n"));
        break;
      case 2:
        printf (gettext ("Section Attributes:"));
        goto do_numlist;
      case 3:
        printf (gettext ("Symbol Attributes:"));

      do_numlist:
        for (;;)
   {
     do { uint64_t _val; unsigned int _len; int _status; _val = read_leb128 (p, end, 
# 18325 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
    0
# 18325 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
    , &_len, &_status); p += _len; (val) = _val; if ((val) != _val) _status |= 2; report_leb_status (_status); } while (0);
     if (val == 0)
       break;
     printf (" %d", val);
   }
        printf ("\n");
        break;
      default:
        printf (gettext ("Unknown tag: %d\n"), tag);
        public_section = 
# 18334 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        0
# 18334 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;
        break;
      }

    if (public_section && display_pub_attribute != 
# 18338 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                  ((void *)0)
# 18338 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                      )
      {
        while (p < end)
   p = display_pub_attribute (p, end);
        
# 18342 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       ((void) sizeof ((
# 18342 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       p == end
# 18342 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 18342 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       p == end
# 18342 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       ) ; else __assert_fail (
# 18342 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       "p == end"
# 18342 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 18342, __extension__ __PRETTY_FUNCTION__); }))
# 18342 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;
      }
    else if (gnu_section && display_proc_gnu_attribute != 
# 18344 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                         ((void *)0)
# 18344 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                             )
      {
        while (p < end)
   p = display_gnu_attribute (p,
         display_proc_gnu_attribute,
         end);
        
# 18350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       ((void) sizeof ((
# 18350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       p == end
# 18350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       ) ? 1 : 0), __extension__ ({ if (
# 18350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       p == end
# 18350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       ) ; else __assert_fail (
# 18350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       "p == end"
# 18350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 18350, __extension__ __PRETTY_FUNCTION__); }))
# 18350 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;
      }
    else if (p < end)
      {
        printf (gettext ("  Unknown attribute:\n"));
        display_raw_attribute (p, end);
        p = end;
      }
    else
      attr_len = 0;
  }
     }
 }

      free (contents);
    }

  return res;
}






static uint64_t
print_mips_got_entry (unsigned char * data, uint64_t pltgot, uint64_t addr,
        unsigned char * data_end)
{
  printf ("  ");
  print_vma (addr, LONG_HEX);
  printf (" ");
  if (addr < pltgot + 0xfff0)
    printf ("%6d(gp)", (int) (addr - pltgot - 0x7ff0));
  else
    printf ("%10s", "");
  printf (" ");
  if (data == 
# 18387 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 18387 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 )
    printf ("%*s", is_32bit_elf ? 8 : 16, gettext ("<unknown>"));
  else
    {
      uint64_t entry;
      unsigned char * from = data + addr - pltgot;

      if (from + (is_32bit_elf ? 4 : 8) > data_end)
 {
   warn (gettext ("MIPS GOT entry extends beyond the end of available data\n"));
   printf ("%*s", is_32bit_elf ? 8 : 16, gettext ("<corrupt>"));
   return (uint64_t) -1;
 }
      else
 {
   entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
   print_vma (entry, LONG_HEX);
 }
    }
  return addr + (is_32bit_elf ? 4 : 8);
}





static uint64_t
print_mips_pltgot_entry (unsigned char * data, uint64_t pltgot, uint64_t addr)
{
  printf ("  ");
  print_vma (addr, LONG_HEX);
  printf (" ");
  if (data == 
# 18419 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 18419 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 )
    printf ("%*s", is_32bit_elf ? 8 : 16, gettext ("<unknown>"));
  else
    {
      uint64_t entry;

      entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
      print_vma (entry, LONG_HEX);
    }
  return addr + (is_32bit_elf ? 4 : 8);
}

static void
print_mips_ases (unsigned int mask)
{
  if (mask & 0x00000001)
    fputs ("\n\tDSP ASE", 
# 18435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         stdout
# 18435 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               );
  if (mask & 0x00000002)
    fputs ("\n\tDSP R2 ASE", 
# 18437 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            stdout
# 18437 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  );
  if (mask & 0x00002000)
    fputs ("\n\tDSP R3 ASE", 
# 18439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            stdout
# 18439 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  );
  if (mask & 0x00000004)
    fputs ("\n\tEnhanced VA Scheme", 
# 18441 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                    stdout
# 18441 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          );
  if (mask & 0x00000008)
    fputs ("\n\tMCU (MicroController) ASE", 
# 18443 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           stdout
# 18443 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                 );
  if (mask & 0x00000010)
    fputs ("\n\tMDMX ASE", 
# 18445 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 18445 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );
  if (mask & 0x00000020)
    fputs ("\n\tMIPS-3D ASE", 
# 18447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             stdout
# 18447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   );
  if (mask & 0x00000040)
    fputs ("\n\tMT ASE", 
# 18449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        stdout
# 18449 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              );
  if (mask & 0x00000080)
    fputs ("\n\tSmartMIPS ASE", 
# 18451 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               stdout
# 18451 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     );
  if (mask & 0x00000100)
    fputs ("\n\tVZ ASE", 
# 18453 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        stdout
# 18453 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              );
  if (mask & 0x00000200)
    fputs ("\n\tMSA ASE", 
# 18455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         stdout
# 18455 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               );
  if (mask & 0x00000400)
    fputs ("\n\tMIPS16 ASE", 
# 18457 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            stdout
# 18457 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  );
  if (mask & 0x00000800)
    fputs ("\n\tMICROMIPS ASE", 
# 18459 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               stdout
# 18459 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     );
  if (mask & 0x00001000)
    fputs ("\n\tXPA ASE", 
# 18461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         stdout
# 18461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               );
  if (mask & 0x00004000)
    fputs ("\n\tMIPS16e2 ASE", 
# 18463 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              stdout
# 18463 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    );
  if (mask & 0x00008000)
    fputs ("\n\tCRC ASE", 
# 18465 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         stdout
# 18465 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               );
  if (mask & 0x00020000)
    fputs ("\n\tGINV ASE", 
# 18467 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 18467 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );
  if (mask & 0x00040000)
    fputs ("\n\tLoongson MMI ASE", 
# 18469 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  stdout
# 18469 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        );
  if (mask & 0x00080000)
    fputs ("\n\tLoongson CAM ASE", 
# 18471 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  stdout
# 18471 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        );
  if (mask & 0x00100000)
    fputs ("\n\tLoongson EXT ASE", 
# 18473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  stdout
# 18473 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        );
  if (mask & 0x00200000)
    fputs ("\n\tLoongson EXT2 ASE", 
# 18475 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   stdout
# 18475 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         );
  if (mask == 0)
    fprintf (
# 18477 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            stdout
# 18477 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  , "\n\t%s", gettext ("None"));
  else if ((mask & ~0x003effff) != 0)
    fprintf (
# 18479 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            stdout
# 18479 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  , "\n\t%s (%x)", gettext ("Unknown"), mask & ~0x003effff);
}

static void
print_mips_isa_ext (unsigned int isa_ext)
{
  switch (isa_ext)
    {
    case 0:
      fputs (gettext ("None"), 
# 18488 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       stdout
# 18488 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             );
      break;
    case 1:
      fputs ("RMI XLR", 
# 18491 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       stdout
# 18491 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             );
      break;
    case 19:
      fputs ("Cavium Networks Octeon3", 
# 18494 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       stdout
# 18494 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             );
      break;
    case 2:
      fputs ("Cavium Networks Octeon2", 
# 18497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       stdout
# 18497 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             );
      break;
    case 3:
      fputs ("Cavium Networks OcteonP", 
# 18500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       stdout
# 18500 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             );
      break;
    case 5:
      fputs ("Cavium Networks Octeon", 
# 18503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      stdout
# 18503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                            );
      break;
    case 6:
      fputs ("Toshiba R5900", 
# 18506 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             stdout
# 18506 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   );
      break;
    case 7:
      fputs ("MIPS R4650", 
# 18509 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 18509 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );
      break;
    case 8:
      fputs ("LSI R4010", 
# 18512 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         stdout
# 18512 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               );
      break;
    case 9:
      fputs ("NEC VR4100", 
# 18515 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 18515 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );
      break;
    case 10:
      fputs ("Toshiba R3900", 
# 18518 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             stdout
# 18518 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   );
      break;
    case 11:
      fputs ("MIPS R10000", 
# 18521 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           stdout
# 18521 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 );
      break;
    case 12:
      fputs ("Broadcom SB-1", 
# 18524 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             stdout
# 18524 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   );
      break;
    case 13:
      fputs ("NEC VR4111/VR4181", 
# 18527 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 stdout
# 18527 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                       );
      break;
    case 14:
      fputs ("NEC VR4120", 
# 18530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 18530 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );
      break;
    case 15:
      fputs ("NEC VR5400", 
# 18533 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 18533 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );
      break;
    case 16:
      fputs ("NEC VR5500", 
# 18536 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 18536 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );
      break;
    case 17:
      fputs ("ST Microelectronics Loongson 2E", 
# 18539 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               stdout
# 18539 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                     );
      break;
    case 18:
      fputs ("ST Microelectronics Loongson 2F", 
# 18542 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               stdout
# 18542 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                     );
      break;
    case 20:
      fputs ("Imagination interAptiv MR2", 
# 18545 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          stdout
# 18545 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                );
      break;
    default:
      fprintf (
# 18548 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              stdout
# 18548 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    , "%s (%d)", gettext ("Unknown"), isa_ext);
    }
}

static signed int
get_mips_reg_size (int reg_size)
{
  return (reg_size == 0x00) ? 0
  : (reg_size == 0x01) ? 32
  : (reg_size == 0x02) ? 64
  : (reg_size == 0x03) ? 128
  : -1;
}

static 
# 18562 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 18563 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_mips_specific (Filedata * filedata)
{
  Elf_Internal_Dyn * entry;
  Elf_Internal_Shdr *sect = 
# 18566 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 18566 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
  size_t liblist_offset = 0;
  size_t liblistno = 0;
  size_t conflictsno = 0;
  size_t options_offset = 0;
  size_t conflicts_offset = 0;
  size_t pltrelsz = 0;
  size_t pltrel = 0;
  uint64_t pltgot = 0;
  uint64_t mips_pltgot = 0;
  uint64_t jmprel = 0;
  uint64_t local_gotno = 0;
  uint64_t gotsym = 0;
  uint64_t symtabno = 0;
  
# 18580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 18580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 18580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 18580 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (! process_attributes (filedata, 
# 18582 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
# 18582 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         , 0x6ffffff5, 
# 18582 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                               ((void *)0)
# 18582 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                   ,
       display_mips_gnu_attribute))
    res = 
# 18584 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 18584 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  sect = find_section (filedata, ".MIPS.abiflags");

  if (sect != 
# 18588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 18588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 )
    {
      Elf_External_ABIFlags_v0 *abiflags_ext;
      Elf_Internal_ABIFlags_v0 abiflags_in;

      if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size)
 {
   error (gettext ("Corrupt MIPS ABI Flags section.\n"));
   res = 
# 18596 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 18596 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
 }
      else
 {
   abiflags_ext = get_data (
# 18600 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 18600 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               , filedata, sect->sh_offset, 1,
       sect->sh_size, gettext ("MIPS ABI Flags section"));
   if (abiflags_ext)
     {
       abiflags_in.version = byte_get (abiflags_ext->version, sizeof (abiflags_ext->version));
       abiflags_in.isa_level = byte_get (abiflags_ext->isa_level, sizeof (abiflags_ext->isa_level));
       abiflags_in.isa_rev = byte_get (abiflags_ext->isa_rev, sizeof (abiflags_ext->isa_rev));
       abiflags_in.gpr_size = byte_get (abiflags_ext->gpr_size, sizeof (abiflags_ext->gpr_size));
       abiflags_in.cpr1_size = byte_get (abiflags_ext->cpr1_size, sizeof (abiflags_ext->cpr1_size));
       abiflags_in.cpr2_size = byte_get (abiflags_ext->cpr2_size, sizeof (abiflags_ext->cpr2_size));
       abiflags_in.fp_abi = byte_get (abiflags_ext->fp_abi, sizeof (abiflags_ext->fp_abi));
       abiflags_in.isa_ext = byte_get (abiflags_ext->isa_ext, sizeof (abiflags_ext->isa_ext));
       abiflags_in.ases = byte_get (abiflags_ext->ases, sizeof (abiflags_ext->ases));
       abiflags_in.flags1 = byte_get (abiflags_ext->flags1, sizeof (abiflags_ext->flags1));
       abiflags_in.flags2 = byte_get (abiflags_ext->flags2, sizeof (abiflags_ext->flags2));

       printf ("\nMIPS ABI Flags Version: %d\n", abiflags_in.version);
       printf ("\nISA: MIPS%d", abiflags_in.isa_level);
       if (abiflags_in.isa_rev > 1)
  printf ("r%d", abiflags_in.isa_rev);
       printf ("\nGPR size: %d",
        get_mips_reg_size (abiflags_in.gpr_size));
       printf ("\nCPR1 size: %d",
        get_mips_reg_size (abiflags_in.cpr1_size));
       printf ("\nCPR2 size: %d",
        get_mips_reg_size (abiflags_in.cpr2_size));
       fputs ("\nFP ABI: ", 
# 18626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           stdout
# 18626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 );
       print_mips_fp_abi_value (abiflags_in.fp_abi);
       fputs ("ISA Extension: ", 
# 18628 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                stdout
# 18628 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      );
       print_mips_isa_ext (abiflags_in.isa_ext);
       fputs ("\nASEs:", 
# 18630 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        stdout
# 18630 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              );
       print_mips_ases (abiflags_in.ases);
       printf ("\nFLAGS 1: %8.8lx", abiflags_in.flags1);
       printf ("\nFLAGS 2: %8.8lx", abiflags_in.flags2);
       fputc ('\n', 
# 18634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   stdout
# 18634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         );
       free (abiflags_ext);
     }
 }
    }


  if (filedata->dynamic_section == 
# 18641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 18641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      )
    {

      sect = find_section (filedata, ".got");
      if (sect != 
# 18645 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 18645 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
 {
   unsigned char *data_end;
   unsigned char *data;
   uint64_t ent, end;
   int addr_size;

   pltgot = sect->sh_addr;

   ent = pltgot;
   addr_size = (is_32bit_elf ? 4 : 8);
   end = pltgot + sect->sh_size;

   data = (unsigned char *) get_data (
# 18658 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     ((void *)0)
# 18658 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         , filedata, sect->sh_offset,
          end - pltgot, 1,
          gettext ("Global Offset Table data"));

   data_end = data + (end - pltgot);

   printf (gettext ("\nStatic GOT:\n"));
   printf (gettext (" Canonical gp value: "));
   print_vma (ent + 0x7ff0, LONG_HEX);
   printf ("\n\n");







   if (data
       && data + ent - pltgot + addr_size <= data_end
       && byte_get (data + ent - pltgot, addr_size) == 0)
     {
       printf (gettext (" Reserved entries:\n"));
       printf (gettext ("  %*s %10s %*s\n"),
        addr_size * 2, gettext ("Address"), gettext ("Access"),
        addr_size * 2, gettext ("Value"));
       ent = print_mips_got_entry (data, pltgot, ent, data_end);
       printf ("\n");
       if (ent == (uint64_t) -1)
  goto sgot_print_fail;







       if (data
    && data + ent - pltgot + addr_size <= data_end
    && (byte_get (data + ent - pltgot, addr_size)
        >> (addr_size * 8 - 1)) != 0)
  {
    ent = print_mips_got_entry (data, pltgot, ent, data_end);
    printf ("\n");
    if (ent == (uint64_t) -1)
      goto sgot_print_fail;
  }
       printf ("\n");
     }

   if (data != 
# 18707 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0) 
# 18707 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   && ent < end)
     {
       printf (gettext (" Local entries:\n"));
       printf ("  %*s %10s %*s\n",
        addr_size * 2, gettext ("Address"), gettext ("Access"),
        addr_size * 2, gettext ("Value"));
       while (ent < end)
  {
    ent = print_mips_got_entry (data, pltgot, ent, data_end);
    printf ("\n");
    if (ent == (uint64_t) -1)
      goto sgot_print_fail;
  }
       printf ("\n");
     }

 sgot_print_fail:
   free (data);
 }
      return res;
    }

  for (entry = filedata->dynamic_section;

       (entry < filedata->dynamic_section + filedata->dynamic_nent
 && entry->d_tag != 0);
       ++entry)
    switch (entry->d_tag)
      {
      case 0x70000009:
 liblist_offset
   = offset_from_vma (filedata, entry->d_un.d_val,
        liblistno * sizeof (Elf32_External_Lib));
 break;
      case 0x70000010:
 liblistno = entry->d_un.d_val;
 break;
      case 0x70000029:
 options_offset = offset_from_vma (filedata, entry->d_un.d_val, 0);
 break;
      case 0x70000008:
 conflicts_offset
   = offset_from_vma (filedata, entry->d_un.d_val,
        conflictsno * sizeof (Elf32_External_Conflict));
 break;
      case 0x7000000b:
 conflictsno = entry->d_un.d_val;
 break;
      case 3:
 pltgot = entry->d_un.d_ptr;
 break;
      case 0x7000000a:
 local_gotno = entry->d_un.d_val;
 break;
      case 0x70000013:
 gotsym = entry->d_un.d_val;
 break;
      case 0x70000011:
 symtabno = entry->d_un.d_val;
 break;
      case 0x70000032:
 mips_pltgot = entry->d_un.d_ptr;
 break;
      case 20:
 pltrel = entry->d_un.d_val;
 break;
      case 2:
 pltrelsz = entry->d_un.d_val;
 break;
      case 23:
 jmprel = entry->d_un.d_ptr;
 break;
      default:
 break;
      }

  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)
    {
      Elf32_External_Lib * elib;
      size_t cnt;

      elib = (Elf32_External_Lib *) get_data (
# 18788 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                             ((void *)0)
# 18788 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                 , filedata, liblist_offset,
           sizeof (Elf32_External_Lib),
           liblistno,
           gettext ("liblist section data"));
      if (elib)
 {
   printf (ngettext ("\nSection '.liblist' contains %zu entry:\n",
       "\nSection '.liblist' contains %zu entries:\n",
       liblistno),
    liblistno);
   fputs (gettext ("     Library              Time Stamp          Checksum   Version Flags\n"),
   
# 18799 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
  stdout
# 18799 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        );

   for (cnt = 0; cnt < liblistno; ++cnt)
     {
       Elf32_Lib liblist;
       time_t atime;
       char timebuf[128];
       struct tm * tmp;

       liblist.l_name = byte_get (elib[cnt].l_name, sizeof (elib[cnt].l_name));
       atime = byte_get (elib[cnt].l_time_stamp, sizeof (elib[cnt].l_time_stamp));
       liblist.l_checksum = byte_get (elib[cnt].l_checksum, sizeof (elib[cnt].l_checksum));
       liblist.l_version = byte_get (elib[cnt].l_version, sizeof (elib[cnt].l_version));
       liblist.l_flags = byte_get (elib[cnt].l_flags, sizeof (elib[cnt].l_flags));

       tmp = gmtime (&atime);
       snprintf (timebuf, sizeof (timebuf),
   "%04u-%02u-%02uT%02u:%02u:%02u",
   tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
   tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

       printf ("%3zu: ", cnt);
       if (valid_dynamic_name (filedata, liblist.l_name))
  print_symbol (20, get_dynamic_name (filedata, liblist.l_name));
       else
  printf (gettext ("<corrupt: %9ld>"), liblist.l_name);
       printf (" %s %#10lx %-7ld", timebuf, liblist.l_checksum,
        liblist.l_version);

       if (liblist.l_flags == 0)
  puts (gettext (" NONE"));
       else
  {
    static const struct
    {
      const char * name;
      int bit;
    }
    l_flags_vals[] =
    {
      { " EXACT_MATCH", 0x00000001 },
      { " IGNORE_INT_VER", 0x00000002 },
      { " REQUIRE_MINOR", 0x00000004 },
      { " EXPORTS", 0x00000008 },
      { " DELAY_LOAD", 0x00000010 },
      { " DELTA", 0x00000020 }
    };
    int flags = liblist.l_flags;
    size_t fcnt;

    for (fcnt = 0; fcnt < (sizeof (l_flags_vals) / sizeof ((l_flags_vals)[0])); ++fcnt)
      if ((flags & l_flags_vals[fcnt].bit) != 0)
        {
   fputs (l_flags_vals[fcnt].name, 
# 18852 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  stdout
# 18852 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        );
   flags ^= l_flags_vals[fcnt].bit;
        }
    if (flags != 0)
      printf (" %#x", (unsigned int) flags);

    puts ("");
  }
     }

   free (elib);
 }
      else
 res = 
# 18865 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 18865 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ;
    }

  if (options_offset != 0)
    {
      Elf_External_Options * eopt;
      size_t offset;
      int cnt;


      sect = find_section_by_type (filedata, 0x7000000d);

      if (sect == 
# 18877 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 18877 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
 {
   error (gettext ("No MIPS_OPTIONS header found\n"));
   return 
# 18880 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 18880 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      if (sect->sh_size < sizeof (* eopt))
 {
   error (gettext ("The MIPS options section is too small.\n"));
   return 
# 18886 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 18886 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      eopt = (Elf_External_Options *) get_data (
# 18889 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               ((void *)0)
# 18889 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   , filedata, options_offset, 1,
                                                sect->sh_size, gettext ("options"));
      if (eopt)
 {
   Elf_Internal_Options option;

   offset = cnt = 0;
   while (offset <= sect->sh_size - sizeof (* eopt))
     {
       Elf_External_Options * eoption;
       unsigned int optsize;

       eoption = (Elf_External_Options *) ((char *) eopt + offset);

       optsize = byte_get (eoption->size, sizeof (eoption->size));


       if (optsize < sizeof (* eopt)
    || optsize > sect->sh_size - offset)
  {
    error (gettext ("Invalid size (%u) for MIPS option\n"),
    optsize);
    free (eopt);
    return 
# 18912 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 18912 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
  }
       offset += optsize;
       ++cnt;
     }

   printf (ngettext ("\nSection '%s' contains %d entry:\n",
       "\nSection '%s' contains %d entries:\n",
       cnt),
    printable_section_name (filedata, sect), cnt);

   offset = 0;
   while (cnt-- > 0)
     {
       size_t len;
       Elf_External_Options * eoption;

       eoption = (Elf_External_Options *) ((char *) eopt + offset);

       option.kind = byte_get (eoption->kind, sizeof (eoption->kind));
       option.size = byte_get (eoption->size, sizeof (eoption->size));
       option.section = byte_get (eoption->section, sizeof (eoption->section));
       option.info = byte_get (eoption->info, sizeof (eoption->info));

       switch (option.kind)
  {
  case 0:

    printf (" NULL       %" 
# 18940 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           "d" 
# 18940 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  " %" 
# 18940 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       "x"
# 18940 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                             ,
     option.section, option.info);
    break;

  case 1:
    printf (" REGINFO    ");
    if (filedata->file_header.e_machine == 8)
      {
        Elf32_External_RegInfo * ereg;
        Elf32_RegInfo reginfo;


        if (option.size < (sizeof (Elf_External_Options)
      + sizeof (Elf32_External_RegInfo)))
   {
     printf (gettext ("<corrupt>\n"));
     error (gettext ("Truncated MIPS REGINFO option\n"));
     cnt = 0;
     break;
   }

        ereg = (Elf32_External_RegInfo *) (eoption + 1);

        reginfo.ri_gprmask = byte_get (ereg->ri_gprmask, sizeof (ereg->ri_gprmask));
        reginfo.ri_cprmask[0] = byte_get (ereg->ri_cprmask[0], sizeof (ereg->ri_cprmask[0]));
        reginfo.ri_cprmask[1] = byte_get (ereg->ri_cprmask[1], sizeof (ereg->ri_cprmask[1]));
        reginfo.ri_cprmask[2] = byte_get (ereg->ri_cprmask[2], sizeof (ereg->ri_cprmask[2]));
        reginfo.ri_cprmask[3] = byte_get (ereg->ri_cprmask[3], sizeof (ereg->ri_cprmask[3]));
        reginfo.ri_gp_value = byte_get (ereg->ri_gp_value, sizeof (ereg->ri_gp_value));

        printf ("GPR %08" 
# 18970 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         "x" 
# 18970 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                "  GP 0x%" 
# 18970 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           "x" 
# 18970 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  "\n",
         reginfo.ri_gprmask, reginfo.ri_gp_value);
        printf ("          "
         "  CPR0 %08" 
# 18973 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     "x" 
# 18973 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            "  CPR1 %08" 
# 18973 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         "x"
         
# 18974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        "  CPR2 %08" 
# 18974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     "x" 
# 18974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            "  CPR3 %08" 
# 18974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         "x" 
# 18974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                "\n",
         reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
         reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
      }
    else
      {

        Elf64_External_RegInfo * ereg;
        Elf64_Internal_RegInfo reginfo;

        if (option.size < (sizeof (Elf_External_Options)
      + sizeof (Elf64_External_RegInfo)))
   {
     printf (gettext ("<corrupt>\n"));
     error (gettext ("Truncated MIPS REGINFO option\n"));
     cnt = 0;
     break;
   }

        ereg = (Elf64_External_RegInfo *) (eoption + 1);
        reginfo.ri_gprmask = byte_get (ereg->ri_gprmask, sizeof (ereg->ri_gprmask));
        reginfo.ri_cprmask[0] = byte_get (ereg->ri_cprmask[0], sizeof (ereg->ri_cprmask[0]));
        reginfo.ri_cprmask[1] = byte_get (ereg->ri_cprmask[1], sizeof (ereg->ri_cprmask[1]));
        reginfo.ri_cprmask[2] = byte_get (ereg->ri_cprmask[2], sizeof (ereg->ri_cprmask[2]));
        reginfo.ri_cprmask[3] = byte_get (ereg->ri_cprmask[3], sizeof (ereg->ri_cprmask[3]));
        reginfo.ri_gp_value = byte_get (ereg->ri_gp_value, sizeof (ereg->ri_gp_value));

        printf ("GPR %08" 
# 19001 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         "x" 
# 19001 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                "  GP 0x%" 
# 19001 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           "l" "x" 
# 19001 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  "\n",
         reginfo.ri_gprmask, reginfo.ri_gp_value);
        printf ("          "
         "  CPR0 %08" 
# 19004 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     "x" 
# 19004 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            "  CPR1 %08" 
# 19004 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         "x"
         
# 19005 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        "  CPR2 %08" 
# 19005 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     "x" 
# 19005 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            "  CPR3 %08" 
# 19005 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                         "x" 
# 19005 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                "\n",
         reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
         reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
      }
    offset += option.size;
    continue;

  case 2:
    fputs (" EXCEPTIONS fpe_min(", 
# 19013 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  stdout
# 19013 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        );
    process_mips_fpe_exception (option.info & 0x1f);
    fputs (") fpe_max(", 
# 19015 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        stdout
# 19015 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              );
    process_mips_fpe_exception ((option.info & 0x1f00) >> 8);
    fputs (")", 
# 19017 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               stdout
# 19017 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     );

    if (option.info & 0x10000)
      fputs (" PAGE0", 
# 19020 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      stdout
# 19020 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            );
    if (option.info & 0x20000)
      fputs (" SMM", 
# 19022 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    stdout
# 19022 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          );
    if (option.info & 0x40000)
      fputs (" FPDBUG", 
# 19024 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       stdout
# 19024 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             );
    if (option.info & 0x80000)
      fputs (" DISMISS", 
# 19026 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        stdout
# 19026 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              );
    break;

  case 3:
    fputs (" PAD       ", 
# 19030 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         stdout
# 19030 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               );
    if (option.info & 0x01)
      fputs (" PREFIX", 
# 19032 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       stdout
# 19032 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             );
    if (option.info & 0x02)
      fputs (" POSTFIX", 
# 19034 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        stdout
# 19034 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              );
    if (option.info & 0x04)
      fputs (" SYMBOL", 
# 19036 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       stdout
# 19036 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             );
    break;

  case 4:
    fputs (" HWPATCH   ", 
# 19040 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         stdout
# 19040 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               );
    if (option.info & 0x00000001)
      fputs (" R4KEOP", 
# 19042 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       stdout
# 19042 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             );
    if (option.info & 0x00000002)
      fputs (" R8KPFETCH", 
# 19044 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 19044 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );
    if (option.info & 0x00000004)
      fputs (" R5KEOP", 
# 19046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       stdout
# 19046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             );
    if (option.info & 0x00000008)
      fputs (" R5KCVTL", 
# 19048 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        stdout
# 19048 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              );
    break;

  case 5:
    fputs (" FILL       ", 
# 19052 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 19052 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );

    break;

  case 6:
    fputs (" TAGS       ", 
# 19057 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          stdout
# 19057 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );

    break;

  case 7:
    fputs (" HWAND     ", 
# 19062 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         stdout
# 19062 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               );
    if (option.info & 0x00000001)
      fputs (" R4KEOP_CHECKED", 
# 19064 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               stdout
# 19064 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     );
    if (option.info & 0x00000002)
      fputs (" R4KEOP_CLEAN", 
# 19066 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             stdout
# 19066 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   );
    break;

  case 8:
    fputs (" HWOR      ", 
# 19070 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         stdout
# 19070 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               );
    if (option.info & 0x00000001)
      fputs (" R4KEOP_CHECKED", 
# 19072 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               stdout
# 19072 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     );
    if (option.info & 0x00000002)
      fputs (" R4KEOP_CLEAN", 
# 19074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             stdout
# 19074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   );
    break;

  case 9:
    printf (" GP_GROUP  %#06x  self-contained %#06x",
     option.info & 0x0000ffff,
     (option.info & 0xffff0000) >> 16);
    break;

  case 10:
    printf (" IDENT     %#06x  self-contained %#06x",
     option.info & 0x0000ffff,
     (option.info & 0xffff0000) >> 16);
    break;

  default:

    printf (" %3d ???     %" 
# 19091 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            "d" 
# 19091 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   " %" 
# 19091 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                        "x"
# 19091 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              ,
     option.kind, option.section, option.info);
    break;
  }

       len = sizeof (* eopt);
       while (len < option.size)
  {
    unsigned char datum = *((unsigned char *) eoption + len);

    if ((_sch_istable[(datum) & 0xff] & (unsigned short)(_sch_isprint)))
      printf ("%c", datum);
    else
      printf ("\\%03o", datum);
    len ++;
  }
       fputs ("\n", 
# 19107 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   stdout
# 19107 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         );

       offset += option.size;
     }
   free (eopt);
 }
      else
 res = 
# 19114 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 19114 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ;
    }

  if (conflicts_offset != 0 && conflictsno != 0)
    {
      Elf32_Conflict * iconf;
      size_t cnt;

      if (filedata->dynamic_symbols == 
# 19122 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      ((void *)0)
# 19122 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          )
 {
   error (gettext ("conflict list found without a dynamic symbol table\n"));
   return 
# 19125 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 19125 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }



      if (conflictsno > filedata->file_size / sizeof (* iconf))
 {
   error (gettext ("Overlarge number of conflicts detected: %zx\n"),
   conflictsno);
   return 
# 19134 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 19134 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));
      if (iconf == 
# 19138 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 19138 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
 {
   error (gettext ("Out of memory allocating space for dynamic conflicts\n"));
   return 
# 19141 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 19141 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      if (is_32bit_elf)
 {
   Elf32_External_Conflict * econf32;

   econf32 = (Elf32_External_Conflict *)
     get_data (
# 19149 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 19149 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  , filedata, conflicts_offset,
        sizeof (*econf32), conflictsno, gettext ("conflict"));
   if (!econf32)
     {
       free (iconf);
       return 
# 19154 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 19154 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }

   for (cnt = 0; cnt < conflictsno; ++cnt)
     iconf[cnt] = byte_get (econf32[cnt], sizeof (econf32[cnt]));

   free (econf32);
 }
      else
 {
   Elf64_External_Conflict * econf64;

   econf64 = (Elf64_External_Conflict *)
     get_data (
# 19167 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 19167 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  , filedata, conflicts_offset,
        sizeof (*econf64), conflictsno, gettext ("conflict"));
   if (!econf64)
     {
       free (iconf);
       return 
# 19172 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 19172 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }

   for (cnt = 0; cnt < conflictsno; ++cnt)
     iconf[cnt] = byte_get (econf64[cnt], sizeof (econf64[cnt]));

   free (econf64);
 }

      printf (ngettext ("\nSection '.conflict' contains %zu entry:\n",
   "\nSection '.conflict' contains %zu entries:\n",
   conflictsno),
       conflictsno);
      puts (gettext ("  Num:    Index       Value  Name"));

      for (cnt = 0; cnt < conflictsno; ++cnt)
 {
   printf ("%5zu: %8lu  ", cnt, iconf[cnt]);

   if (iconf[cnt] >= filedata->num_dynamic_syms)
     printf (gettext ("<corrupt symbol index>"));
   else
     {
       Elf_Internal_Sym * psym;

       psym = & filedata->dynamic_symbols[iconf[cnt]];
       print_vma (psym->st_value, FULL_HEX);
       putchar (' ');
       if (valid_dynamic_name (filedata, psym->st_name))
  print_symbol (25, get_dynamic_name (filedata, psym->st_name));
       else
  printf (gettext ("<corrupt: %14ld>"), psym->st_name);
     }
   putchar ('\n');
 }

      free (iconf);
    }

  if (pltgot != 0 && local_gotno != 0)
    {
      uint64_t ent, local_end, global_end;
      size_t i, offset;
      unsigned char * data;
      unsigned char * data_end;
      int addr_size;

      ent = pltgot;
      addr_size = (is_32bit_elf ? 4 : 8);
      local_end = pltgot + local_gotno * addr_size;


      if (symtabno < gotsym)
 {
   error (gettext ("The GOT symbol offset (%" 
# 19226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "u" 
# 19226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         ") is greater than the symbol table size (%" 
# 19226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "u" 
# 19226 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         ")\n")
                                                               ,
   gotsym, symtabno);
   return 
# 19229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 19229 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      global_end = local_end + (symtabno - gotsym) * addr_size;

      if (global_end < local_end)
 {
   error (gettext ("Too many GOT symbols: %" 
# 19236 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "u" 
# 19236 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         "\n"), symtabno);
   return 
# 19237 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 19237 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      offset = offset_from_vma (filedata, pltgot, global_end - pltgot);
      data = (unsigned char *) get_data (
# 19241 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                        ((void *)0)
# 19241 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                            , filedata, offset,
                                         global_end - pltgot, 1,
      gettext ("Global Offset Table data"));

      data_end = data + (global_end - pltgot);

      printf (gettext ("\nPrimary GOT:\n"));
      printf (gettext (" Canonical gp value: "));
      print_vma (pltgot + 0x7ff0, LONG_HEX);
      printf ("\n\n");

      printf (gettext (" Reserved entries:\n"));
      printf (gettext ("  %*s %10s %*s Purpose\n"),
       addr_size * 2, gettext ("Address"), gettext ("Access"),
       addr_size * 2, gettext ("Initial"));
      ent = print_mips_got_entry (data, pltgot, ent, data_end);
      printf (gettext (" Lazy resolver\n"));
      if (ent == (uint64_t) -1)
 goto got_print_fail;






      if (data
   && data + ent - pltgot + addr_size <= data_end
   && (byte_get (data + ent - pltgot, addr_size)
       >> (addr_size * 8 - 1)) != 0)
 {
   ent = print_mips_got_entry (data, pltgot, ent, data_end);
   printf (gettext (" Module pointer (GNU extension)\n"));
   if (ent == (uint64_t) -1)
     goto got_print_fail;
 }
      printf ("\n");

      if (data != 
# 19278 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0) 
# 19278 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      && ent < local_end)
 {
   printf (gettext (" Local entries:\n"));
   printf ("  %*s %10s %*s\n",
    addr_size * 2, gettext ("Address"), gettext ("Access"),
    addr_size * 2, gettext ("Initial"));
   while (ent < local_end)
     {
       ent = print_mips_got_entry (data, pltgot, ent, data_end);
       printf ("\n");
       if (ent == (uint64_t) -1)
  goto got_print_fail;
     }
   printf ("\n");
 }

      if (data != 
# 19294 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0) 
# 19294 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      && gotsym < symtabno)
 {
   int sym_width;

   printf (gettext (" Global entries:\n"));
   printf ("  %*s %10s %*s %*s %-7s %3s %s\n",
    addr_size * 2, gettext ("Address"),
    gettext ("Access"),
    addr_size * 2, gettext ("Initial"),
    addr_size * 2, gettext ("Sym.Val."),
    gettext ("Type"),

    gettext ("Ndx"), gettext ("Name"));

   sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;

   for (i = gotsym; i < symtabno; i++)
     {
       ent = print_mips_got_entry (data, pltgot, ent, data_end);
       printf (" ");

       if (filedata->dynamic_symbols == 
# 19315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       ((void *)0)
# 19315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           )
  printf (gettext ("<no dynamic symbols>"));
       else if (i < filedata->num_dynamic_syms)
  {
    Elf_Internal_Sym * psym = filedata->dynamic_symbols + i;

    print_vma (psym->st_value, LONG_HEX);
    printf (" %-7s %3s ",
     get_symbol_type (filedata, ((psym->st_info) & 0xF)),
     get_symbol_index_type (filedata, psym->st_shndx));

    if (valid_dynamic_name (filedata, psym->st_name))
      print_symbol (sym_width,
      get_dynamic_name (filedata, psym->st_name));
    else
      printf (gettext ("<corrupt: %14ld>"), psym->st_name);
  }
       else
  printf (gettext ("<symbol index %zu exceeds number of dynamic symbols>"),
   i);

       printf ("\n");
       if (ent == (uint64_t) -1)
  break;
     }
   printf ("\n");
 }

    got_print_fail:
      free (data);
    }

  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)
    {
      uint64_t ent, end;
      uint64_t offset, rel_offset;
      uint64_t count, i;
      unsigned char * data;
      int addr_size, sym_width;
      Elf_Internal_Rela * rels;

      rel_offset = offset_from_vma (filedata, jmprel, pltrelsz);
      if (pltrel == 7)
 {
   if (!slurp_rela_relocs (filedata, rel_offset, pltrelsz, &rels, &count))
     return 
# 19360 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 19360 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
 }
      else
 {
   if (!slurp_rel_relocs (filedata, rel_offset, pltrelsz, &rels, &count))
     return 
# 19365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 19365 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
 }

      ent = mips_pltgot;
      addr_size = (is_32bit_elf ? 4 : 8);
      end = mips_pltgot + (2 + count) * addr_size;

      offset = offset_from_vma (filedata, mips_pltgot, end - mips_pltgot);
      data = (unsigned char *) get_data (
# 19373 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                        ((void *)0)
# 19373 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                            , filedata, offset, end - mips_pltgot,
                                         1, gettext ("Procedure Linkage Table data"));
      if (data == 
# 19375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 19375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
 {
   free (rels);
   return 
# 19378 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 19378 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      printf ("\nPLT GOT:\n\n");
      printf (gettext (" Reserved entries:\n"));
      printf (gettext ("  %*s %*s Purpose\n"),
       addr_size * 2, gettext ("Address"), addr_size * 2, gettext ("Initial"));
      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
      printf (gettext (" PLT lazy resolver\n"));
      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
      printf (gettext (" Module pointer\n"));
      printf ("\n");

      printf (gettext (" Entries:\n"));
      printf ("  %*s %*s %*s %-7s %3s %s\n",
       addr_size * 2, gettext ("Address"),
       addr_size * 2, gettext ("Initial"),
       addr_size * 2, gettext ("Sym.Val."), gettext ("Type"), gettext ("Ndx"), gettext ("Name"));
      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;
      for (i = 0; i < count; i++)
 {
   uint64_t idx = get_reloc_symindex (rels[i].r_info);

   ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
   printf (" ");

   if (idx >= filedata->num_dynamic_syms)
     printf (gettext ("<corrupt symbol index: %" 
# 19405 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "u" 
# 19405 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ">"), idx);
   else
     {
       Elf_Internal_Sym * psym = filedata->dynamic_symbols + idx;

       print_vma (psym->st_value, LONG_HEX);
       printf (" %-7s %3s ",
        get_symbol_type (filedata, ((psym->st_info) & 0xF)),
        get_symbol_index_type (filedata, psym->st_shndx));
       if (valid_dynamic_name (filedata, psym->st_name))
  print_symbol (sym_width,
         get_dynamic_name (filedata, psym->st_name));
       else
  printf (gettext ("<corrupt: %14ld>"), psym->st_name);
     }
   printf ("\n");
 }
      printf ("\n");

      free (data);
      free (rels);
    }

  return res;
}

static 
# 19431 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 19432 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_nds32_specific (Filedata * filedata)
{
  Elf_Internal_Shdr *sect = 
# 19434 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 19434 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;

  sect = find_section (filedata, ".nds32_e_flags");
  if (sect != 
# 19437 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0) 
# 19437 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  && sect->sh_size >= 4)
    {
      unsigned char *buf;
      unsigned int flag;

      printf ("\nNDS32 elf flags section:\n");
      buf = get_data (
# 19443 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 19443 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         , filedata, sect->sh_offset, 1, 4,
        gettext ("NDS32 elf flags section"));

      if (buf == 
# 19446 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 19446 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    )
 return 
# 19447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 19447 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      flag = byte_get (buf, 4);
      free (buf);
      switch (flag & 0x3)
 {
 case 0:
   printf ("(VEC_SIZE):\tNo entry.\n");
   break;
 case 1:
   printf ("(VEC_SIZE):\t4 bytes\n");
   break;
 case 2:
   printf ("(VEC_SIZE):\t16 bytes\n");
   break;
 case 3:
   printf ("(VEC_SIZE):\treserved\n");
   break;
 }
    }

  return 
# 19468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 19468 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 19471 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 19472 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_gnu_liblist (Filedata * filedata)
{
  Elf_Internal_Shdr * section;
  Elf_Internal_Shdr * string_sec;
  Elf32_External_Lib * elib;
  char * strtab;
  size_t strtab_size;
  size_t cnt;
  uint64_t num_liblist;
  unsigned i;
  
# 19482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 19482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 19482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 19482 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (! do_arch)
    return 
# 19485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 19485 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  for (i = 0, section = filedata->section_headers;
       i < filedata->file_header.e_shnum;
       i++, section++)
    {
      switch (section->sh_type)
 {
 case 0x6ffffff7:
   if (section->sh_link >= filedata->file_header.e_shnum)
     break;

   elib = (Elf32_External_Lib *)
              get_data (
# 19498 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 19498 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           , filedata, section->sh_offset, 1, section->sh_size,
                        gettext ("liblist section data"));

   if (elib == 
# 19501 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              ((void *)0)
# 19501 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  )
     {
       res = 
# 19503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 19503 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
       break;
     }

   string_sec = filedata->section_headers + section->sh_link;
   strtab = (char *) get_data (
# 19508 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0)
# 19508 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  , filedata, string_sec->sh_offset, 1,
                                      string_sec->sh_size,
                                      gettext ("liblist string table"));
   if (strtab == 
# 19511 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
       
# 19512 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      || section->sh_entsize != sizeof (Elf32_External_Lib))
     {
       free (elib);
       free (strtab);
       res = 
# 19516 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 19516 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
       break;
     }
   strtab_size = string_sec->sh_size;

   num_liblist = section->sh_size / sizeof (Elf32_External_Lib);
   printf (ngettext ("\nLibrary list section '%s' contains %" 
# 19522 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                             "l" "u"
       
# 19523 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      " entries:\n",
       "\nLibrary list section '%s' contains %" 
# 19524 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               "l" "u"
       
# 19525 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      " entries:\n",
       num_liblist),
    printable_section_name (filedata, section),
    num_liblist);

   puts (gettext ("     Library              Time Stamp          Checksum   Version Flags"));

   for (cnt = 0; cnt < section->sh_size / sizeof (Elf32_External_Lib);
        ++cnt)
     {
       Elf32_Lib liblist;
       time_t atime;
       char timebuf[128];
       struct tm * tmp;

       liblist.l_name = byte_get (elib[cnt].l_name, sizeof (elib[cnt].l_name));
       atime = byte_get (elib[cnt].l_time_stamp, sizeof (elib[cnt].l_time_stamp));
       liblist.l_checksum = byte_get (elib[cnt].l_checksum, sizeof (elib[cnt].l_checksum));
       liblist.l_version = byte_get (elib[cnt].l_version, sizeof (elib[cnt].l_version));
       liblist.l_flags = byte_get (elib[cnt].l_flags, sizeof (elib[cnt].l_flags));

       tmp = gmtime (&atime);
       snprintf (timebuf, sizeof (timebuf),
   "%04u-%02u-%02uT%02u:%02u:%02u",
   tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
   tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

       printf ("%3zu: ", cnt);
       if (do_wide)
  printf ("%-20s", liblist.l_name < strtab_size
   ? strtab + liblist.l_name : gettext ("<corrupt>"));
       else
  printf ("%-20.20s", liblist.l_name < strtab_size
   ? strtab + liblist.l_name : gettext ("<corrupt>"));
       printf (" %s %#010lx %-7ld %-7ld\n", timebuf, liblist.l_checksum,
        liblist.l_version, liblist.l_flags);
     }

   free (elib);
   free (strtab);
 }
    }

  return res;
}

static const char *
get_note_type (Filedata * filedata, unsigned e_type)
{
  static char buff[64];

  if (filedata->file_header.e_type == 4)
    switch (e_type)
      {
      case 6:
 return gettext ("NT_AUXV (auxiliary vector)");
      case 1:
 return gettext ("NT_PRSTATUS (prstatus structure)");
      case 2:
 return gettext ("NT_FPREGSET (floating point registers)");
      case 3:
 return gettext ("NT_PRPSINFO (prpsinfo structure)");
      case 4:
 return gettext ("NT_TASKSTRUCT (task structure)");
      case 0xff000000:
        return gettext ("NT_GDB_TDESC (GDB XML target description)");
      case 0x46e62b7f:
 return gettext ("NT_PRXFPREG (user_xfpregs structure)");
      case 0x100:
 return gettext ("NT_PPC_VMX (ppc Altivec registers)");
      case 0x102:
 return gettext ("NT_PPC_VSX (ppc VSX registers)");
      case 0x103:
 return gettext ("NT_PPC_TAR (ppc TAR register)");
      case 0x104:
 return gettext ("NT_PPC_PPR (ppc PPR register)");
      case 0x105:
 return gettext ("NT_PPC_DSCR (ppc DSCR register)");
      case 0x106:
 return gettext ("NT_PPC_EBB (ppc EBB registers)");
      case 0x107:
 return gettext ("NT_PPC_PMU (ppc PMU registers)");
      case 0x108:
 return gettext ("NT_PPC_TM_CGPR (ppc checkpointed GPR registers)");
      case 0x109:
 return gettext ("NT_PPC_TM_CFPR (ppc checkpointed floating point registers)");
      case 0x10a:
 return gettext ("NT_PPC_TM_CVMX (ppc checkpointed Altivec registers)");
      case 0x10b:
 return gettext ("NT_PPC_TM_CVSX (ppc checkpointed VSX registers)");
      case 0x10c:
 return gettext ("NT_PPC_TM_SPR (ppc TM special purpose registers)");
      case 0x10d:
 return gettext ("NT_PPC_TM_CTAR (ppc checkpointed TAR register)");
      case 0x10e:
 return gettext ("NT_PPC_TM_CPPR (ppc checkpointed PPR register)");
      case 0x10f:
 return gettext ("NT_PPC_TM_CDSCR (ppc checkpointed DSCR register)");
      case 0x200:
 return gettext ("NT_386_TLS (x86 TLS information)");
      case 0x201:
 return gettext ("NT_386_IOPERM (x86 I/O permissions)");
      case 0x202:
 return gettext ("NT_X86_XSTATE (x86 XSAVE extended state)");
      case 0x203:
 return gettext ("NT_X86_CET (x86 CET state)");
      case 0x300:
 return gettext ("NT_S390_HIGH_GPRS (s390 upper register halves)");
      case 0x301:
 return gettext ("NT_S390_TIMER (s390 timer register)");
      case 0x302:
 return gettext ("NT_S390_TODCMP (s390 TOD comparator register)");
      case 0x303:
 return gettext ("NT_S390_TODPREG (s390 TOD programmable register)");
      case 0x304:
 return gettext ("NT_S390_CTRS (s390 control registers)");
      case 0x305:
 return gettext ("NT_S390_PREFIX (s390 prefix register)");
      case 0x306:
 return gettext ("NT_S390_LAST_BREAK (s390 last breaking event address)");
      case 0x307:
 return gettext ("NT_S390_SYSTEM_CALL (s390 system call restart data)");
      case 0x308:
 return gettext ("NT_S390_TDB (s390 transaction diagnostic block)");
      case 0x309:
 return gettext ("NT_S390_VXRS_LOW (s390 vector registers 0-15 upper half)");
      case 0x30a:
 return gettext ("NT_S390_VXRS_HIGH (s390 vector registers 16-31)");
      case 0x30b:
 return gettext ("NT_S390_GS_CB (s390 guarded-storage registers)");
      case 0x30c:
 return gettext ("NT_S390_GS_BC (s390 guarded-storage broadcast control)");
      case 0x400:
 return gettext ("NT_ARM_VFP (arm VFP registers)");
      case 0x401:
 return gettext ("NT_ARM_TLS (AArch TLS registers)");
      case 0x402:
 return gettext ("NT_ARM_HW_BREAK (AArch hardware breakpoint registers)");
      case 0x403:
 return gettext ("NT_ARM_HW_WATCH (AArch hardware watchpoint registers)");
      case 0x404:
 return gettext ("NT_ARM_SYSTEM_CALL (AArch system call number)");
      case 0x405:
 return gettext ("NT_ARM_SVE (AArch SVE registers)");
      case 0x406:
 return gettext ("NT_ARM_PAC_MASK (AArch pointer authentication code masks)");
      case 0x407:
 return gettext ("NT_ARM_PACA_KEYS (ARM pointer authentication address keys)");
      case 0x408:
 return gettext ("NT_ARM_PACG_KEYS (ARM pointer authentication generic keys)");
      case 0x409:
 return gettext ("NT_ARM_TAGGED_ADDR_CTRL (AArch tagged address control)");
      case 0x40b:
 return gettext ("NT_ARM_SSVE (AArch64 streaming SVE registers)");
      case 0x40c:
 return gettext ("NT_ARM_ZA (AArch64 SME ZA register)");
      case 0x40a:
 return gettext ("NT_ARM_PAC_ENABLED_KEYS (AArch64 pointer authentication enabled keys)");
      case 0x600:
 return gettext ("NT_ARC_V2 (ARC HS accumulator/extra registers)");
      case 0x900:
 return gettext ("NT_RISCV_CSR (RISC-V control and status registers)");
      case 10:
 return gettext ("NT_PSTATUS (pstatus structure)");
      case 12:
 return gettext ("NT_FPREGS (floating point registers)");
      case 13:
 return gettext ("NT_PSINFO (psinfo structure)");
      case 16:
 return gettext ("NT_LWPSTATUS (lwpstatus_t structure)");
      case 17:
 return gettext ("NT_LWPSINFO (lwpsinfo_t structure)");
      case 18:
 return gettext ("NT_WIN32PSTATUS (win32_pstatus structure)");
      case 0x53494749:
 return gettext ("NT_SIGINFO (siginfo_t data)");
      case 0x46494c45:
 return gettext ("NT_FILE (mapped files)");
      default:
 break;
      }
  else
    switch (e_type)
      {
      case 1:
 return gettext ("NT_VERSION (version)");
      case 2:
 return gettext ("NT_ARCH (architecture)");
      case 0x100:
 return gettext ("OPEN");
      case 0x101:
 return gettext ("func");
      case 4:
 return gettext ("GO BUILDID");
      case 0xcafe1a7e:
 return gettext ("FDO_PACKAGING_METADATA");
      default:
 break;
      }

  snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
  return buff;
}

static 
# 19729 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 19730 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_core_note (Elf_Internal_Note *pnote)
{
  unsigned int addr_size = is_32bit_elf ? 4 : 8;
  uint64_t count, page_size;
  unsigned char *descdata, *filenames, *descend;

  if (pnote->type != 0x46494c45)
    {
      if (do_wide)
 printf ("\n");
      return 
# 19740 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 19740 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  if (!is_32bit_elf)
    {
      printf (gettext ("    Cannot decode 64-bit note in 32-bit build\n"));

      return 
# 19747 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 19747 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  if (pnote->descsz < 2 * addr_size)
    {
      error (gettext ("    Malformed note - too short for header\n"));
      return 
# 19753 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 19753 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  descdata = (unsigned char *) pnote->descdata;
  descend = descdata + pnote->descsz;

  if (descdata[pnote->descsz - 1] != '\0')
    {
      error (gettext ("    Malformed note - does not end with \\0\n"));
      return 
# 19762 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 19762 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  count = byte_get (descdata, addr_size);
  descdata += addr_size;

  page_size = byte_get (descdata, addr_size);
  descdata += addr_size;

  if (count > ((uint64_t) -1 - 2 * addr_size) / (3 * addr_size)
      || pnote->descsz < 2 * addr_size + count * 3 * addr_size)
    {
      error (gettext ("    Malformed note - too short for supplied file count\n"));
      return 
# 19775 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 19775 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  printf (gettext ("    Page size: "));
  print_vma (page_size, DEC);
  printf ("\n");

  printf (gettext ("    %*s%*s%*s\n"),
   (int) (2 + 2 * addr_size), gettext ("Start"),
   (int) (4 + 2 * addr_size), gettext ("End"),
   (int) (4 + 2 * addr_size), gettext ("Page Offset"));
  filenames = descdata + count * 3 * addr_size;
  while (count-- > 0)
    {
      uint64_t start, end, file_ofs;

      if (filenames == descend)
 {
   error (gettext ("    Malformed note - filenames end too early\n"));
   return 
# 19794 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 19794 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      start = byte_get (descdata, addr_size);
      descdata += addr_size;
      end = byte_get (descdata, addr_size);
      descdata += addr_size;
      file_ofs = byte_get (descdata, addr_size);
      descdata += addr_size;

      printf ("    ");
      print_vma (start, FULL_HEX);
      printf ("  ");
      print_vma (end, FULL_HEX);
      printf ("  ");
      print_vma (file_ofs, FULL_HEX);
      printf ("\n        %s\n", filenames);

      filenames += 1 + strlen ((char *) filenames);
    }

  return 
# 19815 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 19815 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_gnu_elf_note_type (unsigned e_type)
{

  switch (e_type)
    {
    case 1:
      return gettext ("NT_GNU_ABI_TAG (ABI version tag)");
    case 2:
      return gettext ("NT_GNU_HWCAP (DSO-supplied software HWCAP info)");
    case 3:
      return gettext ("NT_GNU_BUILD_ID (unique build ID bitstring)");
    case 4:
      return gettext ("NT_GNU_GOLD_VERSION (gold version)");
    case 5:
      return gettext ("NT_GNU_PROPERTY_TYPE_0");
    case 0x100:
      return gettext ("NT_GNU_BUILD_ATTRIBUTE_OPEN");
    case 0x101:
      return gettext ("NT_GNU_BUILD_ATTRIBUTE_FUNC");
    default:
      {
 static char buff[64];

 snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
 return buff;
      }
    }
}

static void
decode_x86_compat_isa (unsigned int bitmask)
{
  while (bitmask)
    {
      unsigned int bit = bitmask & (- bitmask);

      bitmask &= ~ bit;
      switch (bit)
 {
 case (1U << 0):
   printf ("i486");
   break;
 case (1U << 1):
   printf ("586");
   break;
 case (1U << 2):
   printf ("686");
   break;
 case (1U << 3):
   printf ("SSE");
   break;
 case (1U << 4):
   printf ("SSE2");
   break;
 case (1U << 5):
   printf ("SSE3");
   break;
 case (1U << 6):
   printf ("SSSE3");
   break;
 case (1U << 7):
   printf ("SSE4_1");
   break;
 case (1U << 8):
   printf ("SSE4_2");
   break;
 case (1U << 9):
   printf ("AVX");
   break;
 case (1U << 10):
   printf ("AVX2");
   break;
 case (1U << 11):
   printf ("AVX512F");
   break;
 case (1U << 12):
   printf ("AVX512CD");
   break;
 case (1U << 13):
   printf ("AVX512ER");
   break;
 case (1U << 14):
   printf ("AVX512PF");
   break;
 case (1U << 15):
   printf ("AVX512VL");
   break;
 case (1U << 16):
   printf ("AVX512DQ");
   break;
 case (1U << 17):
   printf ("AVX512BW");
   break;
 default:
   printf (gettext ("<unknown: %x>"), bit);
   break;
 }
      if (bitmask)
 printf (", ");
    }
}

static void
decode_x86_compat_2_isa (unsigned int bitmask)
{
  if (!bitmask)
    {
      printf (gettext ("<None>"));
      return;
    }

  while (bitmask)
    {
      unsigned int bit = bitmask & (- bitmask);

      bitmask &= ~ bit;
      switch (bit)
 {
 case (1U << 0):
   printf ("CMOV");
   break;
 case (1U << 1):
   printf ("SSE");
   break;
 case (1U << 2):
   printf ("SSE2");
   break;
 case (1U << 3):
   printf ("SSE3");
   break;
 case (1U << 4):
   printf ("SSSE3");
   break;
 case (1U << 5):
   printf ("SSE4_1");
   break;
 case (1U << 6):
   printf ("SSE4_2");
   break;
 case (1U << 7):
   printf ("AVX");
   break;
 case (1U << 8):
   printf ("AVX2");
   break;
 case (1U << 9):
   printf ("FMA");
   break;
 case (1U << 10):
   printf ("AVX512F");
   break;
 case (1U << 11):
   printf ("AVX512CD");
   break;
 case (1U << 12):
   printf ("AVX512ER");
   break;
 case (1U << 13):
   printf ("AVX512PF");
   break;
 case (1U << 14):
   printf ("AVX512VL");
   break;
 case (1U << 15):
   printf ("AVX512DQ");
   break;
 case (1U << 16):
   printf ("AVX512BW");
   break;
 case (1U << 17):
   printf ("AVX512_4FMAPS");
   break;
 case (1U << 18):
   printf ("AVX512_4VNNIW");
   break;
 case (1U << 19):
   printf ("AVX512_BITALG");
   break;
 case (1U << 20):
   printf ("AVX512_IFMA");
   break;
 case (1U << 21):
   printf ("AVX512_VBMI");
   break;
 case (1U << 22):
   printf ("AVX512_VBMI2");
   break;
 case (1U << 23):
   printf ("AVX512_VNNI");
   break;
 case (1U << 24):
   printf ("AVX512_BF16");
   break;
 default:
   printf (gettext ("<unknown: %x>"), bit);
   break;
 }
      if (bitmask)
 printf (", ");
    }
}

static const char *
get_amdgpu_elf_note_type (unsigned int e_type)
{
  switch (e_type)
    {
    case 32:
      return gettext ("NT_AMDGPU_METADATA (code object metadata)");
    default:
      {
 static char buf[64];
 snprintf (buf, sizeof (buf), gettext ("Unknown note type: (0x%08x)"), e_type);
 return buf;
      }
    }
}

static void
decode_x86_isa (unsigned int bitmask)
{
  while (bitmask)
    {
      unsigned int bit = bitmask & (- bitmask);

      bitmask &= ~ bit;
      switch (bit)
 {
 case (1U << 0):
   printf ("x86-64-baseline");
   break;
 case (1U << 1):
   printf ("x86-64-v2");
   break;
 case (1U << 2):
   printf ("x86-64-v3");
   break;
 case (1U << 3):
   printf ("x86-64-v4");
   break;
 default:
   printf (gettext ("<unknown: %x>"), bit);
   break;
 }
      if (bitmask)
 printf (", ");
    }
}

static void
decode_x86_feature_1 (unsigned int bitmask)
{
  if (!bitmask)
    {
      printf (gettext ("<None>"));
      return;
    }

  while (bitmask)
    {
      unsigned int bit = bitmask & (- bitmask);

      bitmask &= ~ bit;
      switch (bit)
 {
 case (1U << 0):
   printf ("IBT");
   break;
 case (1U << 1):
   printf ("SHSTK");
   break;
 case (1U << 2):
   printf ("LAM_U48");
   break;
 case (1U << 3):
   printf ("LAM_U57");
   break;
 default:
   printf (gettext ("<unknown: %x>"), bit);
   break;
 }
      if (bitmask)
 printf (", ");
    }
}

static void
decode_x86_feature_2 (unsigned int bitmask)
{
  if (!bitmask)
    {
      printf (gettext ("<None>"));
      return;
    }

  while (bitmask)
    {
      unsigned int bit = bitmask & (- bitmask);

      bitmask &= ~ bit;
      switch (bit)
 {
 case (1U << 0):
   printf ("x86");
   break;
 case (1U << 1):
   printf ("x87");
   break;
 case (1U << 2):
   printf ("MMX");
   break;
 case (1U << 3):
   printf ("XMM");
   break;
 case (1U << 4):
   printf ("YMM");
   break;
 case (1U << 5):
   printf ("ZMM");
   break;
 case (1U << 10):
   printf ("TMM");
   break;
 case (1U << 11):
   printf ("MASK");
   break;
 case (1U << 6):
   printf ("FXSR");
   break;
 case (1U << 7):
   printf ("XSAVE");
   break;
 case (1U << 8):
   printf ("XSAVEOPT");
   break;
 case (1U << 9):
   printf ("XSAVEC");
   break;
 default:
   printf (gettext ("<unknown: %x>"), bit);
   break;
 }
      if (bitmask)
 printf (", ");
    }
}

static void
decode_aarch64_feature_1_and (unsigned int bitmask)
{
  while (bitmask)
    {
      unsigned int bit = bitmask & (- bitmask);

      bitmask &= ~ bit;
      switch (bit)
 {
 case (1U << 0):
   printf ("BTI");
   break;

 case (1U << 1):
   printf ("PAC");
   break;

 default:
   printf (gettext ("<unknown: %x>"), bit);
   break;
 }
      if (bitmask)
 printf (", ");
    }
}

static void
decode_1_needed (unsigned int bitmask)
{
  while (bitmask)
    {
      unsigned int bit = bitmask & (- bitmask);

      bitmask &= ~ bit;
      switch (bit)
 {
 case (1U << 0):
   printf ("indirect external access");
   break;
 default:
   printf (gettext ("<unknown: %x>"), bit);
   break;
 }
      if (bitmask)
 printf (", ");
    }
}

static void
print_gnu_property_note (Filedata * filedata, Elf_Internal_Note * pnote)
{
  unsigned char * ptr = (unsigned char *) pnote->descdata;
  unsigned char * ptr_end = ptr + pnote->descsz;
  unsigned int size = is_32bit_elf ? 4 : 8;

  printf (gettext ("      Properties: "));

  if (pnote->descsz < 8 || (pnote->descsz % size) != 0)
    {
      printf (gettext ("<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n"), pnote->descsz);
      return;
    }

  while (ptr < ptr_end)
    {
      unsigned int j;
      unsigned int type;
      unsigned int datasz;

      if ((size_t) (ptr_end - ptr) < 8)
 {
   printf (gettext ("<corrupt descsz: %#lx>\n"), pnote->descsz);
   break;
 }

      type = byte_get (ptr, 4);
      datasz = byte_get (ptr + 4, 4);

      ptr += 8;

      if (datasz > (size_t) (ptr_end - ptr))
 {
   printf (gettext ("<corrupt type (%#x) datasz: %#x>\n"),
    type, datasz);
   break;
 }

      if (type >= 0xc0000000 && type <= 0xdfffffff)
 {
   if (filedata->file_header.e_machine == 62
       || filedata->file_header.e_machine == 6
       || filedata->file_header.e_machine == 3)
     {
       unsigned int bitmask;

       if (datasz == 4)
  bitmask = byte_get (ptr, 4);
       else
  bitmask = 0;

       switch (type)
  {
  case (0xc0010000 + 2):
    if (datasz != 4)
      printf (gettext ("x86 ISA used: <corrupt length: %#x> "),
       datasz);
    else
      {
        printf ("x86 ISA used: ");
        decode_x86_isa (bitmask);
      }
    goto next;

  case (0xc0008000 + 2):
    if (datasz != 4)
      printf (gettext ("x86 ISA needed: <corrupt length: %#x> "),
       datasz);
    else
      {
        printf ("x86 ISA needed: ");
        decode_x86_isa (bitmask);
      }
    goto next;

  case (0xc0000002 + 0):
    if (datasz != 4)
      printf (gettext ("x86 feature: <corrupt length: %#x> "),
       datasz);
    else
      {
        printf ("x86 feature: ");
        decode_x86_feature_1 (bitmask);
      }
    goto next;

  case (0xc0010000 + 1):
    if (datasz != 4)
      printf (gettext ("x86 feature used: <corrupt length: %#x> "),
       datasz);
    else
      {
        printf ("x86 feature used: ");
        decode_x86_feature_2 (bitmask);
      }
    goto next;

  case (0xc0008000 + 1):
    if (datasz != 4)
      printf (gettext ("x86 feature needed: <corrupt length: %#x> "), datasz);
    else
      {
        printf ("x86 feature needed: ");
        decode_x86_feature_2 (bitmask);
      }
    goto next;

  case 0xc0000000:
    if (datasz != 4)
      printf (gettext ("x86 ISA used: <corrupt length: %#x> "),
       datasz);
    else
      {
        printf ("x86 ISA used: ");
        decode_x86_compat_isa (bitmask);
      }
    goto next;

  case 0xc0000001:
    if (datasz != 4)
      printf (gettext ("x86 ISA needed: <corrupt length: %#x> "),
       datasz);
    else
      {
        printf ("x86 ISA needed: ");
        decode_x86_compat_isa (bitmask);
      }
    goto next;

  case (0xc0010000 + 0):
    if (datasz != 4)
      printf (gettext ("x86 ISA used: <corrupt length: %#x> "),
       datasz);
    else
      {
        printf ("x86 ISA used: ");
        decode_x86_compat_2_isa (bitmask);
      }
    goto next;

  case (0xc0008000 + 0):
    if (datasz != 4)
      printf (gettext ("x86 ISA needed: <corrupt length: %#x> "),
       datasz);
    else
      {
        printf ("x86 ISA needed: ");
        decode_x86_compat_2_isa (bitmask);
      }
    goto next;

  default:
    break;
  }
     }
   else if (filedata->file_header.e_machine == 183)
     {
       if (type == 0xc0000000)
  {
    printf ("AArch64 feature: ");
    if (datasz != 4)
      printf (gettext ("<corrupt length: %#x> "), datasz);
    else
      decode_aarch64_feature_1_and (byte_get (ptr, 4));
    goto next;
  }
     }
 }
      else
 {
   switch (type)
     {
     case 1:
       printf (gettext ("stack size: "));
       if (datasz != size)
  printf (gettext ("<corrupt length: %#x> "), datasz);
       else
  printf ("%#" 
# 20393 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              "l" "x"
# 20393 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    , byte_get (ptr, size));
       goto next;

     case 2:
       printf ("no copy on protected ");
       if (datasz)
  printf (gettext ("<corrupt length: %#x> "), datasz);
       goto next;

     default:
       if ((type >= 0xb0000000
     && type <= 0xb0007fff)
    || (type >= 0xb0008000
        && type <= 0xb000ffff))
  {
    switch (type)
      {
      case 0xb0008000:
        if (datasz != 4)
   printf (gettext ("1_needed: <corrupt length: %#x> "),
    datasz);
        else
   {
     unsigned int bitmask = byte_get (ptr, 4);
     printf ("1_needed: ");
     decode_1_needed (bitmask);
   }
        goto next;

      default:
        break;
      }
    if (type <= 0xb0007fff)
      printf (gettext ("UINT32_AND (%#x): "), type);
    else
      printf (gettext ("UINT32_OR (%#x): "), type);
    if (datasz != 4)
      printf (gettext ("<corrupt length: %#x> "), datasz);
    else
      printf ("%#x", (unsigned int) byte_get (ptr, 4));
    goto next;
  }
       break;
     }
 }

      if (type < 0xc0000000)
 printf (gettext ("<unknown type %#x data: "), type);
      else if (type < 0xe0000000)
 printf (gettext ("<processor-specific type %#x data: "), type);
      else
 printf (gettext ("<application-specific type %#x data: "), type);
      for (j = 0; j < datasz; ++j)
 printf ("%02x ", ptr[j] & 0xff);
      printf (">");

    next:
      ptr += ((datasz + (size - 1)) & ~ (size - 1));
      if (ptr == ptr_end)
 break;

      if (do_wide)
 printf (", ");
      else
 printf ("\n\t");
    }

  printf ("\n");
}

static 
# 20463 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 20464 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_gnu_note (Filedata * filedata, Elf_Internal_Note *pnote)
{

  switch (pnote->type)
    {
    case 3:
      {
 size_t i;

 printf (gettext ("    Build ID: "));
 for (i = 0; i < pnote->descsz; ++i)
   printf ("%02x", pnote->descdata[i] & 0xff);
 printf ("\n");
      }
      break;

    case 1:
      {
 unsigned int os, major, minor, subminor;
 const char *osname;


 if (pnote->descsz < 16)
   {
     printf (gettext ("    <corrupt GNU_ABI_TAG>\n"));
     break;
   }

 os = byte_get ((unsigned char *) pnote->descdata, 4);
 major = byte_get ((unsigned char *) pnote->descdata + 4, 4);
 minor = byte_get ((unsigned char *) pnote->descdata + 8, 4);
 subminor = byte_get ((unsigned char *) pnote->descdata + 12, 4);

 switch (os)
   {
   case 0:
     osname = "Linux";
     break;
   case 1:
     osname = "Hurd";
     break;
   case 2:
     osname = "Solaris";
     break;
   case 3:
     osname = "FreeBSD";
     break;
   case 4:
     osname = "NetBSD";
     break;
   case 5:
     osname = "Syllable";
     break;
   case 6:
     osname = "NaCl";
     break;
   default:
     osname = "Unknown";
     break;
   }

 printf (gettext ("    OS: %s, ABI: %d.%d.%d\n"), osname,
  major, minor, subminor);
      }
      break;

    case 4:
      {
 size_t i;

 printf (gettext ("    Version: "));
 for (i = 0; i < pnote->descsz && pnote->descdata[i] != '\0'; ++i)
   printf ("%c", pnote->descdata[i]);
 printf ("\n");
      }
      break;

    case 2:
      {
 unsigned int num_entries, mask;






 printf (gettext ("      Hardware Capabilities: "));
 if (pnote->descsz < 8)
   {
     error (gettext ("<corrupt GNU_HWCAP>\n"));
     return 
# 20554 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 20554 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
   }
 num_entries = byte_get ((unsigned char *) pnote->descdata, 4);
 mask = byte_get ((unsigned char *) pnote->descdata + 4, 4);
 printf (gettext ("num entries: %d, enabled mask: %x\n"), num_entries, mask);

      }
      break;

    case 5:
      print_gnu_property_note (filedata, pnote);
      break;

    default:



      {
 size_t i;

 printf (gettext ("    Description data: "));
 for (i = 0; i < pnote->descsz; ++i)
   printf ("%02x ", pnote->descdata[i] & 0xff);
 printf ("\n");
      }
      break;
    }

  return 
# 20582 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 20582 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static const char *
get_v850_elf_note_type (enum v850_notes n_type)
{
  static char buff[64];

  switch (n_type)
    {
    case V850_NOTE_ALIGNMENT: return gettext ("Alignment of 8-byte objects");
    case V850_NOTE_DATA_SIZE: return gettext ("Sizeof double and long double");
    case V850_NOTE_FPU_INFO: return gettext ("Type of FPU support needed");
    case V850_NOTE_SIMD_INFO: return gettext ("Use of SIMD instructions");
    case V850_NOTE_CACHE_INFO: return gettext ("Use of cache");
    case V850_NOTE_MMU_INFO: return gettext ("Use of MMU");
    default:
      snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), n_type);
      return buff;
    }
}

static 
# 20604 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 20605 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_v850_note (Elf_Internal_Note * pnote)
{
  unsigned int val;

  if (pnote->descsz != 4)
    return 
# 20610 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 20610 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  val = byte_get ((unsigned char *) pnote->descdata, pnote->descsz);

  if (val == 0)
    {
      printf (gettext ("not set\n"));
      return 
# 20617 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 20617 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  switch (pnote->type)
    {
    case V850_NOTE_ALIGNMENT:
      switch (val)
 {
 case 0x0001: printf (gettext ("4-byte\n")); return 
# 20625 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                          1
# 20625 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                              ;
 case 0x0002: printf (gettext ("8-byte\n")); return 
# 20626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                          1
# 20626 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                              ;
 }
      break;

    case V850_NOTE_DATA_SIZE:
      switch (val)
 {
 case 0x0001: printf (gettext ("4-bytes\n")); return 
# 20633 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                        1
# 20633 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                            ;
 case 0x0002: printf (gettext ("8-bytes\n")); return 
# 20634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                        1
# 20634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                            ;
 }
      break;

    case V850_NOTE_FPU_INFO:
      switch (val)
 {
 case 0x0001: printf (gettext ("FPU-2.0\n")); return 
# 20641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                     1
# 20641 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                         ;
 case 0x0002: printf (gettext ("FPU-3.0\n")); return 
# 20642 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                     1
# 20642 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                         ;
 }
      break;

    case V850_NOTE_MMU_INFO:
    case V850_NOTE_CACHE_INFO:
    case V850_NOTE_SIMD_INFO:
      if (val == 0x0001)
 {
   printf (gettext ("yes\n"));
   return 
# 20652 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         1
# 20652 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
 }
      break;

    default:

      break;
    }

  printf (gettext ("unknown value: %x\n"), val);
  return 
# 20662 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 20662 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}

static 
# 20665 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 20666 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_netbsd_elf_note (Elf_Internal_Note * pnote)
{
  unsigned int version;

  switch (pnote->type)
    {
    case 1:
      if (pnote->descsz < 1)
 break;
      version = byte_get ((unsigned char *) pnote->descdata, sizeof (version));
      if ((version / 10000) % 100)
 printf ("  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u%s%c)\n", pnote->descsz,
  version, version / 100000000, (version / 1000000) % 100,
  (version / 10000) % 100 > 26 ? "Z" : "",
  'A' + (version / 10000) % 26);
      else
 printf ("  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u.%u)\n", pnote->descsz,
  version, version / 100000000, (version / 1000000) % 100,
  (version / 100) % 100);
      return 
# 20685 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 20685 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

    case 5:
      printf ("  NetBSD\t\t0x%08lx\tMARCH <%s>\n", pnote->descsz,
       pnote->descdata);
      return 
# 20690 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 20690 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

    case 3:
      if (pnote->descsz < 1)
 break;
      version = byte_get ((unsigned char *) pnote->descdata, sizeof (version));
      printf ("  NetBSD\t\t0x%08lx\tPaX <%s%s%s%s%s%s>\n", pnote->descsz,
       ((version & 0x01) ? "+mprotect" : ""),
       ((version & 0x02) ? "-mprotect" : ""),
       ((version & 0x04) ? "+guard" : ""),
       ((version & 0x08) ? "-guard" : ""),
       ((version & 0x10) ? "+ASLR" : ""),
       ((version & 0x20) ? "-ASLR" : ""));
      return 
# 20703 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 20703 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  printf ("  NetBSD\t0x%08lx\tUnknown note type: (0x%08lx)\n",
   pnote->descsz, pnote->type);
  return 
# 20708 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 20708 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}

static const char *
get_freebsd_elfcore_note_type (Filedata * filedata, unsigned e_type)
{
  switch (e_type)
    {
    case 7:
      return gettext ("NT_THRMISC (thrmisc structure)");
    case 8:
      return gettext ("NT_PROCSTAT_PROC (proc data)");
    case 9:
      return gettext ("NT_PROCSTAT_FILES (files data)");
    case 10:
      return gettext ("NT_PROCSTAT_VMMAP (vmmap data)");
    case 11:
      return gettext ("NT_PROCSTAT_GROUPS (groups data)");
    case 12:
      return gettext ("NT_PROCSTAT_UMASK (umask data)");
    case 13:
      return gettext ("NT_PROCSTAT_RLIMIT (rlimit data)");
    case 14:
      return gettext ("NT_PROCSTAT_OSREL (osreldate data)");
    case 15:
      return gettext ("NT_PROCSTAT_PSSTRINGS (ps_strings data)");
    case 16:
      return gettext ("NT_PROCSTAT_AUXV (auxv data)");
    case 17:
      return gettext ("NT_PTLWPINFO (ptrace_lwpinfo structure)");
    case 0x200:
      return gettext ("NT_X86_SEGBASES (x86 segment base registers)");
    }
  return get_note_type (filedata, e_type);
}

static const char *
get_netbsd_elfcore_note_type (Filedata * filedata, unsigned e_type)
{
  static char buff[64];

  switch (e_type)
    {
    case 1:

      return gettext ("NetBSD procinfo structure");

    case 2:
      return gettext ("NetBSD ELF auxiliary vector data");

    case 24:
      return gettext ("PT_LWPSTATUS (ptrace_lwpstatus structure)");

    default:





      if (e_type < 32)
 {
   snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
   return buff;
 }
      break;
    }

  switch (filedata->file_header.e_machine)
    {



    case 41:
    case 0x9026:
    case 2:
    case 18:
    case 43:
      switch (e_type)
 {
 case 32 + 0:
   return gettext ("PT_GETREGS (reg structure)");
 case 32 + 2:
   return gettext ("PT_GETFPREGS (fpreg structure)");
 default:
   break;
 }
      break;




    case 42:
      switch (e_type)
 {
 case 32 + 1:
   return gettext ("PT___GETREGS40 (old reg structure)");
 case 32 + 3:
   return gettext ("PT_GETREGS (reg structure)");
 case 32 + 5:
   return gettext ("PT_GETFPREGS (fpreg structure)");
 default:
   break;
 }
      break;



    default:
      switch (e_type)
 {
 case 32 + 1:
   return gettext ("PT_GETREGS (reg structure)");
 case 32 + 3:
   return gettext ("PT_GETFPREGS (fpreg structure)");
 default:
   break;
 }
    }

  snprintf (buff, sizeof (buff), "PT_FIRSTMACH+%d",
     e_type - 32);
  return buff;
}

static const char *
get_openbsd_elfcore_note_type (Filedata * filedata, unsigned e_type)
{
  switch (e_type)
    {
    case 10:
      return gettext ("OpenBSD procinfo structure");
    case 11:
      return gettext ("OpenBSD ELF auxiliary vector data");
    case 20:
      return gettext ("OpenBSD regular registers");
    case 21:
      return gettext ("OpenBSD floating point registers");
    case 23:
      return gettext ("OpenBSD window cookie");
    }

  return get_note_type (filedata, e_type);
}

static const char *
get_qnx_elfcore_note_type (Filedata * filedata, unsigned e_type)
{
  switch (e_type)
    {
    case 1:
      return gettext ("QNX debug fullpath");
    case 2:
      return gettext ("QNX debug relocation");
    case 3:
      return gettext ("QNX stack");
    case 4:
      return gettext ("QNX generator");
    case 5:
      return gettext ("QNX default library");
    case 6:
      return gettext ("QNX core sysinfo");
    case 7:
      return gettext ("QNX core info");
    case 8:
      return gettext ("QNX core status");
    case 9:
      return gettext ("QNX general registers");
    case 10:
      return gettext ("QNX floating point registers");
    case 11:
      return gettext ("QNX link map");
    }

  return get_note_type (filedata, e_type);
}

static const char *
get_stapsdt_note_type (unsigned e_type)
{
  static char buff[64];

  switch (e_type)
    {
    case 3:
      return gettext ("NT_STAPSDT (SystemTap probe descriptors)");

    default:
      break;
    }

  snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
  return buff;
}

static 
# 20902 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 20903 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_stapsdt_note (Elf_Internal_Note *pnote)
{
  size_t len, maxlen;
  size_t addr_size = is_32bit_elf ? 4 : 8;
  char *data = pnote->descdata;
  char *data_end = pnote->descdata + pnote->descsz;
  uint64_t pc, base_addr, semaphore;
  char *provider, *probe, *arg_fmt;

  if (pnote->descsz < (addr_size * 3))
    goto stapdt_note_too_small;

  pc = byte_get ((unsigned char *) data, addr_size);
  data += addr_size;

  base_addr = byte_get ((unsigned char *) data, addr_size);
  data += addr_size;

  semaphore = byte_get ((unsigned char *) data, addr_size);
  data += addr_size;

  if (data >= data_end)
    goto stapdt_note_too_small;
  maxlen = data_end - data;
  len = strnlen (data, maxlen);
  if (len < maxlen)
    {
      provider = data;
      data += len + 1;
    }
  else
    goto stapdt_note_too_small;

  if (data >= data_end)
    goto stapdt_note_too_small;
  maxlen = data_end - data;
  len = strnlen (data, maxlen);
  if (len < maxlen)
    {
      probe = data;
      data += len + 1;
    }
  else
    goto stapdt_note_too_small;

  if (data >= data_end)
    goto stapdt_note_too_small;
  maxlen = data_end - data;
  len = strnlen (data, maxlen);
  if (len < maxlen)
    {
      arg_fmt = data;
      data += len + 1;
    }
  else
    goto stapdt_note_too_small;

  printf (gettext ("    Provider: %s\n"), provider);
  printf (gettext ("    Name: %s\n"), probe);
  printf (gettext ("    Location: "));
  print_vma (pc, FULL_HEX);
  printf (gettext (", Base: "));
  print_vma (base_addr, FULL_HEX);
  printf (gettext (", Semaphore: "));
  print_vma (semaphore, FULL_HEX);
  printf ("\n");
  printf (gettext ("    Arguments: %s\n"), arg_fmt);

  return data == data_end;

 stapdt_note_too_small:
  printf (gettext ("  <corrupt - note is too small>\n"));
  error (gettext ("corrupt stapdt note - the data size is too small\n"));
  return 
# 20976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 20976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}

static 
# 20979 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 20980 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_fdo_note (Elf_Internal_Note * pnote)
{
  if (pnote->descsz > 0 && pnote->type == 0xcafe1a7e)
    {
      printf (gettext ("    Packaging Metadata: %.*s\n"), (int) pnote->descsz, pnote->descdata);
      return 
# 20985 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 20985 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }
  return 
# 20987 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 20987 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}

static const char *
get_ia64_vms_note_type (unsigned e_type)
{
  static char buff[64];

  switch (e_type)
    {
    case 1:
      return gettext ("NT_VMS_MHD (module header)");
    case 2:
      return gettext ("NT_VMS_LNM (language name)");
    case 3:
      return gettext ("NT_VMS_SRC (source files)");
    case 4:
      return "NT_VMS_TITLE";
    case 5:
      return gettext ("NT_VMS_EIDC (consistency check)");
    case 6:
      return gettext ("NT_VMS_FPMODE (FP mode)");
    case 101:
      return "NT_VMS_LINKTIME";
    case 102:
      return gettext ("NT_VMS_IMGNAM (image name)");
    case 103:
      return gettext ("NT_VMS_IMGID (image id)");
    case 104:
      return gettext ("NT_VMS_LINKID (link id)");
    case 105:
      return gettext ("NT_VMS_IMGBID (build id)");
    case 106:
      return gettext ("NT_VMS_GSTNAM (sym table name)");
    case 107:
      return "NT_VMS_ORIG_DYN";
    case 108:
      return "NT_VMS_PATCHTIME";
    default:
      snprintf (buff, sizeof (buff), gettext ("Unknown note type: (0x%08x)"), e_type);
      return buff;
    }
}

static 
# 21031 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 21032 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_ia64_vms_note (Elf_Internal_Note * pnote)
{
  unsigned int maxlen = pnote->descsz;

  if (maxlen < 2 || maxlen != pnote->descsz)
    goto desc_size_fail;

  switch (pnote->type)
    {
    case 1:
      if (maxlen <= 36)
 goto desc_size_fail;

      size_t l = strnlen (pnote->descdata + 34, maxlen - 34);

      printf (gettext ("    Creation date  : %.17s\n"), pnote->descdata);
      printf (gettext ("    Last patch date: %.17s\n"), pnote->descdata + 17);
      if (l + 34 < maxlen)
 {
   printf (gettext ("    Module name    : %s\n"), pnote->descdata + 34);
   if (l + 35 < maxlen)
     printf (gettext ("    Module version : %s\n"), pnote->descdata + 34 + l + 1);
   else
     printf (gettext ("    Module version : <missing>\n"));
 }
      else
 {
   printf (gettext ("    Module name    : <missing>\n"));
   printf (gettext ("    Module version : <missing>\n"));
 }
      break;

    case 2:
      printf (gettext ("   Language: %.*s\n"), maxlen, pnote->descdata);
      break;

    case 6:
      printf (gettext ("   Floating Point mode: "));
      if (maxlen < 8)
 goto desc_size_fail;


      printf ("0x%016" 
# 21074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      "l" "x" 
# 21074 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             "\n",
       byte_get ((unsigned char *) pnote->descdata, 8));
      break;

    case 101:
      printf (gettext ("   Link time: "));
      if (maxlen < 8)
 goto desc_size_fail;


      print_vms_time (byte_get ((unsigned char *) pnote->descdata, 8));
      printf ("\n");
      break;

    case 108:
      printf (gettext ("   Patch time: "));
      if (maxlen < 8)
 goto desc_size_fail;


      print_vms_time (byte_get ((unsigned char *) pnote->descdata, 8));
      printf ("\n");
      break;

    case 107:
      if (maxlen < 34)
 goto desc_size_fail;

      printf (gettext ("   Major id: %u,  minor id: %u\n"),
       (unsigned) byte_get ((unsigned char *) pnote->descdata, 4),
       (unsigned) byte_get ((unsigned char *) pnote->descdata + 4, 4));
      printf (gettext ("   Last modified  : "));
      print_vms_time (byte_get ((unsigned char *) pnote->descdata + 8, 8));
      printf (gettext ("\n   Link flags  : "));
      printf ("0x%016" 
# 21108 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      "l" "x" 
# 21108 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             "\n",
       byte_get ((unsigned char *) pnote->descdata + 16, 8));
      printf (gettext ("   Header flags: 0x%08x\n"),
       (unsigned) byte_get ((unsigned char *) pnote->descdata + 24, 4));
      printf (gettext ("   Image id    : %.*s\n"), maxlen - 32, pnote->descdata + 32);
      break;

    case 102:
      printf (gettext ("    Image name: %.*s\n"), maxlen, pnote->descdata);
      break;

    case 106:
      printf (gettext ("    Global symbol table name: %.*s\n"), maxlen, pnote->descdata);
      break;

    case 103:
      printf (gettext ("    Image id: %.*s\n"), maxlen, pnote->descdata);
      break;

    case 104:
      printf (gettext ("    Linker id: %.*s\n"), maxlen, pnote->descdata);
      break;

    default:
      return 
# 21132 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 21132 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  return 
# 21135 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 21135 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

 desc_size_fail:
  printf (gettext ("  <corrupt - data size is too small>\n"));
  error (gettext ("corrupt IA64 note: data size is too small\n"));
  return 
# 21140 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 21140 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}

struct build_attr_cache {
  Filedata *filedata;
  char *strtab;
  uint64_t strtablen;
  Elf_Internal_Sym *symtab;
  uint64_t nsyms;
} ba_cache;






static Elf_Internal_Sym *
get_symbol_for_build_attribute (Filedata *filedata,
    uint64_t offset,
    
# 21159 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
   _Bool 
# 21159 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        is_open_attr,
    const char **pname)
{
  Elf_Internal_Sym *saved_sym = 
# 21162 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               ((void *)0)
# 21162 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   ;
  Elf_Internal_Sym *sym;

  if (filedata->section_headers != 
# 21165 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
      
# 21166 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     && (ba_cache.filedata == 
# 21166 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                              ((void *)0) 
# 21166 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   || filedata != ba_cache.filedata))
    {
      Elf_Internal_Shdr * symsec;

      free (ba_cache.strtab);
      ba_cache.strtab = 
# 21171 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 21171 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
      free (ba_cache.symtab);
      ba_cache.symtab = 
# 21173 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 21173 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;


      for (symsec = filedata->section_headers;
    symsec < filedata->section_headers + filedata->file_header.e_shnum;
    symsec ++)
 {
   if (symsec->sh_type == 2
       && get_symtab (filedata, symsec,
        &ba_cache.symtab, &ba_cache.nsyms,
        &ba_cache.strtab, &ba_cache.strtablen))
     break;
 }
      ba_cache.filedata = filedata;
    }

  if (ba_cache.symtab == 
# 21189 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0)
# 21189 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                            )
    return 
# 21190 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((void *)0)
# 21190 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;


  for (sym = ba_cache.symtab; sym < ba_cache.symtab + ba_cache.nsyms; sym ++)
    if (sym->st_value == offset)
      {
 if (sym->st_name >= ba_cache.strtablen)

   continue;

 if (ba_cache.strtab[sym->st_name] == 0)
   continue;



 if (ba_cache.strtab[sym->st_name] == '$'
     && ba_cache.strtab[sym->st_name + 1] != 0
     && ba_cache.strtab[sym->st_name + 2] == 0)
   continue;

 if (is_open_attr)
   {



     switch (((sym->st_info) & 0xF))
       {
       case 1:
       case 4:
  saved_sym = sym;
  if (sym->st_size)
    {


      sym = ba_cache.symtab + ba_cache.nsyms;
    }
  continue;

       case 2:

  continue;

       default:
  break;
       }

     switch ((((unsigned int)(sym->st_info)) >> 4))
       {
       case 1:
  if (saved_sym == 
# 21239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
      
# 21240 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     || ((saved_sym->st_info) & 0xF) != 1)
    saved_sym = sym;
  break;

       case 0:
  if (saved_sym == 
# 21245 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 21245 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
    saved_sym = sym;
  break;

       default:
  break;
       }
   }
 else
   {
     if (((sym->st_info) & 0xF) != 2)
       continue;

     saved_sym = sym;
     break;
   }
      }

  if (saved_sym && pname)
    * pname = ba_cache.strtab + saved_sym->st_name;

  return saved_sym;
}



static 
# 21271 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 21272 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
same_section (Filedata * filedata, uint64_t addr1, uint64_t addr2)
{
  Elf_Internal_Shdr * a1;
  Elf_Internal_Shdr * a2;

  a1 = find_section_by_address (filedata, addr1);
  a2 = find_section_by_address (filedata, addr2);

  return a1 == a2 && a1 != 
# 21280 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          ((void *)0)
# 21280 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              ;
}

static 
# 21283 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 21284 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_gnu_build_attribute_description (Elf_Internal_Note * pnote,
           Filedata * filedata)
{
  static uint64_t global_offset = 0;
  static uint64_t global_end = 0;
  static uint64_t func_offset = 0;
  static uint64_t func_end = 0;

  Elf_Internal_Sym *sym;
  const char *name;
  uint64_t start;
  uint64_t end;
  
# 21296 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 21296 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      is_open_attr = pnote->type == 0x100;

  switch (pnote->descsz)
    {
    case 0:


      if (is_open_attr)
 {
   if (global_end > global_offset)
     printf (gettext ("    Applies to region from %#" 
# 21306 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 21306 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " to %#" 
# 21306 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 21306 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n")
                             , global_offset, global_end);
   else
     printf (gettext ("    Applies to region from %#" 
# 21309 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 21309 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n")
             , global_offset);
 }
      else
 {
   if (func_end > func_offset)
     printf (gettext ("    Applies to region from %#" 
# 21315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 21315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            " to %#" 
# 21315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 21315 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n")
                             , func_offset, func_end);
   else
     printf (gettext ("    Applies to region from %#" 
# 21318 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            "l" "x" 
# 21318 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            "\n")
             , func_offset);
 }
      return 
# 21321 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 21321 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

    case 4:
      start = byte_get ((unsigned char *) pnote->descdata, 4);
      end = 0;
      break;

    case 8:
      start = byte_get ((unsigned char *) pnote->descdata, 4);
      end = byte_get ((unsigned char *) pnote->descdata + 4, 4);
      break;

    case 16:
      start = byte_get ((unsigned char *) pnote->descdata, 8);
      end = byte_get ((unsigned char *) pnote->descdata + 8, 8);
      break;

    default:
      error (gettext ("    <invalid description size: %lx>\n"), pnote->descsz);
      printf (gettext ("    <invalid descsz>"));
      return 
# 21341 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 21341 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  name = 
# 21344 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 21344 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
  sym = get_symbol_for_build_attribute (filedata, start, is_open_attr, & name);



  if (sym == 
# 21349 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0) 
# 21349 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 && is_open_attr)
    sym = get_symbol_for_build_attribute (filedata, start + 2, is_open_attr,
       & name);

  if (end == 0 && sym != 
# 21353 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                        ((void *)0) 
# 21353 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             && sym->st_size > 0)
    end = start + sym->st_size;

  if (is_open_attr)
    {


      if (global_end > 0
   && start > ((((bfd_vma) (global_end) + (16) - 1) >= (bfd_vma) (global_end)) ? (((bfd_vma) (global_end) + ((16) - 1)) & ~ (bfd_vma) ((16)-1)) : ~ (bfd_vma) 0)



   && same_section (filedata, start, global_end))
 warn (gettext ("Gap in build notes detected from %#" 
# 21366 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      "l" "x" 
# 21366 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      " to %#" 
# 21366 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      "l" "x" 
# 21366 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      "\n")
                       ,
       global_end + 1, start - 1);

      printf (gettext ("    Applies to region from %#" 
# 21370 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "x"
# 21370 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ), start);
      global_offset = start;

      if (end)
 {
   printf (gettext (" to %#" 
# 21375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "x"
# 21375 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          ), end);
   global_end = end;
 }
    }
  else
    {
      printf (gettext ("    Applies to region from %#" 
# 21381 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "l" "x"
# 21381 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ), start);
      func_offset = start;

      if (end)
 {
   printf (gettext (" to %#" 
# 21386 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "x"
# 21386 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          ), end);
   func_end = end;
 }
    }

  if (sym && name)
    printf (gettext (" (%s)"), name);

  printf ("\n");
  return 
# 21395 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 21395 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 21398 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 21399 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_gnu_build_attribute_name (Elf_Internal_Note * pnote)
{
  static const char string_expected [2] = { '$', 0 };
  static const char number_expected [2] = { '*', 0 };
  static const char bool_expected [3] = { '+', '!', 0 };
  char name_type;
  char name_attribute;
  const char * expected_types;
  const char * name = pnote->namedata;
  const char * text;
  signed int left;

  if (name == 
# 21411 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0) 
# 21411 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  || pnote->namesz < 2)
    {
      error (gettext ("corrupt name field in GNU build attribute note: size = %ld\n"), pnote->namesz);
      print_symbol (-20, gettext ("  <corrupt name>"));
      return 
# 21415 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 21415 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  if (do_wide)
    left = 28;
  else
    left = 20;


  if (name[0] == 'G' && name[1] == 'A')
    {
      if (pnote->namesz < 4)
 {
   error (gettext ("corrupt name field in GNU build attribute note: size = %ld\n"), pnote->namesz);
   print_symbol (-20, gettext ("  <corrupt name>"));
   return 
# 21430 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 21430 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
 }

      printf ("GA");
      name += 2;
      left -= 2;
    }

  switch ((name_type = * name))
    {
    case '*':
    case '$':
    case '+':
    case '!':
      printf ("%c", * name);
      left --;
      break;
    default:
      error (gettext ("unrecognised attribute type in name field: %d\n"), name_type);
      print_symbol (-20, gettext ("<unknown name type>"));
      return 
# 21450 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 21450 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  ++ name;
  text = 
# 21454 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 21454 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

  switch ((name_attribute = * name))
    {
    case 1:
      text = gettext ("<version>");
      expected_types = string_expected;
      ++ name;
      break;
    case 2:
      text = gettext ("<stack prot>");
      expected_types = "!+*";
      ++ name;
      break;
    case 3:
      text = gettext ("<relro>");
      expected_types = bool_expected;
      ++ name;
      break;
    case 4:
      text = gettext ("<stack size>");
      expected_types = number_expected;
      ++ name;
      break;
    case 5:
      text = gettext ("<tool>");
      expected_types = string_expected;
      ++ name;
      break;
    case 6:
      text = gettext ("<ABI>");
      expected_types = "$*";
      ++ name;
      break;
    case 7:
      text = gettext ("<PIC>");
      expected_types = number_expected;
      ++ name;
      break;
    case 8:
      text = gettext ("<short enum>");
      expected_types = bool_expected;
      ++ name;
      break;
    default:
      if ((_sch_istable[(* name) & 0xff] & (unsigned short)(_sch_isprint)))
 {
   int len = strnlen (name, pnote->namesz - (name - pnote->namedata)) + 1;

   if (len > left && ! do_wide)
     len = left;
   printf ("%.*s:", len, name);
   left -= len;
   name += len;
 }
      else
 {
   static char tmpbuf [128];

   error (gettext ("unrecognised byte in name field: %d\n"), * name);
   sprintf (tmpbuf, gettext ("<unknown:_%d>"), * name);
   text = tmpbuf;
   name ++;
 }
      expected_types = "*$!+";
      break;
    }

  if (text)
    left -= printf ("%s", text);

  if (strchr (expected_types, name_type) == 
# 21525 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                           ((void *)0)
# 21525 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                               )
    warn (gettext ("attribute does not have an expected type (%c)\n"), name_type);

  if ((size_t) (name - pnote->namedata) > pnote->namesz)
    {
      error (gettext ("corrupt name field: namesz: %lu but parsing gets to %td\n"),
      pnote->namesz,
      name - pnote->namedata);
      return 
# 21533 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 21533 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  if (left < 1 && ! do_wide)
    return 
# 21537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 21537 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  switch (name_type)
    {
    case '*':
      {
 unsigned int bytes;
 uint64_t val = 0;
 unsigned int shift = 0;
 char *decoded = 
# 21546 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                ((void *)0)
# 21546 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;

 bytes = pnote->namesz - (name - pnote->namedata);
 if (bytes > 0)



   -- bytes;

 if (bytes > sizeof (val))
   {
     error (gettext ("corrupt numeric name field: too many bytes in the value: %x\n"),
     bytes);
     bytes = sizeof (val);
   }



 while (bytes --)
   {
     uint64_t byte = *name++ & 0xff;

     val |= byte << shift;
     shift += 8;
   }

 switch (name_attribute)
   {
   case 7:
     switch (val)
       {
       case 0: decoded = "static"; break;
       case 1: decoded = "pic"; break;
       case 2: decoded = "PIC"; break;
       case 3: decoded = "pie"; break;
       case 4: decoded = "PIE"; break;
       default: break;
       }
     break;
   case 2:
     switch (val)
       {

       case 0: decoded = "off"; break;
       case 1: decoded = "on"; break;
       case 2: decoded = "all"; break;
       case 3: decoded = "strong"; break;
       case 4: decoded = "explicit"; break;
       default: break;
       }
     break;
   default:
     break;
   }

 if (decoded != 
# 21601 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 21601 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   )
   {
     print_symbol (-left, decoded);
     left = 0;
   }
 else if (val == 0)
   {
     printf ("0x0");
     left -= 3;
   }
 else
   {
     if (do_wide)
       left -= printf ("0x%" 
# 21614 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            "l" "x"
# 21614 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                  , val);
     else
       left -= printf ("0x%-.*" 
# 21616 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               "l" "x"
# 21616 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                     , left, val);
   }
      }
      break;
    case '$':
      left -= print_symbol (- left, name);
      break;
    case '+':
      left -= print_symbol (- left, "true");
      break;
    case '!':
      left -= print_symbol (- left, "false");
      break;
    }

  if (do_wide && left > 0)
    printf ("%-*s", left, " ");

  return 
# 21634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 21634 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}



static void
print_note_contents_hex (Elf_Internal_Note *pnote)
{
  if (pnote->descsz)
    {
      size_t i;

      printf (gettext ("   description data: "));
      for (i = 0; i < pnote->descsz; i++)
 printf ("%02x ", pnote->descdata[i] & 0xff);
      if (!do_wide)
 printf ("\n");
    }

  if (do_wide)
    printf ("\n");
}
# 21771 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static 
# 21771 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 21772 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_amdgpu_note (Elf_Internal_Note *pnote)
{
# 21803 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
  print_note_contents_hex (pnote);
  return 
# 21804 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 21804 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

}

static 
# 21808 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 21809 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
print_qnx_note (Elf_Internal_Note *pnote)
{
  switch (pnote->type)
    {
    case 3:
      if (pnote->descsz != 12)
 goto desc_size_fail;

      printf (gettext ("   Stack Size: 0x%" 
# 21817 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "x" 
# 21817 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             "\n"),
       (unsigned) byte_get ((unsigned char *) pnote->descdata, 4));
      printf (gettext ("   Stack allocated: %" 
# 21819 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             "x" 
# 21819 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             "\n"),
       (unsigned) byte_get ((unsigned char *) pnote->descdata + 4, 4));
      printf (gettext ("   Executable: %s\n"),
       ((unsigned) byte_get ((unsigned char *) pnote->descdata + 8, 1)) ? "no": "yes");
      break;

    default:
      print_note_contents_hex(pnote);
    }
  return 
# 21828 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 21828 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

desc_size_fail:
  printf (gettext ("  <corrupt - data size is too small>\n"));
  error (gettext ("corrupt QNX note: data size is too small\n"));
  return 
# 21833 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 21833 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}
# 21843 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
static 
# 21843 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 21844 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_note (Elf_Internal_Note * pnote,
       Filedata * filedata)
{
  const char * name = pnote->namesz ? pnote->namedata : "(NONE)";
  const char * nt;

  if (pnote->namesz == 0)


    nt = get_note_type (filedata, pnote->type);

  else if (startswith (pnote->namedata, "GNU"))

    nt = get_gnu_elf_note_type (pnote->type);

  else if (startswith (pnote->namedata, "AMDGPU"))

    nt = get_amdgpu_elf_note_type (pnote->type);

  else if (startswith (pnote->namedata, "FreeBSD"))

    nt = get_freebsd_elfcore_note_type (filedata, pnote->type);

  else if (startswith (pnote->namedata, "NetBSD-CORE"))

    nt = get_netbsd_elfcore_note_type (filedata, pnote->type);

  else if (startswith (pnote->namedata, "NetBSD"))

    return process_netbsd_elf_note (pnote);

  else if (startswith (pnote->namedata, "PaX"))

    return process_netbsd_elf_note (pnote);

  else if (startswith (pnote->namedata, "OpenBSD"))

    nt = get_openbsd_elfcore_note_type (filedata, pnote->type);

  else if (startswith (pnote->namedata, "QNX"))

    nt = get_qnx_elfcore_note_type (filedata, pnote->type);

  else if (startswith (pnote->namedata, "SPU/"))
    {

      nt = pnote->namedata + 4;
      name = "SPU";
    }

  else if (startswith (pnote->namedata, "IPF/VMS"))

    nt = get_ia64_vms_note_type (pnote->type);

  else if (startswith (pnote->namedata, "stapsdt"))
    nt = get_stapsdt_note_type (pnote->type);

  else


    nt = get_note_type (filedata, pnote->type);

  printf ("  ");

  if (((startswith (pnote->namedata, "GA")
 && strchr ("*$!+", pnote->namedata[2]) != 
# 21909 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
# 21909 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              )
       || strchr ("*$!+", pnote->namedata[0]) != 
# 21910 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                ((void *)0)
# 21910 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                    )
      && (pnote->type == 0x100
   || pnote->type == 0x101))
    print_gnu_build_attribute_name (pnote);
  else
    print_symbol (-20, name);

  if (do_wide)
    printf (" 0x%08lx\t%s\t", pnote->descsz, nt);
  else
    printf (" 0x%08lx\t%s\n", pnote->descsz, nt);

  if (startswith (pnote->namedata, "IPF/VMS"))
    return print_ia64_vms_note (pnote);
  else if (startswith (pnote->namedata, "GNU"))
    return print_gnu_note (filedata, pnote);
  else if (startswith (pnote->namedata, "stapsdt"))
    return print_stapsdt_note (pnote);
  else if (startswith (pnote->namedata, "CORE"))
    return print_core_note (pnote);
  else if (startswith (pnote->namedata, "FDO"))
    return print_fdo_note (pnote);
  else if (((startswith (pnote->namedata, "GA")
      && strchr ("*$!+", pnote->namedata[2]) != 
# 21933 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                               ((void *)0)
# 21933 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                   )
     || strchr ("*$!+", pnote->namedata[0]) != 
# 21934 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              ((void *)0)
# 21934 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                  )
    && (pnote->type == 0x100
        || pnote->type == 0x101))
    return print_gnu_build_attribute_description (pnote, filedata);
  else if (startswith (pnote->namedata, "AMDGPU")
    && pnote->type == 32)
    return print_amdgpu_note (pnote);
  else if (startswith (pnote->namedata, "QNX"))
    return print_qnx_note (pnote);

  print_note_contents_hex (pnote);
  return 
# 21945 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 21945 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static 
# 21948 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 21949 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_notes_at (Filedata * filedata,
    Elf_Internal_Shdr * section,
    uint64_t offset,
    uint64_t length,
    uint64_t align)
{
  Elf_External_Note *pnotes;
  Elf_External_Note *external;
  char *end;
  
# 21958 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 21958 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 21958 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 21958 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (length <= 0)
    return 
# 21961 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 21961 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  if (section)
    {
      pnotes = (Elf_External_Note *) get_section_contents (section, filedata);
      if (pnotes)
 {
   if (! apply_relocations (filedata, section, (unsigned char *) pnotes, length, 
# 21968 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                                ((void *)0)
# 21968 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                    , 
# 21968 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                                      ((void *)0)
# 21968 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                                          ))
     {
       free (pnotes);
       return 
# 21971 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             0
# 21971 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  ;
     }
 }
    }
  else
    pnotes = (Elf_External_Note *) get_data (
# 21976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                            ((void *)0)
# 21976 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                , filedata, offset, 1, length,
          gettext ("notes"));

  if (pnotes == 
# 21979 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 21979 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   )
    return 
# 21980 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 21980 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  external = pnotes;

  if (filedata->is_separate)
    printf (gettext ("In linked file '%s': "), filedata->file_name);
  else
    printf ("\n");
  if (section)
    printf (gettext ("Displaying notes found in: %s\n"), printable_section_name (filedata, section));
  else
    printf (gettext ("Displaying notes found at file offset 0x%08" 
# 21991 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           "l" "x" 
# 21991 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           " with length 0x%08" 
# 21991 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           "l" "x" 
# 21991 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ":\n")
                                         ,
     offset, length);






  if (align < 4)
    align = 4;
  else if (align != 4 && align != 8)
    {
      warn (gettext ("Corrupt note: alignment %" 
# 22004 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           "l" "d" 
# 22004 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ", expecting 4 or 8\n"),
     align);
      free (pnotes);
      return 
# 22007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 22007 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  printf (gettext ("  %-20s %-10s\tDescription\n"), gettext ("Owner"), gettext ("Data size"));

  end = (char *) pnotes + length;
  while ((char *) external < end)
    {
      Elf_Internal_Note inote;
      size_t min_notesz;
      char * next;
      char * temp = 
# 22018 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 22018 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
      size_t data_remaining = end - (char *) external;

      if (!is_ia64_vms (filedata))
 {


   min_notesz = 
# 22025 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               __builtin_offsetof (
# 22025 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               Elf_External_Note
# 22025 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               , 
# 22025 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               name
# 22025 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               )
# 22025 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                 ;
   if (data_remaining < min_notesz)
     {
       warn (ngettext ("Corrupt note: only %zd byte remains, "
         "not enough for a full note\n",
         "Corrupt note: only %zd bytes remain, "
         "not enough for a full note\n",
         data_remaining),
      data_remaining);
       break;
     }
   data_remaining -= min_notesz;

   inote.type = byte_get (external->type, sizeof (external->type));
   inote.namesz = byte_get (external->namesz, sizeof (external->namesz));
   inote.namedata = external->name;
   inote.descsz = byte_get (external->descsz, sizeof (external->descsz));
   inote.descdata = ((char *) external
       + (((bfd_vma) (
# 22043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        __builtin_offsetof (
# 22043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        Elf_External_Note
# 22043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        , 
# 22043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        name
# 22043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ) 
# 22043 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
        + (inote.namesz)) + (((align)) - 1)) & ~ (bfd_vma) (((align)) -1)));
   inote.descpos = offset + (inote.descdata - (char *) pnotes);
   next = ((char *) external
    + (((bfd_vma) ((((bfd_vma) (
# 22046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     __builtin_offsetof (
# 22046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     Elf_External_Note
# 22046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     , 
# 22046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     name
# 22046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ) 
# 22046 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     + ((inote.namesz))) + ((((align))) - 1)) & ~ (bfd_vma) ((((align))) -1)) + (inote.descsz)) + (((align)) - 1)) & ~ (bfd_vma) (((align)) -1)));
 }
      else
 {
   Elf64_External_VMS_Note *vms_external;



   min_notesz = 
# 22054 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               __builtin_offsetof (
# 22054 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               Elf64_External_VMS_Note
# 22054 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               , 
# 22054 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               name
# 22054 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               )
# 22054 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                       ;
   if (data_remaining < min_notesz)
     {
       warn (ngettext ("Corrupt note: only %zd byte remains, "
         "not enough for a full note\n",
         "Corrupt note: only %zd bytes remain, "
         "not enough for a full note\n",
         data_remaining),
      data_remaining);
       break;
     }
   data_remaining -= min_notesz;

   vms_external = (Elf64_External_VMS_Note *) external;
   inote.type = byte_get (vms_external->type, sizeof (vms_external->type));
   inote.namesz = byte_get (vms_external->namesz, sizeof (vms_external->namesz));
   inote.namedata = vms_external->name;
   inote.descsz = byte_get (vms_external->descsz, sizeof (vms_external->descsz));
   inote.descdata = inote.namedata + (((inote.namesz) + ((bfd_vma) 1 << (3)) - 1) & (-((bfd_vma) 1 << (3))));
   inote.descpos = offset + (inote.descdata - (char *) pnotes);
   next = inote.descdata + (((inote.descsz) + ((bfd_vma) 1 << (3)) - 1) & (-((bfd_vma) 1 << (3))));
 }



      if ((size_t) (inote.descdata - inote.namedata) < inote.namesz
   || (size_t) (inote.descdata - inote.namedata) > data_remaining
   || (size_t) (next - inote.descdata) < inote.descsz
   || ((size_t) (next - inote.descdata)
       > data_remaining - (size_t) (inote.descdata - inote.namedata)))
 {
   warn (gettext ("note with invalid namesz and/or descsz found at offset %#tx\n"),
  (char *) external - (char *) pnotes);
   warn (gettext (" type: %#lx, namesize: %#lx, descsize: %#lx, alignment: %u\n"),
  inote.type, inote.namesz, inote.descsz, (int) align);
   break;
 }

      external = (Elf_External_Note *) next;





      if (inote.namesz > 0 && inote.namedata[inote.namesz - 1] != '\0')
 {
   if ((size_t) (inote.descdata - inote.namedata) == inote.namesz)
     {
       temp = (char *) malloc (inote.namesz + 1);
       if (temp == 
# 22103 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 22103 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      )
  {
    error (gettext ("Out of memory allocating space for inote name\n"));
    res = 
# 22106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22106 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
    break;
  }

       memcpy (temp, inote.namedata, inote.namesz);
       inote.namedata = temp;
     }
   inote.namedata[inote.namesz] = 0;
 }

      if (! process_note (& inote, filedata))
 res = 
# 22117 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 22117 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ;

      free (temp);
      temp = 
# 22120 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            ((void *)0)
# 22120 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
    }

  free (pnotes);

  return res;
}

static 
# 22128 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 22129 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_corefile_note_segments (Filedata * filedata)
{
  Elf_Internal_Phdr *segment;
  unsigned int i;
  
# 22133 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 22133 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 22133 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 22133 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (! get_program_headers (filedata))
    return 
# 22136 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 22136 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  for (i = 0, segment = filedata->program_headers;
       i < filedata->file_header.e_phnum;
       i++, segment++)
    {
      if (segment->p_type == 4)
 if (! process_notes_at (filedata, 
# 22143 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                  ((void *)0)
# 22143 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      , segment->p_offset,
    segment->p_filesz, segment->p_align))
   res = 
# 22145 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 22145 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
    }

  return res;
}

static 
# 22151 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 22152 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_v850_notes (Filedata * filedata, uint64_t offset, uint64_t length)
{
  Elf_External_Note * pnotes;
  Elf_External_Note * external;
  char * end;
  
# 22157 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 22157 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 22157 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 22157 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (length <= 0)
    return 
# 22160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22160 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  pnotes = (Elf_External_Note *) get_data (
# 22162 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
# 22162 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              , filedata, offset, 1, length,
                                           gettext ("v850 notes"));
  if (pnotes == 
# 22164 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               ((void *)0)
# 22164 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   )
    return 
# 22165 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22165 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  external = pnotes;
  end = (char*) pnotes + length;

  printf (gettext ("\nDisplaying contents of Renesas V850 notes section at offset" " %#" 
# 22170 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "x" 
# 22170 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         " with length %#" 
# 22170 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         "l" "x" 
# 22170 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
         ":\n")
                                                 ,
   offset, length);

  while ((char *) external + sizeof (Elf_External_Note) < end)
    {
      Elf_External_Note * next;
      Elf_Internal_Note inote;

      inote.type = byte_get (external->type, sizeof (external->type));
      inote.namesz = byte_get (external->namesz, sizeof (external->namesz));
      inote.namedata = external->name;
      inote.descsz = byte_get (external->descsz, sizeof (external->descsz));
      inote.descdata = inote.namedata + (((inote.namesz) + ((bfd_vma) 1 << (2)) - 1) & (-((bfd_vma) 1 << (2))));
      inote.descpos = offset + (inote.descdata - (char *) pnotes);

      if (inote.descdata < (char *) pnotes || inote.descdata >= end)
 {
   warn (gettext ("Corrupt note: name size is too big: %lx\n"), inote.namesz);
   inote.descdata = inote.namedata;
   inote.namesz = 0;
 }

      next = (Elf_External_Note *) (inote.descdata + (((inote.descsz) + ((bfd_vma) 1 << (2)) - 1) & (-((bfd_vma) 1 << (2)))));

      if ( ((char *) next > end)
   || ((char *) next < (char *) pnotes))
 {
   warn (gettext ("corrupt descsz found in note at offset %#tx\n"),
  (char *) external - (char *) pnotes);
   warn (gettext (" type: %#lx, namesize: %#lx, descsize: %#lx\n"),
  inote.type, inote.namesz, inote.descsz);
   break;
 }

      external = next;


      if ( inote.namedata + inote.namesz > end
   || inote.namedata + inote.namesz < inote.namedata)
        {
          warn (gettext ("corrupt namesz found in note at offset %#zx\n"),
                (char *) external - (char *) pnotes);
          warn (gettext (" type: %#lx, namesize: %#lx, descsize: %#lx\n"),
                inote.type, inote.namesz, inote.descsz);
          break;
        }

      printf ("  %s: ", get_v850_elf_note_type (inote.type));

      if (! print_v850_note (& inote))
 {
   res = 
# 22222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 22222 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
   printf ("<corrupt sizes: namesz: %#lx, descsz: %#lx>\n",
    inote.namesz, inote.descsz);
 }
    }

  free (pnotes);

  return res;
}

static 
# 22233 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 22234 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_note_sections (Filedata * filedata)
{
  Elf_Internal_Shdr *section;
  size_t i;
  unsigned int n = 0;
  
# 22239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 22239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res = 
# 22239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 22239 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  for (i = 0, section = filedata->section_headers;
       i < filedata->file_header.e_shnum && section != 
# 22242 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                      ((void *)0)
# 22242 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                          ;
       i++, section++)
    {
      if (section->sh_type == 7)
 {
   if (! process_notes_at (filedata, section, section->sh_offset,
      section->sh_size, section->sh_addralign))
     res = 
# 22249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22249 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   n++;
 }

      if (( filedata->file_header.e_machine == 36
    || filedata->file_header.e_machine == 87
    || filedata->file_header.e_machine == 0x9080)
   && section->sh_type == 0xa0000000)
 {
   if (! process_v850_notes (filedata, section->sh_offset,
        section->sh_size))
     res = 
# 22260 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22260 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   n++;
 }
    }

  if (n == 0)

    return process_corefile_note_segments (filedata);

  return res;
}

static 
# 22272 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 22273 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_notes (Filedata * filedata)
{

  if (! do_notes)
    return 
# 22277 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 22277 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (filedata->file_header.e_type != 4)
    return process_note_sections (filedata);


  if (filedata->file_header.e_phnum > 0)
    return process_corefile_note_segments (filedata);

  if (filedata->is_separate)
    printf (gettext ("No notes found in linked file '%s'.\n"),
     filedata->file_name);
  else
    printf (gettext ("No notes found file.\n"));

  return 
# 22292 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 22292 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static unsigned char *
display_public_gnu_attributes (unsigned char * start,
          const unsigned char * const end)
{
  printf (gettext ("  Unknown GNU attribute: %s\n"), start);

  start += strnlen ((char *) start, end - start);
  display_raw_attribute (start, end);

  return (unsigned char *) end;
}

static unsigned char *
display_generic_attribute (unsigned char * start,
      unsigned int tag,
      const unsigned char * const end)
{
  if (tag == 0)
    return (unsigned char *) end;

  return display_tag_value (tag, start, end);
}

static 
# 22318 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 22319 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_arch_specific (Filedata * filedata)
{
  if (! do_arch)
    return 
# 22322 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 22322 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  switch (filedata->file_header.e_machine)
    {
    case 45:
    case 93:
    case 195:
    case 255:
    case 253:
      return process_attributes (filedata, "ARC", 0x70000001,
     display_arc_attribute,
     display_generic_attribute);
    case 40:
      return process_attributes (filedata, "aeabi", 0x70000003,
     display_arm_attribute,
     display_generic_attribute);

    case 8:
    case 10:
      return process_mips_specific (filedata);

    case 105:
     return process_attributes (filedata, "mspabi", 0x70000003,
    display_msp430_attribute,
    display_msp430_gnu_attribute);

    case 243:
     return process_attributes (filedata, "riscv", 0x70000003,
    display_riscv_attribute,
    display_generic_attribute);

    case 167:
      return process_nds32_specific (filedata);

    case 4:
      return process_attributes (filedata, 
# 22357 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
# 22357 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              , 0x6ffffff5, 
# 22357 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                    ((void *)0)
# 22357 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                        ,
     display_m68k_gnu_attribute);

    case 20:
    case 21:
      return process_attributes (filedata, 
# 22362 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
# 22362 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              , 0x6ffffff5, 
# 22362 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                    ((void *)0)
# 22362 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                        ,
     display_power_gnu_attribute);

    case 22:
    case 0xa390:
      return process_attributes (filedata, 
# 22367 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
# 22367 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              , 0x6ffffff5, 
# 22367 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                    ((void *)0)
# 22367 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                        ,
     display_s390_gnu_attribute);

    case 2:
    case 18:
    case 43:
      return process_attributes (filedata, 
# 22373 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                          ((void *)0)
# 22373 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                              , 0x6ffffff5, 
# 22373 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                    ((void *)0)
# 22373 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                        ,
     display_sparc_gnu_attribute);

    case 140:
      return process_attributes (filedata, "c6xabi", 0x70000003,
     display_tic6x_attribute,
     display_generic_attribute);

    case 252:
      return process_attributes (filedata, "csky", 0x70000001,
     display_csky_attribute, 
# 22383 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            ((void *)0)
# 22383 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                );

    default:
      return process_attributes (filedata, "gnu", 0x6ffffff5,
     display_public_gnu_attributes,
     display_generic_attribute);
    }
}

static 
# 22392 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 22393 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
get_file_header (Filedata * filedata)
{

  if (fread (filedata->file_header.e_ident, 16, 1, filedata->handle) != 1)
    return 
# 22397 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22397 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;


  switch (filedata->file_header.e_ident[5])
    {
    default:
    case 0:
    case 1:
      byte_get = byte_get_little_endian;
      byte_put = byte_put_little_endian;
      break;
    case 2:
      byte_get = byte_get_big_endian;
      byte_put = byte_put_big_endian;
      break;
    }


  is_32bit_elf = (filedata->file_header.e_ident[4] != 2);


  if (is_32bit_elf)
    {
      Elf32_External_Ehdr ehdr32;

      if (fread (ehdr32.e_type, sizeof (ehdr32) - 16, 1, filedata->handle) != 1)
 return 
# 22423 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22423 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      filedata->file_header.e_type = byte_get (ehdr32.e_type, sizeof (ehdr32.e_type));
      filedata->file_header.e_machine = byte_get (ehdr32.e_machine, sizeof (ehdr32.e_machine));
      filedata->file_header.e_version = byte_get (ehdr32.e_version, sizeof (ehdr32.e_version));
      filedata->file_header.e_entry = byte_get (ehdr32.e_entry, sizeof (ehdr32.e_entry));
      filedata->file_header.e_phoff = byte_get (ehdr32.e_phoff, sizeof (ehdr32.e_phoff));
      filedata->file_header.e_shoff = byte_get (ehdr32.e_shoff, sizeof (ehdr32.e_shoff));
      filedata->file_header.e_flags = byte_get (ehdr32.e_flags, sizeof (ehdr32.e_flags));
      filedata->file_header.e_ehsize = byte_get (ehdr32.e_ehsize, sizeof (ehdr32.e_ehsize));
      filedata->file_header.e_phentsize = byte_get (ehdr32.e_phentsize, sizeof (ehdr32.e_phentsize));
      filedata->file_header.e_phnum = byte_get (ehdr32.e_phnum, sizeof (ehdr32.e_phnum));
      filedata->file_header.e_shentsize = byte_get (ehdr32.e_shentsize, sizeof (ehdr32.e_shentsize));
      filedata->file_header.e_shnum = byte_get (ehdr32.e_shnum, sizeof (ehdr32.e_shnum));
      filedata->file_header.e_shstrndx = byte_get (ehdr32.e_shstrndx, sizeof (ehdr32.e_shstrndx));
    }
  else
    {
      Elf64_External_Ehdr ehdr64;

      if (fread (ehdr64.e_type, sizeof (ehdr64) - 16, 1, filedata->handle) != 1)
 return 
# 22444 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22444 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;

      filedata->file_header.e_type = byte_get (ehdr64.e_type, sizeof (ehdr64.e_type));
      filedata->file_header.e_machine = byte_get (ehdr64.e_machine, sizeof (ehdr64.e_machine));
      filedata->file_header.e_version = byte_get (ehdr64.e_version, sizeof (ehdr64.e_version));
      filedata->file_header.e_entry = byte_get (ehdr64.e_entry, sizeof (ehdr64.e_entry));
      filedata->file_header.e_phoff = byte_get (ehdr64.e_phoff, sizeof (ehdr64.e_phoff));
      filedata->file_header.e_shoff = byte_get (ehdr64.e_shoff, sizeof (ehdr64.e_shoff));
      filedata->file_header.e_flags = byte_get (ehdr64.e_flags, sizeof (ehdr64.e_flags));
      filedata->file_header.e_ehsize = byte_get (ehdr64.e_ehsize, sizeof (ehdr64.e_ehsize));
      filedata->file_header.e_phentsize = byte_get (ehdr64.e_phentsize, sizeof (ehdr64.e_phentsize));
      filedata->file_header.e_phnum = byte_get (ehdr64.e_phnum, sizeof (ehdr64.e_phnum));
      filedata->file_header.e_shentsize = byte_get (ehdr64.e_shentsize, sizeof (ehdr64.e_shentsize));
      filedata->file_header.e_shnum = byte_get (ehdr64.e_shnum, sizeof (ehdr64.e_shnum));
      filedata->file_header.e_shstrndx = byte_get (ehdr64.e_shstrndx, sizeof (ehdr64.e_shstrndx));
    }

  return 
# 22461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 22461 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

static void
free_filedata (Filedata *filedata)
{
  free (filedata->program_interpreter);
  free (filedata->program_headers);
  free (filedata->section_headers);
  free (filedata->string_table);
  free (filedata->dump.dump_sects);
  free (filedata->dynamic_strings);
  free (filedata->dynamic_symbols);
  free (filedata->dynamic_syminfo);
  free (filedata->dynamic_section);

  while (filedata->symtab_shndx_list != 
# 22477 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       ((void *)0)
# 22477 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           )
    {
      elf_section_list *next = filedata->symtab_shndx_list->next;
      free (filedata->symtab_shndx_list);
      filedata->symtab_shndx_list = next;
    }

  free (filedata->section_headers_groups);

  if (filedata->section_groups)
    {
      size_t i;
      struct group_list * g;
      struct group_list * next;

      for (i = 0; i < filedata->group_count; i++)
 {
   for (g = filedata->section_groups [i].root; g != 
# 22494 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                   ((void *)0)
# 22494 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                       ; g = next)
     {
       next = g->next;
       free (g);
     }
 }

      free (filedata->section_groups);
    }
  memset (&filedata->section_headers, 0,
   sizeof (Filedata) - 
# 22504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      __builtin_offsetof (
# 22504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      Filedata
# 22504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      , 
# 22504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      section_headers
# 22504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      )
# 22504 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                          );
}

static void
close_file (Filedata * filedata)
{
  if (filedata)
    {
      if (filedata->handle)
 fclose (filedata->handle);
      free (filedata);
    }
}

void
close_debug_file (void * data)
{
  free_filedata ((Filedata *) data);
  close_file ((Filedata *) data);
}

static Filedata *
open_file (const char * pathname, 
# 22526 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                 _Bool 
# 22526 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      is_separate)
{
  struct stat statbuf;
  Filedata * filedata = 
# 22529 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 22529 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;

  if (stat (pathname, & statbuf) < 0
      || ! 
# 22532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          ((((
# 22532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          statbuf.st_mode
# 22532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          )) & 0170000) == (0100000))
# 22532 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                   )
    goto fail;

  filedata = calloc (1, sizeof * filedata);
  if (filedata == 
# 22536 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 22536 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
    goto fail;

  filedata->handle = fopen (pathname, "rb");
  if (filedata->handle == 
# 22540 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 22540 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             )
    goto fail;

  filedata->file_size = statbuf.st_size;
  filedata->file_name = pathname;
  filedata->is_separate = is_separate;

  if (! get_file_header (filedata))
    goto fail;

  if (!get_section_headers (filedata, 
# 22550 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     0
# 22550 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          ))
    goto fail;

  return filedata;

 fail:
  if (filedata)
    {
      if (filedata->handle)
        fclose (filedata->handle);
      free (filedata);
    }
  return 
# 22562 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        ((void *)0)
# 22562 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
}

void *
open_debug_file (const char * pathname)
{
  return open_file (pathname, 
# 22568 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             1
# 22568 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 );
}

static void
initialise_dump_sects (Filedata * filedata)
{




  if (filedata->dump.num_dump_sects > cmdline.num_dump_sects)
    memset (filedata->dump.dump_sects, 0,
     filedata->dump.num_dump_sects * sizeof (*filedata->dump.dump_sects));

  if (cmdline.num_dump_sects > 0)
    {
      if (filedata->dump.num_dump_sects == 0)

 request_dump_bynumber (&filedata->dump, cmdline.num_dump_sects, 0);

      
# 22588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ((void) sizeof ((
# 22588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     filedata->dump.num_dump_sects >= cmdline.num_dump_sects
# 22588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ) ? 1 : 0), __extension__ ({ if (
# 22588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     filedata->dump.num_dump_sects >= cmdline.num_dump_sects
# 22588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     ) ; else __assert_fail (
# 22588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
     "filedata->dump.num_dump_sects >= cmdline.num_dump_sects"
# 22588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
     , "/doner/binutils/binutils-515f23e/binutils/./readelf.c", 22588, __extension__ __PRETTY_FUNCTION__); }))
# 22588 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                     ;
      memcpy (filedata->dump.dump_sects, cmdline.dump_sects,
       cmdline.num_dump_sects * sizeof (*filedata->dump.dump_sects));
    }
}

static 
# 22594 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 22595 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
might_need_separate_debug_info (Filedata * filedata)
{

  if (filedata->file_header.e_shstrndx == 0)
    return 
# 22599 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22599 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;




  if (1 == 0 && do_follow_links)
    return 
# 22605 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 22605 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (process_links || do_syms || do_unwind
      || dump_any_debugging || do_dump || do_debugging)
    return 
# 22609 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          1
# 22609 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  return 
# 22611 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 22611 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
}






static 
# 22619 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 22620 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_object (Filedata * filedata)
{
  
# 22622 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 22622 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      have_separate_files;
  unsigned int i;
  
# 22624 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 22624 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      res;

  if (! get_file_header (filedata))
    {
      error (gettext ("%s: Failed to read file header\n"), filedata->file_name);
      return 
# 22629 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 22629 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }


  for (i = (sizeof (filedata->version_info) / sizeof ((filedata->version_info)[0])); i--;)
    filedata->version_info[i] = 0;

  for (i = (sizeof (filedata->dynamic_info) / sizeof ((filedata->dynamic_info)[0])); i--;)
    filedata->dynamic_info[i] = 0;
  filedata->dynamic_info_DT_GNU_HASH = 0;
  filedata->dynamic_info_DT_MIPS_XHASH = 0;


  if (show_name)
    printf (gettext ("\nFile: %s\n"), filedata->file_name);

  initialise_dump_sects (filedata);



  get_section_headers (filedata, 
# 22649 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                1
# 22649 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                    );

  if (! process_file_header (filedata))
    {
      res = 
# 22653 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 22653 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
      goto out;
    }



  free (filedata->section_headers);
  filedata->section_headers = 
# 22660 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             ((void *)0)
# 22660 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 ;

  if (! process_section_headers (filedata))
    {

      do_unwind = do_version = do_dump = do_arch = 
# 22665 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                  0
# 22665 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                       ;

      if (! do_using_dynamic)
 do_syms = do_dyn_syms = do_reloc = 
# 22668 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                   0
# 22668 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                        ;
    }

  if (! process_section_groups (filedata))

    do_unwind = 
# 22673 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               0
# 22673 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    ;

  process_program_headers (filedata);

  res = process_dynamic_section (filedata);

  if (! process_relocs (filedata))
    res = 
# 22680 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22680 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (! process_unwind (filedata))
    res = 
# 22683 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22683 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (! process_symbol_table (filedata))
    res = 
# 22686 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22686 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (! process_lto_symbol_tables (filedata))
    res = 
# 22689 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22689 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (! process_syminfo (filedata))
    res = 
# 22692 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22692 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (! process_version_sections (filedata))
    res = 
# 22695 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22695 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (might_need_separate_debug_info (filedata))
    have_separate_files = load_separate_debug_files (filedata, filedata->file_name);
  else
    have_separate_files = 
# 22700 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         0
# 22700 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              ;

  if (! process_section_contents (filedata))
    res = 
# 22703 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22703 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (have_separate_files)
    {
      separate_info * d;

      for (d = first_separate_info; d != 
# 22709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                        ((void *)0)
# 22709 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                            ; d = d->next)
 {
   initialise_dump_sects (d->handle);

   if (process_links && ! process_file_header (d->handle))
     res = 
# 22714 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22714 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   else if (! process_section_headers (d->handle))
     res = 
# 22716 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22716 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   else if (! process_section_contents (d->handle))
     res = 
# 22718 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22718 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   else if (process_links)
     {
       if (! process_section_groups (d->handle))
  res = 
# 22722 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22722 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       process_program_headers (d->handle);
       if (! process_dynamic_section (d->handle))
  res = 
# 22725 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22725 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       if (! process_relocs (d->handle))
  res = 
# 22727 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22727 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       if (! process_unwind (d->handle))
  res = 
# 22729 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22729 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       if (! process_symbol_table (d->handle))
  res = 
# 22731 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22731 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       if (! process_lto_symbol_tables (d->handle))
  res = 
# 22733 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22733 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       if (! process_syminfo (d->handle))
  res = 
# 22735 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22735 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       if (! process_version_sections (d->handle))
  res = 
# 22737 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22737 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
       if (! process_notes (d->handle))
  res = 
# 22739 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 22739 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
     }
 }


    }

  if (! process_notes (filedata))
    res = 
# 22747 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22747 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (! process_gnu_liblist (filedata))
    res = 
# 22750 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22750 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

  if (! process_arch_specific (filedata))
    res = 
# 22753 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22753 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;

 out:
  free_filedata (filedata);

  free_debug_memory ();

  return res;
}





static 
# 22767 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 22768 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_archive (Filedata * filedata, 
# 22768 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                     _Bool 
# 22768 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                          is_thin_archive)
{
  struct archive_info arch;
  struct archive_info nested_arch;
  size_t got;
  
# 22773 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 22773 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ret = 
# 22773 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 22773 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  show_name = 
# 22775 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             1
# 22775 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;


  arch.file_name = 
# 22778 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 22778 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;
  arch.file = 
# 22779 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
             ((void *)0)
# 22779 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
  arch.index_array = 
# 22780 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 22780 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;
  arch.sym_table = 
# 22781 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 22781 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;
  arch.longnames = 
# 22782 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  ((void *)0)
# 22782 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                      ;




  nested_arch.file_name = 
# 22787 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 22787 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;
  nested_arch.file = 
# 22788 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                    ((void *)0)
# 22788 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        ;
  nested_arch.index_array = 
# 22789 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 22789 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               ;
  nested_arch.sym_table = 
# 22790 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 22790 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;
  nested_arch.longnames = 
# 22791 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 22791 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             ;

  if (setup_archive (&arch, filedata->file_name, filedata->handle,
       filedata->file_size, is_thin_archive,
       do_archive_index) != 0)
    {
      ret = 
# 22797 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           0
# 22797 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;
      goto out;
    }

  if (do_archive_index)
    {
      if (arch.sym_table == 
# 22803 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 22803 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               )
 error (gettext ("%s: unable to dump the index as none was found\n"),
        filedata->file_name);
      else
 {
   uint64_t i, l;
   uint64_t current_pos;

   printf (gettext ("Index of archive %s: (%" 
# 22811 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "u" 
# 22811 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          " entries," " %#" 
# 22811 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          "l" "x" 
# 22811 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
          " bytes in the symbol table)\n")
                                                   ,
    filedata->file_name, arch.index_num,
    arch.sym_size);

   current_pos = ftell (filedata->handle);

   for (i = l = 0; i < arch.index_num; i++)
     {
       if (i == 0
    || (i > 0 && arch.index_array[i] != arch.index_array[i - 1]))
  {
    char * member_name
      = get_archive_member_name_at (&arch, arch.index_array[i],
        &nested_arch);

    if (member_name != 
# 22827 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                      ((void *)0)
# 22827 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                          )
      {
        char * qualified_name
   = make_qualified_name (&arch, &nested_arch,
            member_name);

        if (qualified_name != 
# 22833 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             ((void *)0)
# 22833 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 )
   {
     printf (gettext ("Contents of binary %s at offset "),
      qualified_name);
     (void) print_vma (arch.index_array[i], PREFIX_HEX);
     putchar ('\n');
     free (qualified_name);
   }
        free (member_name);
      }
  }

       if (l >= arch.sym_size)
  {
    error (gettext ("%s: end of the symbol table reached " "before the end of the index\n")
                                      ,
    filedata->file_name);
    ret = 
# 22850 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         0
# 22850 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
              ;
    break;
  }

       printf ("\t%.*s\n",
        (int) (arch.sym_size - l), arch.sym_table + l);
       l += strnlen (arch.sym_table + l, arch.sym_size - l) + 1;
     }

   if (arch.uses_64bit_indices)
     l = (l + 7) & ~ 7;
   else
     l += l & 1;

   if (l < arch.sym_size)
     {
       error (ngettext ("%s: %" 
# 22866 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                               "l" "d" 
# 22866 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                      " byte remains in the symbol table, "
          "but without corresponding entries in "
          "the index table\n",
          "%s: %" 
# 22869 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 "l" "d" 
# 22869 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        " bytes remain in the symbol table, "
          "but without corresponding entries in "
          "the index table\n",
          arch.sym_size - l),
       filedata->file_name, arch.sym_size - l);
       ret = 
# 22874 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 22874 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
     }

   if (fseek64 (filedata->handle, current_pos, 
# 22877 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                              0
# 22877 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                      ) != 0)
     {
       error (gettext ("%s: failed to seek back to start of object files " "in the archive\n")
                            ,
       filedata->file_name);
       ret = 
# 22882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 22882 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
       goto out;
     }
 }

      if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
   && !do_segments && !do_header && !do_dump && !do_version
   && !do_histogram && !do_debugging && !do_arch && !do_notes
   && !do_section_groups && !do_dyn_syms)
 {
   ret = 
# 22892 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        1
# 22892 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
   goto out;
 }
    }

  while (1)
    {
      char * name;
      size_t namelen;
      char * qualified_name;


      if (fseek64 (filedata->handle, arch.next_arhdr_offset, 
# 22904 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                            0
# 22904 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                    ) != 0)
 {
   error (gettext ("%s: failed to seek to next archive header\n"),
   arch.file_name);
   ret = 
# 22908 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 22908 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
   break;
 }
      got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
      if (got != sizeof arch.arhdr)
 {
   if (got == 0)
     break;


   error (gettext ("%s: failed to read archive header\n"), arch.file_name);

   ret = 
# 22920 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 22920 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
   break;
 }
      if (memcmp (arch.arhdr.ar_fmag, "`\012", 2) != 0)
 {
   error (gettext ("%s: did not find a valid archive header\n"),
   arch.file_name);
   ret = 
# 22927 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 22927 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
   break;
 }

      arch.next_arhdr_offset += sizeof arch.arhdr;

      filedata->archive_file_size = strtoul (arch.arhdr.ar_size, 
# 22933 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                                ((void *)0)
# 22933 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                                    , 10);

      name = get_archive_member_name (&arch, &nested_arch);
      if (name == 
# 22936 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 22936 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
 {
   error (gettext ("%s: bad archive file name\n"), arch.file_name);
   ret = 
# 22939 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 22939 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
   break;
 }
      namelen = strlen (name);

      qualified_name = make_qualified_name (&arch, &nested_arch, name);
      if (qualified_name == 
# 22945 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                           ((void *)0)
# 22945 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                               )
 {
   error (gettext ("%s: bad archive file name\n"), arch.file_name);
   free (name);
   ret = 
# 22949 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 22949 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
             ;
   break;
 }

      if (is_thin_archive && arch.nested_member_origin == 0)
 {

   Filedata * member_filedata;
   char * member_file_name = adjust_relative_path
     (filedata->file_name, name, namelen);

   free (name);
   if (member_file_name == 
# 22961 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          ((void *)0)
# 22961 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              )
     {
       free (qualified_name);
       ret = 
# 22964 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 22964 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
       break;
     }

   member_filedata = open_file (member_file_name, 
# 22968 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                                 0
# 22968 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                                      );
   if (member_filedata == 
# 22969 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 22969 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             )
     {
       error (gettext ("Input file '%s' is not readable.\n"), member_file_name);
       free (member_file_name);
       free (qualified_name);
       ret = 
# 22974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 22974 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
       break;
     }

   filedata->archive_file_offset = arch.nested_member_origin;
   member_filedata->file_name = qualified_name;


   rewind (member_filedata->handle);

   if (! process_object (member_filedata))
     ret = 
# 22985 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 22985 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

   close_file (member_filedata);
   free (member_file_name);
 }
      else if (is_thin_archive)
 {
   Filedata thin_filedata;

   memset (&thin_filedata, 0, sizeof (thin_filedata));


   if (nested_arch.file == 
# 22997 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                          ((void *)0)
# 22997 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              )
     {
       error (gettext ("%s: contains corrupt thin archive: %s\n"),
       qualified_name, name);
       free (qualified_name);
       free (name);
       ret = 
# 23003 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 23003 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
       break;
     }
   free (name);


   filedata->archive_file_offset
     = arch.nested_member_origin + sizeof arch.arhdr;



   if (fseek64 (nested_arch.file, filedata->archive_file_offset,
         
# 23015 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
        0
# 23015 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ) != 0)
     {
       error (gettext ("%s: failed to seek to archive member.\n"),
       nested_arch.file_name);
       free (qualified_name);
       ret = 
# 23020 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 23020 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
       break;
     }

   thin_filedata.handle = nested_arch.file;
   thin_filedata.file_name = qualified_name;

   if (! process_object (& thin_filedata))
     ret = 
# 23028 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 23028 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
 }
      else
 {
   free (name);
   filedata->archive_file_offset = arch.next_arhdr_offset;
   filedata->file_name = qualified_name;
   if (! process_object (filedata))
     ret = 
# 23036 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
          0
# 23036 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;
   arch.next_arhdr_offset += (filedata->archive_file_size + 1) & -2;

   if (arch.next_arhdr_offset < filedata->archive_file_size)
     arch.next_arhdr_offset = -1ul;
 }

      free (qualified_name);
    }

 out:
  if (nested_arch.file != 
# 23047 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 23047 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             )
    fclose (nested_arch.file);
  release_archive (&nested_arch);
  release_archive (&arch);

  return ret;
}

static 
# 23055 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      _Bool

# 23056 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
process_file (char * file_name)
{
  Filedata * filedata = 
# 23058 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                       ((void *)0)
# 23058 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           ;
  struct stat statbuf;
  char armag[8];
  
# 23061 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
 _Bool 
# 23061 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
      ret = 
# 23061 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            1
# 23061 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                ;

  if (stat (file_name, &statbuf) < 0)
    {
      if (
# 23065 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
         (*__errno_location ()) 
# 23065 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               == 
# 23065 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                  2
# 23065 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                        )
 error (gettext ("'%s': No such file\n"), file_name);
      else
 error (gettext ("Could not locate '%s'.  System error message: %s\n"),
        file_name, strerror (
# 23069 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                            (*__errno_location ())
# 23069 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                 ));
      return 
# 23070 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 23070 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  if (! 
# 23073 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       ((((
# 23073 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
       statbuf.st_mode
# 23073 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       )) & 0170000) == (0100000))
# 23073 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                )
    {
      error (gettext ("'%s' is not an ordinary file\n"), file_name);
      return 
# 23076 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 23076 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  filedata = calloc (1, sizeof * filedata);
  if (filedata == 
# 23080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 ((void *)0)
# 23080 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     )
    {
      error (gettext ("Out of memory allocating file data structure\n"));
      return 
# 23083 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 23083 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  filedata->file_name = file_name;
  filedata->handle = fopen (file_name, "rb");
  if (filedata->handle == 
# 23088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         ((void *)0)
# 23088 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                             )
    {
      error (gettext ("Input file '%s' is not readable.\n"), file_name);
      free (filedata);
      return 
# 23092 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 23092 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  if (fread (armag, 8, 1, filedata->handle) != 1)
    {
      error (gettext ("%s: Failed to read file's magic number\n"), file_name);
      fclose (filedata->handle);
      free (filedata);
      return 
# 23100 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 23100 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                 ;
    }

  filedata->file_size = statbuf.st_size;
  filedata->is_separate = 
# 23104 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                         0
# 23104 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                              ;

  if (memcmp (armag, "!<arch>\012", 8) == 0)
    {
      if (! process_archive (filedata, 
# 23108 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                      0
# 23108 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           ))
 ret = 
# 23109 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 23109 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ;
    }
  else if (memcmp (armag, "!<thin>\012", 8) == 0)
    {
      if ( ! process_archive (filedata, 
# 23113 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                                       1
# 23113 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                           ))
 ret = 
# 23114 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 23114 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ;
    }
  else
    {
      if (do_archive_index && !check_all)
 error (gettext ("File %s is not an archive so its index cannot be displayed.\n"),
        file_name);

      rewind (filedata->handle);
      filedata->archive_file_size = filedata->archive_file_offset = 0;

      if (! process_object (filedata))
 ret = 
# 23126 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
      0
# 23126 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
           ;
    }

  fclose (filedata->handle);
  free (filedata->section_headers);
  free (filedata->program_headers);
  free (filedata->string_table);
  free (filedata->dump.dump_sects);
  free (filedata);

  free (ba_cache.strtab);
  ba_cache.strtab = 
# 23137 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 23137 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
  free (ba_cache.symtab);
  ba_cache.symtab = 
# 23139 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                   ((void *)0)
# 23139 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       ;
  ba_cache.filedata = 
# 23140 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                     ((void *)0)
# 23140 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                         ;

  return ret;
}
# 23165 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
int
main (int argc, char ** argv)
{
  int err;


  setlocale (
# 23171 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            5
# 23171 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                       , "");

  setlocale (
# 23173 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            0
# 23173 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                    , "");
  bindtextdomain ("binutils", "/usr/local/share/locale");
  textdomain ("binutils");

  expandargv (&argc, &argv);

  parse_args (& cmdline, argc, argv);

  if (optind < (argc - 1))


    show_name = 
# 23184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
               1
# 23184 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                   ;
  else if (optind >= argc)
    {

      do_checks = 
# 23188 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                 1
# 23188 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                     ;

      warn (gettext ("Nothing to do.\n"));
      usage (
# 23191 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
            stderr
# 23191 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                  );
    }

  err = 
# 23194 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
       0
# 23194 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
            ;
  while (optind < argc)
    if (! process_file (argv[optind++]))
      err = 
# 23197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
           1
# 23197 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
               ;

  free (cmdline.dump_sects);

  free (dump_ctf_symtab_name);
  free (dump_ctf_strtab_name);
  free (dump_ctf_parent_name);

  return err ? 
# 23205 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
              1 
# 23205 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                           : 
# 23205 "/doner/binutils/binutils-515f23e/binutils/./readelf.c" 3 4
                             0
# 23205 "/doner/binutils/binutils-515f23e/binutils/./readelf.c"
                                         ;
}
