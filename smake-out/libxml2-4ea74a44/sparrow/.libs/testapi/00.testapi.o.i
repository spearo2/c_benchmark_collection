# 1 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
# 1 "/doner/libxml2/libxml2-4ea74a44/libxml2//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
# 11 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
# 1 "/doner/libxml2/libxml2-4ea74a44/libxml2/libxml.h" 1
# 37 "/doner/libxml2/libxml2-4ea74a44/libxml2/libxml.h"
# 1 "/doner/libxml2/libxml2-4ea74a44/libxml2/config.h" 1
# 38 "/doner/libxml2/libxml2-4ea74a44/libxml2/libxml.h" 2
# 1 "./include/libxml/xmlversion.h" 1
# 13 "./include/libxml/xmlversion.h"
# 1 "./include/libxml/xmlexports.h" 1
# 14 "./include/libxml/xmlversion.h" 2
# 24 "./include/libxml/xmlversion.h"
 void xmlCheckVersion(int version);
# 39 "/doner/libxml2/libxml2-4ea74a44/libxml2/libxml.h" 2
# 49 "/doner/libxml2/libxml2-4ea74a44/libxml2/libxml.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4
# 52 "/usr/include/stdio.h" 3 4
typedef __gnuc_va_list va_list;
# 65 "/usr/include/stdio.h" 3 4
typedef __off64_t off_t;
# 77 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;
# 86 "/usr/include/stdio.h" 3 4
typedef __fpos64_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 176 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64") __attribute__ ((__warn_unused_result__));
# 187 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 257 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename, const char *__restrict __modes) __asm__ ("" "fopen64")

  __attribute__ ((__warn_unused_result__));
extern FILE *freopen (const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


  __attribute__ ((__warn_unused_result__));
# 279 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 292 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 379 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                          __attribute__ ((__warn_unused_result__));
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                         __attribute__ ((__warn_unused_result__));
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);
# 715 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64")

                  ;
extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");
# 739 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64")
                                          ;
extern int fsetpos (FILE *__stream, const fpos_t *__pos) __asm__ ("" "fsetpos64")
                                                          ;
# 757 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) __attribute__ ((__warn_unused_result__));





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 840 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 127 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 865 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, const char *__restrict __fmt, ...)
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...)

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     const char *__restrict __format, ...);
extern int __printf_chk (int __flag, const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vfprintf (FILE *__restrict __stream,
   const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}


extern int __dprintf_chk (int __fd, int __flag, const char *__restrict __fmt,
     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __vdprintf_chk (int __fd, int __flag,
      const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
dprintf (int __fd, const char *__restrict __fmt, ...)
{
  return __dprintf_chk (__fd, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}





extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vdprintf (int __fd, const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
}
# 243 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")

                                        __attribute__ ((__warn_unused_result__));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}
# 329 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")


                     __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
                                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
         __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
       __stream);
    }


  if (__builtin_constant_p (__size)
      && __builtin_constant_p (__n)
      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
      && __size * __n <= 8)
    {
      size_t __cnt = __size * __n;
      char *__cptr = (char *) __ptr;
      if (__cnt == 0)
 return 0;

      for (; __cnt > 0; --__cnt)
 {
   int __c = getc_unlocked (__stream);
   if (__c == (-1))
     break;
   *__cptr++ = __c;
 }
      return (__cptr - (char *) __ptr) / __size;
    }

  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}
# 868 "/usr/include/stdio.h" 2 3 4






# 50 "/doner/libxml2/libxml2-4ea74a44/libxml2/libxml.h" 2
# 66 "/doner/libxml2/libxml2-4ea74a44/libxml2/libxml.h"

# 66 "/doner/libxml2/libxml2-4ea74a44/libxml2/libxml.h"
extern int __xmlRegisterCallbacks;



void __xmlIOErr(int domain, int code, const char *extra);
void __xmlLoaderErr(void *ctx, const char *msg, const char *filename);





void __htmlParseContent(void *ctx);





void __xmlGlobalInitMutexLock(void);
void __xmlGlobalInitMutexUnlock(void);
void __xmlGlobalInitMutexDestroy(void);





int __xmlRandom(void);


int xmlNop(void);
# 12 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2


# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;






typedef __ino64_t ino_t;
# 59 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 144 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);





# 1 "/usr/include/x86_64-linux-gnu/bits/select2.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/select2.h" 3 4
extern long int __fdelt_chk (long int __d);
extern long int __fdelt_warn (long int __d)
  __attribute__((__warning__ ("bit outside of fd_set selected")));
# 124 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;
# 205 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;
# 227 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) __attribute__ ((__warn_unused_result__));



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 647 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 691 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 713 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64")
                     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) __attribute__ ((__warn_unused_result__));
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (const void *, const void *);
# 820 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void *)0);
}
# 826 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 840 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));
# 1003 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
# 1014 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 3 4
extern char *__realpath_chk (const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__ , __leaf__))

                                                 __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__ , __leaf__))


                                                __attribute__ ((__warn_unused_result__))
     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) realpath (const char *__restrict __name, char *__restrict __resolved)
{
  if (__builtin_object_size (__resolved, 2 > 1) != (size_t) -1)
    {




      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 2 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
                   ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
      if (__buflen > __builtin_object_size (__buf, 2 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__ , __leaf__))
              __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctomb (char *__s, wchar_t __wchar)
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         const char *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 2 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcstombs (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
      if (__len > __builtin_object_size (__dst, 2 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
# 1018 "/usr/include/stdlib.h" 2 3 4






# 15 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 122 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 154 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 385 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 410 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 428 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));








# 1 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bcopy (const void *__src, void *__dest, size_t __len)
{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bzero (void *__dest, size_t __len)
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
}
# 145 "/usr/include/strings.h" 2 3 4
# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 495 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memmove (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
# 58 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memset (void *__dest, int __ch, size_t __len)
{
# 71 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}




void __explicit_bzero_chk (void *__dest, size_t __len, size_t __destlen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) explicit_bzero (void *__dest, size_t __len)
{
  __explicit_bzero_chk (__dest, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}
# 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncpy (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}


extern char *__stpncpy_chk (char *__dest, const char *__src, size_t __n,
       size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern char *__stpncpy_alias (char *__dest, const char *__src, size_t __n) __asm__ ("" "stpncpy") __attribute__ ((__nothrow__ , __leaf__))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpncpy (char *__dest, const char *__src, size_t __n)
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n > __builtin_object_size (__dest, 2 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcat (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncat (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}
# 496 "/usr/include/string.h" 2 3 4




# 16 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/xmlerror.h" 1
# 10 "./include/libxml/xmlerror.h"
# 1 "./include/libxml/parser.h" 1
# 13 "./include/libxml/parser.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 14 "./include/libxml/parser.h" 2


# 1 "./include/libxml/tree.h" 1
# 16 "./include/libxml/tree.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 17 "./include/libxml/tree.h" 2

# 1 "./include/libxml/xmlstring.h" 1
# 28 "./include/libxml/xmlstring.h"

# 28 "./include/libxml/xmlstring.h"
typedef unsigned char xmlChar;
# 40 "./include/libxml/xmlstring.h"
 xmlChar *
                xmlStrdup (const xmlChar *cur);
 xmlChar *
                xmlStrndup (const xmlChar *cur,
                                         int len);
 xmlChar *
                xmlCharStrndup (const char *cur,
                                         int len);
 xmlChar *
                xmlCharStrdup (const char *cur);
 xmlChar *
                xmlStrsub (const xmlChar *str,
                                         int start,
                                         int len);
 const xmlChar *
                xmlStrchr (const xmlChar *str,
                                         xmlChar val);
 const xmlChar *
                xmlStrstr (const xmlChar *str,
                                         const xmlChar *val);
 const xmlChar *
                xmlStrcasestr (const xmlChar *str,
                                         const xmlChar *val);
 int
                xmlStrcmp (const xmlChar *str1,
                                         const xmlChar *str2);
 int
                xmlStrncmp (const xmlChar *str1,
                                         const xmlChar *str2,
                                         int len);
 int
                xmlStrcasecmp (const xmlChar *str1,
                                         const xmlChar *str2);
 int
                xmlStrncasecmp (const xmlChar *str1,
                                         const xmlChar *str2,
                                         int len);
 int
                xmlStrEqual (const xmlChar *str1,
                                         const xmlChar *str2);
 int
                xmlStrQEqual (const xmlChar *pref,
                                         const xmlChar *name,
                                         const xmlChar *str);
 int
                xmlStrlen (const xmlChar *str);
 xmlChar *
                xmlStrcat (xmlChar *cur,
                                         const xmlChar *add);
 xmlChar *
                xmlStrncat (xmlChar *cur,
                                         const xmlChar *add,
                                         int len);
 xmlChar *
                xmlStrncatNew (const xmlChar *str1,
                                         const xmlChar *str2,
                                         int len);
 int
                xmlStrPrintf (xmlChar *buf,
                                         int len,
                                         const xmlChar *msg,
                                         ...);
 int
                xmlStrVPrintf (xmlChar *buf,
                                         int len,
                                         const xmlChar *msg,
                                         va_list ap);

 int
        xmlGetUTF8Char (const unsigned char *utf,
                                         int *len);
 int
        xmlCheckUTF8 (const unsigned char *utf);
 int
        xmlUTF8Strsize (const xmlChar *utf,
                                         int len);
 xmlChar *
        xmlUTF8Strndup (const xmlChar *utf,
                                         int len);
 const xmlChar *
        xmlUTF8Strpos (const xmlChar *utf,
                                         int pos);
 int
        xmlUTF8Strloc (const xmlChar *utf,
                                         const xmlChar *utfchar);
 xmlChar *
        xmlUTF8Strsub (const xmlChar *utf,
                                         int start,
                                         int len);
 int
        xmlUTF8Strlen (const xmlChar *utf);
 int
        xmlUTF8Size (const xmlChar *utf);
 int
        xmlUTF8Charcmp (const xmlChar *utf1,
                                         const xmlChar *utf2);
# 19 "./include/libxml/tree.h" 2
# 28 "./include/libxml/tree.h"
typedef struct _xmlParserInputBuffer xmlParserInputBuffer;
typedef xmlParserInputBuffer *xmlParserInputBufferPtr;

typedef struct _xmlOutputBuffer xmlOutputBuffer;
typedef xmlOutputBuffer *xmlOutputBufferPtr;


typedef struct _xmlParserInput xmlParserInput;
typedef xmlParserInput *xmlParserInputPtr;

typedef struct _xmlParserCtxt xmlParserCtxt;
typedef xmlParserCtxt *xmlParserCtxtPtr;

typedef struct _xmlSAXLocator xmlSAXLocator;
typedef xmlSAXLocator *xmlSAXLocatorPtr;

typedef struct _xmlSAXHandler xmlSAXHandler;
typedef xmlSAXHandler *xmlSAXHandlerPtr;


typedef struct _xmlEntity xmlEntity;
typedef xmlEntity *xmlEntityPtr;
# 74 "./include/libxml/tree.h"
typedef enum {
    XML_BUFFER_ALLOC_DOUBLEIT,
    XML_BUFFER_ALLOC_EXACT,
    XML_BUFFER_ALLOC_IMMUTABLE,
    XML_BUFFER_ALLOC_IO,
    XML_BUFFER_ALLOC_HYBRID
} xmlBufferAllocationScheme;







typedef struct _xmlBuffer xmlBuffer;
typedef xmlBuffer *xmlBufferPtr;
struct _xmlBuffer {
    xmlChar *content;
    unsigned int use;
    unsigned int size;
    xmlBufferAllocationScheme alloc;
    xmlChar *contentIO;
};







typedef struct _xmlBuf xmlBuf;
# 113 "./include/libxml/tree.h"
typedef xmlBuf *xmlBufPtr;





 xmlChar* xmlBufContent (const xmlBufPtr buf);
 xmlChar* xmlBufEnd (const xmlBufPtr buf);
 size_t xmlBufUse (const xmlBufPtr buf);
 size_t xmlBufShrink (xmlBufPtr buf, size_t len);
# 158 "./include/libxml/tree.h"
typedef enum {
    XML_ELEMENT_NODE= 1,
    XML_ATTRIBUTE_NODE= 2,
    XML_TEXT_NODE= 3,
    XML_CDATA_SECTION_NODE= 4,
    XML_ENTITY_REF_NODE= 5,
    XML_ENTITY_NODE= 6,
    XML_PI_NODE= 7,
    XML_COMMENT_NODE= 8,
    XML_DOCUMENT_NODE= 9,
    XML_DOCUMENT_TYPE_NODE= 10,
    XML_DOCUMENT_FRAG_NODE= 11,
    XML_NOTATION_NODE= 12,
    XML_HTML_DOCUMENT_NODE= 13,
    XML_DTD_NODE= 14,
    XML_ELEMENT_DECL= 15,
    XML_ATTRIBUTE_DECL= 16,
    XML_ENTITY_DECL= 17,
    XML_NAMESPACE_DECL= 18,
    XML_XINCLUDE_START= 19,
    XML_XINCLUDE_END= 20

   ,XML_DOCB_DOCUMENT_NODE= 21

} xmlElementType;
# 191 "./include/libxml/tree.h"
typedef struct _xmlNotation xmlNotation;
typedef xmlNotation *xmlNotationPtr;
struct _xmlNotation {
    const xmlChar *name;
    const xmlChar *PublicID;
    const xmlChar *SystemID;
};







typedef enum {
    XML_ATTRIBUTE_CDATA = 1,
    XML_ATTRIBUTE_ID,
    XML_ATTRIBUTE_IDREF ,
    XML_ATTRIBUTE_IDREFS,
    XML_ATTRIBUTE_ENTITY,
    XML_ATTRIBUTE_ENTITIES,
    XML_ATTRIBUTE_NMTOKEN,
    XML_ATTRIBUTE_NMTOKENS,
    XML_ATTRIBUTE_ENUMERATION,
    XML_ATTRIBUTE_NOTATION
} xmlAttributeType;







typedef enum {
    XML_ATTRIBUTE_NONE = 1,
    XML_ATTRIBUTE_REQUIRED,
    XML_ATTRIBUTE_IMPLIED,
    XML_ATTRIBUTE_FIXED
} xmlAttributeDefault;







typedef struct _xmlEnumeration xmlEnumeration;
typedef xmlEnumeration *xmlEnumerationPtr;
struct _xmlEnumeration {
    struct _xmlEnumeration *next;
    const xmlChar *name;
};







typedef struct _xmlAttribute xmlAttribute;
typedef xmlAttribute *xmlAttributePtr;
struct _xmlAttribute {
    void *_private;
    xmlElementType type;
    const xmlChar *name;
    struct _xmlNode *children;
    struct _xmlNode *last;
    struct _xmlDtd *parent;
    struct _xmlNode *next;
    struct _xmlNode *prev;
    struct _xmlDoc *doc;

    struct _xmlAttribute *nexth;
    xmlAttributeType atype;
    xmlAttributeDefault def;
    const xmlChar *defaultValue;
    xmlEnumerationPtr tree;
    const xmlChar *prefix;
    const xmlChar *elem;
};






typedef enum {
    XML_ELEMENT_CONTENT_PCDATA = 1,
    XML_ELEMENT_CONTENT_ELEMENT,
    XML_ELEMENT_CONTENT_SEQ,
    XML_ELEMENT_CONTENT_OR
} xmlElementContentType;






typedef enum {
    XML_ELEMENT_CONTENT_ONCE = 1,
    XML_ELEMENT_CONTENT_OPT,
    XML_ELEMENT_CONTENT_MULT,
    XML_ELEMENT_CONTENT_PLUS
} xmlElementContentOccur;
# 303 "./include/libxml/tree.h"
typedef struct _xmlElementContent xmlElementContent;
typedef xmlElementContent *xmlElementContentPtr;
struct _xmlElementContent {
    xmlElementContentType type;
    xmlElementContentOccur ocur;
    const xmlChar *name;
    struct _xmlElementContent *c1;
    struct _xmlElementContent *c2;
    struct _xmlElementContent *parent;
    const xmlChar *prefix;
};







typedef enum {
    XML_ELEMENT_TYPE_UNDEFINED = 0,
    XML_ELEMENT_TYPE_EMPTY = 1,
    XML_ELEMENT_TYPE_ANY,
    XML_ELEMENT_TYPE_MIXED,
    XML_ELEMENT_TYPE_ELEMENT
} xmlElementTypeVal;




# 1 "./include/libxml/xmlregexp.h" 1
# 28 "./include/libxml/xmlregexp.h"
typedef struct _xmlRegexp xmlRegexp;
typedef xmlRegexp *xmlRegexpPtr;






typedef struct _xmlRegExecCtxt xmlRegExecCtxt;
typedef xmlRegExecCtxt *xmlRegExecCtxtPtr;




# 1 "./include/libxml/tree.h" 1
# 43 "./include/libxml/xmlregexp.h" 2
# 1 "./include/libxml/dict.h" 1
# 14 "./include/libxml/dict.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 15 "./include/libxml/dict.h" 2
# 25 "./include/libxml/dict.h"
typedef struct _xmlDict xmlDict;
typedef xmlDict *xmlDictPtr;




 int xmlInitializeDict(void);




 xmlDictPtr
   xmlDictCreate (void);
 size_t
   xmlDictSetLimit (xmlDictPtr dict,
                                         size_t limit);
 size_t
   xmlDictGetUsage (xmlDictPtr dict);
 xmlDictPtr
   xmlDictCreateSub(xmlDictPtr sub);
 int
   xmlDictReference(xmlDictPtr dict);
 void
   xmlDictFree (xmlDictPtr dict);




 const xmlChar *
   xmlDictLookup (xmlDictPtr dict,
                           const xmlChar *name,
                           int len);
 const xmlChar *
   xmlDictExists (xmlDictPtr dict,
                           const xmlChar *name,
                           int len);
 const xmlChar *
   xmlDictQLookup (xmlDictPtr dict,
                           const xmlChar *prefix,
                           const xmlChar *name);
 int
   xmlDictOwns (xmlDictPtr dict,
      const xmlChar *str);
 int
   xmlDictSize (xmlDictPtr dict);




 void
                        xmlDictCleanup (void);
# 44 "./include/libxml/xmlregexp.h" 2







 xmlRegexpPtr
      xmlRegexpCompile (const xmlChar *regexp);
 void xmlRegFreeRegexp(xmlRegexpPtr regexp);
 int
      xmlRegexpExec (xmlRegexpPtr comp,
      const xmlChar *value);
 void
      xmlRegexpPrint (FILE *output,
      xmlRegexpPtr regexp);
 int
      xmlRegexpIsDeterminist(xmlRegexpPtr comp);
# 72 "./include/libxml/xmlregexp.h"
typedef void (*xmlRegExecCallbacks) (xmlRegExecCtxtPtr exec,
                              const xmlChar *token,
         void *transdata,
         void *inputdata);




 xmlRegExecCtxtPtr
      xmlRegNewExecCtxt (xmlRegexpPtr comp,
      xmlRegExecCallbacks callback,
      void *data);
 void
      xmlRegFreeExecCtxt (xmlRegExecCtxtPtr exec);
 int
      xmlRegExecPushString(xmlRegExecCtxtPtr exec,
      const xmlChar *value,
      void *data);
 int
      xmlRegExecPushString2(xmlRegExecCtxtPtr exec,
      const xmlChar *value,
      const xmlChar *value2,
      void *data);

 int
      xmlRegExecNextValues(xmlRegExecCtxtPtr exec,
      int *nbval,
      int *nbneg,
      xmlChar **values,
      int *terminal);
 int
      xmlRegExecErrInfo (xmlRegExecCtxtPtr exec,
      const xmlChar **string,
      int *nbval,
      int *nbneg,
      xmlChar **values,
      int *terminal);







typedef struct _xmlExpCtxt xmlExpCtxt;
typedef xmlExpCtxt *xmlExpCtxtPtr;

 void
   xmlExpFreeCtxt (xmlExpCtxtPtr ctxt);
 xmlExpCtxtPtr
   xmlExpNewCtxt (int maxNodes,
      xmlDictPtr dict);

 int
   xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt);
 int
   xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt);


typedef struct _xmlExpNode xmlExpNode;
typedef xmlExpNode *xmlExpNodePtr;

typedef enum {
    XML_EXP_EMPTY = 0,
    XML_EXP_FORBID = 1,
    XML_EXP_ATOM = 2,
    XML_EXP_SEQ = 3,
    XML_EXP_OR = 4,
    XML_EXP_COUNT = 5
} xmlExpNodeType;





extern xmlExpNodePtr forbiddenExp;
extern xmlExpNodePtr emptyExp;




 void
   xmlExpFree (xmlExpCtxtPtr ctxt,
      xmlExpNodePtr expr);
 void
   xmlExpRef (xmlExpNodePtr expr);




 xmlExpNodePtr
   xmlExpParse (xmlExpCtxtPtr ctxt,
      const char *expr);
 xmlExpNodePtr
   xmlExpNewAtom (xmlExpCtxtPtr ctxt,
      const xmlChar *name,
      int len);
 xmlExpNodePtr
   xmlExpNewOr (xmlExpCtxtPtr ctxt,
      xmlExpNodePtr left,
      xmlExpNodePtr right);
 xmlExpNodePtr
   xmlExpNewSeq (xmlExpCtxtPtr ctxt,
      xmlExpNodePtr left,
      xmlExpNodePtr right);
 xmlExpNodePtr
   xmlExpNewRange (xmlExpCtxtPtr ctxt,
      xmlExpNodePtr subset,
      int min,
      int max);



 int
   xmlExpIsNillable(xmlExpNodePtr expr);
 int
   xmlExpMaxToken (xmlExpNodePtr expr);
 int
   xmlExpGetLanguage(xmlExpCtxtPtr ctxt,
      xmlExpNodePtr expr,
      const xmlChar**langList,
      int len);
 int
   xmlExpGetStart (xmlExpCtxtPtr ctxt,
      xmlExpNodePtr expr,
      const xmlChar**tokList,
      int len);
 xmlExpNodePtr
   xmlExpStringDerive(xmlExpCtxtPtr ctxt,
      xmlExpNodePtr expr,
      const xmlChar *str,
      int len);
 xmlExpNodePtr
   xmlExpExpDerive (xmlExpCtxtPtr ctxt,
      xmlExpNodePtr expr,
      xmlExpNodePtr sub);
 int
   xmlExpSubsume (xmlExpCtxtPtr ctxt,
      xmlExpNodePtr expr,
      xmlExpNodePtr sub);
 void
   xmlExpDump (xmlBufferPtr buf,
      xmlExpNodePtr expr);
# 333 "./include/libxml/tree.h" 2
# 343 "./include/libxml/tree.h"
typedef struct _xmlElement xmlElement;
typedef xmlElement *xmlElementPtr;
struct _xmlElement {
    void *_private;
    xmlElementType type;
    const xmlChar *name;
    struct _xmlNode *children;
    struct _xmlNode *last;
    struct _xmlDtd *parent;
    struct _xmlNode *next;
    struct _xmlNode *prev;
    struct _xmlDoc *doc;

    xmlElementTypeVal etype;
    xmlElementContentPtr content;
    xmlAttributePtr attributes;
    const xmlChar *prefix;

    xmlRegexpPtr contModel;



};
# 374 "./include/libxml/tree.h"
typedef xmlElementType xmlNsType;
# 386 "./include/libxml/tree.h"
typedef struct _xmlNs xmlNs;
typedef xmlNs *xmlNsPtr;
struct _xmlNs {
    struct _xmlNs *next;
    xmlNsType type;
    const xmlChar *href;
    const xmlChar *prefix;
    void *_private;
    struct _xmlDoc *context;
};







typedef struct _xmlDtd xmlDtd;
typedef xmlDtd *xmlDtdPtr;
struct _xmlDtd {
    void *_private;
    xmlElementType type;
    const xmlChar *name;
    struct _xmlNode *children;
    struct _xmlNode *last;
    struct _xmlDoc *parent;
    struct _xmlNode *next;
    struct _xmlNode *prev;
    struct _xmlDoc *doc;


    void *notations;
    void *elements;
    void *attributes;
    void *entities;
    const xmlChar *ExternalID;
    const xmlChar *SystemID;
    void *pentities;
};






typedef struct _xmlAttr xmlAttr;
typedef xmlAttr *xmlAttrPtr;
struct _xmlAttr {
    void *_private;
    xmlElementType type;
    const xmlChar *name;
    struct _xmlNode *children;
    struct _xmlNode *last;
    struct _xmlNode *parent;
    struct _xmlAttr *next;
    struct _xmlAttr *prev;
    struct _xmlDoc *doc;
    xmlNs *ns;
    xmlAttributeType atype;
    void *psvi;
};







typedef struct _xmlID xmlID;
typedef xmlID *xmlIDPtr;
struct _xmlID {
    struct _xmlID *next;
    const xmlChar *value;
    xmlAttrPtr attr;
    const xmlChar *name;
    int lineno;
    struct _xmlDoc *doc;
};







typedef struct _xmlRef xmlRef;
typedef xmlRef *xmlRefPtr;
struct _xmlRef {
    struct _xmlRef *next;
    const xmlChar *value;
    xmlAttrPtr attr;
    const xmlChar *name;
    int lineno;
};






typedef struct _xmlNode xmlNode;
typedef xmlNode *xmlNodePtr;
struct _xmlNode {
    void *_private;
    xmlElementType type;
    const xmlChar *name;
    struct _xmlNode *children;
    struct _xmlNode *last;
    struct _xmlNode *parent;
    struct _xmlNode *next;
    struct _xmlNode *prev;
    struct _xmlDoc *doc;


    xmlNs *ns;
    xmlChar *content;
    struct _xmlAttr *properties;
    xmlNs *nsDef;
    void *psvi;
    unsigned short line;
    unsigned short extra;
};
# 531 "./include/libxml/tree.h"
typedef enum {
    XML_DOC_WELLFORMED = 1<<0,
    XML_DOC_NSVALID = 1<<1,
    XML_DOC_OLD10 = 1<<2,
    XML_DOC_DTDVALID = 1<<3,
    XML_DOC_XINCLUDE = 1<<4,
    XML_DOC_USERBUILT = 1<<5,

    XML_DOC_INTERNAL = 1<<6,
    XML_DOC_HTML = 1<<7
} xmlDocProperties;






typedef struct _xmlDoc xmlDoc;
typedef xmlDoc *xmlDocPtr;
struct _xmlDoc {
    void *_private;
    xmlElementType type;
    char *name;
    struct _xmlNode *children;
    struct _xmlNode *last;
    struct _xmlNode *parent;
    struct _xmlNode *next;
    struct _xmlNode *prev;
    struct _xmlDoc *doc;


    int compression;
    int standalone;





    struct _xmlDtd *intSubset;
    struct _xmlDtd *extSubset;
    struct _xmlNs *oldNs;
    const xmlChar *version;
    const xmlChar *encoding;
    void *ids;
    void *refs;
    const xmlChar *URL;
    int charset;

    struct _xmlDict *dict;
    void *psvi;
    int parseFlags;

    int properties;

};


typedef struct _xmlDOMWrapCtxt xmlDOMWrapCtxt;
typedef xmlDOMWrapCtxt *xmlDOMWrapCtxtPtr;
# 602 "./include/libxml/tree.h"
typedef xmlNsPtr (*xmlDOMWrapAcquireNsFunction) (xmlDOMWrapCtxtPtr ctxt,
       xmlNodePtr node,
       const xmlChar *nsName,
       const xmlChar *nsPrefix);






struct _xmlDOMWrapCtxt {
    void * _private;




    int type;



    void * namespaceMap;




    xmlDOMWrapAcquireNsFunction getNsForNodeFunc;
};
# 658 "./include/libxml/tree.h"
 int
  xmlValidateNCName (const xmlChar *value,
      int space);



 int
  xmlValidateQName (const xmlChar *value,
      int space);
 int
  xmlValidateName (const xmlChar *value,
      int space);
 int
  xmlValidateNMToken (const xmlChar *value,
      int space);


 xmlChar *
  xmlBuildQName (const xmlChar *ncname,
      const xmlChar *prefix,
      xmlChar *memory,
      int len);
 xmlChar *
  xmlSplitQName2 (const xmlChar *name,
      xmlChar **prefix);
 const xmlChar *
  xmlSplitQName3 (const xmlChar *name,
      int *len);





 void
  xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);
 xmlBufferAllocationScheme
  xmlGetBufferAllocationScheme(void);

 xmlBufferPtr
  xmlBufferCreate (void);
 xmlBufferPtr
  xmlBufferCreateSize (size_t size);
 xmlBufferPtr
  xmlBufferCreateStatic (void *mem,
      size_t size);
 int
  xmlBufferResize (xmlBufferPtr buf,
      unsigned int size);
 void
  xmlBufferFree (xmlBufferPtr buf);
 int
  xmlBufferDump (FILE *file,
      xmlBufferPtr buf);
 int
  xmlBufferAdd (xmlBufferPtr buf,
      const xmlChar *str,
      int len);
 int
  xmlBufferAddHead (xmlBufferPtr buf,
      const xmlChar *str,
      int len);
 int
  xmlBufferCat (xmlBufferPtr buf,
      const xmlChar *str);
 int
  xmlBufferCCat (xmlBufferPtr buf,
      const char *str);
 int
  xmlBufferShrink (xmlBufferPtr buf,
      unsigned int len);
 int
  xmlBufferGrow (xmlBufferPtr buf,
      unsigned int len);
 void
  xmlBufferEmpty (xmlBufferPtr buf);
 const xmlChar*
  xmlBufferContent (const xmlBufferPtr buf);
 xmlChar*
  xmlBufferDetach (xmlBufferPtr buf);
 void
  xmlBufferSetAllocationScheme(xmlBufferPtr buf,
      xmlBufferAllocationScheme scheme);
 int
  xmlBufferLength (const xmlBufferPtr buf);




 xmlDtdPtr
  xmlCreateIntSubset (xmlDocPtr doc,
      const xmlChar *name,
      const xmlChar *ExternalID,
      const xmlChar *SystemID);
 xmlDtdPtr
  xmlNewDtd (xmlDocPtr doc,
      const xmlChar *name,
      const xmlChar *ExternalID,
      const xmlChar *SystemID);
 xmlDtdPtr
  xmlGetIntSubset (xmlDocPtr doc);
 void
  xmlFreeDtd (xmlDtdPtr cur);

 xmlNsPtr
  xmlNewGlobalNs (xmlDocPtr doc,
      const xmlChar *href,
      const xmlChar *prefix);

 xmlNsPtr
  xmlNewNs (xmlNodePtr node,
      const xmlChar *href,
      const xmlChar *prefix);
 void
  xmlFreeNs (xmlNsPtr cur);
 void
  xmlFreeNsList (xmlNsPtr cur);
 xmlDocPtr
  xmlNewDoc (const xmlChar *version);
 void
  xmlFreeDoc (xmlDocPtr cur);
 xmlAttrPtr
  xmlNewDocProp (xmlDocPtr doc,
      const xmlChar *name,
      const xmlChar *value);


 xmlAttrPtr
  xmlNewProp (xmlNodePtr node,
      const xmlChar *name,
      const xmlChar *value);

 xmlAttrPtr
  xmlNewNsProp (xmlNodePtr node,
      xmlNsPtr ns,
      const xmlChar *name,
      const xmlChar *value);
 xmlAttrPtr
  xmlNewNsPropEatName (xmlNodePtr node,
      xmlNsPtr ns,
      xmlChar *name,
      const xmlChar *value);
 void
  xmlFreePropList (xmlAttrPtr cur);
 void
  xmlFreeProp (xmlAttrPtr cur);
 xmlAttrPtr
  xmlCopyProp (xmlNodePtr target,
      xmlAttrPtr cur);
 xmlAttrPtr
  xmlCopyPropList (xmlNodePtr target,
      xmlAttrPtr cur);

 xmlDtdPtr
  xmlCopyDtd (xmlDtdPtr dtd);


 xmlDocPtr
  xmlCopyDoc (xmlDocPtr doc,
      int recursive);




 xmlNodePtr
  xmlNewDocNode (xmlDocPtr doc,
      xmlNsPtr ns,
      const xmlChar *name,
      const xmlChar *content);
 xmlNodePtr
  xmlNewDocNodeEatName (xmlDocPtr doc,
      xmlNsPtr ns,
      xmlChar *name,
      const xmlChar *content);
 xmlNodePtr
  xmlNewNode (xmlNsPtr ns,
      const xmlChar *name);
 xmlNodePtr
  xmlNewNodeEatName (xmlNsPtr ns,
      xmlChar *name);

 xmlNodePtr
  xmlNewChild (xmlNodePtr parent,
      xmlNsPtr ns,
      const xmlChar *name,
      const xmlChar *content);

 xmlNodePtr
  xmlNewDocText (xmlDocPtr doc,
      const xmlChar *content);
 xmlNodePtr
  xmlNewText (const xmlChar *content);
 xmlNodePtr
  xmlNewDocPI (xmlDocPtr doc,
      const xmlChar *name,
      const xmlChar *content);
 xmlNodePtr
  xmlNewPI (const xmlChar *name,
      const xmlChar *content);
 xmlNodePtr
  xmlNewDocTextLen (xmlDocPtr doc,
      const xmlChar *content,
      int len);
 xmlNodePtr
  xmlNewTextLen (const xmlChar *content,
      int len);
 xmlNodePtr
  xmlNewDocComment (xmlDocPtr doc,
      const xmlChar *content);
 xmlNodePtr
  xmlNewComment (const xmlChar *content);
 xmlNodePtr
  xmlNewCDataBlock (xmlDocPtr doc,
      const xmlChar *content,
      int len);
 xmlNodePtr
  xmlNewCharRef (xmlDocPtr doc,
      const xmlChar *name);
 xmlNodePtr
  xmlNewReference (xmlDocPtr doc,
      const xmlChar *name);
 xmlNodePtr
  xmlCopyNode (const xmlNodePtr node,
      int recursive);
 xmlNodePtr
  xmlDocCopyNode (const xmlNodePtr node,
      xmlDocPtr doc,
      int recursive);
 xmlNodePtr
  xmlDocCopyNodeList (xmlDocPtr doc,
      const xmlNodePtr node);
 xmlNodePtr
  xmlCopyNodeList (const xmlNodePtr node);

 xmlNodePtr
  xmlNewTextChild (xmlNodePtr parent,
      xmlNsPtr ns,
      const xmlChar *name,
      const xmlChar *content);
 xmlNodePtr
  xmlNewDocRawNode (xmlDocPtr doc,
      xmlNsPtr ns,
      const xmlChar *name,
      const xmlChar *content);
 xmlNodePtr
  xmlNewDocFragment (xmlDocPtr doc);





 long
  xmlGetLineNo (xmlNodePtr node);

 xmlChar *
  xmlGetNodePath (xmlNodePtr node);

 xmlNodePtr
  xmlDocGetRootElement (xmlDocPtr doc);
 xmlNodePtr
  xmlGetLastChild (xmlNodePtr parent);
 int
  xmlNodeIsText (xmlNodePtr node);
 int
  xmlIsBlankNode (xmlNodePtr node);





 xmlNodePtr
  xmlDocSetRootElement (xmlDocPtr doc,
      xmlNodePtr root);


 void
  xmlNodeSetName (xmlNodePtr cur,
      const xmlChar *name);

 xmlNodePtr
  xmlAddChild (xmlNodePtr parent,
      xmlNodePtr cur);
 xmlNodePtr
  xmlAddChildList (xmlNodePtr parent,
      xmlNodePtr cur);

 xmlNodePtr
  xmlReplaceNode (xmlNodePtr old,
      xmlNodePtr cur);



 xmlNodePtr
  xmlAddPrevSibling (xmlNodePtr cur,
      xmlNodePtr elem);

 xmlNodePtr
  xmlAddSibling (xmlNodePtr cur,
      xmlNodePtr elem);
 xmlNodePtr
  xmlAddNextSibling (xmlNodePtr cur,
      xmlNodePtr elem);
 void
  xmlUnlinkNode (xmlNodePtr cur);
 xmlNodePtr
  xmlTextMerge (xmlNodePtr first,
      xmlNodePtr second);
 int
  xmlTextConcat (xmlNodePtr node,
      const xmlChar *content,
      int len);
 void
  xmlFreeNodeList (xmlNodePtr cur);
 void
  xmlFreeNode (xmlNodePtr cur);
 void
  xmlSetTreeDoc (xmlNodePtr tree,
      xmlDocPtr doc);
 void
  xmlSetListDoc (xmlNodePtr list,
      xmlDocPtr doc);



 xmlNsPtr
  xmlSearchNs (xmlDocPtr doc,
      xmlNodePtr node,
      const xmlChar *nameSpace);
 xmlNsPtr
  xmlSearchNsByHref (xmlDocPtr doc,
      xmlNodePtr node,
      const xmlChar *href);

 xmlNsPtr *
  xmlGetNsList (xmlDocPtr doc,
      xmlNodePtr node);


 void
  xmlSetNs (xmlNodePtr node,
      xmlNsPtr ns);
 xmlNsPtr
  xmlCopyNamespace (xmlNsPtr cur);
 xmlNsPtr
  xmlCopyNamespaceList (xmlNsPtr cur);





 xmlAttrPtr
  xmlSetProp (xmlNodePtr node,
      const xmlChar *name,
      const xmlChar *value);
 xmlAttrPtr
  xmlSetNsProp (xmlNodePtr node,
      xmlNsPtr ns,
      const xmlChar *name,
      const xmlChar *value);

 xmlChar *
  xmlGetNoNsProp (xmlNodePtr node,
      const xmlChar *name);
 xmlChar *
  xmlGetProp (xmlNodePtr node,
      const xmlChar *name);
 xmlAttrPtr
  xmlHasProp (xmlNodePtr node,
      const xmlChar *name);
 xmlAttrPtr
  xmlHasNsProp (xmlNodePtr node,
      const xmlChar *name,
      const xmlChar *nameSpace);
 xmlChar *
  xmlGetNsProp (xmlNodePtr node,
      const xmlChar *name,
      const xmlChar *nameSpace);
 xmlNodePtr
  xmlStringGetNodeList (xmlDocPtr doc,
      const xmlChar *value);
 xmlNodePtr
  xmlStringLenGetNodeList (xmlDocPtr doc,
      const xmlChar *value,
      int len);
 xmlChar *
  xmlNodeListGetString (xmlDocPtr doc,
      xmlNodePtr list,
      int inLine);

 xmlChar *
  xmlNodeListGetRawString (xmlDocPtr doc,
      xmlNodePtr list,
      int inLine);

 void
  xmlNodeSetContent (xmlNodePtr cur,
      const xmlChar *content);

 void
  xmlNodeSetContentLen (xmlNodePtr cur,
      const xmlChar *content,
      int len);

 void
  xmlNodeAddContent (xmlNodePtr cur,
      const xmlChar *content);
 void
  xmlNodeAddContentLen (xmlNodePtr cur,
      const xmlChar *content,
      int len);
 xmlChar *
  xmlNodeGetContent (xmlNodePtr cur);

 int
  xmlNodeBufGetContent (xmlBufferPtr buffer,
      xmlNodePtr cur);
 int
  xmlBufGetNodeContent (xmlBufPtr buf,
      xmlNodePtr cur);

 xmlChar *
  xmlNodeGetLang (xmlNodePtr cur);
 int
  xmlNodeGetSpacePreserve (xmlNodePtr cur);

 void
  xmlNodeSetLang (xmlNodePtr cur,
      const xmlChar *lang);
 void
  xmlNodeSetSpacePreserve (xmlNodePtr cur,
      int val);

 xmlChar *
  xmlNodeGetBase (xmlDocPtr doc,
      xmlNodePtr cur);

 void
  xmlNodeSetBase (xmlNodePtr cur,
      const xmlChar *uri);





 int
  xmlRemoveProp (xmlAttrPtr cur);

 int
  xmlUnsetNsProp (xmlNodePtr node,
      xmlNsPtr ns,
      const xmlChar *name);
 int
  xmlUnsetProp (xmlNodePtr node,
      const xmlChar *name);





 void
  xmlBufferWriteCHAR (xmlBufferPtr buf,
      const xmlChar *string);
 void
  xmlBufferWriteChar (xmlBufferPtr buf,
      const char *string);
 void
  xmlBufferWriteQuotedString(xmlBufferPtr buf,
      const xmlChar *string);


 void xmlAttrSerializeTxtContent(xmlBufferPtr buf,
      xmlDocPtr doc,
      xmlAttrPtr attr,
      const xmlChar *string);






 int
  xmlReconciliateNs (xmlDocPtr doc,
      xmlNodePtr tree);






 void
  xmlDocDumpFormatMemory (xmlDocPtr cur,
      xmlChar **mem,
      int *size,
      int format);
 void
  xmlDocDumpMemory (xmlDocPtr cur,
      xmlChar **mem,
      int *size);
 void
  xmlDocDumpMemoryEnc (xmlDocPtr out_doc,
      xmlChar **doc_txt_ptr,
      int * doc_txt_len,
      const char *txt_encoding);
 void
  xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc,
      xmlChar **doc_txt_ptr,
      int * doc_txt_len,
      const char *txt_encoding,
      int format);
 int
  xmlDocFormatDump (FILE *f,
      xmlDocPtr cur,
      int format);
 int
  xmlDocDump (FILE *f,
      xmlDocPtr cur);
 void
  xmlElemDump (FILE *f,
      xmlDocPtr doc,
      xmlNodePtr cur);
 int
  xmlSaveFile (const char *filename,
      xmlDocPtr cur);
 int
  xmlSaveFormatFile (const char *filename,
      xmlDocPtr cur,
      int format);
 size_t
  xmlBufNodeDump (xmlBufPtr buf,
      xmlDocPtr doc,
      xmlNodePtr cur,
      int level,
      int format);
 int
  xmlNodeDump (xmlBufferPtr buf,
      xmlDocPtr doc,
      xmlNodePtr cur,
      int level,
      int format);

 int
  xmlSaveFileTo (xmlOutputBufferPtr buf,
      xmlDocPtr cur,
      const char *encoding);
 int
  xmlSaveFormatFileTo (xmlOutputBufferPtr buf,
      xmlDocPtr cur,
             const char *encoding,
             int format);
 void
  xmlNodeDumpOutput (xmlOutputBufferPtr buf,
      xmlDocPtr doc,
      xmlNodePtr cur,
      int level,
      int format,
      const char *encoding);

 int
  xmlSaveFormatFileEnc (const char *filename,
      xmlDocPtr cur,
      const char *encoding,
      int format);

 int
  xmlSaveFileEnc (const char *filename,
      xmlDocPtr cur,
      const char *encoding);





 int
  xmlIsXHTML (const xmlChar *systemID,
      const xmlChar *publicID);




 int
  xmlGetDocCompressMode (xmlDocPtr doc);
 void
  xmlSetDocCompressMode (xmlDocPtr doc,
      int mode);
 int
  xmlGetCompressMode (void);
 void
  xmlSetCompressMode (int mode);




 xmlDOMWrapCtxtPtr
  xmlDOMWrapNewCtxt (void);
 void
  xmlDOMWrapFreeCtxt (xmlDOMWrapCtxtPtr ctxt);
 int
     xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt,
      xmlNodePtr elem,
      int options);
 int
     xmlDOMWrapAdoptNode (xmlDOMWrapCtxtPtr ctxt,
      xmlDocPtr sourceDoc,
      xmlNodePtr node,
      xmlDocPtr destDoc,
      xmlNodePtr destParent,
      int options);
 int
     xmlDOMWrapRemoveNode (xmlDOMWrapCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr node,
      int options);
 int
     xmlDOMWrapCloneNode (xmlDOMWrapCtxtPtr ctxt,
      xmlDocPtr sourceDoc,
      xmlNodePtr node,
      xmlNodePtr *clonedNode,
      xmlDocPtr destDoc,
      xmlNodePtr destParent,
      int deep,
      int options);






 unsigned long
            xmlChildElementCount (xmlNodePtr parent);
 xmlNodePtr
            xmlNextElementSibling (xmlNodePtr node);
 xmlNodePtr
            xmlFirstElementChild (xmlNodePtr parent);
 xmlNodePtr
            xmlLastElementChild (xmlNodePtr parent);
 xmlNodePtr
            xmlPreviousElementSibling (xmlNodePtr node);
# 17 "./include/libxml/parser.h" 2

# 1 "./include/libxml/hash.h" 1
# 21 "./include/libxml/hash.h"
typedef struct _xmlHashTable xmlHashTable;
typedef xmlHashTable *xmlHashTablePtr;






# 1 "./include/libxml/parser.h" 1
# 30 "./include/libxml/hash.h" 2
# 69 "./include/libxml/hash.h"
typedef void (*xmlHashDeallocator)(void *payload, xmlChar *name);
# 79 "./include/libxml/hash.h"
typedef void *(*xmlHashCopier)(void *payload, xmlChar *name);
# 88 "./include/libxml/hash.h"
typedef void (*xmlHashScanner)(void *payload, void *data, xmlChar *name);
# 99 "./include/libxml/hash.h"
typedef void (*xmlHashScannerFull)(void *payload, void *data,
       const xmlChar *name, const xmlChar *name2,
       const xmlChar *name3);




 xmlHashTablePtr
   xmlHashCreate (int size);
 xmlHashTablePtr
   xmlHashCreateDict(int size,
      xmlDictPtr dict);
 void
   xmlHashFree (xmlHashTablePtr table,
      xmlHashDeallocator f);




 int
   xmlHashAddEntry (xmlHashTablePtr table,
                           const xmlChar *name,
                           void *userdata);
 int
   xmlHashUpdateEntry(xmlHashTablePtr table,
                           const xmlChar *name,
                           void *userdata,
      xmlHashDeallocator f);
 int
   xmlHashAddEntry2(xmlHashTablePtr table,
                           const xmlChar *name,
                           const xmlChar *name2,
                           void *userdata);
 int
   xmlHashUpdateEntry2(xmlHashTablePtr table,
                           const xmlChar *name,
                           const xmlChar *name2,
                           void *userdata,
      xmlHashDeallocator f);
 int
   xmlHashAddEntry3(xmlHashTablePtr table,
                           const xmlChar *name,
                           const xmlChar *name2,
                           const xmlChar *name3,
                           void *userdata);
 int
   xmlHashUpdateEntry3(xmlHashTablePtr table,
                           const xmlChar *name,
                           const xmlChar *name2,
                           const xmlChar *name3,
                           void *userdata,
      xmlHashDeallocator f);




 int
   xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name,
                           xmlHashDeallocator f);
 int
   xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name,
                            const xmlChar *name2, xmlHashDeallocator f);
 int
   xmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name,
                            const xmlChar *name2, const xmlChar *name3,
                            xmlHashDeallocator f);




 void *
   xmlHashLookup (xmlHashTablePtr table,
      const xmlChar *name);
 void *
   xmlHashLookup2 (xmlHashTablePtr table,
      const xmlChar *name,
      const xmlChar *name2);
 void *
   xmlHashLookup3 (xmlHashTablePtr table,
      const xmlChar *name,
      const xmlChar *name2,
      const xmlChar *name3);
 void *
   xmlHashQLookup (xmlHashTablePtr table,
      const xmlChar *name,
      const xmlChar *prefix);
 void *
   xmlHashQLookup2 (xmlHashTablePtr table,
      const xmlChar *name,
      const xmlChar *prefix,
      const xmlChar *name2,
      const xmlChar *prefix2);
 void *
   xmlHashQLookup3 (xmlHashTablePtr table,
      const xmlChar *name,
      const xmlChar *prefix,
      const xmlChar *name2,
      const xmlChar *prefix2,
      const xmlChar *name3,
      const xmlChar *prefix3);




 xmlHashTablePtr
   xmlHashCopy (xmlHashTablePtr table,
      xmlHashCopier f);
 int
   xmlHashSize (xmlHashTablePtr table);
 void
   xmlHashScan (xmlHashTablePtr table,
      xmlHashScanner f,
      void *data);
 void
   xmlHashScan3 (xmlHashTablePtr table,
      const xmlChar *name,
      const xmlChar *name2,
      const xmlChar *name3,
      xmlHashScanner f,
      void *data);
 void
   xmlHashScanFull (xmlHashTablePtr table,
      xmlHashScannerFull f,
      void *data);
 void
   xmlHashScanFull3(xmlHashTablePtr table,
      const xmlChar *name,
      const xmlChar *name2,
      const xmlChar *name3,
      xmlHashScannerFull f,
      void *data);
# 19 "./include/libxml/parser.h" 2
# 1 "./include/libxml/valid.h" 1
# 15 "./include/libxml/valid.h"
# 1 "./include/libxml/xmlerror.h" 1
# 24 "./include/libxml/xmlerror.h"
typedef enum {
    XML_ERR_NONE = 0,
    XML_ERR_WARNING = 1,
    XML_ERR_ERROR = 2,
    XML_ERR_FATAL = 3
} xmlErrorLevel;






typedef enum {
    XML_FROM_NONE = 0,
    XML_FROM_PARSER,
    XML_FROM_TREE,
    XML_FROM_NAMESPACE,
    XML_FROM_DTD,
    XML_FROM_HTML,
    XML_FROM_MEMORY,
    XML_FROM_OUTPUT,
    XML_FROM_IO,
    XML_FROM_FTP,
    XML_FROM_HTTP,
    XML_FROM_XINCLUDE,
    XML_FROM_XPATH,
    XML_FROM_XPOINTER,
    XML_FROM_REGEXP,
    XML_FROM_DATATYPE,
    XML_FROM_SCHEMASP,
    XML_FROM_SCHEMASV,
    XML_FROM_RELAXNGP,
    XML_FROM_RELAXNGV,
    XML_FROM_CATALOG,
    XML_FROM_C14N,
    XML_FROM_XSLT,
    XML_FROM_VALID,
    XML_FROM_CHECK,
    XML_FROM_WRITER,
    XML_FROM_MODULE,
    XML_FROM_I18N,
    XML_FROM_SCHEMATRONV,
    XML_FROM_BUFFER,
    XML_FROM_URI
} xmlErrorDomain;







typedef struct _xmlError xmlError;
typedef xmlError *xmlErrorPtr;
struct _xmlError {
    int domain;
    int code;
    char *message;
    xmlErrorLevel level;
    char *file;
    int line;
    char *str1;
    char *str2;
    char *str3;
    int int1;
    int int2;
    void *ctxt;
    void *node;
};






typedef enum {
    XML_ERR_OK = 0,
    XML_ERR_INTERNAL_ERROR,
    XML_ERR_NO_MEMORY,
    XML_ERR_DOCUMENT_START,
    XML_ERR_DOCUMENT_EMPTY,
    XML_ERR_DOCUMENT_END,
    XML_ERR_INVALID_HEX_CHARREF,
    XML_ERR_INVALID_DEC_CHARREF,
    XML_ERR_INVALID_CHARREF,
    XML_ERR_INVALID_CHAR,
    XML_ERR_CHARREF_AT_EOF,
    XML_ERR_CHARREF_IN_PROLOG,
    XML_ERR_CHARREF_IN_EPILOG,
    XML_ERR_CHARREF_IN_DTD,
    XML_ERR_ENTITYREF_AT_EOF,
    XML_ERR_ENTITYREF_IN_PROLOG,
    XML_ERR_ENTITYREF_IN_EPILOG,
    XML_ERR_ENTITYREF_IN_DTD,
    XML_ERR_PEREF_AT_EOF,
    XML_ERR_PEREF_IN_PROLOG,
    XML_ERR_PEREF_IN_EPILOG,
    XML_ERR_PEREF_IN_INT_SUBSET,
    XML_ERR_ENTITYREF_NO_NAME,
    XML_ERR_ENTITYREF_SEMICOL_MISSING,
    XML_ERR_PEREF_NO_NAME,
    XML_ERR_PEREF_SEMICOL_MISSING,
    XML_ERR_UNDECLARED_ENTITY,
    XML_WAR_UNDECLARED_ENTITY,
    XML_ERR_UNPARSED_ENTITY,
    XML_ERR_ENTITY_IS_EXTERNAL,
    XML_ERR_ENTITY_IS_PARAMETER,
    XML_ERR_UNKNOWN_ENCODING,
    XML_ERR_UNSUPPORTED_ENCODING,
    XML_ERR_STRING_NOT_STARTED,
    XML_ERR_STRING_NOT_CLOSED,
    XML_ERR_NS_DECL_ERROR,
    XML_ERR_ENTITY_NOT_STARTED,
    XML_ERR_ENTITY_NOT_FINISHED,
    XML_ERR_LT_IN_ATTRIBUTE,
    XML_ERR_ATTRIBUTE_NOT_STARTED,
    XML_ERR_ATTRIBUTE_NOT_FINISHED,
    XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
    XML_ERR_ATTRIBUTE_REDEFINED,
    XML_ERR_LITERAL_NOT_STARTED,
    XML_ERR_LITERAL_NOT_FINISHED,
    XML_ERR_COMMENT_NOT_FINISHED,
    XML_ERR_PI_NOT_STARTED,
    XML_ERR_PI_NOT_FINISHED,
    XML_ERR_NOTATION_NOT_STARTED,
    XML_ERR_NOTATION_NOT_FINISHED,
    XML_ERR_ATTLIST_NOT_STARTED,
    XML_ERR_ATTLIST_NOT_FINISHED,
    XML_ERR_MIXED_NOT_STARTED,
    XML_ERR_MIXED_NOT_FINISHED,
    XML_ERR_ELEMCONTENT_NOT_STARTED,
    XML_ERR_ELEMCONTENT_NOT_FINISHED,
    XML_ERR_XMLDECL_NOT_STARTED,
    XML_ERR_XMLDECL_NOT_FINISHED,
    XML_ERR_CONDSEC_NOT_STARTED,
    XML_ERR_CONDSEC_NOT_FINISHED,
    XML_ERR_EXT_SUBSET_NOT_FINISHED,
    XML_ERR_DOCTYPE_NOT_FINISHED,
    XML_ERR_MISPLACED_CDATA_END,
    XML_ERR_CDATA_NOT_FINISHED,
    XML_ERR_RESERVED_XML_NAME,
    XML_ERR_SPACE_REQUIRED,
    XML_ERR_SEPARATOR_REQUIRED,
    XML_ERR_NMTOKEN_REQUIRED,
    XML_ERR_NAME_REQUIRED,
    XML_ERR_PCDATA_REQUIRED,
    XML_ERR_URI_REQUIRED,
    XML_ERR_PUBID_REQUIRED,
    XML_ERR_LT_REQUIRED,
    XML_ERR_GT_REQUIRED,
    XML_ERR_LTSLASH_REQUIRED,
    XML_ERR_EQUAL_REQUIRED,
    XML_ERR_TAG_NAME_MISMATCH,
    XML_ERR_TAG_NOT_FINISHED,
    XML_ERR_STANDALONE_VALUE,
    XML_ERR_ENCODING_NAME,
    XML_ERR_HYPHEN_IN_COMMENT,
    XML_ERR_INVALID_ENCODING,
    XML_ERR_EXT_ENTITY_STANDALONE,
    XML_ERR_CONDSEC_INVALID,
    XML_ERR_VALUE_REQUIRED,
    XML_ERR_NOT_WELL_BALANCED,
    XML_ERR_EXTRA_CONTENT,
    XML_ERR_ENTITY_CHAR_ERROR,
    XML_ERR_ENTITY_PE_INTERNAL,
    XML_ERR_ENTITY_LOOP,
    XML_ERR_ENTITY_BOUNDARY,
    XML_ERR_INVALID_URI,
    XML_ERR_URI_FRAGMENT,
    XML_WAR_CATALOG_PI,
    XML_ERR_NO_DTD,
    XML_ERR_CONDSEC_INVALID_KEYWORD,
    XML_ERR_VERSION_MISSING,
    XML_WAR_UNKNOWN_VERSION,
    XML_WAR_LANG_VALUE,
    XML_WAR_NS_URI,
    XML_WAR_NS_URI_RELATIVE,
    XML_ERR_MISSING_ENCODING,
    XML_WAR_SPACE_VALUE,
    XML_ERR_NOT_STANDALONE,
    XML_ERR_ENTITY_PROCESSING,
    XML_ERR_NOTATION_PROCESSING,
    XML_WAR_NS_COLUMN,
    XML_WAR_ENTITY_REDEFINED,
    XML_ERR_UNKNOWN_VERSION,
    XML_ERR_VERSION_MISMATCH,
    XML_ERR_NAME_TOO_LONG,
    XML_NS_ERR_XML_NAMESPACE = 200,
    XML_NS_ERR_UNDEFINED_NAMESPACE,
    XML_NS_ERR_QNAME,
    XML_NS_ERR_ATTRIBUTE_REDEFINED,
    XML_NS_ERR_EMPTY,
    XML_NS_ERR_COLON,
    XML_DTD_ATTRIBUTE_DEFAULT = 500,
    XML_DTD_ATTRIBUTE_REDEFINED,
    XML_DTD_ATTRIBUTE_VALUE,
    XML_DTD_CONTENT_ERROR,
    XML_DTD_CONTENT_MODEL,
    XML_DTD_CONTENT_NOT_DETERMINIST,
    XML_DTD_DIFFERENT_PREFIX,
    XML_DTD_ELEM_DEFAULT_NAMESPACE,
    XML_DTD_ELEM_NAMESPACE,
    XML_DTD_ELEM_REDEFINED,
    XML_DTD_EMPTY_NOTATION,
    XML_DTD_ENTITY_TYPE,
    XML_DTD_ID_FIXED,
    XML_DTD_ID_REDEFINED,
    XML_DTD_ID_SUBSET,
    XML_DTD_INVALID_CHILD,
    XML_DTD_INVALID_DEFAULT,
    XML_DTD_LOAD_ERROR,
    XML_DTD_MISSING_ATTRIBUTE,
    XML_DTD_MIXED_CORRUPT,
    XML_DTD_MULTIPLE_ID,
    XML_DTD_NO_DOC,
    XML_DTD_NO_DTD,
    XML_DTD_NO_ELEM_NAME,
    XML_DTD_NO_PREFIX,
    XML_DTD_NO_ROOT,
    XML_DTD_NOTATION_REDEFINED,
    XML_DTD_NOTATION_VALUE,
    XML_DTD_NOT_EMPTY,
    XML_DTD_NOT_PCDATA,
    XML_DTD_NOT_STANDALONE,
    XML_DTD_ROOT_NAME,
    XML_DTD_STANDALONE_WHITE_SPACE,
    XML_DTD_UNKNOWN_ATTRIBUTE,
    XML_DTD_UNKNOWN_ELEM,
    XML_DTD_UNKNOWN_ENTITY,
    XML_DTD_UNKNOWN_ID,
    XML_DTD_UNKNOWN_NOTATION,
    XML_DTD_STANDALONE_DEFAULTED,
    XML_DTD_XMLID_VALUE,
    XML_DTD_XMLID_TYPE,
    XML_DTD_DUP_TOKEN,
    XML_HTML_STRUCURE_ERROR = 800,
    XML_HTML_UNKNOWN_TAG,
    XML_RNGP_ANYNAME_ATTR_ANCESTOR = 1000,
    XML_RNGP_ATTR_CONFLICT,
    XML_RNGP_ATTRIBUTE_CHILDREN,
    XML_RNGP_ATTRIBUTE_CONTENT,
    XML_RNGP_ATTRIBUTE_EMPTY,
    XML_RNGP_ATTRIBUTE_NOOP,
    XML_RNGP_CHOICE_CONTENT,
    XML_RNGP_CHOICE_EMPTY,
    XML_RNGP_CREATE_FAILURE,
    XML_RNGP_DATA_CONTENT,
    XML_RNGP_DEF_CHOICE_AND_INTERLEAVE,
    XML_RNGP_DEFINE_CREATE_FAILED,
    XML_RNGP_DEFINE_EMPTY,
    XML_RNGP_DEFINE_MISSING,
    XML_RNGP_DEFINE_NAME_MISSING,
    XML_RNGP_ELEM_CONTENT_EMPTY,
    XML_RNGP_ELEM_CONTENT_ERROR,
    XML_RNGP_ELEMENT_EMPTY,
    XML_RNGP_ELEMENT_CONTENT,
    XML_RNGP_ELEMENT_NAME,
    XML_RNGP_ELEMENT_NO_CONTENT,
    XML_RNGP_ELEM_TEXT_CONFLICT,
    XML_RNGP_EMPTY,
    XML_RNGP_EMPTY_CONSTRUCT,
    XML_RNGP_EMPTY_CONTENT,
    XML_RNGP_EMPTY_NOT_EMPTY,
    XML_RNGP_ERROR_TYPE_LIB,
    XML_RNGP_EXCEPT_EMPTY,
    XML_RNGP_EXCEPT_MISSING,
    XML_RNGP_EXCEPT_MULTIPLE,
    XML_RNGP_EXCEPT_NO_CONTENT,
    XML_RNGP_EXTERNALREF_EMTPY,
    XML_RNGP_EXTERNAL_REF_FAILURE,
    XML_RNGP_EXTERNALREF_RECURSE,
    XML_RNGP_FORBIDDEN_ATTRIBUTE,
    XML_RNGP_FOREIGN_ELEMENT,
    XML_RNGP_GRAMMAR_CONTENT,
    XML_RNGP_GRAMMAR_EMPTY,
    XML_RNGP_GRAMMAR_MISSING,
    XML_RNGP_GRAMMAR_NO_START,
    XML_RNGP_GROUP_ATTR_CONFLICT,
    XML_RNGP_HREF_ERROR,
    XML_RNGP_INCLUDE_EMPTY,
    XML_RNGP_INCLUDE_FAILURE,
    XML_RNGP_INCLUDE_RECURSE,
    XML_RNGP_INTERLEAVE_ADD,
    XML_RNGP_INTERLEAVE_CREATE_FAILED,
    XML_RNGP_INTERLEAVE_EMPTY,
    XML_RNGP_INTERLEAVE_NO_CONTENT,
    XML_RNGP_INVALID_DEFINE_NAME,
    XML_RNGP_INVALID_URI,
    XML_RNGP_INVALID_VALUE,
    XML_RNGP_MISSING_HREF,
    XML_RNGP_NAME_MISSING,
    XML_RNGP_NEED_COMBINE,
    XML_RNGP_NOTALLOWED_NOT_EMPTY,
    XML_RNGP_NSNAME_ATTR_ANCESTOR,
    XML_RNGP_NSNAME_NO_NS,
    XML_RNGP_PARAM_FORBIDDEN,
    XML_RNGP_PARAM_NAME_MISSING,
    XML_RNGP_PARENTREF_CREATE_FAILED,
    XML_RNGP_PARENTREF_NAME_INVALID,
    XML_RNGP_PARENTREF_NO_NAME,
    XML_RNGP_PARENTREF_NO_PARENT,
    XML_RNGP_PARENTREF_NOT_EMPTY,
    XML_RNGP_PARSE_ERROR,
    XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME,
    XML_RNGP_PAT_ATTR_ATTR,
    XML_RNGP_PAT_ATTR_ELEM,
    XML_RNGP_PAT_DATA_EXCEPT_ATTR,
    XML_RNGP_PAT_DATA_EXCEPT_ELEM,
    XML_RNGP_PAT_DATA_EXCEPT_EMPTY,
    XML_RNGP_PAT_DATA_EXCEPT_GROUP,
    XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE,
    XML_RNGP_PAT_DATA_EXCEPT_LIST,
    XML_RNGP_PAT_DATA_EXCEPT_ONEMORE,
    XML_RNGP_PAT_DATA_EXCEPT_REF,
    XML_RNGP_PAT_DATA_EXCEPT_TEXT,
    XML_RNGP_PAT_LIST_ATTR,
    XML_RNGP_PAT_LIST_ELEM,
    XML_RNGP_PAT_LIST_INTERLEAVE,
    XML_RNGP_PAT_LIST_LIST,
    XML_RNGP_PAT_LIST_REF,
    XML_RNGP_PAT_LIST_TEXT,
    XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME,
    XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME,
    XML_RNGP_PAT_ONEMORE_GROUP_ATTR,
    XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR,
    XML_RNGP_PAT_START_ATTR,
    XML_RNGP_PAT_START_DATA,
    XML_RNGP_PAT_START_EMPTY,
    XML_RNGP_PAT_START_GROUP,
    XML_RNGP_PAT_START_INTERLEAVE,
    XML_RNGP_PAT_START_LIST,
    XML_RNGP_PAT_START_ONEMORE,
    XML_RNGP_PAT_START_TEXT,
    XML_RNGP_PAT_START_VALUE,
    XML_RNGP_PREFIX_UNDEFINED,
    XML_RNGP_REF_CREATE_FAILED,
    XML_RNGP_REF_CYCLE,
    XML_RNGP_REF_NAME_INVALID,
    XML_RNGP_REF_NO_DEF,
    XML_RNGP_REF_NO_NAME,
    XML_RNGP_REF_NOT_EMPTY,
    XML_RNGP_START_CHOICE_AND_INTERLEAVE,
    XML_RNGP_START_CONTENT,
    XML_RNGP_START_EMPTY,
    XML_RNGP_START_MISSING,
    XML_RNGP_TEXT_EXPECTED,
    XML_RNGP_TEXT_HAS_CHILD,
    XML_RNGP_TYPE_MISSING,
    XML_RNGP_TYPE_NOT_FOUND,
    XML_RNGP_TYPE_VALUE,
    XML_RNGP_UNKNOWN_ATTRIBUTE,
    XML_RNGP_UNKNOWN_COMBINE,
    XML_RNGP_UNKNOWN_CONSTRUCT,
    XML_RNGP_UNKNOWN_TYPE_LIB,
    XML_RNGP_URI_FRAGMENT,
    XML_RNGP_URI_NOT_ABSOLUTE,
    XML_RNGP_VALUE_EMPTY,
    XML_RNGP_VALUE_NO_CONTENT,
    XML_RNGP_XMLNS_NAME,
    XML_RNGP_XML_NS,
    XML_XPATH_EXPRESSION_OK = 1200,
    XML_XPATH_NUMBER_ERROR,
    XML_XPATH_UNFINISHED_LITERAL_ERROR,
    XML_XPATH_START_LITERAL_ERROR,
    XML_XPATH_VARIABLE_REF_ERROR,
    XML_XPATH_UNDEF_VARIABLE_ERROR,
    XML_XPATH_INVALID_PREDICATE_ERROR,
    XML_XPATH_EXPR_ERROR,
    XML_XPATH_UNCLOSED_ERROR,
    XML_XPATH_UNKNOWN_FUNC_ERROR,
    XML_XPATH_INVALID_OPERAND,
    XML_XPATH_INVALID_TYPE,
    XML_XPATH_INVALID_ARITY,
    XML_XPATH_INVALID_CTXT_SIZE,
    XML_XPATH_INVALID_CTXT_POSITION,
    XML_XPATH_MEMORY_ERROR,
    XML_XPTR_SYNTAX_ERROR,
    XML_XPTR_RESOURCE_ERROR,
    XML_XPTR_SUB_RESOURCE_ERROR,
    XML_XPATH_UNDEF_PREFIX_ERROR,
    XML_XPATH_ENCODING_ERROR,
    XML_XPATH_INVALID_CHAR_ERROR,
    XML_TREE_INVALID_HEX = 1300,
    XML_TREE_INVALID_DEC,
    XML_TREE_UNTERMINATED_ENTITY,
    XML_TREE_NOT_UTF8,
    XML_SAVE_NOT_UTF8 = 1400,
    XML_SAVE_CHAR_INVALID,
    XML_SAVE_NO_DOCTYPE,
    XML_SAVE_UNKNOWN_ENCODING,
    XML_REGEXP_COMPILE_ERROR = 1450,
    XML_IO_UNKNOWN = 1500,
    XML_IO_EACCES,
    XML_IO_EAGAIN,
    XML_IO_EBADF,
    XML_IO_EBADMSG,
    XML_IO_EBUSY,
    XML_IO_ECANCELED,
    XML_IO_ECHILD,
    XML_IO_EDEADLK,
    XML_IO_EDOM,
    XML_IO_EEXIST,
    XML_IO_EFAULT,
    XML_IO_EFBIG,
    XML_IO_EINPROGRESS,
    XML_IO_EINTR,
    XML_IO_EINVAL,
    XML_IO_EIO,
    XML_IO_EISDIR,
    XML_IO_EMFILE,
    XML_IO_EMLINK,
    XML_IO_EMSGSIZE,
    XML_IO_ENAMETOOLONG,
    XML_IO_ENFILE,
    XML_IO_ENODEV,
    XML_IO_ENOENT,
    XML_IO_ENOEXEC,
    XML_IO_ENOLCK,
    XML_IO_ENOMEM,
    XML_IO_ENOSPC,
    XML_IO_ENOSYS,
    XML_IO_ENOTDIR,
    XML_IO_ENOTEMPTY,
    XML_IO_ENOTSUP,
    XML_IO_ENOTTY,
    XML_IO_ENXIO,
    XML_IO_EPERM,
    XML_IO_EPIPE,
    XML_IO_ERANGE,
    XML_IO_EROFS,
    XML_IO_ESPIPE,
    XML_IO_ESRCH,
    XML_IO_ETIMEDOUT,
    XML_IO_EXDEV,
    XML_IO_NETWORK_ATTEMPT,
    XML_IO_ENCODER,
    XML_IO_FLUSH,
    XML_IO_WRITE,
    XML_IO_NO_INPUT,
    XML_IO_BUFFER_FULL,
    XML_IO_LOAD_ERROR,
    XML_IO_ENOTSOCK,
    XML_IO_EISCONN,
    XML_IO_ECONNREFUSED,
    XML_IO_ENETUNREACH,
    XML_IO_EADDRINUSE,
    XML_IO_EALREADY,
    XML_IO_EAFNOSUPPORT,
    XML_XINCLUDE_RECURSION=1600,
    XML_XINCLUDE_PARSE_VALUE,
    XML_XINCLUDE_ENTITY_DEF_MISMATCH,
    XML_XINCLUDE_NO_HREF,
    XML_XINCLUDE_NO_FALLBACK,
    XML_XINCLUDE_HREF_URI,
    XML_XINCLUDE_TEXT_FRAGMENT,
    XML_XINCLUDE_TEXT_DOCUMENT,
    XML_XINCLUDE_INVALID_CHAR,
    XML_XINCLUDE_BUILD_FAILED,
    XML_XINCLUDE_UNKNOWN_ENCODING,
    XML_XINCLUDE_MULTIPLE_ROOT,
    XML_XINCLUDE_XPTR_FAILED,
    XML_XINCLUDE_XPTR_RESULT,
    XML_XINCLUDE_INCLUDE_IN_INCLUDE,
    XML_XINCLUDE_FALLBACKS_IN_INCLUDE,
    XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE,
    XML_XINCLUDE_DEPRECATED_NS,
    XML_XINCLUDE_FRAGMENT_ID,
    XML_CATALOG_MISSING_ATTR = 1650,
    XML_CATALOG_ENTRY_BROKEN,
    XML_CATALOG_PREFER_VALUE,
    XML_CATALOG_NOT_CATALOG,
    XML_CATALOG_RECURSION,
    XML_SCHEMAP_PREFIX_UNDEFINED = 1700,
    XML_SCHEMAP_ATTRFORMDEFAULT_VALUE,
    XML_SCHEMAP_ATTRGRP_NONAME_NOREF,
    XML_SCHEMAP_ATTR_NONAME_NOREF,
    XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF,
    XML_SCHEMAP_ELEMFORMDEFAULT_VALUE,
    XML_SCHEMAP_ELEM_NONAME_NOREF,
    XML_SCHEMAP_EXTENSION_NO_BASE,
    XML_SCHEMAP_FACET_NO_VALUE,
    XML_SCHEMAP_FAILED_BUILD_IMPORT,
    XML_SCHEMAP_GROUP_NONAME_NOREF,
    XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI,
    XML_SCHEMAP_IMPORT_REDEFINE_NSNAME,
    XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI,
    XML_SCHEMAP_INVALID_BOOLEAN,
    XML_SCHEMAP_INVALID_ENUM,
    XML_SCHEMAP_INVALID_FACET,
    XML_SCHEMAP_INVALID_FACET_VALUE,
    XML_SCHEMAP_INVALID_MAXOCCURS,
    XML_SCHEMAP_INVALID_MINOCCURS,
    XML_SCHEMAP_INVALID_REF_AND_SUBTYPE,
    XML_SCHEMAP_INVALID_WHITE_SPACE,
    XML_SCHEMAP_NOATTR_NOREF,
    XML_SCHEMAP_NOTATION_NO_NAME,
    XML_SCHEMAP_NOTYPE_NOREF,
    XML_SCHEMAP_REF_AND_SUBTYPE,
    XML_SCHEMAP_RESTRICTION_NONAME_NOREF,
    XML_SCHEMAP_SIMPLETYPE_NONAME,
    XML_SCHEMAP_TYPE_AND_SUBTYPE,
    XML_SCHEMAP_UNKNOWN_ALL_CHILD,
    XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD,
    XML_SCHEMAP_UNKNOWN_ATTR_CHILD,
    XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD,
    XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP,
    XML_SCHEMAP_UNKNOWN_BASE_TYPE,
    XML_SCHEMAP_UNKNOWN_CHOICE_CHILD,
    XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD,
    XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD,
    XML_SCHEMAP_UNKNOWN_ELEM_CHILD,
    XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD,
    XML_SCHEMAP_UNKNOWN_FACET_CHILD,
    XML_SCHEMAP_UNKNOWN_FACET_TYPE,
    XML_SCHEMAP_UNKNOWN_GROUP_CHILD,
    XML_SCHEMAP_UNKNOWN_IMPORT_CHILD,
    XML_SCHEMAP_UNKNOWN_LIST_CHILD,
    XML_SCHEMAP_UNKNOWN_NOTATION_CHILD,
    XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD,
    XML_SCHEMAP_UNKNOWN_REF,
    XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD,
    XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD,
    XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD,
    XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD,
    XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD,
    XML_SCHEMAP_UNKNOWN_TYPE,
    XML_SCHEMAP_UNKNOWN_UNION_CHILD,
    XML_SCHEMAP_ELEM_DEFAULT_FIXED,
    XML_SCHEMAP_REGEXP_INVALID,
    XML_SCHEMAP_FAILED_LOAD,
    XML_SCHEMAP_NOTHING_TO_PARSE,
    XML_SCHEMAP_NOROOT,
    XML_SCHEMAP_REDEFINED_GROUP,
    XML_SCHEMAP_REDEFINED_TYPE,
    XML_SCHEMAP_REDEFINED_ELEMENT,
    XML_SCHEMAP_REDEFINED_ATTRGROUP,
    XML_SCHEMAP_REDEFINED_ATTR,
    XML_SCHEMAP_REDEFINED_NOTATION,
    XML_SCHEMAP_FAILED_PARSE,
    XML_SCHEMAP_UNKNOWN_PREFIX,
    XML_SCHEMAP_DEF_AND_PREFIX,
    XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD,
    XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI,
    XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI,
    XML_SCHEMAP_NOT_SCHEMA,
    XML_SCHEMAP_UNKNOWN_MEMBER_TYPE,
    XML_SCHEMAP_INVALID_ATTR_USE,
    XML_SCHEMAP_RECURSIVE,
    XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE,
    XML_SCHEMAP_INVALID_ATTR_COMBINATION,
    XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION,
    XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD,
    XML_SCHEMAP_INVALID_ATTR_NAME,
    XML_SCHEMAP_REF_AND_CONTENT,
    XML_SCHEMAP_CT_PROPS_CORRECT_1,
    XML_SCHEMAP_CT_PROPS_CORRECT_2,
    XML_SCHEMAP_CT_PROPS_CORRECT_3,
    XML_SCHEMAP_CT_PROPS_CORRECT_4,
    XML_SCHEMAP_CT_PROPS_CORRECT_5,
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1,
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2,
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2,
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3,
    XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER,
    XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE,
    XML_SCHEMAP_UNION_NOT_EXPRESSIBLE,
    XML_SCHEMAP_SRC_IMPORT_3_1,
    XML_SCHEMAP_SRC_IMPORT_3_2,
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1,
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2,
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3,
    XML_SCHEMAP_COS_CT_EXTENDS_1_3,
    XML_SCHEMAV_NOROOT = 1801,
    XML_SCHEMAV_UNDECLAREDELEM,
    XML_SCHEMAV_NOTTOPLEVEL,
    XML_SCHEMAV_MISSING,
    XML_SCHEMAV_WRONGELEM,
    XML_SCHEMAV_NOTYPE,
    XML_SCHEMAV_NOROLLBACK,
    XML_SCHEMAV_ISABSTRACT,
    XML_SCHEMAV_NOTEMPTY,
    XML_SCHEMAV_ELEMCONT,
    XML_SCHEMAV_HAVEDEFAULT,
    XML_SCHEMAV_NOTNILLABLE,
    XML_SCHEMAV_EXTRACONTENT,
    XML_SCHEMAV_INVALIDATTR,
    XML_SCHEMAV_INVALIDELEM,
    XML_SCHEMAV_NOTDETERMINIST,
    XML_SCHEMAV_CONSTRUCT,
    XML_SCHEMAV_INTERNAL,
    XML_SCHEMAV_NOTSIMPLE,
    XML_SCHEMAV_ATTRUNKNOWN,
    XML_SCHEMAV_ATTRINVALID,
    XML_SCHEMAV_VALUE,
    XML_SCHEMAV_FACET,
    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1,
    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2,
    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3,
    XML_SCHEMAV_CVC_TYPE_3_1_1,
    XML_SCHEMAV_CVC_TYPE_3_1_2,
    XML_SCHEMAV_CVC_FACET_VALID,
    XML_SCHEMAV_CVC_LENGTH_VALID,
    XML_SCHEMAV_CVC_MINLENGTH_VALID,
    XML_SCHEMAV_CVC_MAXLENGTH_VALID,
    XML_SCHEMAV_CVC_MININCLUSIVE_VALID,
    XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID,
    XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID,
    XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID,
    XML_SCHEMAV_CVC_TOTALDIGITS_VALID,
    XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID,
    XML_SCHEMAV_CVC_PATTERN_VALID,
    XML_SCHEMAV_CVC_ENUMERATION_VALID,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4,
    XML_SCHEMAV_CVC_ELT_1,
    XML_SCHEMAV_CVC_ELT_2,
    XML_SCHEMAV_CVC_ELT_3_1,
    XML_SCHEMAV_CVC_ELT_3_2_1,
    XML_SCHEMAV_CVC_ELT_3_2_2,
    XML_SCHEMAV_CVC_ELT_4_1,
    XML_SCHEMAV_CVC_ELT_4_2,
    XML_SCHEMAV_CVC_ELT_4_3,
    XML_SCHEMAV_CVC_ELT_5_1_1,
    XML_SCHEMAV_CVC_ELT_5_1_2,
    XML_SCHEMAV_CVC_ELT_5_2_1,
    XML_SCHEMAV_CVC_ELT_5_2_2_1,
    XML_SCHEMAV_CVC_ELT_5_2_2_2_1,
    XML_SCHEMAV_CVC_ELT_5_2_2_2_2,
    XML_SCHEMAV_CVC_ELT_6,
    XML_SCHEMAV_CVC_ELT_7,
    XML_SCHEMAV_CVC_ATTRIBUTE_1,
    XML_SCHEMAV_CVC_ATTRIBUTE_2,
    XML_SCHEMAV_CVC_ATTRIBUTE_3,
    XML_SCHEMAV_CVC_ATTRIBUTE_4,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_4,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2,
    XML_SCHEMAV_ELEMENT_CONTENT,
    XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING,
    XML_SCHEMAV_CVC_COMPLEX_TYPE_1,
    XML_SCHEMAV_CVC_AU,
    XML_SCHEMAV_CVC_TYPE_1,
    XML_SCHEMAV_CVC_TYPE_2,
    XML_SCHEMAV_CVC_IDC,
    XML_SCHEMAV_CVC_WILDCARD,
    XML_SCHEMAV_MISC,
    XML_XPTR_UNKNOWN_SCHEME = 1900,
    XML_XPTR_CHILDSEQ_START,
    XML_XPTR_EVAL_FAILED,
    XML_XPTR_EXTRA_OBJECTS,
    XML_C14N_CREATE_CTXT = 1950,
    XML_C14N_REQUIRES_UTF8,
    XML_C14N_CREATE_STACK,
    XML_C14N_INVALID_NODE,
    XML_C14N_UNKNOW_NODE,
    XML_C14N_RELATIVE_NAMESPACE,
    XML_FTP_PASV_ANSWER = 2000,
    XML_FTP_EPSV_ANSWER,
    XML_FTP_ACCNT,
    XML_FTP_URL_SYNTAX,
    XML_HTTP_URL_SYNTAX = 2020,
    XML_HTTP_USE_IP,
    XML_HTTP_UNKNOWN_HOST,
    XML_SCHEMAP_SRC_SIMPLE_TYPE_1 = 3000,
    XML_SCHEMAP_SRC_SIMPLE_TYPE_2,
    XML_SCHEMAP_SRC_SIMPLE_TYPE_3,
    XML_SCHEMAP_SRC_SIMPLE_TYPE_4,
    XML_SCHEMAP_SRC_RESOLVE,
    XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
    XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE,
    XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES,
    XML_SCHEMAP_ST_PROPS_CORRECT_1,
    XML_SCHEMAP_ST_PROPS_CORRECT_2,
    XML_SCHEMAP_ST_PROPS_CORRECT_3,
    XML_SCHEMAP_COS_ST_RESTRICTS_1_1,
    XML_SCHEMAP_COS_ST_RESTRICTS_1_2,
    XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1,
    XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2,
    XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1,
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2,
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1,
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2,
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3,
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4,
    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5,
    XML_SCHEMAP_COS_ST_RESTRICTS_3_1,
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1,
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2,
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2,
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1,
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3,
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4,
    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5,
    XML_SCHEMAP_COS_ST_DERIVED_OK_2_1,
    XML_SCHEMAP_COS_ST_DERIVED_OK_2_2,
    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
    XML_SCHEMAP_S4S_ELEM_MISSING,
    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
    XML_SCHEMAP_S4S_ATTR_MISSING,
    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
    XML_SCHEMAP_SRC_ELEMENT_1,
    XML_SCHEMAP_SRC_ELEMENT_2_1,
    XML_SCHEMAP_SRC_ELEMENT_2_2,
    XML_SCHEMAP_SRC_ELEMENT_3,
    XML_SCHEMAP_P_PROPS_CORRECT_1,
    XML_SCHEMAP_P_PROPS_CORRECT_2_1,
    XML_SCHEMAP_P_PROPS_CORRECT_2_2,
    XML_SCHEMAP_E_PROPS_CORRECT_2,
    XML_SCHEMAP_E_PROPS_CORRECT_3,
    XML_SCHEMAP_E_PROPS_CORRECT_4,
    XML_SCHEMAP_E_PROPS_CORRECT_5,
    XML_SCHEMAP_E_PROPS_CORRECT_6,
    XML_SCHEMAP_SRC_INCLUDE,
    XML_SCHEMAP_SRC_ATTRIBUTE_1,
    XML_SCHEMAP_SRC_ATTRIBUTE_2,
    XML_SCHEMAP_SRC_ATTRIBUTE_3_1,
    XML_SCHEMAP_SRC_ATTRIBUTE_3_2,
    XML_SCHEMAP_SRC_ATTRIBUTE_4,
    XML_SCHEMAP_NO_XMLNS,
    XML_SCHEMAP_NO_XSI,
    XML_SCHEMAP_COS_VALID_DEFAULT_1,
    XML_SCHEMAP_COS_VALID_DEFAULT_2_1,
    XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1,
    XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2,
    XML_SCHEMAP_CVC_SIMPLE_TYPE,
    XML_SCHEMAP_COS_CT_EXTENDS_1_1,
    XML_SCHEMAP_SRC_IMPORT_1_1,
    XML_SCHEMAP_SRC_IMPORT_1_2,
    XML_SCHEMAP_SRC_IMPORT_2,
    XML_SCHEMAP_SRC_IMPORT_2_1,
    XML_SCHEMAP_SRC_IMPORT_2_2,
    XML_SCHEMAP_INTERNAL,
    XML_SCHEMAP_NOT_DETERMINISTIC,
    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1,
    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2,
    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3,
    XML_SCHEMAP_MG_PROPS_CORRECT_1,
    XML_SCHEMAP_MG_PROPS_CORRECT_2,
    XML_SCHEMAP_SRC_CT_1,
    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3,
    XML_SCHEMAP_AU_PROPS_CORRECT_2,
    XML_SCHEMAP_A_PROPS_CORRECT_2,
    XML_SCHEMAP_C_PROPS_CORRECT,
    XML_SCHEMAP_SRC_REDEFINE,
    XML_SCHEMAP_SRC_IMPORT,
    XML_SCHEMAP_WARN_SKIP_SCHEMA,
    XML_SCHEMAP_WARN_UNLOCATED_SCHEMA,
    XML_SCHEMAP_WARN_ATTR_REDECL_PROH,
    XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
    XML_SCHEMAP_AG_PROPS_CORRECT,
    XML_SCHEMAP_COS_CT_EXTENDS_1_2,
    XML_SCHEMAP_AU_PROPS_CORRECT,
    XML_SCHEMAP_A_PROPS_CORRECT_3,
    XML_SCHEMAP_COS_ALL_LIMITED,
    XML_SCHEMATRONV_ASSERT = 4000,
    XML_SCHEMATRONV_REPORT,
    XML_MODULE_OPEN = 4900,
    XML_MODULE_CLOSE,
    XML_CHECK_FOUND_ELEMENT = 5000,
    XML_CHECK_FOUND_ATTRIBUTE,
    XML_CHECK_FOUND_TEXT,
    XML_CHECK_FOUND_CDATA,
    XML_CHECK_FOUND_ENTITYREF,
    XML_CHECK_FOUND_ENTITY,
    XML_CHECK_FOUND_PI,
    XML_CHECK_FOUND_COMMENT,
    XML_CHECK_FOUND_DOCTYPE,
    XML_CHECK_FOUND_FRAGMENT,
    XML_CHECK_FOUND_NOTATION,
    XML_CHECK_UNKNOWN_NODE,
    XML_CHECK_ENTITY_TYPE,
    XML_CHECK_NO_PARENT,
    XML_CHECK_NO_DOC,
    XML_CHECK_NO_NAME,
    XML_CHECK_NO_ELEM,
    XML_CHECK_WRONG_DOC,
    XML_CHECK_NO_PREV,
    XML_CHECK_WRONG_PREV,
    XML_CHECK_NO_NEXT,
    XML_CHECK_WRONG_NEXT,
    XML_CHECK_NOT_DTD,
    XML_CHECK_NOT_ATTR,
    XML_CHECK_NOT_ATTR_DECL,
    XML_CHECK_NOT_ELEM_DECL,
    XML_CHECK_NOT_ENTITY_DECL,
    XML_CHECK_NOT_NS_DECL,
    XML_CHECK_NO_HREF,
    XML_CHECK_WRONG_PARENT,
    XML_CHECK_NS_SCOPE,
    XML_CHECK_NS_ANCESTOR,
    XML_CHECK_NOT_UTF8,
    XML_CHECK_NO_DICT,
    XML_CHECK_NOT_NCNAME,
    XML_CHECK_OUTSIDE_DICT,
    XML_CHECK_WRONG_NAME,
    XML_CHECK_NAME_NOT_NULL,
    XML_I18N_NO_NAME = 6000,
    XML_I18N_NO_HANDLER,
    XML_I18N_EXCESS_HANDLER,
    XML_I18N_CONV_FAILED,
    XML_I18N_NO_OUTPUT,
    XML_BUF_OVERFLOW = 7000
} xmlParserErrors;
# 844 "./include/libxml/xmlerror.h"
typedef void ( *xmlGenericErrorFunc) (void *ctx,
     const char *msg,
     ...) __attribute__((__format__(__printf__,2,3)));
# 855 "./include/libxml/xmlerror.h"
typedef void ( *xmlStructuredErrorFunc) (void *userData, xmlErrorPtr error);





 void
    xmlSetGenericErrorFunc (void *ctx,
     xmlGenericErrorFunc handler);
 void
    initGenericErrorDefaultFunc (xmlGenericErrorFunc *handler);

 void
    xmlSetStructuredErrorFunc (void *ctx,
     xmlStructuredErrorFunc handler);




 void
    xmlParserError (void *ctx,
     const char *msg,
     ...) __attribute__((__format__(__printf__,2,3)));
 void
    xmlParserWarning (void *ctx,
     const char *msg,
     ...) __attribute__((__format__(__printf__,2,3)));
 void
    xmlParserValidityError (void *ctx,
     const char *msg,
     ...) __attribute__((__format__(__printf__,2,3)));
 void
    xmlParserValidityWarning (void *ctx,
     const char *msg,
     ...) __attribute__((__format__(__printf__,2,3)));
 void
    xmlParserPrintFileInfo (xmlParserInputPtr input);
 void
    xmlParserPrintFileContext (xmlParserInputPtr input);




 xmlErrorPtr
    xmlGetLastError (void);
 void
    xmlResetLastError (void);
 xmlErrorPtr
    xmlCtxtGetLastError (void *ctx);
 void
    xmlCtxtResetLastError (void *ctx);
 void
    xmlResetError (xmlErrorPtr err);
 int
    xmlCopyError (xmlErrorPtr from,
     xmlErrorPtr to);
# 16 "./include/libxml/valid.h" 2

# 1 "./include/libxml/list.h" 1
# 20 "./include/libxml/list.h"
typedef struct _xmlLink xmlLink;
typedef xmlLink *xmlLinkPtr;

typedef struct _xmlList xmlList;
typedef xmlList *xmlListPtr;







typedef void (*xmlListDeallocator) (xmlLinkPtr lk);
# 42 "./include/libxml/list.h"
typedef int (*xmlListDataCompare) (const void *data0, const void *data1);
# 52 "./include/libxml/list.h"
typedef int (*xmlListWalker) (const void *data, const void *user);


 xmlListPtr
  xmlListCreate (xmlListDeallocator deallocator,
                                  xmlListDataCompare compare);
 void
  xmlListDelete (xmlListPtr l);


 void *
  xmlListSearch (xmlListPtr l,
      void *data);
 void *
  xmlListReverseSearch (xmlListPtr l,
      void *data);
 int
  xmlListInsert (xmlListPtr l,
      void *data) ;
 int
  xmlListAppend (xmlListPtr l,
      void *data) ;
 int
  xmlListRemoveFirst (xmlListPtr l,
      void *data);
 int
  xmlListRemoveLast (xmlListPtr l,
      void *data);
 int
  xmlListRemoveAll (xmlListPtr l,
      void *data);
 void
  xmlListClear (xmlListPtr l);
 int
  xmlListEmpty (xmlListPtr l);
 xmlLinkPtr
  xmlListFront (xmlListPtr l);
 xmlLinkPtr
  xmlListEnd (xmlListPtr l);
 int
  xmlListSize (xmlListPtr l);

 void
  xmlListPopFront (xmlListPtr l);
 void
  xmlListPopBack (xmlListPtr l);
 int
  xmlListPushFront (xmlListPtr l,
      void *data);
 int
  xmlListPushBack (xmlListPtr l,
      void *data);


 void
  xmlListReverse (xmlListPtr l);
 void
  xmlListSort (xmlListPtr l);
 void
  xmlListWalk (xmlListPtr l,
      xmlListWalker walker,
      const void *user);
 void
  xmlListReverseWalk (xmlListPtr l,
      xmlListWalker walker,
      const void *user);
 void
  xmlListMerge (xmlListPtr l1,
      xmlListPtr l2);
 xmlListPtr
  xmlListDup (const xmlListPtr old);
 int
  xmlListCopy (xmlListPtr cur,
      const xmlListPtr old);

 void *
  xmlLinkGetData (xmlLinkPtr lk);
# 18 "./include/libxml/valid.h" 2
# 1 "./include/libxml/xmlautomata.h" 1
# 29 "./include/libxml/xmlautomata.h"
typedef struct _xmlAutomata xmlAutomata;
typedef xmlAutomata *xmlAutomataPtr;






typedef struct _xmlAutomataState xmlAutomataState;
typedef xmlAutomataState *xmlAutomataStatePtr;




 xmlAutomataPtr
      xmlNewAutomata (void);
 void
      xmlFreeAutomata (xmlAutomataPtr am);

 xmlAutomataStatePtr
      xmlAutomataGetInitState (xmlAutomataPtr am);
 int
      xmlAutomataSetFinalState (xmlAutomataPtr am,
       xmlAutomataStatePtr state);
 xmlAutomataStatePtr
      xmlAutomataNewState (xmlAutomataPtr am);
 xmlAutomataStatePtr
      xmlAutomataNewTransition (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       const xmlChar *token,
       void *data);
 xmlAutomataStatePtr
      xmlAutomataNewTransition2 (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       const xmlChar *token,
       const xmlChar *token2,
       void *data);
 xmlAutomataStatePtr
                    xmlAutomataNewNegTrans (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       const xmlChar *token,
       const xmlChar *token2,
       void *data);

 xmlAutomataStatePtr
      xmlAutomataNewCountTrans (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       const xmlChar *token,
       int min,
       int max,
       void *data);
 xmlAutomataStatePtr
      xmlAutomataNewCountTrans2 (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       const xmlChar *token,
       const xmlChar *token2,
       int min,
       int max,
       void *data);
 xmlAutomataStatePtr
      xmlAutomataNewOnceTrans (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       const xmlChar *token,
       int min,
       int max,
       void *data);
 xmlAutomataStatePtr
      xmlAutomataNewOnceTrans2 (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       const xmlChar *token,
       const xmlChar *token2,
       int min,
       int max,
       void *data);
 xmlAutomataStatePtr
      xmlAutomataNewAllTrans (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       int lax);
 xmlAutomataStatePtr
      xmlAutomataNewEpsilon (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to);
 xmlAutomataStatePtr
      xmlAutomataNewCountedTrans (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       int counter);
 xmlAutomataStatePtr
      xmlAutomataNewCounterTrans (xmlAutomataPtr am,
       xmlAutomataStatePtr from,
       xmlAutomataStatePtr to,
       int counter);
 int
      xmlAutomataNewCounter (xmlAutomataPtr am,
       int min,
       int max);

 xmlRegexpPtr
      xmlAutomataCompile (xmlAutomataPtr am);
 int
      xmlAutomataIsDeterminist (xmlAutomataPtr am);
# 19 "./include/libxml/valid.h" 2
# 28 "./include/libxml/valid.h"
typedef struct _xmlValidState xmlValidState;
typedef xmlValidState *xmlValidStatePtr;
# 42 "./include/libxml/valid.h"
typedef void ( *xmlValidityErrorFunc) (void *ctx,
        const char *msg,
        ...) __attribute__((__format__(__printf__,2,3)));
# 57 "./include/libxml/valid.h"
typedef void ( *xmlValidityWarningFunc) (void *ctx,
          const char *msg,
          ...) __attribute__((__format__(__printf__,2,3)));
# 80 "./include/libxml/valid.h"
typedef struct _xmlValidCtxt xmlValidCtxt;
typedef xmlValidCtxt *xmlValidCtxtPtr;
struct _xmlValidCtxt {
    void *userData;
    xmlValidityErrorFunc error;
    xmlValidityWarningFunc warning;


    xmlNodePtr node;
    int nodeNr;
    int nodeMax;
    xmlNodePtr *nodeTab;

    unsigned int finishDtd;
    xmlDocPtr doc;
    int valid;


    xmlValidState *vstate;
    int vstateNr;
    int vstateMax;
    xmlValidState *vstateTab;


    xmlAutomataPtr am;
    xmlAutomataStatePtr state;




};






typedef struct _xmlHashTable xmlNotationTable;
typedef xmlNotationTable *xmlNotationTablePtr;






typedef struct _xmlHashTable xmlElementTable;
typedef xmlElementTable *xmlElementTablePtr;






typedef struct _xmlHashTable xmlAttributeTable;
typedef xmlAttributeTable *xmlAttributeTablePtr;






typedef struct _xmlHashTable xmlIDTable;
typedef xmlIDTable *xmlIDTablePtr;






typedef struct _xmlHashTable xmlRefTable;
typedef xmlRefTable *xmlRefTablePtr;


 xmlNotationPtr
  xmlAddNotationDecl (xmlValidCtxtPtr ctxt,
      xmlDtdPtr dtd,
      const xmlChar *name,
      const xmlChar *PublicID,
      const xmlChar *SystemID);

 xmlNotationTablePtr
  xmlCopyNotationTable (xmlNotationTablePtr table);

 void
  xmlFreeNotationTable (xmlNotationTablePtr table);

 void
  xmlDumpNotationDecl (xmlBufferPtr buf,
      xmlNotationPtr nota);
 void
  xmlDumpNotationTable (xmlBufferPtr buf,
      xmlNotationTablePtr table);




 xmlElementContentPtr
  xmlNewElementContent (const xmlChar *name,
      xmlElementContentType type);
 xmlElementContentPtr
  xmlCopyElementContent (xmlElementContentPtr content);
 void
  xmlFreeElementContent (xmlElementContentPtr cur);

 xmlElementContentPtr
  xmlNewDocElementContent (xmlDocPtr doc,
      const xmlChar *name,
      xmlElementContentType type);
 xmlElementContentPtr
  xmlCopyDocElementContent(xmlDocPtr doc,
      xmlElementContentPtr content);
 void
  xmlFreeDocElementContent(xmlDocPtr doc,
      xmlElementContentPtr cur);
 void
  xmlSnprintfElementContent(char *buf,
      int size,
                                  xmlElementContentPtr content,
      int englob);


 void
  xmlSprintfElementContent(char *buf,
                                  xmlElementContentPtr content,
      int englob);




 xmlElementPtr
  xmlAddElementDecl (xmlValidCtxtPtr ctxt,
      xmlDtdPtr dtd,
      const xmlChar *name,
      xmlElementTypeVal type,
      xmlElementContentPtr content);

 xmlElementTablePtr
  xmlCopyElementTable (xmlElementTablePtr table);

 void
  xmlFreeElementTable (xmlElementTablePtr table);

 void
  xmlDumpElementTable (xmlBufferPtr buf,
      xmlElementTablePtr table);
 void
  xmlDumpElementDecl (xmlBufferPtr buf,
      xmlElementPtr elem);



 xmlEnumerationPtr
  xmlCreateEnumeration (const xmlChar *name);
 void
  xmlFreeEnumeration (xmlEnumerationPtr cur);

 xmlEnumerationPtr
  xmlCopyEnumeration (xmlEnumerationPtr cur);



 xmlAttributePtr
  xmlAddAttributeDecl (xmlValidCtxtPtr ctxt,
      xmlDtdPtr dtd,
      const xmlChar *elem,
      const xmlChar *name,
      const xmlChar *ns,
      xmlAttributeType type,
      xmlAttributeDefault def,
      const xmlChar *defaultValue,
      xmlEnumerationPtr tree);

 xmlAttributeTablePtr
  xmlCopyAttributeTable (xmlAttributeTablePtr table);

 void
  xmlFreeAttributeTable (xmlAttributeTablePtr table);

 void
  xmlDumpAttributeTable (xmlBufferPtr buf,
     xmlAttributeTablePtr table);
 void
  xmlDumpAttributeDecl (xmlBufferPtr buf,
     xmlAttributePtr attr);



 xmlIDPtr
  xmlAddID (xmlValidCtxtPtr ctxt,
     xmlDocPtr doc,
     const xmlChar *value,
     xmlAttrPtr attr);
 void
  xmlFreeIDTable (xmlIDTablePtr table);
 xmlAttrPtr
  xmlGetID (xmlDocPtr doc,
     const xmlChar *ID);
 int
  xmlIsID (xmlDocPtr doc,
     xmlNodePtr elem,
     xmlAttrPtr attr);
 int
  xmlRemoveID (xmlDocPtr doc,
     xmlAttrPtr attr);


 xmlRefPtr
  xmlAddRef (xmlValidCtxtPtr ctxt,
     xmlDocPtr doc,
     const xmlChar *value,
     xmlAttrPtr attr);
 void
  xmlFreeRefTable (xmlRefTablePtr table);
 int
  xmlIsRef (xmlDocPtr doc,
     xmlNodePtr elem,
     xmlAttrPtr attr);
 int
  xmlRemoveRef (xmlDocPtr doc,
     xmlAttrPtr attr);
 xmlListPtr
  xmlGetRefs (xmlDocPtr doc,
     const xmlChar *ID);






 xmlValidCtxtPtr
  xmlNewValidCtxt(void);
 void
  xmlFreeValidCtxt(xmlValidCtxtPtr);

 int
  xmlValidateRoot (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc);
 int
  xmlValidateElementDecl (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
                           xmlElementPtr elem);
 xmlChar *
  xmlValidNormalizeAttributeValue(xmlDocPtr doc,
      xmlNodePtr elem,
      const xmlChar *name,
      const xmlChar *value);
 xmlChar *
  xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr elem,
      const xmlChar *name,
      const xmlChar *value);
 int
  xmlValidateAttributeDecl(xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
                           xmlAttributePtr attr);
 int
  xmlValidateAttributeValue(xmlAttributeType type,
      const xmlChar *value);
 int
  xmlValidateNotationDecl (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
                           xmlNotationPtr nota);
 int
  xmlValidateDtd (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlDtdPtr dtd);
 int
  xmlValidateDtdFinal (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc);
 int
  xmlValidateDocument (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc);
 int
  xmlValidateElement (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr elem);
 int
  xmlValidateOneElement (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
                           xmlNodePtr elem);
 int
  xmlValidateOneAttribute (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr elem,
      xmlAttrPtr attr,
      const xmlChar *value);
 int
  xmlValidateOneNamespace (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr elem,
      const xmlChar *prefix,
      xmlNsPtr ns,
      const xmlChar *value);
 int
  xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt,
      xmlDocPtr doc);



 int
  xmlValidateNotationUse (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
      const xmlChar *notationName);


 int
  xmlIsMixedElement (xmlDocPtr doc,
      const xmlChar *name);
 xmlAttributePtr
  xmlGetDtdAttrDesc (xmlDtdPtr dtd,
      const xmlChar *elem,
      const xmlChar *name);
 xmlAttributePtr
  xmlGetDtdQAttrDesc (xmlDtdPtr dtd,
      const xmlChar *elem,
      const xmlChar *name,
      const xmlChar *prefix);
 xmlNotationPtr
  xmlGetDtdNotationDesc (xmlDtdPtr dtd,
      const xmlChar *name);
 xmlElementPtr
  xmlGetDtdQElementDesc (xmlDtdPtr dtd,
      const xmlChar *name,
      const xmlChar *prefix);
 xmlElementPtr
  xmlGetDtdElementDesc (xmlDtdPtr dtd,
      const xmlChar *name);



 int
  xmlValidGetPotentialChildren(xmlElementContent *ctree,
      const xmlChar **names,
      int *len,
      int max);

 int
  xmlValidGetValidElements(xmlNode *prev,
      xmlNode *next,
      const xmlChar **names,
      int max);
 int
  xmlValidateNameValue (const xmlChar *value);
 int
  xmlValidateNamesValue (const xmlChar *value);
 int
  xmlValidateNmtokenValue (const xmlChar *value);
 int
  xmlValidateNmtokensValue(const xmlChar *value);





 int
  xmlValidBuildContentModel(xmlValidCtxtPtr ctxt,
      xmlElementPtr elem);

 int
  xmlValidatePushElement (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr elem,
      const xmlChar *qname);
 int
  xmlValidatePushCData (xmlValidCtxtPtr ctxt,
      const xmlChar *data,
      int len);
 int
  xmlValidatePopElement (xmlValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr elem,
      const xmlChar *qname);
# 20 "./include/libxml/parser.h" 2
# 1 "./include/libxml/entities.h" 1
# 24 "./include/libxml/entities.h"
typedef enum {
    XML_INTERNAL_GENERAL_ENTITY = 1,
    XML_EXTERNAL_GENERAL_PARSED_ENTITY = 2,
    XML_EXTERNAL_GENERAL_UNPARSED_ENTITY = 3,
    XML_INTERNAL_PARAMETER_ENTITY = 4,
    XML_EXTERNAL_PARAMETER_ENTITY = 5,
    XML_INTERNAL_PREDEFINED_ENTITY = 6
} xmlEntityType;






struct _xmlEntity {
    void *_private;
    xmlElementType type;
    const xmlChar *name;
    struct _xmlNode *children;
    struct _xmlNode *last;
    struct _xmlDtd *parent;
    struct _xmlNode *next;
    struct _xmlNode *prev;
    struct _xmlDoc *doc;

    xmlChar *orig;
    xmlChar *content;
    int length;
    xmlEntityType etype;
    const xmlChar *ExternalID;
    const xmlChar *SystemID;

    struct _xmlEntity *nexte;
    const xmlChar *URI;
    int owner;
    int checked;


};






typedef struct _xmlHashTable xmlEntitiesTable;
typedef xmlEntitiesTable *xmlEntitiesTablePtr;






 void
  xmlInitializePredefinedEntities (void);


 xmlEntityPtr
   xmlNewEntity (xmlDocPtr doc,
       const xmlChar *name,
       int type,
       const xmlChar *ExternalID,
       const xmlChar *SystemID,
       const xmlChar *content);
 xmlEntityPtr
   xmlAddDocEntity (xmlDocPtr doc,
       const xmlChar *name,
       int type,
       const xmlChar *ExternalID,
       const xmlChar *SystemID,
       const xmlChar *content);
 xmlEntityPtr
   xmlAddDtdEntity (xmlDocPtr doc,
       const xmlChar *name,
       int type,
       const xmlChar *ExternalID,
       const xmlChar *SystemID,
       const xmlChar *content);
 xmlEntityPtr
   xmlGetPredefinedEntity (const xmlChar *name);
 xmlEntityPtr
   xmlGetDocEntity (xmlDocPtr doc,
       const xmlChar *name);
 xmlEntityPtr
   xmlGetDtdEntity (xmlDocPtr doc,
       const xmlChar *name);
 xmlEntityPtr
   xmlGetParameterEntity (xmlDocPtr doc,
       const xmlChar *name);

 const xmlChar *
   xmlEncodeEntities (xmlDocPtr doc,
       const xmlChar *input);

 xmlChar *
   xmlEncodeEntitiesReentrant(xmlDocPtr doc,
       const xmlChar *input);
 xmlChar *
   xmlEncodeSpecialChars (xmlDocPtr doc,
       const xmlChar *input);
 xmlEntitiesTablePtr
   xmlCreateEntitiesTable (void);

 xmlEntitiesTablePtr
   xmlCopyEntitiesTable (xmlEntitiesTablePtr table);

 void
   xmlFreeEntitiesTable (xmlEntitiesTablePtr table);

 void
   xmlDumpEntitiesTable (xmlBufferPtr buf,
       xmlEntitiesTablePtr table);
 void
   xmlDumpEntityDecl (xmlBufferPtr buf,
       xmlEntityPtr ent);


 void
   xmlCleanupPredefinedEntities(void);
# 21 "./include/libxml/parser.h" 2
# 1 "./include/libxml/xmlerror.h" 1
# 22 "./include/libxml/parser.h" 2
# 52 "./include/libxml/parser.h"
typedef void (* xmlParserInputDeallocate)(xmlChar *str);

struct _xmlParserInput {

    xmlParserInputBufferPtr buf;

    const char *filename;
    const char *directory;
    const xmlChar *base;
    const xmlChar *cur;
    const xmlChar *end;
    int length;
    int line;
    int col;





    unsigned long consumed;
    xmlParserInputDeallocate free;
    const xmlChar *encoding;
    const xmlChar *version;
    int standalone;
    int id;
};
# 86 "./include/libxml/parser.h"
typedef struct _xmlParserNodeInfo xmlParserNodeInfo;
typedef xmlParserNodeInfo *xmlParserNodeInfoPtr;

struct _xmlParserNodeInfo {
  const struct _xmlNode* node;

  unsigned long begin_pos;
  unsigned long begin_line;
  unsigned long end_pos;
  unsigned long end_line;
};

typedef struct _xmlParserNodeInfoSeq xmlParserNodeInfoSeq;
typedef xmlParserNodeInfoSeq *xmlParserNodeInfoSeqPtr;
struct _xmlParserNodeInfoSeq {
  unsigned long maximum;
  unsigned long length;
  xmlParserNodeInfo* buffer;
};







typedef enum {
    XML_PARSER_EOF = -1,
    XML_PARSER_START = 0,
    XML_PARSER_MISC,
    XML_PARSER_PI,
    XML_PARSER_DTD,
    XML_PARSER_PROLOG,
    XML_PARSER_COMMENT,
    XML_PARSER_START_TAG,
    XML_PARSER_CONTENT,
    XML_PARSER_CDATA_SECTION,
    XML_PARSER_END_TAG,
    XML_PARSER_ENTITY_DECL,
    XML_PARSER_ENTITY_VALUE,
    XML_PARSER_ATTRIBUTE_VALUE,
    XML_PARSER_SYSTEM_LITERAL,
    XML_PARSER_EPILOG,
    XML_PARSER_IGNORE,
    XML_PARSER_PUBLIC_LITERAL
} xmlParserInputState;
# 163 "./include/libxml/parser.h"
typedef enum {
    XML_PARSE_UNKNOWN = 0,
    XML_PARSE_DOM = 1,
    XML_PARSE_SAX = 2,
    XML_PARSE_PUSH_DOM = 3,
    XML_PARSE_PUSH_SAX = 4,
    XML_PARSE_READER = 5
} xmlParserMode;
# 184 "./include/libxml/parser.h"
struct _xmlParserCtxt {
    struct _xmlSAXHandler *sax;
    void *userData;
    xmlDocPtr myDoc;
    int wellFormed;
    int replaceEntities;
    const xmlChar *version;
    const xmlChar *encoding;
    int standalone;
    int html;





    xmlParserInputPtr input;
    int inputNr;
    int inputMax;
    xmlParserInputPtr *inputTab;


    xmlNodePtr node;
    int nodeNr;
    int nodeMax;
    xmlNodePtr *nodeTab;

    int record_info;
    xmlParserNodeInfoSeq node_seq;

    int errNo;

    int hasExternalSubset;
    int hasPErefs;
    int external;

    int valid;
    int validate;
    xmlValidCtxt vctxt;

    xmlParserInputState instate;
    int token;

    char *directory;


    const xmlChar *name;
    int nameNr;
    int nameMax;
    const xmlChar * *nameTab;

    long nbChars;
    long checkIndex;
    int keepBlanks;
    int disableSAX;
    int inSubset;
    const xmlChar * intSubName;
    xmlChar * extSubURI;
    xmlChar * extSubSystem;


    int * space;
    int spaceNr;
    int spaceMax;
    int * spaceTab;

    int depth;
    xmlParserInputPtr entity;
    int charset;

    int nodelen;
    int nodemem;
    int pedantic;
    void *_private;

    int loadsubset;
    int linenumbers;
    void *catalogs;
    int recovery;
    int progressive;
    xmlDictPtr dict;
    const xmlChar * *atts;
    int maxatts;
    int docdict;




    const xmlChar *str_xml;
    const xmlChar *str_xmlns;
    const xmlChar *str_xml_ns;




    int sax2;
    int nsNr;
    int nsMax;
    const xmlChar * *nsTab;
    int *attallocs;
    void * *pushTab;
    xmlHashTablePtr attsDefault;
    xmlHashTablePtr attsSpecial;
    int nsWellFormed;
    int options;




    int dictNames;
    int freeElemsNr;
    xmlNodePtr freeElems;
    int freeAttrsNr;
    xmlAttrPtr freeAttrs;




    xmlError lastError;
    xmlParserMode parseMode;
    unsigned long nbentities;
    unsigned long sizeentities;


    xmlParserNodeInfo *nodeInfo;
    int nodeInfoNr;
    int nodeInfoMax;
    xmlParserNodeInfo *nodeInfoTab;

    int input_id;
};






struct _xmlSAXLocator {
    const xmlChar *(*getPublicId)(void *ctx);
    const xmlChar *(*getSystemId)(void *ctx);
    int (*getLineNumber)(void *ctx);
    int (*getColumnNumber)(void *ctx);
};
# 349 "./include/libxml/parser.h"
typedef xmlParserInputPtr (*resolveEntitySAXFunc) (void *ctx,
    const xmlChar *publicId,
    const xmlChar *systemId);
# 361 "./include/libxml/parser.h"
typedef void (*internalSubsetSAXFunc) (void *ctx,
    const xmlChar *name,
    const xmlChar *ExternalID,
    const xmlChar *SystemID);
# 374 "./include/libxml/parser.h"
typedef void (*externalSubsetSAXFunc) (void *ctx,
    const xmlChar *name,
    const xmlChar *ExternalID,
    const xmlChar *SystemID);
# 387 "./include/libxml/parser.h"
typedef xmlEntityPtr (*getEntitySAXFunc) (void *ctx,
    const xmlChar *name);
# 398 "./include/libxml/parser.h"
typedef xmlEntityPtr (*getParameterEntitySAXFunc) (void *ctx,
    const xmlChar *name);
# 411 "./include/libxml/parser.h"
typedef void (*entityDeclSAXFunc) (void *ctx,
    const xmlChar *name,
    int type,
    const xmlChar *publicId,
    const xmlChar *systemId,
    xmlChar *content);
# 426 "./include/libxml/parser.h"
typedef void (*notationDeclSAXFunc)(void *ctx,
    const xmlChar *name,
    const xmlChar *publicId,
    const xmlChar *systemId);
# 442 "./include/libxml/parser.h"
typedef void (*attributeDeclSAXFunc)(void *ctx,
    const xmlChar *elem,
    const xmlChar *fullname,
    int type,
    int def,
    const xmlChar *defaultValue,
    xmlEnumerationPtr tree);
# 458 "./include/libxml/parser.h"
typedef void (*elementDeclSAXFunc)(void *ctx,
    const xmlChar *name,
    int type,
    xmlElementContentPtr content);
# 472 "./include/libxml/parser.h"
typedef void (*unparsedEntityDeclSAXFunc)(void *ctx,
    const xmlChar *name,
    const xmlChar *publicId,
    const xmlChar *systemId,
    const xmlChar *notationName);
# 485 "./include/libxml/parser.h"
typedef void (*setDocumentLocatorSAXFunc) (void *ctx,
    xmlSAXLocatorPtr loc);






typedef void (*startDocumentSAXFunc) (void *ctx);






typedef void (*endDocumentSAXFunc) (void *ctx);
# 509 "./include/libxml/parser.h"
typedef void (*startElementSAXFunc) (void *ctx,
    const xmlChar *name,
    const xmlChar **atts);







typedef void (*endElementSAXFunc) (void *ctx,
    const xmlChar *name);
# 532 "./include/libxml/parser.h"
typedef void (*attributeSAXFunc) (void *ctx,
    const xmlChar *name,
    const xmlChar *value);







typedef void (*referenceSAXFunc) (void *ctx,
    const xmlChar *name);
# 552 "./include/libxml/parser.h"
typedef void (*charactersSAXFunc) (void *ctx,
    const xmlChar *ch,
    int len);
# 564 "./include/libxml/parser.h"
typedef void (*ignorableWhitespaceSAXFunc) (void *ctx,
    const xmlChar *ch,
    int len);
# 575 "./include/libxml/parser.h"
typedef void (*processingInstructionSAXFunc) (void *ctx,
    const xmlChar *target,
    const xmlChar *data);







typedef void (*commentSAXFunc) (void *ctx,
    const xmlChar *value);
# 595 "./include/libxml/parser.h"
typedef void (*cdataBlockSAXFunc) (
                         void *ctx,
    const xmlChar *value,
    int len);
# 607 "./include/libxml/parser.h"
typedef void ( *warningSAXFunc) (void *ctx,
    const char *msg, ...) __attribute__((__format__(__printf__,2,3)));
# 617 "./include/libxml/parser.h"
typedef void ( *errorSAXFunc) (void *ctx,
    const char *msg, ...) __attribute__((__format__(__printf__,2,3)));
# 629 "./include/libxml/parser.h"
typedef void ( *fatalErrorSAXFunc) (void *ctx,
    const char *msg, ...) __attribute__((__format__(__printf__,2,3)));
# 639 "./include/libxml/parser.h"
typedef int (*isStandaloneSAXFunc) (void *ctx);
# 648 "./include/libxml/parser.h"
typedef int (*hasInternalSubsetSAXFunc) (void *ctx);
# 658 "./include/libxml/parser.h"
typedef int (*hasExternalSubsetSAXFunc) (void *ctx);
# 691 "./include/libxml/parser.h"
typedef void (*startElementNsSAX2Func) (void *ctx,
     const xmlChar *localname,
     const xmlChar *prefix,
     const xmlChar *URI,
     int nb_namespaces,
     const xmlChar **namespaces,
     int nb_attributes,
     int nb_defaulted,
     const xmlChar **attributes);
# 712 "./include/libxml/parser.h"
typedef void (*endElementNsSAX2Func) (void *ctx,
     const xmlChar *localname,
     const xmlChar *prefix,
     const xmlChar *URI);


struct _xmlSAXHandler {
    internalSubsetSAXFunc internalSubset;
    isStandaloneSAXFunc isStandalone;
    hasInternalSubsetSAXFunc hasInternalSubset;
    hasExternalSubsetSAXFunc hasExternalSubset;
    resolveEntitySAXFunc resolveEntity;
    getEntitySAXFunc getEntity;
    entityDeclSAXFunc entityDecl;
    notationDeclSAXFunc notationDecl;
    attributeDeclSAXFunc attributeDecl;
    elementDeclSAXFunc elementDecl;
    unparsedEntityDeclSAXFunc unparsedEntityDecl;
    setDocumentLocatorSAXFunc setDocumentLocator;
    startDocumentSAXFunc startDocument;
    endDocumentSAXFunc endDocument;
    startElementSAXFunc startElement;
    endElementSAXFunc endElement;
    referenceSAXFunc reference;
    charactersSAXFunc characters;
    ignorableWhitespaceSAXFunc ignorableWhitespace;
    processingInstructionSAXFunc processingInstruction;
    commentSAXFunc comment;
    warningSAXFunc warning;
    errorSAXFunc error;
    fatalErrorSAXFunc fatalError;
    getParameterEntitySAXFunc getParameterEntity;
    cdataBlockSAXFunc cdataBlock;
    externalSubsetSAXFunc externalSubset;
    unsigned int initialized;

    void *_private;
    startElementNsSAX2Func startElementNs;
    endElementNsSAX2Func endElementNs;
    xmlStructuredErrorFunc serror;
};




typedef struct _xmlSAXHandlerV1 xmlSAXHandlerV1;
typedef xmlSAXHandlerV1 *xmlSAXHandlerV1Ptr;
struct _xmlSAXHandlerV1 {
    internalSubsetSAXFunc internalSubset;
    isStandaloneSAXFunc isStandalone;
    hasInternalSubsetSAXFunc hasInternalSubset;
    hasExternalSubsetSAXFunc hasExternalSubset;
    resolveEntitySAXFunc resolveEntity;
    getEntitySAXFunc getEntity;
    entityDeclSAXFunc entityDecl;
    notationDeclSAXFunc notationDecl;
    attributeDeclSAXFunc attributeDecl;
    elementDeclSAXFunc elementDecl;
    unparsedEntityDeclSAXFunc unparsedEntityDecl;
    setDocumentLocatorSAXFunc setDocumentLocator;
    startDocumentSAXFunc startDocument;
    endDocumentSAXFunc endDocument;
    startElementSAXFunc startElement;
    endElementSAXFunc endElement;
    referenceSAXFunc reference;
    charactersSAXFunc characters;
    ignorableWhitespaceSAXFunc ignorableWhitespace;
    processingInstructionSAXFunc processingInstruction;
    commentSAXFunc comment;
    warningSAXFunc warning;
    errorSAXFunc error;
    fatalErrorSAXFunc fatalError;
    getParameterEntitySAXFunc getParameterEntity;
    cdataBlockSAXFunc cdataBlock;
    externalSubsetSAXFunc externalSubset;
    unsigned int initialized;
};
# 801 "./include/libxml/parser.h"
typedef xmlParserInputPtr (*xmlExternalEntityLoader) (const char *URL,
      const char *ID,
      xmlParserCtxtPtr context);





# 1 "./include/libxml/encoding.h" 1
# 28 "./include/libxml/encoding.h"
# 1 "/usr/include/iconv.h" 1 3 4
# 23 "/usr/include/iconv.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/iconv.h" 2 3 4






# 29 "/usr/include/iconv.h" 3 4
typedef void *iconv_t;







extern iconv_t iconv_open (const char *__tocode, const char *__fromcode);




extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
       size_t *__restrict __inbytesleft,
       char **__restrict __outbuf,
       size_t *__restrict __outbytesleft);





extern int iconv_close (iconv_t __cd);


# 29 "./include/libxml/encoding.h" 2
# 58 "./include/libxml/encoding.h"

# 58 "./include/libxml/encoding.h"
typedef enum {
    XML_CHAR_ENCODING_ERROR= -1,
    XML_CHAR_ENCODING_NONE= 0,
    XML_CHAR_ENCODING_UTF8= 1,
    XML_CHAR_ENCODING_UTF16LE= 2,
    XML_CHAR_ENCODING_UTF16BE= 3,
    XML_CHAR_ENCODING_UCS4LE= 4,
    XML_CHAR_ENCODING_UCS4BE= 5,
    XML_CHAR_ENCODING_EBCDIC= 6,
    XML_CHAR_ENCODING_UCS4_2143=7,
    XML_CHAR_ENCODING_UCS4_3412=8,
    XML_CHAR_ENCODING_UCS2= 9,
    XML_CHAR_ENCODING_8859_1= 10,
    XML_CHAR_ENCODING_8859_2= 11,
    XML_CHAR_ENCODING_8859_3= 12,
    XML_CHAR_ENCODING_8859_4= 13,
    XML_CHAR_ENCODING_8859_5= 14,
    XML_CHAR_ENCODING_8859_6= 15,
    XML_CHAR_ENCODING_8859_7= 16,
    XML_CHAR_ENCODING_8859_8= 17,
    XML_CHAR_ENCODING_8859_9= 18,
    XML_CHAR_ENCODING_2022_JP= 19,
    XML_CHAR_ENCODING_SHIFT_JIS=20,
    XML_CHAR_ENCODING_EUC_JP= 21,
    XML_CHAR_ENCODING_ASCII= 22
} xmlCharEncoding;
# 101 "./include/libxml/encoding.h"
typedef int (* xmlCharEncodingInputFunc)(unsigned char *out, int *outlen,
                                         const unsigned char *in, int *inlen);
# 123 "./include/libxml/encoding.h"
typedef int (* xmlCharEncodingOutputFunc)(unsigned char *out, int *outlen,
                                          const unsigned char *in, int *inlen);
# 139 "./include/libxml/encoding.h"
typedef struct _xmlCharEncodingHandler xmlCharEncodingHandler;
typedef xmlCharEncodingHandler *xmlCharEncodingHandlerPtr;
struct _xmlCharEncodingHandler {
    char *name;
    xmlCharEncodingInputFunc input;
    xmlCharEncodingOutputFunc output;

    iconv_t iconv_in;
    iconv_t iconv_out;





};
# 166 "./include/libxml/encoding.h"
 void
 xmlInitCharEncodingHandlers (void);
 void
 xmlCleanupCharEncodingHandlers (void);
 void
 xmlRegisterCharEncodingHandler (xmlCharEncodingHandlerPtr handler);
 xmlCharEncodingHandlerPtr
 xmlGetCharEncodingHandler (xmlCharEncoding enc);
 xmlCharEncodingHandlerPtr
 xmlFindCharEncodingHandler (const char *name);
 xmlCharEncodingHandlerPtr
 xmlNewCharEncodingHandler (const char *name,
      xmlCharEncodingInputFunc input,
      xmlCharEncodingOutputFunc output);




 int
 xmlAddEncodingAlias (const char *name,
      const char *alias);
 int
 xmlDelEncodingAlias (const char *alias);
 const char *
 xmlGetEncodingAlias (const char *alias);
 void
 xmlCleanupEncodingAliases (void);
 xmlCharEncoding
 xmlParseCharEncoding (const char *name);
 const char *
 xmlGetCharEncodingName (xmlCharEncoding enc);




 xmlCharEncoding
 xmlDetectCharEncoding (const unsigned char *in,
      int len);

 int
 xmlCharEncOutFunc (xmlCharEncodingHandler *handler,
      xmlBufferPtr out,
      xmlBufferPtr in);

 int
 xmlCharEncInFunc (xmlCharEncodingHandler *handler,
      xmlBufferPtr out,
      xmlBufferPtr in);
 int
 xmlCharEncFirstLine (xmlCharEncodingHandler *handler,
      xmlBufferPtr out,
      xmlBufferPtr in);
 int
 xmlCharEncCloseFunc (xmlCharEncodingHandler *handler);





 int
 UTF8Toisolat1 (unsigned char *out,
      int *outlen,
      const unsigned char *in,
      int *inlen);

 int
 isolat1ToUTF8 (unsigned char *out,
      int *outlen,
      const unsigned char *in,
      int *inlen);
# 810 "./include/libxml/parser.h" 2
# 1 "./include/libxml/xmlIO.h" 1
# 34 "./include/libxml/xmlIO.h"
typedef int ( *xmlInputMatchCallback) (char const *filename);
# 43 "./include/libxml/xmlIO.h"
typedef void * ( *xmlInputOpenCallback) (char const *filename);
# 54 "./include/libxml/xmlIO.h"
typedef int ( *xmlInputReadCallback) (void * context, char * buffer, int len);
# 63 "./include/libxml/xmlIO.h"
typedef int ( *xmlInputCloseCallback) (void * context);
# 80 "./include/libxml/xmlIO.h"
typedef int ( *xmlOutputMatchCallback) (char const *filename);
# 89 "./include/libxml/xmlIO.h"
typedef void * ( *xmlOutputOpenCallback) (char const *filename);
# 100 "./include/libxml/xmlIO.h"
typedef int ( *xmlOutputWriteCallback) (void * context, const char * buffer,
                                       int len);
# 110 "./include/libxml/xmlIO.h"
typedef int ( *xmlOutputCloseCallback) (void * context);






# 1 "./include/libxml/globals.h" 1
# 19 "./include/libxml/globals.h"
# 1 "./include/libxml/xmlerror.h" 1
# 20 "./include/libxml/globals.h" 2
# 1 "./include/libxml/SAX.h" 1
# 19 "./include/libxml/SAX.h"
# 1 "./include/libxml/xlink.h" 1
# 32 "./include/libxml/xlink.h"
typedef xmlChar *xlinkHRef;
typedef xmlChar *xlinkRole;
typedef xmlChar *xlinkTitle;

typedef enum {
    XLINK_TYPE_NONE = 0,
    XLINK_TYPE_SIMPLE,
    XLINK_TYPE_EXTENDED,
    XLINK_TYPE_EXTENDED_SET
} xlinkType;

typedef enum {
    XLINK_SHOW_NONE = 0,
    XLINK_SHOW_NEW,
    XLINK_SHOW_EMBED,
    XLINK_SHOW_REPLACE
} xlinkShow;

typedef enum {
    XLINK_ACTUATE_NONE = 0,
    XLINK_ACTUATE_AUTO,
    XLINK_ACTUATE_ONREQUEST
} xlinkActuate;
# 64 "./include/libxml/xlink.h"
typedef void (*xlinkNodeDetectFunc) (void *ctx, xmlNodePtr node);
# 81 "./include/libxml/xlink.h"
typedef void
(*xlinkSimpleLinkFunk) (void *ctx,
    xmlNodePtr node,
    const xlinkHRef href,
    const xlinkRole role,
    const xlinkTitle title);
# 106 "./include/libxml/xlink.h"
typedef void
(*xlinkExtendedLinkFunk)(void *ctx,
    xmlNodePtr node,
    int nbLocators,
    const xlinkHRef *hrefs,
    const xlinkRole *roles,
    int nbArcs,
    const xlinkRole *from,
    const xlinkRole *to,
    xlinkShow *show,
    xlinkActuate *actuate,
    int nbTitles,
    const xlinkTitle *titles,
    const xmlChar **langs);
# 134 "./include/libxml/xlink.h"
typedef void
(*xlinkExtendedLinkSetFunk) (void *ctx,
     xmlNodePtr node,
     int nbLocators,
     const xlinkHRef *hrefs,
     const xlinkRole *roles,
     int nbTitles,
     const xlinkTitle *titles,
     const xmlChar **langs);







typedef struct _xlinkHandler xlinkHandler;
typedef xlinkHandler *xlinkHandlerPtr;
struct _xlinkHandler {
    xlinkSimpleLinkFunk simple;
    xlinkExtendedLinkFunk extended;
    xlinkExtendedLinkSetFunk set;
};






 xlinkNodeDetectFunc
  xlinkGetDefaultDetect (void);
 void
  xlinkSetDefaultDetect (xlinkNodeDetectFunc func);




 xlinkHandlerPtr
  xlinkGetDefaultHandler (void);
 void
  xlinkSetDefaultHandler (xlinkHandlerPtr handler);




 xlinkType
  xlinkIsLink (xmlDocPtr doc,
      xmlNodePtr node);
# 20 "./include/libxml/SAX.h" 2






 const xmlChar *
  getPublicId (void *ctx);
 const xmlChar *
  getSystemId (void *ctx);
 void
  setDocumentLocator (void *ctx,
       xmlSAXLocatorPtr loc);

 int
  getLineNumber (void *ctx);
 int
  getColumnNumber (void *ctx);

 int
  isStandalone (void *ctx);
 int
  hasInternalSubset (void *ctx);
 int
  hasExternalSubset (void *ctx);

 void
  internalSubset (void *ctx,
       const xmlChar *name,
       const xmlChar *ExternalID,
       const xmlChar *SystemID);
 void
  externalSubset (void *ctx,
       const xmlChar *name,
       const xmlChar *ExternalID,
       const xmlChar *SystemID);
 xmlEntityPtr
  getEntity (void *ctx,
       const xmlChar *name);
 xmlEntityPtr
  getParameterEntity (void *ctx,
       const xmlChar *name);
 xmlParserInputPtr
  resolveEntity (void *ctx,
       const xmlChar *publicId,
       const xmlChar *systemId);

 void
  entityDecl (void *ctx,
       const xmlChar *name,
       int type,
       const xmlChar *publicId,
       const xmlChar *systemId,
       xmlChar *content);
 void
  attributeDecl (void *ctx,
       const xmlChar *elem,
       const xmlChar *fullname,
       int type,
       int def,
       const xmlChar *defaultValue,
       xmlEnumerationPtr tree);
 void
  elementDecl (void *ctx,
       const xmlChar *name,
       int type,
       xmlElementContentPtr content);
 void
  notationDecl (void *ctx,
       const xmlChar *name,
       const xmlChar *publicId,
       const xmlChar *systemId);
 void
  unparsedEntityDecl (void *ctx,
       const xmlChar *name,
       const xmlChar *publicId,
       const xmlChar *systemId,
       const xmlChar *notationName);

 void
  startDocument (void *ctx);
 void
  endDocument (void *ctx);
 void
  attribute (void *ctx,
       const xmlChar *fullname,
       const xmlChar *value);
 void
  startElement (void *ctx,
       const xmlChar *fullname,
       const xmlChar **atts);
 void
  endElement (void *ctx,
       const xmlChar *name);
 void
  reference (void *ctx,
       const xmlChar *name);
 void
  characters (void *ctx,
       const xmlChar *ch,
       int len);
 void
  ignorableWhitespace (void *ctx,
       const xmlChar *ch,
       int len);
 void
  processingInstruction (void *ctx,
       const xmlChar *target,
       const xmlChar *data);
 void
  globalNamespace (void *ctx,
       const xmlChar *href,
       const xmlChar *prefix);
 void
  setNamespace (void *ctx,
       const xmlChar *name);
 xmlNsPtr
  getNamespace (void *ctx);
 int
  checkNamespace (void *ctx,
       xmlChar *nameSpace);
 void
  namespaceDecl (void *ctx,
       const xmlChar *href,
       const xmlChar *prefix);
 void
  comment (void *ctx,
       const xmlChar *value);
 void
  cdataBlock (void *ctx,
       const xmlChar *value,
       int len);


 void
  initxmlDefaultSAXHandler (xmlSAXHandlerV1 *hdlr,
       int warning);

 void
  inithtmlDefaultSAXHandler (xmlSAXHandlerV1 *hdlr);


 void
  initdocbDefaultSAXHandler (xmlSAXHandlerV1 *hdlr);
# 21 "./include/libxml/globals.h" 2
# 1 "./include/libxml/SAX2.h" 1
# 24 "./include/libxml/SAX2.h"
 const xmlChar *
  xmlSAX2GetPublicId (void *ctx);
 const xmlChar *
  xmlSAX2GetSystemId (void *ctx);
 void
  xmlSAX2SetDocumentLocator (void *ctx,
       xmlSAXLocatorPtr loc);

 int
  xmlSAX2GetLineNumber (void *ctx);
 int
  xmlSAX2GetColumnNumber (void *ctx);

 int
  xmlSAX2IsStandalone (void *ctx);
 int
  xmlSAX2HasInternalSubset (void *ctx);
 int
  xmlSAX2HasExternalSubset (void *ctx);

 void
  xmlSAX2InternalSubset (void *ctx,
       const xmlChar *name,
       const xmlChar *ExternalID,
       const xmlChar *SystemID);
 void
  xmlSAX2ExternalSubset (void *ctx,
       const xmlChar *name,
       const xmlChar *ExternalID,
       const xmlChar *SystemID);
 xmlEntityPtr
  xmlSAX2GetEntity (void *ctx,
       const xmlChar *name);
 xmlEntityPtr
  xmlSAX2GetParameterEntity (void *ctx,
       const xmlChar *name);
 xmlParserInputPtr
  xmlSAX2ResolveEntity (void *ctx,
       const xmlChar *publicId,
       const xmlChar *systemId);

 void
  xmlSAX2EntityDecl (void *ctx,
       const xmlChar *name,
       int type,
       const xmlChar *publicId,
       const xmlChar *systemId,
       xmlChar *content);
 void
  xmlSAX2AttributeDecl (void *ctx,
       const xmlChar *elem,
       const xmlChar *fullname,
       int type,
       int def,
       const xmlChar *defaultValue,
       xmlEnumerationPtr tree);
 void
  xmlSAX2ElementDecl (void *ctx,
       const xmlChar *name,
       int type,
       xmlElementContentPtr content);
 void
  xmlSAX2NotationDecl (void *ctx,
       const xmlChar *name,
       const xmlChar *publicId,
       const xmlChar *systemId);
 void
  xmlSAX2UnparsedEntityDecl (void *ctx,
       const xmlChar *name,
       const xmlChar *publicId,
       const xmlChar *systemId,
       const xmlChar *notationName);

 void
  xmlSAX2StartDocument (void *ctx);
 void
  xmlSAX2EndDocument (void *ctx);

 void
  xmlSAX2StartElement (void *ctx,
       const xmlChar *fullname,
       const xmlChar **atts);
 void
  xmlSAX2EndElement (void *ctx,
       const xmlChar *name);

 void
  xmlSAX2StartElementNs (void *ctx,
       const xmlChar *localname,
       const xmlChar *prefix,
       const xmlChar *URI,
       int nb_namespaces,
       const xmlChar **namespaces,
       int nb_attributes,
       int nb_defaulted,
       const xmlChar **attributes);
 void
  xmlSAX2EndElementNs (void *ctx,
       const xmlChar *localname,
       const xmlChar *prefix,
       const xmlChar *URI);
 void
  xmlSAX2Reference (void *ctx,
       const xmlChar *name);
 void
  xmlSAX2Characters (void *ctx,
       const xmlChar *ch,
       int len);
 void
  xmlSAX2IgnorableWhitespace (void *ctx,
       const xmlChar *ch,
       int len);
 void
  xmlSAX2ProcessingInstruction (void *ctx,
       const xmlChar *target,
       const xmlChar *data);
 void
  xmlSAX2Comment (void *ctx,
       const xmlChar *value);
 void
  xmlSAX2CDataBlock (void *ctx,
       const xmlChar *value,
       int len);


 int
  xmlSAXDefaultVersion (int version);


 int
  xmlSAXVersion (xmlSAXHandler *hdlr,
       int version);
 void
  xmlSAX2InitDefaultSAXHandler (xmlSAXHandler *hdlr,
       int warning);

 void
  xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr);
 void
  htmlDefaultSAXHandlerInit (void);


 void
  xmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr);
 void
  docbDefaultSAXHandlerInit (void);

 void
  xmlDefaultSAXHandlerInit (void);
# 22 "./include/libxml/globals.h" 2
# 1 "./include/libxml/xmlmemory.h" 1
# 57 "./include/libxml/xmlmemory.h"
typedef void ( *xmlFreeFunc)(void *mem);
# 66 "./include/libxml/xmlmemory.h"
typedef void *(__attribute__((alloc_size(1))) *xmlMallocFunc)(size_t size);
# 77 "./include/libxml/xmlmemory.h"
typedef void *( *xmlReallocFunc)(void *mem, size_t size);
# 87 "./include/libxml/xmlmemory.h"
typedef char *( *xmlStrdupFunc)(const char *str);
# 103 "./include/libxml/xmlmemory.h"
 int
 xmlMemSetup (xmlFreeFunc freeFunc,
    xmlMallocFunc mallocFunc,
    xmlReallocFunc reallocFunc,
    xmlStrdupFunc strdupFunc);
 int
 xmlMemGet (xmlFreeFunc *freeFunc,
    xmlMallocFunc *mallocFunc,
    xmlReallocFunc *reallocFunc,
    xmlStrdupFunc *strdupFunc);
 int
 xmlGcMemSetup (xmlFreeFunc freeFunc,
    xmlMallocFunc mallocFunc,
    xmlMallocFunc mallocAtomicFunc,
    xmlReallocFunc reallocFunc,
    xmlStrdupFunc strdupFunc);
 int
 xmlGcMemGet (xmlFreeFunc *freeFunc,
    xmlMallocFunc *mallocFunc,
    xmlMallocFunc *mallocAtomicFunc,
    xmlReallocFunc *reallocFunc,
    xmlStrdupFunc *strdupFunc);




 int
 xmlInitMemory (void);




 void
                xmlCleanupMemory (void);



 int
 xmlMemUsed (void);
 int
 xmlMemBlocks (void);
 void
 xmlMemDisplay (FILE *fp);
 void
 xmlMemDisplayLast(FILE *fp, long nbBytes);
 void
 xmlMemShow (FILE *fp, int nr);
 void
 xmlMemoryDump (void);
 void *
 xmlMemMalloc (size_t size) __attribute__((alloc_size(1)));
 void *
 xmlMemRealloc (void *ptr,size_t size);
 void
 xmlMemFree (void *ptr);
 char *
 xmlMemoryStrdup (const char *str);
 void *
 xmlMallocLoc (size_t size, const char *file, int line) __attribute__((alloc_size(1)));
 void *
 xmlReallocLoc (void *ptr, size_t size, const char *file, int line);
 void *
 xmlMallocAtomicLoc (size_t size, const char *file, int line) __attribute__((alloc_size(1)));
 char *
 xmlMemStrdupLoc (const char *str, const char *file, int line);
# 23 "./include/libxml/globals.h" 2





 void xmlInitGlobals(void);
 void xmlCleanupGlobals(void);
# 42 "./include/libxml/globals.h"
typedef xmlParserInputBufferPtr (*xmlParserInputBufferCreateFilenameFunc) (const char *URI, xmlCharEncoding enc);
# 55 "./include/libxml/globals.h"
typedef xmlOutputBufferPtr (*xmlOutputBufferCreateFilenameFunc) (const char *URI, xmlCharEncodingHandlerPtr encoder, int compression);

 xmlParserInputBufferCreateFilenameFunc
 xmlParserInputBufferCreateFilenameDefault (xmlParserInputBufferCreateFilenameFunc func);
 xmlOutputBufferCreateFilenameFunc
 xmlOutputBufferCreateFilenameDefault (xmlOutputBufferCreateFilenameFunc func);
# 107 "./include/libxml/globals.h"
typedef void (*xmlRegisterNodeFunc) (xmlNodePtr node);






typedef void (*xmlDeregisterNodeFunc) (xmlNodePtr node);

typedef struct _xmlGlobalState xmlGlobalState;
typedef xmlGlobalState *xmlGlobalStatePtr;
struct _xmlGlobalState
{
 const char *xmlParserVersion;

 xmlSAXLocator xmlDefaultSAXLocator;
 xmlSAXHandlerV1 xmlDefaultSAXHandler;
 xmlSAXHandlerV1 docbDefaultSAXHandler;
 xmlSAXHandlerV1 htmlDefaultSAXHandler;

 xmlFreeFunc xmlFree;
 xmlMallocFunc xmlMalloc;
 xmlStrdupFunc xmlMemStrdup;
 xmlReallocFunc xmlRealloc;

 xmlGenericErrorFunc xmlGenericError;
 xmlStructuredErrorFunc xmlStructuredError;
 void *xmlGenericErrorContext;

 int oldXMLWDcompatibility;

 xmlBufferAllocationScheme xmlBufferAllocScheme;
 int xmlDefaultBufferSize;

 int xmlSubstituteEntitiesDefaultValue;
 int xmlDoValidityCheckingDefaultValue;
 int xmlGetWarningsDefaultValue;
 int xmlKeepBlanksDefaultValue;
 int xmlLineNumbersDefaultValue;
 int xmlLoadExtDtdDefaultValue;
 int xmlParserDebugEntities;
 int xmlPedanticParserDefaultValue;

 int xmlSaveNoEmptyTags;
 int xmlIndentTreeOutput;
 const char *xmlTreeIndentString;

 xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;
 xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;

 xmlMallocFunc xmlMallocAtomic;
 xmlError xmlLastError;

 xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;
 xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;

 void *xmlStructuredErrorContext;
};




# 1 "./include/libxml/threads.h" 1
# 23 "./include/libxml/threads.h"
typedef struct _xmlMutex xmlMutex;
typedef xmlMutex *xmlMutexPtr;




typedef struct _xmlRMutex xmlRMutex;
typedef xmlRMutex *xmlRMutexPtr;




# 1 "./include/libxml/globals.h" 1
# 36 "./include/libxml/threads.h" 2



 xmlMutexPtr
   xmlNewMutex (void);
 void
   xmlMutexLock (xmlMutexPtr tok);
 void
   xmlMutexUnlock (xmlMutexPtr tok);
 void
   xmlFreeMutex (xmlMutexPtr tok);

 xmlRMutexPtr
   xmlNewRMutex (void);
 void
   xmlRMutexLock (xmlRMutexPtr tok);
 void
   xmlRMutexUnlock (xmlRMutexPtr tok);
 void
   xmlFreeRMutex (xmlRMutexPtr tok);




 void
   xmlInitThreads (void);
 void
   xmlLockLibrary (void);
 void
   xmlUnlockLibrary(void);
 int
   xmlGetThreadId (void);
 int
   xmlIsMainThread (void);
 void
   xmlCleanupThreads(void);
 xmlGlobalStatePtr
   xmlGetGlobalState(void);
# 170 "./include/libxml/globals.h" 2




 void xmlInitializeGlobalState(xmlGlobalStatePtr gs);

 void xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler);

 void xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler);

 xmlRegisterNodeFunc xmlRegisterNodeDefault(xmlRegisterNodeFunc func);
 xmlRegisterNodeFunc xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func);
 xmlDeregisterNodeFunc xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func);
 xmlDeregisterNodeFunc xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func);

 xmlOutputBufferCreateFilenameFunc
 xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func);
 xmlParserInputBufferCreateFilenameFunc
 xmlThrDefParserInputBufferCreateFilenameDefault(xmlParserInputBufferCreateFilenameFunc func);
# 243 "./include/libxml/globals.h"
extern xmlMallocFunc xmlMalloc;
extern xmlMallocFunc xmlMallocAtomic;
extern xmlReallocFunc xmlRealloc;
extern xmlFreeFunc xmlFree;
extern xmlStrdupFunc xmlMemStrdup;



 xmlSAXHandlerV1 * __docbDefaultSAXHandler(void);
# 261 "./include/libxml/globals.h"
 xmlSAXHandlerV1 * __htmlDefaultSAXHandler(void);
# 270 "./include/libxml/globals.h"
 xmlError * __xmlLastError(void);
# 285 "./include/libxml/globals.h"
 int * __oldXMLWDcompatibility(void);







 xmlBufferAllocationScheme * __xmlBufferAllocScheme(void);






 xmlBufferAllocationScheme xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v);

 int * __xmlDefaultBufferSize(void);






 int xmlThrDefDefaultBufferSize(int v);

 xmlSAXHandlerV1 * __xmlDefaultSAXHandler(void);







 xmlSAXLocator * __xmlDefaultSAXLocator(void);







 int * __xmlDoValidityCheckingDefaultValue(void);






 int xmlThrDefDoValidityCheckingDefaultValue(int v);

 xmlGenericErrorFunc * __xmlGenericError(void);







 xmlStructuredErrorFunc * __xmlStructuredError(void);







 void * * __xmlGenericErrorContext(void);







 void * * __xmlStructuredErrorContext(void);







 int * __xmlGetWarningsDefaultValue(void);






 int xmlThrDefGetWarningsDefaultValue(int v);

 int * __xmlIndentTreeOutput(void);






 int xmlThrDefIndentTreeOutput(int v);

 const char * * __xmlTreeIndentString(void);






 const char * xmlThrDefTreeIndentString(const char * v);

 int * __xmlKeepBlanksDefaultValue(void);






 int xmlThrDefKeepBlanksDefaultValue(int v);

 int * __xmlLineNumbersDefaultValue(void);






 int xmlThrDefLineNumbersDefaultValue(int v);

 int * __xmlLoadExtDtdDefaultValue(void);






 int xmlThrDefLoadExtDtdDefaultValue(int v);

 int * __xmlParserDebugEntities(void);






 int xmlThrDefParserDebugEntities(int v);

 const char * * __xmlParserVersion(void);







 int * __xmlPedanticParserDefaultValue(void);






 int xmlThrDefPedanticParserDefaultValue(int v);

 int * __xmlSaveNoEmptyTags(void);






 int xmlThrDefSaveNoEmptyTags(int v);

 int * __xmlSubstituteEntitiesDefaultValue(void);






 int xmlThrDefSubstituteEntitiesDefaultValue(int v);

 xmlRegisterNodeFunc * __xmlRegisterNodeDefaultValue(void);







 xmlDeregisterNodeFunc * __xmlDeregisterNodeDefaultValue(void);







 xmlParserInputBufferCreateFilenameFunc * __xmlParserInputBufferCreateFilenameValue(void);







 xmlOutputBufferCreateFilenameFunc * __xmlOutputBufferCreateFilenameValue(void);
# 118 "./include/libxml/xmlIO.h" 2







struct _xmlParserInputBuffer {
    void* context;
    xmlInputReadCallback readcallback;
    xmlInputCloseCallback closecallback;

    xmlCharEncodingHandlerPtr encoder;

    xmlBufPtr buffer;
    xmlBufPtr raw;
    int compressed;
    int error;
    unsigned long rawconsumed;
};



struct _xmlOutputBuffer {
    void* context;
    xmlOutputWriteCallback writecallback;
    xmlOutputCloseCallback closecallback;

    xmlCharEncodingHandlerPtr encoder;

    xmlBufPtr buffer;
    xmlBufPtr conv;
    int written;
    int error;
};





 void
 xmlCleanupInputCallbacks (void);

 int
 xmlPopInputCallbacks (void);

 void
 xmlRegisterDefaultInputCallbacks (void);
 xmlParserInputBufferPtr
 xmlAllocParserInputBuffer (xmlCharEncoding enc);

 xmlParserInputBufferPtr
 xmlParserInputBufferCreateFilename (const char *URI,
                                                 xmlCharEncoding enc);
 xmlParserInputBufferPtr
 xmlParserInputBufferCreateFile (FILE *file,
                                                 xmlCharEncoding enc);
 xmlParserInputBufferPtr
 xmlParserInputBufferCreateFd (int fd,
                                          xmlCharEncoding enc);
 xmlParserInputBufferPtr
 xmlParserInputBufferCreateMem (const char *mem, int size,
                                          xmlCharEncoding enc);
 xmlParserInputBufferPtr
 xmlParserInputBufferCreateStatic (const char *mem, int size,
                                          xmlCharEncoding enc);
 xmlParserInputBufferPtr
 xmlParserInputBufferCreateIO (xmlInputReadCallback ioread,
       xmlInputCloseCallback ioclose,
       void *ioctx,
                                          xmlCharEncoding enc);
 int
 xmlParserInputBufferRead (xmlParserInputBufferPtr in,
       int len);
 int
 xmlParserInputBufferGrow (xmlParserInputBufferPtr in,
       int len);
 int
 xmlParserInputBufferPush (xmlParserInputBufferPtr in,
       int len,
       const char *buf);
 void
 xmlFreeParserInputBuffer (xmlParserInputBufferPtr in);
 char *
 xmlParserGetDirectory (const char *filename);

 int
 xmlRegisterInputCallbacks (xmlInputMatchCallback matchFunc,
       xmlInputOpenCallback openFunc,
       xmlInputReadCallback readFunc,
       xmlInputCloseCallback closeFunc);

xmlParserInputBufferPtr
 __xmlParserInputBufferCreateFilename(const char *URI,
          xmlCharEncoding enc);





 void
 xmlCleanupOutputCallbacks (void);
 void
 xmlRegisterDefaultOutputCallbacks(void);
 xmlOutputBufferPtr
 xmlAllocOutputBuffer (xmlCharEncodingHandlerPtr encoder);

 xmlOutputBufferPtr
 xmlOutputBufferCreateFilename (const char *URI,
      xmlCharEncodingHandlerPtr encoder,
      int compression);

 xmlOutputBufferPtr
 xmlOutputBufferCreateFile (FILE *file,
      xmlCharEncodingHandlerPtr encoder);

 xmlOutputBufferPtr
 xmlOutputBufferCreateBuffer (xmlBufferPtr buffer,
      xmlCharEncodingHandlerPtr encoder);

 xmlOutputBufferPtr
 xmlOutputBufferCreateFd (int fd,
      xmlCharEncodingHandlerPtr encoder);

 xmlOutputBufferPtr
 xmlOutputBufferCreateIO (xmlOutputWriteCallback iowrite,
      xmlOutputCloseCallback ioclose,
      void *ioctx,
      xmlCharEncodingHandlerPtr encoder);


 const xmlChar *
        xmlOutputBufferGetContent (xmlOutputBufferPtr out);
 size_t
        xmlOutputBufferGetSize (xmlOutputBufferPtr out);

 int
 xmlOutputBufferWrite (xmlOutputBufferPtr out,
      int len,
      const char *buf);
 int
 xmlOutputBufferWriteString (xmlOutputBufferPtr out,
      const char *str);
 int
 xmlOutputBufferWriteEscape (xmlOutputBufferPtr out,
      const xmlChar *str,
      xmlCharEncodingOutputFunc escaping);

 int
 xmlOutputBufferFlush (xmlOutputBufferPtr out);
 int
 xmlOutputBufferClose (xmlOutputBufferPtr out);

 int
 xmlRegisterOutputCallbacks (xmlOutputMatchCallback matchFunc,
      xmlOutputOpenCallback openFunc,
      xmlOutputWriteCallback writeFunc,
      xmlOutputCloseCallback closeFunc);

xmlOutputBufferPtr
 __xmlOutputBufferCreateFilename(const char *URI,
                              xmlCharEncodingHandlerPtr encoder,
                              int compression);



 void
 xmlRegisterHTTPPostCallbacks (void );




 xmlParserInputPtr
 xmlCheckHTTPInput (xmlParserCtxtPtr ctxt,
      xmlParserInputPtr ret);




 xmlParserInputPtr
 xmlNoNetExternalEntityLoader (const char *URL,
      const char *ID,
      xmlParserCtxtPtr ctxt);





 xmlChar *
 xmlNormalizeWindowsPath (const xmlChar *path);

 int
 xmlCheckFilename (const char *path);



 int
 xmlFileMatch (const char *filename);
 void *
 xmlFileOpen (const char *filename);
 int
 xmlFileRead (void * context,
      char * buffer,
      int len);
 int
 xmlFileClose (void * context);





 int
 xmlIOHTTPMatch (const char *filename);
 void *
 xmlIOHTTPOpen (const char *filename);

 void *
 xmlIOHTTPOpenW (const char * post_uri,
      int compression );

 int
 xmlIOHTTPRead (void * context,
      char * buffer,
      int len);
 int
 xmlIOHTTPClose (void * context);






 int
 xmlIOFTPMatch (const char *filename);
 void *
 xmlIOFTPOpen (const char *filename);
 int
 xmlIOFTPRead (void * context,
      char * buffer,
      int len);
 int
 xmlIOFTPClose (void * context);
# 811 "./include/libxml/parser.h" 2
# 821 "./include/libxml/parser.h"
 void
  xmlInitParser (void);
 void
  xmlCleanupParser (void);




 int
  xmlParserInputRead (xmlParserInputPtr in,
      int len);
 int
  xmlParserInputGrow (xmlParserInputPtr in,
      int len);





 xmlDocPtr
  xmlParseDoc (const xmlChar *cur);
 xmlDocPtr
  xmlParseFile (const char *filename);
 xmlDocPtr
  xmlParseMemory (const char *buffer,
      int size);

 int
  xmlSubstituteEntitiesDefault(int val);
 int
  xmlKeepBlanksDefault (int val);
 void
  xmlStopParser (xmlParserCtxtPtr ctxt);
 int
  xmlPedanticParserDefault(int val);
 int
  xmlLineNumbersDefault (int val);





 xmlDocPtr
  xmlRecoverDoc (const xmlChar *cur);
 xmlDocPtr
  xmlRecoverMemory (const char *buffer,
      int size);
 xmlDocPtr
  xmlRecoverFile (const char *filename);





 int
  xmlParseDocument (xmlParserCtxtPtr ctxt);
 int
  xmlParseExtParsedEnt (xmlParserCtxtPtr ctxt);

 int
  xmlSAXUserParseFile (xmlSAXHandlerPtr sax,
      void *user_data,
      const char *filename);
 int
  xmlSAXUserParseMemory (xmlSAXHandlerPtr sax,
      void *user_data,
      const char *buffer,
      int size);
 xmlDocPtr
  xmlSAXParseDoc (xmlSAXHandlerPtr sax,
      const xmlChar *cur,
      int recovery);
 xmlDocPtr
  xmlSAXParseMemory (xmlSAXHandlerPtr sax,
      const char *buffer,
      int size,
      int recovery);
 xmlDocPtr
  xmlSAXParseMemoryWithData (xmlSAXHandlerPtr sax,
      const char *buffer,
      int size,
      int recovery,
      void *data);
 xmlDocPtr
  xmlSAXParseFile (xmlSAXHandlerPtr sax,
      const char *filename,
      int recovery);
 xmlDocPtr
  xmlSAXParseFileWithData (xmlSAXHandlerPtr sax,
      const char *filename,
      int recovery,
      void *data);
 xmlDocPtr
  xmlSAXParseEntity (xmlSAXHandlerPtr sax,
      const char *filename);
 xmlDocPtr
  xmlParseEntity (const char *filename);



 xmlDtdPtr
  xmlSAXParseDTD (xmlSAXHandlerPtr sax,
      const xmlChar *ExternalID,
      const xmlChar *SystemID);
 xmlDtdPtr
  xmlParseDTD (const xmlChar *ExternalID,
      const xmlChar *SystemID);
 xmlDtdPtr
  xmlIOParseDTD (xmlSAXHandlerPtr sax,
      xmlParserInputBufferPtr input,
      xmlCharEncoding enc);


 int
  xmlParseBalancedChunkMemory(xmlDocPtr doc,
      xmlSAXHandlerPtr sax,
      void *user_data,
      int depth,
      const xmlChar *string,
      xmlNodePtr *lst);

 xmlParserErrors
  xmlParseInNodeContext (xmlNodePtr node,
      const char *data,
      int datalen,
      int options,
      xmlNodePtr *lst);

 int
  xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc,
                     xmlSAXHandlerPtr sax,
                     void *user_data,
                     int depth,
                     const xmlChar *string,
                     xmlNodePtr *lst,
                     int recover);
 int
  xmlParseExternalEntity (xmlDocPtr doc,
      xmlSAXHandlerPtr sax,
      void *user_data,
      int depth,
      const xmlChar *URL,
      const xmlChar *ID,
      xmlNodePtr *lst);

 int
  xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx,
      const xmlChar *URL,
      const xmlChar *ID,
      xmlNodePtr *lst);




 xmlParserCtxtPtr
  xmlNewParserCtxt (void);
 int
  xmlInitParserCtxt (xmlParserCtxtPtr ctxt);
 void
  xmlClearParserCtxt (xmlParserCtxtPtr ctxt);
 void
  xmlFreeParserCtxt (xmlParserCtxtPtr ctxt);

 void
  xmlSetupParserForBuffer (xmlParserCtxtPtr ctxt,
      const xmlChar* buffer,
      const char *filename);

 xmlParserCtxtPtr
  xmlCreateDocParserCtxt (const xmlChar *cur);





 int
  xmlGetFeaturesList (int *len,
      const char **result);
 int
  xmlGetFeature (xmlParserCtxtPtr ctxt,
      const char *name,
      void *result);
 int
  xmlSetFeature (xmlParserCtxtPtr ctxt,
      const char *name,
      void *value);






 xmlParserCtxtPtr
  xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax,
      void *user_data,
      const char *chunk,
      int size,
      const char *filename);
 int
  xmlParseChunk (xmlParserCtxtPtr ctxt,
      const char *chunk,
      int size,
      int terminate);






 xmlParserCtxtPtr
  xmlCreateIOParserCtxt (xmlSAXHandlerPtr sax,
      void *user_data,
      xmlInputReadCallback ioread,
      xmlInputCloseCallback ioclose,
      void *ioctx,
      xmlCharEncoding enc);

 xmlParserInputPtr
  xmlNewIOInputStream (xmlParserCtxtPtr ctxt,
      xmlParserInputBufferPtr input,
      xmlCharEncoding enc);




 const xmlParserNodeInfo*
  xmlParserFindNodeInfo (const xmlParserCtxtPtr ctxt,
             const xmlNodePtr node);
 void
  xmlInitNodeInfoSeq (xmlParserNodeInfoSeqPtr seq);
 void
  xmlClearNodeInfoSeq (xmlParserNodeInfoSeqPtr seq);
 unsigned long
  xmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq,
                                         const xmlNodePtr node);
 void
  xmlParserAddNodeInfo (xmlParserCtxtPtr ctxt,
      const xmlParserNodeInfoPtr info);





 void
  xmlSetExternalEntityLoader(xmlExternalEntityLoader f);
 xmlExternalEntityLoader
  xmlGetExternalEntityLoader(void);
 xmlParserInputPtr
  xmlLoadExternalEntity (const char *URL,
      const char *ID,
      xmlParserCtxtPtr ctxt);




 long
  xmlByteConsumed (xmlParserCtxtPtr ctxt);
# 1088 "./include/libxml/parser.h"
typedef enum {
    XML_PARSE_RECOVER = 1<<0,
    XML_PARSE_NOENT = 1<<1,
    XML_PARSE_DTDLOAD = 1<<2,
    XML_PARSE_DTDATTR = 1<<3,
    XML_PARSE_DTDVALID = 1<<4,
    XML_PARSE_NOERROR = 1<<5,
    XML_PARSE_NOWARNING = 1<<6,
    XML_PARSE_PEDANTIC = 1<<7,
    XML_PARSE_NOBLANKS = 1<<8,
    XML_PARSE_SAX1 = 1<<9,
    XML_PARSE_XINCLUDE = 1<<10,
    XML_PARSE_NONET = 1<<11,
    XML_PARSE_NODICT = 1<<12,
    XML_PARSE_NSCLEAN = 1<<13,
    XML_PARSE_NOCDATA = 1<<14,
    XML_PARSE_NOXINCNODE= 1<<15,
    XML_PARSE_COMPACT = 1<<16,


    XML_PARSE_OLD10 = 1<<17,
    XML_PARSE_NOBASEFIX = 1<<18,
    XML_PARSE_HUGE = 1<<19,
    XML_PARSE_OLDSAX = 1<<20,
    XML_PARSE_IGNORE_ENC= 1<<21,
    XML_PARSE_BIG_LINES = 1<<22
} xmlParserOption;

 void
  xmlCtxtReset (xmlParserCtxtPtr ctxt);
 int
  xmlCtxtResetPush (xmlParserCtxtPtr ctxt,
      const char *chunk,
      int size,
      const char *filename,
      const char *encoding);
 int
  xmlCtxtUseOptions (xmlParserCtxtPtr ctxt,
      int options);
 xmlDocPtr
  xmlReadDoc (const xmlChar *cur,
      const char *URL,
      const char *encoding,
      int options);
 xmlDocPtr
  xmlReadFile (const char *URL,
      const char *encoding,
      int options);
 xmlDocPtr
  xmlReadMemory (const char *buffer,
      int size,
      const char *URL,
      const char *encoding,
      int options);
 xmlDocPtr
  xmlReadFd (int fd,
      const char *URL,
      const char *encoding,
      int options);
 xmlDocPtr
  xmlReadIO (xmlInputReadCallback ioread,
      xmlInputCloseCallback ioclose,
      void *ioctx,
      const char *URL,
      const char *encoding,
      int options);
 xmlDocPtr
  xmlCtxtReadDoc (xmlParserCtxtPtr ctxt,
      const xmlChar *cur,
      const char *URL,
      const char *encoding,
      int options);
 xmlDocPtr
  xmlCtxtReadFile (xmlParserCtxtPtr ctxt,
      const char *filename,
      const char *encoding,
      int options);
 xmlDocPtr
  xmlCtxtReadMemory (xmlParserCtxtPtr ctxt,
      const char *buffer,
      int size,
      const char *URL,
      const char *encoding,
      int options);
 xmlDocPtr
  xmlCtxtReadFd (xmlParserCtxtPtr ctxt,
      int fd,
      const char *URL,
      const char *encoding,
      int options);
 xmlDocPtr
  xmlCtxtReadIO (xmlParserCtxtPtr ctxt,
      xmlInputReadCallback ioread,
      xmlInputCloseCallback ioclose,
      void *ioctx,
      const char *URL,
      const char *encoding,
      int options);
# 1197 "./include/libxml/parser.h"
typedef enum {
    XML_WITH_THREAD = 1,
    XML_WITH_TREE = 2,
    XML_WITH_OUTPUT = 3,
    XML_WITH_PUSH = 4,
    XML_WITH_READER = 5,
    XML_WITH_PATTERN = 6,
    XML_WITH_WRITER = 7,
    XML_WITH_SAX1 = 8,
    XML_WITH_FTP = 9,
    XML_WITH_HTTP = 10,
    XML_WITH_VALID = 11,
    XML_WITH_HTML = 12,
    XML_WITH_LEGACY = 13,
    XML_WITH_C14N = 14,
    XML_WITH_CATALOG = 15,
    XML_WITH_XPATH = 16,
    XML_WITH_XPTR = 17,
    XML_WITH_XINCLUDE = 18,
    XML_WITH_ICONV = 19,
    XML_WITH_ISO8859X = 20,
    XML_WITH_UNICODE = 21,
    XML_WITH_REGEXP = 22,
    XML_WITH_AUTOMATA = 23,
    XML_WITH_EXPR = 24,
    XML_WITH_SCHEMAS = 25,
    XML_WITH_SCHEMATRON = 26,
    XML_WITH_MODULES = 27,
    XML_WITH_DEBUG = 28,
    XML_WITH_DEBUG_MEM = 29,
    XML_WITH_DEBUG_RUN = 30,
    XML_WITH_ZLIB = 31,
    XML_WITH_ICU = 32,
    XML_WITH_LZMA = 33,
    XML_WITH_NONE = 99999
} xmlFeature;

 int
  xmlHasFeature (xmlFeature feature);
# 11 "./include/libxml/xmlerror.h" 2
# 17 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/relaxng.h" 1
# 23 "./include/libxml/relaxng.h"
typedef struct _xmlRelaxNG xmlRelaxNG;
typedef xmlRelaxNG *xmlRelaxNGPtr;
# 35 "./include/libxml/relaxng.h"
typedef void ( *xmlRelaxNGValidityErrorFunc) (void *ctx, const char *msg, ...) __attribute__((__format__(__printf__,2,3)));
# 45 "./include/libxml/relaxng.h"
typedef void ( *xmlRelaxNGValidityWarningFunc) (void *ctx, const char *msg, ...) __attribute__((__format__(__printf__,2,3)));




typedef struct _xmlRelaxNGParserCtxt xmlRelaxNGParserCtxt;
typedef xmlRelaxNGParserCtxt *xmlRelaxNGParserCtxtPtr;

typedef struct _xmlRelaxNGValidCtxt xmlRelaxNGValidCtxt;
typedef xmlRelaxNGValidCtxt *xmlRelaxNGValidCtxtPtr;






typedef enum {
    XML_RELAXNG_OK = 0,
    XML_RELAXNG_ERR_MEMORY,
    XML_RELAXNG_ERR_TYPE,
    XML_RELAXNG_ERR_TYPEVAL,
    XML_RELAXNG_ERR_DUPID,
    XML_RELAXNG_ERR_TYPECMP,
    XML_RELAXNG_ERR_NOSTATE,
    XML_RELAXNG_ERR_NODEFINE,
    XML_RELAXNG_ERR_LISTEXTRA,
    XML_RELAXNG_ERR_LISTEMPTY,
    XML_RELAXNG_ERR_INTERNODATA,
    XML_RELAXNG_ERR_INTERSEQ,
    XML_RELAXNG_ERR_INTEREXTRA,
    XML_RELAXNG_ERR_ELEMNAME,
    XML_RELAXNG_ERR_ATTRNAME,
    XML_RELAXNG_ERR_ELEMNONS,
    XML_RELAXNG_ERR_ATTRNONS,
    XML_RELAXNG_ERR_ELEMWRONGNS,
    XML_RELAXNG_ERR_ATTRWRONGNS,
    XML_RELAXNG_ERR_ELEMEXTRANS,
    XML_RELAXNG_ERR_ATTREXTRANS,
    XML_RELAXNG_ERR_ELEMNOTEMPTY,
    XML_RELAXNG_ERR_NOELEM,
    XML_RELAXNG_ERR_NOTELEM,
    XML_RELAXNG_ERR_ATTRVALID,
    XML_RELAXNG_ERR_CONTENTVALID,
    XML_RELAXNG_ERR_EXTRACONTENT,
    XML_RELAXNG_ERR_INVALIDATTR,
    XML_RELAXNG_ERR_DATAELEM,
    XML_RELAXNG_ERR_VALELEM,
    XML_RELAXNG_ERR_LISTELEM,
    XML_RELAXNG_ERR_DATATYPE,
    XML_RELAXNG_ERR_VALUE,
    XML_RELAXNG_ERR_LIST,
    XML_RELAXNG_ERR_NOGRAMMAR,
    XML_RELAXNG_ERR_EXTRADATA,
    XML_RELAXNG_ERR_LACKDATA,
    XML_RELAXNG_ERR_INTERNAL,
    XML_RELAXNG_ERR_ELEMWRONG,
    XML_RELAXNG_ERR_TEXTWRONG
} xmlRelaxNGValidErr;






typedef enum {
    XML_RELAXNGP_NONE = 0,
    XML_RELAXNGP_FREE_DOC = 1,
    XML_RELAXNGP_CRNG = 2
} xmlRelaxNGParserFlag;

 int
      xmlRelaxNGInitTypes (void);
 void
      xmlRelaxNGCleanupTypes (void);




 xmlRelaxNGParserCtxtPtr
      xmlRelaxNGNewParserCtxt (const char *URL);
 xmlRelaxNGParserCtxtPtr
      xmlRelaxNGNewMemParserCtxt (const char *buffer,
       int size);
 xmlRelaxNGParserCtxtPtr
      xmlRelaxNGNewDocParserCtxt (xmlDocPtr doc);

 int
      xmlRelaxParserSetFlag (xmlRelaxNGParserCtxtPtr ctxt,
       int flag);

 void
      xmlRelaxNGFreeParserCtxt (xmlRelaxNGParserCtxtPtr ctxt);
 void
      xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,
      xmlRelaxNGValidityErrorFunc err,
      xmlRelaxNGValidityWarningFunc warn,
      void *ctx);
 int
      xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,
      xmlRelaxNGValidityErrorFunc *err,
      xmlRelaxNGValidityWarningFunc *warn,
      void **ctx);
 void
      xmlRelaxNGSetParserStructuredErrors(
      xmlRelaxNGParserCtxtPtr ctxt,
      xmlStructuredErrorFunc serror,
      void *ctx);
 xmlRelaxNGPtr
      xmlRelaxNGParse (xmlRelaxNGParserCtxtPtr ctxt);
 void
      xmlRelaxNGFree (xmlRelaxNGPtr schema);

 void
      xmlRelaxNGDump (FILE *output,
      xmlRelaxNGPtr schema);
 void
      xmlRelaxNGDumpTree (FILE * output,
      xmlRelaxNGPtr schema);




 void
      xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,
      xmlRelaxNGValidityErrorFunc err,
      xmlRelaxNGValidityWarningFunc warn,
      void *ctx);
 int
      xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,
      xmlRelaxNGValidityErrorFunc *err,
      xmlRelaxNGValidityWarningFunc *warn,
      void **ctx);
 void
   xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,
       xmlStructuredErrorFunc serror, void *ctx);
 xmlRelaxNGValidCtxtPtr
      xmlRelaxNGNewValidCtxt (xmlRelaxNGPtr schema);
 void
      xmlRelaxNGFreeValidCtxt (xmlRelaxNGValidCtxtPtr ctxt);
 int
      xmlRelaxNGValidateDoc (xmlRelaxNGValidCtxtPtr ctxt,
       xmlDocPtr doc);



 int
      xmlRelaxNGValidatePushElement (xmlRelaxNGValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr elem);
 int
      xmlRelaxNGValidatePushCData (xmlRelaxNGValidCtxtPtr ctxt,
      const xmlChar *data,
      int len);
 int
      xmlRelaxNGValidatePopElement (xmlRelaxNGValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr elem);
 int
      xmlRelaxNGValidateFullElement (xmlRelaxNGValidCtxtPtr ctxt,
      xmlDocPtr doc,
      xmlNodePtr elem);
# 18 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2


static int testlibxml2(void);
static int test_module(const char *module);

static int generic_errors = 0;
static int call_tests = 0;
static int function_tests = 0;

static xmlChar chartab[1024];
static int inttab[1024];
static unsigned long longtab[1024];

static xmlDocPtr api_doc = 
# 31 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                          ((void *)0)
# 31 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                              ;
static xmlDtdPtr api_dtd = 
# 32 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                          ((void *)0)
# 32 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                              ;
static xmlNodePtr api_root = 
# 33 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                            ((void *)0)
# 33 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                ;
static xmlAttrPtr api_attr = 
# 34 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                            ((void *)0)
# 34 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                ;
static xmlNsPtr api_ns = 
# 35 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                        ((void *)0)
# 35 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                            ;

static void
structured_errors(void *userData __attribute__((unused)),
                  xmlErrorPtr error __attribute__((unused))) {
    generic_errors++;
}

static void
free_api_doc(void) {
    xmlFreeDoc(api_doc);
    api_doc = 
# 46 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
             ((void *)0)
# 46 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                 ;
    api_dtd = 
# 47 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
             ((void *)0)
# 47 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                 ;
    api_root = 
# 48 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 48 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ;
    api_attr = 
# 49 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 49 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ;
    api_ns = 
# 50 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
            ((void *)0)
# 50 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                ;
}

static xmlDocPtr
get_api_doc(void) {
    if (api_doc == 
# 55 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                  ((void *)0)
# 55 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                      ) {
        api_doc = xmlReadMemory("<!DOCTYPE root [<!ELEMENT root EMPTY>]><root xmlns:h='http://example.com/' h:foo='bar'/>", 88, "root_test", 
# 56 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                                                                                            ((void *)0)
# 56 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                                                                                                , 0);
 api_root = 
# 57 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
           ((void *)0)
# 57 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
               ;
 api_attr = 
# 58 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
           ((void *)0)
# 58 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
               ;
    }
    return(api_doc);
}

static xmlDtdPtr
get_api_dtd(void) {
    if ((api_dtd == 
# 65 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 65 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       ) || (api_dtd->type != XML_DTD_NODE)) {
        get_api_doc();
 if ((api_doc != 
# 67 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                ((void *)0)
# 67 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                    ) && (api_doc->children != 
# 67 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                               ((void *)0)
# 67 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                   ) &&
     (api_doc->children->type == XML_DTD_NODE))
     api_dtd = (xmlDtdPtr) api_doc->children;
    }
    return(api_dtd);
}

static xmlNodePtr
get_api_root(void) {
    if ((api_root == 
# 76 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                    ((void *)0)
# 76 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                        ) || (api_root->type != XML_ELEMENT_NODE)) {
        get_api_doc();
 if ((api_doc != 
# 78 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                ((void *)0)
# 78 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                    ) && (api_doc->children != 
# 78 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                               ((void *)0)
# 78 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                   ) &&
     (api_doc->children->next != 
# 79 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                ((void *)0)
# 79 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                    ) &&
     (api_doc->children->next->type == XML_ELEMENT_NODE))
     api_root = api_doc->children->next;
    }
    return(api_root);
}

static xmlNsPtr
get_api_ns(void) {
    get_api_root();
    if (api_root != 
# 89 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 89 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       )
        api_ns = api_root->nsDef;
    return(api_ns);
}

static xmlAttrPtr
get_api_attr(void) {

    static int nr = 0;
    xmlChar name[20];


    if ((api_root == 
# 101 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                    ((void *)0)
# 101 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                        ) || (api_root->type != XML_ELEMENT_NODE)) {
        get_api_root();
    }
    if (api_root == 
# 104 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 104 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       )
        return(
# 105 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 105 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  );
    if (api_root->properties != 
# 106 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                               ((void *)0)
# 106 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                   ) {
        api_attr = api_root->properties;
        return(api_root->properties);
    }
    api_attr = 
# 110 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 110 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ;

    snprintf((char *) name, 20, "foo%d", nr++);
    api_attr = xmlSetProp(api_root, name, (const xmlChar *) "bar");

    return(api_attr);
}

static int quiet = 0;

int main(int argc, char **argv) {
    int ret;
    int blocks, mem;



    putenv((char *) "http_proxy=");


    memset(chartab, 0, sizeof(chartab));
    strncpy((char *) chartab, "  chartab\n", 20);
    memset(inttab, 0, sizeof(inttab));
    memset(longtab, 0, sizeof(longtab));

    xmlInitParser();

    xmlRelaxNGInitTypes();


    xmlCheckVersion(20900);

    xmlSetStructuredErrorFunc(
# 141 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                             ((void *)0)
# 141 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                 , structured_errors);

    if (argc >= 2) {
        if (!strcmp(argv[1], "-q")) {
     quiet = 1;
     if (argc >= 3)
         ret = test_module(argv[2]);
     else
  ret = testlibxml2();
        } else {
    ret = test_module(argv[1]);
 }
    } else
 ret = testlibxml2();

    xmlCleanupParser();
    blocks = xmlMemBlocks();
    mem = xmlMemUsed();
    if ((blocks != 0) || (mem != 0)) {
        printf("testapi leaked %d bytes in %d blocks\n", mem, blocks);
    }
    xmlMemoryDump();

    return (ret != 0);
}

# 1 "./include/libxml/HTMLparser.h" 1
# 27 "./include/libxml/HTMLparser.h"
typedef xmlParserCtxt htmlParserCtxt;
typedef xmlParserCtxtPtr htmlParserCtxtPtr;
typedef xmlParserNodeInfo htmlParserNodeInfo;
typedef xmlSAXHandler htmlSAXHandler;
typedef xmlSAXHandlerPtr htmlSAXHandlerPtr;
typedef xmlParserInput htmlParserInput;
typedef xmlParserInputPtr htmlParserInputPtr;
typedef xmlDocPtr htmlDocPtr;
typedef xmlNodePtr htmlNodePtr;





typedef struct _htmlElemDesc htmlElemDesc;
typedef htmlElemDesc *htmlElemDescPtr;
struct _htmlElemDesc {
    const char *name;
    char startTag;
    char endTag;
    char saveEndTag;
    char empty;
    char depr;
    char dtd;
    char isinline;
    const char *desc;
# 64 "./include/libxml/HTMLparser.h"
    const char** subelts;
    const char* defaultsubelt;

    const char** attrs_opt;
    const char** attrs_depr;
    const char** attrs_req;
};




typedef struct _htmlEntityDesc htmlEntityDesc;
typedef htmlEntityDesc *htmlEntityDescPtr;
struct _htmlEntityDesc {
    unsigned int value;
    const char *name;
    const char *desc;
};




 const htmlElemDesc *
   htmlTagLookup (const xmlChar *tag);
 const htmlEntityDesc *
   htmlEntityLookup(const xmlChar *name);
 const htmlEntityDesc *
   htmlEntityValueLookup(unsigned int value);

 int
   htmlIsAutoClosed(htmlDocPtr doc,
      htmlNodePtr elem);
 int
   htmlAutoCloseTag(htmlDocPtr doc,
      const xmlChar *name,
      htmlNodePtr elem);
 const htmlEntityDesc *
   htmlParseEntityRef(htmlParserCtxtPtr ctxt,
      const xmlChar **str);
 int
   htmlParseCharRef(htmlParserCtxtPtr ctxt);
 void
   htmlParseElement(htmlParserCtxtPtr ctxt);

 htmlParserCtxtPtr
   htmlNewParserCtxt(void);

 htmlParserCtxtPtr
   htmlCreateMemoryParserCtxt(const char *buffer,
         int size);

 int
   htmlParseDocument(htmlParserCtxtPtr ctxt);
 htmlDocPtr
   htmlSAXParseDoc (xmlChar *cur,
      const char *encoding,
      htmlSAXHandlerPtr sax,
      void *userData);
 htmlDocPtr
   htmlParseDoc (xmlChar *cur,
      const char *encoding);
 htmlDocPtr
   htmlSAXParseFile(const char *filename,
      const char *encoding,
      htmlSAXHandlerPtr sax,
      void *userData);
 htmlDocPtr
   htmlParseFile (const char *filename,
      const char *encoding);
 int
   UTF8ToHtml (unsigned char *out,
      int *outlen,
      const unsigned char *in,
      int *inlen);
 int
   htmlEncodeEntities(unsigned char *out,
      int *outlen,
      const unsigned char *in,
      int *inlen, int quoteChar);
 int
   htmlIsScriptAttribute(const xmlChar *name);
 int
   htmlHandleOmittedElem(int val);





 htmlParserCtxtPtr
   htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax,
       void *user_data,
       const char *chunk,
       int size,
       const char *filename,
       xmlCharEncoding enc);
 int
   htmlParseChunk (htmlParserCtxtPtr ctxt,
       const char *chunk,
       int size,
       int terminate);


 void
   htmlFreeParserCtxt (htmlParserCtxtPtr ctxt);
# 178 "./include/libxml/HTMLparser.h"
typedef enum {
    HTML_PARSE_RECOVER = 1<<0,
    HTML_PARSE_NODEFDTD = 1<<2,
    HTML_PARSE_NOERROR = 1<<5,
    HTML_PARSE_NOWARNING= 1<<6,
    HTML_PARSE_PEDANTIC = 1<<7,
    HTML_PARSE_NOBLANKS = 1<<8,
    HTML_PARSE_NONET = 1<<11,
    HTML_PARSE_NOIMPLIED= 1<<13,
    HTML_PARSE_COMPACT = 1<<16,
    HTML_PARSE_IGNORE_ENC=1<<21
} htmlParserOption;

 void
  htmlCtxtReset (htmlParserCtxtPtr ctxt);
 int
  htmlCtxtUseOptions (htmlParserCtxtPtr ctxt,
      int options);
 htmlDocPtr
  htmlReadDoc (const xmlChar *cur,
      const char *URL,
      const char *encoding,
      int options);
 htmlDocPtr
  htmlReadFile (const char *URL,
      const char *encoding,
      int options);
 htmlDocPtr
  htmlReadMemory (const char *buffer,
      int size,
      const char *URL,
      const char *encoding,
      int options);
 htmlDocPtr
  htmlReadFd (int fd,
      const char *URL,
      const char *encoding,
      int options);
 htmlDocPtr
  htmlReadIO (xmlInputReadCallback ioread,
      xmlInputCloseCallback ioclose,
      void *ioctx,
      const char *URL,
      const char *encoding,
      int options);
 htmlDocPtr
  htmlCtxtReadDoc (xmlParserCtxtPtr ctxt,
      const xmlChar *cur,
      const char *URL,
      const char *encoding,
      int options);
 htmlDocPtr
  htmlCtxtReadFile (xmlParserCtxtPtr ctxt,
      const char *filename,
      const char *encoding,
      int options);
 htmlDocPtr
  htmlCtxtReadMemory (xmlParserCtxtPtr ctxt,
      const char *buffer,
      int size,
      const char *URL,
      const char *encoding,
      int options);
 htmlDocPtr
  htmlCtxtReadFd (xmlParserCtxtPtr ctxt,
      int fd,
      const char *URL,
      const char *encoding,
      int options);
 htmlDocPtr
  htmlCtxtReadIO (xmlParserCtxtPtr ctxt,
      xmlInputReadCallback ioread,
      xmlInputCloseCallback ioclose,
      void *ioctx,
      const char *URL,
      const char *encoding,
      int options);



typedef enum {
  HTML_NA = 0 ,
  HTML_INVALID = 0x1 ,
  HTML_DEPRECATED = 0x2 ,
  HTML_VALID = 0x4 ,
  HTML_REQUIRED = 0xc
} htmlStatus ;




 htmlStatus htmlAttrAllowed(const htmlElemDesc*, const xmlChar*, int) ;
 int htmlElementAllowedHere(const htmlElemDesc*, const xmlChar*) ;
 htmlStatus htmlElementStatusHere(const htmlElemDesc*, const htmlElemDesc*) ;
 htmlStatus htmlNodeStatus(const htmlNodePtr, int) ;
# 168 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/HTMLtree.h" 1
# 62 "./include/libxml/HTMLtree.h"
 htmlDocPtr
  htmlNewDoc (const xmlChar *URI,
      const xmlChar *ExternalID);
 htmlDocPtr
  htmlNewDocNoDtD (const xmlChar *URI,
      const xmlChar *ExternalID);
 const xmlChar *
  htmlGetMetaEncoding (htmlDocPtr doc);
 int
  htmlSetMetaEncoding (htmlDocPtr doc,
      const xmlChar *encoding);

 void
  htmlDocDumpMemory (xmlDocPtr cur,
      xmlChar **mem,
      int *size);
 void
  htmlDocDumpMemoryFormat (xmlDocPtr cur,
      xmlChar **mem,
      int *size,
      int format);
 int
  htmlDocDump (FILE *f,
      xmlDocPtr cur);
 int
  htmlSaveFile (const char *filename,
      xmlDocPtr cur);
 int
  htmlNodeDump (xmlBufferPtr buf,
      xmlDocPtr doc,
      xmlNodePtr cur);
 void
  htmlNodeDumpFile (FILE *out,
      xmlDocPtr doc,
      xmlNodePtr cur);
 int
  htmlNodeDumpFileFormat (FILE *out,
      xmlDocPtr doc,
      xmlNodePtr cur,
      const char *encoding,
      int format);
 int
  htmlSaveFileEnc (const char *filename,
      xmlDocPtr cur,
      const char *encoding);
 int
  htmlSaveFileFormat (const char *filename,
      xmlDocPtr cur,
      const char *encoding,
      int format);

 void
  htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf,
      xmlDocPtr doc,
      xmlNodePtr cur,
      const char *encoding,
      int format);
 void
  htmlDocContentDumpOutput(xmlOutputBufferPtr buf,
      xmlDocPtr cur,
      const char *encoding);
 void
  htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf,
      xmlDocPtr cur,
      const char *encoding,
      int format);
 void
  htmlNodeDumpOutput (xmlOutputBufferPtr buf,
      xmlDocPtr doc,
      xmlNodePtr cur,
      const char *encoding);



 int
  htmlIsBooleanAttr (const xmlChar *name);
# 169 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/catalog.h" 1
# 50 "./include/libxml/catalog.h"
typedef enum {
    XML_CATA_PREFER_NONE = 0,
    XML_CATA_PREFER_PUBLIC = 1,
    XML_CATA_PREFER_SYSTEM
} xmlCatalogPrefer;

typedef enum {
    XML_CATA_ALLOW_NONE = 0,
    XML_CATA_ALLOW_GLOBAL = 1,
    XML_CATA_ALLOW_DOCUMENT = 2,
    XML_CATA_ALLOW_ALL = 3
} xmlCatalogAllow;

typedef struct _xmlCatalog xmlCatalog;
typedef xmlCatalog *xmlCatalogPtr;




 xmlCatalogPtr
  xmlNewCatalog (int sgml);
 xmlCatalogPtr
  xmlLoadACatalog (const char *filename);
 xmlCatalogPtr
  xmlLoadSGMLSuperCatalog (const char *filename);
 int
  xmlConvertSGMLCatalog (xmlCatalogPtr catal);
 int
  xmlACatalogAdd (xmlCatalogPtr catal,
      const xmlChar *type,
      const xmlChar *orig,
      const xmlChar *replace);
 int
  xmlACatalogRemove (xmlCatalogPtr catal,
      const xmlChar *value);
 xmlChar *
  xmlACatalogResolve (xmlCatalogPtr catal,
      const xmlChar *pubID,
                                  const xmlChar *sysID);
 xmlChar *
  xmlACatalogResolveSystem(xmlCatalogPtr catal,
      const xmlChar *sysID);
 xmlChar *
  xmlACatalogResolvePublic(xmlCatalogPtr catal,
      const xmlChar *pubID);
 xmlChar *
  xmlACatalogResolveURI (xmlCatalogPtr catal,
      const xmlChar *URI);

 void
  xmlACatalogDump (xmlCatalogPtr catal,
      FILE *out);

 void
  xmlFreeCatalog (xmlCatalogPtr catal);
 int
  xmlCatalogIsEmpty (xmlCatalogPtr catal);




 void
  xmlInitializeCatalog (void);
 int
  xmlLoadCatalog (const char *filename);
 void
  xmlLoadCatalogs (const char *paths);
 void
  xmlCatalogCleanup (void);

 void
  xmlCatalogDump (FILE *out);

 xmlChar *
  xmlCatalogResolve (const xmlChar *pubID,
                                  const xmlChar *sysID);
 xmlChar *
  xmlCatalogResolveSystem (const xmlChar *sysID);
 xmlChar *
  xmlCatalogResolvePublic (const xmlChar *pubID);
 xmlChar *
  xmlCatalogResolveURI (const xmlChar *URI);
 int
  xmlCatalogAdd (const xmlChar *type,
      const xmlChar *orig,
      const xmlChar *replace);
 int
  xmlCatalogRemove (const xmlChar *value);
 xmlDocPtr
  xmlParseCatalogFile (const char *filename);
 int
  xmlCatalogConvert (void);





 void
  xmlCatalogFreeLocal (void *catalogs);
 void *
  xmlCatalogAddLocal (void *catalogs,
      const xmlChar *URL);
 xmlChar *
  xmlCatalogLocalResolve (void *catalogs,
      const xmlChar *pubID,
                                  const xmlChar *sysID);
 xmlChar *
  xmlCatalogLocalResolveURI(void *catalogs,
      const xmlChar *URI);



 int
  xmlCatalogSetDebug (int level);
 xmlCatalogPrefer
  xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer);
 void
  xmlCatalogSetDefaults (xmlCatalogAllow allow);
 xmlCatalogAllow
  xmlCatalogGetDefaults (void);



 const xmlChar *
  xmlCatalogGetSystem (const xmlChar *sysID);
 const xmlChar *
  xmlCatalogGetPublic (const xmlChar *pubID);
# 170 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/chvalid.h" 1
# 28 "./include/libxml/chvalid.h"
typedef struct _xmlChSRange xmlChSRange;
typedef xmlChSRange *xmlChSRangePtr;
struct _xmlChSRange {
    unsigned short low;
    unsigned short high;
};

typedef struct _xmlChLRange xmlChLRange;
typedef xmlChLRange *xmlChLRangePtr;
struct _xmlChLRange {
    unsigned int low;
    unsigned int high;
};

typedef struct _xmlChRangeGroup xmlChRangeGroup;
typedef xmlChRangeGroup *xmlChRangeGroupPtr;
struct _xmlChRangeGroup {
    int nbShortRange;
    int nbLongRange;
    const xmlChSRange *shortRange;
    const xmlChLRange *longRange;
};




 int
  xmlCharInRange(unsigned int val, const xmlChRangeGroup *group);
# 80 "./include/libxml/chvalid.h"
extern const xmlChRangeGroup xmlIsBaseCharGroup;
# 124 "./include/libxml/chvalid.h"
extern const xmlChRangeGroup xmlIsCharGroup;
# 136 "./include/libxml/chvalid.h"
extern const xmlChRangeGroup xmlIsCombiningGroup;
# 156 "./include/libxml/chvalid.h"
extern const xmlChRangeGroup xmlIsDigitGroup;
# 176 "./include/libxml/chvalid.h"
extern const xmlChRangeGroup xmlIsExtenderGroup;
# 190 "./include/libxml/chvalid.h"
extern const xmlChRangeGroup xmlIsIdeographicGroup;
extern const unsigned char xmlIsPubidChar_tab[256];
# 210 "./include/libxml/chvalid.h"
 int
  xmlIsBaseChar(unsigned int ch);
 int
  xmlIsBlank(unsigned int ch);
 int
  xmlIsChar(unsigned int ch);
 int
  xmlIsCombining(unsigned int ch);
 int
  xmlIsDigit(unsigned int ch);
 int
  xmlIsExtender(unsigned int ch);
 int
  xmlIsIdeographic(unsigned int ch);
 int
  xmlIsPubidChar(unsigned int ch);
# 171 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2





# 1 "./include/libxml/nanoftp.h" 1
# 60 "./include/libxml/nanoftp.h"
typedef void (*ftpListCallback) (void *userData,
                          const char *filename, const char *attrib,
                          const char *owner, const char *group,
     unsigned long size, int links, int year,
     const char *month, int day, int hour,
     int minute);
# 74 "./include/libxml/nanoftp.h"
typedef void (*ftpDataCallback) (void *userData,
     const char *data,
     int len);




 void
 xmlNanoFTPInit (void);
 void
 xmlNanoFTPCleanup (void);




 void *
 xmlNanoFTPNewCtxt (const char *URL);
 void
 xmlNanoFTPFreeCtxt (void * ctx);
 void *
 xmlNanoFTPConnectTo (const char *server,
     int port);



 void *
 xmlNanoFTPOpen (const char *URL);
 int
 xmlNanoFTPConnect (void *ctx);
 int
 xmlNanoFTPClose (void *ctx);
 int
 xmlNanoFTPQuit (void *ctx);
 void
 xmlNanoFTPScanProxy (const char *URL);
 void
 xmlNanoFTPProxy (const char *host,
     int port,
     const char *user,
     const char *passwd,
     int type);
 int
 xmlNanoFTPUpdateURL (void *ctx,
     const char *URL);




 int
 xmlNanoFTPGetResponse (void *ctx);
 int
 xmlNanoFTPCheckResponse (void *ctx);




 int
 xmlNanoFTPCwd (void *ctx,
     const char *directory);
 int
 xmlNanoFTPDele (void *ctx,
     const char *file);

 int
 xmlNanoFTPGetConnection (void *ctx);
 int
 xmlNanoFTPCloseConnection(void *ctx);
 int
 xmlNanoFTPList (void *ctx,
     ftpListCallback callback,
     void *userData,
     const char *filename);
 int
 xmlNanoFTPGetSocket (void *ctx,
     const char *filename);
 int
 xmlNanoFTPGet (void *ctx,
     ftpDataCallback callback,
     void *userData,
     const char *filename);
 int
 xmlNanoFTPRead (void *ctx,
     void *dest,
     int len);
# 177 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/nanohttp.h" 1
# 21 "./include/libxml/nanohttp.h"
 void
 xmlNanoHTTPInit (void);
 void
 xmlNanoHTTPCleanup (void);
 void
 xmlNanoHTTPScanProxy (const char *URL);
 int
 xmlNanoHTTPFetch (const char *URL,
     const char *filename,
     char **contentType);
 void *
 xmlNanoHTTPMethod (const char *URL,
     const char *method,
     const char *input,
     char **contentType,
     const char *headers,
     int ilen);
 void *
 xmlNanoHTTPMethodRedir (const char *URL,
     const char *method,
     const char *input,
     char **contentType,
     char **redir,
     const char *headers,
     int ilen);
 void *
 xmlNanoHTTPOpen (const char *URL,
     char **contentType);
 void *
 xmlNanoHTTPOpenRedir (const char *URL,
     char **contentType,
     char **redir);
 int
 xmlNanoHTTPReturnCode (void *ctx);
 const char *
 xmlNanoHTTPAuthHeader (void *ctx);
 const char *
 xmlNanoHTTPRedir (void *ctx);
 int
 xmlNanoHTTPContentLength( void * ctx );
 const char *
 xmlNanoHTTPEncoding (void *ctx);
 const char *
 xmlNanoHTTPMimeType (void *ctx);
 int
 xmlNanoHTTPRead (void *ctx,
     void *dest,
     int len);

 int
 xmlNanoHTTPSave (void *ctxt,
     const char *filename);

 void
 xmlNanoHTTPClose (void *ctx);
# 178 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2

# 1 "./include/libxml/parserInternals.h" 1
# 31 "./include/libxml/parserInternals.h"
extern unsigned int xmlParserMaxDepth;
# 312 "./include/libxml/parserInternals.h"
extern const xmlChar xmlStringText[];
extern const xmlChar xmlStringTextNoenc[];
extern const xmlChar xmlStringComment[];




 int xmlIsLetter (int c);




 xmlParserCtxtPtr
   xmlCreateFileParserCtxt (const char *filename);
 xmlParserCtxtPtr
   xmlCreateURLParserCtxt (const char *filename,
       int options);
 xmlParserCtxtPtr
   xmlCreateMemoryParserCtxt(const char *buffer,
       int size);
 xmlParserCtxtPtr
   xmlCreateEntityParserCtxt(const xmlChar *URL,
       const xmlChar *ID,
       const xmlChar *base);
 int
   xmlSwitchEncoding (xmlParserCtxtPtr ctxt,
       xmlCharEncoding enc);
 int
   xmlSwitchToEncoding (xmlParserCtxtPtr ctxt,
      xmlCharEncodingHandlerPtr handler);
 int
   xmlSwitchInputEncoding (xmlParserCtxtPtr ctxt,
       xmlParserInputPtr input,
      xmlCharEncodingHandlerPtr handler);
# 360 "./include/libxml/parserInternals.h"
 xmlParserInputPtr
   xmlNewStringInputStream (xmlParserCtxtPtr ctxt,
       const xmlChar *buffer);
 xmlParserInputPtr
   xmlNewEntityInputStream (xmlParserCtxtPtr ctxt,
       xmlEntityPtr entity);
 int
   xmlPushInput (xmlParserCtxtPtr ctxt,
       xmlParserInputPtr input);
 xmlChar
   xmlPopInput (xmlParserCtxtPtr ctxt);
 void
   xmlFreeInputStream (xmlParserInputPtr input);
 xmlParserInputPtr
   xmlNewInputFromFile (xmlParserCtxtPtr ctxt,
       const char *filename);
 xmlParserInputPtr
   xmlNewInputStream (xmlParserCtxtPtr ctxt);




 xmlChar *
   xmlSplitQName (xmlParserCtxtPtr ctxt,
       const xmlChar *name,
       xmlChar **prefix);




 const xmlChar *
   xmlParseName (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlParseNmtoken (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlParseEntityValue (xmlParserCtxtPtr ctxt,
       xmlChar **orig);
 xmlChar *
   xmlParseAttValue (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlParseSystemLiteral (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlParsePubidLiteral (xmlParserCtxtPtr ctxt);
 void
   xmlParseCharData (xmlParserCtxtPtr ctxt,
       int cdata);
 xmlChar *
   xmlParseExternalID (xmlParserCtxtPtr ctxt,
       xmlChar **publicID,
       int strict);
 void
   xmlParseComment (xmlParserCtxtPtr ctxt);
 const xmlChar *
   xmlParsePITarget (xmlParserCtxtPtr ctxt);
 void
   xmlParsePI (xmlParserCtxtPtr ctxt);
 void
   xmlParseNotationDecl (xmlParserCtxtPtr ctxt);
 void
   xmlParseEntityDecl (xmlParserCtxtPtr ctxt);
 int
   xmlParseDefaultDecl (xmlParserCtxtPtr ctxt,
       xmlChar **value);
 xmlEnumerationPtr
   xmlParseNotationType (xmlParserCtxtPtr ctxt);
 xmlEnumerationPtr
   xmlParseEnumerationType (xmlParserCtxtPtr ctxt);
 int
   xmlParseEnumeratedType (xmlParserCtxtPtr ctxt,
       xmlEnumerationPtr *tree);
 int
   xmlParseAttributeType (xmlParserCtxtPtr ctxt,
       xmlEnumerationPtr *tree);
 void
   xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt);
 xmlElementContentPtr
   xmlParseElementMixedContentDecl
      (xmlParserCtxtPtr ctxt,
       int inputchk);
 xmlElementContentPtr
   xmlParseElementChildrenContentDecl
      (xmlParserCtxtPtr ctxt,
       int inputchk);
 int
   xmlParseElementContentDecl(xmlParserCtxtPtr ctxt,
       const xmlChar *name,
       xmlElementContentPtr *result);
 int
   xmlParseElementDecl (xmlParserCtxtPtr ctxt);
 void
   xmlParseMarkupDecl (xmlParserCtxtPtr ctxt);
 int
   xmlParseCharRef (xmlParserCtxtPtr ctxt);
 xmlEntityPtr
   xmlParseEntityRef (xmlParserCtxtPtr ctxt);
 void
   xmlParseReference (xmlParserCtxtPtr ctxt);
 void
   xmlParsePEReference (xmlParserCtxtPtr ctxt);
 void
   xmlParseDocTypeDecl (xmlParserCtxtPtr ctxt);

 const xmlChar *
   xmlParseAttribute (xmlParserCtxtPtr ctxt,
       xmlChar **value);
 const xmlChar *
   xmlParseStartTag (xmlParserCtxtPtr ctxt);
 void
   xmlParseEndTag (xmlParserCtxtPtr ctxt);

 void
   xmlParseCDSect (xmlParserCtxtPtr ctxt);
 void
   xmlParseContent (xmlParserCtxtPtr ctxt);
 void
   xmlParseElement (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlParseVersionNum (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlParseVersionInfo (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlParseEncName (xmlParserCtxtPtr ctxt);
 const xmlChar *
   xmlParseEncodingDecl (xmlParserCtxtPtr ctxt);
 int
   xmlParseSDDecl (xmlParserCtxtPtr ctxt);
 void
   xmlParseXMLDecl (xmlParserCtxtPtr ctxt);
 void
   xmlParseTextDecl (xmlParserCtxtPtr ctxt);
 void
   xmlParseMisc (xmlParserCtxtPtr ctxt);
 void
   xmlParseExternalSubset (xmlParserCtxtPtr ctxt,
       const xmlChar *ExternalID,
       const xmlChar *SystemID);
# 521 "./include/libxml/parserInternals.h"
 xmlChar *
  xmlStringDecodeEntities (xmlParserCtxtPtr ctxt,
       const xmlChar *str,
       int what,
       xmlChar end,
       xmlChar end2,
       xmlChar end3);
 xmlChar *
  xmlStringLenDecodeEntities (xmlParserCtxtPtr ctxt,
       const xmlChar *str,
       int len,
       int what,
       xmlChar end,
       xmlChar end2,
       xmlChar end3);




 int nodePush (xmlParserCtxtPtr ctxt,
       xmlNodePtr value);
 xmlNodePtr nodePop (xmlParserCtxtPtr ctxt);
 int inputPush (xmlParserCtxtPtr ctxt,
       xmlParserInputPtr value);
 xmlParserInputPtr inputPop (xmlParserCtxtPtr ctxt);
 const xmlChar * namePop (xmlParserCtxtPtr ctxt);
 int namePush (xmlParserCtxtPtr ctxt,
       const xmlChar *value);




 int xmlSkipBlankChars (xmlParserCtxtPtr ctxt);
 int xmlStringCurrentChar (xmlParserCtxtPtr ctxt,
       const xmlChar *cur,
       int *len);
 void xmlParserHandlePEReference(xmlParserCtxtPtr ctxt);
 int xmlCheckLanguageID (const xmlChar *lang);




 int xmlCurrentChar (xmlParserCtxtPtr ctxt,
       int *len);
 int xmlCopyCharMultiByte (xmlChar *out,
       int val);
 int xmlCopyChar (int len,
       xmlChar *out,
       int val);
 void xmlNextChar (xmlParserCtxtPtr ctxt);
 void xmlParserInputShrink (xmlParserInputPtr in);





 void htmlInitAutoClose (void);
 htmlParserCtxtPtr htmlCreateFileParserCtxt(const char *filename,
                                          const char *encoding);
# 596 "./include/libxml/parserInternals.h"
typedef void (*xmlEntityReferenceFunc) (xmlEntityPtr ent,
       xmlNodePtr firstNode,
       xmlNodePtr lastNode);

 void xmlSetEntityReferenceFunc (xmlEntityReferenceFunc func);

 xmlChar *
   xmlParseQuotedString (xmlParserCtxtPtr ctxt);
 void
                        xmlParseNamespace (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlNamespaceParseNSDef (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlScanName (xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlNamespaceParseNCName (xmlParserCtxtPtr ctxt);
 void xmlParserHandleReference(xmlParserCtxtPtr ctxt);
 xmlChar *
   xmlNamespaceParseQName (xmlParserCtxtPtr ctxt,
       xmlChar **prefix);



 xmlChar *
  xmlDecodeEntities (xmlParserCtxtPtr ctxt,
       int len,
       int what,
       xmlChar end,
       xmlChar end2,
       xmlChar end3);
 void
   xmlHandleEntity (xmlParserCtxtPtr ctxt,
       xmlEntityPtr entity);
# 180 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/pattern.h" 1
# 29 "./include/libxml/pattern.h"
typedef struct _xmlPattern xmlPattern;
typedef xmlPattern *xmlPatternPtr;
# 39 "./include/libxml/pattern.h"
typedef enum {
    XML_PATTERN_DEFAULT = 0,
    XML_PATTERN_XPATH = 1<<0,
    XML_PATTERN_XSSEL = 1<<1,
    XML_PATTERN_XSFIELD = 1<<2
} xmlPatternFlags;

 void
   xmlFreePattern (xmlPatternPtr comp);

 void
   xmlFreePatternList (xmlPatternPtr comp);

 xmlPatternPtr
   xmlPatterncompile (const xmlChar *pattern,
       xmlDict *dict,
       int flags,
       const xmlChar **namespaces);
 int
   xmlPatternMatch (xmlPatternPtr comp,
       xmlNodePtr node);


typedef struct _xmlStreamCtxt xmlStreamCtxt;
typedef xmlStreamCtxt *xmlStreamCtxtPtr;

 int
   xmlPatternStreamable (xmlPatternPtr comp);
 int
   xmlPatternMaxDepth (xmlPatternPtr comp);
 int
   xmlPatternMinDepth (xmlPatternPtr comp);
 int
   xmlPatternFromRoot (xmlPatternPtr comp);
 xmlStreamCtxtPtr
   xmlPatternGetStreamCtxt (xmlPatternPtr comp);
 void
   xmlFreeStreamCtxt (xmlStreamCtxtPtr stream);
 int
   xmlStreamPushNode (xmlStreamCtxtPtr stream,
       const xmlChar *name,
       const xmlChar *ns,
       int nodeType);
 int
   xmlStreamPush (xmlStreamCtxtPtr stream,
       const xmlChar *name,
       const xmlChar *ns);
 int
   xmlStreamPushAttr (xmlStreamCtxtPtr stream,
       const xmlChar *name,
       const xmlChar *ns);
 int
   xmlStreamPop (xmlStreamCtxtPtr stream);
 int
   xmlStreamWantsAnyNode (xmlStreamCtxtPtr stream);
# 181 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2

# 1 "./include/libxml/schemasInternals.h" 1
# 29 "./include/libxml/schemasInternals.h"
typedef enum {
    XML_SCHEMAS_UNKNOWN = 0,
    XML_SCHEMAS_STRING,
    XML_SCHEMAS_NORMSTRING,
    XML_SCHEMAS_DECIMAL,
    XML_SCHEMAS_TIME,
    XML_SCHEMAS_GDAY,
    XML_SCHEMAS_GMONTH,
    XML_SCHEMAS_GMONTHDAY,
    XML_SCHEMAS_GYEAR,
    XML_SCHEMAS_GYEARMONTH,
    XML_SCHEMAS_DATE,
    XML_SCHEMAS_DATETIME,
    XML_SCHEMAS_DURATION,
    XML_SCHEMAS_FLOAT,
    XML_SCHEMAS_DOUBLE,
    XML_SCHEMAS_BOOLEAN,
    XML_SCHEMAS_TOKEN,
    XML_SCHEMAS_LANGUAGE,
    XML_SCHEMAS_NMTOKEN,
    XML_SCHEMAS_NMTOKENS,
    XML_SCHEMAS_NAME,
    XML_SCHEMAS_QNAME,
    XML_SCHEMAS_NCNAME,
    XML_SCHEMAS_ID,
    XML_SCHEMAS_IDREF,
    XML_SCHEMAS_IDREFS,
    XML_SCHEMAS_ENTITY,
    XML_SCHEMAS_ENTITIES,
    XML_SCHEMAS_NOTATION,
    XML_SCHEMAS_ANYURI,
    XML_SCHEMAS_INTEGER,
    XML_SCHEMAS_NPINTEGER,
    XML_SCHEMAS_NINTEGER,
    XML_SCHEMAS_NNINTEGER,
    XML_SCHEMAS_PINTEGER,
    XML_SCHEMAS_INT,
    XML_SCHEMAS_UINT,
    XML_SCHEMAS_LONG,
    XML_SCHEMAS_ULONG,
    XML_SCHEMAS_SHORT,
    XML_SCHEMAS_USHORT,
    XML_SCHEMAS_BYTE,
    XML_SCHEMAS_UBYTE,
    XML_SCHEMAS_HEXBINARY,
    XML_SCHEMAS_BASE64BINARY,
    XML_SCHEMAS_ANYTYPE,
    XML_SCHEMAS_ANYSIMPLETYPE
} xmlSchemaValType;




typedef enum {
    XML_SCHEMA_TYPE_BASIC = 1,
    XML_SCHEMA_TYPE_ANY,
    XML_SCHEMA_TYPE_FACET,
    XML_SCHEMA_TYPE_SIMPLE,
    XML_SCHEMA_TYPE_COMPLEX,
    XML_SCHEMA_TYPE_SEQUENCE = 6,
    XML_SCHEMA_TYPE_CHOICE,
    XML_SCHEMA_TYPE_ALL,
    XML_SCHEMA_TYPE_SIMPLE_CONTENT,
    XML_SCHEMA_TYPE_COMPLEX_CONTENT,
    XML_SCHEMA_TYPE_UR,
    XML_SCHEMA_TYPE_RESTRICTION,
    XML_SCHEMA_TYPE_EXTENSION,
    XML_SCHEMA_TYPE_ELEMENT,
    XML_SCHEMA_TYPE_ATTRIBUTE,
    XML_SCHEMA_TYPE_ATTRIBUTEGROUP,
    XML_SCHEMA_TYPE_GROUP,
    XML_SCHEMA_TYPE_NOTATION,
    XML_SCHEMA_TYPE_LIST,
    XML_SCHEMA_TYPE_UNION,
    XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
    XML_SCHEMA_TYPE_IDC_UNIQUE,
    XML_SCHEMA_TYPE_IDC_KEY,
    XML_SCHEMA_TYPE_IDC_KEYREF,
    XML_SCHEMA_TYPE_PARTICLE = 25,
    XML_SCHEMA_TYPE_ATTRIBUTE_USE,
    XML_SCHEMA_FACET_MININCLUSIVE = 1000,
    XML_SCHEMA_FACET_MINEXCLUSIVE,
    XML_SCHEMA_FACET_MAXINCLUSIVE,
    XML_SCHEMA_FACET_MAXEXCLUSIVE,
    XML_SCHEMA_FACET_TOTALDIGITS,
    XML_SCHEMA_FACET_FRACTIONDIGITS,
    XML_SCHEMA_FACET_PATTERN,
    XML_SCHEMA_FACET_ENUMERATION,
    XML_SCHEMA_FACET_WHITESPACE,
    XML_SCHEMA_FACET_LENGTH,
    XML_SCHEMA_FACET_MAXLENGTH,
    XML_SCHEMA_FACET_MINLENGTH,
    XML_SCHEMA_EXTRA_QNAMEREF = 2000,
    XML_SCHEMA_EXTRA_ATTR_USE_PROHIB
} xmlSchemaTypeType;

typedef enum {
    XML_SCHEMA_CONTENT_UNKNOWN = 0,
    XML_SCHEMA_CONTENT_EMPTY = 1,
    XML_SCHEMA_CONTENT_ELEMENTS,
    XML_SCHEMA_CONTENT_MIXED,
    XML_SCHEMA_CONTENT_SIMPLE,
    XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS,
    XML_SCHEMA_CONTENT_BASIC,
    XML_SCHEMA_CONTENT_ANY
} xmlSchemaContentType;

typedef struct _xmlSchemaVal xmlSchemaVal;
typedef xmlSchemaVal *xmlSchemaValPtr;

typedef struct _xmlSchemaType xmlSchemaType;
typedef xmlSchemaType *xmlSchemaTypePtr;

typedef struct _xmlSchemaFacet xmlSchemaFacet;
typedef xmlSchemaFacet *xmlSchemaFacetPtr;




typedef struct _xmlSchemaAnnot xmlSchemaAnnot;
typedef xmlSchemaAnnot *xmlSchemaAnnotPtr;
struct _xmlSchemaAnnot {
    struct _xmlSchemaAnnot *next;
    xmlNodePtr content;
};
# 246 "./include/libxml/schemasInternals.h"
typedef struct _xmlSchemaAttribute xmlSchemaAttribute;
typedef xmlSchemaAttribute *xmlSchemaAttributePtr;
struct _xmlSchemaAttribute {
    xmlSchemaTypeType type;
    struct _xmlSchemaAttribute *next;
    const xmlChar *name;
    const xmlChar *id;
    const xmlChar *ref;
    const xmlChar *refNs;
    const xmlChar *typeName;
    const xmlChar *typeNs;
    xmlSchemaAnnotPtr annot;

    xmlSchemaTypePtr base;
    int occurs;
    const xmlChar *defValue;
    xmlSchemaTypePtr subtypes;
    xmlNodePtr node;
    const xmlChar *targetNamespace;
    int flags;
    const xmlChar *refPrefix;
    xmlSchemaValPtr defVal;
    xmlSchemaAttributePtr refDecl;
};






typedef struct _xmlSchemaAttributeLink xmlSchemaAttributeLink;
typedef xmlSchemaAttributeLink *xmlSchemaAttributeLinkPtr;
struct _xmlSchemaAttributeLink {
    struct _xmlSchemaAttributeLink *next;
    struct _xmlSchemaAttribute *attr;
};
# 294 "./include/libxml/schemasInternals.h"
typedef struct _xmlSchemaWildcardNs xmlSchemaWildcardNs;
typedef xmlSchemaWildcardNs *xmlSchemaWildcardNsPtr;
struct _xmlSchemaWildcardNs {
    struct _xmlSchemaWildcardNs *next;
    const xmlChar *value;
};





typedef struct _xmlSchemaWildcard xmlSchemaWildcard;
typedef xmlSchemaWildcard *xmlSchemaWildcardPtr;
struct _xmlSchemaWildcard {
    xmlSchemaTypeType type;
    const xmlChar *id;
    xmlSchemaAnnotPtr annot;
    xmlNodePtr node;
    int minOccurs;
    int maxOccurs;
    int processContents;
    int any;
    xmlSchemaWildcardNsPtr nsSet;
    xmlSchemaWildcardNsPtr negNsSet;
    int flags;
};
# 359 "./include/libxml/schemasInternals.h"
typedef struct _xmlSchemaAttributeGroup xmlSchemaAttributeGroup;
typedef xmlSchemaAttributeGroup *xmlSchemaAttributeGroupPtr;
struct _xmlSchemaAttributeGroup {
    xmlSchemaTypeType type;
    struct _xmlSchemaAttribute *next;
    const xmlChar *name;
    const xmlChar *id;
    const xmlChar *ref;
    const xmlChar *refNs;
    xmlSchemaAnnotPtr annot;

    xmlSchemaAttributePtr attributes;
    xmlNodePtr node;
    int flags;
    xmlSchemaWildcardPtr attributeWildcard;
    const xmlChar *refPrefix;
    xmlSchemaAttributeGroupPtr refItem;
    const xmlChar *targetNamespace;
    void *attrUses;
};






typedef struct _xmlSchemaTypeLink xmlSchemaTypeLink;
typedef xmlSchemaTypeLink *xmlSchemaTypeLinkPtr;
struct _xmlSchemaTypeLink {
    struct _xmlSchemaTypeLink *next;
    xmlSchemaTypePtr type;
};





typedef struct _xmlSchemaFacetLink xmlSchemaFacetLink;
typedef xmlSchemaFacetLink *xmlSchemaFacetLinkPtr;
struct _xmlSchemaFacetLink {
    struct _xmlSchemaFacetLink *next;
    xmlSchemaFacetPtr facet;
};
# 602 "./include/libxml/schemasInternals.h"
struct _xmlSchemaType {
    xmlSchemaTypeType type;
    struct _xmlSchemaType *next;
    const xmlChar *name;
    const xmlChar *id ;
    const xmlChar *ref;
    const xmlChar *refNs;
    xmlSchemaAnnotPtr annot;
    xmlSchemaTypePtr subtypes;
    xmlSchemaAttributePtr attributes;
    xmlNodePtr node;
    int minOccurs;
    int maxOccurs;

    int flags;
    xmlSchemaContentType contentType;
    const xmlChar *base;
    const xmlChar *baseNs;
    xmlSchemaTypePtr baseType;
    xmlSchemaFacetPtr facets;
    struct _xmlSchemaType *redef;
    int recurse;
    xmlSchemaAttributeLinkPtr *attributeUses;
    xmlSchemaWildcardPtr attributeWildcard;
    int builtInType;
    xmlSchemaTypeLinkPtr memberTypes;
    xmlSchemaFacetLinkPtr facetSet;
    const xmlChar *refPrefix;
    xmlSchemaTypePtr contentTypeDef;

    xmlRegexpPtr contModel;
    const xmlChar *targetNamespace;
    void *attrUses;
};
# 763 "./include/libxml/schemasInternals.h"
typedef struct _xmlSchemaElement xmlSchemaElement;
typedef xmlSchemaElement *xmlSchemaElementPtr;
struct _xmlSchemaElement {
    xmlSchemaTypeType type;
    struct _xmlSchemaType *next;
    const xmlChar *name;
    const xmlChar *id;
    const xmlChar *ref;
    const xmlChar *refNs;
    xmlSchemaAnnotPtr annot;
    xmlSchemaTypePtr subtypes;
    xmlSchemaAttributePtr attributes;
    xmlNodePtr node;
    int minOccurs;
    int maxOccurs;

    int flags;
    const xmlChar *targetNamespace;
    const xmlChar *namedType;
    const xmlChar *namedTypeNs;
    const xmlChar *substGroup;
    const xmlChar *substGroupNs;
    const xmlChar *scope;
    const xmlChar *value;
    struct _xmlSchemaElement *refDecl;

    xmlRegexpPtr contModel;
    xmlSchemaContentType contentType;
    const xmlChar *refPrefix;
    xmlSchemaValPtr defVal;
    void *idcs;
};
# 823 "./include/libxml/schemasInternals.h"
struct _xmlSchemaFacet {
    xmlSchemaTypeType type;
    struct _xmlSchemaFacet *next;
    const xmlChar *value;
    const xmlChar *id;
    xmlSchemaAnnotPtr annot;
    xmlNodePtr node;
    int fixed;
    int whitespace;
    xmlSchemaValPtr val;
    xmlRegexpPtr regexp;
};




typedef struct _xmlSchemaNotation xmlSchemaNotation;
typedef xmlSchemaNotation *xmlSchemaNotationPtr;
struct _xmlSchemaNotation {
    xmlSchemaTypeType type;
    const xmlChar *name;
    xmlSchemaAnnotPtr annot;
    const xmlChar *identifier;
    const xmlChar *targetNamespace;
};
# 923 "./include/libxml/schemasInternals.h"
struct _xmlSchema {
    const xmlChar *name;
    const xmlChar *targetNamespace;
    const xmlChar *version;
    const xmlChar *id;
    xmlDocPtr doc;
    xmlSchemaAnnotPtr annot;
    int flags;

    xmlHashTablePtr typeDecl;
    xmlHashTablePtr attrDecl;
    xmlHashTablePtr attrgrpDecl;
    xmlHashTablePtr elemDecl;
    xmlHashTablePtr notaDecl;

    xmlHashTablePtr schemasImports;

    void *_private;
    xmlHashTablePtr groupDecl;
    xmlDictPtr dict;
    void *includes;
    int preserve;
    int counter;
    xmlHashTablePtr idcDef;
    void *volatiles;
};

 void xmlSchemaFreeType (xmlSchemaTypePtr type);
 void xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard);
# 183 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/schematron.h" 1
# 24 "./include/libxml/schematron.h"
typedef enum {
    XML_SCHEMATRON_OUT_QUIET = 1 << 0,
    XML_SCHEMATRON_OUT_TEXT = 1 << 1,
    XML_SCHEMATRON_OUT_XML = 1 << 2,
    XML_SCHEMATRON_OUT_ERROR = 1 << 3,
    XML_SCHEMATRON_OUT_FILE = 1 << 8,
    XML_SCHEMATRON_OUT_BUFFER = 1 << 9,
    XML_SCHEMATRON_OUT_IO = 1 << 10
} xmlSchematronValidOptions;




typedef struct _xmlSchematron xmlSchematron;
typedef xmlSchematron *xmlSchematronPtr;
# 48 "./include/libxml/schematron.h"
typedef void (*xmlSchematronValidityErrorFunc) (void *ctx, const char *msg, ...);
# 58 "./include/libxml/schematron.h"
typedef void (*xmlSchematronValidityWarningFunc) (void *ctx, const char *msg, ...);




typedef struct _xmlSchematronParserCtxt xmlSchematronParserCtxt;
typedef xmlSchematronParserCtxt *xmlSchematronParserCtxtPtr;

typedef struct _xmlSchematronValidCtxt xmlSchematronValidCtxt;
typedef xmlSchematronValidCtxt *xmlSchematronValidCtxtPtr;




 xmlSchematronParserCtxtPtr
     xmlSchematronNewParserCtxt (const char *URL);
 xmlSchematronParserCtxtPtr
     xmlSchematronNewMemParserCtxt(const char *buffer,
      int size);
 xmlSchematronParserCtxtPtr
     xmlSchematronNewDocParserCtxt(xmlDocPtr doc);
 void
     xmlSchematronFreeParserCtxt (xmlSchematronParserCtxtPtr ctxt);
# 95 "./include/libxml/schematron.h"
 xmlSchematronPtr
     xmlSchematronParse (xmlSchematronParserCtxtPtr ctxt);
 void
     xmlSchematronFree (xmlSchematronPtr schema);



 void
     xmlSchematronSetValidStructuredErrors(
                                   xmlSchematronValidCtxtPtr ctxt,
       xmlStructuredErrorFunc serror,
       void *ctx);
# 128 "./include/libxml/schematron.h"
 xmlSchematronValidCtxtPtr
     xmlSchematronNewValidCtxt (xmlSchematronPtr schema,
      int options);
 void
     xmlSchematronFreeValidCtxt (xmlSchematronValidCtxtPtr ctxt);
 int
     xmlSchematronValidateDoc (xmlSchematronValidCtxtPtr ctxt,
      xmlDocPtr instance);
# 184 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2

# 1 "./include/libxml/uri.h" 1
# 31 "./include/libxml/uri.h"
typedef struct _xmlURI xmlURI;
typedef xmlURI *xmlURIPtr;
struct _xmlURI {
    char *scheme;
    char *opaque;
    char *authority;
    char *server;
    char *user;
    int port;
    char *path;
    char *query;
    char *fragment;
    int cleanup;
    char *query_raw;
};






 xmlURIPtr
  xmlCreateURI (void);
 xmlChar *
  xmlBuildURI (const xmlChar *URI,
      const xmlChar *base);
 xmlChar *
  xmlBuildRelativeURI (const xmlChar *URI,
      const xmlChar *base);
 xmlURIPtr
  xmlParseURI (const char *str);
 xmlURIPtr
  xmlParseURIRaw (const char *str,
      int raw);
 int
  xmlParseURIReference (xmlURIPtr uri,
      const char *str);
 xmlChar *
  xmlSaveUri (xmlURIPtr uri);
 void
  xmlPrintURI (FILE *stream,
      xmlURIPtr uri);
 xmlChar *
  xmlURIEscapeStr (const xmlChar *str,
      const xmlChar *list);
 char *
  xmlURIUnescapeString (const char *str,
      int len,
      char *target);
 int
  xmlNormalizeURIPath (char *path);
 xmlChar *
  xmlURIEscape (const xmlChar *str);
 void
  xmlFreeURI (xmlURIPtr uri);
 xmlChar*
  xmlCanonicPath (const xmlChar *path);
 xmlChar*
  xmlPathToURI (const xmlChar *path);
# 186 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2

# 1 "./include/libxml/xinclude.h" 1
# 86 "./include/libxml/xinclude.h"
typedef struct _xmlXIncludeCtxt xmlXIncludeCtxt;
typedef xmlXIncludeCtxt *xmlXIncludeCtxtPtr;




 int
  xmlXIncludeProcess (xmlDocPtr doc);
 int
  xmlXIncludeProcessFlags (xmlDocPtr doc,
      int flags);
 int
  xmlXIncludeProcessFlagsData(xmlDocPtr doc,
      int flags,
      void *data);
 int
                xmlXIncludeProcessTreeFlagsData(xmlNodePtr tree,
                                         int flags,
                                         void *data);
 int
  xmlXIncludeProcessTree (xmlNodePtr tree);
 int
  xmlXIncludeProcessTreeFlags(xmlNodePtr tree,
      int flags);



 xmlXIncludeCtxtPtr
  xmlXIncludeNewContext (xmlDocPtr doc);
 int
  xmlXIncludeSetFlags (xmlXIncludeCtxtPtr ctxt,
      int flags);
 void
  xmlXIncludeFreeContext (xmlXIncludeCtxtPtr ctxt);
 int
  xmlXIncludeProcessNode (xmlXIncludeCtxtPtr ctxt,
      xmlNodePtr tree);
# 188 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2

# 1 "./include/libxml/xmlerror.h" 1
# 190 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/xmlreader.h" 1
# 18 "./include/libxml/xmlreader.h"
# 1 "./include/libxml/xmlschemas.h" 1
# 28 "./include/libxml/xmlschemas.h"
typedef enum {
    XML_SCHEMAS_ERR_OK = 0,
    XML_SCHEMAS_ERR_NOROOT = 1,
    XML_SCHEMAS_ERR_UNDECLAREDELEM,
    XML_SCHEMAS_ERR_NOTTOPLEVEL,
    XML_SCHEMAS_ERR_MISSING,
    XML_SCHEMAS_ERR_WRONGELEM,
    XML_SCHEMAS_ERR_NOTYPE,
    XML_SCHEMAS_ERR_NOROLLBACK,
    XML_SCHEMAS_ERR_ISABSTRACT,
    XML_SCHEMAS_ERR_NOTEMPTY,
    XML_SCHEMAS_ERR_ELEMCONT,
    XML_SCHEMAS_ERR_HAVEDEFAULT,
    XML_SCHEMAS_ERR_NOTNILLABLE,
    XML_SCHEMAS_ERR_EXTRACONTENT,
    XML_SCHEMAS_ERR_INVALIDATTR,
    XML_SCHEMAS_ERR_INVALIDELEM,
    XML_SCHEMAS_ERR_NOTDETERMINIST,
    XML_SCHEMAS_ERR_CONSTRUCT,
    XML_SCHEMAS_ERR_INTERNAL,
    XML_SCHEMAS_ERR_NOTSIMPLE,
    XML_SCHEMAS_ERR_ATTRUNKNOWN,
    XML_SCHEMAS_ERR_ATTRINVALID,
    XML_SCHEMAS_ERR_VALUE,
    XML_SCHEMAS_ERR_FACET,
    XML_SCHEMAS_ERR_,
    XML_SCHEMAS_ERR_XXX
} xmlSchemaValidError;
# 67 "./include/libxml/xmlschemas.h"
typedef enum {
    XML_SCHEMA_VAL_VC_I_CREATE = 1<<0



} xmlSchemaValidOption;
# 84 "./include/libxml/xmlschemas.h"
typedef struct _xmlSchema xmlSchema;
typedef xmlSchema *xmlSchemaPtr;
# 95 "./include/libxml/xmlschemas.h"
typedef void ( *xmlSchemaValidityErrorFunc)
                 (void *ctx, const char *msg, ...) __attribute__((__format__(__printf__,2,3)));
# 106 "./include/libxml/xmlschemas.h"
typedef void ( *xmlSchemaValidityWarningFunc)
                 (void *ctx, const char *msg, ...) __attribute__((__format__(__printf__,2,3)));




typedef struct _xmlSchemaParserCtxt xmlSchemaParserCtxt;
typedef xmlSchemaParserCtxt *xmlSchemaParserCtxtPtr;

typedef struct _xmlSchemaValidCtxt xmlSchemaValidCtxt;
typedef xmlSchemaValidCtxt *xmlSchemaValidCtxtPtr;
# 131 "./include/libxml/xmlschemas.h"
typedef int ( *xmlSchemaValidityLocatorFunc) (void *ctx,
                           const char **file, unsigned long *line);




 xmlSchemaParserCtxtPtr
     xmlSchemaNewParserCtxt (const char *URL);
 xmlSchemaParserCtxtPtr
     xmlSchemaNewMemParserCtxt (const char *buffer,
      int size);
 xmlSchemaParserCtxtPtr
     xmlSchemaNewDocParserCtxt (xmlDocPtr doc);
 void
     xmlSchemaFreeParserCtxt (xmlSchemaParserCtxtPtr ctxt);
 void
     xmlSchemaSetParserErrors (xmlSchemaParserCtxtPtr ctxt,
      xmlSchemaValidityErrorFunc err,
      xmlSchemaValidityWarningFunc warn,
      void *ctx);
 void
     xmlSchemaSetParserStructuredErrors(xmlSchemaParserCtxtPtr ctxt,
      xmlStructuredErrorFunc serror,
      void *ctx);
 int
  xmlSchemaGetParserErrors(xmlSchemaParserCtxtPtr ctxt,
     xmlSchemaValidityErrorFunc * err,
     xmlSchemaValidityWarningFunc * warn,
     void **ctx);
 int
  xmlSchemaIsValid (xmlSchemaValidCtxtPtr ctxt);

 xmlSchemaPtr
     xmlSchemaParse (xmlSchemaParserCtxtPtr ctxt);
 void
     xmlSchemaFree (xmlSchemaPtr schema);

 void
     xmlSchemaDump (FILE *output,
      xmlSchemaPtr schema);




 void
     xmlSchemaSetValidErrors (xmlSchemaValidCtxtPtr ctxt,
      xmlSchemaValidityErrorFunc err,
      xmlSchemaValidityWarningFunc warn,
      void *ctx);
 void
     xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,
      xmlStructuredErrorFunc serror,
      void *ctx);
 int
     xmlSchemaGetValidErrors (xmlSchemaValidCtxtPtr ctxt,
      xmlSchemaValidityErrorFunc *err,
      xmlSchemaValidityWarningFunc *warn,
      void **ctx);
 int
     xmlSchemaSetValidOptions (xmlSchemaValidCtxtPtr ctxt,
      int options);
 void
            xmlSchemaValidateSetFilename(xmlSchemaValidCtxtPtr vctxt,
                                  const char *filename);
 int
     xmlSchemaValidCtxtGetOptions(xmlSchemaValidCtxtPtr ctxt);

 xmlSchemaValidCtxtPtr
     xmlSchemaNewValidCtxt (xmlSchemaPtr schema);
 void
     xmlSchemaFreeValidCtxt (xmlSchemaValidCtxtPtr ctxt);
 int
     xmlSchemaValidateDoc (xmlSchemaValidCtxtPtr ctxt,
      xmlDocPtr instance);
 int
            xmlSchemaValidateOneElement (xmlSchemaValidCtxtPtr ctxt,
                    xmlNodePtr elem);
 int
     xmlSchemaValidateStream (xmlSchemaValidCtxtPtr ctxt,
      xmlParserInputBufferPtr input,
      xmlCharEncoding enc,
      xmlSAXHandlerPtr sax,
      void *user_data);
 int
     xmlSchemaValidateFile (xmlSchemaValidCtxtPtr ctxt,
      const char * filename,
      int options);

 xmlParserCtxtPtr
     xmlSchemaValidCtxtGetParserCtxt(xmlSchemaValidCtxtPtr ctxt);




typedef struct _xmlSchemaSAXPlug xmlSchemaSAXPlugStruct;
typedef xmlSchemaSAXPlugStruct *xmlSchemaSAXPlugPtr;

 xmlSchemaSAXPlugPtr
            xmlSchemaSAXPlug (xmlSchemaValidCtxtPtr ctxt,
      xmlSAXHandlerPtr *sax,
      void **user_data);
 int
            xmlSchemaSAXUnplug (xmlSchemaSAXPlugPtr plug);


 void
            xmlSchemaValidateSetLocator (xmlSchemaValidCtxtPtr vctxt,
      xmlSchemaValidityLocatorFunc f,
      void *ctxt);
# 19 "./include/libxml/xmlreader.h" 2
# 31 "./include/libxml/xmlreader.h"
typedef enum {
    XML_PARSER_SEVERITY_VALIDITY_WARNING = 1,
    XML_PARSER_SEVERITY_VALIDITY_ERROR = 2,
    XML_PARSER_SEVERITY_WARNING = 3,
    XML_PARSER_SEVERITY_ERROR = 4
} xmlParserSeverities;
# 45 "./include/libxml/xmlreader.h"
typedef enum {
    XML_TEXTREADER_MODE_INITIAL = 0,
    XML_TEXTREADER_MODE_INTERACTIVE = 1,
    XML_TEXTREADER_MODE_ERROR = 2,
    XML_TEXTREADER_MODE_EOF =3,
    XML_TEXTREADER_MODE_CLOSED = 4,
    XML_TEXTREADER_MODE_READING = 5
} xmlTextReaderMode;
# 61 "./include/libxml/xmlreader.h"
typedef enum {
    XML_PARSER_LOADDTD = 1,
    XML_PARSER_DEFAULTATTRS = 2,
    XML_PARSER_VALIDATE = 3,
    XML_PARSER_SUBST_ENTITIES = 4
} xmlParserProperties;






typedef enum {
    XML_READER_TYPE_NONE = 0,
    XML_READER_TYPE_ELEMENT = 1,
    XML_READER_TYPE_ATTRIBUTE = 2,
    XML_READER_TYPE_TEXT = 3,
    XML_READER_TYPE_CDATA = 4,
    XML_READER_TYPE_ENTITY_REFERENCE = 5,
    XML_READER_TYPE_ENTITY = 6,
    XML_READER_TYPE_PROCESSING_INSTRUCTION = 7,
    XML_READER_TYPE_COMMENT = 8,
    XML_READER_TYPE_DOCUMENT = 9,
    XML_READER_TYPE_DOCUMENT_TYPE = 10,
    XML_READER_TYPE_DOCUMENT_FRAGMENT = 11,
    XML_READER_TYPE_NOTATION = 12,
    XML_READER_TYPE_WHITESPACE = 13,
    XML_READER_TYPE_SIGNIFICANT_WHITESPACE = 14,
    XML_READER_TYPE_END_ELEMENT = 15,
    XML_READER_TYPE_END_ENTITY = 16,
    XML_READER_TYPE_XML_DECLARATION = 17
} xmlReaderTypes;






typedef struct _xmlTextReader xmlTextReader;






typedef xmlTextReader *xmlTextReaderPtr;




 xmlTextReaderPtr
   xmlNewTextReader (xmlParserInputBufferPtr input,
                                          const char *URI);
 xmlTextReaderPtr
   xmlNewTextReaderFilename(const char *URI);

 void
   xmlFreeTextReader (xmlTextReaderPtr reader);

 int
            xmlTextReaderSetup(xmlTextReaderPtr reader,
                   xmlParserInputBufferPtr input, const char *URL,
                   const char *encoding, int options);




 int
   xmlTextReaderRead (xmlTextReaderPtr reader);


 xmlChar *
   xmlTextReaderReadInnerXml(xmlTextReaderPtr reader);

 xmlChar *
   xmlTextReaderReadOuterXml(xmlTextReaderPtr reader);


 xmlChar *
   xmlTextReaderReadString (xmlTextReaderPtr reader);
 int
   xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader);




 int
   xmlTextReaderAttributeCount(xmlTextReaderPtr reader);
 int
   xmlTextReaderDepth (xmlTextReaderPtr reader);
 int
   xmlTextReaderHasAttributes(xmlTextReaderPtr reader);
 int
   xmlTextReaderHasValue(xmlTextReaderPtr reader);
 int
   xmlTextReaderIsDefault (xmlTextReaderPtr reader);
 int
   xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader);
 int
   xmlTextReaderNodeType (xmlTextReaderPtr reader);
 int
   xmlTextReaderQuoteChar (xmlTextReaderPtr reader);
 int
   xmlTextReaderReadState (xmlTextReaderPtr reader);
 int
                        xmlTextReaderIsNamespaceDecl(xmlTextReaderPtr reader);

 const xmlChar *
      xmlTextReaderConstBaseUri (xmlTextReaderPtr reader);
 const xmlChar *
      xmlTextReaderConstLocalName (xmlTextReaderPtr reader);
 const xmlChar *
      xmlTextReaderConstName (xmlTextReaderPtr reader);
 const xmlChar *
      xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader);
 const xmlChar *
      xmlTextReaderConstPrefix (xmlTextReaderPtr reader);
 const xmlChar *
      xmlTextReaderConstXmlLang (xmlTextReaderPtr reader);
 const xmlChar *
      xmlTextReaderConstString (xmlTextReaderPtr reader,
       const xmlChar *str);
 const xmlChar *
      xmlTextReaderConstValue (xmlTextReaderPtr reader);





 xmlChar *
   xmlTextReaderBaseUri (xmlTextReaderPtr reader);
 xmlChar *
   xmlTextReaderLocalName (xmlTextReaderPtr reader);
 xmlChar *
   xmlTextReaderName (xmlTextReaderPtr reader);
 xmlChar *
   xmlTextReaderNamespaceUri(xmlTextReaderPtr reader);
 xmlChar *
   xmlTextReaderPrefix (xmlTextReaderPtr reader);
 xmlChar *
   xmlTextReaderXmlLang (xmlTextReaderPtr reader);
 xmlChar *
   xmlTextReaderValue (xmlTextReaderPtr reader);




 int
      xmlTextReaderClose (xmlTextReaderPtr reader);
 xmlChar *
      xmlTextReaderGetAttributeNo (xmlTextReaderPtr reader,
       int no);
 xmlChar *
      xmlTextReaderGetAttribute (xmlTextReaderPtr reader,
       const xmlChar *name);
 xmlChar *
      xmlTextReaderGetAttributeNs (xmlTextReaderPtr reader,
       const xmlChar *localName,
       const xmlChar *namespaceURI);
 xmlParserInputBufferPtr
      xmlTextReaderGetRemainder (xmlTextReaderPtr reader);
 xmlChar *
      xmlTextReaderLookupNamespace(xmlTextReaderPtr reader,
       const xmlChar *prefix);
 int
      xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader,
       int no);
 int
      xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader,
       const xmlChar *name);
 int
      xmlTextReaderMoveToAttributeNs(xmlTextReaderPtr reader,
       const xmlChar *localName,
       const xmlChar *namespaceURI);
 int
      xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader);
 int
      xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader);
 int
      xmlTextReaderMoveToElement (xmlTextReaderPtr reader);
 int
      xmlTextReaderNormalization (xmlTextReaderPtr reader);
 const xmlChar *
      xmlTextReaderConstEncoding (xmlTextReaderPtr reader);




 int
      xmlTextReaderSetParserProp (xmlTextReaderPtr reader,
       int prop,
       int value);
 int
      xmlTextReaderGetParserProp (xmlTextReaderPtr reader,
       int prop);
 xmlNodePtr
      xmlTextReaderCurrentNode (xmlTextReaderPtr reader);

 int
            xmlTextReaderGetParserLineNumber(xmlTextReaderPtr reader);

 int
            xmlTextReaderGetParserColumnNumber(xmlTextReaderPtr reader);

 xmlNodePtr
      xmlTextReaderPreserve (xmlTextReaderPtr reader);

 int
      xmlTextReaderPreservePattern(xmlTextReaderPtr reader,
       const xmlChar *pattern,
       const xmlChar **namespaces);

 xmlDocPtr
      xmlTextReaderCurrentDoc (xmlTextReaderPtr reader);
 xmlNodePtr
      xmlTextReaderExpand (xmlTextReaderPtr reader);
 int
      xmlTextReaderNext (xmlTextReaderPtr reader);
 int
      xmlTextReaderNextSibling (xmlTextReaderPtr reader);
 int
      xmlTextReaderIsValid (xmlTextReaderPtr reader);

 int
      xmlTextReaderRelaxNGValidate(xmlTextReaderPtr reader,
       const char *rng);
 int
      xmlTextReaderRelaxNGValidateCtxt(xmlTextReaderPtr reader,
       xmlRelaxNGValidCtxtPtr ctxt,
       int options);

 int
      xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader,
       xmlRelaxNGPtr schema);
 int
      xmlTextReaderSchemaValidate (xmlTextReaderPtr reader,
       const char *xsd);
 int
      xmlTextReaderSchemaValidateCtxt(xmlTextReaderPtr reader,
       xmlSchemaValidCtxtPtr ctxt,
       int options);
 int
      xmlTextReaderSetSchema (xmlTextReaderPtr reader,
       xmlSchemaPtr schema);

 const xmlChar *
      xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader);
 int
      xmlTextReaderStandalone (xmlTextReaderPtr reader);





 long
  xmlTextReaderByteConsumed (xmlTextReaderPtr reader);




 xmlTextReaderPtr
  xmlReaderWalker (xmlDocPtr doc);
 xmlTextReaderPtr
  xmlReaderForDoc (const xmlChar * cur,
      const char *URL,
      const char *encoding,
      int options);
 xmlTextReaderPtr
  xmlReaderForFile (const char *filename,
      const char *encoding,
      int options);
 xmlTextReaderPtr
  xmlReaderForMemory (const char *buffer,
      int size,
      const char *URL,
      const char *encoding,
      int options);
 xmlTextReaderPtr
  xmlReaderForFd (int fd,
      const char *URL,
      const char *encoding,
      int options);
 xmlTextReaderPtr
  xmlReaderForIO (xmlInputReadCallback ioread,
      xmlInputCloseCallback ioclose,
      void *ioctx,
      const char *URL,
      const char *encoding,
      int options);

 int
  xmlReaderNewWalker (xmlTextReaderPtr reader,
      xmlDocPtr doc);
 int
  xmlReaderNewDoc (xmlTextReaderPtr reader,
      const xmlChar * cur,
      const char *URL,
      const char *encoding,
      int options);
 int
  xmlReaderNewFile (xmlTextReaderPtr reader,
      const char *filename,
      const char *encoding,
      int options);
 int
  xmlReaderNewMemory (xmlTextReaderPtr reader,
      const char *buffer,
      int size,
      const char *URL,
      const char *encoding,
      int options);
 int
  xmlReaderNewFd (xmlTextReaderPtr reader,
      int fd,
      const char *URL,
      const char *encoding,
      int options);
 int
  xmlReaderNewIO (xmlTextReaderPtr reader,
      xmlInputReadCallback ioread,
      xmlInputCloseCallback ioclose,
      void *ioctx,
      const char *URL,
      const char *encoding,
      int options);



typedef void * xmlTextReaderLocatorPtr;
# 400 "./include/libxml/xmlreader.h"
typedef void ( *xmlTextReaderErrorFunc)(void *arg,
            const char *msg,
            xmlParserSeverities severity,
            xmlTextReaderLocatorPtr locator);
 int
     xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator);
 xmlChar *
     xmlTextReaderLocatorBaseURI (xmlTextReaderLocatorPtr locator);
 void
     xmlTextReaderSetErrorHandler(xmlTextReaderPtr reader,
      xmlTextReaderErrorFunc f,
      void *arg);
 void
     xmlTextReaderSetStructuredErrorHandler(xmlTextReaderPtr reader,
         xmlStructuredErrorFunc f,
         void *arg);
 void
     xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,
      xmlTextReaderErrorFunc *f,
      void **arg);
# 191 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/xmlsave.h" 1
# 29 "./include/libxml/xmlsave.h"
typedef enum {
    XML_SAVE_FORMAT = 1<<0,
    XML_SAVE_NO_DECL = 1<<1,
    XML_SAVE_NO_EMPTY = 1<<2,
    XML_SAVE_NO_XHTML = 1<<3,
    XML_SAVE_XHTML = 1<<4,
    XML_SAVE_AS_XML = 1<<5,
    XML_SAVE_AS_HTML = 1<<6,
    XML_SAVE_WSNONSIG = 1<<7
} xmlSaveOption;


typedef struct _xmlSaveCtxt xmlSaveCtxt;
typedef xmlSaveCtxt *xmlSaveCtxtPtr;

 xmlSaveCtxtPtr
  xmlSaveToFd (int fd,
      const char *encoding,
      int options);
 xmlSaveCtxtPtr
  xmlSaveToFilename (const char *filename,
      const char *encoding,
      int options);

 xmlSaveCtxtPtr
  xmlSaveToBuffer (xmlBufferPtr buffer,
      const char *encoding,
      int options);

 xmlSaveCtxtPtr
  xmlSaveToIO (xmlOutputWriteCallback iowrite,
      xmlOutputCloseCallback ioclose,
      void *ioctx,
      const char *encoding,
      int options);

 long
  xmlSaveDoc (xmlSaveCtxtPtr ctxt,
      xmlDocPtr doc);
 long
  xmlSaveTree (xmlSaveCtxtPtr ctxt,
      xmlNodePtr node);

 int
  xmlSaveFlush (xmlSaveCtxtPtr ctxt);
 int
  xmlSaveClose (xmlSaveCtxtPtr ctxt);
 int
  xmlSaveSetEscape (xmlSaveCtxtPtr ctxt,
      xmlCharEncodingOutputFunc escape);
 int
  xmlSaveSetAttrEscape (xmlSaveCtxtPtr ctxt,
      xmlCharEncodingOutputFunc escape);
# 192 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2

# 1 "./include/libxml/xmlschemastypes.h" 1
# 26 "./include/libxml/xmlschemastypes.h"
typedef enum {
    XML_SCHEMA_WHITESPACE_UNKNOWN = 0,
    XML_SCHEMA_WHITESPACE_PRESERVE = 1,
    XML_SCHEMA_WHITESPACE_REPLACE = 2,
    XML_SCHEMA_WHITESPACE_COLLAPSE = 3
} xmlSchemaWhitespaceValueType;

 void
  xmlSchemaInitTypes (void);
 void
  xmlSchemaCleanupTypes (void);
 xmlSchemaTypePtr
  xmlSchemaGetPredefinedType (const xmlChar *name,
       const xmlChar *ns);
 int
  xmlSchemaValidatePredefinedType (xmlSchemaTypePtr type,
       const xmlChar *value,
       xmlSchemaValPtr *val);
 int
  xmlSchemaValPredefTypeNode (xmlSchemaTypePtr type,
       const xmlChar *value,
       xmlSchemaValPtr *val,
       xmlNodePtr node);
 int
  xmlSchemaValidateFacet (xmlSchemaTypePtr base,
       xmlSchemaFacetPtr facet,
       const xmlChar *value,
       xmlSchemaValPtr val);
 int
  xmlSchemaValidateFacetWhtsp (xmlSchemaFacetPtr facet,
       xmlSchemaWhitespaceValueType fws,
       xmlSchemaValType valType,
       const xmlChar *value,
       xmlSchemaValPtr val,
       xmlSchemaWhitespaceValueType ws);
 void
  xmlSchemaFreeValue (xmlSchemaValPtr val);
 xmlSchemaFacetPtr
  xmlSchemaNewFacet (void);
 int
  xmlSchemaCheckFacet (xmlSchemaFacetPtr facet,
       xmlSchemaTypePtr typeDecl,
       xmlSchemaParserCtxtPtr ctxt,
       const xmlChar *name);
 void
  xmlSchemaFreeFacet (xmlSchemaFacetPtr facet);
 int
  xmlSchemaCompareValues (xmlSchemaValPtr x,
       xmlSchemaValPtr y);
 xmlSchemaTypePtr
    xmlSchemaGetBuiltInListSimpleTypeItemType (xmlSchemaTypePtr type);
 int
    xmlSchemaValidateListSimpleTypeFacet (xmlSchemaFacetPtr facet,
       const xmlChar *value,
       unsigned long actualLen,
       unsigned long *expectedLen);
 xmlSchemaTypePtr
  xmlSchemaGetBuiltInType (xmlSchemaValType type);
 int
  xmlSchemaIsBuiltInTypeFacet (xmlSchemaTypePtr type,
       int facetType);
 xmlChar *
  xmlSchemaCollapseString (const xmlChar *value);
 xmlChar *
  xmlSchemaWhiteSpaceReplace (const xmlChar *value);
 unsigned long
  xmlSchemaGetFacetValueAsULong (xmlSchemaFacetPtr facet);
 int
  xmlSchemaValidateLengthFacet (xmlSchemaTypePtr type,
       xmlSchemaFacetPtr facet,
       const xmlChar *value,
       xmlSchemaValPtr val,
       unsigned long *length);
 int
  xmlSchemaValidateLengthFacetWhtsp(xmlSchemaFacetPtr facet,
        xmlSchemaValType valType,
        const xmlChar *value,
        xmlSchemaValPtr val,
        unsigned long *length,
        xmlSchemaWhitespaceValueType ws);
 int
  xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type,
       const xmlChar *value,
       xmlSchemaValPtr *val,
       xmlNodePtr node);
 int
  xmlSchemaGetCanonValue (xmlSchemaValPtr val,
       const xmlChar **retValue);
 int
  xmlSchemaGetCanonValueWhtsp (xmlSchemaValPtr val,
       const xmlChar **retValue,
       xmlSchemaWhitespaceValueType ws);
 int
  xmlSchemaValueAppend (xmlSchemaValPtr prev,
       xmlSchemaValPtr cur);
 xmlSchemaValPtr
  xmlSchemaValueGetNext (xmlSchemaValPtr cur);
 const xmlChar *
  xmlSchemaValueGetAsString (xmlSchemaValPtr val);
 int
  xmlSchemaValueGetAsBoolean (xmlSchemaValPtr val);
 xmlSchemaValPtr
  xmlSchemaNewStringValue (xmlSchemaValType type,
       const xmlChar *value);
 xmlSchemaValPtr
  xmlSchemaNewNOTATIONValue (const xmlChar *name,
       const xmlChar *ns);
 xmlSchemaValPtr
  xmlSchemaNewQNameValue (const xmlChar *namespaceName,
       const xmlChar *localName);
 int
  xmlSchemaCompareValuesWhtsp (xmlSchemaValPtr x,
       xmlSchemaWhitespaceValueType xws,
       xmlSchemaValPtr y,
       xmlSchemaWhitespaceValueType yws);
 xmlSchemaValPtr
  xmlSchemaCopyValue (xmlSchemaValPtr val);
 xmlSchemaValType
  xmlSchemaGetValType (xmlSchemaValPtr val);
# 194 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2

# 1 "./include/libxml/xmlwriter.h" 1
# 26 "./include/libxml/xmlwriter.h"
    typedef struct _xmlTextWriter xmlTextWriter;
    typedef xmlTextWriter *xmlTextWriterPtr;




    xmlTextWriterPtr
        xmlNewTextWriter(xmlOutputBufferPtr out);
    xmlTextWriterPtr
        xmlNewTextWriterFilename(const char *uri, int compression);
    xmlTextWriterPtr
        xmlNewTextWriterMemory(xmlBufferPtr buf, int compression);
    xmlTextWriterPtr
        xmlNewTextWriterPushParser(xmlParserCtxtPtr ctxt, int compression);
    xmlTextWriterPtr
        xmlNewTextWriterDoc(xmlDocPtr * doc, int compression);
    xmlTextWriterPtr
        xmlNewTextWriterTree(xmlDocPtr doc, xmlNodePtr node,
                             int compression);
    void xmlFreeTextWriter(xmlTextWriterPtr writer);
# 55 "./include/libxml/xmlwriter.h"
    int
        xmlTextWriterStartDocument(xmlTextWriterPtr writer,
                                   const char *version,
                                   const char *encoding,
                                   const char *standalone);
    int xmlTextWriterEndDocument(xmlTextWriterPtr
                                                   writer);




    int xmlTextWriterStartComment(xmlTextWriterPtr
                                                    writer);
    int xmlTextWriterEndComment(xmlTextWriterPtr writer);
    int
        xmlTextWriterWriteFormatComment(xmlTextWriterPtr writer,
                                        const char *format, ...)
     __attribute__((__format__(__printf__,2,3)));
    int
        xmlTextWriterWriteVFormatComment(xmlTextWriterPtr writer,
                                         const char *format,
                                         va_list argptr)
      __attribute__((__format__(__printf__,2,0)));
    int xmlTextWriterWriteComment(xmlTextWriterPtr
                                                    writer,
                                                    const xmlChar *
                                                    content);




    int
        xmlTextWriterStartElement(xmlTextWriterPtr writer,
                                  const xmlChar * name);
    int xmlTextWriterStartElementNS(xmlTextWriterPtr
                                                      writer,
                                                      const xmlChar *
                                                      prefix,
                                                      const xmlChar * name,
                                                      const xmlChar *
                                                      namespaceURI);
    int xmlTextWriterEndElement(xmlTextWriterPtr writer);
    int xmlTextWriterFullEndElement(xmlTextWriterPtr
                                                      writer);




    int
        xmlTextWriterWriteFormatElement(xmlTextWriterPtr writer,
                                        const xmlChar * name,
                                        const char *format, ...)
     __attribute__((__format__(__printf__,3,4)));
    int
        xmlTextWriterWriteVFormatElement(xmlTextWriterPtr writer,
                                         const xmlChar * name,
                                         const char *format,
                                         va_list argptr)
      __attribute__((__format__(__printf__,3,0)));
    int xmlTextWriterWriteElement(xmlTextWriterPtr
                                                    writer,
                                                    const xmlChar * name,
                                                    const xmlChar *
                                                    content);
    int
        xmlTextWriterWriteFormatElementNS(xmlTextWriterPtr writer,
                                          const xmlChar * prefix,
                                          const xmlChar * name,
                                          const xmlChar * namespaceURI,
                                          const char *format, ...)
       __attribute__((__format__(__printf__,5,6)));
    int
        xmlTextWriterWriteVFormatElementNS(xmlTextWriterPtr writer,
                                           const xmlChar * prefix,
                                           const xmlChar * name,
                                           const xmlChar * namespaceURI,
                                           const char *format,
                                           va_list argptr)
        __attribute__((__format__(__printf__,5,0)));
    int xmlTextWriterWriteElementNS(xmlTextWriterPtr
                                                      writer,
                                                      const xmlChar *
                                                      prefix,
                                                      const xmlChar * name,
                                                      const xmlChar *
                                                      namespaceURI,
                                                      const xmlChar *
                                                      content);




    int
        xmlTextWriterWriteFormatRaw(xmlTextWriterPtr writer,
                                    const char *format, ...)
        __attribute__((__format__(__printf__,2,3)));
    int
        xmlTextWriterWriteVFormatRaw(xmlTextWriterPtr writer,
                                     const char *format, va_list argptr)
         __attribute__((__format__(__printf__,2,0)));
    int
        xmlTextWriterWriteRawLen(xmlTextWriterPtr writer,
                                 const xmlChar * content, int len);
    int
        xmlTextWriterWriteRaw(xmlTextWriterPtr writer,
                              const xmlChar * content);
    int xmlTextWriterWriteFormatString(xmlTextWriterPtr
                                                         writer,
                                                         const char
                                                         *format, ...)
        __attribute__((__format__(__printf__,2,3)));
    int xmlTextWriterWriteVFormatString(xmlTextWriterPtr
                                                          writer,
                                                          const char
                                                          *format,
                                                          va_list argptr)
         __attribute__((__format__(__printf__,2,0)));
    int xmlTextWriterWriteString(xmlTextWriterPtr writer,
                                                   const xmlChar *
                                                   content);
    int xmlTextWriterWriteBase64(xmlTextWriterPtr writer,
                                                   const char *data,
                                                   int start, int len);
    int xmlTextWriterWriteBinHex(xmlTextWriterPtr writer,
                                                   const char *data,
                                                   int start, int len);




    int
        xmlTextWriterStartAttribute(xmlTextWriterPtr writer,
                                    const xmlChar * name);
    int xmlTextWriterStartAttributeNS(xmlTextWriterPtr
                                                        writer,
                                                        const xmlChar *
                                                        prefix,
                                                        const xmlChar *
                                                        name,
                                                        const xmlChar *
                                                        namespaceURI);
    int xmlTextWriterEndAttribute(xmlTextWriterPtr
                                                    writer);




    int
        xmlTextWriterWriteFormatAttribute(xmlTextWriterPtr writer,
                                          const xmlChar * name,
                                          const char *format, ...)
       __attribute__((__format__(__printf__,3,4)));
    int
        xmlTextWriterWriteVFormatAttribute(xmlTextWriterPtr writer,
                                           const xmlChar * name,
                                           const char *format,
                                           va_list argptr)
        __attribute__((__format__(__printf__,3,0)));
    int xmlTextWriterWriteAttribute(xmlTextWriterPtr
                                                      writer,
                                                      const xmlChar * name,
                                                      const xmlChar *
                                                      content);
    int
        xmlTextWriterWriteFormatAttributeNS(xmlTextWriterPtr writer,
                                            const xmlChar * prefix,
                                            const xmlChar * name,
                                            const xmlChar * namespaceURI,
                                            const char *format, ...)
         __attribute__((__format__(__printf__,5,6)));
    int
        xmlTextWriterWriteVFormatAttributeNS(xmlTextWriterPtr writer,
                                             const xmlChar * prefix,
                                             const xmlChar * name,
                                             const xmlChar * namespaceURI,
                                             const char *format,
                                             va_list argptr)
          __attribute__((__format__(__printf__,5,0)));
    int xmlTextWriterWriteAttributeNS(xmlTextWriterPtr
                                                        writer,
                                                        const xmlChar *
                                                        prefix,
                                                        const xmlChar *
                                                        name,
                                                        const xmlChar *
                                                        namespaceURI,
                                                        const xmlChar *
                                                        content);




    int
        xmlTextWriterStartPI(xmlTextWriterPtr writer,
                             const xmlChar * target);
    int xmlTextWriterEndPI(xmlTextWriterPtr writer);




    int
        xmlTextWriterWriteFormatPI(xmlTextWriterPtr writer,
                                   const xmlChar * target,
                                   const char *format, ...)
       __attribute__((__format__(__printf__,3,4)));
    int
        xmlTextWriterWriteVFormatPI(xmlTextWriterPtr writer,
                                    const xmlChar * target,
                                    const char *format, va_list argptr)
        __attribute__((__format__(__printf__,3,0)));
    int
        xmlTextWriterWritePI(xmlTextWriterPtr writer,
                             const xmlChar * target,
                             const xmlChar * content);
# 280 "./include/libxml/xmlwriter.h"
    int xmlTextWriterStartCDATA(xmlTextWriterPtr writer);
    int xmlTextWriterEndCDATA(xmlTextWriterPtr writer);




    int
        xmlTextWriterWriteFormatCDATA(xmlTextWriterPtr writer,
                                      const char *format, ...)
          __attribute__((__format__(__printf__,2,3)));
    int
        xmlTextWriterWriteVFormatCDATA(xmlTextWriterPtr writer,
                                       const char *format, va_list argptr)
           __attribute__((__format__(__printf__,2,0)));
    int
        xmlTextWriterWriteCDATA(xmlTextWriterPtr writer,
                                const xmlChar * content);




    int
        xmlTextWriterStartDTD(xmlTextWriterPtr writer,
                              const xmlChar * name,
                              const xmlChar * pubid,
                              const xmlChar * sysid);
    int xmlTextWriterEndDTD(xmlTextWriterPtr writer);




    int
        xmlTextWriterWriteFormatDTD(xmlTextWriterPtr writer,
                                    const xmlChar * name,
                                    const xmlChar * pubid,
                                    const xmlChar * sysid,
                                    const char *format, ...)
        __attribute__((__format__(__printf__,5,6)));
    int
        xmlTextWriterWriteVFormatDTD(xmlTextWriterPtr writer,
                                     const xmlChar * name,
                                     const xmlChar * pubid,
                                     const xmlChar * sysid,
                                     const char *format, va_list argptr)
         __attribute__((__format__(__printf__,5,0)));
    int
        xmlTextWriterWriteDTD(xmlTextWriterPtr writer,
                              const xmlChar * name,
                              const xmlChar * pubid,
                              const xmlChar * sysid,
                              const xmlChar * subset);
# 342 "./include/libxml/xmlwriter.h"
    int
        xmlTextWriterStartDTDElement(xmlTextWriterPtr writer,
                                     const xmlChar * name);
    int xmlTextWriterEndDTDElement(xmlTextWriterPtr
                                                     writer);




    int
        xmlTextWriterWriteFormatDTDElement(xmlTextWriterPtr writer,
                                           const xmlChar * name,
                                           const char *format, ...)
        __attribute__((__format__(__printf__,3,4)));
    int
        xmlTextWriterWriteVFormatDTDElement(xmlTextWriterPtr writer,
                                            const xmlChar * name,
                                            const char *format,
                                            va_list argptr)
         __attribute__((__format__(__printf__,3,0)));
    int xmlTextWriterWriteDTDElement(xmlTextWriterPtr
                                                       writer,
                                                       const xmlChar *
                                                       name,
                                                       const xmlChar *
                                                       content);




    int
        xmlTextWriterStartDTDAttlist(xmlTextWriterPtr writer,
                                     const xmlChar * name);
    int xmlTextWriterEndDTDAttlist(xmlTextWriterPtr
                                                     writer);




    int
        xmlTextWriterWriteFormatDTDAttlist(xmlTextWriterPtr writer,
                                           const xmlChar * name,
                                           const char *format, ...)
        __attribute__((__format__(__printf__,3,4)));
    int
        xmlTextWriterWriteVFormatDTDAttlist(xmlTextWriterPtr writer,
                                            const xmlChar * name,
                                            const char *format,
                                            va_list argptr)
         __attribute__((__format__(__printf__,3,0)));
    int xmlTextWriterWriteDTDAttlist(xmlTextWriterPtr
                                                       writer,
                                                       const xmlChar *
                                                       name,
                                                       const xmlChar *
                                                       content);




    int
        xmlTextWriterStartDTDEntity(xmlTextWriterPtr writer,
                                    int pe, const xmlChar * name);
    int xmlTextWriterEndDTDEntity(xmlTextWriterPtr
                                                    writer);




    int
        xmlTextWriterWriteFormatDTDInternalEntity(xmlTextWriterPtr writer,
                                                  int pe,
                                                  const xmlChar * name,
                                                  const char *format, ...)
        __attribute__((__format__(__printf__,4,5)));
    int
        xmlTextWriterWriteVFormatDTDInternalEntity(xmlTextWriterPtr writer,
                                                   int pe,
                                                   const xmlChar * name,
                                                   const char *format,
                                                   va_list argptr)
         __attribute__((__format__(__printf__,4,0)));
    int
        xmlTextWriterWriteDTDInternalEntity(xmlTextWriterPtr writer,
                                            int pe,
                                            const xmlChar * name,
                                            const xmlChar * content);
    int
        xmlTextWriterWriteDTDExternalEntity(xmlTextWriterPtr writer,
                                            int pe,
                                            const xmlChar * name,
                                            const xmlChar * pubid,
                                            const xmlChar * sysid,
                                            const xmlChar * ndataid);
    int
        xmlTextWriterWriteDTDExternalEntityContents(xmlTextWriterPtr
                                                    writer,
                                                    const xmlChar * pubid,
                                                    const xmlChar * sysid,
                                                    const xmlChar *
                                                    ndataid);
    int xmlTextWriterWriteDTDEntity(xmlTextWriterPtr
                                                      writer, int pe,
                                                      const xmlChar * name,
                                                      const xmlChar *
                                                      pubid,
                                                      const xmlChar *
                                                      sysid,
                                                      const xmlChar *
                                                      ndataid,
                                                      const xmlChar *
                                                      content);




    int
        xmlTextWriterWriteDTDNotation(xmlTextWriterPtr writer,
                                      const xmlChar * name,
                                      const xmlChar * pubid,
                                      const xmlChar * sysid);




    int
        xmlTextWriterSetIndent(xmlTextWriterPtr writer, int indent);
    int
        xmlTextWriterSetIndentString(xmlTextWriterPtr writer,
                                     const xmlChar * str);

    int
        xmlTextWriterSetQuoteChar(xmlTextWriterPtr writer, xmlChar quotechar);





    int xmlTextWriterFlush(xmlTextWriterPtr writer);
# 196 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/xpath.h" 1
# 26 "./include/libxml/xpath.h"
# 1 "./include/libxml/xmlerror.h" 1
# 27 "./include/libxml/xpath.h" 2
# 39 "./include/libxml/xpath.h"
typedef struct _xmlXPathContext xmlXPathContext;
typedef xmlXPathContext *xmlXPathContextPtr;
typedef struct _xmlXPathParserContext xmlXPathParserContext;
typedef xmlXPathParserContext *xmlXPathParserContextPtr;





typedef enum {
    XPATH_EXPRESSION_OK = 0,
    XPATH_NUMBER_ERROR,
    XPATH_UNFINISHED_LITERAL_ERROR,
    XPATH_START_LITERAL_ERROR,
    XPATH_VARIABLE_REF_ERROR,
    XPATH_UNDEF_VARIABLE_ERROR,
    XPATH_INVALID_PREDICATE_ERROR,
    XPATH_EXPR_ERROR,
    XPATH_UNCLOSED_ERROR,
    XPATH_UNKNOWN_FUNC_ERROR,
    XPATH_INVALID_OPERAND,
    XPATH_INVALID_TYPE,
    XPATH_INVALID_ARITY,
    XPATH_INVALID_CTXT_SIZE,
    XPATH_INVALID_CTXT_POSITION,
    XPATH_MEMORY_ERROR,
    XPTR_SYNTAX_ERROR,
    XPTR_RESOURCE_ERROR,
    XPTR_SUB_RESOURCE_ERROR,
    XPATH_UNDEF_PREFIX_ERROR,
    XPATH_ENCODING_ERROR,
    XPATH_INVALID_CHAR_ERROR,
    XPATH_INVALID_CTXT,
    XPATH_STACK_ERROR,
    XPATH_FORBID_VARIABLE_ERROR
} xmlXPathError;




typedef struct _xmlNodeSet xmlNodeSet;
typedef xmlNodeSet *xmlNodeSetPtr;
struct _xmlNodeSet {
    int nodeNr;
    int nodeMax;
    xmlNodePtr *nodeTab;

};
# 99 "./include/libxml/xpath.h"
typedef enum {
    XPATH_UNDEFINED = 0,
    XPATH_NODESET = 1,
    XPATH_BOOLEAN = 2,
    XPATH_NUMBER = 3,
    XPATH_STRING = 4,
    XPATH_POINT = 5,
    XPATH_RANGE = 6,
    XPATH_LOCATIONSET = 7,
    XPATH_USERS = 8,
    XPATH_XSLT_TREE = 9
} xmlXPathObjectType;

typedef struct _xmlXPathObject xmlXPathObject;
typedef xmlXPathObject *xmlXPathObjectPtr;
struct _xmlXPathObject {
    xmlXPathObjectType type;
    xmlNodeSetPtr nodesetval;
    int boolval;
    double floatval;
    xmlChar *stringval;
    void *user;
    int index;
    void *user2;
    int index2;
};
# 136 "./include/libxml/xpath.h"
typedef int (*xmlXPathConvertFunc) (xmlXPathObjectPtr obj, int type);





typedef struct _xmlXPathType xmlXPathType;
typedef xmlXPathType *xmlXPathTypePtr;
struct _xmlXPathType {
    const xmlChar *name;
    xmlXPathConvertFunc func;
};





typedef struct _xmlXPathVariable xmlXPathVariable;
typedef xmlXPathVariable *xmlXPathVariablePtr;
struct _xmlXPathVariable {
    const xmlChar *name;
    xmlXPathObjectPtr value;
};
# 168 "./include/libxml/xpath.h"
typedef void (*xmlXPathEvalFunc)(xmlXPathParserContextPtr ctxt,
                          int nargs);





typedef struct _xmlXPathFunct xmlXPathFunct;
typedef xmlXPathFunct *xmlXPathFuncPtr;
struct _xmlXPathFunct {
    const xmlChar *name;
    xmlXPathEvalFunc func;
};
# 194 "./include/libxml/xpath.h"
typedef xmlXPathObjectPtr (*xmlXPathAxisFunc) (xmlXPathParserContextPtr ctxt,
     xmlXPathObjectPtr cur);





typedef struct _xmlXPathAxis xmlXPathAxis;
typedef xmlXPathAxis *xmlXPathAxisPtr;
struct _xmlXPathAxis {
    const xmlChar *name;
    xmlXPathAxisFunc func;
};
# 218 "./include/libxml/xpath.h"
typedef void (*xmlXPathFunction) (xmlXPathParserContextPtr ctxt, int nargs);
# 235 "./include/libxml/xpath.h"
typedef xmlXPathObjectPtr (*xmlXPathVariableLookupFunc) (void *ctxt,
                                         const xmlChar *name,
                                         const xmlChar *ns_uri);
# 250 "./include/libxml/xpath.h"
typedef xmlXPathFunction (*xmlXPathFuncLookupFunc) (void *ctxt,
      const xmlChar *name,
      const xmlChar *ns_uri);
# 288 "./include/libxml/xpath.h"
struct _xmlXPathContext {
    xmlDocPtr doc;
    xmlNodePtr node;

    int nb_variables_unused;
    int max_variables_unused;
    xmlHashTablePtr varHash;

    int nb_types;
    int max_types;
    xmlXPathTypePtr types;

    int nb_funcs_unused;
    int max_funcs_unused;
    xmlHashTablePtr funcHash;

    int nb_axis;
    int max_axis;
    xmlXPathAxisPtr axis;


    xmlNsPtr *namespaces;
    int nsNr;
    void *user;


    int contextSize;
    int proximityPosition;


    int xptr;
    xmlNodePtr here;
    xmlNodePtr origin;


    xmlHashTablePtr nsHash;
    xmlXPathVariableLookupFunc varLookupFunc;
    void *varLookupData;


    void *extra;


    const xmlChar *function;
    const xmlChar *functionURI;


    xmlXPathFuncLookupFunc funcLookupFunc;
    void *funcLookupData;


    xmlNsPtr *tmpNsList;
    int tmpNsNr;


    void *userData;
    xmlStructuredErrorFunc error;
    xmlError lastError;
    xmlNodePtr debugNode;


    xmlDictPtr dict;

    int flags;


    void *cache;
};





typedef struct _xmlXPathCompExpr xmlXPathCompExpr;
typedef xmlXPathCompExpr *xmlXPathCompExprPtr;







struct _xmlXPathParserContext {
    const xmlChar *cur;
    const xmlChar *base;

    int error;

    xmlXPathContextPtr context;
    xmlXPathObjectPtr value;
    int valueNr;
    int valueMax;
    xmlXPathObjectPtr *valueTab;

    xmlXPathCompExprPtr comp;
    int xptr;
    xmlNodePtr ancestor;

    int valueFrame;
};
# 399 "./include/libxml/xpath.h"
extern double xmlXPathNAN;
extern double xmlXPathPINF;
extern double xmlXPathNINF;
# 440 "./include/libxml/xpath.h"
 void
      xmlXPathFreeObject (xmlXPathObjectPtr obj);
 xmlNodeSetPtr
      xmlXPathNodeSetCreate (xmlNodePtr val);
 void
      xmlXPathFreeNodeSetList (xmlXPathObjectPtr obj);
 void
      xmlXPathFreeNodeSet (xmlNodeSetPtr obj);
 xmlXPathObjectPtr
      xmlXPathObjectCopy (xmlXPathObjectPtr val);
 int
      xmlXPathCmpNodes (xmlNodePtr node1,
       xmlNodePtr node2);



 int
      xmlXPathCastNumberToBoolean (double val);
 int
      xmlXPathCastStringToBoolean (const xmlChar * val);
 int
      xmlXPathCastNodeSetToBoolean(xmlNodeSetPtr ns);
 int
      xmlXPathCastToBoolean (xmlXPathObjectPtr val);

 double
      xmlXPathCastBooleanToNumber (int val);
 double
      xmlXPathCastStringToNumber (const xmlChar * val);
 double
      xmlXPathCastNodeToNumber (xmlNodePtr node);
 double
      xmlXPathCastNodeSetToNumber (xmlNodeSetPtr ns);
 double
      xmlXPathCastToNumber (xmlXPathObjectPtr val);

 xmlChar *
      xmlXPathCastBooleanToString (int val);
 xmlChar *
      xmlXPathCastNumberToString (double val);
 xmlChar *
      xmlXPathCastNodeToString (xmlNodePtr node);
 xmlChar *
      xmlXPathCastNodeSetToString (xmlNodeSetPtr ns);
 xmlChar *
      xmlXPathCastToString (xmlXPathObjectPtr val);

 xmlXPathObjectPtr
      xmlXPathConvertBoolean (xmlXPathObjectPtr val);
 xmlXPathObjectPtr
      xmlXPathConvertNumber (xmlXPathObjectPtr val);
 xmlXPathObjectPtr
      xmlXPathConvertString (xmlXPathObjectPtr val);




 xmlXPathContextPtr
      xmlXPathNewContext (xmlDocPtr doc);
 void
      xmlXPathFreeContext (xmlXPathContextPtr ctxt);
 int
      xmlXPathContextSetCache(xmlXPathContextPtr ctxt,
                int active,
         int value,
         int options);



 long
      xmlXPathOrderDocElems (xmlDocPtr doc);
 xmlXPathObjectPtr
      xmlXPathEval (const xmlChar *str,
       xmlXPathContextPtr ctx);
 xmlXPathObjectPtr
      xmlXPathEvalExpression (const xmlChar *str,
       xmlXPathContextPtr ctxt);
 int
      xmlXPathEvalPredicate (xmlXPathContextPtr ctxt,
       xmlXPathObjectPtr res);



 xmlXPathCompExprPtr
      xmlXPathCompile (const xmlChar *str);
 xmlXPathCompExprPtr
      xmlXPathCtxtCompile (xmlXPathContextPtr ctxt,
       const xmlChar *str);
 xmlXPathObjectPtr
      xmlXPathCompiledEval (xmlXPathCompExprPtr comp,
       xmlXPathContextPtr ctx);
 int
      xmlXPathCompiledEvalToBoolean(xmlXPathCompExprPtr comp,
       xmlXPathContextPtr ctxt);
 void
      xmlXPathFreeCompExpr (xmlXPathCompExprPtr comp);


 void
      xmlXPathInit (void);
 int
  xmlXPathIsNaN (double val);
 int
  xmlXPathIsInf (double val);
# 197 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/xpointer.h" 1
# 34 "./include/libxml/xpointer.h"
typedef struct _xmlLocationSet xmlLocationSet;
typedef xmlLocationSet *xmlLocationSetPtr;
struct _xmlLocationSet {
    int locNr;
    int locMax;
    xmlXPathObjectPtr *locTab;
};





 xmlLocationSetPtr
      xmlXPtrLocationSetCreate (xmlXPathObjectPtr val);
 void
      xmlXPtrFreeLocationSet (xmlLocationSetPtr obj);
 xmlLocationSetPtr
      xmlXPtrLocationSetMerge (xmlLocationSetPtr val1,
       xmlLocationSetPtr val2);
 xmlXPathObjectPtr
      xmlXPtrNewRange (xmlNodePtr start,
       int startindex,
       xmlNodePtr end,
       int endindex);
 xmlXPathObjectPtr
      xmlXPtrNewRangePoints (xmlXPathObjectPtr start,
       xmlXPathObjectPtr end);
 xmlXPathObjectPtr
      xmlXPtrNewRangeNodePoint (xmlNodePtr start,
       xmlXPathObjectPtr end);
 xmlXPathObjectPtr
      xmlXPtrNewRangePointNode (xmlXPathObjectPtr start,
       xmlNodePtr end);
 xmlXPathObjectPtr
      xmlXPtrNewRangeNodes (xmlNodePtr start,
       xmlNodePtr end);
 xmlXPathObjectPtr
      xmlXPtrNewLocationSetNodes (xmlNodePtr start,
       xmlNodePtr end);
 xmlXPathObjectPtr
      xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set);
 xmlXPathObjectPtr
      xmlXPtrNewRangeNodeObject (xmlNodePtr start,
       xmlXPathObjectPtr end);
 xmlXPathObjectPtr
      xmlXPtrNewCollapsedRange (xmlNodePtr start);
 void
      xmlXPtrLocationSetAdd (xmlLocationSetPtr cur,
       xmlXPathObjectPtr val);
 xmlXPathObjectPtr
      xmlXPtrWrapLocationSet (xmlLocationSetPtr val);
 void
      xmlXPtrLocationSetDel (xmlLocationSetPtr cur,
       xmlXPathObjectPtr val);
 void
      xmlXPtrLocationSetRemove (xmlLocationSetPtr cur,
       int val);




 xmlXPathContextPtr
      xmlXPtrNewContext (xmlDocPtr doc,
       xmlNodePtr here,
       xmlNodePtr origin);
 xmlXPathObjectPtr
      xmlXPtrEval (const xmlChar *str,
       xmlXPathContextPtr ctx);
 void
      xmlXPtrRangeToFunction (xmlXPathParserContextPtr ctxt,
       int nargs);
 xmlNodePtr
      xmlXPtrBuildNodeList (xmlXPathObjectPtr obj);
 void
      xmlXPtrEvalRangePredicate (xmlXPathParserContextPtr ctxt);
# 198 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/debugXML.h" 1
# 28 "./include/libxml/debugXML.h"
 void
 xmlDebugDumpString (FILE *output,
     const xmlChar *str);
 void
 xmlDebugDumpAttr (FILE *output,
     xmlAttrPtr attr,
     int depth);
 void
 xmlDebugDumpAttrList (FILE *output,
     xmlAttrPtr attr,
     int depth);
 void
 xmlDebugDumpOneNode (FILE *output,
     xmlNodePtr node,
     int depth);
 void
 xmlDebugDumpNode (FILE *output,
     xmlNodePtr node,
     int depth);
 void
 xmlDebugDumpNodeList (FILE *output,
     xmlNodePtr node,
     int depth);
 void
 xmlDebugDumpDocumentHead(FILE *output,
     xmlDocPtr doc);
 void
 xmlDebugDumpDocument (FILE *output,
     xmlDocPtr doc);
 void
 xmlDebugDumpDTD (FILE *output,
     xmlDtdPtr dtd);
 void
 xmlDebugDumpEntities (FILE *output,
     xmlDocPtr doc);







 int
 xmlDebugCheckDocument (FILE * output,
     xmlDocPtr doc);







 void
 xmlLsOneNode (FILE *output, xmlNodePtr node);
 int
 xmlLsCountNode (xmlNodePtr node);

 const char *
 xmlBoolToText (int boolval);
# 103 "./include/libxml/debugXML.h"
typedef char * (* xmlShellReadlineFunc)(char *prompt);







typedef struct _xmlShellCtxt xmlShellCtxt;
typedef xmlShellCtxt *xmlShellCtxtPtr;
struct _xmlShellCtxt {
    char *filename;
    xmlDocPtr doc;
    xmlNodePtr node;
    xmlXPathContextPtr pctxt;
    int loaded;
    FILE *output;
    xmlShellReadlineFunc input;
};
# 134 "./include/libxml/debugXML.h"
typedef int (* xmlShellCmd) (xmlShellCtxtPtr ctxt,
                             char *arg,
        xmlNodePtr node,
        xmlNodePtr node2);

 void
 xmlShellPrintXPathError (int errorType,
     const char *arg);
 void
 xmlShellPrintXPathResult(xmlXPathObjectPtr list);
 int
 xmlShellList (xmlShellCtxtPtr ctxt,
     char *arg,
     xmlNodePtr node,
     xmlNodePtr node2);
 int
 xmlShellBase (xmlShellCtxtPtr ctxt,
     char *arg,
     xmlNodePtr node,
     xmlNodePtr node2);
 int
 xmlShellDir (xmlShellCtxtPtr ctxt,
     char *arg,
     xmlNodePtr node,
     xmlNodePtr node2);
 int
 xmlShellLoad (xmlShellCtxtPtr ctxt,
     char *filename,
     xmlNodePtr node,
     xmlNodePtr node2);

 void
 xmlShellPrintNode (xmlNodePtr node);
 int
 xmlShellCat (xmlShellCtxtPtr ctxt,
     char *arg,
     xmlNodePtr node,
     xmlNodePtr node2);
 int
 xmlShellWrite (xmlShellCtxtPtr ctxt,
     char *filename,
     xmlNodePtr node,
     xmlNodePtr node2);
 int
 xmlShellSave (xmlShellCtxtPtr ctxt,
     char *filename,
     xmlNodePtr node,
     xmlNodePtr node2);


 int
 xmlShellValidate (xmlShellCtxtPtr ctxt,
     char *dtd,
     xmlNodePtr node,
     xmlNodePtr node2);

 int
 xmlShellDu (xmlShellCtxtPtr ctxt,
     char *arg,
     xmlNodePtr tree,
     xmlNodePtr node2);
 int
 xmlShellPwd (xmlShellCtxtPtr ctxt,
     char *buffer,
     xmlNodePtr node,
     xmlNodePtr node2);




 void
 xmlShell (xmlDocPtr doc,
     char *filename,
     xmlShellReadlineFunc input,
     FILE *output);
# 199 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2





void xmlErrMemory(xmlParserCtxtPtr ctxt, const char *extra);
# 216 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
static void *gen_void_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 217 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 217 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_void_ptr(int no __attribute__((unused)), void *val __attribute__((unused)), int nr __attribute__((unused))) {
}
# 235 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
static void *gen_userdata(int no, int nr __attribute__((unused))) {
    if (no == 0) return((void *) &call_tests);
    if (no == 1) return((void *) -1);
    return(
# 238 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 238 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_userdata(int no __attribute__((unused)), void *val __attribute__((unused)), int nr __attribute__((unused))) {
}




static int gen_int(int no, int nr __attribute__((unused))) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(-1);
    if (no == 3) return(122);
    return(-1);
}

static void des_int(int no __attribute__((unused)), int val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int gen_parseroptions(int no, int nr __attribute__((unused))) {
    if (no == 0) return(XML_PARSE_NOBLANKS | XML_PARSE_RECOVER);
    if (no == 1) return(XML_PARSE_NOENT | XML_PARSE_DTDLOAD | XML_PARSE_DTDATTR | XML_PARSE_DTDVALID | XML_PARSE_NOCDATA);
    if (no == 2) return(XML_PARSE_XINCLUDE | XML_PARSE_NOXINCNODE | XML_PARSE_NSCLEAN);
    if (no == 3) return(XML_PARSE_XINCLUDE | XML_PARSE_NODICT);
    return(XML_PARSE_SAX1);
}

static void des_parseroptions(int no __attribute__((unused)), int val __attribute__((unused)), int nr __attribute__((unused))) {
}
# 287 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
static xmlChar gen_xmlChar(int no, int nr __attribute__((unused))) {
    if (no == 0) return('a');
    if (no == 1) return(' ');
    if (no == 2) return((xmlChar) '\xf8');
    return(0);
}

static void des_xmlChar(int no __attribute__((unused)), xmlChar val __attribute__((unused)), int nr __attribute__((unused))) {
}



static unsigned int gen_unsigned_int(int no, int nr __attribute__((unused))) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(122);
    return((unsigned int) -1);
}

static void des_unsigned_int(int no __attribute__((unused)), unsigned int val __attribute__((unused)), int nr __attribute__((unused))) {
}



static unsigned long gen_unsigned_long(int no, int nr __attribute__((unused))) {
    if (no == 0) return(0);
    if (no == 1) return(1);
    if (no == 2) return(122);
    return((unsigned long) -1);
}

static void des_unsigned_long(int no __attribute__((unused)), unsigned long val __attribute__((unused)), int nr __attribute__((unused))) {
}



static double gen_double(int no, int nr __attribute__((unused))) {
    if (no == 0) return(0);
    if (no == 1) return(-1.1);

    if (no == 2) return(xmlXPathNAN);

    return(-1);
}

static void des_double(int no __attribute__((unused)), double val __attribute__((unused)), int nr __attribute__((unused))) {
}



static unsigned long *gen_unsigned_long_ptr(int no, int nr) {
    if (no == 0) return(&longtab[nr]);
    return(
# 339 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 339 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}

static void des_unsigned_long_ptr(int no __attribute__((unused)), unsigned long *val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int *gen_int_ptr(int no, int nr) {
    if (no == 0) return(&inttab[nr]);
    return(
# 349 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 349 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}

static void des_int_ptr(int no __attribute__((unused)), int *val __attribute__((unused)), int nr __attribute__((unused))) {
}



static char *gen_const_char_ptr(int no, int nr __attribute__((unused))) {
    if (no == 0) return((char *) "foo");
    if (no == 1) return((char *) "<foo/>");
    if (no == 2) return((char *) "test/ent2");
    return(
# 361 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 361 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_char_ptr(int no __attribute__((unused)), const char *val __attribute__((unused)), int nr __attribute__((unused))) {
}



static xmlChar *gen_xmlChar_ptr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(&chartab[0]);
    return(
# 370 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 370 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlChar_ptr(int no __attribute__((unused)), xmlChar *val __attribute__((unused)), int nr __attribute__((unused))) {
}



static FILE *gen_FILE_ptr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(fopen("test.out", "a+"));
    return(
# 379 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 379 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_FILE_ptr(int no __attribute__((unused)), FILE *val, int nr __attribute__((unused))) {
    if (val != 
# 382 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 382 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) fclose(val);
}


static FILE *gen_debug_FILE_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(fopen("test.out", "a+"));
}
static void des_debug_FILE_ptr(int no __attribute__((unused)), FILE *val, int nr __attribute__((unused))) {
    if (val != 
# 390 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 390 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) fclose(val);
}



static xmlChar *gen_const_xmlChar_ptr(int no, int nr __attribute__((unused))) {
    if (no == 0) return((xmlChar *) "foo");
    if (no == 1) return((xmlChar *) "<foo/>");
    if (no == 2) return((xmlChar *) "n" "\xf8" "ne");
    if (no == 3) return((xmlChar *) " 2ab ");
    return(
# 400 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 400 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlChar_ptr(int no __attribute__((unused)), const xmlChar *val __attribute__((unused)), int nr __attribute__((unused))) {
}



static const char *gen_filepath(int no, int nr __attribute__((unused))) {
    if (no == 0) return("missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("test/ent2");
    if (no == 3) return("test/valid/REC-xml-19980210.xml");
    if (no == 4) return("test/valid/dtds/xhtml1-strict.dtd");
    if (no == 5) return("http://localhost/");
    if (no == 6) return("http:http://http");
    return(
# 415 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 415 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_filepath(int no __attribute__((unused)), const char *val __attribute__((unused)), int nr __attribute__((unused))) {
}



static xmlChar *gen_eaten_name(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlStrdup((xmlChar *) "eaten"));
    return(
# 424 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 424 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_eaten_name(int no __attribute__((unused)), xmlChar *val __attribute__((unused)), int nr __attribute__((unused))) {
}



static const char *gen_fileoutput(int no, int nr __attribute__((unused))) {
    if (no == 0) return("/missing.xml");
    if (no == 1) return("<foo/>");
    if (no == 2) return("ftp://localhost/foo");
    if (no == 3) return("http://localhost/");
    if (no == 4) return("http:http://http");
    return(
# 437 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 437 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_fileoutput(int no __attribute__((unused)), const char *val __attribute__((unused)), int nr __attribute__((unused))) {
}


static xmlParserCtxtPtr gen_xmlParserCtxtPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlNewParserCtxt());
    if (no == 1) return(xmlCreateMemoryParserCtxt("<doc/>", 6));
    return(
# 446 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 446 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlParserCtxtPtr(int no __attribute__((unused)), xmlParserCtxtPtr val, int nr __attribute__((unused))) {
    if (val != 
# 449 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 449 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  )
        xmlFreeParserCtxt(val);
}


static xmlSAXHandlerPtr gen_xmlSAXHandlerPtr(int no, int nr __attribute__((unused))) {

    if (no == 0) return((xmlSAXHandlerPtr) &(*(__xmlDefaultSAXHandler())));

    return(
# 458 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 458 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSAXHandlerPtr(int no __attribute__((unused)), xmlSAXHandlerPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}


static xmlValidCtxtPtr gen_xmlValidCtxtPtr(int no, int nr __attribute__((unused))) {

    if (no == 0) return(xmlNewValidCtxt());

    return(
# 468 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 468 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlValidCtxtPtr(int no __attribute__((unused)), xmlValidCtxtPtr val, int nr __attribute__((unused))) {

    if (val != 
# 472 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 472 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  )
        xmlFreeValidCtxt(val);

}



static xmlParserInputBufferPtr gen_xmlParserInputBufferPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlParserInputBufferCreateFilename("missing.xml", XML_CHAR_ENCODING_NONE));
    if (no == 1) return(xmlParserInputBufferCreateFilename("<foo/>", XML_CHAR_ENCODING_NONE));
    if (no == 2) return(xmlParserInputBufferCreateFilename("test/ent2", XML_CHAR_ENCODING_NONE));
    if (no == 3) return(xmlParserInputBufferCreateFilename("test/valid/REC-xml-19980210.xml", XML_CHAR_ENCODING_NONE));
    if (no == 4) return(xmlParserInputBufferCreateFilename("test/valid/dtds/xhtml1-strict.dtd", XML_CHAR_ENCODING_NONE));
    if (no == 5) return(xmlParserInputBufferCreateFilename("http://localhost/", XML_CHAR_ENCODING_NONE));
    if (no == 6) return(xmlParserInputBufferCreateFilename("http:http://http", XML_CHAR_ENCODING_NONE));
    return(
# 487 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 487 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlParserInputBufferPtr(int no __attribute__((unused)), xmlParserInputBufferPtr val, int nr __attribute__((unused))) {
    xmlFreeParserInputBuffer(val);
}


static xmlDocPtr gen_xmlDocPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlNewDoc((xmlChar *) "1.0"));
    if (no == 1) return(xmlReadMemory("<foo/>", 6, "test", 
# 496 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                          ((void *)0)
# 496 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                              , 0));
    if (no == 2) return(xmlReadMemory("<!DOCTYPE foo []> <foo/>", 24, "test", 
# 497 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                             ((void *)0)
# 497 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                                 , 0));
    return(
# 498 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 498 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlDocPtr(int no __attribute__((unused)), xmlDocPtr val, int nr __attribute__((unused))) {
    if ((val != 
# 501 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
               ((void *)0)
# 501 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                   ) && (val != api_doc) && (val->doc != api_doc))
        xmlFreeDoc(val);
}


static xmlAttrPtr gen_xmlAttrPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(get_api_attr());
    return(
# 508 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 508 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlAttrPtr(int no, xmlAttrPtr val __attribute__((unused)), int nr __attribute__((unused))) {
    if (no == 0) free_api_doc();
}


static xmlDictPtr gen_xmlDictPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlDictCreate());
    return(
# 517 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 517 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlDictPtr(int no __attribute__((unused)), xmlDictPtr val, int nr __attribute__((unused))) {
    if (val != 
# 520 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 520 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  )
        xmlDictFree(val);
}


static xmlNodePtr gen_xmlNodePtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlNewPI((xmlChar *) "test", 
# 526 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                 ((void *)0)
# 526 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                     ));
    if (no == 1) return(get_api_root());
    return(
# 528 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 528 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );

}
static void des_xmlNodePtr(int no, xmlNodePtr val, int nr __attribute__((unused))) {
    if (no == 1) {
        free_api_doc();
    } else if (val != 
# 534 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                     ((void *)0)
# 534 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                         ) {
        xmlUnlinkNode(val);
        xmlFreeNode(val);
    }
}


static xmlDtdPtr gen_xmlDtdPtr(int no, int nr __attribute__((unused))) {
    if (no == 0)
        return(xmlNewDtd(
# 543 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                        ((void *)0)
# 543 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                            , (xmlChar *) "dtd", (xmlChar *)"foo", (xmlChar *)"bar"));
    if (no == 1) return(get_api_dtd());
    return(
# 545 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 545 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlDtdPtr(int no, xmlDtdPtr val, int nr __attribute__((unused))) {
    if (no == 1) free_api_doc();
    else if (val != 
# 549 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 549 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       ) {
        xmlUnlinkNode((xmlNodePtr) val);
        xmlFreeNode((xmlNodePtr) val);
    }
}


static xmlNsPtr gen_xmlNsPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(get_api_ns());
    return(
# 558 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 558 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlNsPtr(int no, xmlNsPtr val __attribute__((unused)), int nr __attribute__((unused))) {
    if (no == 0) free_api_doc();
}


static xmlNodePtr gen_xmlNodePtr_in(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlNewPI((xmlChar *) "test", 
# 566 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                 ((void *)0)
# 566 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                     ));
    if (no == 0) return(xmlNewText((xmlChar *) "text"));
    return(
# 568 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 568 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlNodePtr_in(int no __attribute__((unused)), xmlNodePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static xmlTextWriterPtr gen_xmlTextWriterPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlNewTextWriterFilename("test.out", 0));
    return(
# 577 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 577 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlTextWriterPtr(int no __attribute__((unused)), xmlTextWriterPtr val, int nr __attribute__((unused))) {
    if (val != 
# 580 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 580 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) xmlFreeTextWriter(val);
}




static xmlTextReaderPtr gen_xmlTextReaderPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlNewTextReaderFilename("test/ent2"));
    if (no == 1) return(xmlNewTextReaderFilename("test/valid/REC-xml-19980210.xml"));
    if (no == 2) return(xmlNewTextReaderFilename("test/valid/dtds/xhtml1-strict.dtd"));
    return(
# 590 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 590 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlTextReaderPtr(int no __attribute__((unused)), xmlTextReaderPtr val, int nr __attribute__((unused))) {
    if (val != 
# 593 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 593 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) xmlFreeTextReader(val);
}



static const xmlChar *static_buf_content = (xmlChar *)"a static buffer";
static xmlBufferPtr gen_xmlBufferPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlBufferCreate());
    if (no == 1) return(xmlBufferCreateStatic((void *)static_buf_content, 13));
    return(
# 602 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 602 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlBufferPtr(int no __attribute__((unused)), xmlBufferPtr val, int nr __attribute__((unused))) {
    if (val != 
# 605 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 605 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
        xmlBufferFree(val);
    }
}


static xmlListPtr gen_xmlListPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlListCreate(
# 612 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                     ((void *)0)
# 612 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                         , 
# 612 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                           ((void *)0)
# 612 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                               ));
    return(
# 613 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 613 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlListPtr(int no __attribute__((unused)), xmlListPtr val, int nr __attribute__((unused))) {
    if (val != 
# 616 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 616 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
        xmlListDelete(val);
    }
}


static xmlHashTablePtr gen_xmlHashTablePtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlHashCreate(10));
    return(
# 624 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 624 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlHashTablePtr(int no __attribute__((unused)), xmlHashTablePtr val, int nr __attribute__((unused))) {
    if (val != 
# 627 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 627 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
        xmlHashFree(val, 
# 628 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                        ((void *)0)
# 628 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                            );
    }
}

# 1 "./include/libxml/xpathInternals.h" 1
# 103 "./include/libxml/xpathInternals.h"
 int
  xmlXPathPopBoolean (xmlXPathParserContextPtr ctxt);
 double
  xmlXPathPopNumber (xmlXPathParserContextPtr ctxt);
 xmlChar *
  xmlXPathPopString (xmlXPathParserContextPtr ctxt);
 xmlNodeSetPtr
  xmlXPathPopNodeSet (xmlXPathParserContextPtr ctxt);
 void *
  xmlXPathPopExternal (xmlXPathParserContextPtr ctxt);
# 334 "./include/libxml/xpathInternals.h"
 void
 xmlXPathRegisterVariableLookup (xmlXPathContextPtr ctxt,
      xmlXPathVariableLookupFunc f,
      void *data);





 void
     xmlXPathRegisterFuncLookup (xmlXPathContextPtr ctxt,
      xmlXPathFuncLookupFunc f,
      void *funcCtxt);




 void
  xmlXPatherror (xmlXPathParserContextPtr ctxt,
     const char *file,
     int line,
     int no);

 void
  xmlXPathErr (xmlXPathParserContextPtr ctxt,
     int error);


 void
  xmlXPathDebugDumpObject (FILE *output,
      xmlXPathObjectPtr cur,
      int depth);
 void
     xmlXPathDebugDumpCompExpr(FILE *output,
      xmlXPathCompExprPtr comp,
      int depth);




 int
  xmlXPathNodeSetContains (xmlNodeSetPtr cur,
       xmlNodePtr val);
 xmlNodeSetPtr
  xmlXPathDifference (xmlNodeSetPtr nodes1,
       xmlNodeSetPtr nodes2);
 xmlNodeSetPtr
  xmlXPathIntersection (xmlNodeSetPtr nodes1,
       xmlNodeSetPtr nodes2);

 xmlNodeSetPtr
  xmlXPathDistinctSorted (xmlNodeSetPtr nodes);
 xmlNodeSetPtr
  xmlXPathDistinct (xmlNodeSetPtr nodes);

 int
  xmlXPathHasSameNodes (xmlNodeSetPtr nodes1,
       xmlNodeSetPtr nodes2);

 xmlNodeSetPtr
  xmlXPathNodeLeadingSorted (xmlNodeSetPtr nodes,
       xmlNodePtr node);
 xmlNodeSetPtr
  xmlXPathLeadingSorted (xmlNodeSetPtr nodes1,
       xmlNodeSetPtr nodes2);
 xmlNodeSetPtr
  xmlXPathNodeLeading (xmlNodeSetPtr nodes,
       xmlNodePtr node);
 xmlNodeSetPtr
  xmlXPathLeading (xmlNodeSetPtr nodes1,
       xmlNodeSetPtr nodes2);

 xmlNodeSetPtr
  xmlXPathNodeTrailingSorted (xmlNodeSetPtr nodes,
       xmlNodePtr node);
 xmlNodeSetPtr
  xmlXPathTrailingSorted (xmlNodeSetPtr nodes1,
       xmlNodeSetPtr nodes2);
 xmlNodeSetPtr
  xmlXPathNodeTrailing (xmlNodeSetPtr nodes,
       xmlNodePtr node);
 xmlNodeSetPtr
  xmlXPathTrailing (xmlNodeSetPtr nodes1,
       xmlNodeSetPtr nodes2);






 int
  xmlXPathRegisterNs (xmlXPathContextPtr ctxt,
       const xmlChar *prefix,
       const xmlChar *ns_uri);
 const xmlChar *
  xmlXPathNsLookup (xmlXPathContextPtr ctxt,
       const xmlChar *prefix);
 void
  xmlXPathRegisteredNsCleanup (xmlXPathContextPtr ctxt);

 int
  xmlXPathRegisterFunc (xmlXPathContextPtr ctxt,
       const xmlChar *name,
       xmlXPathFunction f);
 int
  xmlXPathRegisterFuncNS (xmlXPathContextPtr ctxt,
       const xmlChar *name,
       const xmlChar *ns_uri,
       xmlXPathFunction f);
 int
  xmlXPathRegisterVariable (xmlXPathContextPtr ctxt,
       const xmlChar *name,
       xmlXPathObjectPtr value);
 int
  xmlXPathRegisterVariableNS (xmlXPathContextPtr ctxt,
       const xmlChar *name,
       const xmlChar *ns_uri,
       xmlXPathObjectPtr value);
 xmlXPathFunction
  xmlXPathFunctionLookup (xmlXPathContextPtr ctxt,
       const xmlChar *name);
 xmlXPathFunction
  xmlXPathFunctionLookupNS (xmlXPathContextPtr ctxt,
       const xmlChar *name,
       const xmlChar *ns_uri);
 void
  xmlXPathRegisteredFuncsCleanup (xmlXPathContextPtr ctxt);
 xmlXPathObjectPtr
  xmlXPathVariableLookup (xmlXPathContextPtr ctxt,
       const xmlChar *name);
 xmlXPathObjectPtr
  xmlXPathVariableLookupNS (xmlXPathContextPtr ctxt,
       const xmlChar *name,
       const xmlChar *ns_uri);
 void
  xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt);




 xmlXPathParserContextPtr
    xmlXPathNewParserContext (const xmlChar *str,
       xmlXPathContextPtr ctxt);
 void
  xmlXPathFreeParserContext (xmlXPathParserContextPtr ctxt);


 xmlXPathObjectPtr
  valuePop (xmlXPathParserContextPtr ctxt);
 int
  valuePush (xmlXPathParserContextPtr ctxt,
       xmlXPathObjectPtr value);

 xmlXPathObjectPtr
  xmlXPathNewString (const xmlChar *val);
 xmlXPathObjectPtr
  xmlXPathNewCString (const char *val);
 xmlXPathObjectPtr
  xmlXPathWrapString (xmlChar *val);
 xmlXPathObjectPtr
  xmlXPathWrapCString (char * val);
 xmlXPathObjectPtr
  xmlXPathNewFloat (double val);
 xmlXPathObjectPtr
  xmlXPathNewBoolean (int val);
 xmlXPathObjectPtr
  xmlXPathNewNodeSet (xmlNodePtr val);
 xmlXPathObjectPtr
  xmlXPathNewValueTree (xmlNodePtr val);
 int
  xmlXPathNodeSetAdd (xmlNodeSetPtr cur,
       xmlNodePtr val);
 int
  xmlXPathNodeSetAddUnique (xmlNodeSetPtr cur,
       xmlNodePtr val);
 int
  xmlXPathNodeSetAddNs (xmlNodeSetPtr cur,
       xmlNodePtr node,
       xmlNsPtr ns);
 void
  xmlXPathNodeSetSort (xmlNodeSetPtr set);

 void
  xmlXPathRoot (xmlXPathParserContextPtr ctxt);
 void
  xmlXPathEvalExpr (xmlXPathParserContextPtr ctxt);
 xmlChar *
  xmlXPathParseName (xmlXPathParserContextPtr ctxt);
 xmlChar *
  xmlXPathParseNCName (xmlXPathParserContextPtr ctxt);




 double
  xmlXPathStringEvalNumber (const xmlChar *str);
 int
  xmlXPathEvaluatePredicateResult (xmlXPathParserContextPtr ctxt,
       xmlXPathObjectPtr res);
 void
  xmlXPathRegisterAllFunctions (xmlXPathContextPtr ctxt);
 xmlNodeSetPtr
  xmlXPathNodeSetMerge (xmlNodeSetPtr val1,
       xmlNodeSetPtr val2);
 void
  xmlXPathNodeSetDel (xmlNodeSetPtr cur,
       xmlNodePtr val);
 void
  xmlXPathNodeSetRemove (xmlNodeSetPtr cur,
       int val);
 xmlXPathObjectPtr
  xmlXPathNewNodeSetList (xmlNodeSetPtr val);
 xmlXPathObjectPtr
  xmlXPathWrapNodeSet (xmlNodeSetPtr val);
 xmlXPathObjectPtr
  xmlXPathWrapExternal (void *val);

 int xmlXPathEqualValues(xmlXPathParserContextPtr ctxt);
 int xmlXPathNotEqualValues(xmlXPathParserContextPtr ctxt);
 int xmlXPathCompareValues(xmlXPathParserContextPtr ctxt, int inf, int strict);
 void xmlXPathValueFlipSign(xmlXPathParserContextPtr ctxt);
 void xmlXPathAddValues(xmlXPathParserContextPtr ctxt);
 void xmlXPathSubValues(xmlXPathParserContextPtr ctxt);
 void xmlXPathMultValues(xmlXPathParserContextPtr ctxt);
 void xmlXPathDivValues(xmlXPathParserContextPtr ctxt);
 void xmlXPathModValues(xmlXPathParserContextPtr ctxt);

 int xmlXPathIsNodeType(const xmlChar *name);




 xmlNodePtr xmlXPathNextSelf(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextChild(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextDescendantOrSelf(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextParent(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextAncestorOrSelf(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextFollowingSibling(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextNamespace(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextAttribute(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextAncestor(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);
 xmlNodePtr xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt,
   xmlNodePtr cur);



 void xmlXPathLastFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathPositionFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathCountFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathLocalNameFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathNamespaceURIFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathStringFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathStringLengthFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathConcatFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathContainsFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathStartsWithFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathSubstringBeforeFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathSubstringAfterFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathNormalizeFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathTranslateFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathNotFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathTrueFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathFalseFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathLangFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathNumberFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathSumFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathFloorFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathRoundFunction(xmlXPathParserContextPtr ctxt, int nargs);
 void xmlXPathBooleanFunction(xmlXPathParserContextPtr ctxt, int nargs);




 void xmlXPathNodeSetFreeNs(xmlNsPtr ns);
# 633 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2



static xmlXPathObjectPtr gen_xmlXPathObjectPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlXPathNewString((xmlChar *) "string object"));
    if (no == 1) return(xmlXPathNewFloat(1.1));
    if (no == 2) return(xmlXPathNewBoolean(1));
    if (no == 3) return(xmlXPathNewNodeSet(
# 640 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                          ((void *)0)
# 640 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                              ));
    return(
# 641 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 641 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlXPathObjectPtr(int no __attribute__((unused)), xmlXPathObjectPtr val, int nr __attribute__((unused))) {
    if (val != 
# 644 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 644 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
        xmlXPathFreeObject(val);
    }
}




static xmlOutputBufferPtr gen_xmlOutputBufferPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlOutputBufferCreateFilename("test.out", 
# 653 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                 ((void *)0)
# 653 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                     , 0));
    return(
# 654 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 654 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlOutputBufferPtr(int no __attribute__((unused)), xmlOutputBufferPtr val, int nr __attribute__((unused))) {
    if (val != 
# 657 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 657 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
        xmlOutputBufferClose(val);
    }
}




static void *gen_xmlNanoFTPCtxtPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlNanoFTPNewCtxt("ftp://localhost/foo"));
    if (no == 1) return(xmlNanoFTPNewCtxt("http://localhost/"));
    if (no == 2) return(xmlNanoFTPNewCtxt("foo"));
    return(
# 669 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 669 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlNanoFTPCtxtPtr(int no __attribute__((unused)), void *val, int nr __attribute__((unused))) {
    if (val != 
# 672 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 672 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
        xmlNanoFTPFreeCtxt(val);
    }
}




static void *gen_xmlNanoHTTPCtxtPtr(int no, int nr __attribute__((unused))) {
    if (no == 0) return(xmlNanoHTTPOpen("http://localhost/", 
# 681 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                    ((void *)0)
# 681 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                        ));
    if (no == 1) return(xmlNanoHTTPOpen("ftp://localhost/foo", 
# 682 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                    ((void *)0)
# 682 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                        ));
    if (no == 2) return(xmlNanoHTTPOpen("http:http://http", 
# 683 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                   ((void *)0)
# 683 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                       ));
    return(
# 684 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 684 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlNanoHTTPCtxtPtr(int no __attribute__((unused)), void *val, int nr __attribute__((unused))) {
    if (val != 
# 687 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 687 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
 xmlNanoHTTPClose(val);
    }
}



static xmlCharEncoding gen_xmlCharEncoding(int no, int nr __attribute__((unused))) {
    if (no == 0) return(XML_CHAR_ENCODING_UTF8);
    if (no == 1) return(XML_CHAR_ENCODING_NONE);
    if (no == 2) return(XML_CHAR_ENCODING_8859_1);
    return(XML_CHAR_ENCODING_ERROR);
}
static void des_xmlCharEncoding(int no __attribute__((unused)), xmlCharEncoding val __attribute__((unused)), int nr __attribute__((unused))) {
}




static xmlExpCtxtPtr gen_xmlExpCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 707 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 707 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlExpCtxtPtr(int no __attribute__((unused)), xmlExpCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}


static xmlExpNodePtr gen_xmlExpNodePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 714 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 714 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlExpNodePtr(int no __attribute__((unused)), xmlExpNodePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}





static xmlSchemaPtr gen_xmlSchemaPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 724 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 724 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaPtr(int no __attribute__((unused)), xmlSchemaPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}


static xmlSchemaValidCtxtPtr gen_xmlSchemaValidCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 731 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 731 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaValidCtxtPtr(int no __attribute__((unused)), xmlSchemaValidCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}




static void
test_xmlHashDeallocator(void *payload __attribute__((unused)), xmlChar *name __attribute__((unused))) {
}

static xmlHashDeallocator gen_xmlHashDeallocator(int no, int nr __attribute__((unused))) {
    if (no == 0) return(test_xmlHashDeallocator);
    return(
# 745 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 745 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlHashDeallocator(int no __attribute__((unused)), xmlHashDeallocator val __attribute__((unused)), int nr __attribute__((unused))) {
}


static void desret_int(int val __attribute__((unused))) {
}
static void desret_xmlChar(xmlChar val __attribute__((unused))) {
}
static void desret_long(long val __attribute__((unused))) {
}
static void desret_unsigned_long(unsigned long val __attribute__((unused))) {
}
static void desret_double(double val __attribute__((unused))) {
}
static void desret_xmlCharEncoding(xmlCharEncoding val __attribute__((unused))) {
}




static void desret_void_ptr(void *val __attribute__((unused))) {
}
static void desret_const_char_ptr(const char *val __attribute__((unused))) {
}
static void desret_const_xmlChar_ptr(const xmlChar *val __attribute__((unused))) {
}
static void desret_xmlChar_ptr(xmlChar *val) {
    if (val != 
# 774 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 774 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  )
 xmlFree(val);
}
static void desret_xmlDocPtr(xmlDocPtr val) {
    if (val != api_doc)
 xmlFreeDoc(val);
}
static void desret_xmlDictPtr(xmlDictPtr val) {
    xmlDictFree(val);
}

static void desret_xmlOutputBufferPtr(xmlOutputBufferPtr val) {
    xmlOutputBufferClose(val);
}


static void desret_xmlTextReaderPtr(xmlTextReaderPtr val) {
    xmlFreeTextReader(val);
}

static void desret_xmlNodePtr(xmlNodePtr val) {
    if ((val != 
# 795 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
               ((void *)0)
# 795 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                   ) && (val != api_root) && (val != (xmlNodePtr) api_doc)) {
 xmlUnlinkNode(val);
 xmlFreeNode(val);
    }
}
static void desret_xmlAttrPtr(xmlAttrPtr val) {
    if (val != 
# 801 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 801 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
 xmlUnlinkNode((xmlNodePtr) val);
 xmlFreeNode((xmlNodePtr) val);
    }
}
static void desret_xmlEntityPtr(xmlEntityPtr val) {
    if (val != 
# 807 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 807 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
 xmlUnlinkNode((xmlNodePtr) val);
 xmlFreeNode((xmlNodePtr) val);
    }
}
static void desret_xmlElementPtr(xmlElementPtr val) {
    if (val != 
# 813 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 813 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
 xmlUnlinkNode((xmlNodePtr) val);
    }
}
static void desret_xmlAttributePtr(xmlAttributePtr val) {
    if (val != 
# 818 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 818 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  ) {
 xmlUnlinkNode((xmlNodePtr) val);
    }
}
static void desret_xmlNsPtr(xmlNsPtr val __attribute__((unused))) {
}
static void desret_xmlDtdPtr(xmlDtdPtr val) {
    desret_xmlNodePtr((xmlNodePtr)val);
}

static void desret_xmlXPathObjectPtr(xmlXPathObjectPtr val) {
    xmlXPathFreeObject(val);
}
static void desret_xmlNodeSetPtr(xmlNodeSetPtr val) {
    xmlXPathFreeNodeSet(val);
}

static void desret_xmlParserCtxtPtr(xmlParserCtxtPtr val) {
    xmlFreeParserCtxt(val);
}
static void desret_xmlParserInputBufferPtr(xmlParserInputBufferPtr val) {
    xmlFreeParserInputBuffer(val);
}
static void desret_xmlParserInputPtr(xmlParserInputPtr val) {
    xmlFreeInputStream(val);
}

static void desret_xmlTextWriterPtr(xmlTextWriterPtr val) {
    xmlFreeTextWriter(val);
}

static void desret_xmlBufferPtr(xmlBufferPtr val) {
    xmlBufferFree(val);
}

static void desret_xmlSchemaParserCtxtPtr(xmlSchemaParserCtxtPtr val) {
    xmlSchemaFreeParserCtxt(val);
}
static void desret_xmlSchemaTypePtr(xmlSchemaTypePtr val __attribute__((unused))) {
}
static void desret_xmlRelaxNGParserCtxtPtr(xmlRelaxNGParserCtxtPtr val) {
    xmlRelaxNGFreeParserCtxt(val);
}


static void desret_const_htmlEntityDesc_ptr(const htmlEntityDesc * val __attribute__((unused))) {
}


static void desret_xmlNanoHTTPCtxtPtr(void *val) {
    xmlNanoHTTPClose(val);
}


static void desret_xmlNanoFTPCtxtPtr(void *val) {
    xmlNanoFTPClose(val);
}



static xmlChar ** gen_const_xmlChar_ptr_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 879 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 879 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlChar_ptr_ptr(int no __attribute__((unused)), const xmlChar ** val __attribute__((unused)), int nr __attribute__((unused))) {
}


static unsigned char * gen_unsigned_char_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 886 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 886 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_unsigned_char_ptr(int no __attribute__((unused)), unsigned char * val __attribute__((unused)), int nr __attribute__((unused))) {
}


static unsigned char * gen_const_unsigned_char_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 893 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 893 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_unsigned_char_ptr(int no __attribute__((unused)), const unsigned char * val __attribute__((unused)), int nr __attribute__((unused))) {
}



static htmlNodePtr gen_const_htmlNodePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 901 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 901 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_htmlNodePtr(int no __attribute__((unused)), const htmlNodePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}




static htmlDocPtr gen_htmlDocPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    if (no == 0) return(htmlNewDoc(
# 910 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                  ((void *)0)
# 910 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                      , 
# 910 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                        ((void *)0)
# 910 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                            ));
    if (no == 1) return(htmlReadMemory("<html/>", 7, "test", 
# 911 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                            ((void *)0)
# 911 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                , 0));
    return(
# 912 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 912 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_htmlDocPtr(int no __attribute__((unused)), htmlDocPtr val __attribute__((unused)), int nr __attribute__((unused))) {
    if ((val != 
# 915 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
               ((void *)0)
# 915 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                   ) && (val != api_doc) && (val->doc != api_doc))
        xmlFreeDoc(val);
}
static void desret_htmlDocPtr(htmlDocPtr val) {
    if ((val != 
# 919 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
               ((void *)0)
# 919 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                   ) && (val != api_doc) && (val->doc != api_doc))
        xmlFreeDoc(val);
}

static htmlParserCtxtPtr gen_htmlParserCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    if (no == 0) return(xmlNewParserCtxt());
    if (no == 1) return(htmlCreateMemoryParserCtxt("<html/>", 7));
    return(
# 926 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 926 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_htmlParserCtxtPtr(int no __attribute__((unused)), htmlParserCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
    if (val != 
# 929 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 929 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  )
        htmlFreeParserCtxt(val);
}
static void desret_htmlParserCtxtPtr(htmlParserCtxtPtr val) {
    if (val != 
# 933 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 933 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  )
        htmlFreeParserCtxt(val);
}




static xmlNodeSetPtr gen_xmlNodeSetPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 941 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 941 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlNodeSetPtr(int no __attribute__((unused)), xmlNodeSetPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}





static xmlShellCtxtPtr gen_xmlShellCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 951 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 951 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlShellCtxtPtr(int no __attribute__((unused)), xmlShellCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}





static xmlPatternPtr gen_xmlPatternPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 961 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 961 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlPatternPtr(int no __attribute__((unused)), xmlPatternPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static xmlElementContentPtr gen_xmlElementContentPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 969 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 969 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlElementContentPtr(int no __attribute__((unused)), xmlElementContentPtr val, int nr __attribute__((unused))) {
    if (val != 
# 972 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 972 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  )
        xmlFreeElementContent(val);
}
static void desret_xmlElementContentPtr(xmlElementContentPtr val) {
    if (val != 
# 976 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
              ((void *)0)
# 976 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                  )
        xmlFreeElementContent(val);
}


static xmlParserNodeInfoSeqPtr gen_xmlParserNodeInfoSeqPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 982 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 982 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlParserNodeInfoSeqPtr(int no __attribute__((unused)), xmlParserNodeInfoSeqPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static void desret_const_xmlParserNodeInfo_ptr(const xmlParserNodeInfo *val __attribute__((unused))) {
}


static void ** gen_void_ptr_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 992 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 992 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_void_ptr_ptr(int no __attribute__((unused)), void ** val __attribute__((unused)), int nr __attribute__((unused))) {
}
# 1006 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
static void desret_htmlStatus(htmlStatus val __attribute__((unused))) {
}




static xmlAttributeDefault gen_xmlAttributeDefault(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_ATTRIBUTE_FIXED);
    if (no == 2) return(XML_ATTRIBUTE_IMPLIED);
    if (no == 3) return(XML_ATTRIBUTE_NONE);
    if (no == 4) return(XML_ATTRIBUTE_REQUIRED);
    return(0);
}

static void des_xmlAttributeDefault(int no __attribute__((unused)), xmlAttributeDefault val __attribute__((unused)), int nr __attribute__((unused))) {
}


static xmlAttributeType gen_xmlAttributeType(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_ATTRIBUTE_CDATA);
    if (no == 2) return(XML_ATTRIBUTE_ENTITIES);
    if (no == 3) return(XML_ATTRIBUTE_ENTITY);
    if (no == 4) return(XML_ATTRIBUTE_ENUMERATION);
    return(0);
}

static void des_xmlAttributeType(int no __attribute__((unused)), xmlAttributeType val __attribute__((unused)), int nr __attribute__((unused))) {
}


static xmlBufferAllocationScheme gen_xmlBufferAllocationScheme(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_BUFFER_ALLOC_DOUBLEIT);
    if (no == 2) return(XML_BUFFER_ALLOC_EXACT);
    if (no == 3) return(XML_BUFFER_ALLOC_HYBRID);
    if (no == 4) return(XML_BUFFER_ALLOC_IMMUTABLE);
    return(0);
}

static void des_xmlBufferAllocationScheme(int no __attribute__((unused)), xmlBufferAllocationScheme val __attribute__((unused)), int nr __attribute__((unused))) {
}

static void desret_xmlBufferAllocationScheme(xmlBufferAllocationScheme val __attribute__((unused))) {
}



static xmlCatalogAllow gen_xmlCatalogAllow(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_CATA_ALLOW_ALL);
    if (no == 2) return(XML_CATA_ALLOW_DOCUMENT);
    if (no == 3) return(XML_CATA_ALLOW_GLOBAL);
    if (no == 4) return(XML_CATA_ALLOW_NONE);
    return(0);
}

static void des_xmlCatalogAllow(int no __attribute__((unused)), xmlCatalogAllow val __attribute__((unused)), int nr __attribute__((unused))) {
}

static void desret_xmlCatalogAllow(xmlCatalogAllow val __attribute__((unused))) {
}





static xmlCatalogPrefer gen_xmlCatalogPrefer(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_CATA_PREFER_NONE);
    if (no == 2) return(XML_CATA_PREFER_PUBLIC);
    if (no == 3) return(XML_CATA_PREFER_SYSTEM);
    return(0);
}

static void des_xmlCatalogPrefer(int no __attribute__((unused)), xmlCatalogPrefer val __attribute__((unused)), int nr __attribute__((unused))) {
}

static void desret_xmlCatalogPrefer(xmlCatalogPrefer val __attribute__((unused))) {
}




static xmlElementContentType gen_xmlElementContentType(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_ELEMENT_CONTENT_ELEMENT);
    if (no == 2) return(XML_ELEMENT_CONTENT_OR);
    if (no == 3) return(XML_ELEMENT_CONTENT_PCDATA);
    if (no == 4) return(XML_ELEMENT_CONTENT_SEQ);
    return(0);
}

static void des_xmlElementContentType(int no __attribute__((unused)), xmlElementContentType val __attribute__((unused)), int nr __attribute__((unused))) {
}


static xmlElementTypeVal gen_xmlElementTypeVal(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_ELEMENT_TYPE_ANY);
    if (no == 2) return(XML_ELEMENT_TYPE_ELEMENT);
    if (no == 3) return(XML_ELEMENT_TYPE_EMPTY);
    if (no == 4) return(XML_ELEMENT_TYPE_MIXED);
    return(0);
}

static void des_xmlElementTypeVal(int no __attribute__((unused)), xmlElementTypeVal val __attribute__((unused)), int nr __attribute__((unused))) {
}


static xmlFeature gen_xmlFeature(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_WITH_AUTOMATA);
    if (no == 2) return(XML_WITH_C14N);
    if (no == 3) return(XML_WITH_CATALOG);
    if (no == 4) return(XML_WITH_DEBUG);
    return(0);
}

static void des_xmlFeature(int no __attribute__((unused)), xmlFeature val __attribute__((unused)), int nr __attribute__((unused))) {
}

static void desret_xmlParserErrors(xmlParserErrors val __attribute__((unused))) {
}



static xmlSchemaValType gen_xmlSchemaValType(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_SCHEMAS_ANYSIMPLETYPE);
    if (no == 2) return(XML_SCHEMAS_ANYTYPE);
    if (no == 3) return(XML_SCHEMAS_ANYURI);
    if (no == 4) return(XML_SCHEMAS_BASE64BINARY);
    return(0);
}

static void des_xmlSchemaValType(int no __attribute__((unused)), xmlSchemaValType val __attribute__((unused)), int nr __attribute__((unused))) {
}

static void desret_xmlSchemaValType(xmlSchemaValType val __attribute__((unused))) {
}





static xmlSchemaWhitespaceValueType gen_xmlSchemaWhitespaceValueType(int no, int nr __attribute__((unused))) {
    if (no == 1) return(XML_SCHEMA_WHITESPACE_COLLAPSE);
    if (no == 2) return(XML_SCHEMA_WHITESPACE_PRESERVE);
    if (no == 3) return(XML_SCHEMA_WHITESPACE_REPLACE);
    if (no == 4) return(XML_SCHEMA_WHITESPACE_UNKNOWN);
    return(0);
}

static void des_xmlSchemaWhitespaceValueType(int no __attribute__((unused)), xmlSchemaWhitespaceValueType val __attribute__((unused)), int nr __attribute__((unused))) {
}






# 1 "./include/libxml/c14n.h" 1
# 61 "./include/libxml/c14n.h"
typedef enum {
    XML_C14N_1_0 = 0,
    XML_C14N_EXCLUSIVE_1_0 = 1,
    XML_C14N_1_1 = 2
} xmlC14NMode;

 int
  xmlC14NDocSaveTo (xmlDocPtr doc,
      xmlNodeSetPtr nodes,
      int mode,
      xmlChar **inclusive_ns_prefixes,
      int with_comments,
      xmlOutputBufferPtr buf);

 int
  xmlC14NDocDumpMemory (xmlDocPtr doc,
      xmlNodeSetPtr nodes,
      int mode,
      xmlChar **inclusive_ns_prefixes,
      int with_comments,
      xmlChar **doc_txt_ptr);

 int
  xmlC14NDocSave (xmlDocPtr doc,
      xmlNodeSetPtr nodes,
      int mode,
      xmlChar **inclusive_ns_prefixes,
      int with_comments,
      const char* filename,
      int compression);
# 106 "./include/libxml/c14n.h"
typedef int (*xmlC14NIsVisibleCallback) (void* user_data,
      xmlNodePtr node,
      xmlNodePtr parent);

 int
  xmlC14NExecute (xmlDocPtr doc,
      xmlC14NIsVisibleCallback is_visible_callback,
      void* user_data,
      int mode,
      xmlChar **inclusive_ns_prefixes,
      int with_comments,
      xmlOutputBufferPtr buf);
# 1161 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1183 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
# 1 "./include/libxml/xmlerror.h" 1
# 1184 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2
# 1 "./include/libxml/xmlmodule.h" 1
# 27 "./include/libxml/xmlmodule.h"
typedef struct _xmlModule xmlModule;
typedef xmlModule *xmlModulePtr;






typedef enum {
    XML_MODULE_LAZY = 1,
    XML_MODULE_LOCAL= 2
} xmlModuleOption;

 xmlModulePtr xmlModuleOpen (const char *filename,
       int options);

 int xmlModuleSymbol (xmlModulePtr module,
       const char* name,
       void **result);

 int xmlModuleClose (xmlModulePtr module);

 int xmlModuleFree (xmlModulePtr module);
# 1185 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2






# 1 "./include/libxml/xmlunicode.h" 1
# 26 "./include/libxml/xmlunicode.h"
 int xmlUCSIsAegeanNumbers (int code);
 int xmlUCSIsAlphabeticPresentationForms (int code);
 int xmlUCSIsArabic (int code);
 int xmlUCSIsArabicPresentationFormsA (int code);
 int xmlUCSIsArabicPresentationFormsB (int code);
 int xmlUCSIsArmenian (int code);
 int xmlUCSIsArrows (int code);
 int xmlUCSIsBasicLatin (int code);
 int xmlUCSIsBengali (int code);
 int xmlUCSIsBlockElements (int code);
 int xmlUCSIsBopomofo (int code);
 int xmlUCSIsBopomofoExtended (int code);
 int xmlUCSIsBoxDrawing (int code);
 int xmlUCSIsBraillePatterns (int code);
 int xmlUCSIsBuhid (int code);
 int xmlUCSIsByzantineMusicalSymbols (int code);
 int xmlUCSIsCJKCompatibility (int code);
 int xmlUCSIsCJKCompatibilityForms (int code);
 int xmlUCSIsCJKCompatibilityIdeographs (int code);
 int xmlUCSIsCJKCompatibilityIdeographsSupplement (int code);
 int xmlUCSIsCJKRadicalsSupplement (int code);
 int xmlUCSIsCJKSymbolsandPunctuation (int code);
 int xmlUCSIsCJKUnifiedIdeographs (int code);
 int xmlUCSIsCJKUnifiedIdeographsExtensionA (int code);
 int xmlUCSIsCJKUnifiedIdeographsExtensionB (int code);
 int xmlUCSIsCherokee (int code);
 int xmlUCSIsCombiningDiacriticalMarks (int code);
 int xmlUCSIsCombiningDiacriticalMarksforSymbols (int code);
 int xmlUCSIsCombiningHalfMarks (int code);
 int xmlUCSIsCombiningMarksforSymbols (int code);
 int xmlUCSIsControlPictures (int code);
 int xmlUCSIsCurrencySymbols (int code);
 int xmlUCSIsCypriotSyllabary (int code);
 int xmlUCSIsCyrillic (int code);
 int xmlUCSIsCyrillicSupplement (int code);
 int xmlUCSIsDeseret (int code);
 int xmlUCSIsDevanagari (int code);
 int xmlUCSIsDingbats (int code);
 int xmlUCSIsEnclosedAlphanumerics (int code);
 int xmlUCSIsEnclosedCJKLettersandMonths (int code);
 int xmlUCSIsEthiopic (int code);
 int xmlUCSIsGeneralPunctuation (int code);
 int xmlUCSIsGeometricShapes (int code);
 int xmlUCSIsGeorgian (int code);
 int xmlUCSIsGothic (int code);
 int xmlUCSIsGreek (int code);
 int xmlUCSIsGreekExtended (int code);
 int xmlUCSIsGreekandCoptic (int code);
 int xmlUCSIsGujarati (int code);
 int xmlUCSIsGurmukhi (int code);
 int xmlUCSIsHalfwidthandFullwidthForms (int code);
 int xmlUCSIsHangulCompatibilityJamo (int code);
 int xmlUCSIsHangulJamo (int code);
 int xmlUCSIsHangulSyllables (int code);
 int xmlUCSIsHanunoo (int code);
 int xmlUCSIsHebrew (int code);
 int xmlUCSIsHighPrivateUseSurrogates (int code);
 int xmlUCSIsHighSurrogates (int code);
 int xmlUCSIsHiragana (int code);
 int xmlUCSIsIPAExtensions (int code);
 int xmlUCSIsIdeographicDescriptionCharacters (int code);
 int xmlUCSIsKanbun (int code);
 int xmlUCSIsKangxiRadicals (int code);
 int xmlUCSIsKannada (int code);
 int xmlUCSIsKatakana (int code);
 int xmlUCSIsKatakanaPhoneticExtensions (int code);
 int xmlUCSIsKhmer (int code);
 int xmlUCSIsKhmerSymbols (int code);
 int xmlUCSIsLao (int code);
 int xmlUCSIsLatin1Supplement (int code);
 int xmlUCSIsLatinExtendedA (int code);
 int xmlUCSIsLatinExtendedB (int code);
 int xmlUCSIsLatinExtendedAdditional (int code);
 int xmlUCSIsLetterlikeSymbols (int code);
 int xmlUCSIsLimbu (int code);
 int xmlUCSIsLinearBIdeograms (int code);
 int xmlUCSIsLinearBSyllabary (int code);
 int xmlUCSIsLowSurrogates (int code);
 int xmlUCSIsMalayalam (int code);
 int xmlUCSIsMathematicalAlphanumericSymbols (int code);
 int xmlUCSIsMathematicalOperators (int code);
 int xmlUCSIsMiscellaneousMathematicalSymbolsA (int code);
 int xmlUCSIsMiscellaneousMathematicalSymbolsB (int code);
 int xmlUCSIsMiscellaneousSymbols (int code);
 int xmlUCSIsMiscellaneousSymbolsandArrows (int code);
 int xmlUCSIsMiscellaneousTechnical (int code);
 int xmlUCSIsMongolian (int code);
 int xmlUCSIsMusicalSymbols (int code);
 int xmlUCSIsMyanmar (int code);
 int xmlUCSIsNumberForms (int code);
 int xmlUCSIsOgham (int code);
 int xmlUCSIsOldItalic (int code);
 int xmlUCSIsOpticalCharacterRecognition (int code);
 int xmlUCSIsOriya (int code);
 int xmlUCSIsOsmanya (int code);
 int xmlUCSIsPhoneticExtensions (int code);
 int xmlUCSIsPrivateUse (int code);
 int xmlUCSIsPrivateUseArea (int code);
 int xmlUCSIsRunic (int code);
 int xmlUCSIsShavian (int code);
 int xmlUCSIsSinhala (int code);
 int xmlUCSIsSmallFormVariants (int code);
 int xmlUCSIsSpacingModifierLetters (int code);
 int xmlUCSIsSpecials (int code);
 int xmlUCSIsSuperscriptsandSubscripts (int code);
 int xmlUCSIsSupplementalArrowsA (int code);
 int xmlUCSIsSupplementalArrowsB (int code);
 int xmlUCSIsSupplementalMathematicalOperators (int code);
 int xmlUCSIsSupplementaryPrivateUseAreaA (int code);
 int xmlUCSIsSupplementaryPrivateUseAreaB (int code);
 int xmlUCSIsSyriac (int code);
 int xmlUCSIsTagalog (int code);
 int xmlUCSIsTagbanwa (int code);
 int xmlUCSIsTags (int code);
 int xmlUCSIsTaiLe (int code);
 int xmlUCSIsTaiXuanJingSymbols (int code);
 int xmlUCSIsTamil (int code);
 int xmlUCSIsTelugu (int code);
 int xmlUCSIsThaana (int code);
 int xmlUCSIsThai (int code);
 int xmlUCSIsTibetan (int code);
 int xmlUCSIsUgaritic (int code);
 int xmlUCSIsUnifiedCanadianAboriginalSyllabics (int code);
 int xmlUCSIsVariationSelectors (int code);
 int xmlUCSIsVariationSelectorsSupplement (int code);
 int xmlUCSIsYiRadicals (int code);
 int xmlUCSIsYiSyllables (int code);
 int xmlUCSIsYijingHexagramSymbols (int code);

 int xmlUCSIsBlock (int code, const char *block);

 int xmlUCSIsCatC (int code);
 int xmlUCSIsCatCc (int code);
 int xmlUCSIsCatCf (int code);
 int xmlUCSIsCatCo (int code);
 int xmlUCSIsCatCs (int code);
 int xmlUCSIsCatL (int code);
 int xmlUCSIsCatLl (int code);
 int xmlUCSIsCatLm (int code);
 int xmlUCSIsCatLo (int code);
 int xmlUCSIsCatLt (int code);
 int xmlUCSIsCatLu (int code);
 int xmlUCSIsCatM (int code);
 int xmlUCSIsCatMc (int code);
 int xmlUCSIsCatMe (int code);
 int xmlUCSIsCatMn (int code);
 int xmlUCSIsCatN (int code);
 int xmlUCSIsCatNd (int code);
 int xmlUCSIsCatNl (int code);
 int xmlUCSIsCatNo (int code);
 int xmlUCSIsCatP (int code);
 int xmlUCSIsCatPc (int code);
 int xmlUCSIsCatPd (int code);
 int xmlUCSIsCatPe (int code);
 int xmlUCSIsCatPf (int code);
 int xmlUCSIsCatPi (int code);
 int xmlUCSIsCatPo (int code);
 int xmlUCSIsCatPs (int code);
 int xmlUCSIsCatS (int code);
 int xmlUCSIsCatSc (int code);
 int xmlUCSIsCatSk (int code);
 int xmlUCSIsCatSm (int code);
 int xmlUCSIsCatSo (int code);
 int xmlUCSIsCatZ (int code);
 int xmlUCSIsCatZl (int code);
 int xmlUCSIsCatZp (int code);
 int xmlUCSIsCatZs (int code);

 int xmlUCSIsCat (int code, const char *cat);
# 1192 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 2




static int test_HTMLparser(void);
static int test_HTMLtree(void);
static int test_SAX2(void);
static int test_c14n(void);
static int test_catalog(void);
static int test_chvalid(void);
static int test_debugXML(void);
static int test_dict(void);
static int test_encoding(void);
static int test_entities(void);
static int test_hash(void);
static int test_list(void);
static int test_nanoftp(void);
static int test_nanohttp(void);
static int test_parser(void);
static int test_parserInternals(void);
static int test_pattern(void);
static int test_relaxng(void);
static int test_schemasInternals(void);
static int test_schematron(void);
static int test_tree(void);
static int test_uri(void);
static int test_valid(void);
static int test_xinclude(void);
static int test_xmlIO(void);
static int test_xmlautomata(void);
static int test_xmlerror(void);
static int test_xmlmodule(void);
static int test_xmlreader(void);
static int test_xmlregexp(void);
static int test_xmlsave(void);
static int test_xmlschemas(void);
static int test_xmlschemastypes(void);
static int test_xmlstring(void);
static int test_xmlunicode(void);
static int test_xmlwriter(void);
static int test_xpath(void);
static int test_xpathInternals(void);
static int test_xpointer(void);
# 1244 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
static int
testlibxml2(void)
{
    int test_ret = 0;

    test_ret += test_HTMLparser();
    test_ret += test_HTMLtree();
    test_ret += test_SAX2();
    test_ret += test_c14n();
    test_ret += test_catalog();
    test_ret += test_chvalid();
    test_ret += test_debugXML();
    test_ret += test_dict();
    test_ret += test_encoding();
    test_ret += test_entities();
    test_ret += test_hash();
    test_ret += test_list();
    test_ret += test_nanoftp();
    test_ret += test_nanohttp();
    test_ret += test_parser();
    test_ret += test_parserInternals();
    test_ret += test_pattern();
    test_ret += test_relaxng();
    test_ret += test_schemasInternals();
    test_ret += test_schematron();
    test_ret += test_tree();
    test_ret += test_uri();
    test_ret += test_valid();
    test_ret += test_xinclude();
    test_ret += test_xmlIO();
    test_ret += test_xmlautomata();
    test_ret += test_xmlerror();
    test_ret += test_xmlmodule();
    test_ret += test_xmlreader();
    test_ret += test_xmlregexp();
    test_ret += test_xmlsave();
    test_ret += test_xmlschemas();
    test_ret += test_xmlschemastypes();
    test_ret += test_xmlstring();
    test_ret += test_xmlunicode();
    test_ret += test_xmlwriter();
    test_ret += test_xpath();
    test_ret += test_xpathInternals();
    test_ret += test_xpointer();

    printf("Total: %d functions, %d tests, %d errors\n",
           function_tests, call_tests, test_ret);
    return(test_ret);
}


static int
test_UTF8ToHtml(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    unsigned char * out;
    int n_out;
    int * outlen;
    int n_outlen;
    unsigned char * in;
    int n_in;
    int * inlen;
    int n_inlen;

    for (n_out = 0;n_out < 1;n_out++) {
    for (n_outlen = 0;n_outlen < 2;n_outlen++) {
    for (n_in = 0;n_in < 1;n_in++) {
    for (n_inlen = 0;n_inlen < 2;n_inlen++) {
        mem_base = xmlMemBlocks();
        out = gen_unsigned_char_ptr(n_out, 0);
        outlen = gen_int_ptr(n_outlen, 1);
        in = gen_const_unsigned_char_ptr(n_in, 2);
        inlen = gen_int_ptr(n_inlen, 3);

        ret_val = UTF8ToHtml(out, outlen, (const unsigned char *)in, inlen);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_char_ptr(n_out, out, 0);
        des_int_ptr(n_outlen, outlen, 1);
        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 2);
        des_int_ptr(n_inlen, inlen, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in UTF8ToHtml",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf(" %d", n_outlen);
            printf(" %d", n_in);
            printf(" %d", n_inlen);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}




static htmlElemDesc * gen_const_htmlElemDesc_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 1353 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 1353 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_htmlElemDesc_ptr(int no __attribute__((unused)), const htmlElemDesc * val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_htmlAttrAllowed(void) {
    int test_ret = 0;


    int mem_base;
    htmlStatus ret_val;
    htmlElemDesc * elt;
    int n_elt;
    xmlChar * attr;
    int n_attr;
    int legacy;
    int n_legacy;

    for (n_elt = 0;n_elt < 1;n_elt++) {
    for (n_attr = 0;n_attr < 5;n_attr++) {
    for (n_legacy = 0;n_legacy < 4;n_legacy++) {
        mem_base = xmlMemBlocks();
        elt = gen_const_htmlElemDesc_ptr(n_elt, 0);
        attr = gen_const_xmlChar_ptr(n_attr, 1);
        legacy = gen_int(n_legacy, 2);

        ret_val = htmlAttrAllowed((const htmlElemDesc *)elt, (const xmlChar *)attr, legacy);
        desret_htmlStatus(ret_val);
        call_tests++;
        des_const_htmlElemDesc_ptr(n_elt, (const htmlElemDesc *)elt, 0);
        des_const_xmlChar_ptr(n_attr, (const xmlChar *)attr, 1);
        des_int(n_legacy, legacy, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlAttrAllowed",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_elt);
            printf(" %d", n_attr);
            printf(" %d", n_legacy);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}




static htmlNodePtr gen_htmlNodePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 1411 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 1411 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_htmlNodePtr(int no __attribute__((unused)), htmlNodePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_htmlAutoCloseTag(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    htmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;
    htmlNodePtr elem;
    int n_elem;

    for (n_doc = 0;n_doc < 3;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_elem = 0;n_elem < 1;n_elem++) {
        mem_base = xmlMemBlocks();
        doc = gen_htmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        elem = gen_htmlNodePtr(n_elem, 2);

        ret_val = htmlAutoCloseTag(doc, (const xmlChar *)name, elem);
        desret_int(ret_val);
        call_tests++;
        des_htmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_htmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlAutoCloseTag",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlCreateMemoryParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    htmlParserCtxtPtr ret_val;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;

    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = htmlCreateMemoryParserCtxt((const char *)buffer, size);
        desret_htmlParserCtxtPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCreateMemoryParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}




static htmlSAXHandlerPtr gen_htmlSAXHandlerPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 1510 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 1510 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_htmlSAXHandlerPtr(int no __attribute__((unused)), htmlSAXHandlerPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_htmlCreatePushParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    htmlParserCtxtPtr ret_val;
    htmlSAXHandlerPtr sax;
    int n_sax;
    void * user_data;
    int n_user_data;
    char * chunk;
    int n_chunk;
    int size;
    int n_size;
    const char * filename;
    int n_filename;
    xmlCharEncoding enc;
    int n_enc;

    for (n_sax = 0;n_sax < 1;n_sax++) {
    for (n_user_data = 0;n_user_data < 3;n_user_data++) {
    for (n_chunk = 0;n_chunk < 4;n_chunk++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        sax = gen_htmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        chunk = gen_const_char_ptr(n_chunk, 2);
        size = gen_int(n_size, 3);
        filename = gen_fileoutput(n_filename, 4);
        enc = gen_xmlCharEncoding(n_enc, 5);

        ret_val = htmlCreatePushParserCtxt(sax, user_data, (const char *)chunk, size, filename, enc);
        desret_htmlParserCtxtPtr(ret_val);
        call_tests++;
        des_htmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_const_char_ptr(n_chunk, (const char *)chunk, 2);
        des_int(n_size, size, 3);
        des_fileoutput(n_filename, filename, 4);
        des_xmlCharEncoding(n_enc, enc, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCreatePushParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_filename);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlCtxtReadDoc(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * cur;
    int n_cur;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = htmlCtxtReadDoc(ctxt, (const xmlChar *)cur, URL, (const char *)encoding, options);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlCtxtReadFile(void) {
    int test_ret = 0;


    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 4;n_options++) {
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        filename = gen_filepath(n_filename, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = htmlCtxtReadFile(ctxt, filename, (const char *)encoding, options);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_filepath(n_filename, filename, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlCtxtReadMemory(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        URL = gen_filepath(n_URL, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);
        options = gen_int(n_options, 5);

        ret_val = htmlCtxtReadMemory(ctxt, (const char *)buffer, size, URL, (const char *)encoding, options);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
        des_int(n_size, size, 2);
        des_filepath(n_URL, URL, 3);
        des_const_char_ptr(n_encoding, (const char *)encoding, 4);
        des_int(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReadMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlCtxtReset(void) {
    int test_ret = 0;


    int mem_base;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);

        htmlCtxtReset(ctxt);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtReset",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlCtxtUseOptions(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        options = gen_int(n_options, 1);

        ret_val = htmlCtxtUseOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_options, options, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCtxtUseOptions",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlElementAllowedHere(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    htmlElemDesc * parent;
    int n_parent;
    xmlChar * elt;
    int n_elt;

    for (n_parent = 0;n_parent < 1;n_parent++) {
    for (n_elt = 0;n_elt < 5;n_elt++) {
        mem_base = xmlMemBlocks();
        parent = gen_const_htmlElemDesc_ptr(n_parent, 0);
        elt = gen_const_xmlChar_ptr(n_elt, 1);

        ret_val = htmlElementAllowedHere((const htmlElemDesc *)parent, (const xmlChar *)elt);
        desret_int(ret_val);
        call_tests++;
        des_const_htmlElemDesc_ptr(n_parent, (const htmlElemDesc *)parent, 0);
        des_const_xmlChar_ptr(n_elt, (const xmlChar *)elt, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlElementAllowedHere",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf(" %d", n_elt);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlElementStatusHere(void) {
    int test_ret = 0;


    int mem_base;
    htmlStatus ret_val;
    htmlElemDesc * parent;
    int n_parent;
    htmlElemDesc * elt;
    int n_elt;

    for (n_parent = 0;n_parent < 1;n_parent++) {
    for (n_elt = 0;n_elt < 1;n_elt++) {
        mem_base = xmlMemBlocks();
        parent = gen_const_htmlElemDesc_ptr(n_parent, 0);
        elt = gen_const_htmlElemDesc_ptr(n_elt, 1);

        ret_val = htmlElementStatusHere((const htmlElemDesc *)parent, (const htmlElemDesc *)elt);
        desret_htmlStatus(ret_val);
        call_tests++;
        des_const_htmlElemDesc_ptr(n_parent, (const htmlElemDesc *)parent, 0);
        des_const_htmlElemDesc_ptr(n_elt, (const htmlElemDesc *)elt, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlElementStatusHere",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf(" %d", n_elt);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlEncodeEntities(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    unsigned char * out;
    int n_out;
    int * outlen;
    int n_outlen;
    unsigned char * in;
    int n_in;
    int * inlen;
    int n_inlen;
    int quoteChar;
    int n_quoteChar;

    for (n_out = 0;n_out < 1;n_out++) {
    for (n_outlen = 0;n_outlen < 2;n_outlen++) {
    for (n_in = 0;n_in < 1;n_in++) {
    for (n_inlen = 0;n_inlen < 2;n_inlen++) {
    for (n_quoteChar = 0;n_quoteChar < 4;n_quoteChar++) {
        mem_base = xmlMemBlocks();
        out = gen_unsigned_char_ptr(n_out, 0);
        outlen = gen_int_ptr(n_outlen, 1);
        in = gen_const_unsigned_char_ptr(n_in, 2);
        inlen = gen_int_ptr(n_inlen, 3);
        quoteChar = gen_int(n_quoteChar, 4);

        ret_val = htmlEncodeEntities(out, outlen, (const unsigned char *)in, inlen, quoteChar);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_char_ptr(n_out, out, 0);
        des_int_ptr(n_outlen, outlen, 1);
        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 2);
        des_int_ptr(n_inlen, inlen, 3);
        des_int(n_quoteChar, quoteChar, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlEncodeEntities",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf(" %d", n_outlen);
            printf(" %d", n_in);
            printf(" %d", n_inlen);
            printf(" %d", n_quoteChar);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlEntityLookup(void) {
    int test_ret = 0;


    int mem_base;
    const htmlEntityDesc * ret_val;
    xmlChar * name;
    int n_name;

    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = htmlEntityLookup((const xmlChar *)name);
        desret_const_htmlEntityDesc_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlEntityLookup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlEntityValueLookup(void) {
    int test_ret = 0;


    int mem_base;
    const htmlEntityDesc * ret_val;
    unsigned int value;
    int n_value;

    for (n_value = 0;n_value < 3;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_unsigned_int(n_value, 0);

        ret_val = htmlEntityValueLookup(value);
        desret_const_htmlEntityDesc_ptr(ret_val);
        call_tests++;
        des_unsigned_int(n_value, value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlEntityValueLookup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlHandleOmittedElem(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = htmlHandleOmittedElem(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlHandleOmittedElem",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlIsAutoClosed(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    htmlDocPtr doc;
    int n_doc;
    htmlNodePtr elem;
    int n_elem;

    for (n_doc = 0;n_doc < 3;n_doc++) {
    for (n_elem = 0;n_elem < 1;n_elem++) {
        mem_base = xmlMemBlocks();
        doc = gen_htmlDocPtr(n_doc, 0);
        elem = gen_htmlNodePtr(n_elem, 1);

        ret_val = htmlIsAutoClosed(doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_htmlDocPtr(n_doc, doc, 0);
        des_htmlNodePtr(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsAutoClosed",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlIsScriptAttribute(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlChar * name;
    int n_name;

    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = htmlIsScriptAttribute((const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsScriptAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlNewParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    htmlParserCtxtPtr ret_val;

        mem_base = xmlMemBlocks();

        ret_val = htmlNewParserCtxt();
        desret_htmlParserCtxtPtr(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNewParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_htmlNodeStatus(void) {
    int test_ret = 0;


    int mem_base;
    htmlStatus ret_val;
    htmlNodePtr node;
    int n_node;
    int legacy;
    int n_legacy;

    for (n_node = 0;n_node < 1;n_node++) {
    for (n_legacy = 0;n_legacy < 4;n_legacy++) {
        mem_base = xmlMemBlocks();
        node = gen_const_htmlNodePtr(n_node, 0);
        legacy = gen_int(n_legacy, 1);

        ret_val = htmlNodeStatus((const htmlNodePtr)node, legacy);
        desret_htmlStatus(ret_val);
        call_tests++;
        des_const_htmlNodePtr(n_node, (const htmlNodePtr)node, 0);
        des_int(n_legacy, legacy, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeStatus",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_legacy);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlParseCharRef(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);

        ret_val = htmlParseCharRef(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseCharRef",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlParseChunk(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;
    char * chunk;
    int n_chunk;
    int size;
    int n_size;
    int terminate;
    int n_terminate;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_chunk = 0;n_chunk < 4;n_chunk++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_terminate = 0;n_terminate < 4;n_terminate++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        chunk = gen_const_char_ptr(n_chunk, 1);
        size = gen_int(n_size, 2);
        terminate = gen_int(n_terminate, 3);

        ret_val = htmlParseChunk(ctxt, (const char *)chunk, size, terminate);
        if (ctxt != 
# 2283 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 2283 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       ) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = 
# 2283 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                 ((void *)0)
# 2283 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                     ;}
        desret_int(ret_val);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_chunk, (const char *)chunk, 1);
        des_int(n_size, size, 2);
        des_int(n_terminate, terminate, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseChunk",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_terminate);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlParseDoc(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * cur;
    int n_cur;
    char * encoding;
    int n_encoding;

    for (n_cur = 0;n_cur < 2;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);

        ret_val = htmlParseDoc(cur, (const char *)encoding);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur, 0);
        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlParseDocument(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);

        ret_val = htmlParseDocument(ctxt);
        if (ctxt != 
# 2368 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 2368 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       ) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = 
# 2368 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                 ((void *)0)
# 2368 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                     ;}
        desret_int(ret_val);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseDocument",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlParseElement(void) {
    int test_ret = 0;


    int mem_base;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);

        htmlParseElement(ctxt);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlParseEntityRef(void) {
    int test_ret = 0;


    int mem_base;
    const htmlEntityDesc * ret_val;
    htmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar ** str;
    int n_str;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_str = 0;n_str < 1;n_str++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_htmlParserCtxtPtr(n_ctxt, 0);
        str = gen_const_xmlChar_ptr_ptr(n_str, 1);

        ret_val = htmlParseEntityRef(ctxt, (const xmlChar **)str);
        desret_const_htmlEntityDesc_ptr(ret_val);
        call_tests++;
        des_htmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr_ptr(n_str, (const xmlChar **)str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlParseEntityRef",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlParseFile(void) {
    int test_ret = 0;


    htmlDocPtr ret_val;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;

    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);

        ret_val = htmlParseFile(filename, (const char *)encoding);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
        xmlResetLastError();
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlReadDoc(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * cur;
    int n_cur;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        URL = gen_filepath(n_URL, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_int(n_options, 3);

        ret_val = htmlReadDoc((const xmlChar *)cur, URL, (const char *)encoding, options);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
        des_filepath(n_URL, URL, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlReadFile(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        options = gen_int(n_options, 2);

        ret_val = htmlReadFile(filename, (const char *)encoding, options);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
        des_int(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlReadMemory(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_int(n_options, 4);

        ret_val = htmlReadMemory((const char *)buffer, size, URL, (const char *)encoding, options);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
        des_int(n_size, size, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        des_int(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlReadMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlSAXParseDoc(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * cur;
    int n_cur;
    char * encoding;
    int n_encoding;
    htmlSAXHandlerPtr sax;
    int n_sax;
    void * userData;
    int n_userData;

    for (n_cur = 0;n_cur < 2;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_sax = 0;n_sax < 1;n_sax++) {
    for (n_userData = 0;n_userData < 3;n_userData++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlChar_ptr(n_cur, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        sax = gen_htmlSAXHandlerPtr(n_sax, 2);
        userData = gen_userdata(n_userData, 3);

        ret_val = htmlSAXParseDoc(cur, (const char *)encoding, sax, userData);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_cur, cur, 0);
        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
        des_htmlSAXHandlerPtr(n_sax, sax, 2);
        des_userdata(n_userData, userData, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSAXParseDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_sax);
            printf(" %d", n_userData);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlSAXParseFile(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;
    htmlSAXHandlerPtr sax;
    int n_sax;
    void * userData;
    int n_userData;

    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_sax = 0;n_sax < 1;n_sax++) {
    for (n_userData = 0;n_userData < 3;n_userData++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        sax = gen_htmlSAXHandlerPtr(n_sax, 2);
        userData = gen_userdata(n_userData, 3);

        ret_val = htmlSAXParseFile(filename, (const char *)encoding, sax, userData);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
        des_htmlSAXHandlerPtr(n_sax, sax, 2);
        des_userdata(n_userData, userData, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSAXParseFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_sax);
            printf(" %d", n_userData);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlTagLookup(void) {
    int test_ret = 0;



    return(test_ret);
}

static int
test_HTMLparser(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing HTMLparser : 32 of 38 functions ...\n");
    test_ret += test_UTF8ToHtml();
    test_ret += test_htmlAttrAllowed();
    test_ret += test_htmlAutoCloseTag();
    test_ret += test_htmlCreateMemoryParserCtxt();
    test_ret += test_htmlCreatePushParserCtxt();
    test_ret += test_htmlCtxtReadDoc();
    test_ret += test_htmlCtxtReadFile();
    test_ret += test_htmlCtxtReadMemory();
    test_ret += test_htmlCtxtReset();
    test_ret += test_htmlCtxtUseOptions();
    test_ret += test_htmlElementAllowedHere();
    test_ret += test_htmlElementStatusHere();
    test_ret += test_htmlEncodeEntities();
    test_ret += test_htmlEntityLookup();
    test_ret += test_htmlEntityValueLookup();
    test_ret += test_htmlHandleOmittedElem();
    test_ret += test_htmlIsAutoClosed();
    test_ret += test_htmlIsScriptAttribute();
    test_ret += test_htmlNewParserCtxt();
    test_ret += test_htmlNodeStatus();
    test_ret += test_htmlParseCharRef();
    test_ret += test_htmlParseChunk();
    test_ret += test_htmlParseDoc();
    test_ret += test_htmlParseDocument();
    test_ret += test_htmlParseElement();
    test_ret += test_htmlParseEntityRef();
    test_ret += test_htmlParseFile();
    test_ret += test_htmlReadDoc();
    test_ret += test_htmlReadFile();
    test_ret += test_htmlReadMemory();
    test_ret += test_htmlSAXParseDoc();
    test_ret += test_htmlSAXParseFile();
    test_ret += test_htmlTagLookup();

    if (test_ret != 0)
 printf("Module HTMLparser: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_htmlDocContentDumpFormatOutput(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr buf;
    int n_buf;
    xmlDocPtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;
    int format;
    int n_format;

    for (n_buf = 0;n_buf < 2;n_buf++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        htmlDocContentDumpFormatOutput(buf, cur, (const char *)encoding, format);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocContentDumpFormatOutput",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlDocContentDumpOutput(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr buf;
    int n_buf;
    xmlDocPtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;

    for (n_buf = 0;n_buf < 2;n_buf++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        htmlDocContentDumpOutput(buf, cur, (const char *)encoding);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocContentDumpOutput",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlDocDump(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    FILE * f;
    int n_f;
    xmlDocPtr cur;
    int n_cur;

    for (n_f = 0;n_f < 2;n_f++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = htmlDocDump(f, cur);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_f);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}



static xmlChar ** gen_xmlChar_ptr_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 2962 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 2962 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlChar_ptr_ptr(int no __attribute__((unused)), xmlChar ** val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_htmlDocDumpMemory(void) {
    int test_ret = 0;


    int mem_base;
    xmlDocPtr cur;
    int n_cur;
    xmlChar ** mem;
    int n_mem;
    int * size;
    int n_size;

    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_mem = 0;n_mem < 1;n_mem++) {
    for (n_size = 0;n_size < 2;n_size++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlDocPtr(n_cur, 0);
        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
        size = gen_int_ptr(n_size, 2);

        htmlDocDumpMemory(cur, mem, size);
        call_tests++;
        des_xmlDocPtr(n_cur, cur, 0);
        des_xmlChar_ptr_ptr(n_mem, mem, 1);
        des_int_ptr(n_size, size, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocDumpMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlDocDumpMemoryFormat(void) {
    int test_ret = 0;


    int mem_base;
    xmlDocPtr cur;
    int n_cur;
    xmlChar ** mem;
    int n_mem;
    int * size;
    int n_size;
    int format;
    int n_format;

    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_mem = 0;n_mem < 1;n_mem++) {
    for (n_size = 0;n_size < 2;n_size++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlDocPtr(n_cur, 0);
        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
        size = gen_int_ptr(n_size, 2);
        format = gen_int(n_format, 3);

        htmlDocDumpMemoryFormat(cur, mem, size, format);
        call_tests++;
        des_xmlDocPtr(n_cur, cur, 0);
        des_xmlChar_ptr_ptr(n_mem, mem, 1);
        des_int_ptr(n_size, size, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDocDumpMemoryFormat",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlGetMetaEncoding(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    htmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 3;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_htmlDocPtr(n_doc, 0);

        ret_val = htmlGetMetaEncoding(doc);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_htmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlGetMetaEncoding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlIsBooleanAttr(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlChar * name;
    int n_name;

    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = htmlIsBooleanAttr((const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlIsBooleanAttr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlNewDoc(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * URI;
    int n_URI;
    xmlChar * ExternalID;
    int n_ExternalID;

    for (n_URI = 0;n_URI < 5;n_URI++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);

        ret_val = htmlNewDoc((const xmlChar *)URI, (const xmlChar *)ExternalID);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNewDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URI);
            printf(" %d", n_ExternalID);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlNewDocNoDtD(void) {
    int test_ret = 0;


    int mem_base;
    htmlDocPtr ret_val;
    xmlChar * URI;
    int n_URI;
    xmlChar * ExternalID;
    int n_ExternalID;

    for (n_URI = 0;n_URI < 5;n_URI++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);

        ret_val = htmlNewDocNoDtD((const xmlChar *)URI, (const xmlChar *)ExternalID);
        desret_htmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNewDocNoDtD",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URI);
            printf(" %d", n_ExternalID);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlNodeDump(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr cur;
    int n_cur;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);

        ret_val = htmlNodeDump(buf, doc, cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlNodeDumpFile(void) {
    int test_ret = 0;


    int mem_base;
    FILE * out;
    int n_out;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr cur;
    int n_cur;

    for (n_out = 0;n_out < 2;n_out++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);

        htmlNodeDumpFile(out, doc, cur);
        call_tests++;
        des_FILE_ptr(n_out, out, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlNodeDumpFileFormat(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    FILE * out;
    int n_out;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;
    int format;
    int n_format;

    for (n_out = 0;n_out < 2;n_out++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        format = gen_int(n_format, 4);

        ret_val = htmlNodeDumpFileFormat(out, doc, cur, (const char *)encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_out, out, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpFileFormat",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlNodeDumpFormatOutput(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr buf;
    int n_buf;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;
    int format;
    int n_format;

    for (n_buf = 0;n_buf < 2;n_buf++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        format = gen_int(n_format, 4);

        htmlNodeDumpFormatOutput(buf, doc, cur, (const char *)encoding, format);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpFormatOutput",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlNodeDumpOutput(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr buf;
    int n_buf;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;

    for (n_buf = 0;n_buf < 2;n_buf++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);

        htmlNodeDumpOutput(buf, doc, cur, (const char *)encoding);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlNodeDumpOutput",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlSaveFile(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;
    xmlDocPtr cur;
    int n_cur;

    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = htmlSaveFile(filename, cur);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlSaveFileEnc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;
    xmlDocPtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;

    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        ret_val = htmlSaveFileEnc(filename, cur, (const char *)encoding);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFileEnc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlSaveFileFormat(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;
    xmlDocPtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;
    int format;
    int n_format;

    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        ret_val = htmlSaveFileFormat(filename, cur, (const char *)encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSaveFileFormat",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlSetMetaEncoding(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    htmlDocPtr doc;
    int n_doc;
    xmlChar * encoding;
    int n_encoding;

    for (n_doc = 0;n_doc < 3;n_doc++) {
    for (n_encoding = 0;n_encoding < 5;n_encoding++) {
        mem_base = xmlMemBlocks();
        doc = gen_htmlDocPtr(n_doc, 0);
        encoding = gen_const_xmlChar_ptr(n_encoding, 1);

        ret_val = htmlSetMetaEncoding(doc, (const xmlChar *)encoding);
        desret_int(ret_val);
        call_tests++;
        des_htmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_encoding, (const xmlChar *)encoding, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlSetMetaEncoding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_HTMLtree(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing HTMLtree : 18 of 18 functions ...\n");
    test_ret += test_htmlDocContentDumpFormatOutput();
    test_ret += test_htmlDocContentDumpOutput();
    test_ret += test_htmlDocDump();
    test_ret += test_htmlDocDumpMemory();
    test_ret += test_htmlDocDumpMemoryFormat();
    test_ret += test_htmlGetMetaEncoding();
    test_ret += test_htmlIsBooleanAttr();
    test_ret += test_htmlNewDoc();
    test_ret += test_htmlNewDocNoDtD();
    test_ret += test_htmlNodeDump();
    test_ret += test_htmlNodeDumpFile();
    test_ret += test_htmlNodeDumpFileFormat();
    test_ret += test_htmlNodeDumpFormatOutput();
    test_ret += test_htmlNodeDumpOutput();
    test_ret += test_htmlSaveFile();
    test_ret += test_htmlSaveFileEnc();
    test_ret += test_htmlSaveFileFormat();
    test_ret += test_htmlSetMetaEncoding();

    if (test_ret != 0)
 printf("Module HTMLtree: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_docbDefaultSAXHandlerInit(void) {
    int test_ret = 0;



    int mem_base;

        mem_base = xmlMemBlocks();

        docbDefaultSAXHandlerInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in docbDefaultSAXHandlerInit",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;



    return(test_ret);
}


static int
test_htmlDefaultSAXHandlerInit(void) {
    int test_ret = 0;



    int mem_base;

        mem_base = xmlMemBlocks();

        htmlDefaultSAXHandlerInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlDefaultSAXHandlerInit",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;



    return(test_ret);
}


static int
test_xmlDefaultSAXHandlerInit(void) {
    int test_ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlDefaultSAXHandlerInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDefaultSAXHandlerInit",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}



static xmlEnumerationPtr gen_xmlEnumerationPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 3777 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 3777 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlEnumerationPtr(int no __attribute__((unused)), xmlEnumerationPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlSAX2AttributeDecl(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * elem;
    int n_elem;
    xmlChar * fullname;
    int n_fullname;
    int type;
    int n_type;
    int def;
    int n_def;
    xmlChar * defaultValue;
    int n_defaultValue;
    xmlEnumerationPtr tree;
    int n_tree;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_elem = 0;n_elem < 5;n_elem++) {
    for (n_fullname = 0;n_fullname < 5;n_fullname++) {
    for (n_type = 0;n_type < 4;n_type++) {
    for (n_def = 0;n_def < 4;n_def++) {
    for (n_defaultValue = 0;n_defaultValue < 5;n_defaultValue++) {
    for (n_tree = 0;n_tree < 1;n_tree++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        elem = gen_const_xmlChar_ptr(n_elem, 1);
        fullname = gen_const_xmlChar_ptr(n_fullname, 2);
        type = gen_int(n_type, 3);
        def = gen_int(n_def, 4);
        defaultValue = gen_const_xmlChar_ptr(n_defaultValue, 5);
        tree = gen_xmlEnumerationPtr(n_tree, 6);

        xmlSAX2AttributeDecl(ctx, (const xmlChar *)elem, (const xmlChar *)fullname, type, def, (const xmlChar *)defaultValue, tree);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_elem, (const xmlChar *)elem, 1);
        des_const_xmlChar_ptr(n_fullname, (const xmlChar *)fullname, 2);
        des_int(n_type, type, 3);
        des_int(n_def, def, 4);
        des_const_xmlChar_ptr(n_defaultValue, (const xmlChar *)defaultValue, 5);
        des_xmlEnumerationPtr(n_tree, tree, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2AttributeDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_elem);
            printf(" %d", n_fullname);
            printf(" %d", n_type);
            printf(" %d", n_def);
            printf(" %d", n_defaultValue);
            printf(" %d", n_tree);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2CDataBlock(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * value;
    int n_value;
    int len;
    int n_len;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        len = gen_int(n_len, 2);

        xmlSAX2CDataBlock(ctx, (const xmlChar *)value, len);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2CDataBlock",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_value);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2Characters(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * ch;
    int n_ch;
    int len;
    int n_len;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_ch = 0;n_ch < 5;n_ch++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        ch = gen_const_xmlChar_ptr(n_ch, 1);
        len = gen_int(n_len, 2);

        xmlSAX2Characters(ctx, (const xmlChar *)ch, len);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_ch, (const xmlChar *)ch, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2Characters",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_ch);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2Comment(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * value;
    int n_value;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);

        xmlSAX2Comment(ctx, (const xmlChar *)value);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2Comment",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2ElementDecl(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;
    int type;
    int n_type;
    xmlElementContentPtr content;
    int n_content;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_type = 0;n_type < 4;n_type++) {
    for (n_content = 0;n_content < 1;n_content++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        type = gen_int(n_type, 2);
        content = gen_xmlElementContentPtr(n_content, 3);

        xmlSAX2ElementDecl(ctx, (const xmlChar *)name, type, content);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_int(n_type, type, 2);
        des_xmlElementContentPtr(n_content, content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2ElementDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2EndDocument(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        xmlSAX2EndDocument(ctx);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2EndDocument",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2EndElement(void) {
    int test_ret = 0;



    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        xmlSAX2EndElement(ctx, (const xmlChar *)name);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2EndElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAX2EndElementNs(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * localname;
    int n_localname;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * URI;
    int n_URI;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_localname = 0;n_localname < 5;n_localname++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_URI = 0;n_URI < 5;n_URI++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        localname = gen_const_xmlChar_ptr(n_localname, 1);
        prefix = gen_const_xmlChar_ptr(n_prefix, 2);
        URI = gen_const_xmlChar_ptr(n_URI, 3);

        xmlSAX2EndElementNs(ctx, (const xmlChar *)localname, (const xmlChar *)prefix, (const xmlChar *)URI);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_localname, (const xmlChar *)localname, 1);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 2);
        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2EndElementNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_localname);
            printf(" %d", n_prefix);
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2EntityDecl(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;
    int type;
    int n_type;
    xmlChar * publicId;
    int n_publicId;
    xmlChar * systemId;
    int n_systemId;
    xmlChar * content;
    int n_content;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_type = 0;n_type < 4;n_type++) {
    for (n_publicId = 0;n_publicId < 5;n_publicId++) {
    for (n_systemId = 0;n_systemId < 5;n_systemId++) {
    for (n_content = 0;n_content < 2;n_content++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        type = gen_int(n_type, 2);
        publicId = gen_const_xmlChar_ptr(n_publicId, 3);
        systemId = gen_const_xmlChar_ptr(n_systemId, 4);
        content = gen_xmlChar_ptr(n_content, 5);

        xmlSAX2EntityDecl(ctx, (const xmlChar *)name, type, (const xmlChar *)publicId, (const xmlChar *)systemId, content);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_int(n_type, type, 2);
        des_const_xmlChar_ptr(n_publicId, (const xmlChar *)publicId, 3);
        des_const_xmlChar_ptr(n_systemId, (const xmlChar *)systemId, 4);
        des_xmlChar_ptr(n_content, content, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2EntityDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf(" %d", n_publicId);
            printf(" %d", n_systemId);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2ExternalSubset(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;
    xmlChar * ExternalID;
    int n_ExternalID;
    xmlChar * SystemID;
    int n_SystemID;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < 5;n_SystemID++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);

        xmlSAX2ExternalSubset(ctx, (const xmlChar *)name, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 2);
        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2ExternalSubset",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2GetColumnNumber(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        ret_val = xmlSAX2GetColumnNumber(ctx);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2GetColumnNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2GetEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlSAX2GetEntity(ctx, (const xmlChar *)name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2GetEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2GetLineNumber(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        ret_val = xmlSAX2GetLineNumber(ctx);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2GetLineNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2GetParameterEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlSAX2GetParameterEntity(ctx, (const xmlChar *)name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2GetParameterEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2GetPublicId(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        ret_val = xmlSAX2GetPublicId(ctx);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2GetPublicId",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2GetSystemId(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        ret_val = xmlSAX2GetSystemId(ctx);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2GetSystemId",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2HasExternalSubset(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        ret_val = xmlSAX2HasExternalSubset(ctx);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2HasExternalSubset",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2HasInternalSubset(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        ret_val = xmlSAX2HasInternalSubset(ctx);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2HasInternalSubset",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2IgnorableWhitespace(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * ch;
    int n_ch;
    int len;
    int n_len;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_ch = 0;n_ch < 5;n_ch++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        ch = gen_const_xmlChar_ptr(n_ch, 1);
        len = gen_int(n_len, 2);

        xmlSAX2IgnorableWhitespace(ctx, (const xmlChar *)ch, len);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_ch, (const xmlChar *)ch, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2IgnorableWhitespace",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_ch);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}



static xmlSAXHandler * gen_xmlSAXHandler_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 4584 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 4584 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSAXHandler_ptr(int no __attribute__((unused)), xmlSAXHandler * val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlSAX2InitDefaultSAXHandler(void) {
    int test_ret = 0;

    int mem_base;
    xmlSAXHandler * hdlr;
    int n_hdlr;
    int warning;
    int n_warning;

    for (n_hdlr = 0;n_hdlr < 1;n_hdlr++) {
    for (n_warning = 0;n_warning < 4;n_warning++) {
        mem_base = xmlMemBlocks();
        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0);
        warning = gen_int(n_warning, 1);

        xmlSAX2InitDefaultSAXHandler(hdlr, warning);
        call_tests++;
        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0);
        des_int(n_warning, warning, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2InitDefaultSAXHandler",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_hdlr);
            printf(" %d", n_warning);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2InitDocbDefaultSAXHandler(void) {
    int test_ret = 0;


    int mem_base;
    xmlSAXHandler * hdlr;
    int n_hdlr;

    for (n_hdlr = 0;n_hdlr < 1;n_hdlr++) {
        mem_base = xmlMemBlocks();
        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0);

        xmlSAX2InitDocbDefaultSAXHandler(hdlr);
        call_tests++;
        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2InitDocbDefaultSAXHandler",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_hdlr);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSAX2InitHtmlDefaultSAXHandler(void) {
    int test_ret = 0;


    int mem_base;
    xmlSAXHandler * hdlr;
    int n_hdlr;

    for (n_hdlr = 0;n_hdlr < 1;n_hdlr++) {
        mem_base = xmlMemBlocks();
        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0);

        xmlSAX2InitHtmlDefaultSAXHandler(hdlr);
        call_tests++;
        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2InitHtmlDefaultSAXHandler",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_hdlr);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSAX2InternalSubset(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;
    xmlChar * ExternalID;
    int n_ExternalID;
    xmlChar * SystemID;
    int n_SystemID;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < 5;n_SystemID++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);

        xmlSAX2InternalSubset(ctx, (const xmlChar *)name, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 2);
        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2InternalSubset",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2IsStandalone(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        ret_val = xmlSAX2IsStandalone(ctx);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2IsStandalone",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2NotationDecl(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;
    xmlChar * publicId;
    int n_publicId;
    xmlChar * systemId;
    int n_systemId;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_publicId = 0;n_publicId < 5;n_publicId++) {
    for (n_systemId = 0;n_systemId < 5;n_systemId++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        publicId = gen_const_xmlChar_ptr(n_publicId, 2);
        systemId = gen_const_xmlChar_ptr(n_systemId, 3);

        xmlSAX2NotationDecl(ctx, (const xmlChar *)name, (const xmlChar *)publicId, (const xmlChar *)systemId);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_publicId, (const xmlChar *)publicId, 2);
        des_const_xmlChar_ptr(n_systemId, (const xmlChar *)systemId, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2NotationDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf(" %d", n_publicId);
            printf(" %d", n_systemId);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2ProcessingInstruction(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * target;
    int n_target;
    xmlChar * data;
    int n_data;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_target = 0;n_target < 5;n_target++) {
    for (n_data = 0;n_data < 5;n_data++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        target = gen_const_xmlChar_ptr(n_target, 1);
        data = gen_const_xmlChar_ptr(n_data, 2);

        xmlSAX2ProcessingInstruction(ctx, (const xmlChar *)target, (const xmlChar *)data);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_target, (const xmlChar *)target, 1);
        des_const_xmlChar_ptr(n_data, (const xmlChar *)data, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2ProcessingInstruction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_target);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2Reference(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        xmlSAX2Reference(ctx, (const xmlChar *)name);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2Reference",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2ResolveEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    void * ctx;
    int n_ctx;
    xmlChar * publicId;
    int n_publicId;
    xmlChar * systemId;
    int n_systemId;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_publicId = 0;n_publicId < 5;n_publicId++) {
    for (n_systemId = 0;n_systemId < 5;n_systemId++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        publicId = gen_const_xmlChar_ptr(n_publicId, 1);
        systemId = gen_const_xmlChar_ptr(n_systemId, 2);

        ret_val = xmlSAX2ResolveEntity(ctx, (const xmlChar *)publicId, (const xmlChar *)systemId);
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_publicId, (const xmlChar *)publicId, 1);
        des_const_xmlChar_ptr(n_systemId, (const xmlChar *)systemId, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2ResolveEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_publicId);
            printf(" %d", n_systemId);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}



static xmlSAXLocatorPtr gen_xmlSAXLocatorPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 4953 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 4953 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSAXLocatorPtr(int no __attribute__((unused)), xmlSAXLocatorPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlSAX2SetDocumentLocator(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlSAXLocatorPtr loc;
    int n_loc;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_loc = 0;n_loc < 1;n_loc++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        loc = gen_xmlSAXLocatorPtr(n_loc, 1);

        xmlSAX2SetDocumentLocator(ctx, loc);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_xmlSAXLocatorPtr(n_loc, loc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2SetDocumentLocator",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_loc);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2StartDocument(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        xmlSAX2StartDocument(ctx);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2StartDocument",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2StartElement(void) {
    int test_ret = 0;



    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * fullname;
    int n_fullname;
    xmlChar ** atts;
    int n_atts;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_fullname = 0;n_fullname < 5;n_fullname++) {
    for (n_atts = 0;n_atts < 1;n_atts++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        fullname = gen_const_xmlChar_ptr(n_fullname, 1);
        atts = gen_const_xmlChar_ptr_ptr(n_atts, 2);

        xmlSAX2StartElement(ctx, (const xmlChar *)fullname, (const xmlChar **)atts);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_fullname, (const xmlChar *)fullname, 1);
        des_const_xmlChar_ptr_ptr(n_atts, (const xmlChar **)atts, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2StartElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_fullname);
            printf(" %d", n_atts);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAX2StartElementNs(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * localname;
    int n_localname;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * URI;
    int n_URI;
    int nb_namespaces;
    int n_nb_namespaces;
    xmlChar ** namespaces;
    int n_namespaces;
    int nb_attributes;
    int n_nb_attributes;
    int nb_defaulted;
    int n_nb_defaulted;
    xmlChar ** attributes;
    int n_attributes;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_localname = 0;n_localname < 5;n_localname++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_URI = 0;n_URI < 5;n_URI++) {
    for (n_nb_namespaces = 0;n_nb_namespaces < 4;n_nb_namespaces++) {
    for (n_namespaces = 0;n_namespaces < 1;n_namespaces++) {
    for (n_nb_attributes = 0;n_nb_attributes < 4;n_nb_attributes++) {
    for (n_nb_defaulted = 0;n_nb_defaulted < 4;n_nb_defaulted++) {
    for (n_attributes = 0;n_attributes < 1;n_attributes++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        localname = gen_const_xmlChar_ptr(n_localname, 1);
        prefix = gen_const_xmlChar_ptr(n_prefix, 2);
        URI = gen_const_xmlChar_ptr(n_URI, 3);
        nb_namespaces = gen_int(n_nb_namespaces, 4);
        namespaces = gen_const_xmlChar_ptr_ptr(n_namespaces, 5);
        nb_attributes = gen_int(n_nb_attributes, 6);
        nb_defaulted = gen_int(n_nb_defaulted, 7);
        attributes = gen_const_xmlChar_ptr_ptr(n_attributes, 8);

        xmlSAX2StartElementNs(ctx, (const xmlChar *)localname, (const xmlChar *)prefix, (const xmlChar *)URI, nb_namespaces, (const xmlChar **)namespaces, nb_attributes, nb_defaulted, (const xmlChar **)attributes);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_localname, (const xmlChar *)localname, 1);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 2);
        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 3);
        des_int(n_nb_namespaces, nb_namespaces, 4);
        des_const_xmlChar_ptr_ptr(n_namespaces, (const xmlChar **)namespaces, 5);
        des_int(n_nb_attributes, nb_attributes, 6);
        des_int(n_nb_defaulted, nb_defaulted, 7);
        des_const_xmlChar_ptr_ptr(n_attributes, (const xmlChar **)attributes, 8);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2StartElementNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_localname);
            printf(" %d", n_prefix);
            printf(" %d", n_URI);
            printf(" %d", n_nb_namespaces);
            printf(" %d", n_namespaces);
            printf(" %d", n_nb_attributes);
            printf(" %d", n_nb_defaulted);
            printf(" %d", n_attributes);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAX2UnparsedEntityDecl(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;
    xmlChar * name;
    int n_name;
    xmlChar * publicId;
    int n_publicId;
    xmlChar * systemId;
    int n_systemId;
    xmlChar * notationName;
    int n_notationName;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_publicId = 0;n_publicId < 5;n_publicId++) {
    for (n_systemId = 0;n_systemId < 5;n_systemId++) {
    for (n_notationName = 0;n_notationName < 5;n_notationName++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        publicId = gen_const_xmlChar_ptr(n_publicId, 2);
        systemId = gen_const_xmlChar_ptr(n_systemId, 3);
        notationName = gen_const_xmlChar_ptr(n_notationName, 4);

        xmlSAX2UnparsedEntityDecl(ctx, (const xmlChar *)name, (const xmlChar *)publicId, (const xmlChar *)systemId, (const xmlChar *)notationName);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_publicId, (const xmlChar *)publicId, 2);
        des_const_xmlChar_ptr(n_systemId, (const xmlChar *)systemId, 3);
        des_const_xmlChar_ptr(n_notationName, (const xmlChar *)notationName, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAX2UnparsedEntityDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_name);
            printf(" %d", n_publicId);
            printf(" %d", n_systemId);
            printf(" %d", n_notationName);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSAXDefaultVersion(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    int version;
    int n_version;

    for (n_version = 0;n_version < 4;n_version++) {
        mem_base = xmlMemBlocks();
        version = gen_int(n_version, 0);

        ret_val = xmlSAXDefaultVersion(version);
        desret_int(ret_val);
        call_tests++;
        des_int(n_version, version, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXDefaultVersion",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_version);
            printf("\n");
        }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXVersion(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlSAXHandler * hdlr;
    int n_hdlr;
    int version;
    int n_version;

    for (n_hdlr = 0;n_hdlr < 1;n_hdlr++) {
    for (n_version = 0;n_version < 4;n_version++) {
        mem_base = xmlMemBlocks();
        hdlr = gen_xmlSAXHandler_ptr(n_hdlr, 0);
        version = gen_int(n_version, 1);

        ret_val = xmlSAXVersion(hdlr, version);
        desret_int(ret_val);
        call_tests++;
        des_xmlSAXHandler_ptr(n_hdlr, hdlr, 0);
        des_int(n_version, version, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXVersion",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_hdlr);
            printf(" %d", n_version);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}

static int
test_SAX2(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing SAX2 : 38 of 38 functions ...\n");
    test_ret += test_docbDefaultSAXHandlerInit();
    test_ret += test_htmlDefaultSAXHandlerInit();
    test_ret += test_xmlDefaultSAXHandlerInit();
    test_ret += test_xmlSAX2AttributeDecl();
    test_ret += test_xmlSAX2CDataBlock();
    test_ret += test_xmlSAX2Characters();
    test_ret += test_xmlSAX2Comment();
    test_ret += test_xmlSAX2ElementDecl();
    test_ret += test_xmlSAX2EndDocument();
    test_ret += test_xmlSAX2EndElement();
    test_ret += test_xmlSAX2EndElementNs();
    test_ret += test_xmlSAX2EntityDecl();
    test_ret += test_xmlSAX2ExternalSubset();
    test_ret += test_xmlSAX2GetColumnNumber();
    test_ret += test_xmlSAX2GetEntity();
    test_ret += test_xmlSAX2GetLineNumber();
    test_ret += test_xmlSAX2GetParameterEntity();
    test_ret += test_xmlSAX2GetPublicId();
    test_ret += test_xmlSAX2GetSystemId();
    test_ret += test_xmlSAX2HasExternalSubset();
    test_ret += test_xmlSAX2HasInternalSubset();
    test_ret += test_xmlSAX2IgnorableWhitespace();
    test_ret += test_xmlSAX2InitDefaultSAXHandler();
    test_ret += test_xmlSAX2InitDocbDefaultSAXHandler();
    test_ret += test_xmlSAX2InitHtmlDefaultSAXHandler();
    test_ret += test_xmlSAX2InternalSubset();
    test_ret += test_xmlSAX2IsStandalone();
    test_ret += test_xmlSAX2NotationDecl();
    test_ret += test_xmlSAX2ProcessingInstruction();
    test_ret += test_xmlSAX2Reference();
    test_ret += test_xmlSAX2ResolveEntity();
    test_ret += test_xmlSAX2SetDocumentLocator();
    test_ret += test_xmlSAX2StartDocument();
    test_ret += test_xmlSAX2StartElement();
    test_ret += test_xmlSAX2StartElementNs();
    test_ret += test_xmlSAX2UnparsedEntityDecl();
    test_ret += test_xmlSAXDefaultVersion();
    test_ret += test_xmlSAXVersion();

    if (test_ret != 0)
 printf("Module SAX2: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlC14NDocDumpMemory(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodeSetPtr nodes;
    int n_nodes;
    int mode;
    int n_mode;
    xmlChar ** inclusive_ns_prefixes;
    int n_inclusive_ns_prefixes;
    int with_comments;
    int n_with_comments;
    xmlChar ** doc_txt_ptr;
    int n_doc_txt_ptr;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_nodes = 0;n_nodes < 1;n_nodes++) {
    for (n_mode = 0;n_mode < 4;n_mode++) {
    for (n_inclusive_ns_prefixes = 0;n_inclusive_ns_prefixes < 1;n_inclusive_ns_prefixes++) {
    for (n_with_comments = 0;n_with_comments < 4;n_with_comments++) {
    for (n_doc_txt_ptr = 0;n_doc_txt_ptr < 1;n_doc_txt_ptr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        nodes = gen_xmlNodeSetPtr(n_nodes, 1);
        mode = gen_int(n_mode, 2);
        inclusive_ns_prefixes = gen_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, 3);
        with_comments = gen_int(n_with_comments, 4);
        doc_txt_ptr = gen_xmlChar_ptr_ptr(n_doc_txt_ptr, 5);

        ret_val = xmlC14NDocDumpMemory(doc, nodes, mode, inclusive_ns_prefixes, with_comments, doc_txt_ptr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodeSetPtr(n_nodes, nodes, 1);
        des_int(n_mode, mode, 2);
        des_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, inclusive_ns_prefixes, 3);
        des_int(n_with_comments, with_comments, 4);
        des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlC14NDocDumpMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_nodes);
            printf(" %d", n_mode);
            printf(" %d", n_inclusive_ns_prefixes);
            printf(" %d", n_with_comments);
            printf(" %d", n_doc_txt_ptr);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlC14NDocSave(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodeSetPtr nodes;
    int n_nodes;
    int mode;
    int n_mode;
    xmlChar ** inclusive_ns_prefixes;
    int n_inclusive_ns_prefixes;
    int with_comments;
    int n_with_comments;
    const char * filename;
    int n_filename;
    int compression;
    int n_compression;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_nodes = 0;n_nodes < 1;n_nodes++) {
    for (n_mode = 0;n_mode < 4;n_mode++) {
    for (n_inclusive_ns_prefixes = 0;n_inclusive_ns_prefixes < 1;n_inclusive_ns_prefixes++) {
    for (n_with_comments = 0;n_with_comments < 4;n_with_comments++) {
    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_compression = 0;n_compression < 4;n_compression++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        nodes = gen_xmlNodeSetPtr(n_nodes, 1);
        mode = gen_int(n_mode, 2);
        inclusive_ns_prefixes = gen_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, 3);
        with_comments = gen_int(n_with_comments, 4);
        filename = gen_fileoutput(n_filename, 5);
        compression = gen_int(n_compression, 6);

        ret_val = xmlC14NDocSave(doc, nodes, mode, inclusive_ns_prefixes, with_comments, filename, compression);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodeSetPtr(n_nodes, nodes, 1);
        des_int(n_mode, mode, 2);
        des_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, inclusive_ns_prefixes, 3);
        des_int(n_with_comments, with_comments, 4);
        des_fileoutput(n_filename, filename, 5);
        des_int(n_compression, compression, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlC14NDocSave",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_nodes);
            printf(" %d", n_mode);
            printf(" %d", n_inclusive_ns_prefixes);
            printf(" %d", n_with_comments);
            printf(" %d", n_filename);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlC14NDocSaveTo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodeSetPtr nodes;
    int n_nodes;
    int mode;
    int n_mode;
    xmlChar ** inclusive_ns_prefixes;
    int n_inclusive_ns_prefixes;
    int with_comments;
    int n_with_comments;
    xmlOutputBufferPtr buf;
    int n_buf;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_nodes = 0;n_nodes < 1;n_nodes++) {
    for (n_mode = 0;n_mode < 4;n_mode++) {
    for (n_inclusive_ns_prefixes = 0;n_inclusive_ns_prefixes < 1;n_inclusive_ns_prefixes++) {
    for (n_with_comments = 0;n_with_comments < 4;n_with_comments++) {
    for (n_buf = 0;n_buf < 2;n_buf++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        nodes = gen_xmlNodeSetPtr(n_nodes, 1);
        mode = gen_int(n_mode, 2);
        inclusive_ns_prefixes = gen_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, 3);
        with_comments = gen_int(n_with_comments, 4);
        buf = gen_xmlOutputBufferPtr(n_buf, 5);

        ret_val = xmlC14NDocSaveTo(doc, nodes, mode, inclusive_ns_prefixes, with_comments, buf);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodeSetPtr(n_nodes, nodes, 1);
        des_int(n_mode, mode, 2);
        des_xmlChar_ptr_ptr(n_inclusive_ns_prefixes, inclusive_ns_prefixes, 3);
        des_int(n_with_comments, with_comments, 4);
        des_xmlOutputBufferPtr(n_buf, buf, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlC14NDocSaveTo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_nodes);
            printf(" %d", n_mode);
            printf(" %d", n_inclusive_ns_prefixes);
            printf(" %d", n_with_comments);
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlC14NExecute(void) {
    int test_ret = 0;



    return(test_ret);
}

static int
test_c14n(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing c14n : 3 of 4 functions ...\n");
    test_ret += test_xmlC14NDocDumpMemory();
    test_ret += test_xmlC14NDocSave();
    test_ret += test_xmlC14NDocSaveTo();
    test_ret += test_xmlC14NExecute();

    if (test_ret != 0)
 printf("Module c14n: %d errors\n", test_ret);
    return(test_ret);
}



static xmlCatalogPtr gen_xmlCatalogPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 5581 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 5581 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlCatalogPtr(int no __attribute__((unused)), xmlCatalogPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlACatalogAdd(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlCatalogPtr catal;
    int n_catal;
    xmlChar * type;
    int n_type;
    xmlChar * orig;
    int n_orig;
    xmlChar * replace;
    int n_replace;

    for (n_catal = 0;n_catal < 1;n_catal++) {
    for (n_type = 0;n_type < 5;n_type++) {
    for (n_orig = 0;n_orig < 5;n_orig++) {
    for (n_replace = 0;n_replace < 5;n_replace++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        type = gen_const_xmlChar_ptr(n_type, 1);
        orig = gen_const_xmlChar_ptr(n_orig, 2);
        replace = gen_const_xmlChar_ptr(n_replace, 3);

        ret_val = xmlACatalogAdd(catal, (const xmlChar *)type, (const xmlChar *)orig, (const xmlChar *)replace);
        desret_int(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_type, (const xmlChar *)type, 1);
        des_const_xmlChar_ptr(n_orig, (const xmlChar *)orig, 2);
        des_const_xmlChar_ptr(n_replace, (const xmlChar *)replace, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogAdd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catal);
            printf(" %d", n_type);
            printf(" %d", n_orig);
            printf(" %d", n_replace);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlACatalogDump(void) {
    int test_ret = 0;


    int mem_base;
    xmlCatalogPtr catal;
    int n_catal;
    FILE * out;
    int n_out;

    for (n_catal = 0;n_catal < 1;n_catal++) {
    for (n_out = 0;n_out < 2;n_out++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        out = gen_FILE_ptr(n_out, 1);

        xmlACatalogDump(catal, out);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_FILE_ptr(n_out, out, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catal);
            printf(" %d", n_out);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlACatalogRemove(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlCatalogPtr catal;
    int n_catal;
    xmlChar * value;
    int n_value;

    for (n_catal = 0;n_catal < 1;n_catal++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);

        ret_val = xmlACatalogRemove(catal, (const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogRemove",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catal);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlACatalogResolve(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlCatalogPtr catal;
    int n_catal;
    xmlChar * pubID;
    int n_pubID;
    xmlChar * sysID;
    int n_sysID;

    for (n_catal = 0;n_catal < 1;n_catal++) {
    for (n_pubID = 0;n_pubID < 5;n_pubID++) {
    for (n_sysID = 0;n_sysID < 5;n_sysID++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        pubID = gen_const_xmlChar_ptr(n_pubID, 1);
        sysID = gen_const_xmlChar_ptr(n_sysID, 2);

        ret_val = xmlACatalogResolve(catal, (const xmlChar *)pubID, (const xmlChar *)sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 1);
        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogResolve",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catal);
            printf(" %d", n_pubID);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlACatalogResolvePublic(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlCatalogPtr catal;
    int n_catal;
    xmlChar * pubID;
    int n_pubID;

    for (n_catal = 0;n_catal < 1;n_catal++) {
    for (n_pubID = 0;n_pubID < 5;n_pubID++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        pubID = gen_const_xmlChar_ptr(n_pubID, 1);

        ret_val = xmlACatalogResolvePublic(catal, (const xmlChar *)pubID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogResolvePublic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catal);
            printf(" %d", n_pubID);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlACatalogResolveSystem(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlCatalogPtr catal;
    int n_catal;
    xmlChar * sysID;
    int n_sysID;

    for (n_catal = 0;n_catal < 1;n_catal++) {
    for (n_sysID = 0;n_sysID < 5;n_sysID++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        sysID = gen_const_xmlChar_ptr(n_sysID, 1);

        ret_val = xmlACatalogResolveSystem(catal, (const xmlChar *)sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogResolveSystem",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catal);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlACatalogResolveURI(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlCatalogPtr catal;
    int n_catal;
    xmlChar * URI;
    int n_URI;

    for (n_catal = 0;n_catal < 1;n_catal++) {
    for (n_URI = 0;n_URI < 5;n_URI++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);
        URI = gen_const_xmlChar_ptr(n_URI, 1);

        ret_val = xmlACatalogResolveURI(catal, (const xmlChar *)URI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlACatalogResolveURI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catal);
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogAdd(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlChar * type;
    int n_type;
    xmlChar * orig;
    int n_orig;
    xmlChar * replace;
    int n_replace;

    for (n_type = 0;n_type < 5;n_type++) {
    for (n_orig = 0;n_orig < 5;n_orig++) {
    for (n_replace = 0;n_replace < 5;n_replace++) {
        mem_base = xmlMemBlocks();
        type = gen_const_xmlChar_ptr(n_type, 0);
        orig = gen_const_xmlChar_ptr(n_orig, 1);
        replace = gen_const_xmlChar_ptr(n_replace, 2);

        ret_val = xmlCatalogAdd((const xmlChar *)type, (const xmlChar *)orig, (const xmlChar *)replace);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_type, (const xmlChar *)type, 0);
        des_const_xmlChar_ptr(n_orig, (const xmlChar *)orig, 1);
        des_const_xmlChar_ptr(n_replace, (const xmlChar *)replace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogAdd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_type);
            printf(" %d", n_orig);
            printf(" %d", n_replace);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogCleanup(void) {
    int test_ret = 0;




        xmlCatalogCleanup();
        call_tests++;
        xmlResetLastError();
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogConvert(void) {
    int test_ret = 0;


    int ret_val;


        ret_val = xmlCatalogConvert();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogDump(void) {
    int test_ret = 0;


    int mem_base;
    FILE * out;
    int n_out;

    for (n_out = 0;n_out < 2;n_out++) {
        mem_base = xmlMemBlocks();
        out = gen_FILE_ptr(n_out, 0);

        xmlCatalogDump(out);
        call_tests++;
        des_FILE_ptr(n_out, out, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogGetDefaults(void) {
    int test_ret = 0;


    int mem_base;
    xmlCatalogAllow ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlCatalogGetDefaults();
        desret_xmlCatalogAllow(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogGetDefaults",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogIsEmpty(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlCatalogPtr catal;
    int n_catal;

    for (n_catal = 0;n_catal < 1;n_catal++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);

        ret_val = xmlCatalogIsEmpty(catal);
        desret_int(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogIsEmpty",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catal);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogLocalResolve(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    void * catalogs;
    int n_catalogs;
    xmlChar * pubID;
    int n_pubID;
    xmlChar * sysID;
    int n_sysID;

    for (n_catalogs = 0;n_catalogs < 2;n_catalogs++) {
    for (n_pubID = 0;n_pubID < 5;n_pubID++) {
    for (n_sysID = 0;n_sysID < 5;n_sysID++) {
        mem_base = xmlMemBlocks();
        catalogs = gen_void_ptr(n_catalogs, 0);
        pubID = gen_const_xmlChar_ptr(n_pubID, 1);
        sysID = gen_const_xmlChar_ptr(n_sysID, 2);

        ret_val = xmlCatalogLocalResolve(catalogs, (const xmlChar *)pubID, (const xmlChar *)sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_void_ptr(n_catalogs, catalogs, 0);
        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 1);
        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogLocalResolve",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catalogs);
            printf(" %d", n_pubID);
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogLocalResolveURI(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    void * catalogs;
    int n_catalogs;
    xmlChar * URI;
    int n_URI;

    for (n_catalogs = 0;n_catalogs < 2;n_catalogs++) {
    for (n_URI = 0;n_URI < 5;n_URI++) {
        mem_base = xmlMemBlocks();
        catalogs = gen_void_ptr(n_catalogs, 0);
        URI = gen_const_xmlChar_ptr(n_URI, 1);

        ret_val = xmlCatalogLocalResolveURI(catalogs, (const xmlChar *)URI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_void_ptr(n_catalogs, catalogs, 0);
        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogLocalResolveURI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catalogs);
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogRemove(void) {
    int test_ret = 0;


    int ret_val;
    xmlChar * value;
    int n_value;

    for (n_value = 0;n_value < 5;n_value++) {
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlCatalogRemove((const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        xmlResetLastError();
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogResolve(void) {
    int test_ret = 0;


    xmlChar * ret_val;
    xmlChar * pubID;
    int n_pubID;
    xmlChar * sysID;
    int n_sysID;

    for (n_pubID = 0;n_pubID < 5;n_pubID++) {
    for (n_sysID = 0;n_sysID < 5;n_sysID++) {
        pubID = gen_const_xmlChar_ptr(n_pubID, 0);
        sysID = gen_const_xmlChar_ptr(n_sysID, 1);

        ret_val = xmlCatalogResolve((const xmlChar *)pubID, (const xmlChar *)sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 0);
        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 1);
        xmlResetLastError();
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogResolvePublic(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlChar * pubID;
    int n_pubID;

    for (n_pubID = 0;n_pubID < 5;n_pubID++) {
        mem_base = xmlMemBlocks();
        pubID = gen_const_xmlChar_ptr(n_pubID, 0);

        ret_val = xmlCatalogResolvePublic((const xmlChar *)pubID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pubID, (const xmlChar *)pubID, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolvePublic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_pubID);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogResolveSystem(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlChar * sysID;
    int n_sysID;

    for (n_sysID = 0;n_sysID < 5;n_sysID++) {
        mem_base = xmlMemBlocks();
        sysID = gen_const_xmlChar_ptr(n_sysID, 0);

        ret_val = xmlCatalogResolveSystem((const xmlChar *)sysID);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_sysID, (const xmlChar *)sysID, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolveSystem",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sysID);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogResolveURI(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlChar * URI;
    int n_URI;

    for (n_URI = 0;n_URI < 5;n_URI++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);

        ret_val = xmlCatalogResolveURI((const xmlChar *)URI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogResolveURI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogSetDefaultPrefer(void) {
    int test_ret = 0;


    int mem_base;
    xmlCatalogPrefer ret_val;
    xmlCatalogPrefer prefer;
    int n_prefer;

    for (n_prefer = 0;n_prefer < 3;n_prefer++) {
        mem_base = xmlMemBlocks();
        prefer = gen_xmlCatalogPrefer(n_prefer, 0);

        ret_val = xmlCatalogSetDefaultPrefer(prefer);
        desret_xmlCatalogPrefer(ret_val);
        call_tests++;
        des_xmlCatalogPrefer(n_prefer, prefer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogSetDefaultPrefer",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_prefer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCatalogSetDefaults(void) {
    int test_ret = 0;


    int mem_base;
    xmlCatalogAllow allow;
    int n_allow;

    for (n_allow = 0;n_allow < 4;n_allow++) {
        mem_base = xmlMemBlocks();
        allow = gen_xmlCatalogAllow(n_allow, 0);

        xmlCatalogSetDefaults(allow);
        call_tests++;
        des_xmlCatalogAllow(n_allow, allow, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCatalogSetDefaults",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_allow);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlConvertSGMLCatalog(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlCatalogPtr catal;
    int n_catal;

    for (n_catal = 0;n_catal < 1;n_catal++) {
        mem_base = xmlMemBlocks();
        catal = gen_xmlCatalogPtr(n_catal, 0);

        ret_val = xmlConvertSGMLCatalog(catal);
        desret_int(ret_val);
        call_tests++;
        des_xmlCatalogPtr(n_catal, catal, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlConvertSGMLCatalog",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_catal);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlInitializeCatalog(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitializeCatalog();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitializeCatalog",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlLoadACatalog(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlLoadCatalog(void) {
    int test_ret = 0;


    int ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlLoadCatalog(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlLoadCatalogs(void) {
    int test_ret = 0;


    char * pathss;
    int n_pathss;

    for (n_pathss = 0;n_pathss < 4;n_pathss++) {
        pathss = gen_const_char_ptr(n_pathss, 0);

        xmlLoadCatalogs((const char *)pathss);
        call_tests++;
        des_const_char_ptr(n_pathss, (const char *)pathss, 0);
        xmlResetLastError();
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlLoadSGMLSuperCatalog(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlNewCatalog(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlParseCatalogFile(void) {
    int test_ret = 0;


    int mem_base;
    xmlDocPtr ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlParseCatalogFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseCatalogFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}

static int
test_catalog(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing catalog : 27 of 36 functions ...\n");
    test_ret += test_xmlACatalogAdd();
    test_ret += test_xmlACatalogDump();
    test_ret += test_xmlACatalogRemove();
    test_ret += test_xmlACatalogResolve();
    test_ret += test_xmlACatalogResolvePublic();
    test_ret += test_xmlACatalogResolveSystem();
    test_ret += test_xmlACatalogResolveURI();
    test_ret += test_xmlCatalogAdd();
    test_ret += test_xmlCatalogCleanup();
    test_ret += test_xmlCatalogConvert();
    test_ret += test_xmlCatalogDump();
    test_ret += test_xmlCatalogGetDefaults();
    test_ret += test_xmlCatalogIsEmpty();
    test_ret += test_xmlCatalogLocalResolve();
    test_ret += test_xmlCatalogLocalResolveURI();
    test_ret += test_xmlCatalogRemove();
    test_ret += test_xmlCatalogResolve();
    test_ret += test_xmlCatalogResolvePublic();
    test_ret += test_xmlCatalogResolveSystem();
    test_ret += test_xmlCatalogResolveURI();
    test_ret += test_xmlCatalogSetDefaultPrefer();
    test_ret += test_xmlCatalogSetDefaults();
    test_ret += test_xmlConvertSGMLCatalog();
    test_ret += test_xmlInitializeCatalog();
    test_ret += test_xmlLoadACatalog();
    test_ret += test_xmlLoadCatalog();
    test_ret += test_xmlLoadCatalogs();
    test_ret += test_xmlLoadSGMLSuperCatalog();
    test_ret += test_xmlNewCatalog();
    test_ret += test_xmlParseCatalogFile();

    if (test_ret != 0)
 printf("Module catalog: %d errors\n", test_ret);
    return(test_ret);
}


static xmlChRangeGroup * gen_const_xmlChRangeGroup_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 6597 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 6597 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlChRangeGroup_ptr(int no __attribute__((unused)), const xmlChRangeGroup * val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlCharInRange(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned int val;
    int n_val;
    xmlChRangeGroup * rptr;
    int n_rptr;

    for (n_val = 0;n_val < 3;n_val++) {
    for (n_rptr = 0;n_rptr < 1;n_rptr++) {
        mem_base = xmlMemBlocks();
        val = gen_unsigned_int(n_val, 0);
        rptr = gen_const_xmlChRangeGroup_ptr(n_rptr, 1);

        ret_val = xmlCharInRange(val, (const xmlChRangeGroup *)rptr);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_val, val, 0);
        des_const_xmlChRangeGroup_ptr(n_rptr, (const xmlChRangeGroup *)rptr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharInRange",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf(" %d", n_rptr);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsBaseChar(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch;
    int n_ch;

    for (n_ch = 0;n_ch < 3;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsBaseChar(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBaseChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsBlank(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch;
    int n_ch;

    for (n_ch = 0;n_ch < 3;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsBlank(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBlank",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsChar(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch;
    int n_ch;

    for (n_ch = 0;n_ch < 3;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsChar(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsCombining(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch;
    int n_ch;

    for (n_ch = 0;n_ch < 3;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsCombining(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsCombining",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsDigit(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch;
    int n_ch;

    for (n_ch = 0;n_ch < 3;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsDigit(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsDigit",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsExtender(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch;
    int n_ch;

    for (n_ch = 0;n_ch < 3;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsExtender(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsExtender",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsIdeographic(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch;
    int n_ch;

    for (n_ch = 0;n_ch < 3;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsIdeographic(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsIdeographic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsPubidChar(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned int ch;
    int n_ch;

    for (n_ch = 0;n_ch < 3;n_ch++) {
        mem_base = xmlMemBlocks();
        ch = gen_unsigned_int(n_ch, 0);

        ret_val = xmlIsPubidChar(ch);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_int(n_ch, ch, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsPubidChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ch);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}

static int
test_chvalid(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing chvalid : 9 of 9 functions ...\n");
    test_ret += test_xmlCharInRange();
    test_ret += test_xmlIsBaseChar();
    test_ret += test_xmlIsBlank();
    test_ret += test_xmlIsChar();
    test_ret += test_xmlIsCombining();
    test_ret += test_xmlIsDigit();
    test_ret += test_xmlIsExtender();
    test_ret += test_xmlIsIdeographic();
    test_ret += test_xmlIsPubidChar();

    if (test_ret != 0)
 printf("Module chvalid: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlBoolToText(void) {
    int test_ret = 0;


    int mem_base;
    const char * ret_val;
    int boolval;
    int n_boolval;

    for (n_boolval = 0;n_boolval < 4;n_boolval++) {
        mem_base = xmlMemBlocks();
        boolval = gen_int(n_boolval, 0);

        ret_val = xmlBoolToText(boolval);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_int(n_boolval, boolval, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBoolToText",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_boolval);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugCheckDocument(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    FILE * output;
    int n_output;
    xmlDocPtr doc;
    int n_doc;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlDebugCheckDocument(output, doc);
        desret_int(ret_val);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugCheckDocument",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpAttr(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlAttrPtr attr;
    int n_attr;
    int depth;
    int n_depth;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_attr = 0;n_attr < 2;n_attr++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        attr = gen_xmlAttrPtr(n_attr, 1);
        depth = gen_int(n_depth, 2);

        xmlDebugDumpAttr(output, attr, depth);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlAttrPtr(n_attr, attr, 1);
        des_int(n_depth, depth, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpAttr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_attr);
            printf(" %d", n_depth);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpAttrList(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlAttrPtr attr;
    int n_attr;
    int depth;
    int n_depth;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_attr = 0;n_attr < 2;n_attr++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        attr = gen_xmlAttrPtr(n_attr, 1);
        depth = gen_int(n_depth, 2);

        xmlDebugDumpAttrList(output, attr, depth);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlAttrPtr(n_attr, attr, 1);
        des_int(n_depth, depth, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpAttrList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_attr);
            printf(" %d", n_depth);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpDTD(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlDtdPtr dtd;
    int n_dtd;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_dtd = 0;n_dtd < 3;n_dtd++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        dtd = gen_xmlDtdPtr(n_dtd, 1);

        xmlDebugDumpDTD(output, dtd);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlDtdPtr(n_dtd, dtd, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpDTD",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_dtd);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpDocument(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlDocPtr doc;
    int n_doc;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        xmlDebugDumpDocument(output, doc);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpDocument",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpDocumentHead(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlDocPtr doc;
    int n_doc;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        xmlDebugDumpDocumentHead(output, doc);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpDocumentHead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpEntities(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlDocPtr doc;
    int n_doc;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        xmlDebugDumpEntities(output, doc);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpEntities",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpNode(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlNodePtr node;
    int n_node;
    int depth;
    int n_depth;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        node = gen_xmlNodePtr(n_node, 1);
        depth = gen_int(n_depth, 2);

        xmlDebugDumpNode(output, node, depth);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_int(n_depth, depth, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_node);
            printf(" %d", n_depth);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpNodeList(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlNodePtr node;
    int n_node;
    int depth;
    int n_depth;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        node = gen_xmlNodePtr(n_node, 1);
        depth = gen_int(n_depth, 2);

        xmlDebugDumpNodeList(output, node, depth);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_int(n_depth, depth, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpNodeList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_node);
            printf(" %d", n_depth);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpOneNode(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlNodePtr node;
    int n_node;
    int depth;
    int n_depth;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        node = gen_xmlNodePtr(n_node, 1);
        depth = gen_int(n_depth, 2);

        xmlDebugDumpOneNode(output, node, depth);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_int(n_depth, depth, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpOneNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_node);
            printf(" %d", n_depth);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDebugDumpString(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlChar * str;
    int n_str;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_str = 0;n_str < 5;n_str++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        xmlDebugDumpString(output, (const xmlChar *)str);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDebugDumpString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlLsCountNode(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlLsCountNode(node);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLsCountNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlLsOneNode(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlNodePtr node;
    int n_node;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        output = gen_debug_FILE_ptr(n_output, 0);
        node = gen_xmlNodePtr(n_node, 1);

        xmlLsOneNode(output, node);
        call_tests++;
        des_debug_FILE_ptr(n_output, output, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLsOneNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}



static char * gen_char_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 7491 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 7491 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_char_ptr(int no __attribute__((unused)), char * val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlShell(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlShellBase(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * arg;
    int n_arg;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_arg = 0;n_arg < 1;n_arg++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        arg = gen_char_ptr(n_arg, 1);
        node = gen_xmlNodePtr(n_node, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellBase(ctxt, arg, node, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_arg, arg, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellBase",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_arg);
            printf(" %d", n_node);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellCat(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * arg;
    int n_arg;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_arg = 0;n_arg < 1;n_arg++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        arg = gen_char_ptr(n_arg, 1);
        node = gen_xmlNodePtr(n_node, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellCat(ctxt, arg, node, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_arg, arg, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellCat",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_arg);
            printf(" %d", n_node);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellDir(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * arg;
    int n_arg;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_arg = 0;n_arg < 1;n_arg++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        arg = gen_char_ptr(n_arg, 1);
        node = gen_xmlNodePtr(n_node, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellDir(ctxt, arg, node, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_arg, arg, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellDir",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_arg);
            printf(" %d", n_node);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellDu(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * arg;
    int n_arg;
    xmlNodePtr tree;
    int n_tree;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_arg = 0;n_arg < 1;n_arg++) {
    for (n_tree = 0;n_tree < 3;n_tree++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        arg = gen_char_ptr(n_arg, 1);
        tree = gen_xmlNodePtr(n_tree, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellDu(ctxt, arg, tree, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_arg, arg, 1);
        des_xmlNodePtr(n_tree, tree, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellDu",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_arg);
            printf(" %d", n_tree);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellList(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * arg;
    int n_arg;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_arg = 0;n_arg < 1;n_arg++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        arg = gen_char_ptr(n_arg, 1);
        node = gen_xmlNodePtr(n_node, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellList(ctxt, arg, node, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_arg, arg, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_arg);
            printf(" %d", n_node);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellLoad(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * filename;
    int n_filename;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_filename = 0;n_filename < 1;n_filename++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        filename = gen_char_ptr(n_filename, 1);
        node = gen_xmlNodePtr(n_node, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellLoad(ctxt, filename, node, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_filename, filename, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellLoad",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_node);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellPrintXPathResult(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr list;
    int n_list;

    for (n_list = 0;n_list < 5;n_list++) {
        mem_base = xmlMemBlocks();
        list = gen_xmlXPathObjectPtr(n_list, 0);

        xmlShellPrintXPathResult(list);
        call_tests++;
        des_xmlXPathObjectPtr(n_list, list, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellPrintXPathResult",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_list);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellPwd(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * buffer;
    int n_buffer;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_buffer = 0;n_buffer < 1;n_buffer++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        buffer = gen_char_ptr(n_buffer, 1);
        node = gen_xmlNodePtr(n_node, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellPwd(ctxt, buffer, node, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_buffer, buffer, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellPwd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_node);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellSave(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * filename;
    int n_filename;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_filename = 0;n_filename < 1;n_filename++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        filename = gen_char_ptr(n_filename, 1);
        node = gen_xmlNodePtr(n_node, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellSave(ctxt, filename, node, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_filename, filename, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellSave",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_node);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellValidate(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * dtd;
    int n_dtd;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_dtd = 0;n_dtd < 1;n_dtd++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        dtd = gen_char_ptr(n_dtd, 1);
        node = gen_xmlNodePtr(n_node, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellValidate(ctxt, dtd, node, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_dtd, dtd, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellValidate",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_dtd);
            printf(" %d", n_node);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlShellWrite(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlShellCtxtPtr ctxt;
    int n_ctxt;
    char * filename;
    int n_filename;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr node2;
    int n_node2;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_filename = 0;n_filename < 1;n_filename++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlShellCtxtPtr(n_ctxt, 0);
        filename = gen_char_ptr(n_filename, 1);
        node = gen_xmlNodePtr(n_node, 2);
        node2 = gen_xmlNodePtr(n_node2, 3);

        ret_val = xmlShellWrite(ctxt, filename, node, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlShellCtxtPtr(n_ctxt, ctxt, 0);
        des_char_ptr(n_filename, filename, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr(n_node2, node2, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlShellWrite",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_node);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_debugXML(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing debugXML : 25 of 28 functions ...\n");
    test_ret += test_xmlBoolToText();
    test_ret += test_xmlDebugCheckDocument();
    test_ret += test_xmlDebugDumpAttr();
    test_ret += test_xmlDebugDumpAttrList();
    test_ret += test_xmlDebugDumpDTD();
    test_ret += test_xmlDebugDumpDocument();
    test_ret += test_xmlDebugDumpDocumentHead();
    test_ret += test_xmlDebugDumpEntities();
    test_ret += test_xmlDebugDumpNode();
    test_ret += test_xmlDebugDumpNodeList();
    test_ret += test_xmlDebugDumpOneNode();
    test_ret += test_xmlDebugDumpString();
    test_ret += test_xmlLsCountNode();
    test_ret += test_xmlLsOneNode();
    test_ret += test_xmlShell();
    test_ret += test_xmlShellBase();
    test_ret += test_xmlShellCat();
    test_ret += test_xmlShellDir();
    test_ret += test_xmlShellDu();
    test_ret += test_xmlShellList();
    test_ret += test_xmlShellLoad();
    test_ret += test_xmlShellPrintXPathResult();
    test_ret += test_xmlShellPwd();
    test_ret += test_xmlShellSave();
    test_ret += test_xmlShellValidate();
    test_ret += test_xmlShellWrite();

    if (test_ret != 0)
 printf("Module debugXML: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlDictCleanup(void) {
    int test_ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlDictCleanup();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictCleanup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDictCreate(void) {
    int test_ret = 0;

    int mem_base;
    xmlDictPtr ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlDictCreate();
        desret_xmlDictPtr(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictCreate",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDictCreateSub(void) {
    int test_ret = 0;

    int mem_base;
    xmlDictPtr ret_val;
    xmlDictPtr sub;
    int n_sub;

    for (n_sub = 0;n_sub < 2;n_sub++) {
        mem_base = xmlMemBlocks();
        sub = gen_xmlDictPtr(n_sub, 0);

        ret_val = xmlDictCreateSub(sub);
        desret_xmlDictPtr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_sub, sub, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictCreateSub",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sub);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDictExists(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlDictPtr dict;
    int n_dict;
    xmlChar * name;
    int n_name;
    int len;
    int n_len;

    for (n_dict = 0;n_dict < 2;n_dict++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlDictExists(dict, (const xmlChar *)name, len);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictExists",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dict);
            printf(" %d", n_name);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDictGetUsage(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlDictLookup(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlDictPtr dict;
    int n_dict;
    xmlChar * name;
    int n_name;
    int len;
    int n_len;

    for (n_dict = 0;n_dict < 2;n_dict++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlDictLookup(dict, (const xmlChar *)name, len);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictLookup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dict);
            printf(" %d", n_name);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDictOwns(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDictPtr dict;
    int n_dict;
    xmlChar * str;
    int n_str;

    for (n_dict = 0;n_dict < 2;n_dict++) {
    for (n_str = 0;n_str < 5;n_str++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlDictOwns(dict, (const xmlChar *)str);
        desret_int(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictOwns",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dict);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDictQLookup(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlDictPtr dict;
    int n_dict;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * name;
    int n_name;

    for (n_dict = 0;n_dict < 2;n_dict++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlDictQLookup(dict, (const xmlChar *)prefix, (const xmlChar *)name);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictQLookup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dict);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDictReference(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDictPtr dict;
    int n_dict;

    for (n_dict = 0;n_dict < 2;n_dict++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);

        ret_val = xmlDictReference(dict);
        xmlDictFree(dict);
        desret_int(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictReference",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dict);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDictSetLimit(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlDictSize(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDictPtr dict;
    int n_dict;

    for (n_dict = 0;n_dict < 2;n_dict++) {
        mem_base = xmlMemBlocks();
        dict = gen_xmlDictPtr(n_dict, 0);

        ret_val = xmlDictSize(dict);
        desret_int(ret_val);
        call_tests++;
        des_xmlDictPtr(n_dict, dict, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDictSize",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dict);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlInitializeDict(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlInitializeDict();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitializeDict",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}

static int
test_dict(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing dict : 10 of 13 functions ...\n");
    test_ret += test_xmlDictCleanup();
    test_ret += test_xmlDictCreate();
    test_ret += test_xmlDictCreateSub();
    test_ret += test_xmlDictExists();
    test_ret += test_xmlDictGetUsage();
    test_ret += test_xmlDictLookup();
    test_ret += test_xmlDictOwns();
    test_ret += test_xmlDictQLookup();
    test_ret += test_xmlDictReference();
    test_ret += test_xmlDictSetLimit();
    test_ret += test_xmlDictSize();
    test_ret += test_xmlInitializeDict();

    if (test_ret != 0)
 printf("Module dict: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_UTF8Toisolat1(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    unsigned char * out;
    int n_out;
    int * outlen;
    int n_outlen;
    unsigned char * in;
    int n_in;
    int * inlen;
    int n_inlen;

    for (n_out = 0;n_out < 1;n_out++) {
    for (n_outlen = 0;n_outlen < 2;n_outlen++) {
    for (n_in = 0;n_in < 1;n_in++) {
    for (n_inlen = 0;n_inlen < 2;n_inlen++) {
        mem_base = xmlMemBlocks();
        out = gen_unsigned_char_ptr(n_out, 0);
        outlen = gen_int_ptr(n_outlen, 1);
        in = gen_const_unsigned_char_ptr(n_in, 2);
        inlen = gen_int_ptr(n_inlen, 3);

        ret_val = UTF8Toisolat1(out, outlen, (const unsigned char *)in, inlen);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_char_ptr(n_out, out, 0);
        des_int_ptr(n_outlen, outlen, 1);
        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 2);
        des_int_ptr(n_inlen, inlen, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in UTF8Toisolat1",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf(" %d", n_outlen);
            printf(" %d", n_in);
            printf(" %d", n_inlen);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_isolat1ToUTF8(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned char * out;
    int n_out;
    int * outlen;
    int n_outlen;
    unsigned char * in;
    int n_in;
    int * inlen;
    int n_inlen;

    for (n_out = 0;n_out < 1;n_out++) {
    for (n_outlen = 0;n_outlen < 2;n_outlen++) {
    for (n_in = 0;n_in < 1;n_in++) {
    for (n_inlen = 0;n_inlen < 2;n_inlen++) {
        mem_base = xmlMemBlocks();
        out = gen_unsigned_char_ptr(n_out, 0);
        outlen = gen_int_ptr(n_outlen, 1);
        in = gen_const_unsigned_char_ptr(n_in, 2);
        inlen = gen_int_ptr(n_inlen, 3);

        ret_val = isolat1ToUTF8(out, outlen, (const unsigned char *)in, inlen);
        desret_int(ret_val);
        call_tests++;
        des_unsigned_char_ptr(n_out, out, 0);
        des_int_ptr(n_outlen, outlen, 1);
        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 2);
        des_int_ptr(n_inlen, inlen, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in isolat1ToUTF8",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf(" %d", n_outlen);
            printf(" %d", n_in);
            printf(" %d", n_inlen);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlAddEncodingAlias(void) {
    int test_ret = 0;

    int ret_val;
    char * name;
    int n_name;
    char * alias;
    int n_alias;

    for (n_name = 0;n_name < 4;n_name++) {
    for (n_alias = 0;n_alias < 4;n_alias++) {
        name = gen_const_char_ptr(n_name, 0);
        alias = gen_const_char_ptr(n_alias, 1);

        ret_val = xmlAddEncodingAlias((const char *)name, (const char *)alias);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_name, (const char *)name, 0);
        des_const_char_ptr(n_alias, (const char *)alias, 1);
        xmlResetLastError();
    }
    }
    function_tests++;

    return(test_ret);
}



static xmlCharEncodingHandler * gen_xmlCharEncodingHandler_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 8654 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 8654 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlCharEncodingHandler_ptr(int no __attribute__((unused)), xmlCharEncodingHandler * val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlCharEncCloseFunc(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlCharEncodingHandler * handler;
    int n_handler;

    for (n_handler = 0;n_handler < 1;n_handler++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);

        ret_val = xmlCharEncCloseFunc(handler);
        desret_int(ret_val);
        call_tests++;
        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharEncCloseFunc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_handler);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCharEncFirstLine(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlCharEncodingHandler * handler;
    int n_handler;
    xmlBufferPtr out;
    int n_out;
    xmlBufferPtr in;
    int n_in;

    for (n_handler = 0;n_handler < 1;n_handler++) {
    for (n_out = 0;n_out < 3;n_out++) {
    for (n_in = 0;n_in < 3;n_in++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
        out = gen_xmlBufferPtr(n_out, 1);
        in = gen_xmlBufferPtr(n_in, 2);

        ret_val = xmlCharEncFirstLine(handler, out, in);
        desret_int(ret_val);
        call_tests++;
        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
        des_xmlBufferPtr(n_out, out, 1);
        des_xmlBufferPtr(n_in, in, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharEncFirstLine",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_handler);
            printf(" %d", n_out);
            printf(" %d", n_in);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCharEncInFunc(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlCharEncodingHandler * handler;
    int n_handler;
    xmlBufferPtr out;
    int n_out;
    xmlBufferPtr in;
    int n_in;

    for (n_handler = 0;n_handler < 1;n_handler++) {
    for (n_out = 0;n_out < 3;n_out++) {
    for (n_in = 0;n_in < 3;n_in++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
        out = gen_xmlBufferPtr(n_out, 1);
        in = gen_xmlBufferPtr(n_in, 2);

        ret_val = xmlCharEncInFunc(handler, out, in);
        desret_int(ret_val);
        call_tests++;
        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
        des_xmlBufferPtr(n_out, out, 1);
        des_xmlBufferPtr(n_in, in, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharEncInFunc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_handler);
            printf(" %d", n_out);
            printf(" %d", n_in);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCharEncOutFunc(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlCharEncodingHandler * handler;
    int n_handler;
    xmlBufferPtr out;
    int n_out;
    xmlBufferPtr in;
    int n_in;

    for (n_handler = 0;n_handler < 1;n_handler++) {
    for (n_out = 0;n_out < 3;n_out++) {
    for (n_in = 0;n_in < 3;n_in++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandler_ptr(n_handler, 0);
        out = gen_xmlBufferPtr(n_out, 1);
        in = gen_xmlBufferPtr(n_in, 2);

        ret_val = xmlCharEncOutFunc(handler, out, in);
        desret_int(ret_val);
        call_tests++;
        des_xmlCharEncodingHandler_ptr(n_handler, handler, 0);
        des_xmlBufferPtr(n_out, out, 1);
        des_xmlBufferPtr(n_in, in, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharEncOutFunc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_handler);
            printf(" %d", n_out);
            printf(" %d", n_in);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCleanupCharEncodingHandlers(void) {
    int test_ret = 0;



        xmlCleanupCharEncodingHandlers();
        call_tests++;
        xmlResetLastError();
    function_tests++;

    return(test_ret);
}


static int
test_xmlCleanupEncodingAliases(void) {
    int test_ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupEncodingAliases();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupEncodingAliases",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDelEncodingAlias(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    char * alias;
    int n_alias;

    for (n_alias = 0;n_alias < 4;n_alias++) {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias, 0);

        ret_val = xmlDelEncodingAlias((const char *)alias);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_alias, (const char *)alias, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDelEncodingAlias",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_alias);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDetectCharEncoding(void) {
    int test_ret = 0;

    int mem_base;
    xmlCharEncoding ret_val;
    unsigned char * in;
    int n_in;
    int len;
    int n_len;

    for (n_in = 0;n_in < 1;n_in++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_const_unsigned_char_ptr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlDetectCharEncoding((const unsigned char *)in, len);
        desret_xmlCharEncoding(ret_val);
        call_tests++;
        des_const_unsigned_char_ptr(n_in, (const unsigned char *)in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDetectCharEncoding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlFindCharEncodingHandler(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlGetCharEncodingHandler(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlGetCharEncodingName(void) {
    int test_ret = 0;

    int mem_base;
    const char * ret_val;
    xmlCharEncoding enc;
    int n_enc;

    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        enc = gen_xmlCharEncoding(n_enc, 0);

        ret_val = xmlGetCharEncodingName(enc);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_xmlCharEncoding(n_enc, enc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetCharEncodingName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetEncodingAlias(void) {
    int test_ret = 0;

    int mem_base;
    const char * ret_val;
    char * alias;
    int n_alias;

    for (n_alias = 0;n_alias < 4;n_alias++) {
        mem_base = xmlMemBlocks();
        alias = gen_const_char_ptr(n_alias, 0);

        ret_val = xmlGetEncodingAlias((const char *)alias);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_alias, (const char *)alias, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetEncodingAlias",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_alias);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlInitCharEncodingHandlers(void) {
    int test_ret = 0;



        xmlInitCharEncodingHandlers();
        call_tests++;
        xmlResetLastError();
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewCharEncodingHandler(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlParseCharEncoding(void) {
    int test_ret = 0;

    int mem_base;
    xmlCharEncoding ret_val;
    char * name;
    int n_name;

    for (n_name = 0;n_name < 4;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_char_ptr(n_name, 0);

        ret_val = xmlParseCharEncoding((const char *)name);
        desret_xmlCharEncoding(ret_val);
        call_tests++;
        des_const_char_ptr(n_name, (const char *)name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseCharEncoding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}



static xmlCharEncodingHandlerPtr gen_xmlCharEncodingHandlerPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 9081 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 9081 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlCharEncodingHandlerPtr(int no __attribute__((unused)), xmlCharEncodingHandlerPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlRegisterCharEncodingHandler(void) {
    int test_ret = 0;

    int mem_base;
    xmlCharEncodingHandlerPtr handler;
    int n_handler;

    for (n_handler = 0;n_handler < 1;n_handler++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 0);

        xmlRegisterCharEncodingHandler(handler);
        call_tests++;
        des_xmlCharEncodingHandlerPtr(n_handler, handler, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterCharEncodingHandler",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_handler);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}

static int
test_encoding(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing encoding : 16 of 19 functions ...\n");
    test_ret += test_UTF8Toisolat1();
    test_ret += test_isolat1ToUTF8();
    test_ret += test_xmlAddEncodingAlias();
    test_ret += test_xmlCharEncCloseFunc();
    test_ret += test_xmlCharEncFirstLine();
    test_ret += test_xmlCharEncInFunc();
    test_ret += test_xmlCharEncOutFunc();
    test_ret += test_xmlCleanupCharEncodingHandlers();
    test_ret += test_xmlCleanupEncodingAliases();
    test_ret += test_xmlDelEncodingAlias();
    test_ret += test_xmlDetectCharEncoding();
    test_ret += test_xmlFindCharEncodingHandler();
    test_ret += test_xmlGetCharEncodingHandler();
    test_ret += test_xmlGetCharEncodingName();
    test_ret += test_xmlGetEncodingAlias();
    test_ret += test_xmlInitCharEncodingHandlers();
    test_ret += test_xmlNewCharEncodingHandler();
    test_ret += test_xmlParseCharEncoding();
    test_ret += test_xmlRegisterCharEncodingHandler();

    if (test_ret != 0)
 printf("Module encoding: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlAddDocEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;
    int type;
    int n_type;
    xmlChar * ExternalID;
    int n_ExternalID;
    xmlChar * SystemID;
    int n_SystemID;
    xmlChar * content;
    int n_content;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_type = 0;n_type < 4;n_type++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < 5;n_SystemID++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        type = gen_int(n_type, 2);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 3);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 4);
        content = gen_const_xmlChar_ptr(n_content, 5);

        ret_val = xmlAddDocEntity(doc, (const xmlChar *)name, type, (const xmlChar *)ExternalID, (const xmlChar *)SystemID, (const xmlChar *)content);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_int(n_type, type, 2);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 3);
        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 4);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddDocEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlAddDtdEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;
    int type;
    int n_type;
    xmlChar * ExternalID;
    int n_ExternalID;
    xmlChar * SystemID;
    int n_SystemID;
    xmlChar * content;
    int n_content;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_type = 0;n_type < 4;n_type++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < 5;n_SystemID++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        type = gen_int(n_type, 2);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 3);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 4);
        content = gen_const_xmlChar_ptr(n_content, 5);

        ret_val = xmlAddDtdEntity(doc, (const xmlChar *)name, type, (const xmlChar *)ExternalID, (const xmlChar *)SystemID, (const xmlChar *)content);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_int(n_type, type, 2);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 3);
        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 4);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddDtdEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCleanupPredefinedEntities(void) {
    int test_ret = 0;



    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupPredefinedEntities();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupPredefinedEntities",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;



    return(test_ret);
}



static xmlEntitiesTablePtr gen_xmlEntitiesTablePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 9308 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 9308 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlEntitiesTablePtr(int no __attribute__((unused)), xmlEntitiesTablePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlCopyEntitiesTable(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlCreateEntitiesTable(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlDumpEntitiesTable(void) {
    int test_ret = 0;


    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlEntitiesTablePtr table;
    int n_table;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_table = 0;n_table < 1;n_table++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        table = gen_xmlEntitiesTablePtr(n_table, 1);

        xmlDumpEntitiesTable(buf, table);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlEntitiesTablePtr(n_table, table, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpEntitiesTable",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_table);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}



static xmlEntityPtr gen_xmlEntityPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 9374 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 9374 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlEntityPtr(int no __attribute__((unused)), xmlEntityPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlDumpEntityDecl(void) {
    int test_ret = 0;


    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlEntityPtr ent;
    int n_ent;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_ent = 0;n_ent < 1;n_ent++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        ent = gen_xmlEntityPtr(n_ent, 1);

        xmlDumpEntityDecl(buf, ent);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlEntityPtr(n_ent, ent, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpEntityDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_ent);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlEncodeEntitiesReentrant(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * input;
    int n_input;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_input = 0;n_input < 5;n_input++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        input = gen_const_xmlChar_ptr(n_input, 1);

        ret_val = xmlEncodeEntitiesReentrant(doc, (const xmlChar *)input);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_input, (const xmlChar *)input, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlEncodeEntitiesReentrant",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_input);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlEncodeSpecialChars(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * input;
    int n_input;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_input = 0;n_input < 5;n_input++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        input = gen_const_xmlChar_ptr(n_input, 1);

        ret_val = xmlEncodeSpecialChars(doc, (const xmlChar *)input);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_input, (const xmlChar *)input, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlEncodeSpecialChars",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_input);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetDocEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetDocEntity(doc, (const xmlChar *)name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDocEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetDtdEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetDtdEntity(doc, (const xmlChar *)name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDtdEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetParameterEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetParameterEntity(doc, (const xmlChar *)name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetParameterEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetPredefinedEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlChar * name;
    int n_name;

    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = xmlGetPredefinedEntity((const xmlChar *)name);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetPredefinedEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlInitializePredefinedEntities(void) {
    int test_ret = 0;



    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitializePredefinedEntities();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitializePredefinedEntities",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;



    return(test_ret);
}


static int
test_xmlNewEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlEntityPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;
    int type;
    int n_type;
    xmlChar * ExternalID;
    int n_ExternalID;
    xmlChar * SystemID;
    int n_SystemID;
    xmlChar * content;
    int n_content;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_type = 0;n_type < 4;n_type++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < 5;n_SystemID++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        type = gen_int(n_type, 2);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 3);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 4);
        content = gen_const_xmlChar_ptr(n_content, 5);

        ret_val = xmlNewEntity(doc, (const xmlChar *)name, type, (const xmlChar *)ExternalID, (const xmlChar *)SystemID, (const xmlChar *)content);
        desret_xmlEntityPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_int(n_type, type, 2);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 3);
        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 4);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}

static int
test_entities(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing entities : 13 of 17 functions ...\n");
    test_ret += test_xmlAddDocEntity();
    test_ret += test_xmlAddDtdEntity();
    test_ret += test_xmlCleanupPredefinedEntities();
    test_ret += test_xmlCopyEntitiesTable();
    test_ret += test_xmlCreateEntitiesTable();
    test_ret += test_xmlDumpEntitiesTable();
    test_ret += test_xmlDumpEntityDecl();
    test_ret += test_xmlEncodeEntitiesReentrant();
    test_ret += test_xmlEncodeSpecialChars();
    test_ret += test_xmlGetDocEntity();
    test_ret += test_xmlGetDtdEntity();
    test_ret += test_xmlGetParameterEntity();
    test_ret += test_xmlGetPredefinedEntity();
    test_ret += test_xmlInitializePredefinedEntities();
    test_ret += test_xmlNewEntity();

    if (test_ret != 0)
 printf("Module entities: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlHashAddEntry(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    void * userdata;
    int n_userdata;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_userdata = 0;n_userdata < 3;n_userdata++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        userdata = gen_userdata(n_userdata, 2);

        ret_val = xmlHashAddEntry(table, (const xmlChar *)name, userdata);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_userdata(n_userdata, userdata, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashAddEntry",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_userdata);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashAddEntry2(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    xmlChar * name2;
    int n_name2;
    void * userdata;
    int n_userdata;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
    for (n_userdata = 0;n_userdata < 3;n_userdata++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        userdata = gen_userdata(n_userdata, 3);

        ret_val = xmlHashAddEntry2(table, (const xmlChar *)name, (const xmlChar *)name2, userdata);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
        des_userdata(n_userdata, userdata, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashAddEntry2",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_userdata);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashAddEntry3(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    xmlChar * name2;
    int n_name2;
    xmlChar * name3;
    int n_name3;
    void * userdata;
    int n_userdata;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
    for (n_name3 = 0;n_name3 < 5;n_name3++) {
    for (n_userdata = 0;n_userdata < 3;n_userdata++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        name3 = gen_const_xmlChar_ptr(n_name3, 3);
        userdata = gen_userdata(n_userdata, 4);

        ret_val = xmlHashAddEntry3(table, (const xmlChar *)name, (const xmlChar *)name2, (const xmlChar *)name3, userdata);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 3);
        des_userdata(n_userdata, userdata, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashAddEntry3",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_name3);
            printf(" %d", n_userdata);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashCopy(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlHashCreate(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlHashCreateDict(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlHashLookup(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlHashLookup(table, (const xmlChar *)name);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashLookup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashLookup2(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    xmlChar * name2;
    int n_name2;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);

        ret_val = xmlHashLookup2(table, (const xmlChar *)name, (const xmlChar *)name2);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashLookup2",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashLookup3(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    xmlChar * name2;
    int n_name2;
    xmlChar * name3;
    int n_name3;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
    for (n_name3 = 0;n_name3 < 5;n_name3++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        name3 = gen_const_xmlChar_ptr(n_name3, 3);

        ret_val = xmlHashLookup3(table, (const xmlChar *)name, (const xmlChar *)name2, (const xmlChar *)name3);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashLookup3",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_name3);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashQLookup(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * name;
    int n_name;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlHashQLookup(table, (const xmlChar *)prefix, (const xmlChar *)name);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashQLookup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashQLookup2(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * name;
    int n_name;
    xmlChar * prefix2;
    int n_prefix2;
    xmlChar * name2;
    int n_name2;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_prefix2 = 0;n_prefix2 < 5;n_prefix2++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        prefix2 = gen_const_xmlChar_ptr(n_prefix2, 3);
        name2 = gen_const_xmlChar_ptr(n_name2, 4);

        ret_val = xmlHashQLookup2(table, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)prefix2, (const xmlChar *)name2);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_prefix2, (const xmlChar *)prefix2, 3);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashQLookup2",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_prefix2);
            printf(" %d", n_name2);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashQLookup3(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * name;
    int n_name;
    xmlChar * prefix2;
    int n_prefix2;
    xmlChar * name2;
    int n_name2;
    xmlChar * prefix3;
    int n_prefix3;
    xmlChar * name3;
    int n_name3;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_prefix2 = 0;n_prefix2 < 5;n_prefix2++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
    for (n_prefix3 = 0;n_prefix3 < 5;n_prefix3++) {
    for (n_name3 = 0;n_name3 < 5;n_name3++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        prefix2 = gen_const_xmlChar_ptr(n_prefix2, 3);
        name2 = gen_const_xmlChar_ptr(n_name2, 4);
        prefix3 = gen_const_xmlChar_ptr(n_prefix3, 5);
        name3 = gen_const_xmlChar_ptr(n_name3, 6);

        ret_val = xmlHashQLookup3(table, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)prefix2, (const xmlChar *)name2, (const xmlChar *)prefix3, (const xmlChar *)name3);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_prefix2, (const xmlChar *)prefix2, 3);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 4);
        des_const_xmlChar_ptr(n_prefix3, (const xmlChar *)prefix3, 5);
        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashQLookup3",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_prefix2);
            printf(" %d", n_name2);
            printf(" %d", n_prefix3);
            printf(" %d", n_name3);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashRemoveEntry(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    xmlHashDeallocator f;
    int n_f;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_f = 0;n_f < 2;n_f++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        f = gen_xmlHashDeallocator(n_f, 2);

        ret_val = xmlHashRemoveEntry(table, (const xmlChar *)name, f);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_xmlHashDeallocator(n_f, f, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashRemoveEntry",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_f);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashRemoveEntry2(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    xmlChar * name2;
    int n_name2;
    xmlHashDeallocator f;
    int n_f;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
    for (n_f = 0;n_f < 2;n_f++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        f = gen_xmlHashDeallocator(n_f, 3);

        ret_val = xmlHashRemoveEntry2(table, (const xmlChar *)name, (const xmlChar *)name2, f);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
        des_xmlHashDeallocator(n_f, f, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashRemoveEntry2",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_f);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashRemoveEntry3(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    xmlChar * name2;
    int n_name2;
    xmlChar * name3;
    int n_name3;
    xmlHashDeallocator f;
    int n_f;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
    for (n_name3 = 0;n_name3 < 5;n_name3++) {
    for (n_f = 0;n_f < 2;n_f++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        name3 = gen_const_xmlChar_ptr(n_name3, 3);
        f = gen_xmlHashDeallocator(n_f, 4);

        ret_val = xmlHashRemoveEntry3(table, (const xmlChar *)name, (const xmlChar *)name2, (const xmlChar *)name3, f);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 3);
        des_xmlHashDeallocator(n_f, f, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashRemoveEntry3",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_name3);
            printf(" %d", n_f);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashScan(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlHashScan3(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlHashScanFull(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlHashScanFull3(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlHashSize(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;

    for (n_table = 0;n_table < 2;n_table++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);

        ret_val = xmlHashSize(table);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashSize",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashUpdateEntry(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    void * userdata;
    int n_userdata;
    xmlHashDeallocator f;
    int n_f;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_userdata = 0;n_userdata < 3;n_userdata++) {
    for (n_f = 0;n_f < 2;n_f++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        userdata = gen_userdata(n_userdata, 2);
        f = gen_xmlHashDeallocator(n_f, 3);

        ret_val = xmlHashUpdateEntry(table, (const xmlChar *)name, userdata, f);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_userdata(n_userdata, userdata, 2);
        des_xmlHashDeallocator(n_f, f, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashUpdateEntry",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_userdata);
            printf(" %d", n_f);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashUpdateEntry2(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    xmlChar * name2;
    int n_name2;
    void * userdata;
    int n_userdata;
    xmlHashDeallocator f;
    int n_f;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
    for (n_userdata = 0;n_userdata < 3;n_userdata++) {
    for (n_f = 0;n_f < 2;n_f++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        userdata = gen_userdata(n_userdata, 3);
        f = gen_xmlHashDeallocator(n_f, 4);

        ret_val = xmlHashUpdateEntry2(table, (const xmlChar *)name, (const xmlChar *)name2, userdata, f);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
        des_userdata(n_userdata, userdata, 3);
        des_xmlHashDeallocator(n_f, f, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashUpdateEntry2",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_userdata);
            printf(" %d", n_f);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHashUpdateEntry3(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlHashTablePtr table;
    int n_table;
    xmlChar * name;
    int n_name;
    xmlChar * name2;
    int n_name2;
    xmlChar * name3;
    int n_name3;
    void * userdata;
    int n_userdata;
    xmlHashDeallocator f;
    int n_f;

    for (n_table = 0;n_table < 2;n_table++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_name2 = 0;n_name2 < 5;n_name2++) {
    for (n_name3 = 0;n_name3 < 5;n_name3++) {
    for (n_userdata = 0;n_userdata < 3;n_userdata++) {
    for (n_f = 0;n_f < 2;n_f++) {
        mem_base = xmlMemBlocks();
        table = gen_xmlHashTablePtr(n_table, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        name2 = gen_const_xmlChar_ptr(n_name2, 2);
        name3 = gen_const_xmlChar_ptr(n_name3, 3);
        userdata = gen_userdata(n_userdata, 4);
        f = gen_xmlHashDeallocator(n_f, 5);

        ret_val = xmlHashUpdateEntry3(table, (const xmlChar *)name, (const xmlChar *)name2, (const xmlChar *)name3, userdata, f);
        desret_int(ret_val);
        call_tests++;
        des_xmlHashTablePtr(n_table, table, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_name2, (const xmlChar *)name2, 2);
        des_const_xmlChar_ptr(n_name3, (const xmlChar *)name3, 3);
        des_userdata(n_userdata, userdata, 4);
        des_xmlHashDeallocator(n_f, f, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHashUpdateEntry3",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_table);
            printf(" %d", n_name);
            printf(" %d", n_name2);
            printf(" %d", n_name3);
            printf(" %d", n_userdata);
            printf(" %d", n_f);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}

static int
test_hash(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing hash : 16 of 24 functions ...\n");
    test_ret += test_xmlHashAddEntry();
    test_ret += test_xmlHashAddEntry2();
    test_ret += test_xmlHashAddEntry3();
    test_ret += test_xmlHashCopy();
    test_ret += test_xmlHashCreate();
    test_ret += test_xmlHashCreateDict();
    test_ret += test_xmlHashLookup();
    test_ret += test_xmlHashLookup2();
    test_ret += test_xmlHashLookup3();
    test_ret += test_xmlHashQLookup();
    test_ret += test_xmlHashQLookup2();
    test_ret += test_xmlHashQLookup3();
    test_ret += test_xmlHashRemoveEntry();
    test_ret += test_xmlHashRemoveEntry2();
    test_ret += test_xmlHashRemoveEntry3();
    test_ret += test_xmlHashScan();
    test_ret += test_xmlHashScan3();
    test_ret += test_xmlHashScanFull();
    test_ret += test_xmlHashScanFull3();
    test_ret += test_xmlHashSize();
    test_ret += test_xmlHashUpdateEntry();
    test_ret += test_xmlHashUpdateEntry2();
    test_ret += test_xmlHashUpdateEntry3();

    if (test_ret != 0)
 printf("Module hash: %d errors\n", test_ret);
    return(test_ret);
}


static xmlLinkPtr gen_xmlLinkPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 10717 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 10717 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlLinkPtr(int no __attribute__((unused)), xmlLinkPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlLinkGetData(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    xmlLinkPtr lk;
    int n_lk;

    for (n_lk = 0;n_lk < 1;n_lk++) {
        mem_base = xmlMemBlocks();
        lk = gen_xmlLinkPtr(n_lk, 0);

        ret_val = xmlLinkGetData(lk);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlLinkPtr(n_lk, lk, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLinkGetData",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_lk);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListAppend(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l;
    int n_l;
    void * data;
    int n_data;

    for (n_l = 0;n_l < 2;n_l++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListAppend(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListAppend",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListClear(void) {
    int test_ret = 0;

    int mem_base;
    xmlListPtr l;
    int n_l;

    for (n_l = 0;n_l < 2;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListClear(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListClear",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}



static xmlListPtr gen_const_xmlListPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 10825 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 10825 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlListPtr(int no __attribute__((unused)), const xmlListPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlListCopy(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr cur;
    int n_cur;
    xmlListPtr old;
    int n_old;

    for (n_cur = 0;n_cur < 2;n_cur++) {
    for (n_old = 0;n_old < 1;n_old++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlListPtr(n_cur, 0);
        old = gen_const_xmlListPtr(n_old, 1);

        ret_val = xmlListCopy(cur, (const xmlListPtr)old);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_cur, cur, 0);
        des_const_xmlListPtr(n_old, (const xmlListPtr)old, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListCopy",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_old);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListCreate(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlListDup(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlListEmpty(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l;
    int n_l;

    for (n_l = 0;n_l < 2;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        ret_val = xmlListEmpty(l);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListEmpty",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListEnd(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlListFront(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlListInsert(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l;
    int n_l;
    void * data;
    int n_data;

    for (n_l = 0;n_l < 2;n_l++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListInsert(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListInsert",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListMerge(void) {
    int test_ret = 0;

    int mem_base;
    xmlListPtr l1;
    int n_l1;
    xmlListPtr l2;
    int n_l2;

    for (n_l1 = 0;n_l1 < 2;n_l1++) {
    for (n_l2 = 0;n_l2 < 2;n_l2++) {
        mem_base = xmlMemBlocks();
        l1 = gen_xmlListPtr(n_l1, 0);
        l2 = gen_xmlListPtr(n_l2, 1);

        xmlListMerge(l1, l2);
        call_tests++;
        des_xmlListPtr(n_l1, l1, 0);
        des_xmlListPtr(n_l2, l2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListMerge",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l1);
            printf(" %d", n_l2);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListPopBack(void) {
    int test_ret = 0;

    int mem_base;
    xmlListPtr l;
    int n_l;

    for (n_l = 0;n_l < 2;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListPopBack(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPopBack",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListPopFront(void) {
    int test_ret = 0;

    int mem_base;
    xmlListPtr l;
    int n_l;

    for (n_l = 0;n_l < 2;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListPopFront(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPopFront",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListPushBack(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l;
    int n_l;
    void * data;
    int n_data;

    for (n_l = 0;n_l < 2;n_l++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListPushBack(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPushBack",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListPushFront(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l;
    int n_l;
    void * data;
    int n_data;

    for (n_l = 0;n_l < 2;n_l++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListPushFront(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListPushFront",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListRemoveAll(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l;
    int n_l;
    void * data;
    int n_data;

    for (n_l = 0;n_l < 2;n_l++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListRemoveAll(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListRemoveAll",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListRemoveFirst(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l;
    int n_l;
    void * data;
    int n_data;

    for (n_l = 0;n_l < 2;n_l++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListRemoveFirst(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListRemoveFirst",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListRemoveLast(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l;
    int n_l;
    void * data;
    int n_data;

    for (n_l = 0;n_l < 2;n_l++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListRemoveLast(l, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListRemoveLast",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListReverse(void) {
    int test_ret = 0;

    int mem_base;
    xmlListPtr l;
    int n_l;

    for (n_l = 0;n_l < 2;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListReverse(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListReverse",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListReverseSearch(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    xmlListPtr l;
    int n_l;
    void * data;
    int n_data;

    for (n_l = 0;n_l < 2;n_l++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListReverseSearch(l, data);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListReverseSearch",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListReverseWalk(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlListSearch(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    xmlListPtr l;
    int n_l;
    void * data;
    int n_data;

    for (n_l = 0;n_l < 2;n_l++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);
        data = gen_userdata(n_data, 1);

        ret_val = xmlListSearch(l, data);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        des_userdata(n_data, data, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListSearch",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListSize(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlListPtr l;
    int n_l;

    for (n_l = 0;n_l < 2;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        ret_val = xmlListSize(l);
        desret_int(ret_val);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListSize",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListSort(void) {
    int test_ret = 0;

    int mem_base;
    xmlListPtr l;
    int n_l;

    for (n_l = 0;n_l < 2;n_l++) {
        mem_base = xmlMemBlocks();
        l = gen_xmlListPtr(n_l, 0);

        xmlListSort(l);
        call_tests++;
        des_xmlListPtr(n_l, l, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlListSort",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_l);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlListWalk(void) {
    int test_ret = 0;



    return(test_ret);
}

static int
test_list(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing list : 19 of 26 functions ...\n");
    test_ret += test_xmlLinkGetData();
    test_ret += test_xmlListAppend();
    test_ret += test_xmlListClear();
    test_ret += test_xmlListCopy();
    test_ret += test_xmlListCreate();
    test_ret += test_xmlListDup();
    test_ret += test_xmlListEmpty();
    test_ret += test_xmlListEnd();
    test_ret += test_xmlListFront();
    test_ret += test_xmlListInsert();
    test_ret += test_xmlListMerge();
    test_ret += test_xmlListPopBack();
    test_ret += test_xmlListPopFront();
    test_ret += test_xmlListPushBack();
    test_ret += test_xmlListPushFront();
    test_ret += test_xmlListRemoveAll();
    test_ret += test_xmlListRemoveFirst();
    test_ret += test_xmlListRemoveLast();
    test_ret += test_xmlListReverse();
    test_ret += test_xmlListReverseSearch();
    test_ret += test_xmlListReverseWalk();
    test_ret += test_xmlListSearch();
    test_ret += test_xmlListSize();
    test_ret += test_xmlListSort();
    test_ret += test_xmlListWalk();

    if (test_ret != 0)
 printf("Module list: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlNanoFTPCheckResponse(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 4;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoFTPCheckResponse(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCheckResponse",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPCleanup(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoFTPCleanup();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCleanup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPCloseConnection(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 4;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoFTPCloseConnection(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCloseConnection",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPCwd(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;
    char * directory;
    int n_directory;

    for (n_ctx = 0;n_ctx < 4;n_ctx++) {
    for (n_directory = 0;n_directory < 4;n_directory++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        directory = gen_const_char_ptr(n_directory, 1);

        ret_val = xmlNanoFTPCwd(ctx, (const char *)directory);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        des_const_char_ptr(n_directory, (const char *)directory, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPCwd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_directory);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPDele(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;
    const char * file;
    int n_file;

    for (n_ctx = 0;n_ctx < 4;n_ctx++) {
    for (n_file = 0;n_file < 8;n_file++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        file = gen_filepath(n_file, 1);

        ret_val = xmlNanoFTPDele(ctx, file);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        des_filepath(n_file, file, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPDele",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_file);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPGet(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlNanoFTPGetConnection(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlNanoFTPGetResponse(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 4;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoFTPGetResponse(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPGetResponse",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPGetSocket(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlNanoFTPInit(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoFTPInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPInit",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPList(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlNanoFTPNewCtxt(void) {
    int test_ret = 0;


    int mem_base;
    void * ret_val;
    const char * URL;
    int n_URL;

    for (n_URL = 0;n_URL < 8;n_URL++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);

        ret_val = xmlNanoFTPNewCtxt(URL);
        desret_xmlNanoFTPCtxtPtr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPNewCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPOpen(void) {
    int test_ret = 0;


    int mem_base;
    void * ret_val;
    const char * URL;
    int n_URL;

    for (n_URL = 0;n_URL < 8;n_URL++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);

        ret_val = xmlNanoFTPOpen(URL);
        desret_xmlNanoFTPCtxtPtr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPOpen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPProxy(void) {
    int test_ret = 0;


    char * host;
    int n_host;
    int port;
    int n_port;
    char * user;
    int n_user;
    char * passwd;
    int n_passwd;
    int type;
    int n_type;

    for (n_host = 0;n_host < 4;n_host++) {
    for (n_port = 0;n_port < 4;n_port++) {
    for (n_user = 0;n_user < 4;n_user++) {
    for (n_passwd = 0;n_passwd < 4;n_passwd++) {
    for (n_type = 0;n_type < 4;n_type++) {
        host = gen_const_char_ptr(n_host, 0);
        port = gen_int(n_port, 1);
        user = gen_const_char_ptr(n_user, 2);
        passwd = gen_const_char_ptr(n_passwd, 3);
        type = gen_int(n_type, 4);

        xmlNanoFTPProxy((const char *)host, port, (const char *)user, (const char *)passwd, type);
        call_tests++;
        des_const_char_ptr(n_host, (const char *)host, 0);
        des_int(n_port, port, 1);
        des_const_char_ptr(n_user, (const char *)user, 2);
        des_const_char_ptr(n_passwd, (const char *)passwd, 3);
        des_int(n_type, type, 4);
        xmlResetLastError();
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPQuit(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 4;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoFTPQuit(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPQuit",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPRead(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;
    void * dest;
    int n_dest;
    int len;
    int n_len;

    for (n_ctx = 0;n_ctx < 4;n_ctx++) {
    for (n_dest = 0;n_dest < 2;n_dest++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        dest = gen_void_ptr(n_dest, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNanoFTPRead(ctx, dest, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        des_void_ptr(n_dest, dest, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPRead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_dest);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPScanProxy(void) {
    int test_ret = 0;


    const char * URL;
    int n_URL;

    for (n_URL = 0;n_URL < 8;n_URL++) {
        URL = gen_filepath(n_URL, 0);

        xmlNanoFTPScanProxy(URL);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoFTPUpdateURL(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;
    const char * URL;
    int n_URL;

    for (n_ctx = 0;n_ctx < 4;n_ctx++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoFTPCtxtPtr(n_ctx, 0);
        URL = gen_filepath(n_URL, 1);

        ret_val = xmlNanoFTPUpdateURL(ctx, URL);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoFTPCtxtPtr(n_ctx, ctx, 0);
        des_filepath(n_URL, URL, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoFTPUpdateURL",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_URL);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_nanoftp(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing nanoftp : 14 of 22 functions ...\n");
    test_ret += test_xmlNanoFTPCheckResponse();
    test_ret += test_xmlNanoFTPCleanup();
    test_ret += test_xmlNanoFTPCloseConnection();
    test_ret += test_xmlNanoFTPCwd();
    test_ret += test_xmlNanoFTPDele();
    test_ret += test_xmlNanoFTPGet();
    test_ret += test_xmlNanoFTPGetConnection();
    test_ret += test_xmlNanoFTPGetResponse();
    test_ret += test_xmlNanoFTPGetSocket();
    test_ret += test_xmlNanoFTPInit();
    test_ret += test_xmlNanoFTPList();
    test_ret += test_xmlNanoFTPNewCtxt();
    test_ret += test_xmlNanoFTPOpen();
    test_ret += test_xmlNanoFTPProxy();
    test_ret += test_xmlNanoFTPQuit();
    test_ret += test_xmlNanoFTPRead();
    test_ret += test_xmlNanoFTPScanProxy();
    test_ret += test_xmlNanoFTPUpdateURL();

    if (test_ret != 0)
 printf("Module nanoftp: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlNanoHTTPAuthHeader(void) {
    int test_ret = 0;


    int mem_base;
    const char * ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPAuthHeader(ctx);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPAuthHeader",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPCleanup(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoHTTPCleanup();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPCleanup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPContentLength(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPContentLength(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPContentLength",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPEncoding(void) {
    int test_ret = 0;


    int mem_base;
    const char * ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPEncoding(ctx);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPEncoding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}



static char ** gen_char_ptr_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 12189 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 12189 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_char_ptr_ptr(int no __attribute__((unused)), char ** val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlNanoHTTPFetch(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * URL;
    int n_URL;
    const char * filename;
    int n_filename;
    char ** contentType;
    int n_contentType;

    for (n_URL = 0;n_URL < 6;n_URL++) {
    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_contentType = 0;n_contentType < 1;n_contentType++) {
        mem_base = xmlMemBlocks();
        URL = gen_fileoutput(n_URL, 0);
        filename = gen_fileoutput(n_filename, 1);
        contentType = gen_char_ptr_ptr(n_contentType, 2);

        ret_val = xmlNanoHTTPFetch(URL, filename, contentType);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_URL, URL, 0);
        des_fileoutput(n_filename, filename, 1);
        des_char_ptr_ptr(n_contentType, contentType, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPFetch",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf(" %d", n_filename);
            printf(" %d", n_contentType);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPInit(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        xmlNanoHTTPInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPInit",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPMimeType(void) {
    int test_ret = 0;


    int mem_base;
    const char * ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPMimeType(ctx);
        desret_const_char_ptr(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPMimeType",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPOpen(void) {
    int test_ret = 0;


    int mem_base;
    void * ret_val;
    const char * URL;
    int n_URL;
    char ** contentType;
    int n_contentType;

    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_contentType = 0;n_contentType < 1;n_contentType++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);
        contentType = gen_char_ptr_ptr(n_contentType, 1);

        ret_val = xmlNanoHTTPOpen(URL, contentType);
        desret_xmlNanoHTTPCtxtPtr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        des_char_ptr_ptr(n_contentType, contentType, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPOpen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf(" %d", n_contentType);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPOpenRedir(void) {
    int test_ret = 0;


    int mem_base;
    void * ret_val;
    const char * URL;
    int n_URL;
    char ** contentType;
    int n_contentType;
    char ** redir;
    int n_redir;

    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_contentType = 0;n_contentType < 1;n_contentType++) {
    for (n_redir = 0;n_redir < 1;n_redir++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);
        contentType = gen_char_ptr_ptr(n_contentType, 1);
        redir = gen_char_ptr_ptr(n_redir, 2);

        ret_val = xmlNanoHTTPOpenRedir(URL, contentType, redir);
        desret_xmlNanoHTTPCtxtPtr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        des_char_ptr_ptr(n_contentType, contentType, 1);
        des_char_ptr_ptr(n_redir, redir, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPOpenRedir",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf(" %d", n_contentType);
            printf(" %d", n_redir);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPRead(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;
    void * dest;
    int n_dest;
    int len;
    int n_len;

    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
    for (n_dest = 0;n_dest < 2;n_dest++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);
        dest = gen_void_ptr(n_dest, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNanoHTTPRead(ctx, dest, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        des_void_ptr(n_dest, dest, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPRead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_dest);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPRedir(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlNanoHTTPReturnCode(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlNanoHTTPCtxtPtr(n_ctx, 0);

        ret_val = xmlNanoHTTPReturnCode(ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlNanoHTTPCtxtPtr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPReturnCode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPSave(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * ctxt;
    int n_ctxt;
    const char * filename;
    int n_filename;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_filename = 0;n_filename < 6;n_filename++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_void_ptr(n_ctxt, 0);
        filename = gen_fileoutput(n_filename, 1);

        ret_val = xmlNanoHTTPSave(ctxt, filename);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_ctxt, ctxt, 0);
        des_fileoutput(n_filename, filename, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNanoHTTPSave",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNanoHTTPScanProxy(void) {
    int test_ret = 0;


    const char * URL;
    int n_URL;

    for (n_URL = 0;n_URL < 8;n_URL++) {
        URL = gen_filepath(n_URL, 0);

        xmlNanoHTTPScanProxy(URL);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        xmlResetLastError();
    }
    function_tests++;


    return(test_ret);
}

static int
test_nanohttp(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing nanohttp : 13 of 17 functions ...\n");
    test_ret += test_xmlNanoHTTPAuthHeader();
    test_ret += test_xmlNanoHTTPCleanup();
    test_ret += test_xmlNanoHTTPContentLength();
    test_ret += test_xmlNanoHTTPEncoding();
    test_ret += test_xmlNanoHTTPFetch();
    test_ret += test_xmlNanoHTTPInit();
    test_ret += test_xmlNanoHTTPMimeType();
    test_ret += test_xmlNanoHTTPOpen();
    test_ret += test_xmlNanoHTTPOpenRedir();
    test_ret += test_xmlNanoHTTPRead();
    test_ret += test_xmlNanoHTTPRedir();
    test_ret += test_xmlNanoHTTPReturnCode();
    test_ret += test_xmlNanoHTTPSave();
    test_ret += test_xmlNanoHTTPScanProxy();

    if (test_ret != 0)
 printf("Module nanohttp: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlByteConsumed(void) {
    int test_ret = 0;

    int mem_base;
    long ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlByteConsumed(ctxt);
        desret_long(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlByteConsumed",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlClearNodeInfoSeq(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserNodeInfoSeqPtr seq;
    int n_seq;

    for (n_seq = 0;n_seq < 1;n_seq++) {
        mem_base = xmlMemBlocks();
        seq = gen_xmlParserNodeInfoSeqPtr(n_seq, 0);

        xmlClearNodeInfoSeq(seq);
        call_tests++;
        des_xmlParserNodeInfoSeqPtr(n_seq, seq, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlClearNodeInfoSeq",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_seq);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlClearParserCtxt(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlClearParserCtxt(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlClearParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCreateDocParserCtxt(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;
    xmlChar * cur;
    int n_cur;

    for (n_cur = 0;n_cur < 5;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);

        ret_val = xmlCreateDocParserCtxt((const xmlChar *)cur);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateDocParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCreatePushParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    xmlParserCtxtPtr ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    void * user_data;
    int n_user_data;
    char * chunk;
    int n_chunk;
    int size;
    int n_size;
    const char * filename;
    int n_filename;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_user_data = 0;n_user_data < 3;n_user_data++) {
    for (n_chunk = 0;n_chunk < 4;n_chunk++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_filename = 0;n_filename < 6;n_filename++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        chunk = gen_const_char_ptr(n_chunk, 2);
        size = gen_int(n_size, 3);
        filename = gen_fileoutput(n_filename, 4);

        ret_val = xmlCreatePushParserCtxt(sax, user_data, (const char *)chunk, size, filename);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_const_char_ptr(n_chunk, (const char *)chunk, 2);
        des_int(n_size, size, 3);
        des_fileoutput(n_filename, filename, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreatePushParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCtxtReadDoc(void) {
    int test_ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * cur;
    int n_cur;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_parseroptions(n_options, 4);

        ret_val = xmlCtxtReadDoc(ctxt, (const xmlChar *)cur, URL, (const char *)encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        des_parseroptions(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCtxtReadFile(void) {
    int test_ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        filename = gen_filepath(n_filename, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_parseroptions(n_options, 3);

        ret_val = xmlCtxtReadFile(ctxt, filename, (const char *)encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_filepath(n_filename, filename, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_parseroptions(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCtxtReadMemory(void) {
    int test_ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        URL = gen_filepath(n_URL, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);
        options = gen_parseroptions(n_options, 5);

        ret_val = xmlCtxtReadMemory(ctxt, (const char *)buffer, size, URL, (const char *)encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
        des_int(n_size, size, 2);
        des_filepath(n_URL, URL, 3);
        des_const_char_ptr(n_encoding, (const char *)encoding, 4);
        des_parseroptions(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReadMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCtxtReset(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlCtxtReset(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtReset",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCtxtResetPush(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    char * chunk;
    int n_chunk;
    int size;
    int n_size;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_chunk = 0;n_chunk < 4;n_chunk++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        chunk = gen_const_char_ptr(n_chunk, 1);
        size = gen_int(n_size, 2);
        filename = gen_filepath(n_filename, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);

        ret_val = xmlCtxtResetPush(ctxt, (const char *)chunk, size, filename, (const char *)encoding);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_chunk, (const char *)chunk, 1);
        des_int(n_size, size, 2);
        des_filepath(n_filename, filename, 3);
        des_const_char_ptr(n_encoding, (const char *)encoding, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtResetPush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCtxtUseOptions(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        options = gen_parseroptions(n_options, 1);

        ret_val = xmlCtxtUseOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_parseroptions(n_options, options, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtUseOptions",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetExternalEntityLoader(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlGetFeature(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    char * name;
    int n_name;
    void * result;
    int n_result;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_name = 0;n_name < 4;n_name++) {
    for (n_result = 0;n_result < 2;n_result++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        name = gen_const_char_ptr(n_name, 1);
        result = gen_void_ptr(n_result, 2);

        ret_val = xmlGetFeature(ctxt, (const char *)name, result);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_name, (const char *)name, 1);
        des_void_ptr(n_result, result, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetFeature",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_result);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}



static char ** gen_const_char_ptr_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 13127 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 13127 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_char_ptr_ptr(int no __attribute__((unused)), const char ** val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlGetFeaturesList(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    int * len;
    int n_len;
    char ** result;
    int n_result;

    for (n_len = 0;n_len < 2;n_len++) {
    for (n_result = 0;n_result < 1;n_result++) {
        mem_base = xmlMemBlocks();
        len = gen_int_ptr(n_len, 0);
        result = gen_const_char_ptr_ptr(n_result, 1);

        ret_val = xmlGetFeaturesList(len, (const char **)result);
        desret_int(ret_val);
        call_tests++;
        des_int_ptr(n_len, len, 0);
        des_const_char_ptr_ptr(n_result, (const char **)result, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetFeaturesList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_len);
            printf(" %d", n_result);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlHasFeature(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlFeature feature;
    int n_feature;

    for (n_feature = 0;n_feature < 4;n_feature++) {
        mem_base = xmlMemBlocks();
        feature = gen_xmlFeature(n_feature, 0);

        ret_val = xmlHasFeature(feature);
        desret_int(ret_val);
        call_tests++;
        des_xmlFeature(n_feature, feature, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHasFeature",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_feature);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIOParseDTD(void) {
    int test_ret = 0;



    xmlDtdPtr ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    xmlParserInputBufferPtr input;
    int n_input;
    xmlCharEncoding enc;
    int n_enc;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_input = 0;n_input < 8;n_input++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        input = gen_xmlParserInputBufferPtr(n_input, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);

        ret_val = xmlIOParseDTD(sax, input, enc);
        input = 
# 13229 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
               ((void *)0)
# 13229 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                   ;
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_xmlParserInputBufferPtr(n_input, input, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        xmlResetLastError();
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlInitNodeInfoSeq(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserNodeInfoSeqPtr seq;
    int n_seq;

    for (n_seq = 0;n_seq < 1;n_seq++) {
        mem_base = xmlMemBlocks();
        seq = gen_xmlParserNodeInfoSeqPtr(n_seq, 0);

        xmlInitNodeInfoSeq(seq);
        call_tests++;
        des_xmlParserNodeInfoSeqPtr(n_seq, seq, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitNodeInfoSeq",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_seq);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlInitParser(void) {
    int test_ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlInitParser();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitParser",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlInitParserCtxt(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlInitParserCtxt(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlInitParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlKeepBlanksDefault(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    int val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlKeepBlanksDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlKeepBlanksDefault",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlLineNumbersDefault(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    int val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlLineNumbersDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLineNumbersDefault",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlLoadExternalEntity(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    const char * URL;
    int n_URL;
    char * ID;
    int n_ID;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_ID = 0;n_ID < 4;n_ID++) {
    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);
        ID = gen_const_char_ptr(n_ID, 1);
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 2);

        ret_val = xmlLoadExternalEntity(URL, (const char *)ID, ctxt);
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        des_const_char_ptr(n_ID, (const char *)ID, 1);
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLoadExternalEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf(" %d", n_ID);
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewIOInputStream(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlParserInputBufferPtr input;
    int n_input;
    xmlCharEncoding enc;
    int n_enc;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_input = 0;n_input < 8;n_input++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        input = gen_xmlParserInputBufferPtr(n_input, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);

        ret_val = xmlNewIOInputStream(ctxt, input, enc);
        if (ret_val != 
# 13464 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                      ((void *)0)
# 13464 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                          ) input = 
# 13464 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                    ((void *)0)
# 13464 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                        ;
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlParserInputBufferPtr(n_input, input, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewIOInputStream",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_input);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewParserCtxt(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlNewParserCtxt();
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}



static xmlNodePtr * gen_xmlNodePtr_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 13516 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 13516 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlNodePtr_ptr(int no __attribute__((unused)), xmlNodePtr * val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlParseBalancedChunkMemory(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlSAXHandlerPtr sax;
    int n_sax;
    void * user_data;
    int n_user_data;
    int depth;
    int n_depth;
    xmlChar * string;
    int n_string;
    xmlNodePtr * lst;
    int n_lst;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_user_data = 0;n_user_data < 3;n_user_data++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
    for (n_string = 0;n_string < 5;n_string++) {
    for (n_lst = 0;n_lst < 1;n_lst++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
        user_data = gen_userdata(n_user_data, 2);
        depth = gen_int(n_depth, 3);
        string = gen_const_xmlChar_ptr(n_string, 4);
        lst = gen_xmlNodePtr_ptr(n_lst, 5);


        if (sax == (xmlSAXHandlerPtr)&(*(__xmlDefaultSAXHandler()))) user_data = 
# 13557 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                       ((void *)0)
# 13557 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                           ;



        ret_val = xmlParseBalancedChunkMemory(doc, sax, user_data, depth, (const xmlChar *)string, lst);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlSAXHandlerPtr(n_sax, sax, 1);
        des_userdata(n_user_data, user_data, 2);
        des_int(n_depth, depth, 3);
        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 4);
        des_xmlNodePtr_ptr(n_lst, lst, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseBalancedChunkMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_depth);
            printf(" %d", n_string);
            printf(" %d", n_lst);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlParseBalancedChunkMemoryRecover(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlSAXHandlerPtr sax;
    int n_sax;
    void * user_data;
    int n_user_data;
    int depth;
    int n_depth;
    xmlChar * string;
    int n_string;
    xmlNodePtr * lst;
    int n_lst;
    int recover;
    int n_recover;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_user_data = 0;n_user_data < 3;n_user_data++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
    for (n_string = 0;n_string < 5;n_string++) {
    for (n_lst = 0;n_lst < 1;n_lst++) {
    for (n_recover = 0;n_recover < 4;n_recover++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
        user_data = gen_userdata(n_user_data, 2);
        depth = gen_int(n_depth, 3);
        string = gen_const_xmlChar_ptr(n_string, 4);
        lst = gen_xmlNodePtr_ptr(n_lst, 5);
        recover = gen_int(n_recover, 6);


        if (sax == (xmlSAXHandlerPtr)&(*(__xmlDefaultSAXHandler()))) user_data = 
# 13637 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                       ((void *)0)
# 13637 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                           ;



        ret_val = xmlParseBalancedChunkMemoryRecover(doc, sax, user_data, depth, (const xmlChar *)string, lst, recover);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlSAXHandlerPtr(n_sax, sax, 1);
        des_userdata(n_user_data, user_data, 2);
        des_int(n_depth, depth, 3);
        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 4);
        des_xmlNodePtr_ptr(n_lst, lst, 5);
        des_int(n_recover, recover, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseBalancedChunkMemoryRecover",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_depth);
            printf(" %d", n_string);
            printf(" %d", n_lst);
            printf(" %d", n_recover);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlParseChunk(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    char * chunk;
    int n_chunk;
    int size;
    int n_size;
    int terminate;
    int n_terminate;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_chunk = 0;n_chunk < 4;n_chunk++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_terminate = 0;n_terminate < 4;n_terminate++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        chunk = gen_const_char_ptr(n_chunk, 1);
        size = gen_int(n_size, 2);
        terminate = gen_int(n_terminate, 3);

        ret_val = xmlParseChunk(ctxt, (const char *)chunk, size, terminate);
        if (ctxt != 
# 13707 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 13707 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       ) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = 
# 13707 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                 ((void *)0)
# 13707 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                     ;}
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_chunk, (const char *)chunk, 1);
        des_int(n_size, size, 2);
        des_int(n_terminate, terminate, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseChunk",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_chunk);
            printf(" %d", n_size);
            printf(" %d", n_terminate);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlParseCtxtExternalEntity(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctx;
    int n_ctx;
    xmlChar * URL;
    int n_URL;
    xmlChar * ID;
    int n_ID;
    xmlNodePtr * lst;
    int n_lst;

    for (n_ctx = 0;n_ctx < 3;n_ctx++) {
    for (n_URL = 0;n_URL < 5;n_URL++) {
    for (n_ID = 0;n_ID < 5;n_ID++) {
    for (n_lst = 0;n_lst < 1;n_lst++) {
        mem_base = xmlMemBlocks();
        ctx = gen_xmlParserCtxtPtr(n_ctx, 0);
        URL = gen_const_xmlChar_ptr(n_URL, 1);
        ID = gen_const_xmlChar_ptr(n_ID, 2);
        lst = gen_xmlNodePtr_ptr(n_lst, 3);

        ret_val = xmlParseCtxtExternalEntity(ctx, (const xmlChar *)URL, (const xmlChar *)ID, lst);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctx, ctx, 0);
        des_const_xmlChar_ptr(n_URL, (const xmlChar *)URL, 1);
        des_const_xmlChar_ptr(n_ID, (const xmlChar *)ID, 2);
        des_xmlNodePtr_ptr(n_lst, lst, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseCtxtExternalEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_URL);
            printf(" %d", n_ID);
            printf(" %d", n_lst);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParseDTD(void) {
    int test_ret = 0;



    int mem_base;
    xmlDtdPtr ret_val;
    xmlChar * ExternalID;
    int n_ExternalID;
    xmlChar * SystemID;
    int n_SystemID;

    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < 5;n_SystemID++) {
        mem_base = xmlMemBlocks();
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 0);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 1);

        ret_val = xmlParseDTD((const xmlChar *)ExternalID, (const xmlChar *)SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 0);
        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDTD",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlParseDoc(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur;
    int n_cur;

    for (n_cur = 0;n_cur < 5;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);

        ret_val = xmlParseDoc((const xmlChar *)cur);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlParseDocument(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlParseDocument(ctxt);
        if (ctxt != 
# 13882 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 13882 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       ) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = 
# 13882 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                 ((void *)0)
# 13882 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                     ;}
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseDocument",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParseEntity(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlParseEntity(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlParseExtParsedEnt(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlParseExtParsedEnt(ctxt);
        if (ctxt != 
# 13951 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 13951 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       ) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = 
# 13951 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                 ((void *)0)
# 13951 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                     ;}
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseExtParsedEnt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParseExternalEntity(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlSAXHandlerPtr sax;
    int n_sax;
    void * user_data;
    int n_user_data;
    int depth;
    int n_depth;
    xmlChar * URL;
    int n_URL;
    xmlChar * ID;
    int n_ID;
    xmlNodePtr * lst;
    int n_lst;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_user_data = 0;n_user_data < 3;n_user_data++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
    for (n_URL = 0;n_URL < 5;n_URL++) {
    for (n_ID = 0;n_ID < 5;n_ID++) {
    for (n_lst = 0;n_lst < 1;n_lst++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        sax = gen_xmlSAXHandlerPtr(n_sax, 1);
        user_data = gen_userdata(n_user_data, 2);
        depth = gen_int(n_depth, 3);
        URL = gen_const_xmlChar_ptr(n_URL, 4);
        ID = gen_const_xmlChar_ptr(n_ID, 5);
        lst = gen_xmlNodePtr_ptr(n_lst, 6);

        ret_val = xmlParseExternalEntity(doc, sax, user_data, depth, (const xmlChar *)URL, (const xmlChar *)ID, lst);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlSAXHandlerPtr(n_sax, sax, 1);
        des_userdata(n_user_data, user_data, 2);
        des_int(n_depth, depth, 3);
        des_const_xmlChar_ptr(n_URL, (const xmlChar *)URL, 4);
        des_const_xmlChar_ptr(n_ID, (const xmlChar *)ID, 5);
        des_xmlNodePtr_ptr(n_lst, lst, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseExternalEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_depth);
            printf(" %d", n_URL);
            printf(" %d", n_ID);
            printf(" %d", n_lst);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlParseFile(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlParseFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlParseInNodeContext(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserErrors ret_val;
    xmlNodePtr node;
    int n_node;
    char * data;
    int n_data;
    int datalen;
    int n_datalen;
    int options;
    int n_options;
    xmlNodePtr * lst;
    int n_lst;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_data = 0;n_data < 4;n_data++) {
    for (n_datalen = 0;n_datalen < 4;n_datalen++) {
    for (n_options = 0;n_options < 5;n_options++) {
    for (n_lst = 0;n_lst < 1;n_lst++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        data = gen_const_char_ptr(n_data, 1);
        datalen = gen_int(n_datalen, 2);
        options = gen_parseroptions(n_options, 3);
        lst = gen_xmlNodePtr_ptr(n_lst, 4);

        ret_val = xmlParseInNodeContext(node, (const char *)data, datalen, options, lst);
        desret_xmlParserErrors(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_char_ptr(n_data, (const char *)data, 1);
        des_int(n_datalen, datalen, 2);
        des_parseroptions(n_options, options, 3);
        des_xmlNodePtr_ptr(n_lst, lst, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseInNodeContext",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_data);
            printf(" %d", n_datalen);
            printf(" %d", n_options);
            printf(" %d", n_lst);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParseMemory(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;

    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = xmlParseMemory((const char *)buffer, size);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}



static xmlParserNodeInfoPtr gen_const_xmlParserNodeInfoPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 14189 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 14189 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlParserNodeInfoPtr(int no __attribute__((unused)), const xmlParserNodeInfoPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlParserAddNodeInfo(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlParserNodeInfoPtr info;
    int n_info;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_info = 0;n_info < 1;n_info++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        info = gen_const_xmlParserNodeInfoPtr(n_info, 1);

        xmlParserAddNodeInfo(ctxt, (const xmlParserNodeInfoPtr)info);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlParserNodeInfoPtr(n_info, (const xmlParserNodeInfoPtr)info, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserAddNodeInfo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_info);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}



static xmlParserCtxtPtr gen_const_xmlParserCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 14233 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 14233 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlParserCtxtPtr(int no __attribute__((unused)), const xmlParserCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}


static xmlNodePtr gen_const_xmlNodePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 14240 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 14240 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlNodePtr(int no __attribute__((unused)), const xmlNodePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlParserFindNodeInfo(void) {
    int test_ret = 0;

    int mem_base;
    const xmlParserNodeInfo * ret_val;
    xmlParserCtxtPtr ctx;
    int n_ctx;
    xmlNodePtr node;
    int n_node;

    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
    for (n_node = 0;n_node < 1;n_node++) {
        mem_base = xmlMemBlocks();
        ctx = gen_const_xmlParserCtxtPtr(n_ctx, 0);
        node = gen_const_xmlNodePtr(n_node, 1);

        ret_val = xmlParserFindNodeInfo((const xmlParserCtxtPtr)ctx, (const xmlNodePtr)node);
        desret_const_xmlParserNodeInfo_ptr(ret_val);
        call_tests++;
        des_const_xmlParserCtxtPtr(n_ctx, (const xmlParserCtxtPtr)ctx, 0);
        des_const_xmlNodePtr(n_node, (const xmlNodePtr)node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserFindNodeInfo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}



static xmlParserNodeInfoSeqPtr gen_const_xmlParserNodeInfoSeqPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 14286 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 14286 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlParserNodeInfoSeqPtr(int no __attribute__((unused)), const xmlParserNodeInfoSeqPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlParserFindNodeInfoIndex(void) {
    int test_ret = 0;

    int mem_base;
    unsigned long ret_val;
    xmlParserNodeInfoSeqPtr seq;
    int n_seq;
    xmlNodePtr node;
    int n_node;

    for (n_seq = 0;n_seq < 1;n_seq++) {
    for (n_node = 0;n_node < 1;n_node++) {
        mem_base = xmlMemBlocks();
        seq = gen_const_xmlParserNodeInfoSeqPtr(n_seq, 0);
        node = gen_const_xmlNodePtr(n_node, 1);

        ret_val = xmlParserFindNodeInfoIndex((const xmlParserNodeInfoSeqPtr)seq, (const xmlNodePtr)node);
        desret_unsigned_long(ret_val);
        call_tests++;
        des_const_xmlParserNodeInfoSeqPtr(n_seq, (const xmlParserNodeInfoSeqPtr)seq, 0);
        des_const_xmlNodePtr(n_node, (const xmlNodePtr)node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserFindNodeInfoIndex",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_seq);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}



static xmlParserInputPtr gen_xmlParserInputPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 14332 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 14332 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlParserInputPtr(int no __attribute__((unused)), xmlParserInputPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlParserInputGrow(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputPtr in;
    int n_in;
    int len;
    int n_len;

    for (n_in = 0;n_in < 1;n_in++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputGrow(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputGrow",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserInputRead(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputPtr in;
    int n_in;
    int len;
    int n_len;

    for (n_in = 0;n_in < 1;n_in++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputRead(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputRead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlPedanticParserDefault(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    int val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlPedanticParserDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPedanticParserDefault",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlReadDoc(void) {
    int test_ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur;
    int n_cur;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        URL = gen_filepath(n_URL, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_parseroptions(n_options, 3);

        ret_val = xmlReadDoc((const xmlChar *)cur, URL, (const char *)encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
        des_filepath(n_URL, URL, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_parseroptions(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlReadFile(void) {
    int test_ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        options = gen_parseroptions(n_options, 2);

        ret_val = xmlReadFile(filename, (const char *)encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
        des_parseroptions(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlReadMemory(void) {
    int test_ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_parseroptions(n_options, 4);

        ret_val = xmlReadMemory((const char *)buffer, size, URL, (const char *)encoding, options);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
        des_int(n_size, size, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        des_parseroptions(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReadMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlRecoverDoc(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * cur;
    int n_cur;

    for (n_cur = 0;n_cur < 5;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);

        ret_val = xmlRecoverDoc((const xmlChar *)cur);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlRecoverFile(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlRecoverFile(filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlRecoverMemory(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;

    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = xmlRecoverMemory((const char *)buffer, size);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRecoverMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXParseDTD(void) {
    int test_ret = 0;



    int mem_base;
    xmlDtdPtr ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    xmlChar * ExternalID;
    int n_ExternalID;
    xmlChar * SystemID;
    int n_SystemID;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < 5;n_SystemID++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 1);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 2);

        ret_val = xmlSAXParseDTD(sax, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 1);
        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseDTD",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXParseDoc(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    xmlChar * cur;
    int n_cur;
    int recovery;
    int n_recovery;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_recovery = 0;n_recovery < 4;n_recovery++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        recovery = gen_int(n_recovery, 2);

        ret_val = xmlSAXParseDoc(sax, (const xmlChar *)cur, recovery);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
        des_int(n_recovery, recovery, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_cur);
            printf(" %d", n_recovery);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXParseEntity(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    const char * filename;
    int n_filename;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        filename = gen_filepath(n_filename, 1);

        ret_val = xmlSAXParseEntity(sax, filename);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_filepath(n_filename, filename, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXParseFile(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    const char * filename;
    int n_filename;
    int recovery;
    int n_recovery;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_recovery = 0;n_recovery < 4;n_recovery++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        filename = gen_filepath(n_filename, 1);
        recovery = gen_int(n_recovery, 2);

        ret_val = xmlSAXParseFile(sax, filename, recovery);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_filepath(n_filename, filename, 1);
        des_int(n_recovery, recovery, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_filename);
            printf(" %d", n_recovery);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXParseFileWithData(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    const char * filename;
    int n_filename;
    int recovery;
    int n_recovery;
    void * data;
    int n_data;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_recovery = 0;n_recovery < 4;n_recovery++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        filename = gen_filepath(n_filename, 1);
        recovery = gen_int(n_recovery, 2);
        data = gen_userdata(n_data, 3);

        ret_val = xmlSAXParseFileWithData(sax, filename, recovery, data);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_filepath(n_filename, filename, 1);
        des_int(n_recovery, recovery, 2);
        des_userdata(n_data, data, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseFileWithData",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_filename);
            printf(" %d", n_recovery);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXParseMemory(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;
    int recovery;
    int n_recovery;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_recovery = 0;n_recovery < 4;n_recovery++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        recovery = gen_int(n_recovery, 3);

        ret_val = xmlSAXParseMemory(sax, (const char *)buffer, size, recovery);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
        des_int(n_size, size, 2);
        des_int(n_recovery, recovery, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_recovery);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXParseMemoryWithData(void) {
    int test_ret = 0;



    int mem_base;
    xmlDocPtr ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;
    int recovery;
    int n_recovery;
    void * data;
    int n_data;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_recovery = 0;n_recovery < 4;n_recovery++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        recovery = gen_int(n_recovery, 3);
        data = gen_userdata(n_data, 4);

        ret_val = xmlSAXParseMemoryWithData(sax, (const char *)buffer, size, recovery, data);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
        des_int(n_size, size, 2);
        des_int(n_recovery, recovery, 3);
        des_userdata(n_data, data, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXParseMemoryWithData",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_recovery);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXUserParseFile(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    void * user_data;
    int n_user_data;
    const char * filename;
    int n_filename;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_user_data = 0;n_user_data < 3;n_user_data++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        filename = gen_filepath(n_filename, 2);


        if (sax == (xmlSAXHandlerPtr)&(*(__xmlDefaultSAXHandler()))) user_data = 
# 15116 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                       ((void *)0)
# 15116 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                           ;



        ret_val = xmlSAXUserParseFile(sax, user_data, filename);
        desret_int(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_filepath(n_filename, filename, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXUserParseFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSAXUserParseMemory(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlSAXHandlerPtr sax;
    int n_sax;
    void * user_data;
    int n_user_data;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;

    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_user_data = 0;n_user_data < 3;n_user_data++) {
    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
        mem_base = xmlMemBlocks();
        sax = gen_xmlSAXHandlerPtr(n_sax, 0);
        user_data = gen_userdata(n_user_data, 1);
        buffer = gen_const_char_ptr(n_buffer, 2);
        size = gen_int(n_size, 3);


        if (sax == (xmlSAXHandlerPtr)&(*(__xmlDefaultSAXHandler()))) user_data = 
# 15175 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                       ((void *)0)
# 15175 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                           ;



        ret_val = xmlSAXUserParseMemory(sax, user_data, (const char *)buffer, size);
        desret_int(ret_val);
        call_tests++;
        des_xmlSAXHandlerPtr(n_sax, sax, 0);
        des_userdata(n_user_data, user_data, 1);
        des_const_char_ptr(n_buffer, (const char *)buffer, 2);
        des_int(n_size, size, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSAXUserParseMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSetExternalEntityLoader(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSetFeature(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    char * name;
    int n_name;
    void * value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_name = 0;n_name < 4;n_name++) {
    for (n_value = 0;n_value < 2;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        name = gen_const_char_ptr(n_name, 1);
        value = gen_void_ptr(n_value, 2);

        ret_val = xmlSetFeature(ctxt, (const char *)name, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_name, (const char *)name, 1);
        des_void_ptr(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetFeature",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlSetupParserForBuffer(void) {
    int test_ret = 0;



    int mem_base;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * buffer;
    int n_buffer;
    const char * filename;
    int n_filename;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_buffer = 0;n_buffer < 5;n_buffer++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_xmlChar_ptr(n_buffer, 1);
        filename = gen_filepath(n_filename, 2);

        xmlSetupParserForBuffer(ctxt, (const xmlChar *)buffer, filename);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_buffer, (const xmlChar *)buffer, 1);
        des_filepath(n_filename, filename, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetupParserForBuffer",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlStopParser(void) {
    int test_ret = 0;


    int mem_base;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlStopParser(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStopParser",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSubstituteEntitiesDefault(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    int val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlSubstituteEntitiesDefault(val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSubstituteEntitiesDefault",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}

static int
test_parser(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing parser : 61 of 70 functions ...\n");
    test_ret += test_xmlByteConsumed();
    test_ret += test_xmlClearNodeInfoSeq();
    test_ret += test_xmlClearParserCtxt();
    test_ret += test_xmlCreateDocParserCtxt();
    test_ret += test_xmlCreatePushParserCtxt();
    test_ret += test_xmlCtxtReadDoc();
    test_ret += test_xmlCtxtReadFile();
    test_ret += test_xmlCtxtReadMemory();
    test_ret += test_xmlCtxtReset();
    test_ret += test_xmlCtxtResetPush();
    test_ret += test_xmlCtxtUseOptions();
    test_ret += test_xmlGetExternalEntityLoader();
    test_ret += test_xmlGetFeature();
    test_ret += test_xmlGetFeaturesList();
    test_ret += test_xmlHasFeature();
    test_ret += test_xmlIOParseDTD();
    test_ret += test_xmlInitNodeInfoSeq();
    test_ret += test_xmlInitParser();
    test_ret += test_xmlInitParserCtxt();
    test_ret += test_xmlKeepBlanksDefault();
    test_ret += test_xmlLineNumbersDefault();
    test_ret += test_xmlLoadExternalEntity();
    test_ret += test_xmlNewIOInputStream();
    test_ret += test_xmlNewParserCtxt();
    test_ret += test_xmlParseBalancedChunkMemory();
    test_ret += test_xmlParseBalancedChunkMemoryRecover();
    test_ret += test_xmlParseChunk();
    test_ret += test_xmlParseCtxtExternalEntity();
    test_ret += test_xmlParseDTD();
    test_ret += test_xmlParseDoc();
    test_ret += test_xmlParseDocument();
    test_ret += test_xmlParseEntity();
    test_ret += test_xmlParseExtParsedEnt();
    test_ret += test_xmlParseExternalEntity();
    test_ret += test_xmlParseFile();
    test_ret += test_xmlParseInNodeContext();
    test_ret += test_xmlParseMemory();
    test_ret += test_xmlParserAddNodeInfo();
    test_ret += test_xmlParserFindNodeInfo();
    test_ret += test_xmlParserFindNodeInfoIndex();
    test_ret += test_xmlParserInputGrow();
    test_ret += test_xmlParserInputRead();
    test_ret += test_xmlPedanticParserDefault();
    test_ret += test_xmlReadDoc();
    test_ret += test_xmlReadFile();
    test_ret += test_xmlReadMemory();
    test_ret += test_xmlRecoverDoc();
    test_ret += test_xmlRecoverFile();
    test_ret += test_xmlRecoverMemory();
    test_ret += test_xmlSAXParseDTD();
    test_ret += test_xmlSAXParseDoc();
    test_ret += test_xmlSAXParseEntity();
    test_ret += test_xmlSAXParseFile();
    test_ret += test_xmlSAXParseFileWithData();
    test_ret += test_xmlSAXParseMemory();
    test_ret += test_xmlSAXParseMemoryWithData();
    test_ret += test_xmlSAXUserParseFile();
    test_ret += test_xmlSAXUserParseMemory();
    test_ret += test_xmlSetExternalEntityLoader();
    test_ret += test_xmlSetFeature();
    test_ret += test_xmlSetupParserForBuffer();
    test_ret += test_xmlStopParser();
    test_ret += test_xmlSubstituteEntitiesDefault();

    if (test_ret != 0)
 printf("Module parser: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_htmlCreateFileParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    htmlParserCtxtPtr ret_val;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;

    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);

        ret_val = htmlCreateFileParserCtxt(filename, (const char *)encoding);
        desret_htmlParserCtxtPtr(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlCreateFileParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_htmlInitAutoClose(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        htmlInitAutoClose();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in htmlInitAutoClose",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_inputPop(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = inputPop(ctxt);
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in inputPop",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_inputPush(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlParserInputPtr value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_value = 0;n_value < 1;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        value = gen_xmlParserInputPtr(n_value, 1);

        ret_val = inputPush(ctxt, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlParserInputPtr(n_value, value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in inputPush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_namePop(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = namePop(ctxt);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in namePop",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_namePush(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);

        ret_val = namePush(ctxt, (const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in namePush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_nodePop(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = nodePop(ctxt);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in nodePop",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_nodePush(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlNodePtr value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_value = 0;n_value < 3;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        value = gen_xmlNodePtr(n_value, 1);

        ret_val = nodePush(ctxt, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_value, value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in nodePush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCheckLanguageID(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * lang;
    int n_lang;

    for (n_lang = 0;n_lang < 5;n_lang++) {
        mem_base = xmlMemBlocks();
        lang = gen_const_xmlChar_ptr(n_lang, 0);

        ret_val = xmlCheckLanguageID((const xmlChar *)lang);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_lang, (const xmlChar *)lang, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCheckLanguageID",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_lang);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCopyChar(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    int len;
    int n_len;
    xmlChar * out;
    int n_out;
    int val;
    int n_val;

    for (n_len = 0;n_len < 4;n_len++) {
    for (n_out = 0;n_out < 2;n_out++) {
    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        len = gen_int(n_len, 0);
        out = gen_xmlChar_ptr(n_out, 1);
        val = gen_int(n_val, 2);

        ret_val = xmlCopyChar(len, out, val);
        desret_int(ret_val);
        call_tests++;
        des_int(n_len, len, 0);
        des_xmlChar_ptr(n_out, out, 1);
        des_int(n_val, val, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_len);
            printf(" %d", n_out);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCopyCharMultiByte(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * out;
    int n_out;
    int val;
    int n_val;

    for (n_out = 0;n_out < 2;n_out++) {
    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlChar_ptr(n_out, 0);
        val = gen_int(n_val, 1);

        ret_val = xmlCopyCharMultiByte(out, val);
        desret_int(ret_val);
        call_tests++;
        des_xmlChar_ptr(n_out, out, 0);
        des_int(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyCharMultiByte",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCreateEntityParserCtxt(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;
    xmlChar * URL;
    int n_URL;
    xmlChar * ID;
    int n_ID;
    xmlChar * base;
    int n_base;

    for (n_URL = 0;n_URL < 5;n_URL++) {
    for (n_ID = 0;n_ID < 5;n_ID++) {
    for (n_base = 0;n_base < 5;n_base++) {
        mem_base = xmlMemBlocks();
        URL = gen_const_xmlChar_ptr(n_URL, 0);
        ID = gen_const_xmlChar_ptr(n_ID, 1);
        base = gen_const_xmlChar_ptr(n_base, 2);

        ret_val = xmlCreateEntityParserCtxt((const xmlChar *)URL, (const xmlChar *)ID, (const xmlChar *)base);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URL, (const xmlChar *)URL, 0);
        des_const_xmlChar_ptr(n_ID, (const xmlChar *)ID, 1);
        des_const_xmlChar_ptr(n_base, (const xmlChar *)base, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateEntityParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf(" %d", n_ID);
            printf(" %d", n_base);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCreateFileParserCtxt(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 6;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);

        ret_val = xmlCreateFileParserCtxt(filename);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateFileParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCreateMemoryParserCtxt(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;

    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = xmlCreateMemoryParserCtxt((const char *)buffer, size);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateMemoryParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCreateURLParserCtxt(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ret_val;
    const char * filename;
    int n_filename;
    int options;
    int n_options;

    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        options = gen_int(n_options, 1);

        ret_val = xmlCreateURLParserCtxt(filename, options);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_int(n_options, options, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateURLParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCurrentChar(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    int * len;
    int n_len;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_len = 0;n_len < 2;n_len++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        len = gen_int_ptr(n_len, 1);

        ret_val = xmlCurrentChar(ctxt, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int_ptr(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCurrentChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlErrMemory(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    char * extra;
    int n_extra;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_extra = 0;n_extra < 4;n_extra++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        extra = gen_const_char_ptr(n_extra, 1);

        xmlErrMemory(ctxt, (const char *)extra);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_char_ptr(n_extra, (const char *)extra, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlErrMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_extra);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsLetter(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    int c;
    int n_c;

    for (n_c = 0;n_c < 4;n_c++) {
        mem_base = xmlMemBlocks();
        c = gen_int(n_c, 0);

        ret_val = xmlIsLetter(c);
        desret_int(ret_val);
        call_tests++;
        des_int(n_c, c, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsLetter",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_c);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewEntityInputStream(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlEntityPtr entity;
    int n_entity;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_entity = 0;n_entity < 1;n_entity++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        entity = gen_xmlEntityPtr(n_entity, 1);

        ret_val = xmlNewEntityInputStream(ctxt, entity);
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlEntityPtr(n_entity, entity, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewEntityInputStream",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_entity);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewInputFromFile(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    const char * filename;
    int n_filename;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        filename = gen_filepath(n_filename, 1);

        ret_val = xmlNewInputFromFile(ctxt, filename);
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_filepath(n_filename, filename, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewInputFromFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewInputStream(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlNewInputStream(ctxt);
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewInputStream",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewStringInputStream(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * buffer;
    int n_buffer;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_buffer = 0;n_buffer < 5;n_buffer++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        buffer = gen_const_xmlChar_ptr(n_buffer, 1);

        ret_val = xmlNewStringInputStream(ctxt, (const xmlChar *)buffer);
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_buffer, (const xmlChar *)buffer, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewStringInputStream",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_buffer);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNextChar(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        xmlNextChar(ctxt);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNextChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserInputShrink(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr in;
    int n_in;

    for (n_in = 0;n_in < 1;n_in++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputPtr(n_in, 0);

        xmlParserInputShrink(in);
        call_tests++;
        des_xmlParserInputPtr(n_in, in, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputShrink",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_in);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlPopInput(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);

        ret_val = xmlPopInput(ctxt);
        desret_xmlChar(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPopInput",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlPushInput(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlParserInputPtr input;
    int n_input;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_input = 0;n_input < 1;n_input++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        input = gen_xmlParserInputPtr(n_input, 1);

        ret_val = xmlPushInput(ctxt, input);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlParserInputPtr(n_input, input, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPushInput",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_input);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSetEntityReferenceFunc(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSplitQName(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * name;
    int n_name;
    xmlChar ** prefix;
    int n_prefix;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_prefix = 0;n_prefix < 1;n_prefix++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        prefix = gen_xmlChar_ptr_ptr(n_prefix, 2);

        ret_val = xmlSplitQName(ctxt, (const xmlChar *)name, prefix);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_xmlChar_ptr_ptr(n_prefix, prefix, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSplitQName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStringCurrentChar(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * cur;
    int n_cur;
    int * len;
    int n_len;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_len = 0;n_len < 2;n_len++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        len = gen_int_ptr(n_len, 2);

        ret_val = xmlStringCurrentChar(ctxt, (const xmlChar *)cur, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
        des_int_ptr(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringCurrentChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStringDecodeEntities(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * str;
    int n_str;
    int what;
    int n_what;
    xmlChar end;
    int n_end;
    xmlChar end2;
    int n_end2;
    xmlChar end3;
    int n_end3;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_str = 0;n_str < 5;n_str++) {
    for (n_what = 0;n_what < 4;n_what++) {
    for (n_end = 0;n_end < 4;n_end++) {
    for (n_end2 = 0;n_end2 < 4;n_end2++) {
    for (n_end3 = 0;n_end3 < 4;n_end3++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);
        what = gen_int(n_what, 2);
        end = gen_xmlChar(n_end, 3);
        end2 = gen_xmlChar(n_end2, 4);
        end3 = gen_xmlChar(n_end3, 5);

        ret_val = xmlStringDecodeEntities(ctxt, (const xmlChar *)str, what, end, end2, end3);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
        des_int(n_what, what, 2);
        des_xmlChar(n_end, end, 3);
        des_xmlChar(n_end2, end2, 4);
        des_xmlChar(n_end3, end3, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringDecodeEntities",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_str);
            printf(" %d", n_what);
            printf(" %d", n_end);
            printf(" %d", n_end2);
            printf(" %d", n_end3);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStringLenDecodeEntities(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * str;
    int n_str;
    int len;
    int n_len;
    int what;
    int n_what;
    xmlChar end;
    int n_end;
    xmlChar end2;
    int n_end2;
    xmlChar end3;
    int n_end3;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_str = 0;n_str < 5;n_str++) {
    for (n_len = 0;n_len < 4;n_len++) {
    for (n_what = 0;n_what < 4;n_what++) {
    for (n_end = 0;n_end < 4;n_end++) {
    for (n_end2 = 0;n_end2 < 4;n_end2++) {
    for (n_end3 = 0;n_end3 < 4;n_end3++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);
        len = gen_int(n_len, 2);
        what = gen_int(n_what, 3);
        end = gen_xmlChar(n_end, 4);
        end2 = gen_xmlChar(n_end2, 5);
        end3 = gen_xmlChar(n_end3, 6);

        ret_val = xmlStringLenDecodeEntities(ctxt, (const xmlChar *)str, len, what, end, end2, end3);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
        des_int(n_len, len, 2);
        des_int(n_what, what, 3);
        des_xmlChar(n_end, end, 4);
        des_xmlChar(n_end2, end2, 5);
        des_xmlChar(n_end3, end3, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringLenDecodeEntities",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_str);
            printf(" %d", n_len);
            printf(" %d", n_what);
            printf(" %d", n_end);
            printf(" %d", n_end2);
            printf(" %d", n_end3);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSwitchEncoding(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlCharEncoding enc;
    int n_enc;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        enc = gen_xmlCharEncoding(n_enc, 1);

        ret_val = xmlSwitchEncoding(ctxt, enc);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlCharEncoding(n_enc, enc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSwitchEncoding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSwitchInputEncoding(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlParserInputPtr input;
    int n_input;
    xmlCharEncodingHandlerPtr handler;
    int n_handler;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_input = 0;n_input < 1;n_input++) {
    for (n_handler = 0;n_handler < 1;n_handler++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        input = gen_xmlParserInputPtr(n_input, 1);
        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 2);

        ret_val = xmlSwitchInputEncoding(ctxt, input, handler);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlParserInputPtr(n_input, input, 1);
        des_xmlCharEncodingHandlerPtr(n_handler, handler, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSwitchInputEncoding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_input);
            printf(" %d", n_handler);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSwitchToEncoding(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlCharEncodingHandlerPtr handler;
    int n_handler;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_handler = 0;n_handler < 1;n_handler++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        handler = gen_xmlCharEncodingHandlerPtr(n_handler, 1);

        ret_val = xmlSwitchToEncoding(ctxt, handler);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlCharEncodingHandlerPtr(n_handler, handler, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSwitchToEncoding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_handler);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}

static int
test_parserInternals(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing parserInternals : 33 of 90 functions ...\n");
    test_ret += test_htmlCreateFileParserCtxt();
    test_ret += test_htmlInitAutoClose();
    test_ret += test_inputPop();
    test_ret += test_inputPush();
    test_ret += test_namePop();
    test_ret += test_namePush();
    test_ret += test_nodePop();
    test_ret += test_nodePush();
    test_ret += test_xmlCheckLanguageID();
    test_ret += test_xmlCopyChar();
    test_ret += test_xmlCopyCharMultiByte();
    test_ret += test_xmlCreateEntityParserCtxt();
    test_ret += test_xmlCreateFileParserCtxt();
    test_ret += test_xmlCreateMemoryParserCtxt();
    test_ret += test_xmlCreateURLParserCtxt();
    test_ret += test_xmlCurrentChar();
    test_ret += test_xmlErrMemory();
    test_ret += test_xmlIsLetter();
    test_ret += test_xmlNewEntityInputStream();
    test_ret += test_xmlNewInputFromFile();
    test_ret += test_xmlNewInputStream();
    test_ret += test_xmlNewStringInputStream();
    test_ret += test_xmlNextChar();
    test_ret += test_xmlParserInputShrink();
    test_ret += test_xmlPopInput();
    test_ret += test_xmlPushInput();
    test_ret += test_xmlSetEntityReferenceFunc();
    test_ret += test_xmlSplitQName();
    test_ret += test_xmlStringCurrentChar();
    test_ret += test_xmlStringDecodeEntities();
    test_ret += test_xmlStringLenDecodeEntities();
    test_ret += test_xmlSwitchEncoding();
    test_ret += test_xmlSwitchInputEncoding();
    test_ret += test_xmlSwitchToEncoding();

    if (test_ret != 0)
 printf("Module parserInternals: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlPatternFromRoot(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlPatternPtr comp;
    int n_comp;

    for (n_comp = 0;n_comp < 1;n_comp++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0);

        ret_val = xmlPatternFromRoot(comp);
        desret_int(ret_val);
        call_tests++;
        des_xmlPatternPtr(n_comp, comp, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPatternFromRoot",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_comp);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlPatternGetStreamCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlPatternMatch(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlPatternPtr comp;
    int n_comp;
    xmlNodePtr node;
    int n_node;

    for (n_comp = 0;n_comp < 1;n_comp++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlPatternMatch(comp, node);
        desret_int(ret_val);
        call_tests++;
        des_xmlPatternPtr(n_comp, comp, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPatternMatch",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_comp);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlPatternMaxDepth(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlPatternPtr comp;
    int n_comp;

    for (n_comp = 0;n_comp < 1;n_comp++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0);

        ret_val = xmlPatternMaxDepth(comp);
        desret_int(ret_val);
        call_tests++;
        des_xmlPatternPtr(n_comp, comp, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPatternMaxDepth",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_comp);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlPatternMinDepth(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlPatternPtr comp;
    int n_comp;

    for (n_comp = 0;n_comp < 1;n_comp++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0);

        ret_val = xmlPatternMinDepth(comp);
        desret_int(ret_val);
        call_tests++;
        des_xmlPatternPtr(n_comp, comp, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPatternMinDepth",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_comp);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlPatternStreamable(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlPatternPtr comp;
    int n_comp;

    for (n_comp = 0;n_comp < 1;n_comp++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlPatternPtr(n_comp, 0);

        ret_val = xmlPatternStreamable(comp);
        desret_int(ret_val);
        call_tests++;
        des_xmlPatternPtr(n_comp, comp, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPatternStreamable",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_comp);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlPatterncompile(void) {
    int test_ret = 0;



    return(test_ret);
}




static xmlStreamCtxtPtr gen_xmlStreamCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 17005 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 17005 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlStreamCtxtPtr(int no __attribute__((unused)), xmlStreamCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlStreamPop(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlStreamCtxtPtr stream;
    int n_stream;

    for (n_stream = 0;n_stream < 1;n_stream++) {
        mem_base = xmlMemBlocks();
        stream = gen_xmlStreamCtxtPtr(n_stream, 0);

        ret_val = xmlStreamPop(stream);
        desret_int(ret_val);
        call_tests++;
        des_xmlStreamCtxtPtr(n_stream, stream, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStreamPop",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_stream);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlStreamPush(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlStreamCtxtPtr stream;
    int n_stream;
    xmlChar * name;
    int n_name;
    xmlChar * ns;
    int n_ns;

    for (n_stream = 0;n_stream < 1;n_stream++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ns = 0;n_ns < 5;n_ns++) {
        mem_base = xmlMemBlocks();
        stream = gen_xmlStreamCtxtPtr(n_stream, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ns = gen_const_xmlChar_ptr(n_ns, 2);

        ret_val = xmlStreamPush(stream, (const xmlChar *)name, (const xmlChar *)ns);
        desret_int(ret_val);
        call_tests++;
        des_xmlStreamCtxtPtr(n_stream, stream, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStreamPush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_stream);
            printf(" %d", n_name);
            printf(" %d", n_ns);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlStreamPushAttr(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlStreamCtxtPtr stream;
    int n_stream;
    xmlChar * name;
    int n_name;
    xmlChar * ns;
    int n_ns;

    for (n_stream = 0;n_stream < 1;n_stream++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ns = 0;n_ns < 5;n_ns++) {
        mem_base = xmlMemBlocks();
        stream = gen_xmlStreamCtxtPtr(n_stream, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ns = gen_const_xmlChar_ptr(n_ns, 2);

        ret_val = xmlStreamPushAttr(stream, (const xmlChar *)name, (const xmlChar *)ns);
        desret_int(ret_val);
        call_tests++;
        des_xmlStreamCtxtPtr(n_stream, stream, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStreamPushAttr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_stream);
            printf(" %d", n_name);
            printf(" %d", n_ns);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlStreamPushNode(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlStreamCtxtPtr stream;
    int n_stream;
    xmlChar * name;
    int n_name;
    xmlChar * ns;
    int n_ns;
    int nodeType;
    int n_nodeType;

    for (n_stream = 0;n_stream < 1;n_stream++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ns = 0;n_ns < 5;n_ns++) {
    for (n_nodeType = 0;n_nodeType < 4;n_nodeType++) {
        mem_base = xmlMemBlocks();
        stream = gen_xmlStreamCtxtPtr(n_stream, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ns = gen_const_xmlChar_ptr(n_ns, 2);
        nodeType = gen_int(n_nodeType, 3);

        ret_val = xmlStreamPushNode(stream, (const xmlChar *)name, (const xmlChar *)ns, nodeType);
        desret_int(ret_val);
        call_tests++;
        des_xmlStreamCtxtPtr(n_stream, stream, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 2);
        des_int(n_nodeType, nodeType, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStreamPushNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_stream);
            printf(" %d", n_name);
            printf(" %d", n_ns);
            printf(" %d", n_nodeType);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlStreamWantsAnyNode(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlStreamCtxtPtr streamCtxt;
    int n_streamCtxt;

    for (n_streamCtxt = 0;n_streamCtxt < 1;n_streamCtxt++) {
        mem_base = xmlMemBlocks();
        streamCtxt = gen_xmlStreamCtxtPtr(n_streamCtxt, 0);

        ret_val = xmlStreamWantsAnyNode(streamCtxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlStreamCtxtPtr(n_streamCtxt, streamCtxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStreamWantsAnyNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_streamCtxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}

static int
test_pattern(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing pattern : 10 of 15 functions ...\n");
    test_ret += test_xmlPatternFromRoot();
    test_ret += test_xmlPatternGetStreamCtxt();
    test_ret += test_xmlPatternMatch();
    test_ret += test_xmlPatternMaxDepth();
    test_ret += test_xmlPatternMinDepth();
    test_ret += test_xmlPatternStreamable();
    test_ret += test_xmlPatterncompile();
    test_ret += test_xmlStreamPop();
    test_ret += test_xmlStreamPush();
    test_ret += test_xmlStreamPushAttr();
    test_ret += test_xmlStreamPushNode();
    test_ret += test_xmlStreamWantsAnyNode();

    if (test_ret != 0)
 printf("Module pattern: %d errors\n", test_ret);
    return(test_ret);
}



static xmlRelaxNGPtr gen_xmlRelaxNGPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 17256 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 17256 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlRelaxNGPtr(int no __attribute__((unused)), xmlRelaxNGPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlRelaxNGDump(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlRelaxNGPtr schema;
    int n_schema;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_schema = 0;n_schema < 1;n_schema++) {
        mem_base = xmlMemBlocks();
        output = gen_FILE_ptr(n_output, 0);
        schema = gen_xmlRelaxNGPtr(n_schema, 1);

        xmlRelaxNGDump(output, schema);
        call_tests++;
        des_FILE_ptr(n_output, output, 0);
        des_xmlRelaxNGPtr(n_schema, schema, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_schema);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGDumpTree(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlRelaxNGPtr schema;
    int n_schema;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_schema = 0;n_schema < 1;n_schema++) {
        mem_base = xmlMemBlocks();
        output = gen_FILE_ptr(n_output, 0);
        schema = gen_xmlRelaxNGPtr(n_schema, 1);

        xmlRelaxNGDumpTree(output, schema);
        call_tests++;
        des_FILE_ptr(n_output, output, 0);
        des_xmlRelaxNGPtr(n_schema, schema, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGDumpTree",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_schema);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}




static xmlRelaxNGParserCtxtPtr gen_xmlRelaxNGParserCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 17344 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 17344 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlRelaxNGParserCtxtPtr(int no __attribute__((unused)), xmlRelaxNGParserCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}





static xmlRelaxNGValidityErrorFunc * gen_xmlRelaxNGValidityErrorFunc_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 17354 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 17354 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlRelaxNGValidityErrorFunc_ptr(int no __attribute__((unused)), xmlRelaxNGValidityErrorFunc * val __attribute__((unused)), int nr __attribute__((unused))) {
}





static xmlRelaxNGValidityWarningFunc * gen_xmlRelaxNGValidityWarningFunc_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 17364 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 17364 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlRelaxNGValidityWarningFunc_ptr(int no __attribute__((unused)), xmlRelaxNGValidityWarningFunc * val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlRelaxNGGetParserErrors(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRelaxNGParserCtxtPtr ctxt;
    int n_ctxt;
    xmlRelaxNGValidityErrorFunc * err;
    int n_err;
    xmlRelaxNGValidityWarningFunc * warn;
    int n_warn;
    void ** ctx;
    int n_ctx;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_err = 0;n_err < 1;n_err++) {
    for (n_warn = 0;n_warn < 1;n_warn++) {
    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGParserCtxtPtr(n_ctxt, 0);
        err = gen_xmlRelaxNGValidityErrorFunc_ptr(n_err, 1);
        warn = gen_xmlRelaxNGValidityWarningFunc_ptr(n_warn, 2);
        ctx = gen_void_ptr_ptr(n_ctx, 3);

        ret_val = xmlRelaxNGGetParserErrors(ctxt, err, warn, ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlRelaxNGValidityErrorFunc_ptr(n_err, err, 1);
        des_xmlRelaxNGValidityWarningFunc_ptr(n_warn, warn, 2);
        des_void_ptr_ptr(n_ctx, ctx, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGGetParserErrors",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_err);
            printf(" %d", n_warn);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}




static xmlRelaxNGValidCtxtPtr gen_xmlRelaxNGValidCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 17429 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 17429 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlRelaxNGValidCtxtPtr(int no __attribute__((unused)), xmlRelaxNGValidCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlRelaxNGGetValidErrors(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt;
    int n_ctxt;
    xmlRelaxNGValidityErrorFunc * err;
    int n_err;
    xmlRelaxNGValidityWarningFunc * warn;
    int n_warn;
    void ** ctx;
    int n_ctx;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_err = 0;n_err < 1;n_err++) {
    for (n_warn = 0;n_warn < 1;n_warn++) {
    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        err = gen_xmlRelaxNGValidityErrorFunc_ptr(n_err, 1);
        warn = gen_xmlRelaxNGValidityWarningFunc_ptr(n_warn, 2);
        ctx = gen_void_ptr_ptr(n_ctx, 3);

        ret_val = xmlRelaxNGGetValidErrors(ctxt, err, warn, ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlRelaxNGValidityErrorFunc_ptr(n_err, err, 1);
        des_xmlRelaxNGValidityWarningFunc_ptr(n_warn, warn, 2);
        des_void_ptr_ptr(n_ctx, ctx, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGGetValidErrors",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_err);
            printf(" %d", n_warn);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGInitTypes(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlRelaxNGInitTypes();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGInitTypes",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGNewDocParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    xmlRelaxNGParserCtxtPtr ret_val;
    xmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlRelaxNGNewDocParserCtxt(doc);
        desret_xmlRelaxNGParserCtxtPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGNewDocParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGNewMemParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    xmlRelaxNGParserCtxtPtr ret_val;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;

    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = xmlRelaxNGNewMemParserCtxt((const char *)buffer, size);
        desret_xmlRelaxNGParserCtxtPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGNewMemParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGNewParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    xmlRelaxNGParserCtxtPtr ret_val;
    char * URL;
    int n_URL;

    for (n_URL = 0;n_URL < 4;n_URL++) {
        mem_base = xmlMemBlocks();
        URL = gen_const_char_ptr(n_URL, 0);

        ret_val = xmlRelaxNGNewParserCtxt((const char *)URL);
        desret_xmlRelaxNGParserCtxtPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_URL, (const char *)URL, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGNewParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGNewValidCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlRelaxNGParse(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlRelaxNGSetParserErrors(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlRelaxNGSetParserStructuredErrors(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlRelaxNGSetValidErrors(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlRelaxNGSetValidStructuredErrors(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlRelaxNGValidateDoc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlRelaxNGValidateDoc(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidateDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGValidateFullElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlRelaxNGValidateFullElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidateFullElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGValidatePopElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlRelaxNGValidatePopElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidatePopElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGValidatePushCData(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * data;
    int n_data;
    int len;
    int n_len;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_data = 0;n_data < 5;n_data++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        data = gen_const_xmlChar_ptr(n_data, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlRelaxNGValidatePushCData(ctxt, (const xmlChar *)data, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_data, (const xmlChar *)data, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidatePushCData",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_data);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxNGValidatePushElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRelaxNGValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlRelaxNGValidatePushElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxNGValidatePushElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRelaxParserSetFlag(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRelaxNGParserCtxtPtr ctxt;
    int n_ctxt;
    int flags;
    int n_flags;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_flags = 0;n_flags < 4;n_flags++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlRelaxNGParserCtxtPtr(n_ctxt, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlRelaxParserSetFlag(ctxt, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlRelaxNGParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRelaxParserSetFlag",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_relaxng(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing relaxng : 14 of 24 functions ...\n");
    test_ret += test_xmlRelaxNGDump();
    test_ret += test_xmlRelaxNGDumpTree();
    test_ret += test_xmlRelaxNGGetParserErrors();
    test_ret += test_xmlRelaxNGGetValidErrors();
    test_ret += test_xmlRelaxNGInitTypes();
    test_ret += test_xmlRelaxNGNewDocParserCtxt();
    test_ret += test_xmlRelaxNGNewMemParserCtxt();
    test_ret += test_xmlRelaxNGNewParserCtxt();
    test_ret += test_xmlRelaxNGNewValidCtxt();
    test_ret += test_xmlRelaxNGParse();
    test_ret += test_xmlRelaxNGSetParserErrors();
    test_ret += test_xmlRelaxNGSetParserStructuredErrors();
    test_ret += test_xmlRelaxNGSetValidErrors();
    test_ret += test_xmlRelaxNGSetValidStructuredErrors();
    test_ret += test_xmlRelaxNGValidateDoc();
    test_ret += test_xmlRelaxNGValidateFullElement();
    test_ret += test_xmlRelaxNGValidatePopElement();
    test_ret += test_xmlRelaxNGValidatePushCData();
    test_ret += test_xmlRelaxNGValidatePushElement();
    test_ret += test_xmlRelaxParserSetFlag();

    if (test_ret != 0)
 printf("Module relaxng: %d errors\n", test_ret);
    return(test_ret);
}
static int
test_schemasInternals(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing schemasInternals : 0 of 2 functions ...\n");

    if (test_ret != 0)
 printf("Module schemasInternals: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlSchematronNewDocParserCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchematronNewMemParserCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchematronNewParserCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}




static xmlSchematronPtr gen_xmlSchematronPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 18034 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 18034 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchematronPtr(int no __attribute__((unused)), xmlSchematronPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSchematronNewValidCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}




static xmlSchematronParserCtxtPtr gen_xmlSchematronParserCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 18054 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 18054 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchematronParserCtxtPtr(int no __attribute__((unused)), xmlSchematronParserCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSchematronParse(void) {
    int test_ret = 0;



    return(test_ret);
}




static xmlSchematronValidCtxtPtr gen_xmlSchematronValidCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 18074 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 18074 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchematronValidCtxtPtr(int no __attribute__((unused)), xmlSchematronValidCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSchematronSetValidStructuredErrors(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchematronValidateDoc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchematronValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr instance;
    int n_instance;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_instance = 0;n_instance < 4;n_instance++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchematronValidCtxtPtr(n_ctxt, 0);
        instance = gen_xmlDocPtr(n_instance, 1);

        ret_val = xmlSchematronValidateDoc(ctxt, instance);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchematronValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_instance, instance, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchematronValidateDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_instance);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_schematron(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing schematron : 1 of 10 functions ...\n");
    test_ret += test_xmlSchematronNewDocParserCtxt();
    test_ret += test_xmlSchematronNewMemParserCtxt();
    test_ret += test_xmlSchematronNewParserCtxt();
    test_ret += test_xmlSchematronNewValidCtxt();
    test_ret += test_xmlSchematronParse();
    test_ret += test_xmlSchematronSetValidStructuredErrors();
    test_ret += test_xmlSchematronValidateDoc();

    if (test_ret != 0)
 printf("Module schematron: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlAddChild(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent;
    int n_parent;
    xmlNodePtr cur;
    int n_cur;

    for (n_parent = 0;n_parent < 3;n_parent++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        cur = gen_xmlNodePtr_in(n_cur, 1);

        ret_val = xmlAddChild(parent, cur);
        if (ret_val == 
# 18167 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                      ((void *)0)
# 18167 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                          ) { xmlFreeNode(cur) ; cur = 
# 18167 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                       ((void *)0) 
# 18167 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                            ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNodePtr_in(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddChild",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlAddChildList(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent;
    int n_parent;
    xmlNodePtr cur;
    int n_cur;

    for (n_parent = 0;n_parent < 3;n_parent++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        cur = gen_xmlNodePtr_in(n_cur, 1);

        ret_val = xmlAddChildList(parent, cur);
        if (ret_val == 
# 18207 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                      ((void *)0)
# 18207 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                          ) { xmlFreeNodeList(cur) ; cur = 
# 18207 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                           ((void *)0) 
# 18207 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNodePtr_in(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddChildList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlAddNextSibling(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur;
    int n_cur;
    xmlNodePtr elem;
    int n_elem;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        elem = gen_xmlNodePtr_in(n_elem, 1);

        ret_val = xmlAddNextSibling(cur, elem);
        if (ret_val == 
# 18247 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                      ((void *)0)
# 18247 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                          ) { xmlFreeNode(elem) ; elem = 
# 18247 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                         ((void *)0) 
# 18247 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                              ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_xmlNodePtr_in(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddNextSibling",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlAddPrevSibling(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur;
    int n_cur;
    xmlNodePtr elem;
    int n_elem;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        elem = gen_xmlNodePtr_in(n_elem, 1);

        ret_val = xmlAddPrevSibling(cur, elem);
        if (ret_val == 
# 18288 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                      ((void *)0)
# 18288 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                          ) { xmlFreeNode(elem) ; elem = 
# 18288 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                         ((void *)0) 
# 18288 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                              ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_xmlNodePtr_in(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddPrevSibling",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlAddSibling(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr cur;
    int n_cur;
    xmlNodePtr elem;
    int n_elem;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        elem = gen_xmlNodePtr_in(n_elem, 1);

        ret_val = xmlAddSibling(cur, elem);
        if (ret_val == 
# 18329 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                      ((void *)0)
# 18329 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                          ) { xmlFreeNode(elem) ; elem = 
# 18329 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                         ((void *)0) 
# 18329 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                              ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_xmlNodePtr_in(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddSibling",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlAttrSerializeTxtContent(void) {
    int test_ret = 0;



    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlDocPtr doc;
    int n_doc;
    xmlAttrPtr attr;
    int n_attr;
    xmlChar * string;
    int n_string;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_attr = 0;n_attr < 2;n_attr++) {
    for (n_string = 0;n_string < 5;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);
        string = gen_const_xmlChar_ptr(n_string, 3);

        xmlAttrSerializeTxtContent(buf, doc, attr, (const xmlChar *)string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAttrSerializeTxtContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}



static xmlBufPtr gen_const_xmlBufPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 18408 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 18408 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlBufPtr(int no __attribute__((unused)), const xmlBufPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlBufContent(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlBufPtr buf;
    int n_buf;

    for (n_buf = 0;n_buf < 1;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_const_xmlBufPtr(n_buf, 0);

        ret_val = xmlBufContent((const xmlBufPtr)buf);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlBufPtr(n_buf, (const xmlBufPtr)buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufEnd(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlBufPtr buf;
    int n_buf;

    for (n_buf = 0;n_buf < 1;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_const_xmlBufPtr(n_buf, 0);

        ret_val = xmlBufEnd((const xmlBufPtr)buf);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlBufPtr(n_buf, (const xmlBufPtr)buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufEnd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}



static xmlBufPtr gen_xmlBufPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 18479 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 18479 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlBufPtr(int no __attribute__((unused)), xmlBufPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlBufGetNodeContent(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufPtr buf;
    int n_buf;
    xmlNodePtr cur;
    int n_cur;

    for (n_buf = 0;n_buf < 1;n_buf++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufPtr(n_buf, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlBufGetNodeContent(buf, cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufPtr(n_buf, buf, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufGetNodeContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufNodeDump(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlBufShrink(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlBufUse(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlBufferAdd(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;
    xmlChar * str;
    int n_str;
    int len;
    int n_len;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_str = 0;n_str < 5;n_str++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlBufferAdd(buf, (const xmlChar *)str, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferAdd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferAddHead(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;
    xmlChar * str;
    int n_str;
    int len;
    int n_len;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_str = 0;n_str < 5;n_str++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlBufferAddHead(buf, (const xmlChar *)str, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferAddHead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferCCat(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;
    char * str;
    int n_str;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_str = 0;n_str < 4;n_str++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_char_ptr(n_str, 1);

        ret_val = xmlBufferCCat(buf, (const char *)str);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_char_ptr(n_str, (const char *)str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferCCat",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferCat(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;
    xmlChar * str;
    int n_str;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_str = 0;n_str < 5;n_str++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlBufferCat(buf, (const xmlChar *)str);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferCat",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}



static xmlBufferPtr gen_const_xmlBufferPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 18725 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 18725 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_const_xmlBufferPtr(int no __attribute__((unused)), const xmlBufferPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlBufferContent(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlBufferPtr buf;
    int n_buf;

    for (n_buf = 0;n_buf < 1;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_const_xmlBufferPtr(n_buf, 0);

        ret_val = xmlBufferContent((const xmlBufferPtr)buf);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlBufferPtr(n_buf, (const xmlBufferPtr)buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferCreate(void) {
    int test_ret = 0;

    int mem_base;
    xmlBufferPtr ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlBufferCreate();
        desret_xmlBufferPtr(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferCreate",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferCreateSize(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlBufferCreateStatic(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlBufferDetach(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlBufferPtr buf;
    int n_buf;

    for (n_buf = 0;n_buf < 3;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);

        ret_val = xmlBufferDetach(buf);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferDetach",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferEmpty(void) {
    int test_ret = 0;

    int mem_base;
    xmlBufferPtr buf;
    int n_buf;

    for (n_buf = 0;n_buf < 3;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);

        xmlBufferEmpty(buf);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferEmpty",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferGrow(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;
    unsigned int len;
    int n_len;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_len = 0;n_len < 3;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        len = gen_unsigned_int(n_len, 1);

        ret_val = xmlBufferGrow(buf, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_unsigned_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferGrow",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferLength(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;

    for (n_buf = 0;n_buf < 1;n_buf++) {
        mem_base = xmlMemBlocks();
        buf = gen_const_xmlBufferPtr(n_buf, 0);

        ret_val = xmlBufferLength((const xmlBufferPtr)buf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlBufferPtr(n_buf, (const xmlBufferPtr)buf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferLength",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferResize(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;
    unsigned int size;
    int n_size;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_size = 0;n_size < 3;n_size++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        size = gen_unsigned_int(n_size, 1);

        ret_val = xmlBufferResize(buf, size);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_unsigned_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferResize",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferSetAllocationScheme(void) {
    int test_ret = 0;

    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlBufferAllocationScheme scheme;
    int n_scheme;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_scheme = 0;n_scheme < 4;n_scheme++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        scheme = gen_xmlBufferAllocationScheme(n_scheme, 1);

        xmlBufferSetAllocationScheme(buf, scheme);
        if ((buf != 
# 18996 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 18996 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       ) && (scheme == XML_BUFFER_ALLOC_IMMUTABLE) && (buf->content != 
# 18996 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                                       ((void *)0)
# 18996 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                                           ) && (buf->content != static_buf_content)) { xmlFree(buf->content); buf->content = 
# 18996 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                                                                                                                              ((void *)0)
# 18996 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                                                                                                                                  ;}
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlBufferAllocationScheme(n_scheme, scheme, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferSetAllocationScheme",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_scheme);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferShrink(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;
    unsigned int len;
    int n_len;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_len = 0;n_len < 3;n_len++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        len = gen_unsigned_int(n_len, 1);

        ret_val = xmlBufferShrink(buf, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_unsigned_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferShrink",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferWriteCHAR(void) {
    int test_ret = 0;

    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlChar * string;
    int n_string;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_string = 0;n_string < 5;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        string = gen_const_xmlChar_ptr(n_string, 1);

        xmlBufferWriteCHAR(buf, (const xmlChar *)string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferWriteCHAR",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferWriteChar(void) {
    int test_ret = 0;

    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    char * string;
    int n_string;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_string = 0;n_string < 4;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        string = gen_const_char_ptr(n_string, 1);

        xmlBufferWriteChar(buf, (const char *)string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_char_ptr(n_string, (const char *)string, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferWriteChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBufferWriteQuotedString(void) {
    int test_ret = 0;

    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlChar * string;
    int n_string;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_string = 0;n_string < 5;n_string++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        string = gen_const_xmlChar_ptr(n_string, 1);

        xmlBufferWriteQuotedString(buf, (const xmlChar *)string);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_const_xmlChar_ptr(n_string, (const xmlChar *)string, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBufferWriteQuotedString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_string);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBuildQName(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * ncname;
    int n_ncname;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * memory;
    int n_memory;
    int len;
    int n_len;

    for (n_ncname = 0;n_ncname < 5;n_ncname++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_memory = 0;n_memory < 2;n_memory++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ncname = gen_const_xmlChar_ptr(n_ncname, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        memory = gen_xmlChar_ptr(n_memory, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlBuildQName((const xmlChar *)ncname, (const xmlChar *)prefix, memory, len);
        if ((ret_val != 
# 19193 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                       ((void *)0)
# 19193 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                           ) && (ret_val != ncname) &&
              (ret_val != prefix) && (ret_val != memory))
              xmlFree(ret_val);
   ret_val = 
# 19196 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
            ((void *)0)
# 19196 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                ;
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_ncname, (const xmlChar *)ncname, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_xmlChar_ptr(n_memory, memory, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildQName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ncname);
            printf(" %d", n_prefix);
            printf(" %d", n_memory);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlChildElementCount(void) {
    int test_ret = 0;


    int mem_base;
    unsigned long ret_val;
    xmlNodePtr parent;
    int n_parent;

    for (n_parent = 0;n_parent < 3;n_parent++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);

        ret_val = xmlChildElementCount(parent);
        desret_unsigned_long(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlChildElementCount",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCopyDoc(void) {
    int test_ret = 0;


    int mem_base;
    xmlDocPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    int recursive;
    int n_recursive;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_recursive = 0;n_recursive < 4;n_recursive++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        recursive = gen_int(n_recursive, 1);

        ret_val = xmlCopyDoc(doc, recursive);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_recursive, recursive, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_recursive);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCopyDtd(void) {
    int test_ret = 0;


    int mem_base;
    xmlDtdPtr ret_val;
    xmlDtdPtr dtd;
    int n_dtd;

    for (n_dtd = 0;n_dtd < 3;n_dtd++) {
        mem_base = xmlMemBlocks();
        dtd = gen_xmlDtdPtr(n_dtd, 0);

        ret_val = xmlCopyDtd(dtd);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDtdPtr(n_dtd, dtd, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyDtd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dtd);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlCopyNamespace(void) {
    int test_ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlNsPtr cur;
    int n_cur;

    for (n_cur = 0;n_cur < 2;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNsPtr(n_cur, 0);

        ret_val = xmlCopyNamespace(cur);
        if (ret_val != 
# 19347 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                      ((void *)0)
# 19347 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                          ) xmlFreeNs(ret_val);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlNsPtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyNamespace",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCopyNamespaceList(void) {
    int test_ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlNsPtr cur;
    int n_cur;

    for (n_cur = 0;n_cur < 2;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNsPtr(n_cur, 0);

        ret_val = xmlCopyNamespaceList(cur);
        if (ret_val != 
# 19380 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                      ((void *)0)
# 19380 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                          ) xmlFreeNsList(ret_val);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlNsPtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyNamespaceList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCopyNode(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr node;
    int n_node;
    int extended;
    int n_extended;

    for (n_node = 0;n_node < 1;n_node++) {
    for (n_extended = 0;n_extended < 4;n_extended++) {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNodePtr(n_node, 0);
        extended = gen_int(n_extended, 1);

        ret_val = xmlCopyNode((const xmlNodePtr)node, extended);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlNodePtr(n_node, (const xmlNodePtr)node, 0);
        des_int(n_extended, extended, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_extended);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCopyNodeList(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 1;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNodePtr(n_node, 0);

        ret_val = xmlCopyNodeList((const xmlNodePtr)node);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlNodePtr(n_node, (const xmlNodePtr)node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyNodeList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCopyProp(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr target;
    int n_target;
    xmlAttrPtr cur;
    int n_cur;

    for (n_target = 0;n_target < 3;n_target++) {
    for (n_cur = 0;n_cur < 2;n_cur++) {
        mem_base = xmlMemBlocks();
        target = gen_xmlNodePtr(n_target, 0);
        cur = gen_xmlAttrPtr(n_cur, 1);

        ret_val = xmlCopyProp(target, cur);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_target, target, 0);
        des_xmlAttrPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_target);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCopyPropList(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr target;
    int n_target;
    xmlAttrPtr cur;
    int n_cur;

    for (n_target = 0;n_target < 3;n_target++) {
    for (n_cur = 0;n_cur < 2;n_cur++) {
        mem_base = xmlMemBlocks();
        target = gen_xmlNodePtr(n_target, 0);
        cur = gen_xmlAttrPtr(n_cur, 1);

        ret_val = xmlCopyPropList(target, cur);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_target, target, 0);
        des_xmlAttrPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyPropList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_target);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCreateIntSubset(void) {
    int test_ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;
    xmlChar * ExternalID;
    int n_ExternalID;
    xmlChar * SystemID;
    int n_SystemID;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < 5;n_SystemID++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);

        ret_val = xmlCreateIntSubset(doc, (const xmlChar *)name, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 2);
        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCreateIntSubset",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}



static xmlDOMWrapCtxtPtr gen_xmlDOMWrapCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 19603 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 19603 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlDOMWrapCtxtPtr(int no __attribute__((unused)), xmlDOMWrapCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlDOMWrapAdoptNode(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDOMWrapCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr sourceDoc;
    int n_sourceDoc;
    xmlNodePtr node;
    int n_node;
    xmlDocPtr destDoc;
    int n_destDoc;
    xmlNodePtr destParent;
    int n_destParent;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_sourceDoc = 0;n_sourceDoc < 4;n_sourceDoc++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_destDoc = 0;n_destDoc < 4;n_destDoc++) {
    for (n_destParent = 0;n_destParent < 3;n_destParent++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlDOMWrapCtxtPtr(n_ctxt, 0);
        sourceDoc = gen_xmlDocPtr(n_sourceDoc, 1);
        node = gen_xmlNodePtr(n_node, 2);
        destDoc = gen_xmlDocPtr(n_destDoc, 3);
        destParent = gen_xmlNodePtr(n_destParent, 4);
        options = gen_int(n_options, 5);

        ret_val = xmlDOMWrapAdoptNode(ctxt, sourceDoc, node, destDoc, destParent, options);
        if ((node != 
# 19642 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                    ((void *)0)
# 19642 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                        ) && (node->parent == 
# 19642 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                              ((void *)0)
# 19642 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                  )) {xmlUnlinkNode(node);xmlFreeNode(node);node = 
# 19642 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                                                   ((void *)0)
# 19642 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                                                       ;}
        desret_int(ret_val);
        call_tests++;
        des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_sourceDoc, sourceDoc, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlDocPtr(n_destDoc, destDoc, 3);
        des_xmlNodePtr(n_destParent, destParent, 4);
        des_int(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDOMWrapAdoptNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_sourceDoc);
            printf(" %d", n_node);
            printf(" %d", n_destDoc);
            printf(" %d", n_destParent);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDOMWrapCloneNode(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDOMWrapCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr sourceDoc;
    int n_sourceDoc;
    xmlNodePtr node;
    int n_node;
    xmlNodePtr * resNode;
    int n_resNode;
    xmlDocPtr destDoc;
    int n_destDoc;
    xmlNodePtr destParent;
    int n_destParent;
    int deep;
    int n_deep;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_sourceDoc = 0;n_sourceDoc < 4;n_sourceDoc++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_resNode = 0;n_resNode < 1;n_resNode++) {
    for (n_destDoc = 0;n_destDoc < 4;n_destDoc++) {
    for (n_destParent = 0;n_destParent < 3;n_destParent++) {
    for (n_deep = 0;n_deep < 4;n_deep++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlDOMWrapCtxtPtr(n_ctxt, 0);
        sourceDoc = gen_xmlDocPtr(n_sourceDoc, 1);
        node = gen_xmlNodePtr(n_node, 2);
        resNode = gen_xmlNodePtr_ptr(n_resNode, 3);
        destDoc = gen_xmlDocPtr(n_destDoc, 4);
        destParent = gen_xmlNodePtr(n_destParent, 5);
        deep = gen_int(n_deep, 6);
        options = gen_int(n_options, 7);

        ret_val = xmlDOMWrapCloneNode(ctxt, sourceDoc, node, resNode, destDoc, destParent, deep, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_sourceDoc, sourceDoc, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_xmlNodePtr_ptr(n_resNode, resNode, 3);
        des_xmlDocPtr(n_destDoc, destDoc, 4);
        des_xmlNodePtr(n_destParent, destParent, 5);
        des_int(n_deep, deep, 6);
        des_int(n_options, options, 7);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDOMWrapCloneNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_sourceDoc);
            printf(" %d", n_node);
            printf(" %d", n_resNode);
            printf(" %d", n_destDoc);
            printf(" %d", n_destParent);
            printf(" %d", n_deep);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDOMWrapNewCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlDOMWrapReconcileNamespaces(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDOMWrapCtxtPtr ctxt;
    int n_ctxt;
    xmlNodePtr elem;
    int n_elem;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlDOMWrapCtxtPtr(n_ctxt, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        options = gen_int(n_options, 2);

        ret_val = xmlDOMWrapReconcileNamespaces(ctxt, elem, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_int(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDOMWrapReconcileNamespaces",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_elem);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDOMWrapRemoveNode(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDOMWrapCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr node;
    int n_node;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlDOMWrapCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        node = gen_xmlNodePtr(n_node, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlDOMWrapRemoveNode(ctxt, doc, node, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlDOMWrapCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_node, node, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDOMWrapRemoveNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_node);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDocCopyNode(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr node;
    int n_node;
    xmlDocPtr doc;
    int n_doc;
    int extended;
    int n_extended;

    for (n_node = 0;n_node < 1;n_node++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_extended = 0;n_extended < 4;n_extended++) {
        mem_base = xmlMemBlocks();
        node = gen_const_xmlNodePtr(n_node, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        extended = gen_int(n_extended, 2);

        ret_val = xmlDocCopyNode((const xmlNodePtr)node, doc, extended);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlNodePtr(n_node, (const xmlNodePtr)node, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_int(n_extended, extended, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocCopyNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_doc);
            printf(" %d", n_extended);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDocCopyNodeList(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr node;
    int n_node;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_node = 0;n_node < 1;n_node++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        node = gen_const_xmlNodePtr(n_node, 1);

        ret_val = xmlDocCopyNodeList(doc, (const xmlNodePtr)node);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlNodePtr(n_node, (const xmlNodePtr)node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocCopyNodeList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDocDump(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    FILE * f;
    int n_f;
    xmlDocPtr cur;
    int n_cur;

    for (n_f = 0;n_f < 2;n_f++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = xmlDocDump(f, cur);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_f);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDocDumpFormatMemory(void) {
    int test_ret = 0;


    int mem_base;
    xmlDocPtr cur;
    int n_cur;
    xmlChar ** mem;
    int n_mem;
    int * size;
    int n_size;
    int format;
    int n_format;

    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_mem = 0;n_mem < 1;n_mem++) {
    for (n_size = 0;n_size < 2;n_size++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlDocPtr(n_cur, 0);
        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
        size = gen_int_ptr(n_size, 2);
        format = gen_int(n_format, 3);

        xmlDocDumpFormatMemory(cur, mem, size, format);
        call_tests++;
        des_xmlDocPtr(n_cur, cur, 0);
        des_xmlChar_ptr_ptr(n_mem, mem, 1);
        des_int_ptr(n_size, size, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDumpFormatMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDocDumpFormatMemoryEnc(void) {
    int test_ret = 0;


    int mem_base;
    xmlDocPtr out_doc;
    int n_out_doc;
    xmlChar ** doc_txt_ptr;
    int n_doc_txt_ptr;
    int * doc_txt_len;
    int n_doc_txt_len;
    char * txt_encoding;
    int n_txt_encoding;
    int format;
    int n_format;

    for (n_out_doc = 0;n_out_doc < 4;n_out_doc++) {
    for (n_doc_txt_ptr = 0;n_doc_txt_ptr < 1;n_doc_txt_ptr++) {
    for (n_doc_txt_len = 0;n_doc_txt_len < 2;n_doc_txt_len++) {
    for (n_txt_encoding = 0;n_txt_encoding < 4;n_txt_encoding++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        out_doc = gen_xmlDocPtr(n_out_doc, 0);
        doc_txt_ptr = gen_xmlChar_ptr_ptr(n_doc_txt_ptr, 1);
        doc_txt_len = gen_int_ptr(n_doc_txt_len, 2);
        txt_encoding = gen_const_char_ptr(n_txt_encoding, 3);
        format = gen_int(n_format, 4);

        xmlDocDumpFormatMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len, (const char *)txt_encoding, format);
        call_tests++;
        des_xmlDocPtr(n_out_doc, out_doc, 0);
        des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr, 1);
        des_int_ptr(n_doc_txt_len, doc_txt_len, 2);
        des_const_char_ptr(n_txt_encoding, (const char *)txt_encoding, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDumpFormatMemoryEnc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out_doc);
            printf(" %d", n_doc_txt_ptr);
            printf(" %d", n_doc_txt_len);
            printf(" %d", n_txt_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDocDumpMemory(void) {
    int test_ret = 0;


    int mem_base;
    xmlDocPtr cur;
    int n_cur;
    xmlChar ** mem;
    int n_mem;
    int * size;
    int n_size;

    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_mem = 0;n_mem < 1;n_mem++) {
    for (n_size = 0;n_size < 2;n_size++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlDocPtr(n_cur, 0);
        mem = gen_xmlChar_ptr_ptr(n_mem, 1);
        size = gen_int_ptr(n_size, 2);

        xmlDocDumpMemory(cur, mem, size);
        call_tests++;
        des_xmlDocPtr(n_cur, cur, 0);
        des_xmlChar_ptr_ptr(n_mem, mem, 1);
        des_int_ptr(n_size, size, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDumpMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDocDumpMemoryEnc(void) {
    int test_ret = 0;


    int mem_base;
    xmlDocPtr out_doc;
    int n_out_doc;
    xmlChar ** doc_txt_ptr;
    int n_doc_txt_ptr;
    int * doc_txt_len;
    int n_doc_txt_len;
    char * txt_encoding;
    int n_txt_encoding;

    for (n_out_doc = 0;n_out_doc < 4;n_out_doc++) {
    for (n_doc_txt_ptr = 0;n_doc_txt_ptr < 1;n_doc_txt_ptr++) {
    for (n_doc_txt_len = 0;n_doc_txt_len < 2;n_doc_txt_len++) {
    for (n_txt_encoding = 0;n_txt_encoding < 4;n_txt_encoding++) {
        mem_base = xmlMemBlocks();
        out_doc = gen_xmlDocPtr(n_out_doc, 0);
        doc_txt_ptr = gen_xmlChar_ptr_ptr(n_doc_txt_ptr, 1);
        doc_txt_len = gen_int_ptr(n_doc_txt_len, 2);
        txt_encoding = gen_const_char_ptr(n_txt_encoding, 3);

        xmlDocDumpMemoryEnc(out_doc, doc_txt_ptr, doc_txt_len, (const char *)txt_encoding);
        call_tests++;
        des_xmlDocPtr(n_out_doc, out_doc, 0);
        des_xmlChar_ptr_ptr(n_doc_txt_ptr, doc_txt_ptr, 1);
        des_int_ptr(n_doc_txt_len, doc_txt_len, 2);
        des_const_char_ptr(n_txt_encoding, (const char *)txt_encoding, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocDumpMemoryEnc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out_doc);
            printf(" %d", n_doc_txt_ptr);
            printf(" %d", n_doc_txt_len);
            printf(" %d", n_txt_encoding);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDocFormatDump(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    FILE * f;
    int n_f;
    xmlDocPtr cur;
    int n_cur;
    int format;
    int n_format;

    for (n_f = 0;n_f < 2;n_f++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        format = gen_int(n_format, 2);

        ret_val = xmlDocFormatDump(f, cur, format);
        desret_int(ret_val);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_int(n_format, format, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocFormatDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_f);
            printf(" %d", n_cur);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDocGetRootElement(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlDocGetRootElement(doc);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocGetRootElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlDocSetRootElement(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr root;
    int n_root;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_root = 0;n_root < 3;n_root++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        root = gen_xmlNodePtr_in(n_root, 1);

        ret_val = xmlDocSetRootElement(doc, root);
        if (doc == 
# 20303 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                  ((void *)0)
# 20303 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                      ) { xmlFreeNode(root) ; root = 
# 20303 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                     ((void *)0) 
# 20303 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                          ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr_in(n_root, root, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDocSetRootElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_root);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlElemDump(void) {
    int test_ret = 0;


    int mem_base;
    FILE * f;
    int n_f;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr cur;
    int n_cur;

    for (n_f = 0;n_f < 2;n_f++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        f = gen_FILE_ptr(n_f, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);

        xmlElemDump(f, doc, cur);
        call_tests++;
        des_FILE_ptr(n_f, f, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlElemDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_f);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlFirstElementChild(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent;
    int n_parent;

    for (n_parent = 0;n_parent < 3;n_parent++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);

        ret_val = xmlFirstElementChild(parent);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFirstElementChild",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlGetBufferAllocationScheme(void) {
    int test_ret = 0;

    int mem_base;
    xmlBufferAllocationScheme ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlGetBufferAllocationScheme();
        desret_xmlBufferAllocationScheme(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetBufferAllocationScheme",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetCompressMode(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlGetCompressMode();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetCompressMode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetDocCompressMode(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlGetDocCompressMode(doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDocCompressMode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetIntSubset(void) {
    int test_ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlGetIntSubset(doc);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetIntSubset",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetLastChild(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent;
    int n_parent;

    for (n_parent = 0;n_parent < 3;n_parent++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);

        ret_val = xmlGetLastChild(parent);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetLastChild",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetLineNo(void) {
    int test_ret = 0;

    int mem_base;
    long ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlGetLineNo(node);
        desret_long(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetLineNo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetNoNsProp(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * name;
    int n_name;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetNoNsProp(node, (const xmlChar *)name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNoNsProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetNodePath(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlGetNodePath(node);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNodePath",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlGetNsList(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlGetNsProp(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * name;
    int n_name;
    xmlChar * nameSpace;
    int n_nameSpace;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_nameSpace = 0;n_nameSpace < 5;n_nameSpace++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);

        ret_val = xmlGetNsProp(node, (const xmlChar *)name, (const xmlChar *)nameSpace);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_nameSpace, (const xmlChar *)nameSpace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetNsProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_nameSpace);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetProp(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * name;
    int n_name;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetProp(node, (const xmlChar *)name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHasNsProp(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * name;
    int n_name;
    xmlChar * nameSpace;
    int n_nameSpace;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_nameSpace = 0;n_nameSpace < 5;n_nameSpace++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);

        ret_val = xmlHasNsProp(node, (const xmlChar *)name, (const xmlChar *)nameSpace);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_nameSpace, (const xmlChar *)nameSpace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHasNsProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_nameSpace);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlHasProp(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * name;
    int n_name;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlHasProp(node, (const xmlChar *)name);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlHasProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsBlankNode(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlIsBlankNode(node);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsBlankNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsXHTML(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * systemID;
    int n_systemID;
    xmlChar * publicID;
    int n_publicID;

    for (n_systemID = 0;n_systemID < 5;n_systemID++) {
    for (n_publicID = 0;n_publicID < 5;n_publicID++) {
        mem_base = xmlMemBlocks();
        systemID = gen_const_xmlChar_ptr(n_systemID, 0);
        publicID = gen_const_xmlChar_ptr(n_publicID, 1);

        ret_val = xmlIsXHTML((const xmlChar *)systemID, (const xmlChar *)publicID);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_systemID, (const xmlChar *)systemID, 0);
        des_const_xmlChar_ptr(n_publicID, (const xmlChar *)publicID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsXHTML",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_systemID);
            printf(" %d", n_publicID);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlLastElementChild(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent;
    int n_parent;

    for (n_parent = 0;n_parent < 3;n_parent++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);

        ret_val = xmlLastElementChild(parent);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlLastElementChild",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNewCDataBlock(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * content;
    int n_content;
    int len;
    int n_len;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_content = 0;n_content < 5;n_content++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNewCDataBlock(doc, (const xmlChar *)content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewCDataBlock",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewCharRef(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlNewCharRef(doc, (const xmlChar *)name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewCharRef",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewChild(void) {
    int test_ret = 0;



    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent;
    int n_parent;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_parent = 0;n_parent < 3;n_parent++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewChild(parent, ns, (const xmlChar *)name, (const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewChild",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlNewComment(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlChar * content;
    int n_content;

    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0);

        ret_val = xmlNewComment((const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewComment",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_content);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDoc(void) {
    int test_ret = 0;

    int mem_base;
    xmlDocPtr ret_val;
    xmlChar * version;
    int n_version;

    for (n_version = 0;n_version < 5;n_version++) {
        mem_base = xmlMemBlocks();
        version = gen_const_xmlChar_ptr(n_version, 0);

        ret_val = xmlNewDoc((const xmlChar *)version);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_version, (const xmlChar *)version, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_version);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDocComment(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * content;
    int n_content;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlNewDocComment(doc, (const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocComment",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDocFragment(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlNewDocFragment(doc);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocFragment",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNewDocNode(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewDocNode(doc, ns, (const xmlChar *)name, (const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDocNodeEatName(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 2;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_eaten_name(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewDocNodeEatName(doc, ns, name, (const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_eaten_name(n_name, name, 2);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocNodeEatName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDocPI(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlNewDocPI(doc, (const xmlChar *)name, (const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocPI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDocProp(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;
    xmlChar * value;
    int n_value;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);

        ret_val = xmlNewDocProp(doc, (const xmlChar *)name, (const xmlChar *)value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDocRawNode(void) {
    int test_ret = 0;



    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewDocRawNode(doc, ns, (const xmlChar *)name, (const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocRawNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlNewDocText(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * content;
    int n_content;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlNewDocText(doc, (const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocText",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDocTextLen(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * content;
    int n_content;
    int len;
    int n_len;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_content = 0;n_content < 5;n_content++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlNewDocTextLen(doc, (const xmlChar *)content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocTextLen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDtd(void) {
    int test_ret = 0;

    int mem_base;
    xmlDtdPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;
    xmlChar * ExternalID;
    int n_ExternalID;
    xmlChar * SystemID;
    int n_SystemID;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ExternalID = 0;n_ExternalID < 5;n_ExternalID++) {
    for (n_SystemID = 0;n_SystemID < 5;n_SystemID++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ExternalID = gen_const_xmlChar_ptr(n_ExternalID, 2);
        SystemID = gen_const_xmlChar_ptr(n_SystemID, 3);

        ret_val = xmlNewDtd(doc, (const xmlChar *)name, (const xmlChar *)ExternalID, (const xmlChar *)SystemID);
        desret_xmlDtdPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_ExternalID, (const xmlChar *)ExternalID, 2);
        des_const_xmlChar_ptr(n_SystemID, (const xmlChar *)SystemID, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDtd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_ExternalID);
            printf(" %d", n_SystemID);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewNode(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;

    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNsPtr(n_ns, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlNewNode(ns, (const xmlChar *)name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNsPtr(n_ns, ns, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewNodeEatName(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;

    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 2;n_name++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNsPtr(n_ns, 0);
        name = gen_eaten_name(n_name, 1);

        ret_val = xmlNewNodeEatName(ns, name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNsPtr(n_ns, ns, 0);
        des_eaten_name(n_name, name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNodeEatName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewNs(void) {
    int test_ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * href;
    int n_href;
    xmlChar * prefix;
    int n_prefix;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_href = 0;n_href < 5;n_href++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        href = gen_const_xmlChar_ptr(n_href, 1);
        prefix = gen_const_xmlChar_ptr(n_prefix, 2);

        ret_val = xmlNewNs(node, (const xmlChar *)href, (const xmlChar *)prefix);
        if ((node == 
# 21714 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                    ((void *)0)
# 21714 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                        ) && (ret_val != 
# 21714 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                         ((void *)0)
# 21714 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                             )) xmlFreeNs(ret_val);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_href, (const xmlChar *)href, 1);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_href);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewNsProp(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node;
    int n_node;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;
    xmlChar * value;
    int n_value;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);

        ret_val = xmlNewNsProp(node, ns, (const xmlChar *)name, (const xmlChar *)value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNsProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewNsPropEatName(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node;
    int n_node;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;
    xmlChar * value;
    int n_value;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 2;n_name++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_eaten_name(n_name, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);

        ret_val = xmlNewNsPropEatName(node, ns, name, (const xmlChar *)value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_eaten_name(n_name, name, 2);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewNsPropEatName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewPI(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlNewPI((const xmlChar *)name, (const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewPI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewProp(void) {
    int test_ret = 0;



    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * name;
    int n_name;
    xmlChar * value;
    int n_value;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);

        ret_val = xmlNewProp(node, (const xmlChar *)name, (const xmlChar *)value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlNewReference(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlNewReference(doc, (const xmlChar *)name);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewReference",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewText(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlChar * content;
    int n_content;

    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0);

        ret_val = xmlNewText((const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewText",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_content);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewTextChild(void) {
    int test_ret = 0;



    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr parent;
    int n_parent;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_parent = 0;n_parent < 3;n_parent++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        parent = gen_xmlNodePtr(n_parent, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlNewTextChild(parent, ns, (const xmlChar *)name, (const xmlChar *)content);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_parent, parent, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextChild",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_parent);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlNewTextLen(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlChar * content;
    int n_content;
    int len;
    int n_len;

    for (n_content = 0;n_content < 5;n_content++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        content = gen_const_xmlChar_ptr(n_content, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlNewTextLen((const xmlChar *)content, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextLen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNextElementSibling(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlNextElementSibling(node);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNextElementSibling",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNodeAddContent(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr cur;
    int n_cur;
    xmlChar * content;
    int n_content;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        xmlNodeAddContent(cur, (const xmlChar *)content);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeAddContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeAddContentLen(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr cur;
    int n_cur;
    xmlChar * content;
    int n_content;
    int len;
    int n_len;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_content = 0;n_content < 5;n_content++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        xmlNodeAddContentLen(cur, (const xmlChar *)content, len);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeAddContentLen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeBufGetContent(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlBufferPtr buffer;
    int n_buffer;
    xmlNodePtr cur;
    int n_cur;

    for (n_buffer = 0;n_buffer < 3;n_buffer++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        buffer = gen_xmlBufferPtr(n_buffer, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlNodeBufGetContent(buffer, cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buffer, buffer, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeBufGetContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeDump(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlBufferPtr buf;
    int n_buf;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr cur;
    int n_cur;
    int level;
    int n_level;
    int format;
    int n_format;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_level = 0;n_level < 4;n_level++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        level = gen_int(n_level, 3);
        format = gen_int(n_format, 4);

        ret_val = xmlNodeDump(buf, doc, cur, level, format);
        desret_int(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_int(n_level, level, 3);
        des_int(n_format, format, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_level);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNodeDumpOutput(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr buf;
    int n_buf;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr cur;
    int n_cur;
    int level;
    int n_level;
    int format;
    int n_format;
    char * encoding;
    int n_encoding;

    for (n_buf = 0;n_buf < 2;n_buf++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_level = 0;n_level < 4;n_level++) {
    for (n_format = 0;n_format < 4;n_format++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        cur = gen_xmlNodePtr(n_cur, 2);
        level = gen_int(n_level, 3);
        format = gen_int(n_format, 4);
        encoding = gen_const_char_ptr(n_encoding, 5);

        xmlNodeDumpOutput(buf, doc, cur, level, format, (const char *)encoding);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_cur, cur, 2);
        des_int(n_level, level, 3);
        des_int(n_format, format, 4);
        des_const_char_ptr(n_encoding, (const char *)encoding, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeDumpOutput",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf(" %d", n_level);
            printf(" %d", n_format);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNodeGetBase(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr cur;
    int n_cur;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlNodeGetBase(doc, cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetBase",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeGetContent(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr cur;
    int n_cur;

    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);

        ret_val = xmlNodeGetContent(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeGetLang(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr cur;
    int n_cur;

    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);

        ret_val = xmlNodeGetLang(cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetLang",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeGetSpacePreserve(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr cur;
    int n_cur;

    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);

        ret_val = xmlNodeGetSpacePreserve(cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeGetSpacePreserve",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeIsText(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlNodeIsText(node);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeIsText",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeListGetRawString(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr list;
    int n_list;
    int inLine;
    int n_inLine;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_list = 0;n_list < 3;n_list++) {
    for (n_inLine = 0;n_inLine < 4;n_inLine++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        list = gen_xmlNodePtr(n_list, 1);
        inLine = gen_int(n_inLine, 2);

        ret_val = xmlNodeListGetRawString(doc, list, inLine);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_list, list, 1);
        des_int(n_inLine, inLine, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeListGetRawString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_list);
            printf(" %d", n_inLine);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNodeListGetString(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr list;
    int n_list;
    int inLine;
    int n_inLine;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_list = 0;n_list < 3;n_list++) {
    for (n_inLine = 0;n_inLine < 4;n_inLine++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        list = gen_xmlNodePtr(n_list, 1);
        inLine = gen_int(n_inLine, 2);

        ret_val = xmlNodeListGetString(doc, list, inLine);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_list, list, 1);
        des_int(n_inLine, inLine, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeListGetString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_list);
            printf(" %d", n_inLine);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeSetBase(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr cur;
    int n_cur;
    xmlChar * uri;
    int n_uri;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_uri = 0;n_uri < 5;n_uri++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        uri = gen_const_xmlChar_ptr(n_uri, 1);

        xmlNodeSetBase(cur, (const xmlChar *)uri);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_uri, (const xmlChar *)uri, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetBase",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_uri);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNodeSetContent(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr cur;
    int n_cur;
    xmlChar * content;
    int n_content;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        xmlNodeSetContent(cur, (const xmlChar *)content);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNodeSetContentLen(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr cur;
    int n_cur;
    xmlChar * content;
    int n_content;
    int len;
    int n_len;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_content = 0;n_content < 5;n_content++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        xmlNodeSetContentLen(cur, (const xmlChar *)content, len);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetContentLen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNodeSetLang(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr cur;
    int n_cur;
    xmlChar * lang;
    int n_lang;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_lang = 0;n_lang < 5;n_lang++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        lang = gen_const_xmlChar_ptr(n_lang, 1);

        xmlNodeSetLang(cur, (const xmlChar *)lang);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_lang, (const xmlChar *)lang, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetLang",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_lang);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNodeSetName(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr cur;
    int n_cur;
    xmlChar * name;
    int n_name;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        xmlNodeSetName(cur, (const xmlChar *)name);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNodeSetSpacePreserve(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr cur;
    int n_cur;
    int val;
    int n_val;

    for (n_cur = 0;n_cur < 3;n_cur++) {
    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodePtr(n_cur, 0);
        val = gen_int(n_val, 1);

        xmlNodeSetSpacePreserve(cur, val);
        call_tests++;
        des_xmlNodePtr(n_cur, cur, 0);
        des_int(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNodeSetSpacePreserve",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlPreviousElementSibling(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlPreviousElementSibling(node);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPreviousElementSibling",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlReconciliateNs(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr tree;
    int n_tree;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_tree = 0;n_tree < 3;n_tree++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        tree = gen_xmlNodePtr(n_tree, 1);

        ret_val = xmlReconciliateNs(doc, tree);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_tree, tree, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReconciliateNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_tree);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlRemoveProp(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlAttrPtr cur;
    int n_cur;

    for (n_cur = 0;n_cur < 2;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlAttrPtr(n_cur, 0);

        ret_val = xmlRemoveProp(cur);
        cur = 
# 22975 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
             ((void *)0)
# 22975 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                 ;
        desret_int(ret_val);
        call_tests++;
        des_xmlAttrPtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRemoveProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlReplaceNode(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr old;
    int n_old;
    xmlNodePtr cur;
    int n_cur;

    for (n_old = 0;n_old < 3;n_old++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        old = gen_xmlNodePtr(n_old, 0);
        cur = gen_xmlNodePtr_in(n_cur, 1);

        ret_val = xmlReplaceNode(old, cur);
        if (cur != 
# 23013 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                  ((void *)0)
# 23013 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                      ) {
              xmlUnlinkNode(cur);
              xmlFreeNode(cur) ; cur = 
# 23015 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                      ((void *)0) 
# 23015 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                           ; }
          if (old != 
# 23016 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                    ((void *)0)
# 23016 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                        ) {
              xmlUnlinkNode(old);
              xmlFreeNode(old) ; old = 
# 23018 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                      ((void *)0) 
# 23018 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                           ; }
   ret_val = 
# 23019 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
            ((void *)0)
# 23019 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                ;
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_old, old, 0);
        des_xmlNodePtr_in(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReplaceNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_old);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSaveFile(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;
    xmlDocPtr cur;
    int n_cur;

    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);

        ret_val = xmlSaveFile(filename, cur);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSaveFileEnc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;
    xmlDocPtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;

    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        ret_val = xmlSaveFileEnc(filename, cur, (const char *)encoding);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFileEnc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSaveFileTo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlOutputBufferPtr buf;
    int n_buf;
    xmlDocPtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;

    for (n_buf = 0;n_buf < 2;n_buf++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);

        ret_val = xmlSaveFileTo(buf, cur, (const char *)encoding);
        buf = 
# 23154 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
             ((void *)0)
# 23154 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                 ;
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFileTo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSaveFormatFile(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;
    xmlDocPtr cur;
    int n_cur;
    int format;
    int n_format;

    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        format = gen_int(n_format, 2);

        ret_val = xmlSaveFormatFile(filename, cur, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_int(n_format, format, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSaveFormatFileEnc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;
    xmlDocPtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;
    int format;
    int n_format;

    for (n_filename = 0;n_filename < 6;n_filename++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        filename = gen_fileoutput(n_filename, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        ret_val = xmlSaveFormatFileEnc(filename, cur, (const char *)encoding, format);
        desret_int(ret_val);
        call_tests++;
        des_fileoutput(n_filename, filename, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFileEnc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSaveFormatFileTo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlOutputBufferPtr buf;
    int n_buf;
    xmlDocPtr cur;
    int n_cur;
    char * encoding;
    int n_encoding;
    int format;
    int n_format;

    for (n_buf = 0;n_buf < 2;n_buf++) {
    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_format = 0;n_format < 4;n_format++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlOutputBufferPtr(n_buf, 0);
        cur = gen_xmlDocPtr(n_cur, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        format = gen_int(n_format, 3);

        ret_val = xmlSaveFormatFileTo(buf, cur, (const char *)encoding, format);
        buf = 
# 23310 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
             ((void *)0)
# 23310 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                 ;
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_buf, buf, 0);
        des_xmlDocPtr(n_cur, cur, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_int(n_format, format, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFormatFileTo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_cur);
            printf(" %d", n_encoding);
            printf(" %d", n_format);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSearchNs(void) {
    int test_ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr node;
    int n_node;
    xmlChar * nameSpace;
    int n_nameSpace;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_nameSpace = 0;n_nameSpace < 5;n_nameSpace++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        node = gen_xmlNodePtr(n_node, 1);
        nameSpace = gen_const_xmlChar_ptr(n_nameSpace, 2);

        ret_val = xmlSearchNs(doc, node, (const xmlChar *)nameSpace);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_const_xmlChar_ptr(n_nameSpace, (const xmlChar *)nameSpace, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSearchNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_node);
            printf(" %d", n_nameSpace);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSearchNsByHref(void) {
    int test_ret = 0;

    int mem_base;
    xmlNsPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr node;
    int n_node;
    xmlChar * href;
    int n_href;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_href = 0;n_href < 5;n_href++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        node = gen_xmlNodePtr(n_node, 1);
        href = gen_const_xmlChar_ptr(n_href, 2);

        ret_val = xmlSearchNsByHref(doc, node, (const xmlChar *)href);
        desret_xmlNsPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_const_xmlChar_ptr(n_href, (const xmlChar *)href, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSearchNsByHref",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_node);
            printf(" %d", n_href);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSetBufferAllocationScheme(void) {
    int test_ret = 0;

    int mem_base;
    xmlBufferAllocationScheme scheme;
    int n_scheme;

    for (n_scheme = 0;n_scheme < 4;n_scheme++) {
        mem_base = xmlMemBlocks();
        scheme = gen_xmlBufferAllocationScheme(n_scheme, 0);

        xmlSetBufferAllocationScheme(scheme);
        call_tests++;
        des_xmlBufferAllocationScheme(n_scheme, scheme, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetBufferAllocationScheme",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_scheme);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSetCompressMode(void) {
    int test_ret = 0;

    int mem_base;
    int mode;
    int n_mode;

    for (n_mode = 0;n_mode < 4;n_mode++) {
        mem_base = xmlMemBlocks();
        mode = gen_int(n_mode, 0);

        xmlSetCompressMode(mode);
        call_tests++;
        des_int(n_mode, mode, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetCompressMode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_mode);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSetDocCompressMode(void) {
    int test_ret = 0;

    int mem_base;
    xmlDocPtr doc;
    int n_doc;
    int mode;
    int n_mode;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_mode = 0;n_mode < 4;n_mode++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        mode = gen_int(n_mode, 1);

        xmlSetDocCompressMode(doc, mode);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_mode, mode, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetDocCompressMode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_mode);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSetNs(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr node;
    int n_node;
    xmlNsPtr ns;
    int n_ns;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);

        xmlSetNs(node, ns);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSetNsProp(void) {
    int test_ret = 0;


    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node;
    int n_node;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;
    xmlChar * value;
    int n_value;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);

        ret_val = xmlSetNsProp(node, ns, (const xmlChar *)name, (const xmlChar *)value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetNsProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSetProp(void) {
    int test_ret = 0;


    int mem_base;
    xmlAttrPtr ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * name;
    int n_name;
    xmlChar * value;
    int n_value;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);

        ret_val = xmlSetProp(node, (const xmlChar *)name, (const xmlChar *)value);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSetProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSplitQName2(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * name;
    int n_name;
    xmlChar ** prefix;
    int n_prefix;

    for (n_name = 0;n_name < 5;n_name++) {
    for (n_prefix = 0;n_prefix < 1;n_prefix++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        prefix = gen_xmlChar_ptr_ptr(n_prefix, 1);

        ret_val = xmlSplitQName2((const xmlChar *)name, prefix);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        des_xmlChar_ptr_ptr(n_prefix, prefix, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSplitQName2",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSplitQName3(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlChar * name;
    int n_name;
    int * len;
    int n_len;

    for (n_name = 0;n_name < 5;n_name++) {
    for (n_len = 0;n_len < 2;n_len++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        len = gen_int_ptr(n_len, 1);

        ret_val = xmlSplitQName3((const xmlChar *)name, len);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        des_int_ptr(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSplitQName3",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStringGetNodeList(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * value;
    int n_value;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);

        ret_val = xmlStringGetNodeList(doc, (const xmlChar *)value);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringGetNodeList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStringLenGetNodeList(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * value;
    int n_value;
    int len;
    int n_len;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStringLenGetNodeList(doc, (const xmlChar *)value, len);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStringLenGetNodeList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_value);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlTextConcat(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * content;
    int n_content;
    int len;
    int n_len;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_content = 0;n_content < 5;n_content++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlTextConcat(node, (const xmlChar *)content, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextConcat",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlTextMerge(void) {
    int test_ret = 0;

    int mem_base;
    xmlNodePtr ret_val;
    xmlNodePtr first;
    int n_first;
    xmlNodePtr second;
    int n_second;

    for (n_first = 0;n_first < 3;n_first++) {
    for (n_second = 0;n_second < 3;n_second++) {
        mem_base = xmlMemBlocks();
        first = gen_xmlNodePtr_in(n_first, 0);
        second = gen_xmlNodePtr_in(n_second, 1);

        ret_val = xmlTextMerge(first, second);
        if ((first != 
# 23895 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                     ((void *)0)
# 23895 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                         ) && (first->type != XML_TEXT_NODE)) {
              xmlUnlinkNode(second);
              xmlFreeNode(second) ; second = 
# 23897 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                            ((void *)0) 
# 23897 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                 ; }
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlNodePtr_in(n_first, first, 0);
        des_xmlNodePtr_in(n_second, second, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextMerge",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_first);
            printf(" %d", n_second);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlUnsetNsProp(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodePtr node;
    int n_node;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * name;
    int n_name;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        ns = gen_xmlNsPtr(n_ns, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlUnsetNsProp(node, ns, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_xmlNsPtr(n_ns, ns, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUnsetNsProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUnsetProp(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodePtr node;
    int n_node;
    xmlChar * name;
    int n_name;

    for (n_node = 0;n_node < 3;n_node++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlUnsetProp(node, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUnsetProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateNCName(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlChar * value;
    int n_value;
    int space;
    int n_space;

    for (n_value = 0;n_value < 5;n_value++) {
    for (n_space = 0;n_space < 4;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateNCName((const xmlChar *)value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNCName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlValidateNMToken(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlChar * value;
    int n_value;
    int space;
    int n_space;

    for (n_value = 0;n_value < 5;n_value++) {
    for (n_space = 0;n_space < 4;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateNMToken((const xmlChar *)value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNMToken",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlValidateName(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlChar * value;
    int n_value;
    int space;
    int n_space;

    for (n_value = 0;n_value < 5;n_value++) {
    for (n_space = 0;n_space < 4;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateName((const xmlChar *)value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlValidateQName(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlChar * value;
    int n_value;
    int space;
    int n_space;

    for (n_value = 0;n_value < 5;n_value++) {
    for (n_space = 0;n_space < 4;n_space++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);
        space = gen_int(n_space, 1);

        ret_val = xmlValidateQName((const xmlChar *)value, space);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        des_int(n_space, space, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateQName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf(" %d", n_space);
            printf("\n");
        }
    }
    }
    function_tests++;



    return(test_ret);
}

static int
test_tree(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing tree : 142 of 164 functions ...\n");
    test_ret += test_xmlAddChild();
    test_ret += test_xmlAddChildList();
    test_ret += test_xmlAddNextSibling();
    test_ret += test_xmlAddPrevSibling();
    test_ret += test_xmlAddSibling();
    test_ret += test_xmlAttrSerializeTxtContent();
    test_ret += test_xmlBufContent();
    test_ret += test_xmlBufEnd();
    test_ret += test_xmlBufGetNodeContent();
    test_ret += test_xmlBufNodeDump();
    test_ret += test_xmlBufShrink();
    test_ret += test_xmlBufUse();
    test_ret += test_xmlBufferAdd();
    test_ret += test_xmlBufferAddHead();
    test_ret += test_xmlBufferCCat();
    test_ret += test_xmlBufferCat();
    test_ret += test_xmlBufferContent();
    test_ret += test_xmlBufferCreate();
    test_ret += test_xmlBufferCreateSize();
    test_ret += test_xmlBufferCreateStatic();
    test_ret += test_xmlBufferDetach();
    test_ret += test_xmlBufferEmpty();
    test_ret += test_xmlBufferGrow();
    test_ret += test_xmlBufferLength();
    test_ret += test_xmlBufferResize();
    test_ret += test_xmlBufferSetAllocationScheme();
    test_ret += test_xmlBufferShrink();
    test_ret += test_xmlBufferWriteCHAR();
    test_ret += test_xmlBufferWriteChar();
    test_ret += test_xmlBufferWriteQuotedString();
    test_ret += test_xmlBuildQName();
    test_ret += test_xmlChildElementCount();
    test_ret += test_xmlCopyDoc();
    test_ret += test_xmlCopyDtd();
    test_ret += test_xmlCopyNamespace();
    test_ret += test_xmlCopyNamespaceList();
    test_ret += test_xmlCopyNode();
    test_ret += test_xmlCopyNodeList();
    test_ret += test_xmlCopyProp();
    test_ret += test_xmlCopyPropList();
    test_ret += test_xmlCreateIntSubset();
    test_ret += test_xmlDOMWrapAdoptNode();
    test_ret += test_xmlDOMWrapCloneNode();
    test_ret += test_xmlDOMWrapNewCtxt();
    test_ret += test_xmlDOMWrapReconcileNamespaces();
    test_ret += test_xmlDOMWrapRemoveNode();
    test_ret += test_xmlDocCopyNode();
    test_ret += test_xmlDocCopyNodeList();
    test_ret += test_xmlDocDump();
    test_ret += test_xmlDocDumpFormatMemory();
    test_ret += test_xmlDocDumpFormatMemoryEnc();
    test_ret += test_xmlDocDumpMemory();
    test_ret += test_xmlDocDumpMemoryEnc();
    test_ret += test_xmlDocFormatDump();
    test_ret += test_xmlDocGetRootElement();
    test_ret += test_xmlDocSetRootElement();
    test_ret += test_xmlElemDump();
    test_ret += test_xmlFirstElementChild();
    test_ret += test_xmlGetBufferAllocationScheme();
    test_ret += test_xmlGetCompressMode();
    test_ret += test_xmlGetDocCompressMode();
    test_ret += test_xmlGetIntSubset();
    test_ret += test_xmlGetLastChild();
    test_ret += test_xmlGetLineNo();
    test_ret += test_xmlGetNoNsProp();
    test_ret += test_xmlGetNodePath();
    test_ret += test_xmlGetNsList();
    test_ret += test_xmlGetNsProp();
    test_ret += test_xmlGetProp();
    test_ret += test_xmlHasNsProp();
    test_ret += test_xmlHasProp();
    test_ret += test_xmlIsBlankNode();
    test_ret += test_xmlIsXHTML();
    test_ret += test_xmlLastElementChild();
    test_ret += test_xmlNewCDataBlock();
    test_ret += test_xmlNewCharRef();
    test_ret += test_xmlNewChild();
    test_ret += test_xmlNewComment();
    test_ret += test_xmlNewDoc();
    test_ret += test_xmlNewDocComment();
    test_ret += test_xmlNewDocFragment();
    test_ret += test_xmlNewDocNode();
    test_ret += test_xmlNewDocNodeEatName();
    test_ret += test_xmlNewDocPI();
    test_ret += test_xmlNewDocProp();
    test_ret += test_xmlNewDocRawNode();
    test_ret += test_xmlNewDocText();
    test_ret += test_xmlNewDocTextLen();
    test_ret += test_xmlNewDtd();
    test_ret += test_xmlNewNode();
    test_ret += test_xmlNewNodeEatName();
    test_ret += test_xmlNewNs();
    test_ret += test_xmlNewNsProp();
    test_ret += test_xmlNewNsPropEatName();
    test_ret += test_xmlNewPI();
    test_ret += test_xmlNewProp();
    test_ret += test_xmlNewReference();
    test_ret += test_xmlNewText();
    test_ret += test_xmlNewTextChild();
    test_ret += test_xmlNewTextLen();
    test_ret += test_xmlNextElementSibling();
    test_ret += test_xmlNodeAddContent();
    test_ret += test_xmlNodeAddContentLen();
    test_ret += test_xmlNodeBufGetContent();
    test_ret += test_xmlNodeDump();
    test_ret += test_xmlNodeDumpOutput();
    test_ret += test_xmlNodeGetBase();
    test_ret += test_xmlNodeGetContent();
    test_ret += test_xmlNodeGetLang();
    test_ret += test_xmlNodeGetSpacePreserve();
    test_ret += test_xmlNodeIsText();
    test_ret += test_xmlNodeListGetRawString();
    test_ret += test_xmlNodeListGetString();
    test_ret += test_xmlNodeSetBase();
    test_ret += test_xmlNodeSetContent();
    test_ret += test_xmlNodeSetContentLen();
    test_ret += test_xmlNodeSetLang();
    test_ret += test_xmlNodeSetName();
    test_ret += test_xmlNodeSetSpacePreserve();
    test_ret += test_xmlPreviousElementSibling();
    test_ret += test_xmlReconciliateNs();
    test_ret += test_xmlRemoveProp();
    test_ret += test_xmlReplaceNode();
    test_ret += test_xmlSaveFile();
    test_ret += test_xmlSaveFileEnc();
    test_ret += test_xmlSaveFileTo();
    test_ret += test_xmlSaveFormatFile();
    test_ret += test_xmlSaveFormatFileEnc();
    test_ret += test_xmlSaveFormatFileTo();
    test_ret += test_xmlSearchNs();
    test_ret += test_xmlSearchNsByHref();
    test_ret += test_xmlSetBufferAllocationScheme();
    test_ret += test_xmlSetCompressMode();
    test_ret += test_xmlSetDocCompressMode();
    test_ret += test_xmlSetNs();
    test_ret += test_xmlSetNsProp();
    test_ret += test_xmlSetProp();
    test_ret += test_xmlSplitQName2();
    test_ret += test_xmlSplitQName3();
    test_ret += test_xmlStringGetNodeList();
    test_ret += test_xmlStringLenGetNodeList();
    test_ret += test_xmlTextConcat();
    test_ret += test_xmlTextMerge();
    test_ret += test_xmlUnsetNsProp();
    test_ret += test_xmlUnsetProp();
    test_ret += test_xmlValidateNCName();
    test_ret += test_xmlValidateNMToken();
    test_ret += test_xmlValidateName();
    test_ret += test_xmlValidateQName();

    if (test_ret != 0)
 printf("Module tree: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlBuildRelativeURI(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * URI;
    int n_URI;
    xmlChar * base;
    int n_base;

    for (n_URI = 0;n_URI < 5;n_URI++) {
    for (n_base = 0;n_base < 5;n_base++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        base = gen_const_xmlChar_ptr(n_base, 1);

        ret_val = xmlBuildRelativeURI((const xmlChar *)URI, (const xmlChar *)base);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
        des_const_xmlChar_ptr(n_base, (const xmlChar *)base, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildRelativeURI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URI);
            printf(" %d", n_base);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlBuildURI(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * URI;
    int n_URI;
    xmlChar * base;
    int n_base;

    for (n_URI = 0;n_URI < 5;n_URI++) {
    for (n_base = 0;n_base < 5;n_base++) {
        mem_base = xmlMemBlocks();
        URI = gen_const_xmlChar_ptr(n_URI, 0);
        base = gen_const_xmlChar_ptr(n_base, 1);

        ret_val = xmlBuildURI((const xmlChar *)URI, (const xmlChar *)base);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_URI, (const xmlChar *)URI, 0);
        des_const_xmlChar_ptr(n_base, (const xmlChar *)base, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlBuildURI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URI);
            printf(" %d", n_base);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCanonicPath(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * path;
    int n_path;

    for (n_path = 0;n_path < 5;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0);

        ret_val = xmlCanonicPath((const xmlChar *)path);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_path, (const xmlChar *)path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCanonicPath",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCreateURI(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlNormalizeURIPath(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    char * path;
    int n_path;

    for (n_path = 0;n_path < 1;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_char_ptr(n_path, 0);

        ret_val = xmlNormalizeURIPath(path);
        desret_int(ret_val);
        call_tests++;
        des_char_ptr(n_path, path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNormalizeURIPath",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParseURI(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlParseURIRaw(void) {
    int test_ret = 0;



    return(test_ret);
}



static xmlURIPtr gen_xmlURIPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 24513 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 24513 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlURIPtr(int no __attribute__((unused)), xmlURIPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlParseURIReference(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlURIPtr uri;
    int n_uri;
    char * str;
    int n_str;

    for (n_uri = 0;n_uri < 1;n_uri++) {
    for (n_str = 0;n_str < 4;n_str++) {
        mem_base = xmlMemBlocks();
        uri = gen_xmlURIPtr(n_uri, 0);
        str = gen_const_char_ptr(n_str, 1);

        ret_val = xmlParseURIReference(uri, (const char *)str);
        desret_int(ret_val);
        call_tests++;
        des_xmlURIPtr(n_uri, uri, 0);
        des_const_char_ptr(n_str, (const char *)str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParseURIReference",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_uri);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlPathToURI(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * path;
    int n_path;

    for (n_path = 0;n_path < 5;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0);

        ret_val = xmlPathToURI((const xmlChar *)path);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_path, (const xmlChar *)path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPathToURI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlPrintURI(void) {
    int test_ret = 0;

    int mem_base;
    FILE * stream;
    int n_stream;
    xmlURIPtr uri;
    int n_uri;

    for (n_stream = 0;n_stream < 2;n_stream++) {
    for (n_uri = 0;n_uri < 1;n_uri++) {
        mem_base = xmlMemBlocks();
        stream = gen_FILE_ptr(n_stream, 0);
        uri = gen_xmlURIPtr(n_uri, 1);

        xmlPrintURI(stream, uri);
        call_tests++;
        des_FILE_ptr(n_stream, stream, 0);
        des_xmlURIPtr(n_uri, uri, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPrintURI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_stream);
            printf(" %d", n_uri);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSaveUri(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlURIPtr uri;
    int n_uri;

    for (n_uri = 0;n_uri < 1;n_uri++) {
        mem_base = xmlMemBlocks();
        uri = gen_xmlURIPtr(n_uri, 0);

        ret_val = xmlSaveUri(uri);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlURIPtr(n_uri, uri, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveUri",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_uri);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlURIEscape(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * str;
    int n_str;

    for (n_str = 0;n_str < 5;n_str++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);

        ret_val = xmlURIEscape((const xmlChar *)str);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlURIEscape",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlURIEscapeStr(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * str;
    int n_str;
    xmlChar * list;
    int n_list;

    for (n_str = 0;n_str < 5;n_str++) {
    for (n_list = 0;n_list < 5;n_list++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        list = gen_const_xmlChar_ptr(n_list, 1);

        ret_val = xmlURIEscapeStr((const xmlChar *)str, (const xmlChar *)list);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        des_const_xmlChar_ptr(n_list, (const xmlChar *)list, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlURIEscapeStr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf(" %d", n_list);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlURIUnescapeString(void) {
    int test_ret = 0;



    return(test_ret);
}

static int
test_uri(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing uri : 10 of 15 functions ...\n");
    test_ret += test_xmlBuildRelativeURI();
    test_ret += test_xmlBuildURI();
    test_ret += test_xmlCanonicPath();
    test_ret += test_xmlCreateURI();
    test_ret += test_xmlNormalizeURIPath();
    test_ret += test_xmlParseURI();
    test_ret += test_xmlParseURIRaw();
    test_ret += test_xmlParseURIReference();
    test_ret += test_xmlPathToURI();
    test_ret += test_xmlPrintURI();
    test_ret += test_xmlSaveUri();
    test_ret += test_xmlURIEscape();
    test_ret += test_xmlURIEscapeStr();
    test_ret += test_xmlURIUnescapeString();

    if (test_ret != 0)
 printf("Module uri: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlAddAttributeDecl(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttributePtr ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDtdPtr dtd;
    int n_dtd;
    xmlChar * elem;
    int n_elem;
    xmlChar * name;
    int n_name;
    xmlChar * ns;
    int n_ns;
    xmlAttributeType type;
    int n_type;
    xmlAttributeDefault def;
    int n_def;
    xmlChar * defaultValue;
    int n_defaultValue;
    xmlEnumerationPtr tree;
    int n_tree;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_dtd = 0;n_dtd < 3;n_dtd++) {
    for (n_elem = 0;n_elem < 5;n_elem++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ns = 0;n_ns < 5;n_ns++) {
    for (n_type = 0;n_type < 4;n_type++) {
    for (n_def = 0;n_def < 4;n_def++) {
    for (n_defaultValue = 0;n_defaultValue < 5;n_defaultValue++) {
    for (n_tree = 0;n_tree < 1;n_tree++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        dtd = gen_xmlDtdPtr(n_dtd, 1);
        elem = gen_const_xmlChar_ptr(n_elem, 2);
        name = gen_const_xmlChar_ptr(n_name, 3);
        ns = gen_const_xmlChar_ptr(n_ns, 4);
        type = gen_xmlAttributeType(n_type, 5);
        def = gen_xmlAttributeDefault(n_def, 6);
        defaultValue = gen_const_xmlChar_ptr(n_defaultValue, 7);
        tree = gen_xmlEnumerationPtr(n_tree, 8);

        ret_val = xmlAddAttributeDecl(ctxt, dtd, (const xmlChar *)elem, (const xmlChar *)name, (const xmlChar *)ns, type, def, (const xmlChar *)defaultValue, tree);
        desret_xmlAttributePtr(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDtdPtr(n_dtd, dtd, 1);
        des_const_xmlChar_ptr(n_elem, (const xmlChar *)elem, 2);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 3);
        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 4);
        des_xmlAttributeType(n_type, type, 5);
        des_xmlAttributeDefault(n_def, def, 6);
        des_const_xmlChar_ptr(n_defaultValue, (const xmlChar *)defaultValue, 7);
        des_xmlEnumerationPtr(n_tree, tree, 8);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddAttributeDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_dtd);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf(" %d", n_ns);
            printf(" %d", n_type);
            printf(" %d", n_def);
            printf(" %d", n_defaultValue);
            printf(" %d", n_tree);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlAddElementDecl(void) {
    int test_ret = 0;

    int mem_base;
    xmlElementPtr ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDtdPtr dtd;
    int n_dtd;
    xmlChar * name;
    int n_name;
    xmlElementTypeVal type;
    int n_type;
    xmlElementContentPtr content;
    int n_content;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_dtd = 0;n_dtd < 3;n_dtd++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_type = 0;n_type < 4;n_type++) {
    for (n_content = 0;n_content < 1;n_content++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        dtd = gen_xmlDtdPtr(n_dtd, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        type = gen_xmlElementTypeVal(n_type, 3);
        content = gen_xmlElementContentPtr(n_content, 4);

        ret_val = xmlAddElementDecl(ctxt, dtd, (const xmlChar *)name, type, content);
        desret_xmlElementPtr(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDtdPtr(n_dtd, dtd, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_xmlElementTypeVal(n_type, type, 3);
        des_xmlElementContentPtr(n_content, content, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAddElementDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_dtd);
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlAddID(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAddNotationDecl(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAddRef(void) {
    int test_ret = 0;



    return(test_ret);
}



static xmlAttributeTablePtr gen_xmlAttributeTablePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 24943 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 24943 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlAttributeTablePtr(int no __attribute__((unused)), xmlAttributeTablePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlCopyAttributeTable(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlCopyDocElementContent(void) {
    int test_ret = 0;

    int mem_base;
    xmlElementContentPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlElementContentPtr cur;
    int n_cur;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_cur = 0;n_cur < 1;n_cur++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        cur = gen_xmlElementContentPtr(n_cur, 1);

        ret_val = xmlCopyDocElementContent(doc, cur);
        desret_xmlElementContentPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlElementContentPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyDocElementContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCopyElementContent(void) {
    int test_ret = 0;

    int mem_base;
    xmlElementContentPtr ret_val;
    xmlElementContentPtr cur;
    int n_cur;

    for (n_cur = 0;n_cur < 1;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlElementContentPtr(n_cur, 0);

        ret_val = xmlCopyElementContent(cur);
        desret_xmlElementContentPtr(ret_val);
        call_tests++;
        des_xmlElementContentPtr(n_cur, cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyElementContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}



static xmlElementTablePtr gen_xmlElementTablePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 25031 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 25031 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlElementTablePtr(int no __attribute__((unused)), xmlElementTablePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlCopyElementTable(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlCopyEnumeration(void) {
    int test_ret = 0;



    return(test_ret);
}



static xmlNotationTablePtr gen_xmlNotationTablePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 25058 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 25058 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlNotationTablePtr(int no __attribute__((unused)), xmlNotationTablePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlCopyNotationTable(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlCreateEnumeration(void) {
    int test_ret = 0;



    return(test_ret);
}



static xmlAttributePtr gen_xmlAttributePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 25085 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 25085 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlAttributePtr(int no __attribute__((unused)), xmlAttributePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlDumpAttributeDecl(void) {
    int test_ret = 0;


    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlAttributePtr attr;
    int n_attr;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_attr = 0;n_attr < 1;n_attr++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        attr = gen_xmlAttributePtr(n_attr, 1);

        xmlDumpAttributeDecl(buf, attr);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlAttributePtr(n_attr, attr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpAttributeDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDumpAttributeTable(void) {
    int test_ret = 0;


    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlAttributeTablePtr table;
    int n_table;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_table = 0;n_table < 1;n_table++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        table = gen_xmlAttributeTablePtr(n_table, 1);

        xmlDumpAttributeTable(buf, table);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlAttributeTablePtr(n_table, table, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpAttributeTable",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_table);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}



static xmlElementPtr gen_xmlElementPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 25170 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 25170 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlElementPtr(int no __attribute__((unused)), xmlElementPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlDumpElementDecl(void) {
    int test_ret = 0;


    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlElementPtr elem;
    int n_elem;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_elem = 0;n_elem < 1;n_elem++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        elem = gen_xmlElementPtr(n_elem, 1);

        xmlDumpElementDecl(buf, elem);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlElementPtr(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpElementDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDumpElementTable(void) {
    int test_ret = 0;


    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlElementTablePtr table;
    int n_table;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_table = 0;n_table < 1;n_table++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        table = gen_xmlElementTablePtr(n_table, 1);

        xmlDumpElementTable(buf, table);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlElementTablePtr(n_table, table, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpElementTable",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_table);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}



static xmlNotationPtr gen_xmlNotationPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 25255 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 25255 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlNotationPtr(int no __attribute__((unused)), xmlNotationPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlDumpNotationDecl(void) {
    int test_ret = 0;


    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlNotationPtr nota;
    int n_nota;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_nota = 0;n_nota < 1;n_nota++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        nota = gen_xmlNotationPtr(n_nota, 1);

        xmlDumpNotationDecl(buf, nota);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlNotationPtr(n_nota, nota, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpNotationDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_nota);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlDumpNotationTable(void) {
    int test_ret = 0;


    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlNotationTablePtr table;
    int n_table;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_table = 0;n_table < 1;n_table++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        table = gen_xmlNotationTablePtr(n_table, 1);

        xmlDumpNotationTable(buf, table);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlNotationTablePtr(n_table, table, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlDumpNotationTable",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_table);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlGetDtdAttrDesc(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttributePtr ret_val;
    xmlDtdPtr dtd;
    int n_dtd;
    xmlChar * elem;
    int n_elem;
    xmlChar * name;
    int n_name;

    for (n_dtd = 0;n_dtd < 3;n_dtd++) {
    for (n_elem = 0;n_elem < 5;n_elem++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        dtd = gen_xmlDtdPtr(n_dtd, 0);
        elem = gen_const_xmlChar_ptr(n_elem, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlGetDtdAttrDesc(dtd, (const xmlChar *)elem, (const xmlChar *)name);
        desret_xmlAttributePtr(ret_val);
        call_tests++;
        des_xmlDtdPtr(n_dtd, dtd, 0);
        des_const_xmlChar_ptr(n_elem, (const xmlChar *)elem, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDtdAttrDesc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dtd);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetDtdElementDesc(void) {
    int test_ret = 0;

    int mem_base;
    xmlElementPtr ret_val;
    xmlDtdPtr dtd;
    int n_dtd;
    xmlChar * name;
    int n_name;

    for (n_dtd = 0;n_dtd < 3;n_dtd++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        dtd = gen_xmlDtdPtr(n_dtd, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlGetDtdElementDesc(dtd, (const xmlChar *)name);
        desret_xmlElementPtr(ret_val);
        call_tests++;
        des_xmlDtdPtr(n_dtd, dtd, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDtdElementDesc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dtd);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetDtdNotationDesc(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlGetDtdQAttrDesc(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttributePtr ret_val;
    xmlDtdPtr dtd;
    int n_dtd;
    xmlChar * elem;
    int n_elem;
    xmlChar * name;
    int n_name;
    xmlChar * prefix;
    int n_prefix;

    for (n_dtd = 0;n_dtd < 3;n_dtd++) {
    for (n_elem = 0;n_elem < 5;n_elem++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
        mem_base = xmlMemBlocks();
        dtd = gen_xmlDtdPtr(n_dtd, 0);
        elem = gen_const_xmlChar_ptr(n_elem, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        prefix = gen_const_xmlChar_ptr(n_prefix, 3);

        ret_val = xmlGetDtdQAttrDesc(dtd, (const xmlChar *)elem, (const xmlChar *)name, (const xmlChar *)prefix);
        desret_xmlAttributePtr(ret_val);
        call_tests++;
        des_xmlDtdPtr(n_dtd, dtd, 0);
        des_const_xmlChar_ptr(n_elem, (const xmlChar *)elem, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDtdQAttrDesc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dtd);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetDtdQElementDesc(void) {
    int test_ret = 0;

    int mem_base;
    xmlElementPtr ret_val;
    xmlDtdPtr dtd;
    int n_dtd;
    xmlChar * name;
    int n_name;
    xmlChar * prefix;
    int n_prefix;

    for (n_dtd = 0;n_dtd < 3;n_dtd++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
        mem_base = xmlMemBlocks();
        dtd = gen_xmlDtdPtr(n_dtd, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        prefix = gen_const_xmlChar_ptr(n_prefix, 2);

        ret_val = xmlGetDtdQElementDesc(dtd, (const xmlChar *)name, (const xmlChar *)prefix);
        desret_xmlElementPtr(ret_val);
        call_tests++;
        des_xmlDtdPtr(n_dtd, dtd, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetDtdQElementDesc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_dtd);
            printf(" %d", n_name);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetID(void) {
    int test_ret = 0;

    int mem_base;
    xmlAttrPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * ID;
    int n_ID;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_ID = 0;n_ID < 5;n_ID++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        ID = gen_const_xmlChar_ptr(n_ID, 1);

        ret_val = xmlGetID(doc, (const xmlChar *)ID);
        desret_xmlAttrPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_ID, (const xmlChar *)ID, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetID",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_ID);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetRefs(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlIsID(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;
    xmlAttrPtr attr;
    int n_attr;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
    for (n_attr = 0;n_attr < 2;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);

        ret_val = xmlIsID(doc, elem, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsID",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsMixedElement(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlIsMixedElement(doc, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsMixedElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIsRef(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;
    xmlAttrPtr attr;
    int n_attr;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
    for (n_attr = 0;n_attr < 2;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        attr = gen_xmlAttrPtr(n_attr, 2);

        ret_val = xmlIsRef(doc, elem, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_xmlAttrPtr(n_attr, attr, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIsRef",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewDocElementContent(void) {
    int test_ret = 0;

    int mem_base;
    xmlElementContentPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * name;
    int n_name;
    xmlElementContentType type;
    int n_type;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_type = 0;n_type < 4;n_type++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        type = gen_xmlElementContentType(n_type, 2);

        ret_val = xmlNewDocElementContent(doc, (const xmlChar *)name, type);
        xmlFreeDocElementContent(doc, ret_val); ret_val = 
# 25734 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                         ((void *)0)
# 25734 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                             ;
        desret_xmlElementContentPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_xmlElementContentType(n_type, type, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewDocElementContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewElementContent(void) {
    int test_ret = 0;

    int mem_base;
    xmlElementContentPtr ret_val;
    xmlChar * name;
    int n_name;
    xmlElementContentType type;
    int n_type;

    for (n_name = 0;n_name < 5;n_name++) {
    for (n_type = 0;n_type < 4;n_type++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        type = gen_xmlElementContentType(n_type, 1);

        ret_val = xmlNewElementContent((const xmlChar *)name, type);
        desret_xmlElementContentPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        des_xmlElementContentType(n_type, type, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewElementContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf(" %d", n_type);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNewValidCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlRemoveID(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlAttrPtr attr;
    int n_attr;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_attr = 0;n_attr < 2;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        attr = gen_xmlAttrPtr(n_attr, 1);

        ret_val = xmlRemoveID(doc, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlAttrPtr(n_attr, attr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRemoveID",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlRemoveRef(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlAttrPtr attr;
    int n_attr;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_attr = 0;n_attr < 2;n_attr++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        attr = gen_xmlAttrPtr(n_attr, 1);

        ret_val = xmlRemoveRef(doc, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlAttrPtr(n_attr, attr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRemoveRef",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSnprintfElementContent(void) {
    int test_ret = 0;

    int mem_base;
    char * buf;
    int n_buf;
    int size;
    int n_size;
    xmlElementContentPtr content;
    int n_content;
    int englob;
    int n_englob;

    for (n_buf = 0;n_buf < 1;n_buf++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_content = 0;n_content < 1;n_content++) {
    for (n_englob = 0;n_englob < 4;n_englob++) {
        mem_base = xmlMemBlocks();
        buf = gen_char_ptr(n_buf, 0);
        size = gen_int(n_size, 1);
        content = gen_xmlElementContentPtr(n_content, 2);
        englob = gen_int(n_englob, 3);

        xmlSnprintfElementContent(buf, size, content, englob);
        call_tests++;
        des_char_ptr(n_buf, buf, 0);
        des_int(n_size, size, 1);
        des_xmlElementContentPtr(n_content, content, 2);
        des_int(n_englob, englob, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSnprintfElementContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_size);
            printf(" %d", n_content);
            printf(" %d", n_englob);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlSprintfElementContent(void) {
    int test_ret = 0;



    int mem_base;
    char * buf;
    int n_buf;
    xmlElementContentPtr content;
    int n_content;
    int englob;
    int n_englob;

    for (n_buf = 0;n_buf < 1;n_buf++) {
    for (n_content = 0;n_content < 1;n_content++) {
    for (n_englob = 0;n_englob < 4;n_englob++) {
        mem_base = xmlMemBlocks();
        buf = gen_char_ptr(n_buf, 0);
        content = gen_xmlElementContentPtr(n_content, 1);
        englob = gen_int(n_englob, 2);

        xmlSprintfElementContent(buf, content, englob);
        call_tests++;
        des_char_ptr(n_buf, buf, 0);
        des_xmlElementContentPtr(n_content, content, 1);
        des_int(n_englob, englob, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSprintfElementContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_content);
            printf(" %d", n_englob);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlValidBuildContentModel(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlElementPtr elem;
    int n_elem;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_elem = 0;n_elem < 1;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        elem = gen_xmlElementPtr(n_elem, 1);

        ret_val = xmlValidBuildContentModel(ctxt, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlElementPtr(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidBuildContentModel",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidCtxtNormalizeAttributeValue(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;
    xmlChar * name;
    int n_name;
    xmlChar * value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        name = gen_const_xmlChar_ptr(n_name, 3);
        value = gen_const_xmlChar_ptr(n_value, 4);

        ret_val = xmlValidCtxtNormalizeAttributeValue(ctxt, doc, elem, (const xmlChar *)name, (const xmlChar *)value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 3);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidCtxtNormalizeAttributeValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}



static xmlElementContent * gen_xmlElementContent_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 26090 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 26090 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlElementContent_ptr(int no __attribute__((unused)), xmlElementContent * val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlValidGetPotentialChildren(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlElementContent * ctree;
    int n_ctree;
    xmlChar ** names;
    int n_names;
    int * len;
    int n_len;
    int max;
    int n_max;

    for (n_ctree = 0;n_ctree < 1;n_ctree++) {
    for (n_names = 0;n_names < 1;n_names++) {
    for (n_len = 0;n_len < 2;n_len++) {
    for (n_max = 0;n_max < 4;n_max++) {
        mem_base = xmlMemBlocks();
        ctree = gen_xmlElementContent_ptr(n_ctree, 0);
        names = gen_const_xmlChar_ptr_ptr(n_names, 1);
        len = gen_int_ptr(n_len, 2);
        max = gen_int(n_max, 3);

        ret_val = xmlValidGetPotentialChildren(ctree, (const xmlChar **)names, len, max);
        desret_int(ret_val);
        call_tests++;
        des_xmlElementContent_ptr(n_ctree, ctree, 0);
        des_const_xmlChar_ptr_ptr(n_names, (const xmlChar **)names, 1);
        des_int_ptr(n_len, len, 2);
        des_int(n_max, max, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidGetPotentialChildren",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctree);
            printf(" %d", n_names);
            printf(" %d", n_len);
            printf(" %d", n_max);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlValidGetValidElements(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlNode * prev;
    int n_prev;
    xmlNode * next;
    int n_next;
    xmlChar ** names;
    int n_names;
    int max;
    int n_max;

    for (n_prev = 0;n_prev < 3;n_prev++) {
    for (n_next = 0;n_next < 3;n_next++) {
    for (n_names = 0;n_names < 1;n_names++) {
    for (n_max = 0;n_max < 4;n_max++) {
        mem_base = xmlMemBlocks();
        prev = gen_xmlNodePtr(n_prev, 0);
        next = gen_xmlNodePtr(n_next, 1);
        names = gen_const_xmlChar_ptr_ptr(n_names, 2);
        max = gen_int(n_max, 3);

        ret_val = xmlValidGetValidElements(prev, next, (const xmlChar **)names, max);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_prev, prev, 0);
        des_xmlNodePtr(n_next, next, 1);
        des_const_xmlChar_ptr_ptr(n_names, (const xmlChar **)names, 2);
        des_int(n_max, max, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidGetValidElements",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_prev);
            printf(" %d", n_next);
            printf(" %d", n_names);
            printf(" %d", n_max);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlValidNormalizeAttributeValue(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;
    xmlChar * name;
    int n_name;
    xmlChar * value;
    int n_value;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        elem = gen_xmlNodePtr(n_elem, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);

        ret_val = xmlValidNormalizeAttributeValue(doc, elem, (const xmlChar *)name, (const xmlChar *)value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidNormalizeAttributeValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateAttributeDecl(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlAttributePtr attr;
    int n_attr;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_attr = 0;n_attr < 1;n_attr++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        attr = gen_xmlAttributePtr(n_attr, 2);

        ret_val = xmlValidateAttributeDecl(ctxt, doc, attr);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlAttributePtr(n_attr, attr, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateAttributeDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_attr);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateAttributeValue(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlAttributeType type;
    int n_type;
    xmlChar * value;
    int n_value;

    for (n_type = 0;n_type < 4;n_type++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlAttributeType(n_type, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);

        ret_val = xmlValidateAttributeValue(type, (const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_xmlAttributeType(n_type, type, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateAttributeValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_type);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateDocument(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateDocument(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDocument",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateDocumentFinal(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateDocumentFinal(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDocumentFinal",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateDtd(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlDtdPtr dtd;
    int n_dtd;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_dtd = 0;n_dtd < 3;n_dtd++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        dtd = gen_xmlDtdPtr(n_dtd, 2);

        ret_val = xmlValidateDtd(ctxt, doc, dtd);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlDtdPtr(n_dtd, dtd, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDtd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_dtd);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateDtdFinal(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateDtdFinal(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateDtdFinal",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlValidateElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateElementDecl(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlElementPtr elem;
    int n_elem;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 1;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlElementPtr(n_elem, 2);

        ret_val = xmlValidateElementDecl(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlElementPtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateElementDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateNameValue(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlChar * value;
    int n_value;

    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNameValue((const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNameValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateNamesValue(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlChar * value;
    int n_value;

    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNamesValue((const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNamesValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateNmtokenValue(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlChar * value;
    int n_value;

    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNmtokenValue((const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNmtokenValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateNmtokensValue(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlChar * value;
    int n_value;

    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlValidateNmtokensValue((const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNmtokensValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateNotationDecl(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNotationPtr nota;
    int n_nota;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_nota = 0;n_nota < 1;n_nota++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        nota = gen_xmlNotationPtr(n_nota, 2);

        ret_val = xmlValidateNotationDecl(ctxt, doc, nota);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNotationPtr(n_nota, nota, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNotationDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_nota);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateNotationUse(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlChar * notationName;
    int n_notationName;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_notationName = 0;n_notationName < 5;n_notationName++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        notationName = gen_const_xmlChar_ptr(n_notationName, 2);

        ret_val = xmlValidateNotationUse(ctxt, doc, (const xmlChar *)notationName);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_const_xmlChar_ptr(n_notationName, (const xmlChar *)notationName, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateNotationUse",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_notationName);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateOneAttribute(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;
    xmlAttrPtr attr;
    int n_attr;
    xmlChar * value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
    for (n_attr = 0;n_attr < 2;n_attr++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        attr = gen_xmlAttrPtr(n_attr, 3);
        value = gen_const_xmlChar_ptr(n_value, 4);

        ret_val = xmlValidateOneAttribute(ctxt, doc, elem, attr, (const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_xmlAttrPtr(n_attr, attr, 3);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateOneAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_attr);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateOneElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);

        ret_val = xmlValidateOneElement(ctxt, doc, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateOneElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateOneNamespace(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;
    xmlChar * prefix;
    int n_prefix;
    xmlNsPtr ns;
    int n_ns;
    xmlChar * value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        prefix = gen_const_xmlChar_ptr(n_prefix, 3);
        ns = gen_xmlNsPtr(n_ns, 4);
        value = gen_const_xmlChar_ptr(n_value, 5);

        ret_val = xmlValidateOneNamespace(ctxt, doc, elem, (const xmlChar *)prefix, ns, (const xmlChar *)value);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 3);
        des_xmlNsPtr(n_ns, ns, 4);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateOneNamespace",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_prefix);
            printf(" %d", n_ns);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidatePopElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;
    xmlChar * qname;
    int n_qname;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
    for (n_qname = 0;n_qname < 5;n_qname++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        qname = gen_const_xmlChar_ptr(n_qname, 3);

        ret_val = xmlValidatePopElement(ctxt, doc, elem, (const xmlChar *)qname);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_qname, (const xmlChar *)qname, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidatePopElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_qname);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidatePushCData(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlChar * data;
    int n_data;
    int len;
    int n_len;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_data = 0;n_data < 5;n_data++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        data = gen_const_xmlChar_ptr(n_data, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlValidatePushCData(ctxt, (const xmlChar *)data, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_data, (const xmlChar *)data, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidatePushCData",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_data);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidatePushElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr elem;
    int n_elem;
    xmlChar * qname;
    int n_qname;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
    for (n_qname = 0;n_qname < 5;n_qname++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);
        elem = gen_xmlNodePtr(n_elem, 2);
        qname = gen_const_xmlChar_ptr(n_qname, 3);

        ret_val = xmlValidatePushElement(ctxt, doc, elem, (const xmlChar *)qname);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        des_xmlNodePtr(n_elem, elem, 2);
        des_const_xmlChar_ptr(n_qname, (const xmlChar *)qname, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidatePushElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf(" %d", n_elem);
            printf(" %d", n_qname);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlValidateRoot(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;

    for (n_ctxt = 0;n_ctxt < 2;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlValidateRoot(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlValidateRoot",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_valid(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing valid : 50 of 70 functions ...\n");
    test_ret += test_xmlAddAttributeDecl();
    test_ret += test_xmlAddElementDecl();
    test_ret += test_xmlAddID();
    test_ret += test_xmlAddNotationDecl();
    test_ret += test_xmlAddRef();
    test_ret += test_xmlCopyAttributeTable();
    test_ret += test_xmlCopyDocElementContent();
    test_ret += test_xmlCopyElementContent();
    test_ret += test_xmlCopyElementTable();
    test_ret += test_xmlCopyEnumeration();
    test_ret += test_xmlCopyNotationTable();
    test_ret += test_xmlCreateEnumeration();
    test_ret += test_xmlDumpAttributeDecl();
    test_ret += test_xmlDumpAttributeTable();
    test_ret += test_xmlDumpElementDecl();
    test_ret += test_xmlDumpElementTable();
    test_ret += test_xmlDumpNotationDecl();
    test_ret += test_xmlDumpNotationTable();
    test_ret += test_xmlGetDtdAttrDesc();
    test_ret += test_xmlGetDtdElementDesc();
    test_ret += test_xmlGetDtdNotationDesc();
    test_ret += test_xmlGetDtdQAttrDesc();
    test_ret += test_xmlGetDtdQElementDesc();
    test_ret += test_xmlGetID();
    test_ret += test_xmlGetRefs();
    test_ret += test_xmlIsID();
    test_ret += test_xmlIsMixedElement();
    test_ret += test_xmlIsRef();
    test_ret += test_xmlNewDocElementContent();
    test_ret += test_xmlNewElementContent();
    test_ret += test_xmlNewValidCtxt();
    test_ret += test_xmlRemoveID();
    test_ret += test_xmlRemoveRef();
    test_ret += test_xmlSnprintfElementContent();
    test_ret += test_xmlSprintfElementContent();
    test_ret += test_xmlValidBuildContentModel();
    test_ret += test_xmlValidCtxtNormalizeAttributeValue();
    test_ret += test_xmlValidGetPotentialChildren();
    test_ret += test_xmlValidGetValidElements();
    test_ret += test_xmlValidNormalizeAttributeValue();
    test_ret += test_xmlValidateAttributeDecl();
    test_ret += test_xmlValidateAttributeValue();
    test_ret += test_xmlValidateDocument();
    test_ret += test_xmlValidateDocumentFinal();
    test_ret += test_xmlValidateDtd();
    test_ret += test_xmlValidateDtdFinal();
    test_ret += test_xmlValidateElement();
    test_ret += test_xmlValidateElementDecl();
    test_ret += test_xmlValidateNameValue();
    test_ret += test_xmlValidateNamesValue();
    test_ret += test_xmlValidateNmtokenValue();
    test_ret += test_xmlValidateNmtokensValue();
    test_ret += test_xmlValidateNotationDecl();
    test_ret += test_xmlValidateNotationUse();
    test_ret += test_xmlValidateOneAttribute();
    test_ret += test_xmlValidateOneElement();
    test_ret += test_xmlValidateOneNamespace();
    test_ret += test_xmlValidatePopElement();
    test_ret += test_xmlValidatePushCData();
    test_ret += test_xmlValidatePushElement();
    test_ret += test_xmlValidateRoot();

    if (test_ret != 0)
 printf("Module valid: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlXIncludeNewContext(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXIncludeProcess(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlXIncludeProcess(doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcess",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXIncludeProcessFlags(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    int flags;
    int n_flags;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_flags = 0;n_flags < 4;n_flags++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlXIncludeProcessFlags(doc, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessFlags",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXIncludeProcessFlagsData(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlDocPtr doc;
    int n_doc;
    int flags;
    int n_flags;
    void * data;
    int n_data;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_flags = 0;n_flags < 4;n_flags++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        flags = gen_int(n_flags, 1);
        data = gen_userdata(n_data, 2);

        ret_val = xmlXIncludeProcessFlagsData(doc, flags, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_int(n_flags, flags, 1);
        des_userdata(n_data, data, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessFlagsData",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_flags);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}




static xmlXIncludeCtxtPtr gen_xmlXIncludeCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 27437 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 27437 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlXIncludeCtxtPtr(int no __attribute__((unused)), xmlXIncludeCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlXIncludeProcessNode(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXIncludeCtxtPtr ctxt;
    int n_ctxt;
    xmlNodePtr node;
    int n_node;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXIncludeCtxtPtr(n_ctxt, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlXIncludeProcessNode(ctxt, node);
        desret_int(ret_val);
        call_tests++;
        des_xmlXIncludeCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXIncludeProcessTree(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodePtr tree;
    int n_tree;

    for (n_tree = 0;n_tree < 3;n_tree++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree, 0);

        ret_val = xmlXIncludeProcessTree(tree);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_tree, tree, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessTree",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_tree);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXIncludeProcessTreeFlags(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodePtr tree;
    int n_tree;
    int flags;
    int n_flags;

    for (n_tree = 0;n_tree < 3;n_tree++) {
    for (n_flags = 0;n_flags < 4;n_flags++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlXIncludeProcessTreeFlags(tree, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_tree, tree, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessTreeFlags",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_tree);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXIncludeProcessTreeFlagsData(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodePtr tree;
    int n_tree;
    int flags;
    int n_flags;
    void * data;
    int n_data;

    for (n_tree = 0;n_tree < 3;n_tree++) {
    for (n_flags = 0;n_flags < 4;n_flags++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        tree = gen_xmlNodePtr(n_tree, 0);
        flags = gen_int(n_flags, 1);
        data = gen_userdata(n_data, 2);

        ret_val = xmlXIncludeProcessTreeFlagsData(tree, flags, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_tree, tree, 0);
        des_int(n_flags, flags, 1);
        des_userdata(n_data, data, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeProcessTreeFlagsData",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_tree);
            printf(" %d", n_flags);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXIncludeSetFlags(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXIncludeCtxtPtr ctxt;
    int n_ctxt;
    int flags;
    int n_flags;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_flags = 0;n_flags < 4;n_flags++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXIncludeCtxtPtr(n_ctxt, 0);
        flags = gen_int(n_flags, 1);

        ret_val = xmlXIncludeSetFlags(ctxt, flags);
        desret_int(ret_val);
        call_tests++;
        des_xmlXIncludeCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_flags, flags, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXIncludeSetFlags",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_flags);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xinclude(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xinclude : 8 of 10 functions ...\n");
    test_ret += test_xmlXIncludeNewContext();
    test_ret += test_xmlXIncludeProcess();
    test_ret += test_xmlXIncludeProcessFlags();
    test_ret += test_xmlXIncludeProcessFlagsData();
    test_ret += test_xmlXIncludeProcessNode();
    test_ret += test_xmlXIncludeProcessTree();
    test_ret += test_xmlXIncludeProcessTreeFlags();
    test_ret += test_xmlXIncludeProcessTreeFlagsData();
    test_ret += test_xmlXIncludeSetFlags();

    if (test_ret != 0)
 printf("Module xinclude: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlAllocOutputBuffer(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr ret_val;
    xmlCharEncodingHandlerPtr encoder;
    int n_encoder;

    for (n_encoder = 0;n_encoder < 1;n_encoder++) {
        mem_base = xmlMemBlocks();
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 0);

        ret_val = xmlAllocOutputBuffer(encoder);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests++;
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAllocOutputBuffer",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_encoder);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlAllocParserInputBuffer(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    xmlCharEncoding enc;
    int n_enc;

    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        enc = gen_xmlCharEncoding(n_enc, 0);

        ret_val = xmlAllocParserInputBuffer(enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_xmlCharEncoding(n_enc, enc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAllocParserInputBuffer",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCheckFilename(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    char * path;
    int n_path;

    for (n_path = 0;n_path < 4;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_char_ptr(n_path, 0);

        ret_val = xmlCheckFilename((const char *)path);
        desret_int(ret_val);
        call_tests++;
        des_const_char_ptr(n_path, (const char *)path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCheckFilename",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCheckHTTPInput(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    xmlParserInputPtr ret;
    int n_ret;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_ret = 0;n_ret < 1;n_ret++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        ret = gen_xmlParserInputPtr(n_ret, 1);

        ret_val = xmlCheckHTTPInput(ctxt, ret);
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlParserInputPtr(n_ret, ret, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCheckHTTPInput",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_ret);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCleanupInputCallbacks(void) {
    int test_ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupInputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupInputCallbacks",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCleanupOutputCallbacks(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        xmlCleanupOutputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCleanupOutputCallbacks",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlFileClose(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    void * context;
    int n_context;

    for (n_context = 0;n_context < 2;n_context++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);

        ret_val = xmlFileClose(context);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileClose",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_context);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlFileMatch(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlFileMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileMatch",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlFileOpen(void) {
    int test_ret = 0;

    int mem_base;
    void * ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlFileOpen(filename);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileOpen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlFileRead(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    void * context;
    int n_context;
    char * buffer;
    int n_buffer;
    int len;
    int n_len;

    for (n_context = 0;n_context < 2;n_context++) {
    for (n_buffer = 0;n_buffer < 1;n_buffer++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);
        buffer = gen_char_ptr(n_buffer, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlFileRead(context, buffer, len);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        des_char_ptr(n_buffer, buffer, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlFileRead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_context);
            printf(" %d", n_buffer);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlIOFTPClose(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * context;
    int n_context;

    for (n_context = 0;n_context < 2;n_context++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);

        ret_val = xmlIOFTPClose(context);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPClose",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_context);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlIOFTPMatch(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOFTPMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPMatch",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlIOFTPOpen(void) {
    int test_ret = 0;


    int mem_base;
    void * ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOFTPOpen(filename);
        desret_void_ptr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPOpen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlIOFTPRead(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * context;
    int n_context;
    char * buffer;
    int n_buffer;
    int len;
    int n_len;

    for (n_context = 0;n_context < 2;n_context++) {
    for (n_buffer = 0;n_buffer < 1;n_buffer++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);
        buffer = gen_char_ptr(n_buffer, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlIOFTPRead(context, buffer, len);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        des_char_ptr(n_buffer, buffer, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOFTPRead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_context);
            printf(" %d", n_buffer);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlIOHTTPClose(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * context;
    int n_context;

    for (n_context = 0;n_context < 2;n_context++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);

        ret_val = xmlIOHTTPClose(context);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPClose",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_context);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlIOHTTPMatch(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOHTTPMatch(filename);
        desret_int(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPMatch",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlIOHTTPOpen(void) {
    int test_ret = 0;


    int mem_base;
    void * ret_val;
    const char * filename;
    int n_filename;

    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);

        ret_val = xmlIOHTTPOpen(filename);
        desret_xmlNanoHTTPCtxtPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPOpen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlIOHTTPRead(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    void * context;
    int n_context;
    char * buffer;
    int n_buffer;
    int len;
    int n_len;

    for (n_context = 0;n_context < 2;n_context++) {
    for (n_buffer = 0;n_buffer < 1;n_buffer++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        context = gen_void_ptr(n_context, 0);
        buffer = gen_char_ptr(n_buffer, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlIOHTTPRead(context, buffer, len);
        desret_int(ret_val);
        call_tests++;
        des_void_ptr(n_context, context, 0);
        des_char_ptr(n_buffer, buffer, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlIOHTTPRead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_context);
            printf(" %d", n_buffer);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNoNetExternalEntityLoader(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr ret_val;
    const char * URL;
    int n_URL;
    char * ID;
    int n_ID;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;

    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_ID = 0;n_ID < 4;n_ID++) {
    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
        mem_base = xmlMemBlocks();
        URL = gen_filepath(n_URL, 0);
        ID = gen_const_char_ptr(n_ID, 1);
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 2);

        ret_val = xmlNoNetExternalEntityLoader(URL, (const char *)ID, ctxt);
        desret_xmlParserInputPtr(ret_val);
        call_tests++;
        des_filepath(n_URL, URL, 0);
        des_const_char_ptr(n_ID, (const char *)ID, 1);
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNoNetExternalEntityLoader",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf(" %d", n_ID);
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlNormalizeWindowsPath(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * path;
    int n_path;

    for (n_path = 0;n_path < 5;n_path++) {
        mem_base = xmlMemBlocks();
        path = gen_const_xmlChar_ptr(n_path, 0);

        ret_val = xmlNormalizeWindowsPath((const xmlChar *)path);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_path, (const xmlChar *)path, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNormalizeWindowsPath",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_path);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlOutputBufferCreateBuffer(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr ret_val;
    xmlBufferPtr buffer;
    int n_buffer;
    xmlCharEncodingHandlerPtr encoder;
    int n_encoder;

    for (n_buffer = 0;n_buffer < 3;n_buffer++) {
    for (n_encoder = 0;n_encoder < 1;n_encoder++) {
        mem_base = xmlMemBlocks();
        buffer = gen_xmlBufferPtr(n_buffer, 0);
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);

        ret_val = xmlOutputBufferCreateBuffer(buffer, encoder);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buffer, buffer, 0);
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferCreateBuffer",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_encoder);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlOutputBufferCreateFd(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr ret_val;
    int fd;
    int n_fd;
    xmlCharEncodingHandlerPtr encoder;
    int n_encoder;

    for (n_fd = 0;n_fd < 4;n_fd++) {
    for (n_encoder = 0;n_encoder < 1;n_encoder++) {
        mem_base = xmlMemBlocks();
        fd = gen_int(n_fd, 0);
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);

        ret_val = xmlOutputBufferCreateFd(fd, encoder);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests++;
        des_int(n_fd, fd, 0);
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferCreateFd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_fd);
            printf(" %d", n_encoder);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlOutputBufferCreateFile(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr ret_val;
    FILE * file;
    int n_file;
    xmlCharEncodingHandlerPtr encoder;
    int n_encoder;

    for (n_file = 0;n_file < 2;n_file++) {
    for (n_encoder = 0;n_encoder < 1;n_encoder++) {
        mem_base = xmlMemBlocks();
        file = gen_FILE_ptr(n_file, 0);
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);

        ret_val = xmlOutputBufferCreateFile(file, encoder);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests++;
        des_FILE_ptr(n_file, file, 0);
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferCreateFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_file);
            printf(" %d", n_encoder);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlOutputBufferCreateFilename(void) {
    int test_ret = 0;


    int mem_base;
    xmlOutputBufferPtr ret_val;
    const char * URI;
    int n_URI;
    xmlCharEncodingHandlerPtr encoder;
    int n_encoder;
    int compression;
    int n_compression;

    for (n_URI = 0;n_URI < 6;n_URI++) {
    for (n_encoder = 0;n_encoder < 1;n_encoder++) {
    for (n_compression = 0;n_compression < 4;n_compression++) {
        mem_base = xmlMemBlocks();
        URI = gen_fileoutput(n_URI, 0);
        encoder = gen_xmlCharEncodingHandlerPtr(n_encoder, 1);
        compression = gen_int(n_compression, 2);

        ret_val = xmlOutputBufferCreateFilename(URI, encoder, compression);
        desret_xmlOutputBufferPtr(ret_val);
        call_tests++;
        des_fileoutput(n_URI, URI, 0);
        des_xmlCharEncodingHandlerPtr(n_encoder, encoder, 1);
        des_int(n_compression, compression, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferCreateFilename",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URI);
            printf(" %d", n_encoder);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlOutputBufferFlush(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlOutputBufferPtr out;
    int n_out;

    for (n_out = 0;n_out < 2;n_out++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);

        ret_val = xmlOutputBufferFlush(out);
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferFlush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlOutputBufferGetContent(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlOutputBufferPtr out;
    int n_out;

    for (n_out = 0;n_out < 2;n_out++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);

        ret_val = xmlOutputBufferGetContent(out);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferGetContent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlOutputBufferGetSize(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlOutputBufferWrite(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlOutputBufferPtr out;
    int n_out;
    int len;
    int n_len;
    char * buf;
    int n_buf;

    for (n_out = 0;n_out < 2;n_out++) {
    for (n_len = 0;n_len < 4;n_len++) {
    for (n_buf = 0;n_buf < 4;n_buf++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);
        len = gen_int(n_len, 1);
        buf = gen_const_char_ptr(n_buf, 2);

        ret_val = xmlOutputBufferWrite(out, len, (const char *)buf);
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        des_int(n_len, len, 1);
        des_const_char_ptr(n_buf, (const char *)buf, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferWrite",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf(" %d", n_len);
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlOutputBufferWriteEscape(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlOutputBufferWriteString(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlOutputBufferPtr out;
    int n_out;
    char * str;
    int n_str;

    for (n_out = 0;n_out < 2;n_out++) {
    for (n_str = 0;n_str < 4;n_str++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);
        str = gen_const_char_ptr(n_str, 1);

        ret_val = xmlOutputBufferWriteString(out, (const char *)str);
        desret_int(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        des_const_char_ptr(n_str, (const char *)str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlOutputBufferWriteString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlParserGetDirectory(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlParserInputBufferCreateFd(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    int fd;
    int n_fd;
    xmlCharEncoding enc;
    int n_enc;

    for (n_fd = 0;n_fd < 4;n_fd++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        fd = gen_int(n_fd, 0);
        enc = gen_xmlCharEncoding(n_enc, 1);
        if (fd >= 0) fd = -1;

        ret_val = xmlParserInputBufferCreateFd(fd, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_int(n_fd, fd, 0);
        des_xmlCharEncoding(n_enc, enc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateFd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_fd);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserInputBufferCreateFile(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    FILE * file;
    int n_file;
    xmlCharEncoding enc;
    int n_enc;

    for (n_file = 0;n_file < 2;n_file++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        file = gen_FILE_ptr(n_file, 0);
        enc = gen_xmlCharEncoding(n_enc, 1);

        ret_val = xmlParserInputBufferCreateFile(file, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_FILE_ptr(n_file, file, 0);
        des_xmlCharEncoding(n_enc, enc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_file);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserInputBufferCreateFilename(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    const char * URI;
    int n_URI;
    xmlCharEncoding enc;
    int n_enc;

    for (n_URI = 0;n_URI < 6;n_URI++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        URI = gen_fileoutput(n_URI, 0);
        enc = gen_xmlCharEncoding(n_enc, 1);

        ret_val = xmlParserInputBufferCreateFilename(URI, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_fileoutput(n_URI, URI, 0);
        des_xmlCharEncoding(n_enc, enc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateFilename",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URI);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserInputBufferCreateMem(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    char * mem;
    int n_mem;
    int size;
    int n_size;
    xmlCharEncoding enc;
    int n_enc;

    for (n_mem = 0;n_mem < 4;n_mem++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        mem = gen_const_char_ptr(n_mem, 0);
        size = gen_int(n_size, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);

        ret_val = xmlParserInputBufferCreateMem((const char *)mem, size, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_mem, (const char *)mem, 0);
        des_int(n_size, size, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateMem",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserInputBufferCreateStatic(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputBufferPtr ret_val;
    char * mem;
    int n_mem;
    int size;
    int n_size;
    xmlCharEncoding enc;
    int n_enc;

    for (n_mem = 0;n_mem < 4;n_mem++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
        mem_base = xmlMemBlocks();
        mem = gen_const_char_ptr(n_mem, 0);
        size = gen_int(n_size, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);

        ret_val = xmlParserInputBufferCreateStatic((const char *)mem, size, enc);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_mem, (const char *)mem, 0);
        des_int(n_size, size, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferCreateStatic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_mem);
            printf(" %d", n_size);
            printf(" %d", n_enc);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserInputBufferGrow(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputBufferPtr in;
    int n_in;
    int len;
    int n_len;

    for (n_in = 0;n_in < 8;n_in++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputBufferPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputBufferGrow(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferGrow",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserInputBufferPush(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputBufferPtr in;
    int n_in;
    int len;
    int n_len;
    char * buf;
    int n_buf;

    for (n_in = 0;n_in < 8;n_in++) {
    for (n_len = 0;n_len < 4;n_len++) {
    for (n_buf = 0;n_buf < 4;n_buf++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputBufferPtr(n_in, 0);
        len = gen_int(n_len, 1);
        buf = gen_const_char_ptr(n_buf, 2);

        ret_val = xmlParserInputBufferPush(in, len, (const char *)buf);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        des_const_char_ptr(n_buf, (const char *)buf, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferPush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf(" %d", n_buf);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserInputBufferRead(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlParserInputBufferPtr in;
    int n_in;
    int len;
    int n_len;

    for (n_in = 0;n_in < 8;n_in++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        in = gen_xmlParserInputBufferPtr(n_in, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlParserInputBufferRead(in, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_in, in, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserInputBufferRead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_in);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlPopInputCallbacks(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;

        mem_base = xmlMemBlocks();

        ret_val = xmlPopInputCallbacks();
        desret_int(ret_val);
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlPopInputCallbacks",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlRegisterDefaultInputCallbacks(void) {
    int test_ret = 0;

    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterDefaultInputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterDefaultInputCallbacks",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;

    return(test_ret);
}


static int
test_xmlRegisterDefaultOutputCallbacks(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterDefaultOutputCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterDefaultOutputCallbacks",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRegisterHTTPPostCallbacks(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        xmlRegisterHTTPPostCallbacks();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegisterHTTPPostCallbacks",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}

static int
test_xmlIO(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlIO : 40 of 50 functions ...\n");
    test_ret += test_xmlAllocOutputBuffer();
    test_ret += test_xmlAllocParserInputBuffer();
    test_ret += test_xmlCheckFilename();
    test_ret += test_xmlCheckHTTPInput();
    test_ret += test_xmlCleanupInputCallbacks();
    test_ret += test_xmlCleanupOutputCallbacks();
    test_ret += test_xmlFileClose();
    test_ret += test_xmlFileMatch();
    test_ret += test_xmlFileOpen();
    test_ret += test_xmlFileRead();
    test_ret += test_xmlIOFTPClose();
    test_ret += test_xmlIOFTPMatch();
    test_ret += test_xmlIOFTPOpen();
    test_ret += test_xmlIOFTPRead();
    test_ret += test_xmlIOHTTPClose();
    test_ret += test_xmlIOHTTPMatch();
    test_ret += test_xmlIOHTTPOpen();
    test_ret += test_xmlIOHTTPRead();
    test_ret += test_xmlNoNetExternalEntityLoader();
    test_ret += test_xmlNormalizeWindowsPath();
    test_ret += test_xmlOutputBufferCreateBuffer();
    test_ret += test_xmlOutputBufferCreateFd();
    test_ret += test_xmlOutputBufferCreateFile();
    test_ret += test_xmlOutputBufferCreateFilename();
    test_ret += test_xmlOutputBufferFlush();
    test_ret += test_xmlOutputBufferGetContent();
    test_ret += test_xmlOutputBufferGetSize();
    test_ret += test_xmlOutputBufferWrite();
    test_ret += test_xmlOutputBufferWriteEscape();
    test_ret += test_xmlOutputBufferWriteString();
    test_ret += test_xmlParserGetDirectory();
    test_ret += test_xmlParserInputBufferCreateFd();
    test_ret += test_xmlParserInputBufferCreateFile();
    test_ret += test_xmlParserInputBufferCreateFilename();
    test_ret += test_xmlParserInputBufferCreateMem();
    test_ret += test_xmlParserInputBufferCreateStatic();
    test_ret += test_xmlParserInputBufferGrow();
    test_ret += test_xmlParserInputBufferPush();
    test_ret += test_xmlParserInputBufferRead();
    test_ret += test_xmlPopInputCallbacks();
    test_ret += test_xmlRegisterDefaultInputCallbacks();
    test_ret += test_xmlRegisterDefaultOutputCallbacks();
    test_ret += test_xmlRegisterHTTPPostCallbacks();

    if (test_ret != 0)
 printf("Module xmlIO: %d errors\n", test_ret);
    return(test_ret);
}



static xmlAutomataPtr gen_xmlAutomataPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 29219 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 29219 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlAutomataPtr(int no __attribute__((unused)), xmlAutomataPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlAutomataCompile(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataGetInitState(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataIsDeterminist(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlAutomataPtr am;
    int n_am;

    for (n_am = 0;n_am < 1;n_am++) {
        mem_base = xmlMemBlocks();
        am = gen_xmlAutomataPtr(n_am, 0);

        ret_val = xmlAutomataIsDeterminist(am);
        desret_int(ret_val);
        call_tests++;
        des_xmlAutomataPtr(n_am, am, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAutomataIsDeterminist",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_am);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}




static xmlAutomataStatePtr gen_xmlAutomataStatePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 29283 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 29283 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlAutomataStatePtr(int no __attribute__((unused)), xmlAutomataStatePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlAutomataNewAllTrans(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewCountTrans(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewCountTrans2(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewCountedTrans(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewCounter(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlAutomataPtr am;
    int n_am;
    int min;
    int n_min;
    int max;
    int n_max;

    for (n_am = 0;n_am < 1;n_am++) {
    for (n_min = 0;n_min < 4;n_min++) {
    for (n_max = 0;n_max < 4;n_max++) {
        mem_base = xmlMemBlocks();
        am = gen_xmlAutomataPtr(n_am, 0);
        min = gen_int(n_min, 1);
        max = gen_int(n_max, 2);

        ret_val = xmlAutomataNewCounter(am, min, max);
        desret_int(ret_val);
        call_tests++;
        des_xmlAutomataPtr(n_am, am, 0);
        des_int(n_min, min, 1);
        des_int(n_max, max, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAutomataNewCounter",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_am);
            printf(" %d", n_min);
            printf(" %d", n_max);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlAutomataNewCounterTrans(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewEpsilon(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewNegTrans(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewOnceTrans(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewOnceTrans2(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewState(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewTransition(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataNewTransition2(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlAutomataSetFinalState(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlAutomataPtr am;
    int n_am;
    xmlAutomataStatePtr state;
    int n_state;

    for (n_am = 0;n_am < 1;n_am++) {
    for (n_state = 0;n_state < 1;n_state++) {
        mem_base = xmlMemBlocks();
        am = gen_xmlAutomataPtr(n_am, 0);
        state = gen_xmlAutomataStatePtr(n_state, 1);

        ret_val = xmlAutomataSetFinalState(am, state);
        desret_int(ret_val);
        call_tests++;
        des_xmlAutomataPtr(n_am, am, 0);
        des_xmlAutomataStatePtr(n_state, state, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlAutomataSetFinalState",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_am);
            printf(" %d", n_state);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNewAutomata(void) {
    int test_ret = 0;



    return(test_ret);
}

static int
test_xmlautomata(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlautomata : 3 of 19 functions ...\n");
    test_ret += test_xmlAutomataCompile();
    test_ret += test_xmlAutomataGetInitState();
    test_ret += test_xmlAutomataIsDeterminist();
    test_ret += test_xmlAutomataNewAllTrans();
    test_ret += test_xmlAutomataNewCountTrans();
    test_ret += test_xmlAutomataNewCountTrans2();
    test_ret += test_xmlAutomataNewCountedTrans();
    test_ret += test_xmlAutomataNewCounter();
    test_ret += test_xmlAutomataNewCounterTrans();
    test_ret += test_xmlAutomataNewEpsilon();
    test_ret += test_xmlAutomataNewNegTrans();
    test_ret += test_xmlAutomataNewOnceTrans();
    test_ret += test_xmlAutomataNewOnceTrans2();
    test_ret += test_xmlAutomataNewState();
    test_ret += test_xmlAutomataNewTransition();
    test_ret += test_xmlAutomataNewTransition2();
    test_ret += test_xmlAutomataSetFinalState();
    test_ret += test_xmlNewAutomata();

    if (test_ret != 0)
 printf("Module xmlautomata: %d errors\n", test_ret);
    return(test_ret);
}


static xmlGenericErrorFunc * gen_xmlGenericErrorFunc_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 29539 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 29539 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlGenericErrorFunc_ptr(int no __attribute__((unused)), xmlGenericErrorFunc * val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_initGenericErrorDefaultFunc(void) {
    int test_ret = 0;

    int mem_base;
    xmlGenericErrorFunc * handler;
    int n_handler;

    for (n_handler = 0;n_handler < 1;n_handler++) {
        mem_base = xmlMemBlocks();
        handler = gen_xmlGenericErrorFunc_ptr(n_handler, 0);

        initGenericErrorDefaultFunc(handler);
        call_tests++;
        des_xmlGenericErrorFunc_ptr(n_handler, handler, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in initGenericErrorDefaultFunc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_handler);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}



static xmlErrorPtr gen_xmlErrorPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 29576 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 29576 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlErrorPtr(int no __attribute__((unused)), xmlErrorPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}

static int
test_xmlCopyError(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlErrorPtr from;
    int n_from;
    xmlErrorPtr to;
    int n_to;

    for (n_from = 0;n_from < 1;n_from++) {
    for (n_to = 0;n_to < 1;n_to++) {
        mem_base = xmlMemBlocks();
        from = gen_xmlErrorPtr(n_from, 0);
        to = gen_xmlErrorPtr(n_to, 1);

        ret_val = xmlCopyError(from, to);
        desret_int(ret_val);
        call_tests++;
        des_xmlErrorPtr(n_from, from, 0);
        des_xmlErrorPtr(n_to, to, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCopyError",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_from);
            printf(" %d", n_to);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCtxtGetLastError(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlCtxtResetLastError(void) {
    int test_ret = 0;

    int mem_base;
    void * ctx;
    int n_ctx;

    for (n_ctx = 0;n_ctx < 2;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctx = gen_void_ptr(n_ctx, 0);

        xmlCtxtResetLastError(ctx);
        call_tests++;
        des_void_ptr(n_ctx, ctx, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCtxtResetLastError",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetLastError(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlParserError(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlParserPrintFileContext(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr input;
    int n_input;

    for (n_input = 0;n_input < 1;n_input++) {
        mem_base = xmlMemBlocks();
        input = gen_xmlParserInputPtr(n_input, 0);

        xmlParserPrintFileContext(input);
        call_tests++;
        des_xmlParserInputPtr(n_input, input, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserPrintFileContext",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_input);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserPrintFileInfo(void) {
    int test_ret = 0;

    int mem_base;
    xmlParserInputPtr input;
    int n_input;

    for (n_input = 0;n_input < 1;n_input++) {
        mem_base = xmlMemBlocks();
        input = gen_xmlParserInputPtr(n_input, 0);

        xmlParserPrintFileInfo(input);
        call_tests++;
        des_xmlParserInputPtr(n_input, input, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlParserPrintFileInfo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_input);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlParserValidityError(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlParserValidityWarning(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlParserWarning(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlResetError(void) {
    int test_ret = 0;

    int mem_base;
    xmlErrorPtr err;
    int n_err;

    for (n_err = 0;n_err < 1;n_err++) {
        mem_base = xmlMemBlocks();
        err = gen_xmlErrorPtr(n_err, 0);

        xmlResetError(err);
        call_tests++;
        des_xmlErrorPtr(n_err, err, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlResetError",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_err);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlResetLastError(void) {
    int test_ret = 0;



        xmlResetLastError();
        call_tests++;
        xmlResetLastError();
    function_tests++;

    return(test_ret);
}


static int
test_xmlSetGenericErrorFunc(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSetStructuredErrorFunc(void) {
    int test_ret = 0;



    return(test_ret);
}

static int
test_xmlerror(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlerror : 7 of 15 functions ...\n");
    test_ret += test_initGenericErrorDefaultFunc();
    test_ret += test_xmlCopyError();
    test_ret += test_xmlCtxtGetLastError();
    test_ret += test_xmlCtxtResetLastError();
    test_ret += test_xmlGetLastError();
    test_ret += test_xmlParserError();
    test_ret += test_xmlParserPrintFileContext();
    test_ret += test_xmlParserPrintFileInfo();
    test_ret += test_xmlParserValidityError();
    test_ret += test_xmlParserValidityWarning();
    test_ret += test_xmlParserWarning();
    test_ret += test_xmlResetError();
    test_ret += test_xmlResetLastError();
    test_ret += test_xmlSetGenericErrorFunc();
    test_ret += test_xmlSetStructuredErrorFunc();

    if (test_ret != 0)
 printf("Module xmlerror: %d errors\n", test_ret);
    return(test_ret);
}



static xmlModulePtr gen_xmlModulePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 29863 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 29863 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlModulePtr(int no __attribute__((unused)), xmlModulePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlModuleClose(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlModulePtr module;
    int n_module;

    for (n_module = 0;n_module < 1;n_module++) {
        mem_base = xmlMemBlocks();
        module = gen_xmlModulePtr(n_module, 0);

        ret_val = xmlModuleClose(module);
        desret_int(ret_val);
        call_tests++;
        des_xmlModulePtr(n_module, module, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlModuleClose",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_module);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlModuleOpen(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlModuleSymbol(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlModulePtr module;
    int n_module;
    char * name;
    int n_name;
    void ** symbol;
    int n_symbol;

    for (n_module = 0;n_module < 1;n_module++) {
    for (n_name = 0;n_name < 4;n_name++) {
    for (n_symbol = 0;n_symbol < 1;n_symbol++) {
        mem_base = xmlMemBlocks();
        module = gen_xmlModulePtr(n_module, 0);
        name = gen_const_char_ptr(n_name, 1);
        symbol = gen_void_ptr_ptr(n_symbol, 2);

        ret_val = xmlModuleSymbol(module, (const char *)name, symbol);
        desret_int(ret_val);
        call_tests++;
        des_xmlModulePtr(n_module, module, 0);
        des_const_char_ptr(n_name, (const char *)name, 1);
        des_void_ptr_ptr(n_symbol, symbol, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlModuleSymbol",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_module);
            printf(" %d", n_name);
            printf(" %d", n_symbol);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xmlmodule(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlmodule : 2 of 4 functions ...\n");
    test_ret += test_xmlModuleClose();
    test_ret += test_xmlModuleOpen();
    test_ret += test_xmlModuleSymbol();

    if (test_ret != 0)
 printf("Module xmlmodule: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlNewTextReader(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextReaderPtr ret_val;
    xmlParserInputBufferPtr input;
    int n_input;
    const char * URI;
    int n_URI;

    for (n_input = 0;n_input < 8;n_input++) {
    for (n_URI = 0;n_URI < 8;n_URI++) {
        mem_base = xmlMemBlocks();
        input = gen_xmlParserInputBufferPtr(n_input, 0);
        URI = gen_filepath(n_URI, 1);

        ret_val = xmlNewTextReader(input, URI);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_xmlParserInputBufferPtr(n_input, input, 0);
        des_filepath(n_URI, URI, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextReader",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_input);
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNewTextReaderFilename(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextReaderPtr ret_val;
    const char * URI;
    int n_URI;

    for (n_URI = 0;n_URI < 8;n_URI++) {
        mem_base = xmlMemBlocks();
        URI = gen_filepath(n_URI, 0);

        ret_val = xmlNewTextReaderFilename(URI);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_filepath(n_URI, URI, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextReaderFilename",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URI);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlReaderForDoc(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextReaderPtr ret_val;
    xmlChar * cur;
    int n_cur;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        URL = gen_filepath(n_URL, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_parseroptions(n_options, 3);

        ret_val = xmlReaderForDoc((const xmlChar *)cur, URL, (const char *)encoding, options);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
        des_filepath(n_URL, URL, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_parseroptions(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderForDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlReaderForFile(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextReaderPtr ret_val;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        filename = gen_filepath(n_filename, 0);
        encoding = gen_const_char_ptr(n_encoding, 1);
        options = gen_parseroptions(n_options, 2);

        ret_val = xmlReaderForFile(filename, (const char *)encoding, options);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_filepath(n_filename, filename, 0);
        des_const_char_ptr(n_encoding, (const char *)encoding, 1);
        des_parseroptions(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderForFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlReaderForMemory(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextReaderPtr ret_val;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_parseroptions(n_options, 4);

        ret_val = xmlReaderForMemory((const char *)buffer, size, URL, (const char *)encoding, options);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
        des_int(n_size, size, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        des_parseroptions(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderForMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlReaderNewDoc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlChar * cur;
    int n_cur;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        cur = gen_const_xmlChar_ptr(n_cur, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_parseroptions(n_options, 4);

        ret_val = xmlReaderNewDoc(reader, (const xmlChar *)cur, URL, (const char *)encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 1);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        des_parseroptions(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_cur);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlReaderNewFile(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    const char * filename;
    int n_filename;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        filename = gen_filepath(n_filename, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        options = gen_parseroptions(n_options, 3);

        ret_val = xmlReaderNewFile(reader, filename, (const char *)encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_filepath(n_filename, filename, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_parseroptions(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_filename);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlReaderNewMemory(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        buffer = gen_const_char_ptr(n_buffer, 1);
        size = gen_int(n_size, 2);
        URL = gen_filepath(n_URL, 3);
        encoding = gen_const_char_ptr(n_encoding, 4);
        options = gen_parseroptions(n_options, 5);

        ret_val = xmlReaderNewMemory(reader, (const char *)buffer, size, URL, (const char *)encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_char_ptr(n_buffer, (const char *)buffer, 1);
        des_int(n_size, size, 2);
        des_filepath(n_URL, URL, 3);
        des_const_char_ptr(n_encoding, (const char *)encoding, 4);
        des_parseroptions(n_options, options, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlReaderNewWalker(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlDocPtr doc;
    int n_doc;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlReaderNewWalker(reader, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderNewWalker",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlReaderWalker(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextReaderPtr ret_val;
    xmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlReaderWalker(doc);
        desret_xmlTextReaderPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlReaderWalker",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderAttributeCount(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderAttributeCount(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderAttributeCount",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderBaseUri(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderBaseUri(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderBaseUri",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderByteConsumed(void) {
    int test_ret = 0;


    int mem_base;
    long ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderByteConsumed(reader);
        desret_long(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderByteConsumed",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderClose(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderClose(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderClose",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstBaseUri(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstBaseUri(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstBaseUri",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstEncoding(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstEncoding(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstEncoding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstLocalName(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstLocalName(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstLocalName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstName(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstName(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstNamespaceUri(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstNamespaceUri(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstNamespaceUri",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstPrefix(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstPrefix(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstPrefix",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstString(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlChar * str;
    int n_str;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_str = 0;n_str < 5;n_str++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlTextReaderConstString(reader, (const xmlChar *)str);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstValue(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstValue(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstXmlLang(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstXmlLang(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstXmlLang",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderConstXmlVersion(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderConstXmlVersion(reader);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderConstXmlVersion",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderCurrentDoc(void) {
    int test_ret = 0;


    int mem_base;
    xmlDocPtr ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderCurrentDoc(reader);
        desret_xmlDocPtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderCurrentDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderCurrentNode(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderCurrentNode(reader);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderCurrentNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderDepth(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderDepth(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderDepth",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderExpand(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderExpand(reader);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderExpand",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderGetAttribute(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlChar * name;
    int n_name;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextReaderGetAttribute(reader, (const xmlChar *)name);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderGetAttributeNo(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    int no;
    int n_no;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_no = 0;n_no < 4;n_no++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        no = gen_int(n_no, 1);

        ret_val = xmlTextReaderGetAttributeNo(reader, no);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_no, no, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_no);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderGetAttributeNs(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlChar * localName;
    int n_localName;
    xmlChar * namespaceURI;
    int n_namespaceURI;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_localName = 0;n_localName < 5;n_localName++) {
    for (n_namespaceURI = 0;n_namespaceURI < 5;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        localName = gen_const_xmlChar_ptr(n_localName, 1);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);

        ret_val = xmlTextReaderGetAttributeNs(reader, (const xmlChar *)localName, (const xmlChar *)namespaceURI);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_localName, (const xmlChar *)localName, 1);
        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetAttributeNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_localName);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}




static xmlTextReaderErrorFunc * gen_xmlTextReaderErrorFunc_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 31228 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 31228 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlTextReaderErrorFunc_ptr(int no __attribute__((unused)), xmlTextReaderErrorFunc * val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlTextReaderGetErrorHandler(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlTextReaderErrorFunc * f;
    int n_f;
    void ** arg;
    int n_arg;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_f = 0;n_f < 1;n_f++) {
    for (n_arg = 0;n_arg < 1;n_arg++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        f = gen_xmlTextReaderErrorFunc_ptr(n_f, 1);
        arg = gen_void_ptr_ptr(n_arg, 2);

        xmlTextReaderGetErrorHandler(reader, f, arg);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlTextReaderErrorFunc_ptr(n_f, f, 1);
        des_void_ptr_ptr(n_arg, arg, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetErrorHandler",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_f);
            printf(" %d", n_arg);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderGetParserColumnNumber(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderGetParserColumnNumber(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetParserColumnNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderGetParserLineNumber(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderGetParserLineNumber(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetParserLineNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderGetParserProp(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    int prop;
    int n_prop;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_prop = 0;n_prop < 4;n_prop++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        prop = gen_int(n_prop, 1);

        ret_val = xmlTextReaderGetParserProp(reader, prop);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_prop, prop, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetParserProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_prop);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderGetRemainder(void) {
    int test_ret = 0;


    int mem_base;
    xmlParserInputBufferPtr ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderGetRemainder(reader);
        desret_xmlParserInputBufferPtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderGetRemainder",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderHasAttributes(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderHasAttributes(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderHasAttributes",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderHasValue(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderHasValue(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderHasValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderIsDefault(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsDefault(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsDefault",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderIsEmptyElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsEmptyElement(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsEmptyElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderIsNamespaceDecl(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsNamespaceDecl(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsNamespaceDecl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderIsValid(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderIsValid(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderIsValid",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderLocalName(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderLocalName(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLocalName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}




static xmlTextReaderLocatorPtr gen_xmlTextReaderLocatorPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 31665 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 31665 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlTextReaderLocatorPtr(int no __attribute__((unused)), xmlTextReaderLocatorPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlTextReaderLocatorBaseURI(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderLocatorPtr locator;
    int n_locator;

    for (n_locator = 0;n_locator < 1;n_locator++) {
        mem_base = xmlMemBlocks();
        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);

        ret_val = xmlTextReaderLocatorBaseURI(locator);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLocatorBaseURI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_locator);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderLocatorLineNumber(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderLocatorPtr locator;
    int n_locator;

    for (n_locator = 0;n_locator < 1;n_locator++) {
        mem_base = xmlMemBlocks();
        locator = gen_xmlTextReaderLocatorPtr(n_locator, 0);

        ret_val = xmlTextReaderLocatorLineNumber(locator);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderLocatorPtr(n_locator, locator, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLocatorLineNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_locator);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderLookupNamespace(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlChar * prefix;
    int n_prefix;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);

        ret_val = xmlTextReaderLookupNamespace(reader, (const xmlChar *)prefix);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderLookupNamespace",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderMoveToAttribute(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlChar * name;
    int n_name;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextReaderMoveToAttribute(reader, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderMoveToAttributeNo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    int no;
    int n_no;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_no = 0;n_no < 4;n_no++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        no = gen_int(n_no, 1);

        ret_val = xmlTextReaderMoveToAttributeNo(reader, no);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_no, no, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_no);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderMoveToAttributeNs(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlChar * localName;
    int n_localName;
    xmlChar * namespaceURI;
    int n_namespaceURI;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_localName = 0;n_localName < 5;n_localName++) {
    for (n_namespaceURI = 0;n_namespaceURI < 5;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        localName = gen_const_xmlChar_ptr(n_localName, 1);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 2);

        ret_val = xmlTextReaderMoveToAttributeNs(reader, (const xmlChar *)localName, (const xmlChar *)namespaceURI);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_localName, (const xmlChar *)localName, 1);
        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToAttributeNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_localName);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderMoveToElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderMoveToElement(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderMoveToFirstAttribute(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderMoveToFirstAttribute(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToFirstAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderMoveToNextAttribute(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderMoveToNextAttribute(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderMoveToNextAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderName(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderName(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderNamespaceUri(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNamespaceUri(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNamespaceUri",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderNext(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNext(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNext",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderNextSibling(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNextSibling(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNextSibling",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderNodeType(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNodeType(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNodeType",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderNormalization(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderNormalization(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderNormalization",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderPrefix(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderPrefix(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderPrefix",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderPreserve(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderPreserve(reader);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderPreserve",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderPreservePattern(void) {
    int test_ret = 0;



    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlChar * pattern;
    int n_pattern;
    xmlChar ** namespaces;
    int n_namespaces;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_pattern = 0;n_pattern < 5;n_pattern++) {
    for (n_namespaces = 0;n_namespaces < 1;n_namespaces++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        pattern = gen_const_xmlChar_ptr(n_pattern, 1);
        namespaces = gen_const_xmlChar_ptr_ptr(n_namespaces, 2);

        ret_val = xmlTextReaderPreservePattern(reader, (const xmlChar *)pattern, (const xmlChar **)namespaces);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_xmlChar_ptr(n_pattern, (const xmlChar *)pattern, 1);
        des_const_xmlChar_ptr_ptr(n_namespaces, (const xmlChar **)namespaces, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderPreservePattern",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_pattern);
            printf(" %d", n_namespaces);
            printf("\n");
        }
    }
    }
    }
    function_tests++;



    return(test_ret);
}


static int
test_xmlTextReaderQuoteChar(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderQuoteChar(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderQuoteChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderRead(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderRead(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderRead",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderReadAttributeValue(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderReadAttributeValue(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderReadAttributeValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderReadState(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderReadState(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderReadState",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderRelaxNGSetSchema(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlRelaxNGPtr schema;
    int n_schema;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_schema = 0;n_schema < 1;n_schema++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        schema = gen_xmlRelaxNGPtr(n_schema, 1);

        ret_val = xmlTextReaderRelaxNGSetSchema(reader, schema);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlRelaxNGPtr(n_schema, schema, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderRelaxNGSetSchema",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_schema);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderRelaxNGValidate(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    char * rng;
    int n_rng;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_rng = 0;n_rng < 4;n_rng++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        rng = gen_const_char_ptr(n_rng, 1);

        ret_val = xmlTextReaderRelaxNGValidate(reader, (const char *)rng);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_char_ptr(n_rng, (const char *)rng, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidate",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_rng);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderRelaxNGValidateCtxt(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlRelaxNGValidCtxtPtr ctxt;
    int n_ctxt;
    int options;
    int n_options;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        ctxt = gen_xmlRelaxNGValidCtxtPtr(n_ctxt, 1);
        options = gen_parseroptions(n_options, 2);

        ret_val = xmlTextReaderRelaxNGValidateCtxt(reader, ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlRelaxNGValidCtxtPtr(n_ctxt, ctxt, 1);
        des_parseroptions(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderRelaxNGValidateCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderSchemaValidate(void) {
    int test_ret = 0;


    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    char * xsd;
    int n_xsd;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_xsd = 0;n_xsd < 4;n_xsd++) {
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        xsd = gen_const_char_ptr(n_xsd, 1);

        ret_val = xmlTextReaderSchemaValidate(reader, (const char *)xsd);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_const_char_ptr(n_xsd, (const char *)xsd, 1);
        xmlResetLastError();
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderSchemaValidateCtxt(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;
    int options;
    int n_options;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 1);
        options = gen_parseroptions(n_options, 2);

        ret_val = xmlTextReaderSchemaValidateCtxt(reader, ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 1);
        des_parseroptions(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderSchemaValidateCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderSetErrorHandler(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextReaderSetParserProp(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    int prop;
    int n_prop;
    int value;
    int n_value;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_prop = 0;n_prop < 4;n_prop++) {
    for (n_value = 0;n_value < 4;n_value++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        prop = gen_int(n_prop, 1);
        value = gen_int(n_value, 2);

        ret_val = xmlTextReaderSetParserProp(reader, prop, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_int(n_prop, prop, 1);
        des_int(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderSetParserProp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_prop);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderSetSchema(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlSchemaPtr schema;
    int n_schema;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_schema = 0;n_schema < 1;n_schema++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        schema = gen_xmlSchemaPtr(n_schema, 1);

        ret_val = xmlTextReaderSetSchema(reader, schema);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_xmlSchemaPtr(n_schema, schema, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderSetSchema",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_schema);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderSetStructuredErrorHandler(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextReaderSetup(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;
    xmlParserInputBufferPtr input;
    int n_input;
    const char * URL;
    int n_URL;
    char * encoding;
    int n_encoding;
    int options;
    int n_options;

    for (n_reader = 0;n_reader < 4;n_reader++) {
    for (n_input = 0;n_input < 8;n_input++) {
    for (n_URL = 0;n_URL < 8;n_URL++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_options = 0;n_options < 5;n_options++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);
        input = gen_xmlParserInputBufferPtr(n_input, 1);
        URL = gen_filepath(n_URL, 2);
        encoding = gen_const_char_ptr(n_encoding, 3);
        options = gen_parseroptions(n_options, 4);

        ret_val = xmlTextReaderSetup(reader, input, URL, (const char *)encoding, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        des_filepath(n_URL, URL, 2);
        des_const_char_ptr(n_encoding, (const char *)encoding, 3);
        des_parseroptions(n_options, options, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderSetup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf(" %d", n_input);
            printf(" %d", n_URL);
            printf(" %d", n_encoding);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderStandalone(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderStandalone(reader);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderStandalone",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderValue(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderValue(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextReaderXmlLang(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlTextReaderPtr reader;
    int n_reader;

    for (n_reader = 0;n_reader < 4;n_reader++) {
        mem_base = xmlMemBlocks();
        reader = gen_xmlTextReaderPtr(n_reader, 0);

        ret_val = xmlTextReaderXmlLang(reader);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlTextReaderPtr(n_reader, reader, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextReaderXmlLang",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_reader);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xmlreader(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlreader : 76 of 86 functions ...\n");
    test_ret += test_xmlNewTextReader();
    test_ret += test_xmlNewTextReaderFilename();
    test_ret += test_xmlReaderForDoc();
    test_ret += test_xmlReaderForFile();
    test_ret += test_xmlReaderForMemory();
    test_ret += test_xmlReaderNewDoc();
    test_ret += test_xmlReaderNewFile();
    test_ret += test_xmlReaderNewMemory();
    test_ret += test_xmlReaderNewWalker();
    test_ret += test_xmlReaderWalker();
    test_ret += test_xmlTextReaderAttributeCount();
    test_ret += test_xmlTextReaderBaseUri();
    test_ret += test_xmlTextReaderByteConsumed();
    test_ret += test_xmlTextReaderClose();
    test_ret += test_xmlTextReaderConstBaseUri();
    test_ret += test_xmlTextReaderConstEncoding();
    test_ret += test_xmlTextReaderConstLocalName();
    test_ret += test_xmlTextReaderConstName();
    test_ret += test_xmlTextReaderConstNamespaceUri();
    test_ret += test_xmlTextReaderConstPrefix();
    test_ret += test_xmlTextReaderConstString();
    test_ret += test_xmlTextReaderConstValue();
    test_ret += test_xmlTextReaderConstXmlLang();
    test_ret += test_xmlTextReaderConstXmlVersion();
    test_ret += test_xmlTextReaderCurrentDoc();
    test_ret += test_xmlTextReaderCurrentNode();
    test_ret += test_xmlTextReaderDepth();
    test_ret += test_xmlTextReaderExpand();
    test_ret += test_xmlTextReaderGetAttribute();
    test_ret += test_xmlTextReaderGetAttributeNo();
    test_ret += test_xmlTextReaderGetAttributeNs();
    test_ret += test_xmlTextReaderGetErrorHandler();
    test_ret += test_xmlTextReaderGetParserColumnNumber();
    test_ret += test_xmlTextReaderGetParserLineNumber();
    test_ret += test_xmlTextReaderGetParserProp();
    test_ret += test_xmlTextReaderGetRemainder();
    test_ret += test_xmlTextReaderHasAttributes();
    test_ret += test_xmlTextReaderHasValue();
    test_ret += test_xmlTextReaderIsDefault();
    test_ret += test_xmlTextReaderIsEmptyElement();
    test_ret += test_xmlTextReaderIsNamespaceDecl();
    test_ret += test_xmlTextReaderIsValid();
    test_ret += test_xmlTextReaderLocalName();
    test_ret += test_xmlTextReaderLocatorBaseURI();
    test_ret += test_xmlTextReaderLocatorLineNumber();
    test_ret += test_xmlTextReaderLookupNamespace();
    test_ret += test_xmlTextReaderMoveToAttribute();
    test_ret += test_xmlTextReaderMoveToAttributeNo();
    test_ret += test_xmlTextReaderMoveToAttributeNs();
    test_ret += test_xmlTextReaderMoveToElement();
    test_ret += test_xmlTextReaderMoveToFirstAttribute();
    test_ret += test_xmlTextReaderMoveToNextAttribute();
    test_ret += test_xmlTextReaderName();
    test_ret += test_xmlTextReaderNamespaceUri();
    test_ret += test_xmlTextReaderNext();
    test_ret += test_xmlTextReaderNextSibling();
    test_ret += test_xmlTextReaderNodeType();
    test_ret += test_xmlTextReaderNormalization();
    test_ret += test_xmlTextReaderPrefix();
    test_ret += test_xmlTextReaderPreserve();
    test_ret += test_xmlTextReaderPreservePattern();
    test_ret += test_xmlTextReaderQuoteChar();
    test_ret += test_xmlTextReaderRead();
    test_ret += test_xmlTextReaderReadAttributeValue();
    test_ret += test_xmlTextReaderReadState();
    test_ret += test_xmlTextReaderRelaxNGSetSchema();
    test_ret += test_xmlTextReaderRelaxNGValidate();
    test_ret += test_xmlTextReaderRelaxNGValidateCtxt();
    test_ret += test_xmlTextReaderSchemaValidate();
    test_ret += test_xmlTextReaderSchemaValidateCtxt();
    test_ret += test_xmlTextReaderSetErrorHandler();
    test_ret += test_xmlTextReaderSetParserProp();
    test_ret += test_xmlTextReaderSetSchema();
    test_ret += test_xmlTextReaderSetStructuredErrorHandler();
    test_ret += test_xmlTextReaderSetup();
    test_ret += test_xmlTextReaderStandalone();
    test_ret += test_xmlTextReaderValue();
    test_ret += test_xmlTextReaderXmlLang();

    if (test_ret != 0)
 printf("Module xmlreader: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlExpCtxtNbCons(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlExpCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);

        ret_val = xmlExpCtxtNbCons(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlExpCtxtNbCons",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlExpCtxtNbNodes(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlExpCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);

        ret_val = xmlExpCtxtNbNodes(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlExpCtxtNbNodes",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlExpDump(void) {
    int test_ret = 0;


    int mem_base;
    xmlBufferPtr buf;
    int n_buf;
    xmlExpNodePtr expr;
    int n_expr;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_expr = 0;n_expr < 1;n_expr++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        expr = gen_xmlExpNodePtr(n_expr, 1);

        xmlExpDump(buf, expr);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_xmlExpNodePtr(n_expr, expr, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlExpDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_expr);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlExpExpDerive(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlExpGetLanguage(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlExpCtxtPtr ctxt;
    int n_ctxt;
    xmlExpNodePtr exp;
    int n_exp;
    xmlChar ** langList;
    int n_langList;
    int len;
    int n_len;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_exp = 0;n_exp < 1;n_exp++) {
    for (n_langList = 0;n_langList < 1;n_langList++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
        exp = gen_xmlExpNodePtr(n_exp, 1);
        langList = gen_const_xmlChar_ptr_ptr(n_langList, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlExpGetLanguage(ctxt, exp, (const xmlChar **)langList, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlExpNodePtr(n_exp, exp, 1);
        des_const_xmlChar_ptr_ptr(n_langList, (const xmlChar **)langList, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlExpGetLanguage",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_exp);
            printf(" %d", n_langList);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlExpGetStart(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlExpCtxtPtr ctxt;
    int n_ctxt;
    xmlExpNodePtr exp;
    int n_exp;
    xmlChar ** tokList;
    int n_tokList;
    int len;
    int n_len;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_exp = 0;n_exp < 1;n_exp++) {
    for (n_tokList = 0;n_tokList < 1;n_tokList++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
        exp = gen_xmlExpNodePtr(n_exp, 1);
        tokList = gen_const_xmlChar_ptr_ptr(n_tokList, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlExpGetStart(ctxt, exp, (const xmlChar **)tokList, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlExpNodePtr(n_exp, exp, 1);
        des_const_xmlChar_ptr_ptr(n_tokList, (const xmlChar **)tokList, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlExpGetStart",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_exp);
            printf(" %d", n_tokList);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlExpIsNillable(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlExpNodePtr exp;
    int n_exp;

    for (n_exp = 0;n_exp < 1;n_exp++) {
        mem_base = xmlMemBlocks();
        exp = gen_xmlExpNodePtr(n_exp, 0);

        ret_val = xmlExpIsNillable(exp);
        desret_int(ret_val);
        call_tests++;
        des_xmlExpNodePtr(n_exp, exp, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlExpIsNillable",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_exp);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlExpMaxToken(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlExpNodePtr expr;
    int n_expr;

    for (n_expr = 0;n_expr < 1;n_expr++) {
        mem_base = xmlMemBlocks();
        expr = gen_xmlExpNodePtr(n_expr, 0);

        ret_val = xmlExpMaxToken(expr);
        desret_int(ret_val);
        call_tests++;
        des_xmlExpNodePtr(n_expr, expr, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlExpMaxToken",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_expr);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlExpNewAtom(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlExpNewCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlExpNewOr(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlExpNewRange(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlExpNewSeq(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlExpParse(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlExpRef(void) {
    int test_ret = 0;


    int mem_base;
    xmlExpNodePtr exp;
    int n_exp;

    for (n_exp = 0;n_exp < 1;n_exp++) {
        mem_base = xmlMemBlocks();
        exp = gen_xmlExpNodePtr(n_exp, 0);

        xmlExpRef(exp);
        call_tests++;
        des_xmlExpNodePtr(n_exp, exp, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlExpRef",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_exp);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlExpStringDerive(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlExpSubsume(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlExpCtxtPtr ctxt;
    int n_ctxt;
    xmlExpNodePtr exp;
    int n_exp;
    xmlExpNodePtr sub;
    int n_sub;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_exp = 0;n_exp < 1;n_exp++) {
    for (n_sub = 0;n_sub < 1;n_sub++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlExpCtxtPtr(n_ctxt, 0);
        exp = gen_xmlExpNodePtr(n_exp, 1);
        sub = gen_xmlExpNodePtr(n_sub, 2);

        ret_val = xmlExpSubsume(ctxt, exp, sub);
        desret_int(ret_val);
        call_tests++;
        des_xmlExpCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlExpNodePtr(n_exp, exp, 1);
        des_xmlExpNodePtr(n_sub, sub, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlExpSubsume",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_exp);
            printf(" %d", n_sub);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}




static xmlRegExecCtxtPtr gen_xmlRegExecCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 33488 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 33488 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlRegExecCtxtPtr(int no __attribute__((unused)), xmlRegExecCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlRegExecErrInfo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRegExecCtxtPtr exec;
    int n_exec;
    xmlChar ** string;
    int n_string;
    int * nbval;
    int n_nbval;
    int * nbneg;
    int n_nbneg;
    xmlChar ** values;
    int n_values;
    int * terminal;
    int n_terminal;

    for (n_exec = 0;n_exec < 1;n_exec++) {
    for (n_string = 0;n_string < 1;n_string++) {
    for (n_nbval = 0;n_nbval < 2;n_nbval++) {
    for (n_nbneg = 0;n_nbneg < 2;n_nbneg++) {
    for (n_values = 0;n_values < 1;n_values++) {
    for (n_terminal = 0;n_terminal < 2;n_terminal++) {
        mem_base = xmlMemBlocks();
        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
        string = gen_const_xmlChar_ptr_ptr(n_string, 1);
        nbval = gen_int_ptr(n_nbval, 2);
        nbneg = gen_int_ptr(n_nbneg, 3);
        values = gen_xmlChar_ptr_ptr(n_values, 4);
        terminal = gen_int_ptr(n_terminal, 5);

        ret_val = xmlRegExecErrInfo(exec, (const xmlChar **)string, nbval, nbneg, values, terminal);
        desret_int(ret_val);
        call_tests++;
        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
        des_const_xmlChar_ptr_ptr(n_string, (const xmlChar **)string, 1);
        des_int_ptr(n_nbval, nbval, 2);
        des_int_ptr(n_nbneg, nbneg, 3);
        des_xmlChar_ptr_ptr(n_values, values, 4);
        des_int_ptr(n_terminal, terminal, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegExecErrInfo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_exec);
            printf(" %d", n_string);
            printf(" %d", n_nbval);
            printf(" %d", n_nbneg);
            printf(" %d", n_values);
            printf(" %d", n_terminal);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRegExecNextValues(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRegExecCtxtPtr exec;
    int n_exec;
    int * nbval;
    int n_nbval;
    int * nbneg;
    int n_nbneg;
    xmlChar ** values;
    int n_values;
    int * terminal;
    int n_terminal;

    for (n_exec = 0;n_exec < 1;n_exec++) {
    for (n_nbval = 0;n_nbval < 2;n_nbval++) {
    for (n_nbneg = 0;n_nbneg < 2;n_nbneg++) {
    for (n_values = 0;n_values < 1;n_values++) {
    for (n_terminal = 0;n_terminal < 2;n_terminal++) {
        mem_base = xmlMemBlocks();
        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
        nbval = gen_int_ptr(n_nbval, 1);
        nbneg = gen_int_ptr(n_nbneg, 2);
        values = gen_xmlChar_ptr_ptr(n_values, 3);
        terminal = gen_int_ptr(n_terminal, 4);

        ret_val = xmlRegExecNextValues(exec, nbval, nbneg, values, terminal);
        desret_int(ret_val);
        call_tests++;
        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
        des_int_ptr(n_nbval, nbval, 1);
        des_int_ptr(n_nbneg, nbneg, 2);
        des_xmlChar_ptr_ptr(n_values, values, 3);
        des_int_ptr(n_terminal, terminal, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegExecNextValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_exec);
            printf(" %d", n_nbval);
            printf(" %d", n_nbneg);
            printf(" %d", n_values);
            printf(" %d", n_terminal);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRegExecPushString(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRegExecCtxtPtr exec;
    int n_exec;
    xmlChar * value;
    int n_value;
    void * data;
    int n_data;

    for (n_exec = 0;n_exec < 1;n_exec++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        data = gen_userdata(n_data, 2);

        ret_val = xmlRegExecPushString(exec, (const xmlChar *)value, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        des_userdata(n_data, data, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegExecPushString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_exec);
            printf(" %d", n_value);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRegExecPushString2(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRegExecCtxtPtr exec;
    int n_exec;
    xmlChar * value;
    int n_value;
    xmlChar * value2;
    int n_value2;
    void * data;
    int n_data;

    for (n_exec = 0;n_exec < 1;n_exec++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_value2 = 0;n_value2 < 5;n_value2++) {
    for (n_data = 0;n_data < 3;n_data++) {
        mem_base = xmlMemBlocks();
        exec = gen_xmlRegExecCtxtPtr(n_exec, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        value2 = gen_const_xmlChar_ptr(n_value2, 2);
        data = gen_userdata(n_data, 3);

        ret_val = xmlRegExecPushString2(exec, (const xmlChar *)value, (const xmlChar *)value2, data);
        desret_int(ret_val);
        call_tests++;
        des_xmlRegExecCtxtPtr(n_exec, exec, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        des_const_xmlChar_ptr(n_value2, (const xmlChar *)value2, 2);
        des_userdata(n_data, data, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegExecPushString2",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_exec);
            printf(" %d", n_value);
            printf(" %d", n_value2);
            printf(" %d", n_data);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}




static xmlRegexpPtr gen_xmlRegexpPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 33732 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 33732 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlRegexpPtr(int no __attribute__((unused)), xmlRegexpPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlRegNewExecCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlRegexpCompile(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlRegexpExec(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRegexpPtr comp;
    int n_comp;
    xmlChar * content;
    int n_content;

    for (n_comp = 0;n_comp < 1;n_comp++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlRegexpPtr(n_comp, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlRegexpExec(comp, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlRegexpPtr(n_comp, comp, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegexpExec",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_comp);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRegexpIsDeterminist(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlRegexpPtr comp;
    int n_comp;

    for (n_comp = 0;n_comp < 1;n_comp++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlRegexpPtr(n_comp, 0);

        ret_val = xmlRegexpIsDeterminist(comp);
        desret_int(ret_val);
        call_tests++;
        des_xmlRegexpPtr(n_comp, comp, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegexpIsDeterminist",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_comp);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlRegexpPrint(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlRegexpPtr regexp;
    int n_regexp;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_regexp = 0;n_regexp < 1;n_regexp++) {
        mem_base = xmlMemBlocks();
        output = gen_FILE_ptr(n_output, 0);
        regexp = gen_xmlRegexpPtr(n_regexp, 1);

        xmlRegexpPrint(output, regexp);
        call_tests++;
        des_FILE_ptr(n_output, output, 0);
        des_xmlRegexpPtr(n_regexp, regexp, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlRegexpPrint",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_regexp);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xmlregexp(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlregexp : 16 of 30 functions ...\n");
    test_ret += test_xmlExpCtxtNbCons();
    test_ret += test_xmlExpCtxtNbNodes();
    test_ret += test_xmlExpDump();
    test_ret += test_xmlExpExpDerive();
    test_ret += test_xmlExpGetLanguage();
    test_ret += test_xmlExpGetStart();
    test_ret += test_xmlExpIsNillable();
    test_ret += test_xmlExpMaxToken();
    test_ret += test_xmlExpNewAtom();
    test_ret += test_xmlExpNewCtxt();
    test_ret += test_xmlExpNewOr();
    test_ret += test_xmlExpNewRange();
    test_ret += test_xmlExpNewSeq();
    test_ret += test_xmlExpParse();
    test_ret += test_xmlExpRef();
    test_ret += test_xmlExpStringDerive();
    test_ret += test_xmlExpSubsume();
    test_ret += test_xmlRegExecErrInfo();
    test_ret += test_xmlRegExecNextValues();
    test_ret += test_xmlRegExecPushString();
    test_ret += test_xmlRegExecPushString2();
    test_ret += test_xmlRegNewExecCtxt();
    test_ret += test_xmlRegexpCompile();
    test_ret += test_xmlRegexpExec();
    test_ret += test_xmlRegexpIsDeterminist();
    test_ret += test_xmlRegexpPrint();

    if (test_ret != 0)
 printf("Module xmlregexp: %d errors\n", test_ret);
    return(test_ret);
}



static xmlSaveCtxtPtr gen_xmlSaveCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 33912 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 33912 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSaveCtxtPtr(int no __attribute__((unused)), xmlSaveCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSaveClose(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSaveCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);

        ret_val = xmlSaveClose(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveClose",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSaveDoc(void) {
    int test_ret = 0;


    int mem_base;
    long ret_val;
    xmlSaveCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlSaveDoc(ctxt, doc);
        desret_long(ret_val);
        call_tests++;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSaveFlush(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSaveCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);

        ret_val = xmlSaveFlush(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveFlush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSaveSetAttrEscape(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSaveSetEscape(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSaveToBuffer(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSaveToFd(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSaveToFilename(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSaveTree(void) {
    int test_ret = 0;


    int mem_base;
    long ret_val;
    xmlSaveCtxtPtr ctxt;
    int n_ctxt;
    xmlNodePtr node;
    int n_node;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSaveCtxtPtr(n_ctxt, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlSaveTree(ctxt, node);
        desret_long(ret_val);
        call_tests++;
        des_xmlSaveCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSaveTree",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xmlsave(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlsave : 4 of 10 functions ...\n");
    test_ret += test_xmlSaveClose();
    test_ret += test_xmlSaveDoc();
    test_ret += test_xmlSaveFlush();
    test_ret += test_xmlSaveSetAttrEscape();
    test_ret += test_xmlSaveSetEscape();
    test_ret += test_xmlSaveToBuffer();
    test_ret += test_xmlSaveToFd();
    test_ret += test_xmlSaveToFilename();
    test_ret += test_xmlSaveTree();

    if (test_ret != 0)
 printf("Module xmlsave: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlSchemaDump(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlSchemaPtr schema;
    int n_schema;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_schema = 0;n_schema < 1;n_schema++) {
        mem_base = xmlMemBlocks();
        output = gen_FILE_ptr(n_output, 0);
        schema = gen_xmlSchemaPtr(n_schema, 1);

        xmlSchemaDump(output, schema);
        call_tests++;
        des_FILE_ptr(n_output, output, 0);
        des_xmlSchemaPtr(n_schema, schema, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaDump",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_schema);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}




static xmlSchemaParserCtxtPtr gen_xmlSchemaParserCtxtPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 34180 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 34180 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaParserCtxtPtr(int no __attribute__((unused)), xmlSchemaParserCtxtPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}





static xmlSchemaValidityErrorFunc * gen_xmlSchemaValidityErrorFunc_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 34190 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 34190 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaValidityErrorFunc_ptr(int no __attribute__((unused)), xmlSchemaValidityErrorFunc * val __attribute__((unused)), int nr __attribute__((unused))) {
}





static xmlSchemaValidityWarningFunc * gen_xmlSchemaValidityWarningFunc_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 34200 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 34200 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaValidityWarningFunc_ptr(int no __attribute__((unused)), xmlSchemaValidityWarningFunc * val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSchemaGetParserErrors(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaParserCtxtPtr ctxt;
    int n_ctxt;
    xmlSchemaValidityErrorFunc * err;
    int n_err;
    xmlSchemaValidityWarningFunc * warn;
    int n_warn;
    void ** ctx;
    int n_ctx;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_err = 0;n_err < 1;n_err++) {
    for (n_warn = 0;n_warn < 1;n_warn++) {
    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaParserCtxtPtr(n_ctxt, 0);
        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
        ctx = gen_void_ptr_ptr(n_ctx, 3);

        ret_val = xmlSchemaGetParserErrors(ctxt, err, warn, ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaParserCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
        des_void_ptr_ptr(n_ctx, ctx, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetParserErrors",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_err);
            printf(" %d", n_warn);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaGetValidErrors(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;
    xmlSchemaValidityErrorFunc * err;
    int n_err;
    xmlSchemaValidityWarningFunc * warn;
    int n_warn;
    void ** ctx;
    int n_ctx;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_err = 0;n_err < 1;n_err++) {
    for (n_warn = 0;n_warn < 1;n_warn++) {
    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        err = gen_xmlSchemaValidityErrorFunc_ptr(n_err, 1);
        warn = gen_xmlSchemaValidityWarningFunc_ptr(n_warn, 2);
        ctx = gen_void_ptr_ptr(n_ctx, 3);

        ret_val = xmlSchemaGetValidErrors(ctxt, err, warn, ctx);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlSchemaValidityErrorFunc_ptr(n_err, err, 1);
        des_xmlSchemaValidityWarningFunc_ptr(n_warn, warn, 2);
        des_void_ptr_ptr(n_ctx, ctx, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetValidErrors",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_err);
            printf(" %d", n_warn);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaIsValid(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);

        ret_val = xmlSchemaIsValid(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaIsValid",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaNewDocParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    xmlSchemaParserCtxtPtr ret_val;
    xmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlSchemaNewDocParserCtxt(doc);
        desret_xmlSchemaParserCtxtPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaNewDocParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaNewMemParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    xmlSchemaParserCtxtPtr ret_val;
    char * buffer;
    int n_buffer;
    int size;
    int n_size;

    for (n_buffer = 0;n_buffer < 4;n_buffer++) {
    for (n_size = 0;n_size < 4;n_size++) {
        mem_base = xmlMemBlocks();
        buffer = gen_const_char_ptr(n_buffer, 0);
        size = gen_int(n_size, 1);

        ret_val = xmlSchemaNewMemParserCtxt((const char *)buffer, size);
        desret_xmlSchemaParserCtxtPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_buffer, (const char *)buffer, 0);
        des_int(n_size, size, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaNewMemParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buffer);
            printf(" %d", n_size);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaNewParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    xmlSchemaParserCtxtPtr ret_val;
    char * URL;
    int n_URL;

    for (n_URL = 0;n_URL < 4;n_URL++) {
        mem_base = xmlMemBlocks();
        URL = gen_const_char_ptr(n_URL, 0);

        ret_val = xmlSchemaNewParserCtxt((const char *)URL);
        desret_xmlSchemaParserCtxtPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_URL, (const char *)URL, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaNewParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_URL);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaNewValidCtxt(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaParse(void) {
    int test_ret = 0;



    return(test_ret);
}




static xmlSAXHandlerPtr * gen_xmlSAXHandlerPtr_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 34483 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 34483 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSAXHandlerPtr_ptr(int no __attribute__((unused)), xmlSAXHandlerPtr * val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSchemaSAXPlug(void) {
    int test_ret = 0;



    return(test_ret);
}




static xmlSchemaSAXPlugPtr gen_xmlSchemaSAXPlugPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 34503 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 34503 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaSAXPlugPtr(int no __attribute__((unused)), xmlSchemaSAXPlugPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSchemaSAXUnplug(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaSAXPlugPtr plug;
    int n_plug;

    for (n_plug = 0;n_plug < 1;n_plug++) {
        mem_base = xmlMemBlocks();
        plug = gen_xmlSchemaSAXPlugPtr(n_plug, 0);

        ret_val = xmlSchemaSAXUnplug(plug);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaSAXPlugPtr(n_plug, plug, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaSAXUnplug",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_plug);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaSetParserErrors(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaSetParserStructuredErrors(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaSetValidErrors(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaSetValidOptions(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        options = gen_int(n_options, 1);

        ret_val = xmlSchemaSetValidOptions(ctxt, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_options, options, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaSetValidOptions",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaSetValidStructuredErrors(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaValidCtxtGetOptions(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);

        ret_val = xmlSchemaValidCtxtGetOptions(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidCtxtGetOptions",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidCtxtGetParserCtxt(void) {
    int test_ret = 0;


    int mem_base;
    xmlParserCtxtPtr ret_val;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);

        ret_val = xmlSchemaValidCtxtGetParserCtxt(ctxt);
        desret_xmlParserCtxtPtr(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidCtxtGetParserCtxt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateDoc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;
    xmlDocPtr doc;
    int n_doc;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        doc = gen_xmlDocPtr(n_doc, 1);

        ret_val = xmlSchemaValidateDoc(ctxt, doc);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlDocPtr(n_doc, doc, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateDoc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateFile(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;
    const char * filename;
    int n_filename;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        filename = gen_filepath(n_filename, 1);
        options = gen_int(n_options, 2);

        ret_val = xmlSchemaValidateFile(ctxt, filename, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_filepath(n_filename, filename, 1);
        des_int(n_options, options, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateFile",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_filename);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateOneElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;
    xmlNodePtr elem;
    int n_elem;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_elem = 0;n_elem < 3;n_elem++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        elem = gen_xmlNodePtr(n_elem, 1);

        ret_val = xmlSchemaValidateOneElement(ctxt, elem);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_elem, elem, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateOneElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_elem);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateSetFilename(void) {
    int test_ret = 0;


    int mem_base;
    xmlSchemaValidCtxtPtr vctxt;
    int n_vctxt;
    const char * filename;
    int n_filename;

    for (n_vctxt = 0;n_vctxt < 1;n_vctxt++) {
    for (n_filename = 0;n_filename < 8;n_filename++) {
        mem_base = xmlMemBlocks();
        vctxt = gen_xmlSchemaValidCtxtPtr(n_vctxt, 0);
        filename = gen_filepath(n_filename, 1);

        xmlSchemaValidateSetFilename(vctxt, filename);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_vctxt, vctxt, 0);
        des_filepath(n_filename, filename, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateSetFilename",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_vctxt);
            printf(" %d", n_filename);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateSetLocator(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaValidateStream(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValidCtxtPtr ctxt;
    int n_ctxt;
    xmlParserInputBufferPtr input;
    int n_input;
    xmlCharEncoding enc;
    int n_enc;
    xmlSAXHandlerPtr sax;
    int n_sax;
    void * user_data;
    int n_user_data;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_input = 0;n_input < 8;n_input++) {
    for (n_enc = 0;n_enc < 4;n_enc++) {
    for (n_sax = 0;n_sax < 2;n_sax++) {
    for (n_user_data = 0;n_user_data < 3;n_user_data++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlSchemaValidCtxtPtr(n_ctxt, 0);
        input = gen_xmlParserInputBufferPtr(n_input, 1);
        enc = gen_xmlCharEncoding(n_enc, 2);
        sax = gen_xmlSAXHandlerPtr(n_sax, 3);
        user_data = gen_userdata(n_user_data, 4);

        ret_val = xmlSchemaValidateStream(ctxt, input, enc, sax, user_data);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValidCtxtPtr(n_ctxt, ctxt, 0);
        des_xmlParserInputBufferPtr(n_input, input, 1);
        des_xmlCharEncoding(n_enc, enc, 2);
        des_xmlSAXHandlerPtr(n_sax, sax, 3);
        des_userdata(n_user_data, user_data, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateStream",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_input);
            printf(" %d", n_enc);
            printf(" %d", n_sax);
            printf(" %d", n_user_data);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xmlschemas(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlschemas : 16 of 27 functions ...\n");
    test_ret += test_xmlSchemaDump();
    test_ret += test_xmlSchemaGetParserErrors();
    test_ret += test_xmlSchemaGetValidErrors();
    test_ret += test_xmlSchemaIsValid();
    test_ret += test_xmlSchemaNewDocParserCtxt();
    test_ret += test_xmlSchemaNewMemParserCtxt();
    test_ret += test_xmlSchemaNewParserCtxt();
    test_ret += test_xmlSchemaNewValidCtxt();
    test_ret += test_xmlSchemaParse();
    test_ret += test_xmlSchemaSAXPlug();
    test_ret += test_xmlSchemaSAXUnplug();
    test_ret += test_xmlSchemaSetParserErrors();
    test_ret += test_xmlSchemaSetParserStructuredErrors();
    test_ret += test_xmlSchemaSetValidErrors();
    test_ret += test_xmlSchemaSetValidOptions();
    test_ret += test_xmlSchemaSetValidStructuredErrors();
    test_ret += test_xmlSchemaValidCtxtGetOptions();
    test_ret += test_xmlSchemaValidCtxtGetParserCtxt();
    test_ret += test_xmlSchemaValidateDoc();
    test_ret += test_xmlSchemaValidateFile();
    test_ret += test_xmlSchemaValidateOneElement();
    test_ret += test_xmlSchemaValidateSetFilename();
    test_ret += test_xmlSchemaValidateSetLocator();
    test_ret += test_xmlSchemaValidateStream();

    if (test_ret != 0)
 printf("Module xmlschemas: %d errors\n", test_ret);
    return(test_ret);
}



static xmlSchemaFacetPtr gen_xmlSchemaFacetPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 34971 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 34971 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaFacetPtr(int no __attribute__((unused)), xmlSchemaFacetPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}





static xmlSchemaTypePtr gen_xmlSchemaTypePtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 34981 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 34981 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaTypePtr(int no __attribute__((unused)), xmlSchemaTypePtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSchemaCheckFacet(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaFacetPtr facet;
    int n_facet;
    xmlSchemaTypePtr typeDecl;
    int n_typeDecl;
    xmlSchemaParserCtxtPtr pctxt;
    int n_pctxt;
    xmlChar * name;
    int n_name;

    for (n_facet = 0;n_facet < 1;n_facet++) {
    for (n_typeDecl = 0;n_typeDecl < 1;n_typeDecl++) {
    for (n_pctxt = 0;n_pctxt < 1;n_pctxt++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
        typeDecl = gen_xmlSchemaTypePtr(n_typeDecl, 1);
        pctxt = gen_xmlSchemaParserCtxtPtr(n_pctxt, 2);
        name = gen_const_xmlChar_ptr(n_name, 3);

        ret_val = xmlSchemaCheckFacet(facet, typeDecl, pctxt, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaFacetPtr(n_facet, facet, 0);
        des_xmlSchemaTypePtr(n_typeDecl, typeDecl, 1);
        des_xmlSchemaParserCtxtPtr(n_pctxt, pctxt, 2);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCheckFacet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_facet);
            printf(" %d", n_typeDecl);
            printf(" %d", n_pctxt);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaCleanupTypes(void) {
    int test_ret = 0;




        xmlSchemaCleanupTypes();
        call_tests++;
        xmlResetLastError();
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaCollapseString(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlChar * value;
    int n_value;

    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlSchemaCollapseString((const xmlChar *)value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCollapseString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}




static xmlSchemaValPtr gen_xmlSchemaValPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 35097 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 35097 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaValPtr(int no __attribute__((unused)), xmlSchemaValPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSchemaCompareValues(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValPtr x;
    int n_x;
    xmlSchemaValPtr y;
    int n_y;

    for (n_x = 0;n_x < 1;n_x++) {
    for (n_y = 0;n_y < 1;n_y++) {
        mem_base = xmlMemBlocks();
        x = gen_xmlSchemaValPtr(n_x, 0);
        y = gen_xmlSchemaValPtr(n_y, 1);

        ret_val = xmlSchemaCompareValues(x, y);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValPtr(n_x, x, 0);
        des_xmlSchemaValPtr(n_y, y, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCompareValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_x);
            printf(" %d", n_y);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaCompareValuesWhtsp(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValPtr x;
    int n_x;
    xmlSchemaWhitespaceValueType xws;
    int n_xws;
    xmlSchemaValPtr y;
    int n_y;
    xmlSchemaWhitespaceValueType yws;
    int n_yws;

    for (n_x = 0;n_x < 1;n_x++) {
    for (n_xws = 0;n_xws < 4;n_xws++) {
    for (n_y = 0;n_y < 1;n_y++) {
    for (n_yws = 0;n_yws < 4;n_yws++) {
        mem_base = xmlMemBlocks();
        x = gen_xmlSchemaValPtr(n_x, 0);
        xws = gen_xmlSchemaWhitespaceValueType(n_xws, 1);
        y = gen_xmlSchemaValPtr(n_y, 2);
        yws = gen_xmlSchemaWhitespaceValueType(n_yws, 3);

        ret_val = xmlSchemaCompareValuesWhtsp(x, xws, y, yws);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValPtr(n_x, x, 0);
        des_xmlSchemaWhitespaceValueType(n_xws, xws, 1);
        des_xmlSchemaValPtr(n_y, y, 2);
        des_xmlSchemaWhitespaceValueType(n_yws, yws, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaCompareValuesWhtsp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_x);
            printf(" %d", n_xws);
            printf(" %d", n_y);
            printf(" %d", n_yws);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaCopyValue(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaGetBuiltInListSimpleTypeItemType(void) {
    int test_ret = 0;


    int mem_base;
    xmlSchemaTypePtr ret_val;
    xmlSchemaTypePtr type;
    int n_type;

    for (n_type = 0;n_type < 1;n_type++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);

        ret_val = xmlSchemaGetBuiltInListSimpleTypeItemType(type);
        desret_xmlSchemaTypePtr(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetBuiltInListSimpleTypeItemType",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_type);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaGetBuiltInType(void) {
    int test_ret = 0;


    xmlSchemaTypePtr ret_val;
    xmlSchemaValType type;
    int n_type;

    for (n_type = 0;n_type < 4;n_type++) {
        type = gen_xmlSchemaValType(n_type, 0);

        ret_val = xmlSchemaGetBuiltInType(type);
        desret_xmlSchemaTypePtr(ret_val);
        call_tests++;
        des_xmlSchemaValType(n_type, type, 0);
        xmlResetLastError();
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaGetCanonValue(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValPtr val;
    int n_val;
    xmlChar ** retValue;
    int n_retValue;

    for (n_val = 0;n_val < 1;n_val++) {
    for (n_retValue = 0;n_retValue < 1;n_retValue++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlSchemaValPtr(n_val, 0);
        retValue = gen_const_xmlChar_ptr_ptr(n_retValue, 1);

        ret_val = xmlSchemaGetCanonValue(val, (const xmlChar **)retValue);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValPtr(n_val, val, 0);
        des_const_xmlChar_ptr_ptr(n_retValue, (const xmlChar **)retValue, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetCanonValue",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf(" %d", n_retValue);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaGetCanonValueWhtsp(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValPtr val;
    int n_val;
    xmlChar ** retValue;
    int n_retValue;
    xmlSchemaWhitespaceValueType ws;
    int n_ws;

    for (n_val = 0;n_val < 1;n_val++) {
    for (n_retValue = 0;n_retValue < 1;n_retValue++) {
    for (n_ws = 0;n_ws < 4;n_ws++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlSchemaValPtr(n_val, 0);
        retValue = gen_const_xmlChar_ptr_ptr(n_retValue, 1);
        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 2);

        ret_val = xmlSchemaGetCanonValueWhtsp(val, (const xmlChar **)retValue, ws);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValPtr(n_val, val, 0);
        des_const_xmlChar_ptr_ptr(n_retValue, (const xmlChar **)retValue, 1);
        des_xmlSchemaWhitespaceValueType(n_ws, ws, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetCanonValueWhtsp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf(" %d", n_retValue);
            printf(" %d", n_ws);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaGetFacetValueAsULong(void) {
    int test_ret = 0;


    int mem_base;
    unsigned long ret_val;
    xmlSchemaFacetPtr facet;
    int n_facet;

    for (n_facet = 0;n_facet < 1;n_facet++) {
        mem_base = xmlMemBlocks();
        facet = gen_xmlSchemaFacetPtr(n_facet, 0);

        ret_val = xmlSchemaGetFacetValueAsULong(facet);
        desret_unsigned_long(ret_val);
        call_tests++;
        des_xmlSchemaFacetPtr(n_facet, facet, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetFacetValueAsULong",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_facet);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaGetPredefinedType(void) {
    int test_ret = 0;


    int mem_base;
    xmlSchemaTypePtr ret_val;
    xmlChar * name;
    int n_name;
    xmlChar * ns;
    int n_ns;

    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ns = 0;n_ns < 5;n_ns++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);
        ns = gen_const_xmlChar_ptr(n_ns, 1);

        ret_val = xmlSchemaGetPredefinedType((const xmlChar *)name, (const xmlChar *)ns);
        desret_xmlSchemaTypePtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        des_const_xmlChar_ptr(n_ns, (const xmlChar *)ns, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetPredefinedType",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf(" %d", n_ns);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaGetValType(void) {
    int test_ret = 0;


    int mem_base;
    xmlSchemaValType ret_val;
    xmlSchemaValPtr val;
    int n_val;

    for (n_val = 0;n_val < 1;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlSchemaValPtr(n_val, 0);

        ret_val = xmlSchemaGetValType(val);
        desret_xmlSchemaValType(ret_val);
        call_tests++;
        des_xmlSchemaValPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaGetValType",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaInitTypes(void) {
    int test_ret = 0;




        xmlSchemaInitTypes();
        call_tests++;
        xmlResetLastError();
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaIsBuiltInTypeFacet(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type;
    int n_type;
    int facetType;
    int n_facetType;

    for (n_type = 0;n_type < 1;n_type++) {
    for (n_facetType = 0;n_facetType < 4;n_facetType++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        facetType = gen_int(n_facetType, 1);

        ret_val = xmlSchemaIsBuiltInTypeFacet(type, facetType);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_int(n_facetType, facetType, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaIsBuiltInTypeFacet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_type);
            printf(" %d", n_facetType);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaNewFacet(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaNewNOTATIONValue(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaNewQNameValue(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaNewStringValue(void) {
    int test_ret = 0;



    return(test_ret);
}




static xmlSchemaValPtr * gen_xmlSchemaValPtr_ptr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 35568 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 35568 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlSchemaValPtr_ptr(int no __attribute__((unused)), xmlSchemaValPtr * val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlSchemaValPredefTypeNode(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type;
    int n_type;
    xmlChar * value;
    int n_value;
    xmlSchemaValPtr * val;
    int n_val;
    xmlNodePtr node;
    int n_node;

    for (n_type = 0;n_type < 1;n_type++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_val = 0;n_val < 1;n_val++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
        node = gen_xmlNodePtr(n_node, 3);

        ret_val = xmlSchemaValPredefTypeNode(type, (const xmlChar *)value, val, node);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        des_xmlSchemaValPtr_ptr(n_val, val, 2);
        des_xmlNodePtr(n_node, node, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_type);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValPredefTypeNodeNoNorm(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type;
    int n_type;
    xmlChar * value;
    int n_value;
    xmlSchemaValPtr * val;
    int n_val;
    xmlNodePtr node;
    int n_node;

    for (n_type = 0;n_type < 1;n_type++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_val = 0;n_val < 1;n_val++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        val = gen_xmlSchemaValPtr_ptr(n_val, 2);
        node = gen_xmlNodePtr(n_node, 3);

        ret_val = xmlSchemaValPredefTypeNodeNoNorm(type, (const xmlChar *)value, val, node);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        des_xmlSchemaValPtr_ptr(n_val, val, 2);
        des_xmlNodePtr(n_node, node, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValPredefTypeNodeNoNorm",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_type);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateFacet(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaTypePtr base;
    int n_base;
    xmlSchemaFacetPtr facet;
    int n_facet;
    xmlChar * value;
    int n_value;
    xmlSchemaValPtr val;
    int n_val;

    for (n_base = 0;n_base < 1;n_base++) {
    for (n_facet = 0;n_facet < 1;n_facet++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_val = 0;n_val < 1;n_val++) {
        mem_base = xmlMemBlocks();
        base = gen_xmlSchemaTypePtr(n_base, 0);
        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);
        val = gen_xmlSchemaValPtr(n_val, 3);

        ret_val = xmlSchemaValidateFacet(base, facet, (const xmlChar *)value, val);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_base, base, 0);
        des_xmlSchemaFacetPtr(n_facet, facet, 1);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
        des_xmlSchemaValPtr(n_val, val, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateFacet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_base);
            printf(" %d", n_facet);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateFacetWhtsp(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaFacetPtr facet;
    int n_facet;
    xmlSchemaWhitespaceValueType fws;
    int n_fws;
    xmlSchemaValType valType;
    int n_valType;
    xmlChar * value;
    int n_value;
    xmlSchemaValPtr val;
    int n_val;
    xmlSchemaWhitespaceValueType ws;
    int n_ws;

    for (n_facet = 0;n_facet < 1;n_facet++) {
    for (n_fws = 0;n_fws < 4;n_fws++) {
    for (n_valType = 0;n_valType < 4;n_valType++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_val = 0;n_val < 1;n_val++) {
    for (n_ws = 0;n_ws < 4;n_ws++) {
        mem_base = xmlMemBlocks();
        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
        fws = gen_xmlSchemaWhitespaceValueType(n_fws, 1);
        valType = gen_xmlSchemaValType(n_valType, 2);
        value = gen_const_xmlChar_ptr(n_value, 3);
        val = gen_xmlSchemaValPtr(n_val, 4);
        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 5);

        ret_val = xmlSchemaValidateFacetWhtsp(facet, fws, valType, (const xmlChar *)value, val, ws);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaFacetPtr(n_facet, facet, 0);
        des_xmlSchemaWhitespaceValueType(n_fws, fws, 1);
        des_xmlSchemaValType(n_valType, valType, 2);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 3);
        des_xmlSchemaValPtr(n_val, val, 4);
        des_xmlSchemaWhitespaceValueType(n_ws, ws, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateFacetWhtsp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_facet);
            printf(" %d", n_fws);
            printf(" %d", n_valType);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf(" %d", n_ws);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateLengthFacet(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type;
    int n_type;
    xmlSchemaFacetPtr facet;
    int n_facet;
    xmlChar * value;
    int n_value;
    xmlSchemaValPtr val;
    int n_val;
    unsigned long * length;
    int n_length;

    for (n_type = 0;n_type < 1;n_type++) {
    for (n_facet = 0;n_facet < 1;n_facet++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_val = 0;n_val < 1;n_val++) {
    for (n_length = 0;n_length < 2;n_length++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        facet = gen_xmlSchemaFacetPtr(n_facet, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);
        val = gen_xmlSchemaValPtr(n_val, 3);
        length = gen_unsigned_long_ptr(n_length, 4);

        ret_val = xmlSchemaValidateLengthFacet(type, facet, (const xmlChar *)value, val, length);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_xmlSchemaFacetPtr(n_facet, facet, 1);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
        des_xmlSchemaValPtr(n_val, val, 3);
        des_unsigned_long_ptr(n_length, length, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateLengthFacet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_type);
            printf(" %d", n_facet);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf(" %d", n_length);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateLengthFacetWhtsp(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaFacetPtr facet;
    int n_facet;
    xmlSchemaValType valType;
    int n_valType;
    xmlChar * value;
    int n_value;
    xmlSchemaValPtr val;
    int n_val;
    unsigned long * length;
    int n_length;
    xmlSchemaWhitespaceValueType ws;
    int n_ws;

    for (n_facet = 0;n_facet < 1;n_facet++) {
    for (n_valType = 0;n_valType < 4;n_valType++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_val = 0;n_val < 1;n_val++) {
    for (n_length = 0;n_length < 2;n_length++) {
    for (n_ws = 0;n_ws < 4;n_ws++) {
        mem_base = xmlMemBlocks();
        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
        valType = gen_xmlSchemaValType(n_valType, 1);
        value = gen_const_xmlChar_ptr(n_value, 2);
        val = gen_xmlSchemaValPtr(n_val, 3);
        length = gen_unsigned_long_ptr(n_length, 4);
        ws = gen_xmlSchemaWhitespaceValueType(n_ws, 5);

        ret_val = xmlSchemaValidateLengthFacetWhtsp(facet, valType, (const xmlChar *)value, val, length, ws);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaFacetPtr(n_facet, facet, 0);
        des_xmlSchemaValType(n_valType, valType, 1);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 2);
        des_xmlSchemaValPtr(n_val, val, 3);
        des_unsigned_long_ptr(n_length, length, 4);
        des_xmlSchemaWhitespaceValueType(n_ws, ws, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateLengthFacetWhtsp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_facet);
            printf(" %d", n_valType);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf(" %d", n_length);
            printf(" %d", n_ws);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidateListSimpleTypeFacet(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaFacetPtr facet;
    int n_facet;
    xmlChar * value;
    int n_value;
    unsigned long actualLen;
    int n_actualLen;
    unsigned long * expectedLen;
    int n_expectedLen;

    for (n_facet = 0;n_facet < 1;n_facet++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_actualLen = 0;n_actualLen < 4;n_actualLen++) {
    for (n_expectedLen = 0;n_expectedLen < 2;n_expectedLen++) {
        mem_base = xmlMemBlocks();
        facet = gen_xmlSchemaFacetPtr(n_facet, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        actualLen = gen_unsigned_long(n_actualLen, 2);
        expectedLen = gen_unsigned_long_ptr(n_expectedLen, 3);

        ret_val = xmlSchemaValidateListSimpleTypeFacet(facet, (const xmlChar *)value, actualLen, expectedLen);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaFacetPtr(n_facet, facet, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        des_unsigned_long(n_actualLen, actualLen, 2);
        des_unsigned_long_ptr(n_expectedLen, expectedLen, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidateListSimpleTypeFacet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_facet);
            printf(" %d", n_value);
            printf(" %d", n_actualLen);
            printf(" %d", n_expectedLen);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValidatePredefinedType(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaTypePtr type;
    int n_type;
    xmlChar * value;
    int n_value;
    xmlSchemaValPtr * val;
    int n_val;

    for (n_type = 0;n_type < 1;n_type++) {
    for (n_value = 0;n_value < 5;n_value++) {
    for (n_val = 0;n_val < 1;n_val++) {
        mem_base = xmlMemBlocks();
        type = gen_xmlSchemaTypePtr(n_type, 0);
        value = gen_const_xmlChar_ptr(n_value, 1);
        val = gen_xmlSchemaValPtr_ptr(n_val, 2);

        ret_val = xmlSchemaValidatePredefinedType(type, (const xmlChar *)value, val);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaTypePtr(n_type, type, 0);
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 1);
        des_xmlSchemaValPtr_ptr(n_val, val, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValidatePredefinedType",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_type);
            printf(" %d", n_value);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValueAppend(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValPtr prev;
    int n_prev;
    xmlSchemaValPtr cur;
    int n_cur;

    for (n_prev = 0;n_prev < 1;n_prev++) {
    for (n_cur = 0;n_cur < 1;n_cur++) {
        mem_base = xmlMemBlocks();
        prev = gen_xmlSchemaValPtr(n_prev, 0);
        cur = gen_xmlSchemaValPtr(n_cur, 1);

        ret_val = xmlSchemaValueAppend(prev, cur);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValPtr(n_prev, prev, 0);
        des_xmlSchemaValPtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValueAppend",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_prev);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValueGetAsBoolean(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlSchemaValPtr val;
    int n_val;

    for (n_val = 0;n_val < 1;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlSchemaValPtr(n_val, 0);

        ret_val = xmlSchemaValueGetAsBoolean(val);
        desret_int(ret_val);
        call_tests++;
        des_xmlSchemaValPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValueGetAsBoolean",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValueGetAsString(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlSchemaValPtr val;
    int n_val;

    for (n_val = 0;n_val < 1;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlSchemaValPtr(n_val, 0);

        ret_val = xmlSchemaValueGetAsString(val);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlSchemaValPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaValueGetAsString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlSchemaValueGetNext(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlSchemaWhiteSpaceReplace(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlChar * value;
    int n_value;

    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        value = gen_const_xmlChar_ptr(n_value, 0);

        ret_val = xmlSchemaWhiteSpaceReplace((const xmlChar *)value);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_value, (const xmlChar *)value, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlSchemaWhiteSpaceReplace",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_value);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xmlschemastypes(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlschemastypes : 26 of 34 functions ...\n");
    test_ret += test_xmlSchemaCheckFacet();
    test_ret += test_xmlSchemaCleanupTypes();
    test_ret += test_xmlSchemaCollapseString();
    test_ret += test_xmlSchemaCompareValues();
    test_ret += test_xmlSchemaCompareValuesWhtsp();
    test_ret += test_xmlSchemaCopyValue();
    test_ret += test_xmlSchemaGetBuiltInListSimpleTypeItemType();
    test_ret += test_xmlSchemaGetBuiltInType();
    test_ret += test_xmlSchemaGetCanonValue();
    test_ret += test_xmlSchemaGetCanonValueWhtsp();
    test_ret += test_xmlSchemaGetFacetValueAsULong();
    test_ret += test_xmlSchemaGetPredefinedType();
    test_ret += test_xmlSchemaGetValType();
    test_ret += test_xmlSchemaInitTypes();
    test_ret += test_xmlSchemaIsBuiltInTypeFacet();
    test_ret += test_xmlSchemaNewFacet();
    test_ret += test_xmlSchemaNewNOTATIONValue();
    test_ret += test_xmlSchemaNewQNameValue();
    test_ret += test_xmlSchemaNewStringValue();
    test_ret += test_xmlSchemaValPredefTypeNode();
    test_ret += test_xmlSchemaValPredefTypeNodeNoNorm();
    test_ret += test_xmlSchemaValidateFacet();
    test_ret += test_xmlSchemaValidateFacetWhtsp();
    test_ret += test_xmlSchemaValidateLengthFacet();
    test_ret += test_xmlSchemaValidateLengthFacetWhtsp();
    test_ret += test_xmlSchemaValidateListSimpleTypeFacet();
    test_ret += test_xmlSchemaValidatePredefinedType();
    test_ret += test_xmlSchemaValueAppend();
    test_ret += test_xmlSchemaValueGetAsBoolean();
    test_ret += test_xmlSchemaValueGetAsString();
    test_ret += test_xmlSchemaValueGetNext();
    test_ret += test_xmlSchemaWhiteSpaceReplace();

    if (test_ret != 0)
 printf("Module xmlschemastypes: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlCharStrdup(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    char * cur;
    int n_cur;

    for (n_cur = 0;n_cur < 4;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_char_ptr(n_cur, 0);

        ret_val = xmlCharStrdup((const char *)cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_cur, (const char *)cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharStrdup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCharStrndup(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    char * cur;
    int n_cur;
    int len;
    int n_len;

    for (n_cur = 0;n_cur < 4;n_cur++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_char_ptr(n_cur, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlCharStrndup((const char *)cur, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_char_ptr(n_cur, (const char *)cur, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCharStrndup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlCheckUTF8(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned char * utf;
    int n_utf;

    for (n_utf = 0;n_utf < 1;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_unsigned_char_ptr(n_utf, 0);

        ret_val = xmlCheckUTF8((const unsigned char *)utf);
        desret_int(ret_val);
        call_tests++;
        des_const_unsigned_char_ptr(n_utf, (const unsigned char *)utf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlCheckUTF8",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlGetUTF8Char(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    unsigned char * utf;
    int n_utf;
    int * len;
    int n_len;

    for (n_utf = 0;n_utf < 1;n_utf++) {
    for (n_len = 0;n_len < 2;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_unsigned_char_ptr(n_utf, 0);
        len = gen_int_ptr(n_len, 1);

        ret_val = xmlGetUTF8Char((const unsigned char *)utf, len);
        desret_int(ret_val);
        call_tests++;
        des_const_unsigned_char_ptr(n_utf, (const unsigned char *)utf, 0);
        des_int_ptr(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlGetUTF8Char",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrEqual(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1;
    int n_str1;
    xmlChar * str2;
    int n_str2;

    for (n_str1 = 0;n_str1 < 5;n_str1++) {
    for (n_str2 = 0;n_str2 < 5;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);

        ret_val = xmlStrEqual((const xmlChar *)str1, (const xmlChar *)str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrEqual",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrPrintf(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlStrQEqual(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * pref;
    int n_pref;
    xmlChar * name;
    int n_name;
    xmlChar * str;
    int n_str;

    for (n_pref = 0;n_pref < 5;n_pref++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_str = 0;n_str < 5;n_str++) {
        mem_base = xmlMemBlocks();
        pref = gen_const_xmlChar_ptr(n_pref, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        str = gen_const_xmlChar_ptr(n_str, 2);

        ret_val = xmlStrQEqual((const xmlChar *)pref, (const xmlChar *)name, (const xmlChar *)str);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_pref, (const xmlChar *)pref, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrQEqual",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_pref);
            printf(" %d", n_name);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrVPrintf(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlStrcasecmp(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1;
    int n_str1;
    xmlChar * str2;
    int n_str2;

    for (n_str1 = 0;n_str1 < 5;n_str1++) {
    for (n_str2 = 0;n_str2 < 5;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);

        ret_val = xmlStrcasecmp((const xmlChar *)str1, (const xmlChar *)str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcasecmp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrcasestr(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlChar * str;
    int n_str;
    xmlChar * val;
    int n_val;

    for (n_str = 0;n_str < 5;n_str++) {
    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        val = gen_const_xmlChar_ptr(n_val, 1);

        ret_val = xmlStrcasestr((const xmlChar *)str, (const xmlChar *)val);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcasestr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrchr(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlChar * str;
    int n_str;
    xmlChar val;
    int n_val;

    for (n_str = 0;n_str < 5;n_str++) {
    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        val = gen_xmlChar(n_val, 1);

        ret_val = xmlStrchr((const xmlChar *)str, val);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        des_xmlChar(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrchr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrcmp(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1;
    int n_str1;
    xmlChar * str2;
    int n_str2;

    for (n_str1 = 0;n_str1 < 5;n_str1++) {
    for (n_str2 = 0;n_str2 < 5;n_str2++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);

        ret_val = xmlStrcmp((const xmlChar *)str1, (const xmlChar *)str2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrcmp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrdup(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * cur;
    int n_cur;

    for (n_cur = 0;n_cur < 5;n_cur++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);

        ret_val = xmlStrdup((const xmlChar *)cur);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrdup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrlen(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str;
    int n_str;

    for (n_str = 0;n_str < 5;n_str++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);

        ret_val = xmlStrlen((const xmlChar *)str);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrlen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrncasecmp(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1;
    int n_str1;
    xmlChar * str2;
    int n_str2;
    int len;
    int n_len;

    for (n_str1 = 0;n_str1 < 5;n_str1++) {
    for (n_str2 = 0;n_str2 < 5;n_str2++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrncasecmp((const xmlChar *)str1, (const xmlChar *)str2, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncasecmp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrncatNew(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * str1;
    int n_str1;
    xmlChar * str2;
    int n_str2;
    int len;
    int n_len;

    for (n_str1 = 0;n_str1 < 5;n_str1++) {
    for (n_str2 = 0;n_str2 < 5;n_str2++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrncatNew((const xmlChar *)str1, (const xmlChar *)str2, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncatNew",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrncmp(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * str1;
    int n_str1;
    xmlChar * str2;
    int n_str2;
    int len;
    int n_len;

    for (n_str1 = 0;n_str1 < 5;n_str1++) {
    for (n_str2 = 0;n_str2 < 5;n_str2++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        str1 = gen_const_xmlChar_ptr(n_str1, 0);
        str2 = gen_const_xmlChar_ptr(n_str2, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrncmp((const xmlChar *)str1, (const xmlChar *)str2, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str1, (const xmlChar *)str1, 0);
        des_const_xmlChar_ptr(n_str2, (const xmlChar *)str2, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrncmp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str1);
            printf(" %d", n_str2);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrndup(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * cur;
    int n_cur;
    int len;
    int n_len;

    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        cur = gen_const_xmlChar_ptr(n_cur, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlStrndup((const xmlChar *)cur, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_cur, (const xmlChar *)cur, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrndup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrstr(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlChar * str;
    int n_str;
    xmlChar * val;
    int n_val;

    for (n_str = 0;n_str < 5;n_str++) {
    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        val = gen_const_xmlChar_ptr(n_val, 1);

        ret_val = xmlStrstr((const xmlChar *)str, (const xmlChar *)val);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrstr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlStrsub(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * str;
    int n_str;
    int start;
    int n_start;
    int len;
    int n_len;

    for (n_str = 0;n_str < 5;n_str++) {
    for (n_start = 0;n_start < 4;n_start++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        start = gen_int(n_start, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlStrsub((const xmlChar *)str, start, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        des_int(n_start, start, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlStrsub",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlUTF8Charcmp(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf1;
    int n_utf1;
    xmlChar * utf2;
    int n_utf2;

    for (n_utf1 = 0;n_utf1 < 5;n_utf1++) {
    for (n_utf2 = 0;n_utf2 < 5;n_utf2++) {
        mem_base = xmlMemBlocks();
        utf1 = gen_const_xmlChar_ptr(n_utf1, 0);
        utf2 = gen_const_xmlChar_ptr(n_utf2, 1);

        ret_val = xmlUTF8Charcmp((const xmlChar *)utf1, (const xmlChar *)utf2);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf1, (const xmlChar *)utf1, 0);
        des_const_xmlChar_ptr(n_utf2, (const xmlChar *)utf2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Charcmp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf1);
            printf(" %d", n_utf2);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlUTF8Size(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf;
    int n_utf;

    for (n_utf = 0;n_utf < 5;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);

        ret_val = xmlUTF8Size((const xmlChar *)utf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Size",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlUTF8Strlen(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf;
    int n_utf;

    for (n_utf = 0;n_utf < 5;n_utf++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);

        ret_val = xmlUTF8Strlen((const xmlChar *)utf);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strlen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf);
            printf("\n");
        }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlUTF8Strloc(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf;
    int n_utf;
    xmlChar * utfchar;
    int n_utfchar;

    for (n_utf = 0;n_utf < 5;n_utf++) {
    for (n_utfchar = 0;n_utfchar < 5;n_utfchar++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        utfchar = gen_const_xmlChar_ptr(n_utfchar, 1);

        ret_val = xmlUTF8Strloc((const xmlChar *)utf, (const xmlChar *)utfchar);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
        des_const_xmlChar_ptr(n_utfchar, (const xmlChar *)utfchar, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strloc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf);
            printf(" %d", n_utfchar);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlUTF8Strndup(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * utf;
    int n_utf;
    int len;
    int n_len;

    for (n_utf = 0;n_utf < 5;n_utf++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlUTF8Strndup((const xmlChar *)utf, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strndup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlUTF8Strpos(void) {
    int test_ret = 0;

    int mem_base;
    const xmlChar * ret_val;
    xmlChar * utf;
    int n_utf;
    int pos;
    int n_pos;

    for (n_utf = 0;n_utf < 5;n_utf++) {
    for (n_pos = 0;n_pos < 4;n_pos++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        pos = gen_int(n_pos, 1);

        ret_val = xmlUTF8Strpos((const xmlChar *)utf, pos);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
        des_int(n_pos, pos, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strpos",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf);
            printf(" %d", n_pos);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlUTF8Strsize(void) {
    int test_ret = 0;

    int mem_base;
    int ret_val;
    xmlChar * utf;
    int n_utf;
    int len;
    int n_len;

    for (n_utf = 0;n_utf < 5;n_utf++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        len = gen_int(n_len, 1);

        ret_val = xmlUTF8Strsize((const xmlChar *)utf, len);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
        des_int(n_len, len, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strsize",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    function_tests++;

    return(test_ret);
}


static int
test_xmlUTF8Strsub(void) {
    int test_ret = 0;

    int mem_base;
    xmlChar * ret_val;
    xmlChar * utf;
    int n_utf;
    int start;
    int n_start;
    int len;
    int n_len;

    for (n_utf = 0;n_utf < 5;n_utf++) {
    for (n_start = 0;n_start < 4;n_start++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        utf = gen_const_xmlChar_ptr(n_utf, 0);
        start = gen_int(n_start, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlUTF8Strsub((const xmlChar *)utf, start, len);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_utf, (const xmlChar *)utf, 0);
        des_int(n_start, start, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUTF8Strsub",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_utf);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;

    return(test_ret);
}

static int
test_xmlstring(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlstring : 26 of 30 functions ...\n");
    test_ret += test_xmlCharStrdup();
    test_ret += test_xmlCharStrndup();
    test_ret += test_xmlCheckUTF8();
    test_ret += test_xmlGetUTF8Char();
    test_ret += test_xmlStrEqual();
    test_ret += test_xmlStrPrintf();
    test_ret += test_xmlStrQEqual();
    test_ret += test_xmlStrVPrintf();
    test_ret += test_xmlStrcasecmp();
    test_ret += test_xmlStrcasestr();
    test_ret += test_xmlStrchr();
    test_ret += test_xmlStrcmp();
    test_ret += test_xmlStrdup();
    test_ret += test_xmlStrlen();
    test_ret += test_xmlStrncasecmp();
    test_ret += test_xmlStrncatNew();
    test_ret += test_xmlStrncmp();
    test_ret += test_xmlStrndup();
    test_ret += test_xmlStrstr();
    test_ret += test_xmlStrsub();
    test_ret += test_xmlUTF8Charcmp();
    test_ret += test_xmlUTF8Size();
    test_ret += test_xmlUTF8Strlen();
    test_ret += test_xmlUTF8Strloc();
    test_ret += test_xmlUTF8Strndup();
    test_ret += test_xmlUTF8Strpos();
    test_ret += test_xmlUTF8Strsize();
    test_ret += test_xmlUTF8Strsub();

    if (test_ret != 0)
 printf("Module xmlstring: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlUCSIsAegeanNumbers(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsAegeanNumbers(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsAegeanNumbers",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsAlphabeticPresentationForms(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsAlphabeticPresentationForms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsAlphabeticPresentationForms",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsArabic(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArabic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArabic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsArabicPresentationFormsA(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArabicPresentationFormsA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArabicPresentationFormsA",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsArabicPresentationFormsB(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArabicPresentationFormsB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArabicPresentationFormsB",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsArmenian(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArmenian(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArmenian",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsArrows(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsArrows(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsArrows",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsBasicLatin(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBasicLatin(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBasicLatin",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsBengali(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBengali(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBengali",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsBlock(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;
    char * block;
    int n_block;

    for (n_code = 0;n_code < 4;n_code++) {
    for (n_block = 0;n_block < 4;n_block++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);
        block = gen_const_char_ptr(n_block, 1);

        ret_val = xmlUCSIsBlock(code, (const char *)block);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        des_const_char_ptr(n_block, (const char *)block, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBlock",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf(" %d", n_block);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsBlockElements(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBlockElements(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBlockElements",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsBopomofo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBopomofo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBopomofo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsBopomofoExtended(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBopomofoExtended(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBopomofoExtended",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsBoxDrawing(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBoxDrawing(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBoxDrawing",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsBraillePatterns(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBraillePatterns(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBraillePatterns",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsBuhid(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsBuhid(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsBuhid",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsByzantineMusicalSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsByzantineMusicalSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsByzantineMusicalSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCJKCompatibility(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKCompatibility(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibility",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCJKCompatibilityForms(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKCompatibilityForms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityForms",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCJKCompatibilityIdeographs(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKCompatibilityIdeographs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCJKCompatibilityIdeographsSupplement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKCompatibilityIdeographsSupplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKCompatibilityIdeographsSupplement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCJKRadicalsSupplement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKRadicalsSupplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKRadicalsSupplement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCJKSymbolsandPunctuation(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKSymbolsandPunctuation(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKSymbolsandPunctuation",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCJKUnifiedIdeographs(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKUnifiedIdeographs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCJKUnifiedIdeographsExtensionA(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionA",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCJKUnifiedIdeographsExtensionB(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCJKUnifiedIdeographsExtensionB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCJKUnifiedIdeographsExtensionB",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCat(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;
    char * cat;
    int n_cat;

    for (n_code = 0;n_code < 4;n_code++) {
    for (n_cat = 0;n_cat < 4;n_cat++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);
        cat = gen_const_char_ptr(n_cat, 1);

        ret_val = xmlUCSIsCat(code, (const char *)cat);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        des_const_char_ptr(n_cat, (const char *)cat, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCat",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf(" %d", n_cat);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatC(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatC(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatC",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatCc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatCc(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatCc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatCf(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatCf(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatCf",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatCo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatCo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatCo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatCs(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatCs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatCs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatL(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatL(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatL",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatLl(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLl(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatLm(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLm(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLm",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatLo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatLt(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLt(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLt",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatLu(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatLu(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatLu",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatM(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatM(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatM",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatMc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatMc(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatMc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatMe(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatMe(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatMe",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatMn(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatMn(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatMn",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatN(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatN(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatN",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatNd(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatNd(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatNd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatNl(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatNl(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatNl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatNo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatNo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatNo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatP(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatP(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatP",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatPc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPc(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatPd(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPd(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatPe(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPe(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPe",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatPf(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPf(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPf",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatPi(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPi(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPi",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatPo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatPs(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatPs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatPs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatS(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatS(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatS",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatSc(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatSc(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatSc",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatSk(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatSk(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatSk",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatSm(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatSm(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatSm",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatSo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatSo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatSo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatZ(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatZ(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatZ",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatZl(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatZl(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatZl",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatZp(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatZp(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatZp",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCatZs(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCatZs(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCatZs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCherokee(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCherokee(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCherokee",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCombiningDiacriticalMarks(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCombiningDiacriticalMarks(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarks",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCombiningDiacriticalMarksforSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCombiningDiacriticalMarksforSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCombiningDiacriticalMarksforSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCombiningHalfMarks(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCombiningHalfMarks(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCombiningHalfMarks",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCombiningMarksforSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCombiningMarksforSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCombiningMarksforSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsControlPictures(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsControlPictures(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsControlPictures",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCurrencySymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCurrencySymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCurrencySymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCypriotSyllabary(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCypriotSyllabary(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCypriotSyllabary",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCyrillic(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCyrillic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCyrillic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsCyrillicSupplement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsCyrillicSupplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsCyrillicSupplement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsDeseret(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsDeseret(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsDeseret",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsDevanagari(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsDevanagari(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsDevanagari",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsDingbats(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsDingbats(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsDingbats",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsEnclosedAlphanumerics(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsEnclosedAlphanumerics(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsEnclosedAlphanumerics",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsEnclosedCJKLettersandMonths(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsEnclosedCJKLettersandMonths(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsEnclosedCJKLettersandMonths",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsEthiopic(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsEthiopic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsEthiopic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsGeneralPunctuation(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGeneralPunctuation(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGeneralPunctuation",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsGeometricShapes(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGeometricShapes(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGeometricShapes",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsGeorgian(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGeorgian(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGeorgian",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsGothic(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGothic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGothic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsGreek(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGreek(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGreek",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsGreekExtended(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGreekExtended(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGreekExtended",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsGreekandCoptic(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGreekandCoptic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGreekandCoptic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsGujarati(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGujarati(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGujarati",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsGurmukhi(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsGurmukhi(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsGurmukhi",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsHalfwidthandFullwidthForms(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHalfwidthandFullwidthForms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHalfwidthandFullwidthForms",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsHangulCompatibilityJamo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHangulCompatibilityJamo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHangulCompatibilityJamo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsHangulJamo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHangulJamo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHangulJamo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsHangulSyllables(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHangulSyllables(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHangulSyllables",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsHanunoo(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHanunoo(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHanunoo",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsHebrew(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHebrew(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHebrew",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsHighPrivateUseSurrogates(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHighPrivateUseSurrogates(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHighPrivateUseSurrogates",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsHighSurrogates(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHighSurrogates(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHighSurrogates",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsHiragana(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsHiragana(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsHiragana",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsIPAExtensions(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsIPAExtensions(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsIPAExtensions",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsIdeographicDescriptionCharacters(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsIdeographicDescriptionCharacters(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsIdeographicDescriptionCharacters",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsKanbun(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKanbun(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKanbun",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsKangxiRadicals(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKangxiRadicals(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKangxiRadicals",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsKannada(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKannada(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKannada",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsKatakana(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKatakana(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKatakana",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsKatakanaPhoneticExtensions(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKatakanaPhoneticExtensions(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKatakanaPhoneticExtensions",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsKhmer(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKhmer(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKhmer",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsKhmerSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsKhmerSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsKhmerSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLao(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLao(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLao",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLatin1Supplement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLatin1Supplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLatin1Supplement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLatinExtendedA(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLatinExtendedA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedA",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLatinExtendedAdditional(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLatinExtendedAdditional(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedAdditional",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLatinExtendedB(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLatinExtendedB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLatinExtendedB",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLetterlikeSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLetterlikeSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLetterlikeSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLimbu(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLimbu(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLimbu",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLinearBIdeograms(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLinearBIdeograms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLinearBIdeograms",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLinearBSyllabary(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLinearBSyllabary(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLinearBSyllabary",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsLowSurrogates(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsLowSurrogates(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsLowSurrogates",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMalayalam(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMalayalam(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMalayalam",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMathematicalAlphanumericSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMathematicalAlphanumericSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMathematicalAlphanumericSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMathematicalOperators(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMathematicalOperators(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMathematicalOperators",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMiscellaneousMathematicalSymbolsA(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsA",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMiscellaneousMathematicalSymbolsB(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousMathematicalSymbolsB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousMathematicalSymbolsB",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMiscellaneousSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMiscellaneousSymbolsandArrows(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousSymbolsandArrows(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousSymbolsandArrows",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMiscellaneousTechnical(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMiscellaneousTechnical(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMiscellaneousTechnical",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMongolian(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMongolian(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMongolian",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMusicalSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMusicalSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMusicalSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsMyanmar(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsMyanmar(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsMyanmar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsNumberForms(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsNumberForms(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsNumberForms",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsOgham(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOgham(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOgham",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsOldItalic(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOldItalic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOldItalic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsOpticalCharacterRecognition(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOpticalCharacterRecognition(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOpticalCharacterRecognition",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsOriya(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOriya(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOriya",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsOsmanya(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsOsmanya(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsOsmanya",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsPhoneticExtensions(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsPhoneticExtensions(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsPhoneticExtensions",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsPrivateUse(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsPrivateUse(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsPrivateUse",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsPrivateUseArea(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsPrivateUseArea(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsPrivateUseArea",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsRunic(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsRunic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsRunic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsShavian(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsShavian(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsShavian",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSinhala(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSinhala(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSinhala",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSmallFormVariants(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSmallFormVariants(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSmallFormVariants",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSpacingModifierLetters(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSpacingModifierLetters(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSpacingModifierLetters",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSpecials(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSpecials(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSpecials",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSuperscriptsandSubscripts(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSuperscriptsandSubscripts(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSuperscriptsandSubscripts",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSupplementalArrowsA(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementalArrowsA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementalArrowsA",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSupplementalArrowsB(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementalArrowsB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementalArrowsB",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSupplementalMathematicalOperators(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementalMathematicalOperators(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementalMathematicalOperators",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSupplementaryPrivateUseAreaA(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementaryPrivateUseAreaA(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaA",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSupplementaryPrivateUseAreaB(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSupplementaryPrivateUseAreaB(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSupplementaryPrivateUseAreaB",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsSyriac(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsSyriac(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsSyriac",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsTagalog(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTagalog(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTagalog",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsTagbanwa(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTagbanwa(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTagbanwa",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsTags(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTags(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTags",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsTaiLe(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTaiLe(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTaiLe",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsTaiXuanJingSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTaiXuanJingSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTaiXuanJingSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsTamil(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTamil(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTamil",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsTelugu(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTelugu(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTelugu",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsThaana(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsThaana(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsThaana",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsThai(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsThai(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsThai",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsTibetan(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsTibetan(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsTibetan",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsUgaritic(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsUgaritic(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsUgaritic",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsUnifiedCanadianAboriginalSyllabics(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsUnifiedCanadianAboriginalSyllabics(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsUnifiedCanadianAboriginalSyllabics",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsVariationSelectors(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsVariationSelectors(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsVariationSelectors",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsVariationSelectorsSupplement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsVariationSelectorsSupplement(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsVariationSelectorsSupplement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsYiRadicals(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsYiRadicals(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsYiRadicals",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsYiSyllables(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsYiSyllables(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsYiSyllables",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlUCSIsYijingHexagramSymbols(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    int code;
    int n_code;

    for (n_code = 0;n_code < 4;n_code++) {
        mem_base = xmlMemBlocks();
        code = gen_int(n_code, 0);

        ret_val = xmlUCSIsYijingHexagramSymbols(code);
        desret_int(ret_val);
        call_tests++;
        des_int(n_code, code, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlUCSIsYijingHexagramSymbols",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_code);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xmlunicode(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlunicode : 166 of 166 functions ...\n");
    test_ret += test_xmlUCSIsAegeanNumbers();
    test_ret += test_xmlUCSIsAlphabeticPresentationForms();
    test_ret += test_xmlUCSIsArabic();
    test_ret += test_xmlUCSIsArabicPresentationFormsA();
    test_ret += test_xmlUCSIsArabicPresentationFormsB();
    test_ret += test_xmlUCSIsArmenian();
    test_ret += test_xmlUCSIsArrows();
    test_ret += test_xmlUCSIsBasicLatin();
    test_ret += test_xmlUCSIsBengali();
    test_ret += test_xmlUCSIsBlock();
    test_ret += test_xmlUCSIsBlockElements();
    test_ret += test_xmlUCSIsBopomofo();
    test_ret += test_xmlUCSIsBopomofoExtended();
    test_ret += test_xmlUCSIsBoxDrawing();
    test_ret += test_xmlUCSIsBraillePatterns();
    test_ret += test_xmlUCSIsBuhid();
    test_ret += test_xmlUCSIsByzantineMusicalSymbols();
    test_ret += test_xmlUCSIsCJKCompatibility();
    test_ret += test_xmlUCSIsCJKCompatibilityForms();
    test_ret += test_xmlUCSIsCJKCompatibilityIdeographs();
    test_ret += test_xmlUCSIsCJKCompatibilityIdeographsSupplement();
    test_ret += test_xmlUCSIsCJKRadicalsSupplement();
    test_ret += test_xmlUCSIsCJKSymbolsandPunctuation();
    test_ret += test_xmlUCSIsCJKUnifiedIdeographs();
    test_ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionA();
    test_ret += test_xmlUCSIsCJKUnifiedIdeographsExtensionB();
    test_ret += test_xmlUCSIsCat();
    test_ret += test_xmlUCSIsCatC();
    test_ret += test_xmlUCSIsCatCc();
    test_ret += test_xmlUCSIsCatCf();
    test_ret += test_xmlUCSIsCatCo();
    test_ret += test_xmlUCSIsCatCs();
    test_ret += test_xmlUCSIsCatL();
    test_ret += test_xmlUCSIsCatLl();
    test_ret += test_xmlUCSIsCatLm();
    test_ret += test_xmlUCSIsCatLo();
    test_ret += test_xmlUCSIsCatLt();
    test_ret += test_xmlUCSIsCatLu();
    test_ret += test_xmlUCSIsCatM();
    test_ret += test_xmlUCSIsCatMc();
    test_ret += test_xmlUCSIsCatMe();
    test_ret += test_xmlUCSIsCatMn();
    test_ret += test_xmlUCSIsCatN();
    test_ret += test_xmlUCSIsCatNd();
    test_ret += test_xmlUCSIsCatNl();
    test_ret += test_xmlUCSIsCatNo();
    test_ret += test_xmlUCSIsCatP();
    test_ret += test_xmlUCSIsCatPc();
    test_ret += test_xmlUCSIsCatPd();
    test_ret += test_xmlUCSIsCatPe();
    test_ret += test_xmlUCSIsCatPf();
    test_ret += test_xmlUCSIsCatPi();
    test_ret += test_xmlUCSIsCatPo();
    test_ret += test_xmlUCSIsCatPs();
    test_ret += test_xmlUCSIsCatS();
    test_ret += test_xmlUCSIsCatSc();
    test_ret += test_xmlUCSIsCatSk();
    test_ret += test_xmlUCSIsCatSm();
    test_ret += test_xmlUCSIsCatSo();
    test_ret += test_xmlUCSIsCatZ();
    test_ret += test_xmlUCSIsCatZl();
    test_ret += test_xmlUCSIsCatZp();
    test_ret += test_xmlUCSIsCatZs();
    test_ret += test_xmlUCSIsCherokee();
    test_ret += test_xmlUCSIsCombiningDiacriticalMarks();
    test_ret += test_xmlUCSIsCombiningDiacriticalMarksforSymbols();
    test_ret += test_xmlUCSIsCombiningHalfMarks();
    test_ret += test_xmlUCSIsCombiningMarksforSymbols();
    test_ret += test_xmlUCSIsControlPictures();
    test_ret += test_xmlUCSIsCurrencySymbols();
    test_ret += test_xmlUCSIsCypriotSyllabary();
    test_ret += test_xmlUCSIsCyrillic();
    test_ret += test_xmlUCSIsCyrillicSupplement();
    test_ret += test_xmlUCSIsDeseret();
    test_ret += test_xmlUCSIsDevanagari();
    test_ret += test_xmlUCSIsDingbats();
    test_ret += test_xmlUCSIsEnclosedAlphanumerics();
    test_ret += test_xmlUCSIsEnclosedCJKLettersandMonths();
    test_ret += test_xmlUCSIsEthiopic();
    test_ret += test_xmlUCSIsGeneralPunctuation();
    test_ret += test_xmlUCSIsGeometricShapes();
    test_ret += test_xmlUCSIsGeorgian();
    test_ret += test_xmlUCSIsGothic();
    test_ret += test_xmlUCSIsGreek();
    test_ret += test_xmlUCSIsGreekExtended();
    test_ret += test_xmlUCSIsGreekandCoptic();
    test_ret += test_xmlUCSIsGujarati();
    test_ret += test_xmlUCSIsGurmukhi();
    test_ret += test_xmlUCSIsHalfwidthandFullwidthForms();
    test_ret += test_xmlUCSIsHangulCompatibilityJamo();
    test_ret += test_xmlUCSIsHangulJamo();
    test_ret += test_xmlUCSIsHangulSyllables();
    test_ret += test_xmlUCSIsHanunoo();
    test_ret += test_xmlUCSIsHebrew();
    test_ret += test_xmlUCSIsHighPrivateUseSurrogates();
    test_ret += test_xmlUCSIsHighSurrogates();
    test_ret += test_xmlUCSIsHiragana();
    test_ret += test_xmlUCSIsIPAExtensions();
    test_ret += test_xmlUCSIsIdeographicDescriptionCharacters();
    test_ret += test_xmlUCSIsKanbun();
    test_ret += test_xmlUCSIsKangxiRadicals();
    test_ret += test_xmlUCSIsKannada();
    test_ret += test_xmlUCSIsKatakana();
    test_ret += test_xmlUCSIsKatakanaPhoneticExtensions();
    test_ret += test_xmlUCSIsKhmer();
    test_ret += test_xmlUCSIsKhmerSymbols();
    test_ret += test_xmlUCSIsLao();
    test_ret += test_xmlUCSIsLatin1Supplement();
    test_ret += test_xmlUCSIsLatinExtendedA();
    test_ret += test_xmlUCSIsLatinExtendedAdditional();
    test_ret += test_xmlUCSIsLatinExtendedB();
    test_ret += test_xmlUCSIsLetterlikeSymbols();
    test_ret += test_xmlUCSIsLimbu();
    test_ret += test_xmlUCSIsLinearBIdeograms();
    test_ret += test_xmlUCSIsLinearBSyllabary();
    test_ret += test_xmlUCSIsLowSurrogates();
    test_ret += test_xmlUCSIsMalayalam();
    test_ret += test_xmlUCSIsMathematicalAlphanumericSymbols();
    test_ret += test_xmlUCSIsMathematicalOperators();
    test_ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsA();
    test_ret += test_xmlUCSIsMiscellaneousMathematicalSymbolsB();
    test_ret += test_xmlUCSIsMiscellaneousSymbols();
    test_ret += test_xmlUCSIsMiscellaneousSymbolsandArrows();
    test_ret += test_xmlUCSIsMiscellaneousTechnical();
    test_ret += test_xmlUCSIsMongolian();
    test_ret += test_xmlUCSIsMusicalSymbols();
    test_ret += test_xmlUCSIsMyanmar();
    test_ret += test_xmlUCSIsNumberForms();
    test_ret += test_xmlUCSIsOgham();
    test_ret += test_xmlUCSIsOldItalic();
    test_ret += test_xmlUCSIsOpticalCharacterRecognition();
    test_ret += test_xmlUCSIsOriya();
    test_ret += test_xmlUCSIsOsmanya();
    test_ret += test_xmlUCSIsPhoneticExtensions();
    test_ret += test_xmlUCSIsPrivateUse();
    test_ret += test_xmlUCSIsPrivateUseArea();
    test_ret += test_xmlUCSIsRunic();
    test_ret += test_xmlUCSIsShavian();
    test_ret += test_xmlUCSIsSinhala();
    test_ret += test_xmlUCSIsSmallFormVariants();
    test_ret += test_xmlUCSIsSpacingModifierLetters();
    test_ret += test_xmlUCSIsSpecials();
    test_ret += test_xmlUCSIsSuperscriptsandSubscripts();
    test_ret += test_xmlUCSIsSupplementalArrowsA();
    test_ret += test_xmlUCSIsSupplementalArrowsB();
    test_ret += test_xmlUCSIsSupplementalMathematicalOperators();
    test_ret += test_xmlUCSIsSupplementaryPrivateUseAreaA();
    test_ret += test_xmlUCSIsSupplementaryPrivateUseAreaB();
    test_ret += test_xmlUCSIsSyriac();
    test_ret += test_xmlUCSIsTagalog();
    test_ret += test_xmlUCSIsTagbanwa();
    test_ret += test_xmlUCSIsTags();
    test_ret += test_xmlUCSIsTaiLe();
    test_ret += test_xmlUCSIsTaiXuanJingSymbols();
    test_ret += test_xmlUCSIsTamil();
    test_ret += test_xmlUCSIsTelugu();
    test_ret += test_xmlUCSIsThaana();
    test_ret += test_xmlUCSIsThai();
    test_ret += test_xmlUCSIsTibetan();
    test_ret += test_xmlUCSIsUgaritic();
    test_ret += test_xmlUCSIsUnifiedCanadianAboriginalSyllabics();
    test_ret += test_xmlUCSIsVariationSelectors();
    test_ret += test_xmlUCSIsVariationSelectorsSupplement();
    test_ret += test_xmlUCSIsYiRadicals();
    test_ret += test_xmlUCSIsYiSyllables();
    test_ret += test_xmlUCSIsYijingHexagramSymbols();

    if (test_ret != 0)
 printf("Module xmlunicode: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlNewTextWriter(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextWriterPtr ret_val;
    xmlOutputBufferPtr out;
    int n_out;

    for (n_out = 0;n_out < 2;n_out++) {
        mem_base = xmlMemBlocks();
        out = gen_xmlOutputBufferPtr(n_out, 0);

        ret_val = xmlNewTextWriter(out);
        if (ret_val != 
# 43159 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                      ((void *)0)
# 43159 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                          ) out = 
# 43159 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                  ((void *)0)
# 43159 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                      ;
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_xmlOutputBufferPtr(n_out, out, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriter",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_out);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNewTextWriterFilename(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextWriterPtr ret_val;
    const char * uri;
    int n_uri;
    int compression;
    int n_compression;

    for (n_uri = 0;n_uri < 6;n_uri++) {
    for (n_compression = 0;n_compression < 4;n_compression++) {
        mem_base = xmlMemBlocks();
        uri = gen_fileoutput(n_uri, 0);
        compression = gen_int(n_compression, 1);

        ret_val = xmlNewTextWriterFilename(uri, compression);
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_fileoutput(n_uri, uri, 0);
        des_int(n_compression, compression, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriterFilename",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_uri);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNewTextWriterMemory(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextWriterPtr ret_val;
    xmlBufferPtr buf;
    int n_buf;
    int compression;
    int n_compression;

    for (n_buf = 0;n_buf < 3;n_buf++) {
    for (n_compression = 0;n_compression < 4;n_compression++) {
        mem_base = xmlMemBlocks();
        buf = gen_xmlBufferPtr(n_buf, 0);
        compression = gen_int(n_compression, 1);

        ret_val = xmlNewTextWriterMemory(buf, compression);
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_xmlBufferPtr(n_buf, buf, 0);
        des_int(n_compression, compression, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriterMemory",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_buf);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNewTextWriterPushParser(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextWriterPtr ret_val;
    xmlParserCtxtPtr ctxt;
    int n_ctxt;
    int compression;
    int n_compression;

    for (n_ctxt = 0;n_ctxt < 3;n_ctxt++) {
    for (n_compression = 0;n_compression < 4;n_compression++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlParserCtxtPtr(n_ctxt, 0);
        compression = gen_int(n_compression, 1);

        ret_val = xmlNewTextWriterPushParser(ctxt, compression);
        if (ctxt != 
# 43280 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                   ((void *)0)
# 43280 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                       ) {xmlFreeDoc(ctxt->myDoc); ctxt->myDoc = 
# 43280 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                 ((void *)0)
# 43280 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                     ;} if (ret_val != 
# 43280 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                                       ((void *)0)
# 43280 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                                           ) ctxt = 
# 43280 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
                                                                                                    ((void *)0)
# 43280 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                                                                                                        ;
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_xmlParserCtxtPtr(n_ctxt, ctxt, 0);
        des_int(n_compression, compression, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriterPushParser",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlNewTextWriterTree(void) {
    int test_ret = 0;


    int mem_base;
    xmlTextWriterPtr ret_val;
    xmlDocPtr doc;
    int n_doc;
    xmlNodePtr node;
    int n_node;
    int compression;
    int n_compression;

    for (n_doc = 0;n_doc < 4;n_doc++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_compression = 0;n_compression < 4;n_compression++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);
        node = gen_xmlNodePtr(n_node, 1);
        compression = gen_int(n_compression, 2);

        ret_val = xmlNewTextWriterTree(doc, node, compression);
        desret_xmlTextWriterPtr(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_int(n_compression, compression, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlNewTextWriterTree",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf(" %d", n_node);
            printf(" %d", n_compression);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndAttribute(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndAttribute(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndCDATA(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndCDATA(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndCDATA",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndComment(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndComment(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndComment",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndDTD(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTD(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTD",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndDTDAttlist(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTDAttlist(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTDAttlist",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndDTDElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTDElement(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTDElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndDTDEntity(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDTDEntity(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDTDEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndDocument(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndDocument(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndDocument",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndElement(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterEndPI(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterEndPI(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterEndPI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterFlush(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterFlush(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterFlush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterFullEndElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterFullEndElement(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterFullEndElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterSetIndent(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    int indent;
    int n_indent;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_indent = 0;n_indent < 4;n_indent++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        indent = gen_int(n_indent, 1);

        ret_val = xmlTextWriterSetIndent(writer, indent);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_indent, indent, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterSetIndent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_indent);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterSetIndentString(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * str;
    int n_str;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_str = 0;n_str < 5;n_str++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        str = gen_const_xmlChar_ptr(n_str, 1);

        ret_val = xmlTextWriterSetIndentString(writer, (const xmlChar *)str);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterSetIndentString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_str);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterSetQuoteChar(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar quotechar;
    int n_quotechar;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_quotechar = 0;n_quotechar < 4;n_quotechar++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        quotechar = gen_xmlChar(n_quotechar, 1);

        ret_val = xmlTextWriterSetQuoteChar(writer, quotechar);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_xmlChar(n_quotechar, quotechar, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterSetQuoteChar",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_quotechar);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartAttribute(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartAttribute(writer, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartAttributeNS(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * name;
    int n_name;
    xmlChar * namespaceURI;
    int n_namespaceURI;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < 5;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);

        ret_val = xmlTextWriterStartAttributeNS(writer, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)namespaceURI);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartAttributeNS",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartCDATA(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterStartCDATA(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartCDATA",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartComment(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;

    for (n_writer = 0;n_writer < 2;n_writer++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);

        ret_val = xmlTextWriterStartComment(writer);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartComment",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartDTD(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;
    xmlChar * pubid;
    int n_pubid;
    xmlChar * sysid;
    int n_sysid;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_pubid = 0;n_pubid < 5;n_pubid++) {
    for (n_sysid = 0;n_sysid < 5;n_sysid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
        sysid = gen_const_xmlChar_ptr(n_sysid, 3);

        ret_val = xmlTextWriterStartDTD(writer, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 2);
        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTD",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartDTDAttlist(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartDTDAttlist(writer, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTDAttlist",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartDTDElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartDTDElement(writer, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTDElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartDTDEntity(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    int pe;
    int n_pe;
    xmlChar * name;
    int n_name;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_pe = 0;n_pe < 4;n_pe++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);

        ret_val = xmlTextWriterStartDTDEntity(writer, pe, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDTDEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartDocument(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    char * version;
    int n_version;
    char * encoding;
    int n_encoding;
    char * standalone;
    int n_standalone;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_version = 0;n_version < 4;n_version++) {
    for (n_encoding = 0;n_encoding < 4;n_encoding++) {
    for (n_standalone = 0;n_standalone < 4;n_standalone++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        version = gen_const_char_ptr(n_version, 1);
        encoding = gen_const_char_ptr(n_encoding, 2);
        standalone = gen_const_char_ptr(n_standalone, 3);

        ret_val = xmlTextWriterStartDocument(writer, (const char *)version, (const char *)encoding, (const char *)standalone);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_char_ptr(n_version, (const char *)version, 1);
        des_const_char_ptr(n_encoding, (const char *)encoding, 2);
        des_const_char_ptr(n_standalone, (const char *)standalone, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartDocument",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_version);
            printf(" %d", n_encoding);
            printf(" %d", n_standalone);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlTextWriterStartElement(writer, (const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartElementNS(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * name;
    int n_name;
    xmlChar * namespaceURI;
    int n_namespaceURI;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < 5;n_namespaceURI++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);

        ret_val = xmlTextWriterStartElementNS(writer, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)namespaceURI);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartElementNS",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterStartPI(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * target;
    int n_target;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_target = 0;n_target < 5;n_target++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        target = gen_const_xmlChar_ptr(n_target, 1);

        ret_val = xmlTextWriterStartPI(writer, (const xmlChar *)target);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_target, (const xmlChar *)target, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterStartPI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_target);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteAttribute(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteAttribute(writer, (const xmlChar *)name, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteAttributeNS(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * name;
    int n_name;
    xmlChar * namespaceURI;
    int n_namespaceURI;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < 5;n_namespaceURI++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
        content = gen_const_xmlChar_ptr(n_content, 4);

        ret_val = xmlTextWriterWriteAttributeNS(writer, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)namespaceURI, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 3);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteAttributeNS",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteBase64(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    char * data;
    int n_data;
    int start;
    int n_start;
    int len;
    int n_len;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_data = 0;n_data < 4;n_data++) {
    for (n_start = 0;n_start < 4;n_start++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        data = gen_const_char_ptr(n_data, 1);
        start = gen_int(n_start, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlTextWriterWriteBase64(writer, (const char *)data, start, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_char_ptr(n_data, (const char *)data, 1);
        des_int(n_start, start, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteBase64",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_data);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteBinHex(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    char * data;
    int n_data;
    int start;
    int n_start;
    int len;
    int n_len;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_data = 0;n_data < 4;n_data++) {
    for (n_start = 0;n_start < 4;n_start++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        data = gen_const_char_ptr(n_data, 1);
        start = gen_int(n_start, 2);
        len = gen_int(n_len, 3);

        ret_val = xmlTextWriterWriteBinHex(writer, (const char *)data, start, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_char_ptr(n_data, (const char *)data, 1);
        des_int(n_start, start, 2);
        des_int(n_len, len, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteBinHex",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_data);
            printf(" %d", n_start);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteCDATA(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteCDATA(writer, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteCDATA",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteComment(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteComment(writer, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteComment",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteDTD(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;
    xmlChar * pubid;
    int n_pubid;
    xmlChar * sysid;
    int n_sysid;
    xmlChar * subset;
    int n_subset;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_pubid = 0;n_pubid < 5;n_pubid++) {
    for (n_sysid = 0;n_sysid < 5;n_sysid++) {
    for (n_subset = 0;n_subset < 5;n_subset++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
        sysid = gen_const_xmlChar_ptr(n_sysid, 3);
        subset = gen_const_xmlChar_ptr(n_subset, 4);

        ret_val = xmlTextWriterWriteDTD(writer, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid, (const xmlChar *)subset);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 2);
        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 3);
        des_const_xmlChar_ptr(n_subset, (const xmlChar *)subset, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTD",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_subset);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteDTDAttlist(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteDTDAttlist(writer, (const xmlChar *)name, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDAttlist",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteDTDElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteDTDElement(writer, (const xmlChar *)name, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteDTDEntity(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    int pe;
    int n_pe;
    xmlChar * name;
    int n_name;
    xmlChar * pubid;
    int n_pubid;
    xmlChar * sysid;
    int n_sysid;
    xmlChar * ndataid;
    int n_ndataid;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_pe = 0;n_pe < 4;n_pe++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_pubid = 0;n_pubid < 5;n_pubid++) {
    for (n_sysid = 0;n_sysid < 5;n_sysid++) {
    for (n_ndataid = 0;n_ndataid < 5;n_ndataid++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        pubid = gen_const_xmlChar_ptr(n_pubid, 3);
        sysid = gen_const_xmlChar_ptr(n_sysid, 4);
        ndataid = gen_const_xmlChar_ptr(n_ndataid, 5);
        content = gen_const_xmlChar_ptr(n_content, 6);

        ret_val = xmlTextWriterWriteDTDEntity(writer, pe, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid, (const xmlChar *)ndataid, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 3);
        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 4);
        des_const_xmlChar_ptr(n_ndataid, (const xmlChar *)ndataid, 5);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 6);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_ndataid);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteDTDExternalEntity(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    int pe;
    int n_pe;
    xmlChar * name;
    int n_name;
    xmlChar * pubid;
    int n_pubid;
    xmlChar * sysid;
    int n_sysid;
    xmlChar * ndataid;
    int n_ndataid;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_pe = 0;n_pe < 4;n_pe++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_pubid = 0;n_pubid < 5;n_pubid++) {
    for (n_sysid = 0;n_sysid < 5;n_sysid++) {
    for (n_ndataid = 0;n_ndataid < 5;n_ndataid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        pubid = gen_const_xmlChar_ptr(n_pubid, 3);
        sysid = gen_const_xmlChar_ptr(n_sysid, 4);
        ndataid = gen_const_xmlChar_ptr(n_ndataid, 5);

        ret_val = xmlTextWriterWriteDTDExternalEntity(writer, pe, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid, (const xmlChar *)ndataid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 3);
        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 4);
        des_const_xmlChar_ptr(n_ndataid, (const xmlChar *)ndataid, 5);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_ndataid);
            printf("\n");
        }
    }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteDTDExternalEntityContents(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * pubid;
    int n_pubid;
    xmlChar * sysid;
    int n_sysid;
    xmlChar * ndataid;
    int n_ndataid;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_pubid = 0;n_pubid < 5;n_pubid++) {
    for (n_sysid = 0;n_sysid < 5;n_sysid++) {
    for (n_ndataid = 0;n_ndataid < 5;n_ndataid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pubid = gen_const_xmlChar_ptr(n_pubid, 1);
        sysid = gen_const_xmlChar_ptr(n_sysid, 2);
        ndataid = gen_const_xmlChar_ptr(n_ndataid, 3);

        ret_val = xmlTextWriterWriteDTDExternalEntityContents(writer, (const xmlChar *)pubid, (const xmlChar *)sysid, (const xmlChar *)ndataid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 1);
        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 2);
        des_const_xmlChar_ptr(n_ndataid, (const xmlChar *)ndataid, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDExternalEntityContents",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf(" %d", n_ndataid);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteDTDInternalEntity(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    int pe;
    int n_pe;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_pe = 0;n_pe < 4;n_pe++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        pe = gen_int(n_pe, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        content = gen_const_xmlChar_ptr(n_content, 3);

        ret_val = xmlTextWriterWriteDTDInternalEntity(writer, pe, (const xmlChar *)name, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_int(n_pe, pe, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDInternalEntity",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_pe);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteDTDNotation(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;
    xmlChar * pubid;
    int n_pubid;
    xmlChar * sysid;
    int n_sysid;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_pubid = 0;n_pubid < 5;n_pubid++) {
    for (n_sysid = 0;n_sysid < 5;n_sysid++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        pubid = gen_const_xmlChar_ptr(n_pubid, 2);
        sysid = gen_const_xmlChar_ptr(n_sysid, 3);

        ret_val = xmlTextWriterWriteDTDNotation(writer, (const xmlChar *)name, (const xmlChar *)pubid, (const xmlChar *)sysid);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_pubid, (const xmlChar *)pubid, 2);
        des_const_xmlChar_ptr(n_sysid, (const xmlChar *)sysid, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteDTDNotation",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_pubid);
            printf(" %d", n_sysid);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteElement(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * name;
    int n_name;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWriteElement(writer, (const xmlChar *)name, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteElement",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_name);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteElementNS(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * name;
    int n_name;
    xmlChar * namespaceURI;
    int n_namespaceURI;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_namespaceURI = 0;n_namespaceURI < 5;n_namespaceURI++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        name = gen_const_xmlChar_ptr(n_name, 2);
        namespaceURI = gen_const_xmlChar_ptr(n_namespaceURI, 3);
        content = gen_const_xmlChar_ptr(n_content, 4);

        ret_val = xmlTextWriterWriteElementNS(writer, (const xmlChar *)prefix, (const xmlChar *)name, (const xmlChar *)namespaceURI, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 2);
        des_const_xmlChar_ptr(n_namespaceURI, (const xmlChar *)namespaceURI, 3);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 4);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteElementNS",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_prefix);
            printf(" %d", n_name);
            printf(" %d", n_namespaceURI);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatAttribute(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatAttributeNS(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatCDATA(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatComment(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatDTD(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatDTDAttlist(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatDTDElement(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatDTDInternalEntity(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatElement(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatElementNS(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatPI(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatRaw(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteFormatString(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWritePI(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * target;
    int n_target;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_target = 0;n_target < 5;n_target++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        target = gen_const_xmlChar_ptr(n_target, 1);
        content = gen_const_xmlChar_ptr(n_content, 2);

        ret_val = xmlTextWriterWritePI(writer, (const xmlChar *)target, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_target, (const xmlChar *)target, 1);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWritePI",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_target);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteRaw(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteRaw(writer, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteRaw",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteRawLen(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * content;
    int n_content;
    int len;
    int n_len;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_content = 0;n_content < 5;n_content++) {
    for (n_len = 0;n_len < 4;n_len++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);
        len = gen_int(n_len, 2);

        ret_val = xmlTextWriterWriteRawLen(writer, (const xmlChar *)content, len);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        des_int(n_len, len, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteRawLen",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf(" %d", n_len);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteString(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlTextWriterPtr writer;
    int n_writer;
    xmlChar * content;
    int n_content;

    for (n_writer = 0;n_writer < 2;n_writer++) {
    for (n_content = 0;n_content < 5;n_content++) {
        mem_base = xmlMemBlocks();
        writer = gen_xmlTextWriterPtr(n_writer, 0);
        content = gen_const_xmlChar_ptr(n_content, 1);

        ret_val = xmlTextWriterWriteString(writer, (const xmlChar *)content);
        desret_int(ret_val);
        call_tests++;
        des_xmlTextWriterPtr(n_writer, writer, 0);
        des_const_xmlChar_ptr(n_content, (const xmlChar *)content, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlTextWriterWriteString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_writer);
            printf(" %d", n_content);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatAttribute(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatAttributeNS(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatCDATA(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatComment(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatDTD(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatDTDAttlist(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatDTDElement(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatDTDInternalEntity(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatElement(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatElementNS(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatPI(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatRaw(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlTextWriterWriteVFormatString(void) {
    int test_ret = 0;



    return(test_ret);
}

static int
test_xmlwriter(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xmlwriter : 52 of 80 functions ...\n");
    test_ret += test_xmlNewTextWriter();
    test_ret += test_xmlNewTextWriterFilename();
    test_ret += test_xmlNewTextWriterMemory();
    test_ret += test_xmlNewTextWriterPushParser();
    test_ret += test_xmlNewTextWriterTree();
    test_ret += test_xmlTextWriterEndAttribute();
    test_ret += test_xmlTextWriterEndCDATA();
    test_ret += test_xmlTextWriterEndComment();
    test_ret += test_xmlTextWriterEndDTD();
    test_ret += test_xmlTextWriterEndDTDAttlist();
    test_ret += test_xmlTextWriterEndDTDElement();
    test_ret += test_xmlTextWriterEndDTDEntity();
    test_ret += test_xmlTextWriterEndDocument();
    test_ret += test_xmlTextWriterEndElement();
    test_ret += test_xmlTextWriterEndPI();
    test_ret += test_xmlTextWriterFlush();
    test_ret += test_xmlTextWriterFullEndElement();
    test_ret += test_xmlTextWriterSetIndent();
    test_ret += test_xmlTextWriterSetIndentString();
    test_ret += test_xmlTextWriterSetQuoteChar();
    test_ret += test_xmlTextWriterStartAttribute();
    test_ret += test_xmlTextWriterStartAttributeNS();
    test_ret += test_xmlTextWriterStartCDATA();
    test_ret += test_xmlTextWriterStartComment();
    test_ret += test_xmlTextWriterStartDTD();
    test_ret += test_xmlTextWriterStartDTDAttlist();
    test_ret += test_xmlTextWriterStartDTDElement();
    test_ret += test_xmlTextWriterStartDTDEntity();
    test_ret += test_xmlTextWriterStartDocument();
    test_ret += test_xmlTextWriterStartElement();
    test_ret += test_xmlTextWriterStartElementNS();
    test_ret += test_xmlTextWriterStartPI();
    test_ret += test_xmlTextWriterWriteAttribute();
    test_ret += test_xmlTextWriterWriteAttributeNS();
    test_ret += test_xmlTextWriterWriteBase64();
    test_ret += test_xmlTextWriterWriteBinHex();
    test_ret += test_xmlTextWriterWriteCDATA();
    test_ret += test_xmlTextWriterWriteComment();
    test_ret += test_xmlTextWriterWriteDTD();
    test_ret += test_xmlTextWriterWriteDTDAttlist();
    test_ret += test_xmlTextWriterWriteDTDElement();
    test_ret += test_xmlTextWriterWriteDTDEntity();
    test_ret += test_xmlTextWriterWriteDTDExternalEntity();
    test_ret += test_xmlTextWriterWriteDTDExternalEntityContents();
    test_ret += test_xmlTextWriterWriteDTDInternalEntity();
    test_ret += test_xmlTextWriterWriteDTDNotation();
    test_ret += test_xmlTextWriterWriteElement();
    test_ret += test_xmlTextWriterWriteElementNS();
    test_ret += test_xmlTextWriterWriteFormatAttribute();
    test_ret += test_xmlTextWriterWriteFormatAttributeNS();
    test_ret += test_xmlTextWriterWriteFormatCDATA();
    test_ret += test_xmlTextWriterWriteFormatComment();
    test_ret += test_xmlTextWriterWriteFormatDTD();
    test_ret += test_xmlTextWriterWriteFormatDTDAttlist();
    test_ret += test_xmlTextWriterWriteFormatDTDElement();
    test_ret += test_xmlTextWriterWriteFormatDTDInternalEntity();
    test_ret += test_xmlTextWriterWriteFormatElement();
    test_ret += test_xmlTextWriterWriteFormatElementNS();
    test_ret += test_xmlTextWriterWriteFormatPI();
    test_ret += test_xmlTextWriterWriteFormatRaw();
    test_ret += test_xmlTextWriterWriteFormatString();
    test_ret += test_xmlTextWriterWritePI();
    test_ret += test_xmlTextWriterWriteRaw();
    test_ret += test_xmlTextWriterWriteRawLen();
    test_ret += test_xmlTextWriterWriteString();
    test_ret += test_xmlTextWriterWriteVFormatAttribute();
    test_ret += test_xmlTextWriterWriteVFormatAttributeNS();
    test_ret += test_xmlTextWriterWriteVFormatCDATA();
    test_ret += test_xmlTextWriterWriteVFormatComment();
    test_ret += test_xmlTextWriterWriteVFormatDTD();
    test_ret += test_xmlTextWriterWriteVFormatDTDAttlist();
    test_ret += test_xmlTextWriterWriteVFormatDTDElement();
    test_ret += test_xmlTextWriterWriteVFormatDTDInternalEntity();
    test_ret += test_xmlTextWriterWriteVFormatElement();
    test_ret += test_xmlTextWriterWriteVFormatElementNS();
    test_ret += test_xmlTextWriterWriteVFormatPI();
    test_ret += test_xmlTextWriterWriteVFormatRaw();
    test_ret += test_xmlTextWriterWriteVFormatString();

    if (test_ret != 0)
 printf("Module xmlwriter: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlXPathCastBooleanToNumber(void) {
    int test_ret = 0;


    int mem_base;
    double ret_val;
    int val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlXPathCastBooleanToNumber(val);
        desret_double(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastBooleanToNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastBooleanToString(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    int val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlXPathCastBooleanToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastBooleanToString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastNodeSetToBoolean(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodeSetPtr ns;
    int n_ns;

    for (n_ns = 0;n_ns < 1;n_ns++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNodeSetPtr(n_ns, 0);

        ret_val = xmlXPathCastNodeSetToBoolean(ns);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_ns, ns, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeSetToBoolean",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ns);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastNodeSetToNumber(void) {
    int test_ret = 0;


    int mem_base;
    double ret_val;
    xmlNodeSetPtr ns;
    int n_ns;

    for (n_ns = 0;n_ns < 1;n_ns++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNodeSetPtr(n_ns, 0);

        ret_val = xmlXPathCastNodeSetToNumber(ns);
        desret_double(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_ns, ns, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeSetToNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ns);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastNodeSetToString(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlNodeSetPtr ns;
    int n_ns;

    for (n_ns = 0;n_ns < 1;n_ns++) {
        mem_base = xmlMemBlocks();
        ns = gen_xmlNodeSetPtr(n_ns, 0);

        ret_val = xmlXPathCastNodeSetToString(ns);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_ns, ns, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeSetToString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ns);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastNodeToNumber(void) {
    int test_ret = 0;


    int mem_base;
    double ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlXPathCastNodeToNumber(node);
        desret_double(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeToNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastNodeToString(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlNodePtr node;
    int n_node;

    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        node = gen_xmlNodePtr(n_node, 0);

        ret_val = xmlXPathCastNodeToString(node);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node, node, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNodeToString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastNumberToBoolean(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    double val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0);

        ret_val = xmlXPathCastNumberToBoolean(val);
        desret_int(ret_val);
        call_tests++;
        des_double(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNumberToBoolean",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastNumberToString(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    double val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0);

        ret_val = xmlXPathCastNumberToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_double(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastNumberToString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastStringToBoolean(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlChar * val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val, 0);

        ret_val = xmlXPathCastStringToBoolean((const xmlChar *)val);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastStringToBoolean",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastStringToNumber(void) {
    int test_ret = 0;


    int mem_base;
    double ret_val;
    xmlChar * val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val, 0);

        ret_val = xmlXPathCastStringToNumber((const xmlChar *)val);
        desret_double(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastStringToNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastToBoolean(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathObjectPtr val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathCastToBoolean(val);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastToBoolean",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastToNumber(void) {
    int test_ret = 0;


    int mem_base;
    double ret_val;
    xmlXPathObjectPtr val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathCastToNumber(val);
        desret_double(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastToNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCastToString(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlXPathObjectPtr val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathCastToString(val);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCastToString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCmpNodes(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodePtr node1;
    int n_node1;
    xmlNodePtr node2;
    int n_node2;

    for (n_node1 = 0;n_node1 < 3;n_node1++) {
    for (n_node2 = 0;n_node2 < 3;n_node2++) {
        mem_base = xmlMemBlocks();
        node1 = gen_xmlNodePtr(n_node1, 0);
        node2 = gen_xmlNodePtr(n_node2, 1);

        ret_val = xmlXPathCmpNodes(node1, node2);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodePtr(n_node1, node1, 0);
        des_xmlNodePtr(n_node2, node2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCmpNodes",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_node1);
            printf(" %d", n_node2);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCompile(void) {
    int test_ret = 0;



    return(test_ret);
}




static xmlXPathCompExprPtr gen_xmlXPathCompExprPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 46359 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 46359 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlXPathCompExprPtr(int no __attribute__((unused)), xmlXPathCompExprPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}





static xmlXPathContextPtr gen_xmlXPathContextPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 46369 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 46369 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlXPathContextPtr(int no __attribute__((unused)), xmlXPathContextPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlXPathCompiledEval(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathCompExprPtr comp;
    int n_comp;
    xmlXPathContextPtr ctx;
    int n_ctx;

    for (n_comp = 0;n_comp < 1;n_comp++) {
    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlXPathCompExprPtr(n_comp, 0);
        ctx = gen_xmlXPathContextPtr(n_ctx, 1);

        ret_val = xmlXPathCompiledEval(comp, ctx);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathCompExprPtr(n_comp, comp, 0);
        des_xmlXPathContextPtr(n_ctx, ctx, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCompiledEval",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_comp);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCompiledEvalToBoolean(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathCompExprPtr comp;
    int n_comp;
    xmlXPathContextPtr ctxt;
    int n_ctxt;

    for (n_comp = 0;n_comp < 1;n_comp++) {
    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        comp = gen_xmlXPathCompExprPtr(n_comp, 0);
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 1);

        ret_val = xmlXPathCompiledEvalToBoolean(comp, ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathCompExprPtr(n_comp, comp, 0);
        des_xmlXPathContextPtr(n_ctxt, ctxt, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCompiledEvalToBoolean",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_comp);
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathContextSetCache(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathContextPtr ctxt;
    int n_ctxt;
    int active;
    int n_active;
    int value;
    int n_value;
    int options;
    int n_options;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_active = 0;n_active < 4;n_active++) {
    for (n_value = 0;n_value < 4;n_value++) {
    for (n_options = 0;n_options < 4;n_options++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        active = gen_int(n_active, 1);
        value = gen_int(n_value, 2);
        options = gen_int(n_options, 3);

        ret_val = xmlXPathContextSetCache(ctxt, active, value, options);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        des_int(n_active, active, 1);
        des_int(n_value, value, 2);
        des_int(n_options, options, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathContextSetCache",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_active);
            printf(" %d", n_value);
            printf(" %d", n_options);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathConvertBoolean(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathConvertBoolean(val);
        val = 
# 46528 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
             ((void *)0)
# 46528 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                 ;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConvertBoolean",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathConvertNumber(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathConvertNumber(val);
        val = 
# 46563 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
             ((void *)0)
# 46563 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                 ;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConvertNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathConvertString(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathConvertString(val);
        val = 
# 46598 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
             ((void *)0)
# 46598 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
                 ;
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConvertString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCtxtCompile(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPathEval(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlChar * str;
    int n_str;
    xmlXPathContextPtr ctx;
    int n_ctx;

    for (n_str = 0;n_str < 5;n_str++) {
    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        ctx = gen_xmlXPathContextPtr(n_ctx, 1);

        ret_val = xmlXPathEval((const xmlChar *)str, ctx);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        des_xmlXPathContextPtr(n_ctx, ctx, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathEval",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathEvalExpression(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlChar * str;
    int n_str;
    xmlXPathContextPtr ctxt;
    int n_ctxt;

    for (n_str = 0;n_str < 5;n_str++) {
    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 1);

        ret_val = xmlXPathEvalExpression((const xmlChar *)str, ctxt);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        des_xmlXPathContextPtr(n_ctxt, ctxt, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathEvalExpression",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathEvalPredicate(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathContextPtr ctxt;
    int n_ctxt;
    xmlXPathObjectPtr res;
    int n_res;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_res = 0;n_res < 5;n_res++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        res = gen_xmlXPathObjectPtr(n_res, 1);

        ret_val = xmlXPathEvalPredicate(ctxt, res);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        des_xmlXPathObjectPtr(n_res, res, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathEvalPredicate",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_res);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathInit(void) {
    int test_ret = 0;


    int mem_base;

        mem_base = xmlMemBlocks();

        xmlXPathInit();
        call_tests++;
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathInit",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf("\n");
        }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathIsInf(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    double val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0);

        ret_val = xmlXPathIsInf(val);
        desret_int(ret_val);
        call_tests++;
        des_double(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathIsInf",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathIsNaN(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    double val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0);

        ret_val = xmlXPathIsNaN(val);
        desret_int(ret_val);
        call_tests++;
        des_double(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathIsNaN",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNewContext(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPathNodeSetCreate(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodePtr val;
    int n_val;

    for (n_val = 0;n_val < 3;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlNodePtr(n_val, 0);

        ret_val = xmlXPathNodeSetCreate(val);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeSetCreate",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathObjectCopy(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlXPathObjectPtr(n_val, 0);

        ret_val = xmlXPathObjectCopy(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathObjectCopy",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathOrderDocElems(void) {
    int test_ret = 0;


    int mem_base;
    long ret_val;
    xmlDocPtr doc;
    int n_doc;

    for (n_doc = 0;n_doc < 4;n_doc++) {
        mem_base = xmlMemBlocks();
        doc = gen_xmlDocPtr(n_doc, 0);

        ret_val = xmlXPathOrderDocElems(doc);
        desret_long(ret_val);
        call_tests++;
        des_xmlDocPtr(n_doc, doc, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathOrderDocElems",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_doc);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xpath(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xpath : 30 of 38 functions ...\n");
    test_ret += test_xmlXPathCastBooleanToNumber();
    test_ret += test_xmlXPathCastBooleanToString();
    test_ret += test_xmlXPathCastNodeSetToBoolean();
    test_ret += test_xmlXPathCastNodeSetToNumber();
    test_ret += test_xmlXPathCastNodeSetToString();
    test_ret += test_xmlXPathCastNodeToNumber();
    test_ret += test_xmlXPathCastNodeToString();
    test_ret += test_xmlXPathCastNumberToBoolean();
    test_ret += test_xmlXPathCastNumberToString();
    test_ret += test_xmlXPathCastStringToBoolean();
    test_ret += test_xmlXPathCastStringToNumber();
    test_ret += test_xmlXPathCastToBoolean();
    test_ret += test_xmlXPathCastToNumber();
    test_ret += test_xmlXPathCastToString();
    test_ret += test_xmlXPathCmpNodes();
    test_ret += test_xmlXPathCompile();
    test_ret += test_xmlXPathCompiledEval();
    test_ret += test_xmlXPathCompiledEvalToBoolean();
    test_ret += test_xmlXPathContextSetCache();
    test_ret += test_xmlXPathConvertBoolean();
    test_ret += test_xmlXPathConvertNumber();
    test_ret += test_xmlXPathConvertString();
    test_ret += test_xmlXPathCtxtCompile();
    test_ret += test_xmlXPathEval();
    test_ret += test_xmlXPathEvalExpression();
    test_ret += test_xmlXPathEvalPredicate();
    test_ret += test_xmlXPathInit();
    test_ret += test_xmlXPathIsInf();
    test_ret += test_xmlXPathIsNaN();
    test_ret += test_xmlXPathNewContext();
    test_ret += test_xmlXPathNodeSetCreate();
    test_ret += test_xmlXPathObjectCopy();
    test_ret += test_xmlXPathOrderDocElems();

    if (test_ret != 0)
 printf("Module xpath: %d errors\n", test_ret);
    return(test_ret);
}



static xmlXPathParserContextPtr gen_xmlXPathParserContextPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 47002 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 47002 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlXPathParserContextPtr(int no __attribute__((unused)), xmlXPathParserContextPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_valuePop(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = valuePop(ctxt);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in valuePop",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_valuePush(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlXPathObjectPtr value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        value = gen_xmlXPathObjectPtr(n_value, 1);

        ret_val = valuePush(ctxt, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlXPathObjectPtr(n_value, value, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in valuePush",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathAddValues(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPathAddValues(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathAddValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathBooleanFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathBooleanFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathBooleanFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCeilingFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathCeilingFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCeilingFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCompareValues(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int inf;
    int n_inf;
    int strict;
    int n_strict;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_inf = 0;n_inf < 4;n_inf++) {
    for (n_strict = 0;n_strict < 4;n_strict++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        inf = gen_int(n_inf, 1);
        strict = gen_int(n_strict, 2);

        ret_val = xmlXPathCompareValues(ctxt, inf, strict);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_inf, inf, 1);
        des_int(n_strict, strict, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCompareValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_inf);
            printf(" %d", n_strict);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathConcatFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathConcatFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathConcatFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathContainsFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathContainsFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathContainsFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathCountFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathCountFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathCountFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathDebugDumpCompExpr(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlXPathCompExprPtr comp;
    int n_comp;
    int depth;
    int n_depth;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_comp = 0;n_comp < 1;n_comp++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
        mem_base = xmlMemBlocks();
        output = gen_FILE_ptr(n_output, 0);
        comp = gen_xmlXPathCompExprPtr(n_comp, 1);
        depth = gen_int(n_depth, 2);

        xmlXPathDebugDumpCompExpr(output, comp, depth);
        call_tests++;
        des_FILE_ptr(n_output, output, 0);
        des_xmlXPathCompExprPtr(n_comp, comp, 1);
        des_int(n_depth, depth, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathDebugDumpCompExpr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_comp);
            printf(" %d", n_depth);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathDebugDumpObject(void) {
    int test_ret = 0;


    int mem_base;
    FILE * output;
    int n_output;
    xmlXPathObjectPtr cur;
    int n_cur;
    int depth;
    int n_depth;

    for (n_output = 0;n_output < 2;n_output++) {
    for (n_cur = 0;n_cur < 5;n_cur++) {
    for (n_depth = 0;n_depth < 4;n_depth++) {
        mem_base = xmlMemBlocks();
        output = gen_FILE_ptr(n_output, 0);
        cur = gen_xmlXPathObjectPtr(n_cur, 1);
        depth = gen_int(n_depth, 2);

        xmlXPathDebugDumpObject(output, cur, depth);
        call_tests++;
        des_FILE_ptr(n_output, output, 0);
        des_xmlXPathObjectPtr(n_cur, cur, 1);
        des_int(n_depth, depth, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathDebugDumpObject",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_output);
            printf(" %d", n_cur);
            printf(" %d", n_depth);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathDifference(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes1;
    int n_nodes1;
    xmlNodeSetPtr nodes2;
    int n_nodes2;

    for (n_nodes1 = 0;n_nodes1 < 1;n_nodes1++) {
    for (n_nodes2 = 0;n_nodes2 < 1;n_nodes2++) {
        mem_base = xmlMemBlocks();
        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);

        ret_val = xmlXPathDifference(nodes1, nodes2);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathDifference",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes1);
            printf(" %d", n_nodes2);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathDistinct(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes;
    int n_nodes;

    for (n_nodes = 0;n_nodes < 1;n_nodes++) {
        mem_base = xmlMemBlocks();
        nodes = gen_xmlNodeSetPtr(n_nodes, 0);

        ret_val = xmlXPathDistinct(nodes);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes, nodes, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathDistinct",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathDistinctSorted(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes;
    int n_nodes;

    for (n_nodes = 0;n_nodes < 1;n_nodes++) {
        mem_base = xmlMemBlocks();
        nodes = gen_xmlNodeSetPtr(n_nodes, 0);

        ret_val = xmlXPathDistinctSorted(nodes);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes, nodes, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathDistinctSorted",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathDivValues(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPathDivValues(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathDivValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathEqualValues(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = xmlXPathEqualValues(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathEqualValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathErr(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int error;
    int n_error;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_error = 0;n_error < 4;n_error++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        error = gen_int(n_error, 1);

        xmlXPathErr(ctxt, error);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_error, error, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathErr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_error);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathEvalExpr(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPathEvalExpr(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathEvalExpr",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathEvaluatePredicateResult(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlXPathObjectPtr res;
    int n_res;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_res = 0;n_res < 5;n_res++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        res = gen_xmlXPathObjectPtr(n_res, 1);

        ret_val = xmlXPathEvaluatePredicateResult(ctxt, res);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlXPathObjectPtr(n_res, res, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathEvaluatePredicateResult",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_res);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathFalseFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathFalseFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathFalseFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathFloorFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathFloorFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathFloorFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathFunctionLookup(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPathFunctionLookupNS(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPathHasSameNodes(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodeSetPtr nodes1;
    int n_nodes1;
    xmlNodeSetPtr nodes2;
    int n_nodes2;

    for (n_nodes1 = 0;n_nodes1 < 1;n_nodes1++) {
    for (n_nodes2 = 0;n_nodes2 < 1;n_nodes2++) {
        mem_base = xmlMemBlocks();
        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);

        ret_val = xmlXPathHasSameNodes(nodes1, nodes2);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathHasSameNodes",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes1);
            printf(" %d", n_nodes2);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathIdFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathIdFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathIdFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathIntersection(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes1;
    int n_nodes1;
    xmlNodeSetPtr nodes2;
    int n_nodes2;

    for (n_nodes1 = 0;n_nodes1 < 1;n_nodes1++) {
    for (n_nodes2 = 0;n_nodes2 < 1;n_nodes2++) {
        mem_base = xmlMemBlocks();
        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);

        ret_val = xmlXPathIntersection(nodes1, nodes2);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathIntersection",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes1);
            printf(" %d", n_nodes2);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathIsNodeType(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlChar * name;
    int n_name;

    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        name = gen_const_xmlChar_ptr(n_name, 0);

        ret_val = xmlXPathIsNodeType((const xmlChar *)name);
        desret_int(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathIsNodeType",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_name);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathLangFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathLangFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathLangFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathLastFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathLastFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathLastFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathLeading(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes1;
    int n_nodes1;
    xmlNodeSetPtr nodes2;
    int n_nodes2;

    for (n_nodes1 = 0;n_nodes1 < 1;n_nodes1++) {
    for (n_nodes2 = 0;n_nodes2 < 1;n_nodes2++) {
        mem_base = xmlMemBlocks();
        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);

        ret_val = xmlXPathLeading(nodes1, nodes2);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathLeading",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes1);
            printf(" %d", n_nodes2);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathLeadingSorted(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes1;
    int n_nodes1;
    xmlNodeSetPtr nodes2;
    int n_nodes2;

    for (n_nodes1 = 0;n_nodes1 < 1;n_nodes1++) {
    for (n_nodes2 = 0;n_nodes2 < 1;n_nodes2++) {
        mem_base = xmlMemBlocks();
        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);

        ret_val = xmlXPathLeadingSorted(nodes1, nodes2);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathLeadingSorted",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes1);
            printf(" %d", n_nodes2);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathLocalNameFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathLocalNameFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathLocalNameFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathModValues(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPathModValues(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathModValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathMultValues(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPathMultValues(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathMultValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNamespaceURIFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathNamespaceURIFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNamespaceURIFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNewBoolean(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    int val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_int(n_val, 0);

        ret_val = xmlXPathNewBoolean(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_int(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNewBoolean",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNewCString(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    char * val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_const_char_ptr(n_val, 0);

        ret_val = xmlXPathNewCString((const char *)val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_const_char_ptr(n_val, (const char *)val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNewCString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNewFloat(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    double val;
    int n_val;

    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_double(n_val, 0);

        ret_val = xmlXPathNewFloat(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_double(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNewFloat",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNewNodeSet(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr val;
    int n_val;

    for (n_val = 0;n_val < 3;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlNodePtr(n_val, 0);

        ret_val = xmlXPathNewNodeSet(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNewNodeSet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNewNodeSetList(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodeSetPtr val;
    int n_val;

    for (n_val = 0;n_val < 1;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlNodeSetPtr(n_val, 0);

        ret_val = xmlXPathNewNodeSetList(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNewNodeSetList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNewParserContext(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPathNewString(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlChar * val;
    int n_val;

    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_const_xmlChar_ptr(n_val, 0);

        ret_val = xmlXPathNewString((const xmlChar *)val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_val, (const xmlChar *)val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNewString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextAncestor(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextAncestor(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextAncestor",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextAncestorOrSelf(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextAncestorOrSelf(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextAncestorOrSelf",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextAttribute(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextAttribute(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextAttribute",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextChild(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextChild(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextChild",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextDescendant(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextDescendant(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextDescendant",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextDescendantOrSelf(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextDescendantOrSelf(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextDescendantOrSelf",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextFollowing(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextFollowing(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextFollowing",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextFollowingSibling(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextFollowingSibling(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextFollowingSibling",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextNamespace(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextNamespace(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextNamespace",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextParent(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextParent(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextParent",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextPreceding(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextPreceding(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextPreceding",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextPrecedingSibling(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextPrecedingSibling(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextPrecedingSibling",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNextSelf(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    xmlNodePtr cur;
    int n_cur;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_cur = 0;n_cur < 3;n_cur++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        cur = gen_xmlNodePtr(n_cur, 1);

        ret_val = xmlXPathNextSelf(ctxt, cur);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_xmlNodePtr(n_cur, cur, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNextSelf",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_cur);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeLeading(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes;
    int n_nodes;
    xmlNodePtr node;
    int n_node;

    for (n_nodes = 0;n_nodes < 1;n_nodes++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlXPathNodeLeading(nodes, node);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes, nodes, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeLeading",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeLeadingSorted(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes;
    int n_nodes;
    xmlNodePtr node;
    int n_node;

    for (n_nodes = 0;n_nodes < 1;n_nodes++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlXPathNodeLeadingSorted(nodes, node);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes, nodes, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeLeadingSorted",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeSetAdd(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodeSetPtr cur;
    int n_cur;
    xmlNodePtr val;
    int n_val;

    for (n_cur = 0;n_cur < 1;n_cur++) {
    for (n_val = 0;n_val < 3;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodeSetPtr(n_cur, 0);
        val = gen_xmlNodePtr(n_val, 1);

        ret_val = xmlXPathNodeSetAdd(cur, val);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_cur, cur, 0);
        des_xmlNodePtr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeSetAdd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeSetAddNs(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodeSetPtr cur;
    int n_cur;
    xmlNodePtr node;
    int n_node;
    xmlNsPtr ns;
    int n_ns;

    for (n_cur = 0;n_cur < 1;n_cur++) {
    for (n_node = 0;n_node < 3;n_node++) {
    for (n_ns = 0;n_ns < 2;n_ns++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodeSetPtr(n_cur, 0);
        node = gen_xmlNodePtr(n_node, 1);
        ns = gen_xmlNsPtr(n_ns, 2);

        ret_val = xmlXPathNodeSetAddNs(cur, node, ns);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_cur, cur, 0);
        des_xmlNodePtr(n_node, node, 1);
        des_xmlNsPtr(n_ns, ns, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeSetAddNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_node);
            printf(" %d", n_ns);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeSetAddUnique(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodeSetPtr cur;
    int n_cur;
    xmlNodePtr val;
    int n_val;

    for (n_cur = 0;n_cur < 1;n_cur++) {
    for (n_val = 0;n_val < 3;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodeSetPtr(n_cur, 0);
        val = gen_xmlNodePtr(n_val, 1);

        ret_val = xmlXPathNodeSetAddUnique(cur, val);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_cur, cur, 0);
        des_xmlNodePtr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeSetAddUnique",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeSetContains(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlNodeSetPtr cur;
    int n_cur;
    xmlNodePtr val;
    int n_val;

    for (n_cur = 0;n_cur < 1;n_cur++) {
    for (n_val = 0;n_val < 3;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodeSetPtr(n_cur, 0);
        val = gen_xmlNodePtr(n_val, 1);

        ret_val = xmlXPathNodeSetContains(cur, val);
        desret_int(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_cur, cur, 0);
        des_xmlNodePtr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeSetContains",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeSetDel(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr cur;
    int n_cur;
    xmlNodePtr val;
    int n_val;

    for (n_cur = 0;n_cur < 1;n_cur++) {
    for (n_val = 0;n_val < 3;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodeSetPtr(n_cur, 0);
        val = gen_xmlNodePtr(n_val, 1);

        xmlXPathNodeSetDel(cur, val);
        call_tests++;
        des_xmlNodeSetPtr(n_cur, cur, 0);
        des_xmlNodePtr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeSetDel",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeSetMerge(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr val1;
    int n_val1;
    xmlNodeSetPtr val2;
    int n_val2;

    for (n_val1 = 0;n_val1 < 1;n_val1++) {
    for (n_val2 = 0;n_val2 < 1;n_val2++) {
        mem_base = xmlMemBlocks();
        val1 = gen_xmlNodeSetPtr(n_val1, 0);
        val2 = gen_xmlNodeSetPtr(n_val2, 1);

        ret_val = xmlXPathNodeSetMerge(val1, val2);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_val1, val1, 0);
        des_xmlNodeSetPtr(n_val2, val2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeSetMerge",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val1);
            printf(" %d", n_val2);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeSetRemove(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr cur;
    int n_cur;
    int val;
    int n_val;

    for (n_cur = 0;n_cur < 1;n_cur++) {
    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlNodeSetPtr(n_cur, 0);
        val = gen_int(n_val, 1);

        xmlXPathNodeSetRemove(cur, val);
        call_tests++;
        des_xmlNodeSetPtr(n_cur, cur, 0);
        des_int(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeSetRemove",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeSetSort(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr set;
    int n_set;

    for (n_set = 0;n_set < 1;n_set++) {
        mem_base = xmlMemBlocks();
        set = gen_xmlNodeSetPtr(n_set, 0);

        xmlXPathNodeSetSort(set);
        call_tests++;
        des_xmlNodeSetPtr(n_set, set, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeSetSort",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_set);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeTrailing(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes;
    int n_nodes;
    xmlNodePtr node;
    int n_node;

    for (n_nodes = 0;n_nodes < 1;n_nodes++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlXPathNodeTrailing(nodes, node);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes, nodes, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeTrailing",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNodeTrailingSorted(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes;
    int n_nodes;
    xmlNodePtr node;
    int n_node;

    for (n_nodes = 0;n_nodes < 1;n_nodes++) {
    for (n_node = 0;n_node < 3;n_node++) {
        mem_base = xmlMemBlocks();
        nodes = gen_xmlNodeSetPtr(n_nodes, 0);
        node = gen_xmlNodePtr(n_node, 1);

        ret_val = xmlXPathNodeTrailingSorted(nodes, node);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes, nodes, 0);
        des_xmlNodePtr(n_node, node, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNodeTrailingSorted",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes);
            printf(" %d", n_node);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNormalizeFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathNormalizeFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNormalizeFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNotEqualValues(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = xmlXPathNotEqualValues(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNotEqualValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNotFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathNotFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNotFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNsLookup(void) {
    int test_ret = 0;


    int mem_base;
    const xmlChar * ret_val;
    xmlXPathContextPtr ctxt;
    int n_ctxt;
    xmlChar * prefix;
    int n_prefix;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);

        ret_val = xmlXPathNsLookup(ctxt, (const xmlChar *)prefix);
        desret_const_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNsLookup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_prefix);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathNumberFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathNumberFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathNumberFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathParseNCName(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = xmlXPathParseNCName(ctxt);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathParseNCName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathParseName(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = xmlXPathParseName(ctxt);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathParseName",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathPopBoolean(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = xmlXPathPopBoolean(ctxt);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathPopBoolean",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathPopExternal(void) {
    int test_ret = 0;


    int mem_base;
    void * ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = xmlXPathPopExternal(ctxt);
        desret_void_ptr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathPopExternal",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathPopNodeSet(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = xmlXPathPopNodeSet(ctxt);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathPopNodeSet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathPopNumber(void) {
    int test_ret = 0;


    int mem_base;
    double ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = xmlXPathPopNumber(ctxt);
        desret_double(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathPopNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathPopString(void) {
    int test_ret = 0;


    int mem_base;
    xmlChar * ret_val;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        ret_val = xmlXPathPopString(ctxt);
        desret_xmlChar_ptr(ret_val);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathPopString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathPositionFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathPositionFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathPositionFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathRegisterAllFunctions(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);

        xmlXPathRegisterAllFunctions(ctxt);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathRegisterAllFunctions",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathRegisterFunc(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPathRegisterFuncLookup(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPathRegisterFuncNS(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPathRegisterNs(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathContextPtr ctxt;
    int n_ctxt;
    xmlChar * prefix;
    int n_prefix;
    xmlChar * ns_uri;
    int n_ns_uri;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_prefix = 0;n_prefix < 5;n_prefix++) {
    for (n_ns_uri = 0;n_ns_uri < 5;n_ns_uri++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        prefix = gen_const_xmlChar_ptr(n_prefix, 1);
        ns_uri = gen_const_xmlChar_ptr(n_ns_uri, 2);

        ret_val = xmlXPathRegisterNs(ctxt, (const xmlChar *)prefix, (const xmlChar *)ns_uri);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_prefix, (const xmlChar *)prefix, 1);
        des_const_xmlChar_ptr(n_ns_uri, (const xmlChar *)ns_uri, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathRegisterNs",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_prefix);
            printf(" %d", n_ns_uri);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathRegisterVariable(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathContextPtr ctxt;
    int n_ctxt;
    xmlChar * name;
    int n_name;
    xmlXPathObjectPtr value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        value = gen_xmlXPathObjectPtr(n_value, 2);

        ret_val = xmlXPathRegisterVariable(ctxt, (const xmlChar *)name, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_xmlXPathObjectPtr(n_value, value, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathRegisterVariable",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathRegisterVariableLookup(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPathRegisterVariableNS(void) {
    int test_ret = 0;


    int mem_base;
    int ret_val;
    xmlXPathContextPtr ctxt;
    int n_ctxt;
    xmlChar * name;
    int n_name;
    xmlChar * ns_uri;
    int n_ns_uri;
    xmlXPathObjectPtr value;
    int n_value;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ns_uri = 0;n_ns_uri < 5;n_ns_uri++) {
    for (n_value = 0;n_value < 5;n_value++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ns_uri = gen_const_xmlChar_ptr(n_ns_uri, 2);
        value = gen_xmlXPathObjectPtr(n_value, 3);

        ret_val = xmlXPathRegisterVariableNS(ctxt, (const xmlChar *)name, (const xmlChar *)ns_uri, value);
        desret_int(ret_val);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_ns_uri, (const xmlChar *)ns_uri, 2);
        des_xmlXPathObjectPtr(n_value, value, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathRegisterVariableNS",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_ns_uri);
            printf(" %d", n_value);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathRegisteredFuncsCleanup(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);

        xmlXPathRegisteredFuncsCleanup(ctxt);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathRegisteredFuncsCleanup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathRegisteredNsCleanup(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);

        xmlXPathRegisteredNsCleanup(ctxt);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathRegisteredNsCleanup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathRegisteredVariablesCleanup(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);

        xmlXPathRegisteredVariablesCleanup(ctxt);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathRegisteredVariablesCleanup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathRoot(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPathRoot(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathRoot",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathRoundFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathRoundFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathRoundFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathStartsWithFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathStartsWithFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathStartsWithFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathStringEvalNumber(void) {
    int test_ret = 0;


    int mem_base;
    double ret_val;
    xmlChar * str;
    int n_str;

    for (n_str = 0;n_str < 5;n_str++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);

        ret_val = xmlXPathStringEvalNumber((const xmlChar *)str);
        desret_double(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathStringEvalNumber",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathStringFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathStringFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathStringFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathStringLengthFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathStringLengthFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathStringLengthFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathSubValues(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPathSubValues(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathSubValues",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathSubstringAfterFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathSubstringAfterFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathSubstringAfterFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathSubstringBeforeFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathSubstringBeforeFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathSubstringBeforeFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathSubstringFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathSubstringFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathSubstringFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathSumFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathSumFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathSumFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathTrailing(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes1;
    int n_nodes1;
    xmlNodeSetPtr nodes2;
    int n_nodes2;

    for (n_nodes1 = 0;n_nodes1 < 1;n_nodes1++) {
    for (n_nodes2 = 0;n_nodes2 < 1;n_nodes2++) {
        mem_base = xmlMemBlocks();
        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);

        ret_val = xmlXPathTrailing(nodes1, nodes2);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathTrailing",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes1);
            printf(" %d", n_nodes2);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathTrailingSorted(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodeSetPtr ret_val;
    xmlNodeSetPtr nodes1;
    int n_nodes1;
    xmlNodeSetPtr nodes2;
    int n_nodes2;

    for (n_nodes1 = 0;n_nodes1 < 1;n_nodes1++) {
    for (n_nodes2 = 0;n_nodes2 < 1;n_nodes2++) {
        mem_base = xmlMemBlocks();
        nodes1 = gen_xmlNodeSetPtr(n_nodes1, 0);
        nodes2 = gen_xmlNodeSetPtr(n_nodes2, 1);

        ret_val = xmlXPathTrailingSorted(nodes1, nodes2);
        desret_xmlNodeSetPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_nodes1, nodes1, 0);
        des_xmlNodeSetPtr(n_nodes2, nodes2, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathTrailingSorted",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_nodes1);
            printf(" %d", n_nodes2);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathTranslateFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathTranslateFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathTranslateFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathTrueFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPathTrueFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathTrueFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathValueFlipSign(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPathValueFlipSign(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathValueFlipSign",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathVariableLookup(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathContextPtr ctxt;
    int n_ctxt;
    xmlChar * name;
    int n_name;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_name = 0;n_name < 5;n_name++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);

        ret_val = xmlXPathVariableLookup(ctxt, (const xmlChar *)name);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathVariableLookup",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathVariableLookupNS(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathContextPtr ctxt;
    int n_ctxt;
    xmlChar * name;
    int n_name;
    xmlChar * ns_uri;
    int n_ns_uri;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_name = 0;n_name < 5;n_name++) {
    for (n_ns_uri = 0;n_ns_uri < 5;n_ns_uri++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathContextPtr(n_ctxt, 0);
        name = gen_const_xmlChar_ptr(n_name, 1);
        ns_uri = gen_const_xmlChar_ptr(n_ns_uri, 2);

        ret_val = xmlXPathVariableLookupNS(ctxt, (const xmlChar *)name, (const xmlChar *)ns_uri);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathContextPtr(n_ctxt, ctxt, 0);
        des_const_xmlChar_ptr(n_name, (const xmlChar *)name, 1);
        des_const_xmlChar_ptr(n_ns_uri, (const xmlChar *)ns_uri, 2);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathVariableLookupNS",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_name);
            printf(" %d", n_ns_uri);
            printf("\n");
        }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathWrapCString(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    char * val;
    int n_val;

    for (n_val = 0;n_val < 1;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_char_ptr(n_val, 0);

        ret_val = xmlXPathWrapCString(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_char_ptr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathWrapCString",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathWrapExternal(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    void * val;
    int n_val;

    for (n_val = 0;n_val < 2;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_void_ptr(n_val, 0);

        ret_val = xmlXPathWrapExternal(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_void_ptr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathWrapExternal",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPathWrapNodeSet(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodeSetPtr val;
    int n_val;

    for (n_val = 0;n_val < 1;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlNodeSetPtr(n_val, 0);

        ret_val = xmlXPathWrapNodeSet(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPathWrapNodeSet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPatherror(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    const char * file;
    int n_file;
    int line;
    int n_line;
    int no;
    int n_no;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_file = 0;n_file < 8;n_file++) {
    for (n_line = 0;n_line < 4;n_line++) {
    for (n_no = 0;n_no < 4;n_no++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        file = gen_filepath(n_file, 1);
        line = gen_int(n_line, 2);
        no = gen_int(n_no, 3);

        xmlXPatherror(ctxt, file, line, no);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_filepath(n_file, file, 1);
        des_int(n_line, line, 2);
        des_int(n_no, no, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPatherror",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_file);
            printf(" %d", n_line);
            printf(" %d", n_no);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xpathInternals(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xpathInternals : 106 of 117 functions ...\n");
    test_ret += test_valuePop();
    test_ret += test_valuePush();
    test_ret += test_xmlXPathAddValues();
    test_ret += test_xmlXPathBooleanFunction();
    test_ret += test_xmlXPathCeilingFunction();
    test_ret += test_xmlXPathCompareValues();
    test_ret += test_xmlXPathConcatFunction();
    test_ret += test_xmlXPathContainsFunction();
    test_ret += test_xmlXPathCountFunction();
    test_ret += test_xmlXPathDebugDumpCompExpr();
    test_ret += test_xmlXPathDebugDumpObject();
    test_ret += test_xmlXPathDifference();
    test_ret += test_xmlXPathDistinct();
    test_ret += test_xmlXPathDistinctSorted();
    test_ret += test_xmlXPathDivValues();
    test_ret += test_xmlXPathEqualValues();
    test_ret += test_xmlXPathErr();
    test_ret += test_xmlXPathEvalExpr();
    test_ret += test_xmlXPathEvaluatePredicateResult();
    test_ret += test_xmlXPathFalseFunction();
    test_ret += test_xmlXPathFloorFunction();
    test_ret += test_xmlXPathFunctionLookup();
    test_ret += test_xmlXPathFunctionLookupNS();
    test_ret += test_xmlXPathHasSameNodes();
    test_ret += test_xmlXPathIdFunction();
    test_ret += test_xmlXPathIntersection();
    test_ret += test_xmlXPathIsNodeType();
    test_ret += test_xmlXPathLangFunction();
    test_ret += test_xmlXPathLastFunction();
    test_ret += test_xmlXPathLeading();
    test_ret += test_xmlXPathLeadingSorted();
    test_ret += test_xmlXPathLocalNameFunction();
    test_ret += test_xmlXPathModValues();
    test_ret += test_xmlXPathMultValues();
    test_ret += test_xmlXPathNamespaceURIFunction();
    test_ret += test_xmlXPathNewBoolean();
    test_ret += test_xmlXPathNewCString();
    test_ret += test_xmlXPathNewFloat();
    test_ret += test_xmlXPathNewNodeSet();
    test_ret += test_xmlXPathNewNodeSetList();
    test_ret += test_xmlXPathNewParserContext();
    test_ret += test_xmlXPathNewString();
    test_ret += test_xmlXPathNextAncestor();
    test_ret += test_xmlXPathNextAncestorOrSelf();
    test_ret += test_xmlXPathNextAttribute();
    test_ret += test_xmlXPathNextChild();
    test_ret += test_xmlXPathNextDescendant();
    test_ret += test_xmlXPathNextDescendantOrSelf();
    test_ret += test_xmlXPathNextFollowing();
    test_ret += test_xmlXPathNextFollowingSibling();
    test_ret += test_xmlXPathNextNamespace();
    test_ret += test_xmlXPathNextParent();
    test_ret += test_xmlXPathNextPreceding();
    test_ret += test_xmlXPathNextPrecedingSibling();
    test_ret += test_xmlXPathNextSelf();
    test_ret += test_xmlXPathNodeLeading();
    test_ret += test_xmlXPathNodeLeadingSorted();
    test_ret += test_xmlXPathNodeSetAdd();
    test_ret += test_xmlXPathNodeSetAddNs();
    test_ret += test_xmlXPathNodeSetAddUnique();
    test_ret += test_xmlXPathNodeSetContains();
    test_ret += test_xmlXPathNodeSetDel();
    test_ret += test_xmlXPathNodeSetMerge();
    test_ret += test_xmlXPathNodeSetRemove();
    test_ret += test_xmlXPathNodeSetSort();
    test_ret += test_xmlXPathNodeTrailing();
    test_ret += test_xmlXPathNodeTrailingSorted();
    test_ret += test_xmlXPathNormalizeFunction();
    test_ret += test_xmlXPathNotEqualValues();
    test_ret += test_xmlXPathNotFunction();
    test_ret += test_xmlXPathNsLookup();
    test_ret += test_xmlXPathNumberFunction();
    test_ret += test_xmlXPathParseNCName();
    test_ret += test_xmlXPathParseName();
    test_ret += test_xmlXPathPopBoolean();
    test_ret += test_xmlXPathPopExternal();
    test_ret += test_xmlXPathPopNodeSet();
    test_ret += test_xmlXPathPopNumber();
    test_ret += test_xmlXPathPopString();
    test_ret += test_xmlXPathPositionFunction();
    test_ret += test_xmlXPathRegisterAllFunctions();
    test_ret += test_xmlXPathRegisterFunc();
    test_ret += test_xmlXPathRegisterFuncLookup();
    test_ret += test_xmlXPathRegisterFuncNS();
    test_ret += test_xmlXPathRegisterNs();
    test_ret += test_xmlXPathRegisterVariable();
    test_ret += test_xmlXPathRegisterVariableLookup();
    test_ret += test_xmlXPathRegisterVariableNS();
    test_ret += test_xmlXPathRegisteredFuncsCleanup();
    test_ret += test_xmlXPathRegisteredNsCleanup();
    test_ret += test_xmlXPathRegisteredVariablesCleanup();
    test_ret += test_xmlXPathRoot();
    test_ret += test_xmlXPathRoundFunction();
    test_ret += test_xmlXPathStartsWithFunction();
    test_ret += test_xmlXPathStringEvalNumber();
    test_ret += test_xmlXPathStringFunction();
    test_ret += test_xmlXPathStringLengthFunction();
    test_ret += test_xmlXPathSubValues();
    test_ret += test_xmlXPathSubstringAfterFunction();
    test_ret += test_xmlXPathSubstringBeforeFunction();
    test_ret += test_xmlXPathSubstringFunction();
    test_ret += test_xmlXPathSumFunction();
    test_ret += test_xmlXPathTrailing();
    test_ret += test_xmlXPathTrailingSorted();
    test_ret += test_xmlXPathTranslateFunction();
    test_ret += test_xmlXPathTrueFunction();
    test_ret += test_xmlXPathValueFlipSign();
    test_ret += test_xmlXPathVariableLookup();
    test_ret += test_xmlXPathVariableLookupNS();
    test_ret += test_xmlXPathWrapCString();
    test_ret += test_xmlXPathWrapExternal();
    test_ret += test_xmlXPathWrapNodeSet();
    test_ret += test_xmlXPatherror();

    if (test_ret != 0)
 printf("Module xpathInternals: %d errors\n", test_ret);
    return(test_ret);
}

static int
test_xmlXPtrBuildNodeList(void) {
    int test_ret = 0;


    int mem_base;
    xmlNodePtr ret_val;
    xmlXPathObjectPtr obj;
    int n_obj;

    for (n_obj = 0;n_obj < 5;n_obj++) {
        mem_base = xmlMemBlocks();
        obj = gen_xmlXPathObjectPtr(n_obj, 0);

        ret_val = xmlXPtrBuildNodeList(obj);
        desret_xmlNodePtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_obj, obj, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrBuildNodeList",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_obj);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrEval(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlChar * str;
    int n_str;
    xmlXPathContextPtr ctx;
    int n_ctx;

    for (n_str = 0;n_str < 5;n_str++) {
    for (n_ctx = 0;n_ctx < 1;n_ctx++) {
        mem_base = xmlMemBlocks();
        str = gen_const_xmlChar_ptr(n_str, 0);
        ctx = gen_xmlXPathContextPtr(n_ctx, 1);

        ret_val = xmlXPtrEval((const xmlChar *)str, ctx);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_const_xmlChar_ptr(n_str, (const xmlChar *)str, 0);
        des_xmlXPathContextPtr(n_ctx, ctx, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrEval",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_str);
            printf(" %d", n_ctx);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrEvalRangePredicate(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);

        xmlXPtrEvalRangePredicate(ctxt);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrEvalRangePredicate",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}




static xmlLocationSetPtr gen_xmlLocationSetPtr(int no __attribute__((unused)), int nr __attribute__((unused))) {
    return(
# 51393 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c" 3 4
          ((void *)0)
# 51393 "/doner/libxml2/libxml2-4ea74a44/libxml2/testapi.c"
              );
}
static void des_xmlLocationSetPtr(int no __attribute__((unused)), xmlLocationSetPtr val __attribute__((unused)), int nr __attribute__((unused))) {
}



static int
test_xmlXPtrLocationSetAdd(void) {
    int test_ret = 0;


    int mem_base;
    xmlLocationSetPtr cur;
    int n_cur;
    xmlXPathObjectPtr val;
    int n_val;

    for (n_cur = 0;n_cur < 1;n_cur++) {
    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlLocationSetPtr(n_cur, 0);
        val = gen_xmlXPathObjectPtr(n_val, 1);

        xmlXPtrLocationSetAdd(cur, val);
        call_tests++;
        des_xmlLocationSetPtr(n_cur, cur, 0);
        des_xmlXPathObjectPtr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrLocationSetAdd",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrLocationSetCreate(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPtrLocationSetDel(void) {
    int test_ret = 0;


    int mem_base;
    xmlLocationSetPtr cur;
    int n_cur;
    xmlXPathObjectPtr val;
    int n_val;

    for (n_cur = 0;n_cur < 1;n_cur++) {
    for (n_val = 0;n_val < 5;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlLocationSetPtr(n_cur, 0);
        val = gen_xmlXPathObjectPtr(n_val, 1);

        xmlXPtrLocationSetDel(cur, val);
        call_tests++;
        des_xmlLocationSetPtr(n_cur, cur, 0);
        des_xmlXPathObjectPtr(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrLocationSetDel",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrLocationSetMerge(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPtrLocationSetRemove(void) {
    int test_ret = 0;


    int mem_base;
    xmlLocationSetPtr cur;
    int n_cur;
    int val;
    int n_val;

    for (n_cur = 0;n_cur < 1;n_cur++) {
    for (n_val = 0;n_val < 4;n_val++) {
        mem_base = xmlMemBlocks();
        cur = gen_xmlLocationSetPtr(n_cur, 0);
        val = gen_int(n_val, 1);

        xmlXPtrLocationSetRemove(cur, val);
        call_tests++;
        des_xmlLocationSetPtr(n_cur, cur, 0);
        des_int(n_val, val, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrLocationSetRemove",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_cur);
            printf(" %d", n_val);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrNewCollapsedRange(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start;
    int n_start;

    for (n_start = 0;n_start < 3;n_start++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);

        ret_val = xmlXPtrNewCollapsedRange(start);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewCollapsedRange",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_start);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrNewContext(void) {
    int test_ret = 0;



    return(test_ret);
}


static int
test_xmlXPtrNewLocationSetNodeSet(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodeSetPtr set;
    int n_set;

    for (n_set = 0;n_set < 1;n_set++) {
        mem_base = xmlMemBlocks();
        set = gen_xmlNodeSetPtr(n_set, 0);

        ret_val = xmlXPtrNewLocationSetNodeSet(set);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodeSetPtr(n_set, set, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewLocationSetNodeSet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_set);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrNewLocationSetNodes(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start;
    int n_start;
    xmlNodePtr end;
    int n_end;

    for (n_start = 0;n_start < 3;n_start++) {
    for (n_end = 0;n_end < 3;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlNodePtr(n_end, 1);

        ret_val = xmlXPtrNewLocationSetNodes(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlNodePtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewLocationSetNodes",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrNewRange(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start;
    int n_start;
    int startindex;
    int n_startindex;
    xmlNodePtr end;
    int n_end;
    int endindex;
    int n_endindex;

    for (n_start = 0;n_start < 3;n_start++) {
    for (n_startindex = 0;n_startindex < 4;n_startindex++) {
    for (n_end = 0;n_end < 3;n_end++) {
    for (n_endindex = 0;n_endindex < 4;n_endindex++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        startindex = gen_int(n_startindex, 1);
        end = gen_xmlNodePtr(n_end, 2);
        endindex = gen_int(n_endindex, 3);

        ret_val = xmlXPtrNewRange(start, startindex, end, endindex);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_int(n_startindex, startindex, 1);
        des_xmlNodePtr(n_end, end, 2);
        des_int(n_endindex, endindex, 3);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRange",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_start);
            printf(" %d", n_startindex);
            printf(" %d", n_end);
            printf(" %d", n_endindex);
            printf("\n");
        }
    }
    }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrNewRangeNodeObject(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start;
    int n_start;
    xmlXPathObjectPtr end;
    int n_end;

    for (n_start = 0;n_start < 3;n_start++) {
    for (n_end = 0;n_end < 5;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlXPathObjectPtr(n_end, 1);

        ret_val = xmlXPtrNewRangeNodeObject(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlXPathObjectPtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangeNodeObject",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrNewRangeNodePoint(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start;
    int n_start;
    xmlXPathObjectPtr end;
    int n_end;

    for (n_start = 0;n_start < 3;n_start++) {
    for (n_end = 0;n_end < 5;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlXPathObjectPtr(n_end, 1);

        ret_val = xmlXPtrNewRangeNodePoint(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlXPathObjectPtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangeNodePoint",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrNewRangeNodes(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlNodePtr start;
    int n_start;
    xmlNodePtr end;
    int n_end;

    for (n_start = 0;n_start < 3;n_start++) {
    for (n_end = 0;n_end < 3;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlNodePtr(n_start, 0);
        end = gen_xmlNodePtr(n_end, 1);

        ret_val = xmlXPtrNewRangeNodes(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlNodePtr(n_start, start, 0);
        des_xmlNodePtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangeNodes",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrNewRangePointNode(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr start;
    int n_start;
    xmlNodePtr end;
    int n_end;

    for (n_start = 0;n_start < 5;n_start++) {
    for (n_end = 0;n_end < 3;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlXPathObjectPtr(n_start, 0);
        end = gen_xmlNodePtr(n_end, 1);

        ret_val = xmlXPtrNewRangePointNode(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_start, start, 0);
        des_xmlNodePtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangePointNode",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrNewRangePoints(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlXPathObjectPtr start;
    int n_start;
    xmlXPathObjectPtr end;
    int n_end;

    for (n_start = 0;n_start < 5;n_start++) {
    for (n_end = 0;n_end < 5;n_end++) {
        mem_base = xmlMemBlocks();
        start = gen_xmlXPathObjectPtr(n_start, 0);
        end = gen_xmlXPathObjectPtr(n_end, 1);

        ret_val = xmlXPtrNewRangePoints(start, end);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlXPathObjectPtr(n_start, start, 0);
        des_xmlXPathObjectPtr(n_end, end, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrNewRangePoints",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_start);
            printf(" %d", n_end);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrRangeToFunction(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathParserContextPtr ctxt;
    int n_ctxt;
    int nargs;
    int n_nargs;

    for (n_ctxt = 0;n_ctxt < 1;n_ctxt++) {
    for (n_nargs = 0;n_nargs < 4;n_nargs++) {
        mem_base = xmlMemBlocks();
        ctxt = gen_xmlXPathParserContextPtr(n_ctxt, 0);
        nargs = gen_int(n_nargs, 1);

        xmlXPtrRangeToFunction(ctxt, nargs);
        call_tests++;
        des_xmlXPathParserContextPtr(n_ctxt, ctxt, 0);
        des_int(n_nargs, nargs, 1);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrRangeToFunction",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_ctxt);
            printf(" %d", n_nargs);
            printf("\n");
        }
    }
    }
    function_tests++;


    return(test_ret);
}


static int
test_xmlXPtrWrapLocationSet(void) {
    int test_ret = 0;


    int mem_base;
    xmlXPathObjectPtr ret_val;
    xmlLocationSetPtr val;
    int n_val;

    for (n_val = 0;n_val < 1;n_val++) {
        mem_base = xmlMemBlocks();
        val = gen_xmlLocationSetPtr(n_val, 0);

        ret_val = xmlXPtrWrapLocationSet(val);
        desret_xmlXPathObjectPtr(ret_val);
        call_tests++;
        des_xmlLocationSetPtr(n_val, val, 0);
        xmlResetLastError();
        if (mem_base != xmlMemBlocks()) {
            printf("Leak of %d blocks found in xmlXPtrWrapLocationSet",
            xmlMemBlocks() - mem_base);
     test_ret++;
            printf(" %d", n_val);
            printf("\n");
        }
    }
    function_tests++;


    return(test_ret);
}

static int
test_xpointer(void) {
    int test_ret = 0;

    if (quiet == 0) printf("Testing xpointer : 17 of 21 functions ...\n");
    test_ret += test_xmlXPtrBuildNodeList();
    test_ret += test_xmlXPtrEval();
    test_ret += test_xmlXPtrEvalRangePredicate();
    test_ret += test_xmlXPtrLocationSetAdd();
    test_ret += test_xmlXPtrLocationSetCreate();
    test_ret += test_xmlXPtrLocationSetDel();
    test_ret += test_xmlXPtrLocationSetMerge();
    test_ret += test_xmlXPtrLocationSetRemove();
    test_ret += test_xmlXPtrNewCollapsedRange();
    test_ret += test_xmlXPtrNewContext();
    test_ret += test_xmlXPtrNewLocationSetNodeSet();
    test_ret += test_xmlXPtrNewLocationSetNodes();
    test_ret += test_xmlXPtrNewRange();
    test_ret += test_xmlXPtrNewRangeNodeObject();
    test_ret += test_xmlXPtrNewRangeNodePoint();
    test_ret += test_xmlXPtrNewRangeNodes();
    test_ret += test_xmlXPtrNewRangePointNode();
    test_ret += test_xmlXPtrNewRangePoints();
    test_ret += test_xmlXPtrRangeToFunction();
    test_ret += test_xmlXPtrWrapLocationSet();

    if (test_ret != 0)
 printf("Module xpointer: %d errors\n", test_ret);
    return(test_ret);
}
static int
test_module(const char *module) {
    if (!strcmp(module, "HTMLparser")) return(test_HTMLparser());
    if (!strcmp(module, "HTMLtree")) return(test_HTMLtree());
    if (!strcmp(module, "SAX2")) return(test_SAX2());
    if (!strcmp(module, "c14n")) return(test_c14n());
    if (!strcmp(module, "catalog")) return(test_catalog());
    if (!strcmp(module, "chvalid")) return(test_chvalid());
    if (!strcmp(module, "debugXML")) return(test_debugXML());
    if (!strcmp(module, "dict")) return(test_dict());
    if (!strcmp(module, "encoding")) return(test_encoding());
    if (!strcmp(module, "entities")) return(test_entities());
    if (!strcmp(module, "hash")) return(test_hash());
    if (!strcmp(module, "list")) return(test_list());
    if (!strcmp(module, "nanoftp")) return(test_nanoftp());
    if (!strcmp(module, "nanohttp")) return(test_nanohttp());
    if (!strcmp(module, "parser")) return(test_parser());
    if (!strcmp(module, "parserInternals")) return(test_parserInternals());
    if (!strcmp(module, "pattern")) return(test_pattern());
    if (!strcmp(module, "relaxng")) return(test_relaxng());
    if (!strcmp(module, "schemasInternals")) return(test_schemasInternals());
    if (!strcmp(module, "schematron")) return(test_schematron());
    if (!strcmp(module, "tree")) return(test_tree());
    if (!strcmp(module, "uri")) return(test_uri());
    if (!strcmp(module, "valid")) return(test_valid());
    if (!strcmp(module, "xinclude")) return(test_xinclude());
    if (!strcmp(module, "xmlIO")) return(test_xmlIO());
    if (!strcmp(module, "xmlautomata")) return(test_xmlautomata());
    if (!strcmp(module, "xmlerror")) return(test_xmlerror());
    if (!strcmp(module, "xmlmodule")) return(test_xmlmodule());
    if (!strcmp(module, "xmlreader")) return(test_xmlreader());
    if (!strcmp(module, "xmlregexp")) return(test_xmlregexp());
    if (!strcmp(module, "xmlsave")) return(test_xmlsave());
    if (!strcmp(module, "xmlschemas")) return(test_xmlschemas());
    if (!strcmp(module, "xmlschemastypes")) return(test_xmlschemastypes());
    if (!strcmp(module, "xmlstring")) return(test_xmlstring());
    if (!strcmp(module, "xmlunicode")) return(test_xmlunicode());
    if (!strcmp(module, "xmlwriter")) return(test_xmlwriter());
    if (!strcmp(module, "xpath")) return(test_xpath());
    if (!strcmp(module, "xpathInternals")) return(test_xpathInternals());
    if (!strcmp(module, "xpointer")) return(test_xpointer());
    return(0);
}
