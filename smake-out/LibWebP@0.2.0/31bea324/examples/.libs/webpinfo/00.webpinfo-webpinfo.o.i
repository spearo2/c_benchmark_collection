# 1 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
# 1 "/doner/libwebp/libwebp-31bea324/examples//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
# 15 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
# 1 "/usr/include/assert.h" 1 3 4
# 35 "/usr/include/assert.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 36 "/usr/include/assert.h" 2 3 4
# 16 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4
# 52 "/usr/include/stdio.h" 3 4
typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 77 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 173 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
# 187 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 279 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 292 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 379 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                          __attribute__ ((__warn_unused_result__));
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                         __attribute__ ((__warn_unused_result__));
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 757 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) __attribute__ ((__warn_unused_result__));





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 840 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 127 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 865 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, const char *__restrict __fmt, ...)
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...)

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     const char *__restrict __format, ...);
extern int __printf_chk (int __flag, const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vfprintf (FILE *__restrict __stream,
   const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}


extern int __dprintf_chk (int __fd, int __flag, const char *__restrict __fmt,
     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __vdprintf_chk (int __fd, int __flag,
      const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
dprintf (int __fd, const char *__restrict __fmt, ...)
{
  return __dprintf_chk (__fd, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}





extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vdprintf (int __fd, const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
}
# 243 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")

                                        __attribute__ ((__warn_unused_result__));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 2 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 2 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}
# 329 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")


                     __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
                                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
         __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
       __stream);
    }


  if (__builtin_constant_p (__size)
      && __builtin_constant_p (__n)
      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
      && __size * __n <= 8)
    {
      size_t __cnt = __size * __n;
      char *__cptr = (char *) __ptr;
      if (__cnt == 0)
 return 0;

      for (; __cnt > 0; --__cnt)
 {
   int __c = getc_unlocked (__stream);
   if (__c == (-1))
     break;
   *__cptr++ = __c;
 }
      return (__cptr - (char *) __ptr) / __size;
    }

  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}
# 868 "/usr/include/stdio.h" 2 3 4






# 17 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 2


# 1 "../src/webp/config.h" 1
# 20 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 2


# 1 "/doner/libwebp/libwebp-31bea324/examples/../imageio/imageio_util.h" 1
# 17 "/doner/libwebp/libwebp-31bea324/examples/../imageio/imageio_util.h"
# 1 "../src/webp/types.h" 1
# 17 "../src/webp/types.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;
# 18 "../src/webp/types.h" 2


# 1 "/usr/include/inttypes.h" 1 3 4
# 27 "/usr/include/inttypes.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 2 3 4
# 28 "/usr/include/inttypes.h" 2 3 4






typedef int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));





extern long int __strtol_internal (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__nothrow__ , __leaf__)) strtoimax (const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __strtoul_internal (const char *__restrict __nptr,
          char ** __restrict __endptr,
          int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__nothrow__ , __leaf__)) strtoumax (const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtoul_internal (nptr, endptr, base, 0);
}

extern long int __wcstol_internal (const __gwchar_t * __restrict __nptr,
       __gwchar_t **__restrict __endptr,
       int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__nothrow__ , __leaf__)) wcstoimax (const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __wcstoul_internal (const __gwchar_t *
          __restrict __nptr,
          __gwchar_t **
          __restrict __endptr,
          int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__nothrow__ , __leaf__)) wcstoumax (const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstoul_internal (nptr, endptr, base, 0);
}
# 432 "/usr/include/inttypes.h" 3 4

# 21 "../src/webp/types.h" 2
# 63 "../src/webp/types.h"

# 63 "../src/webp/types.h"
extern __attribute__ ((visibility ("default"))) void* WebPMalloc(size_t size);


extern __attribute__ ((visibility ("default"))) void WebPFree(void* ptr);
# 18 "/doner/libwebp/libwebp-31bea324/examples/../imageio/imageio_util.h" 2
# 28 "/doner/libwebp/libwebp-31bea324/examples/../imageio/imageio_util.h"
FILE* ImgIoUtilSetBinaryMode(FILE* file);
# 38 "/doner/libwebp/libwebp-31bea324/examples/../imageio/imageio_util.h"
int ImgIoUtilReadFile(const char* const file_name,
                      const uint8_t** data, size_t* data_size);


int ImgIoUtilReadFromStdin(const uint8_t** data, size_t* data_size);



int ImgIoUtilWriteFile(const char* const file_name,
                       const uint8_t* data, size_t data_size);




void ImgIoUtilCopyPlane(const uint8_t* src, int src_stride,
                        uint8_t* dst, int dst_stride, int width, int height);




int ImgIoUtilCheckSizeArgumentsOverflow(uint64_t stride, size_t height);
# 23 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 2
# 1 "/doner/libwebp/libwebp-31bea324/examples/./unicode.h" 1
# 80 "/doner/libwebp/libwebp-31bea324/examples/./unicode.h"
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4

# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 122 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 154 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 385 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 410 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 428 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));








# 1 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bcopy (const void *__src, void *__dest, size_t __len)
{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bzero (void *__dest, size_t __len)
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
}
# 145 "/usr/include/strings.h" 2 3 4
# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 495 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memmove (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
# 58 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memset (void *__dest, int __ch, size_t __len)
{
# 71 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}




void __explicit_bzero_chk (void *__dest, size_t __len, size_t __destlen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) explicit_bzero (void *__dest, size_t __len)
{
  __explicit_bzero_chk (__dest, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}
# 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncpy (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}


extern char *__stpncpy_chk (char *__dest, const char *__src, size_t __n,
       size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern char *__stpncpy_alias (char *__dest, const char *__src, size_t __n) __asm__ ("" "stpncpy") __attribute__ ((__nothrow__ , __leaf__))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpncpy (char *__dest, const char *__src, size_t __n)
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n > __builtin_object_size (__dest, 2 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcat (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncat (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}
# 496 "/usr/include/string.h" 2 3 4




# 81 "/doner/libwebp/libwebp-31bea324/examples/./unicode.h" 2
# 24 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 2
# 1 "../src/webp/decode.h" 1
# 17 "../src/webp/decode.h"
# 1 "../src/webp/./types.h" 1
# 18 "../src/webp/decode.h" 2
# 29 "../src/webp/decode.h"

# 29 "../src/webp/decode.h"
typedef struct WebPRGBABuffer WebPRGBABuffer;
typedef struct WebPYUVABuffer WebPYUVABuffer;
typedef struct WebPDecBuffer WebPDecBuffer;
typedef struct WebPIDecoder WebPIDecoder;
typedef struct WebPBitstreamFeatures WebPBitstreamFeatures;
typedef struct WebPDecoderOptions WebPDecoderOptions;
typedef struct WebPDecoderConfig WebPDecoderConfig;



extern __attribute__ ((visibility ("default"))) int WebPGetDecoderVersion(void);
# 51 "../src/webp/decode.h"
extern __attribute__ ((visibility ("default"))) int WebPGetInfo(const uint8_t* data, size_t data_size,
                            int* width, int* height);






extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeRGBA(const uint8_t* data, size_t data_size,
                                    int* width, int* height);


extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeARGB(const uint8_t* data, size_t data_size,
                                    int* width, int* height);


extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeBGRA(const uint8_t* data, size_t data_size,
                                    int* width, int* height);



extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeRGB(const uint8_t* data, size_t data_size,
                                   int* width, int* height);


extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeBGR(const uint8_t* data, size_t data_size,
                                   int* width, int* height);
# 90 "../src/webp/decode.h"
extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeYUV(const uint8_t* data, size_t data_size,
                                   int* width, int* height,
                                   uint8_t** u, uint8_t** v,
                                   int* stride, int* uv_stride);
# 103 "../src/webp/decode.h"
extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeRGBAInto(
    const uint8_t* data, size_t data_size,
    uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeARGBInto(
    const uint8_t* data, size_t data_size,
    uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeBGRAInto(
    const uint8_t* data, size_t data_size,
    uint8_t* output_buffer, size_t output_buffer_size, int output_stride);



extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeRGBInto(
    const uint8_t* data, size_t data_size,
    uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeBGRInto(
    const uint8_t* data, size_t data_size,
    uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
# 129 "../src/webp/decode.h"
extern __attribute__ ((visibility ("default"))) uint8_t* WebPDecodeYUVInto(
    const uint8_t* data, size_t data_size,
    uint8_t* luma, size_t luma_size, int luma_stride,
    uint8_t* u, size_t u_size, int u_stride,
    uint8_t* v, size_t v_size, int v_stride);
# 150 "../src/webp/decode.h"
typedef enum WEBP_CSP_MODE {
  MODE_RGB = 0, MODE_RGBA = 1,
  MODE_BGR = 2, MODE_BGRA = 3,
  MODE_ARGB = 4, MODE_RGBA_4444 = 5,
  MODE_RGB_565 = 6,

  MODE_rgbA = 7,
  MODE_bgrA = 8,
  MODE_Argb = 9,
  MODE_rgbA_4444 = 10,

  MODE_YUV = 11, MODE_YUVA = 12,
  MODE_LAST = 13
} WEBP_CSP_MODE;


static inline int WebPIsPremultipliedMode(WEBP_CSP_MODE mode) {
  return (mode == MODE_rgbA || mode == MODE_bgrA || mode == MODE_Argb ||
          mode == MODE_rgbA_4444);
}

static inline int WebPIsAlphaMode(WEBP_CSP_MODE mode) {
  return (mode == MODE_RGBA || mode == MODE_BGRA || mode == MODE_ARGB ||
          mode == MODE_RGBA_4444 || mode == MODE_YUVA ||
          WebPIsPremultipliedMode(mode));
}

static inline int WebPIsRGBMode(WEBP_CSP_MODE mode) {
  return (mode < MODE_YUV);
}




struct WebPRGBABuffer {
  uint8_t* rgba;
  int stride;
  size_t size;
};

struct WebPYUVABuffer {
  uint8_t* y, *u, *v, *a;
  int y_stride;
  int u_stride, v_stride;
  int a_stride;
  size_t y_size;
  size_t u_size, v_size;
  size_t a_size;
};


struct WebPDecBuffer {
  WEBP_CSP_MODE colorspace;
  int width, height;
  int is_external_memory;



  union {
    WebPRGBABuffer RGBA;
    WebPYUVABuffer YUVA;
  } u;
  uint32_t pad[4];

  uint8_t* private_memory;


};


extern __attribute__ ((visibility ("default"))) int WebPInitDecBufferInternal(WebPDecBuffer*, int);



static inline int WebPInitDecBuffer(WebPDecBuffer* buffer) {
  return WebPInitDecBufferInternal(buffer, 0x0209);
}



extern __attribute__ ((visibility ("default"))) void WebPFreeDecBuffer(WebPDecBuffer* buffer);




typedef enum VP8StatusCode {
  VP8_STATUS_OK = 0,
  VP8_STATUS_OUT_OF_MEMORY,
  VP8_STATUS_INVALID_PARAM,
  VP8_STATUS_BITSTREAM_ERROR,
  VP8_STATUS_UNSUPPORTED_FEATURE,
  VP8_STATUS_SUSPENDED,
  VP8_STATUS_USER_ABORT,
  VP8_STATUS_NOT_ENOUGH_DATA
} VP8StatusCode;
# 284 "../src/webp/decode.h"
extern __attribute__ ((visibility ("default"))) WebPIDecoder* WebPINewDecoder(WebPDecBuffer* output_buffer);
# 296 "../src/webp/decode.h"
extern __attribute__ ((visibility ("default"))) WebPIDecoder* WebPINewRGB(
    WEBP_CSP_MODE csp,
    uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
# 311 "../src/webp/decode.h"
extern __attribute__ ((visibility ("default"))) WebPIDecoder* WebPINewYUVA(
    uint8_t* luma, size_t luma_size, int luma_stride,
    uint8_t* u, size_t u_size, int u_stride,
    uint8_t* v, size_t v_size, int v_stride,
    uint8_t* a, size_t a_size, int a_stride);



extern __attribute__ ((visibility ("default"))) WebPIDecoder* WebPINewYUV(
    uint8_t* luma, size_t luma_size, int luma_stride,
    uint8_t* u, size_t u_size, int u_stride,
    uint8_t* v, size_t v_size, int v_stride);



extern __attribute__ ((visibility ("default"))) void WebPIDelete(WebPIDecoder* idec);




extern __attribute__ ((visibility ("default"))) VP8StatusCode WebPIAppend(
    WebPIDecoder* idec, const uint8_t* data, size_t data_size);






extern __attribute__ ((visibility ("default"))) VP8StatusCode WebPIUpdate(
    WebPIDecoder* idec, const uint8_t* data, size_t data_size);
# 349 "../src/webp/decode.h"
extern __attribute__ ((visibility ("default"))) uint8_t* WebPIDecGetRGB(
    const WebPIDecoder* idec, int* last_y,
    int* width, int* height, int* stride);




extern __attribute__ ((visibility ("default"))) uint8_t* WebPIDecGetYUVA(
    const WebPIDecoder* idec, int* last_y,
    uint8_t** u, uint8_t** v, uint8_t** a,
    int* width, int* height, int* stride, int* uv_stride, int* a_stride);



static inline uint8_t* WebPIDecGetYUV(
    const WebPIDecoder* idec, int* last_y, uint8_t** u, uint8_t** v,
    int* width, int* height, int* stride, int* uv_stride) {
  return WebPIDecGetYUVA(idec, last_y, u, v, 
# 366 "../src/webp/decode.h" 3 4
                                            ((void *)0)
# 366 "../src/webp/decode.h"
                                                , width, height,
                         stride, uv_stride, 
# 367 "../src/webp/decode.h" 3 4
                                           ((void *)0)
# 367 "../src/webp/decode.h"
                                               );
}







extern __attribute__ ((visibility ("default"))) const WebPDecBuffer* WebPIDecodedArea(
    const WebPIDecoder* idec, int* left, int* top, int* width, int* height);
# 413 "../src/webp/decode.h"
struct WebPBitstreamFeatures {
  int width;
  int height;
  int has_alpha;
  int has_animation;
  int format;

  uint32_t pad[5];
};


extern __attribute__ ((visibility ("default"))) VP8StatusCode WebPGetFeaturesInternal(
    const uint8_t*, size_t, WebPBitstreamFeatures*, int);
# 438 "../src/webp/decode.h"
static inline VP8StatusCode WebPGetFeatures(
    const uint8_t* data, size_t data_size,
    WebPBitstreamFeatures* features) {
  return WebPGetFeaturesInternal(data, data_size, features,
                                 0x0209);
}


struct WebPDecoderOptions {
  int bypass_filtering;
  int no_fancy_upsampling;
  int use_cropping;
  int crop_left, crop_top;

  int crop_width, crop_height;
  int use_scaling;
  int scaled_width, scaled_height;
  int use_threads;
  int dithering_strength;
  int flip;
  int alpha_dithering_strength;

  uint32_t pad[5];
};


struct WebPDecoderConfig {
  WebPBitstreamFeatures input;
  WebPDecBuffer output;
  WebPDecoderOptions options;
};


extern __attribute__ ((visibility ("default"))) int WebPInitDecoderConfigInternal(WebPDecoderConfig*, int);




static inline int WebPInitDecoderConfig(WebPDecoderConfig* config) {
  return WebPInitDecoderConfigInternal(config, 0x0209);
}
# 491 "../src/webp/decode.h"
extern __attribute__ ((visibility ("default"))) WebPIDecoder* WebPIDecode(const uint8_t* data, size_t data_size,
                                      WebPDecoderConfig* config);




extern __attribute__ ((visibility ("default"))) VP8StatusCode WebPDecode(const uint8_t* data, size_t data_size,
                                     WebPDecoderConfig* config);
# 25 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 2
# 1 "../src/webp/format_constants.h" 1
# 55 "../src/webp/format_constants.h"
typedef enum {
  PREDICTOR_TRANSFORM = 0,
  CROSS_COLOR_TRANSFORM = 1,
  SUBTRACT_GREEN_TRANSFORM = 2,
  COLOR_INDEXING_TRANSFORM = 3
} VP8LImageTransformType;
# 26 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 2
# 1 "../src/webp/mux_types.h" 1
# 29 "../src/webp/mux_types.h"
typedef struct WebPData WebPData;


typedef enum WebPFeatureFlags {
  ANIMATION_FLAG = 0x00000002,
  XMP_FLAG = 0x00000004,
  EXIF_FLAG = 0x00000008,
  ALPHA_FLAG = 0x00000010,
  ICCP_FLAG = 0x00000020,

  ALL_VALID_FLAGS = 0x0000003e
} WebPFeatureFlags;



typedef enum WebPMuxAnimDispose {
  WEBP_MUX_DISPOSE_NONE,
  WEBP_MUX_DISPOSE_BACKGROUND
} WebPMuxAnimDispose;



typedef enum WebPMuxAnimBlend {
  WEBP_MUX_BLEND,
  WEBP_MUX_NO_BLEND
} WebPMuxAnimBlend;




struct WebPData {
  const uint8_t* bytes;
  size_t size;
};


static inline void WebPDataInit(WebPData* webp_data) {
  if (webp_data != 
# 66 "../src/webp/mux_types.h" 3 4
                  ((void *)0)
# 66 "../src/webp/mux_types.h"
                      ) {
    memset(webp_data, 0, sizeof(*webp_data));
  }
}



static inline void WebPDataClear(WebPData* webp_data) {
  if (webp_data != 
# 74 "../src/webp/mux_types.h" 3 4
                  ((void *)0)
# 74 "../src/webp/mux_types.h"
                      ) {
    WebPFree((void*)webp_data->bytes);
    WebPDataInit(webp_data);
  }
}



static inline int WebPDataCopy(const WebPData* src, WebPData* dst) {
  if (src == 
# 83 "../src/webp/mux_types.h" 3 4
            ((void *)0) 
# 83 "../src/webp/mux_types.h"
                 || dst == 
# 83 "../src/webp/mux_types.h" 3 4
                           ((void *)0)
# 83 "../src/webp/mux_types.h"
                               ) return 0;
  WebPDataInit(dst);
  if (src->bytes != 
# 85 "../src/webp/mux_types.h" 3 4
                   ((void *)0) 
# 85 "../src/webp/mux_types.h"
                        && src->size != 0) {
    dst->bytes = (uint8_t*)WebPMalloc(src->size);
    if (dst->bytes == 
# 87 "../src/webp/mux_types.h" 3 4
                     ((void *)0)
# 87 "../src/webp/mux_types.h"
                         ) return 0;
    memcpy((void*)dst->bytes, src->bytes, src->size);
    dst->size = src->size;
  }
  return 1;
}
# 27 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 2
# 47 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
static const char* const kFormats[3] = {
  "Unknown",
  "Lossy",
  "Lossless"
};

static const char* const kLosslessTransforms[4] = {
  "Predictor",
  "Cross Color",
  "Subtract Green",
  "Color Indexing"
};

static const char* const kAlphaFilterMethods[4] = {
  "None",
  "Horizontal",
  "Vertical",
  "Gradient"
};

typedef enum {
  WEBP_INFO_OK = 0,
  WEBP_INFO_TRUNCATED_DATA,
  WEBP_INFO_PARSE_ERROR,
  WEBP_INFO_INVALID_PARAM,
  WEBP_INFO_BITSTREAM_ERROR,
  WEBP_INFO_MISSING_DATA,
  WEBP_INFO_INVALID_COMMAND
} WebPInfoStatus;

typedef enum ChunkID {
  CHUNK_VP8,
  CHUNK_VP8L,
  CHUNK_VP8X,
  CHUNK_ALPHA,
  CHUNK_ANIM,
  CHUNK_ANMF,
  CHUNK_ICCP,
  CHUNK_EXIF,
  CHUNK_XMP,
  CHUNK_UNKNOWN,
  CHUNK_TYPES = CHUNK_UNKNOWN
} ChunkID;

typedef struct {
  size_t start_;
  size_t end_;
  const uint8_t* buf_;
} MemBuffer;

typedef struct {
  size_t offset_;
  size_t size_;
  const uint8_t* payload_;
  ChunkID id_;
} ChunkData;

typedef struct WebPInfo {
  int canvas_width_;
  int canvas_height_;
  int loop_count_;
  int num_frames_;
  int chunk_counts_[CHUNK_TYPES];
  int anmf_subchunk_counts_[3];
  uint32_t bgcolor_;
  int feature_flags_;
  int has_alpha_;

  int frame_width_, frame_height_;
  size_t anim_frame_data_size_;
  int is_processing_anim_frame_, seen_alpha_subchunk_, seen_image_subchunk_;

  int quiet_, show_diagnosis_, show_summary_;
  int num_warnings_;
  int parse_bitstream_;
} WebPInfo;

static void WebPInfoInit(WebPInfo* const webp_info) {
  memset(webp_info, 0, sizeof(*webp_info));
}

static const uint32_t kWebPChunkTags[CHUNK_TYPES] = {
  (('V') | ('P') << 8 | ('8') << 16 | (uint32_t)(' ') << 24),
  (('V') | ('P') << 8 | ('8') << 16 | (uint32_t)('L') << 24),
  (('V') | ('P') << 8 | ('8') << 16 | (uint32_t)('X') << 24),
  (('A') | ('L') << 8 | ('P') << 16 | (uint32_t)('H') << 24),
  (('A') | ('N') << 8 | ('I') << 16 | (uint32_t)('M') << 24),
  (('A') | ('N') << 8 | ('M') << 16 | (uint32_t)('F') << 24),
  (('I') | ('C') << 8 | ('C') << 16 | (uint32_t)('P') << 24),
  (('E') | ('X') << 8 | ('I') << 16 | (uint32_t)('F') << 24),
  (('X') | ('M') << 8 | ('P') << 16 | (uint32_t)(' ') << 24),
};




static int GetLE16(const uint8_t* const data) {
  return (data[0] << 0) | (data[1] << 8);
}

static int GetLE24(const uint8_t* const data) {
  return GetLE16(data) | (data[2] << 16);
}

static uint32_t GetLE32(const uint8_t* const data) {
  return GetLE16(data) | ((uint32_t)GetLE16(data + 2) << 16);
}

static int ReadLE16(const uint8_t** data) {
  const int val = GetLE16(*data);
  *data += 2;
  return val;
}

static int ReadLE24(const uint8_t** data) {
  const int val = GetLE24(*data);
  *data += 3;
  return val;
}

static uint32_t ReadLE32(const uint8_t** data) {
  const uint32_t val = GetLE32(*data);
  *data += 4;
  return val;
}

static int ReadFileToWebPData(const char* const filename,
                              WebPData* const webp_data) {
  const uint8_t* data;
  size_t size;
  if (!ImgIoUtilReadFile(filename, &data, &size)) return 0;
  webp_data->bytes = data;
  webp_data->size = size;
  return 1;
}




static void InitMemBuffer(MemBuffer* const mem, const WebPData* webp_data) {
  mem->buf_ = webp_data->bytes;
  mem->start_ = 0;
  mem->end_ = webp_data->size;
}

static size_t MemDataSize(const MemBuffer* const mem) {
  return (mem->end_ - mem->start_);
}

static const uint8_t* GetBuffer(MemBuffer* const mem) {
  return mem->buf_ + mem->start_;
}

static void Skip(MemBuffer* const mem, size_t size) {
  mem->start_ += size;
}

static uint32_t ReadMemBufLE32(MemBuffer* const mem) {
  const uint8_t* const data = mem->buf_ + mem->start_;
  const uint32_t val = GetLE32(data);
  
# 207 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 ((void) (0))
# 207 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
                              ;
  Skip(mem, 4);
  return val;
}




static int GetBits(const uint8_t* const data, size_t data_size, size_t nb,
                   int* val, uint64_t* const bit_pos) {
  *val = 0;
  while (nb-- > 0) {
    const uint64_t p = (*bit_pos)++;
    if ((p >> 3) >= data_size) {
      return 0;
    } else {
      const int bit = !!(data[p >> 3] & (128 >> ((p & 7))));
      *val = (*val << 1) | bit;
    }
  }
  return 1;
}

static int GetSignedBits(const uint8_t* const data, size_t data_size, size_t nb,
                         int* val, uint64_t* const bit_pos) {
  int sign;
  if (!GetBits(data, data_size, nb, val, bit_pos)) return 0;
  if (!GetBits(data, data_size, 1, &sign, bit_pos)) return 0;
  if (sign) *val = -(*val);
  return 1;
}
# 255 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
static WebPInfoStatus ParseLossySegmentHeader(const WebPInfo* const webp_info,
                                              const uint8_t* const data,
                                              size_t data_size,
                                              uint64_t* const bit_pos) {
  int use_segment;
  do { if (!GetBits(data, data_size, 1, &(use_segment), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 260 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 stderr
# 260 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
 , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
  printf("  Use segment:      %d\n", use_segment);
  if (use_segment) {
    int update_map, update_data;
    do { if (!GetBits(data, data_size, 1, &(update_map), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 264 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 264 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    do { if (!GetBits(data, data_size, 1, &(update_data), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 265 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 265 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    printf("  Update map:       %d\n"
           "  Update data:      %d\n",
           update_map, update_data);
    if (update_data) {
      int i, a_delta;
      int quantizer[4] = {0, 0, 0, 0};
      int filter_strength[4] = {0, 0, 0, 0};
      do { if (!GetBits(data, data_size, 1, &(a_delta), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 273 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 273 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
      printf("  Absolute delta:   %d\n", a_delta);
      for (i = 0; i < 4; ++i) {
        int bit;
        do { if (!GetBits(data, data_size, 1, &(bit), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 277 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 277 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
        if (bit) do { if (!GetSignedBits(data, data_size, 7, &(quantizer[i]), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 278 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
                stderr
# 278 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
                , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
      }
      for (i = 0; i < 4; ++i) {
        int bit;
        do { if (!GetBits(data, data_size, 1, &(bit), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 282 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 282 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
        if (bit) do { if (!GetSignedBits(data, data_size, 6, &(filter_strength[i]), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 283 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
                stderr
# 283 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
                , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
      }
      printf("  Quantizer:        %d %d %d %d\n", quantizer[0], quantizer[1],
             quantizer[2], quantizer[3]);
      printf("  Filter strength:  %d %d %d %d\n", filter_strength[0],
             filter_strength[1], filter_strength[2], filter_strength[3]);
    }
    if (update_map) {
      int i;
      int prob_segment[3] = {255, 255, 255};
      for (i = 0; i < 3; ++i) {
        int bit;
        do { if (!GetBits(data, data_size, 1, &(bit), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 295 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 295 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
        if (bit) do { if (!GetBits(data, data_size, 8, &(prob_segment[i]), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 296 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
                stderr
# 296 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
                , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
      }
      printf("  Prob segment:     %d %d %d\n",
             prob_segment[0], prob_segment[1], prob_segment[2]);
    }
  }
  return WEBP_INFO_OK;
}

static WebPInfoStatus ParseLossyFilterHeader(const WebPInfo* const webp_info,
                                             const uint8_t* const data,
                                             size_t data_size,
                                             uint64_t* const bit_pos) {
  int simple_filter, level, sharpness, use_lf_delta;
  do { if (!GetBits(data, data_size, 1, &(simple_filter), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 310 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 stderr
# 310 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
 , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
  do { if (!GetBits(data, data_size, 6, &(level), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 311 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 stderr
# 311 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
 , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
  do { if (!GetBits(data, data_size, 3, &(sharpness), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 312 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 stderr
# 312 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
 , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
  do { if (!GetBits(data, data_size, 1, &(use_lf_delta), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 313 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 stderr
# 313 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
 , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
  printf("  Simple filter:    %d\n", simple_filter);
  printf("  Level:            %d\n", level);
  printf("  Sharpness:        %d\n", sharpness);
  printf("  Use lf delta:     %d\n", use_lf_delta);
  if (use_lf_delta) {
    int update;
    do { if (!GetBits(data, data_size, 1, &(update), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 320 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 320 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    printf("  Update lf delta:  %d\n", update);
    if (update) {
      int i;
      for (i = 0; i < 4 + 4; ++i) {
        int temp;
        do { if (!GetBits(data, data_size, 1, &(temp), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 326 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 326 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
        if (temp) do { if (!GetBits(data, data_size, 7, &(temp), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 327 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
                 stderr
# 327 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
                 , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
      }
    }
  }
  return WEBP_INFO_OK;
}

static WebPInfoStatus ParseLossyHeader(const ChunkData* const chunk_data,
                                       const WebPInfo* const webp_info) {
  const uint8_t* data = chunk_data->payload_;
  size_t data_size = chunk_data->size_ - 8;
  const uint32_t bits = (uint32_t)data[0] | (data[1] << 8) | (data[2] << 16);
  const int key_frame = !(bits & 1);
  const int profile = (bits >> 1) & 7;
  const int display = (bits >> 4) & 1;
  const uint32_t partition0_length = (bits >> 5);
  WebPInfoStatus status = WEBP_INFO_OK;
  uint64_t bit_position = 0;
  uint64_t* const bit_pos = &bit_position;
  int colorspace, clamp_type;
  printf("  Parsing lossy bitstream...\n");

  
# 349 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 ((void) (0))
# 349 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
                                                    ;
  if (profile > 3) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 351 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 351 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Unknown profile."); } } while (0);
    return WEBP_INFO_BITSTREAM_ERROR;
  }
  if (!display) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 355 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 355 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Frame is not displayable."); } } while (0);
    return WEBP_INFO_BITSTREAM_ERROR;
  }
  data += 3;
  data_size -= 3;
  printf("  Key frame:        %s\n"
         "  Profile:          %d\n"
         "  Display:          %s\n"
         "  Part. 0 length:   %d\n",
         key_frame ? "Yes" : "No", profile,
         display ? "Yes" : "No", partition0_length);
  if (key_frame) {
    if (!(data[0] == 0x9d && data[1] == 0x01 && data[2] == 0x2a)) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 368 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 368 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Invalid lossy bitstream signature."); } } while (0);
      return WEBP_INFO_BITSTREAM_ERROR;
    }
    printf("  Width:            %d\n"
           "  X scale:          %d\n"
           "  Height:           %d\n"
           "  Y scale:          %d\n",
           ((data[4] << 8) | data[3]) & 0x3fff, data[4] >> 6,
           ((data[6] << 8) | data[5]) & 0x3fff, data[6] >> 6);
    data += 7;
    data_size -= 7;
  } else {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 380 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 380 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Non-keyframe detected in lossy bitstream."); } } while (0);
    return WEBP_INFO_BITSTREAM_ERROR;
  }
  if (partition0_length >= data_size) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 384 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 384 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Bad partition length."); } } while (0);
    return WEBP_INFO_BITSTREAM_ERROR;
  }
  do { if (!GetBits(data, data_size, 1, &(colorspace), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 387 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 stderr
# 387 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
 , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
  do { if (!GetBits(data, data_size, 1, &(clamp_type), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 388 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 stderr
# 388 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
 , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
  printf("  Color space:      %d\n", colorspace);
  printf("  Clamp type:       %d\n", clamp_type);
  status = ParseLossySegmentHeader(webp_info, data, data_size, bit_pos);
  if (status != WEBP_INFO_OK) return status;
  status = ParseLossyFilterHeader(webp_info, data, data_size, bit_pos);
  if (status != WEBP_INFO_OK) return status;
  {
    const uint8_t* part_size = data + partition0_length;
    int num_parts, i;
    size_t part_data_size;
    do { if (!GetBits(data, data_size, 2, &(num_parts), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 399 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 399 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    num_parts = 1 << num_parts;
    if ((int)(data_size - partition0_length) < (num_parts - 1) * 3) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 402 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 402 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Truncated lossy bitstream."); } } while (0);
      return WEBP_INFO_TRUNCATED_DATA;
    }
    part_data_size = data_size - partition0_length - (num_parts - 1) * 3;
    printf("  Total partitions: %d\n", num_parts);
    for (i = 1; i < num_parts; ++i) {
      const size_t psize =
          part_size[0] | (part_size[1] << 8) | (part_size[2] << 16);
      if (psize > part_data_size) {
        do { if (webp_info->show_diagnosis_) { fprintf(
# 411 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 411 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "Truncated partition."); } } while (0);
        return WEBP_INFO_TRUNCATED_DATA;
      }
      printf("  Part. %d length:   %d\n", i, (int)psize);
      part_data_size -= psize;
      part_size += 3;
    }
  }

  {
    int base_q, bit;
    int dq_y1_dc = 0, dq_y2_dc = 0, dq_y2_ac = 0, dq_uv_dc = 0, dq_uv_ac = 0;
    do { if (!GetBits(data, data_size, 7, &(base_q), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 423 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 423 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    do { if (!GetBits(data, data_size, 1, &(bit), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 424 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 424 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    if (bit) do { if (!GetSignedBits(data, data_size, 4, &(dq_y1_dc), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 425 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
            stderr
# 425 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
            , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    do { if (!GetBits(data, data_size, 1, &(bit), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 426 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 426 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    if (bit) do { if (!GetSignedBits(data, data_size, 4, &(dq_y2_dc), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 427 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
            stderr
# 427 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
            , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    do { if (!GetBits(data, data_size, 1, &(bit), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 428 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 428 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    if (bit) do { if (!GetSignedBits(data, data_size, 4, &(dq_y2_ac), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 429 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
            stderr
# 429 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
            , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    do { if (!GetBits(data, data_size, 1, &(bit), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 430 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 430 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    if (bit) do { if (!GetSignedBits(data, data_size, 4, &(dq_uv_dc), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 431 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
            stderr
# 431 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
            , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    do { if (!GetBits(data, data_size, 1, &(bit), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 432 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 432 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    if (bit) do { if (!GetSignedBits(data, data_size, 4, &(dq_uv_ac), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 433 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
            stderr
# 433 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
            , "Error: %s\n", "Truncated lossy bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    printf("  Base Q:           %d\n", base_q);
    printf("  DQ Y1 DC:         %d\n", dq_y1_dc);
    printf("  DQ Y2 DC:         %d\n", dq_y2_dc);
    printf("  DQ Y2 AC:         %d\n", dq_y2_ac);
    printf("  DQ UV DC:         %d\n", dq_uv_dc);
    printf("  DQ UV AC:         %d\n", dq_uv_ac);
  }
  if ((*bit_pos >> 3) >= partition0_length) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 442 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 442 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossy bitstream."); } } while (0);
    return WEBP_INFO_TRUNCATED_DATA;
  }
  return WEBP_INFO_OK;
}




static int LLGetBits(const uint8_t* const data, size_t data_size, size_t nb,
                     int* val, uint64_t* const bit_pos) {
  uint32_t i = 0;
  *val = 0;
  while (i < nb) {
    const uint64_t p = (*bit_pos)++;
    if ((p >> 3) >= data_size) {
      return 0;
    } else {
      const int bit = !!(data[p >> 3] & (1 << ((p & 7))));
      *val = *val | (bit << i);
      ++i;
    }
  }
  return 1;
}
# 476 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
static WebPInfoStatus ParseLosslessTransform(WebPInfo* const webp_info,
                                             const uint8_t* const data,
                                             size_t data_size,
                                             uint64_t* const bit_pos) {
  int use_transform, block_size, n_colors;
  do { if (!LLGetBits(data, data_size, 1, &(use_transform), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 481 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
 stderr
# 481 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
 , "Error: %s\n", "Truncated lossless bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
  printf("  Use transform:    %s\n", use_transform ? "Yes" : "No");
  if (use_transform) {
    int type;
    do { if (!LLGetBits(data, data_size, 2, &(type), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 485 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 485 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossless bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    printf("  1st transform:    %s (%d)\n", kLosslessTransforms[type], type);
    switch (type) {
      case PREDICTOR_TRANSFORM:
      case CROSS_COLOR_TRANSFORM:
        do { if (!LLGetBits(data, data_size, 3, &(block_size), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 490 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 490 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "Truncated lossless bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
        block_size = 1 << (block_size + 2);
        printf("  Tran. block size: %d\n", block_size);
        break;
      case COLOR_INDEXING_TRANSFORM:
        do { if (!LLGetBits(data, data_size, 8, &(n_colors), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 495 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 495 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "Truncated lossless bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
        n_colors += 1;
        printf("  No. of colors:    %d\n", n_colors);
        break;
      default: break;
    }
  }
  return WEBP_INFO_OK;
}

static WebPInfoStatus ParseLosslessHeader(const ChunkData* const chunk_data,
                                          WebPInfo* const webp_info) {
  const uint8_t* data = chunk_data->payload_;
  size_t data_size = chunk_data->size_ - 8;
  uint64_t bit_position = 0;
  uint64_t* const bit_pos = &bit_position;
  WebPInfoStatus status;
  printf("  Parsing lossless bitstream...\n");
  if (data_size < 5) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 514 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 514 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossless bitstream."); } } while (0);
    return WEBP_INFO_TRUNCATED_DATA;
  }
  if (data[0] != 0x2f) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 518 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 518 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Invalid lossless bitstream signature."); } } while (0);
    return WEBP_INFO_BITSTREAM_ERROR;
  }
  data += 1;
  data_size -= 1;
  {
    int width, height, has_alpha, version;
    do { if (!LLGetBits(data, data_size, 14, &(width), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 525 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 525 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossless bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    do { if (!LLGetBits(data, data_size, 14, &(height), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 526 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 526 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossless bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    do { if (!LLGetBits(data, data_size, 1, &(has_alpha), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 527 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 527 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossless bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    do { if (!LLGetBits(data, data_size, 3, &(version), bit_pos)) { do { if (webp_info->show_diagnosis_) { fprintf(
# 528 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 528 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated lossless bitstream."); } } while (0); return WEBP_INFO_TRUNCATED_DATA; } } while (0);
    width += 1;
    height += 1;
    printf("  Width:            %d\n", width);
    printf("  Height:           %d\n", height);
    printf("  Alpha:            %d\n", has_alpha);
    printf("  Version:          %d\n", version);
  }
  status = ParseLosslessTransform(webp_info, data, data_size, bit_pos);
  if (status != WEBP_INFO_OK) return status;
  return WEBP_INFO_OK;
}

static WebPInfoStatus ParseAlphaHeader(const ChunkData* const chunk_data,
                                       WebPInfo* const webp_info) {
  const uint8_t* data = chunk_data->payload_;
  size_t data_size = chunk_data->size_ - 8;
  if (data_size <= 1) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 546 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 546 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated ALPH chunk."); } } while (0);
    return WEBP_INFO_TRUNCATED_DATA;
  }
  printf("  Parsing ALPH chunk...\n");
  {
    const int compression_method = (data[0] >> 0) & 0x03;
    const int filter = (data[0] >> 2) & 0x03;
    const int pre_processing = (data[0] >> 4) & 0x03;
    const int reserved_bits = (data[0] >> 6) & 0x03;
    printf("  Compression:      %d\n", compression_method);
    printf("  Filter:           %s (%d)\n",
           kAlphaFilterMethods[filter], filter);
    printf("  Pre-processing:   %d\n", pre_processing);
    if (compression_method > 1) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 560 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 560 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Invalid Alpha compression method."); } } while (0);
      return WEBP_INFO_BITSTREAM_ERROR;
    }
    if (pre_processing > 1) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 564 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 564 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Invalid Alpha pre-processing method."); } } while (0);
      return WEBP_INFO_BITSTREAM_ERROR;
    }
    if (reserved_bits != 0) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 568 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 568 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Warning: %s\n", "Reserved bits in ALPH chunk header are not all 0."); } ++webp_info->num_warnings_; } while (0);
    }
    data += 1;
    data_size -= 1;
    if (compression_method == 1) {
      uint64_t bit_pos = 0;
      WebPInfoStatus status =
          ParseLosslessTransform(webp_info, data, data_size, &bit_pos);
      if (status != WEBP_INFO_OK) return status;
    }
  }
  return WEBP_INFO_OK;
}




static WebPInfoStatus ParseRIFFHeader(WebPInfo* const webp_info,
                                      MemBuffer* const mem) {
  const size_t min_size = 12 + 8;
  size_t riff_size;

  if (MemDataSize(mem) < min_size) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 591 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 591 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated data detected when parsing RIFF header."); } } while (0);
    return WEBP_INFO_TRUNCATED_DATA;
  }
  if (memcmp(GetBuffer(mem), "RIFF", 4) ||
      memcmp(GetBuffer(mem) + 8, "WEBP", 4)) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 596 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 596 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Corrupted RIFF header."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  riff_size = GetLE32(GetBuffer(mem) + 4);
  if (riff_size < 8) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 601 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 601 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "RIFF size is too small."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  if (riff_size > (~0U - 8 - 1)) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 605 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 605 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "RIFF size is over limit."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  riff_size += 8;
  if (!webp_info->quiet_) {
    printf("RIFF HEADER:\n");
    printf("  File size: %6d\n", (int)riff_size);
  }
  if (riff_size < mem->end_) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 614 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 614 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Warning: %s\n", "RIFF size is smaller than the file size."); } ++webp_info->num_warnings_; } while (0);
    mem->end_ = riff_size;
  } else if (riff_size > mem->end_) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 617 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 617 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated data detected when parsing RIFF payload."); } } while (0);
    return WEBP_INFO_TRUNCATED_DATA;
  }
  Skip(mem, 12);
  return WEBP_INFO_OK;
}

static WebPInfoStatus ParseChunk(const WebPInfo* const webp_info,
                                 MemBuffer* const mem,
                                 ChunkData* const chunk_data) {
  memset(chunk_data, 0, sizeof(*chunk_data));
  if (MemDataSize(mem) < 8) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 629 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 629 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated data detected when parsing chunk header."); } } while (0);
    return WEBP_INFO_TRUNCATED_DATA;
  } else {
    const size_t chunk_start_offset = mem->start_;
    const uint32_t fourcc = ReadMemBufLE32(mem);
    const uint32_t payload_size = ReadMemBufLE32(mem);
    const uint32_t payload_size_padded = payload_size + (payload_size & 1);
    const size_t chunk_size = 8 + payload_size_padded;
    int i;
    if (payload_size > (~0U - 8 - 1)) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 639 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 639 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Size of chunk payload is over limit."); } } while (0);
      return WEBP_INFO_INVALID_PARAM;
    }
    if (payload_size_padded > MemDataSize(mem)){
      do { if (webp_info->show_diagnosis_) { fprintf(
# 643 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 643 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Truncated data detected when parsing chunk payload."); } } while (0);
      return WEBP_INFO_TRUNCATED_DATA;
    }
    for (i = 0; i < CHUNK_TYPES; ++i) {
      if (kWebPChunkTags[i] == fourcc) break;
    }
    chunk_data->offset_ = chunk_start_offset;
    chunk_data->size_ = chunk_size;
    chunk_data->id_ = (ChunkID)i;
    chunk_data->payload_ = GetBuffer(mem);
    if (chunk_data->id_ == CHUNK_ANMF) {
      if (payload_size != payload_size_padded) {
        do { if (webp_info->show_diagnosis_) { fprintf(
# 655 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 655 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "ANMF chunk size should always be even."); } } while (0);
        return WEBP_INFO_PARSE_ERROR;
      }

      Skip(mem, 16);
    } else {
      Skip(mem, payload_size_padded);
    }
    return WEBP_INFO_OK;
  }
}




static WebPInfoStatus ProcessVP8XChunk(const ChunkData* const chunk_data,
                                       WebPInfo* const webp_info) {
  const uint8_t* data = chunk_data->payload_;
  if (webp_info->chunk_counts_[CHUNK_VP8] ||
      webp_info->chunk_counts_[CHUNK_VP8L] ||
      webp_info->chunk_counts_[CHUNK_VP8X]) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 676 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 676 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Already seen a VP8/VP8L/VP8X chunk when parsing VP8X chunk."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  if (chunk_data->size_ != 10 + 8) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 680 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 680 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Corrupted VP8X chunk."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  ++webp_info->chunk_counts_[CHUNK_VP8X];
  webp_info->feature_flags_ = *data;
  data += 4;
  webp_info->canvas_width_ = 1 + ReadLE24(&data);
  webp_info->canvas_height_ = 1 + ReadLE24(&data);
  if (!webp_info->quiet_) {
    printf("  ICCP: %d\n  Alpha: %d\n  EXIF: %d\n  XMP: %d\n  Animation: %d\n",
           (webp_info->feature_flags_ & ICCP_FLAG) != 0,
           (webp_info->feature_flags_ & ALPHA_FLAG) != 0,
           (webp_info->feature_flags_ & EXIF_FLAG) != 0,
           (webp_info->feature_flags_ & XMP_FLAG) != 0,
           (webp_info->feature_flags_ & ANIMATION_FLAG) != 0);
    printf("  Canvas size %d x %d\n",
           webp_info->canvas_width_, webp_info->canvas_height_);
  }
  if (webp_info->canvas_width_ > (1 << 24)) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 699 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 699 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Warning: %s\n", "Canvas width is out of range in VP8X chunk."); } ++webp_info->num_warnings_; } while (0);
  }
  if (webp_info->canvas_height_ > (1 << 24)) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 702 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 702 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Warning: %s\n", "Canvas height is out of range in VP8X chunk."); } ++webp_info->num_warnings_; } while (0);
  }
  if ((uint64_t)webp_info->canvas_width_ * webp_info->canvas_height_ >
      (1ULL << 32)) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 706 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 706 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Warning: %s\n", "Canvas area is out of range in VP8X chunk."); } ++webp_info->num_warnings_; } while (0);
  }
  return WEBP_INFO_OK;
}

static WebPInfoStatus ProcessANIMChunk(const ChunkData* const chunk_data,
                                       WebPInfo* const webp_info) {
  const uint8_t* data = chunk_data->payload_;
  if (!webp_info->chunk_counts_[CHUNK_VP8X]) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 715 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 715 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "ANIM chunk detected before VP8X chunk."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  if (chunk_data->size_ != 6 + 8) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 719 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 719 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Corrupted ANIM chunk."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  webp_info->bgcolor_ = ReadLE32(&data);
  webp_info->loop_count_ = ReadLE16(&data);
  ++webp_info->chunk_counts_[CHUNK_ANIM];
  if (!webp_info->quiet_) {
    printf("  Background color:(ARGB) %02x %02x %02x %02x\n",
           (webp_info->bgcolor_ >> 24) & 0xff,
           (webp_info->bgcolor_ >> 16) & 0xff,
           (webp_info->bgcolor_ >> 8) & 0xff,
           webp_info->bgcolor_ & 0xff);
    printf("  Loop count      : %d\n", webp_info->loop_count_);
  }
  if (webp_info->loop_count_ > (1 << 16)) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 734 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 734 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Warning: %s\n", "Loop count is out of range in ANIM chunk."); } ++webp_info->num_warnings_; } while (0);
  }
  return WEBP_INFO_OK;
}

static WebPInfoStatus ProcessANMFChunk(const ChunkData* const chunk_data,
                                       WebPInfo* const webp_info) {
  const uint8_t* data = chunk_data->payload_;
  int offset_x, offset_y, width, height, duration, blend, dispose, temp;
  if (webp_info->is_processing_anim_frame_) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 744 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 744 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "ANMF chunk detected within another ANMF chunk."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  if (!webp_info->chunk_counts_[CHUNK_ANIM]) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 748 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 748 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "ANMF chunk detected before ANIM chunk."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  if (chunk_data->size_ <= 8 + 16) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 752 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 752 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Truncated data detected when parsing ANMF chunk."); } } while (0);
    return WEBP_INFO_TRUNCATED_DATA;
  }
  offset_x = 2 * ReadLE24(&data);
  offset_y = 2 * ReadLE24(&data);
  width = 1 + ReadLE24(&data);
  height = 1 + ReadLE24(&data);
  duration = ReadLE24(&data);
  temp = *data;
  dispose = temp & 1;
  blend = (temp >> 1) & 1;
  ++webp_info->chunk_counts_[CHUNK_ANMF];
  if (!webp_info->quiet_) {
    printf("  Offset_X: %d\n  Offset_Y: %d\n  Width: %d\n  Height: %d\n"
           "  Duration: %d\n  Dispose: %d\n  Blend: %d\n",
           offset_x, offset_y, width, height, duration, dispose, blend);
  }
  if (duration > (1 << 24)) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 770 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 770 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Invalid duration parameter in ANMF chunk."); } } while (0);
    return WEBP_INFO_INVALID_PARAM;
  }
  if (offset_x > (1 << 24) || offset_y > (1 << 24)) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 774 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 774 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Invalid offset parameters in ANMF chunk."); } } while (0);
    return WEBP_INFO_INVALID_PARAM;
  }
  if ((uint64_t)offset_x + width > (uint64_t)webp_info->canvas_width_ ||
      (uint64_t)offset_y + height > (uint64_t)webp_info->canvas_height_) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 779 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 779 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "Frame exceeds canvas in ANMF chunk."); } } while (0);
    return WEBP_INFO_INVALID_PARAM;
  }
  webp_info->is_processing_anim_frame_ = 1;
  webp_info->seen_alpha_subchunk_ = 0;
  webp_info->seen_image_subchunk_ = 0;
  webp_info->frame_width_ = width;
  webp_info->frame_height_ = height;
  webp_info->anim_frame_data_size_ =
      chunk_data->size_ - 8 - 16;
  return WEBP_INFO_OK;
}

static WebPInfoStatus ProcessImageChunk(const ChunkData* const chunk_data,
                                        WebPInfo* const webp_info) {
  const uint8_t* data = chunk_data->payload_ - 8;
  WebPBitstreamFeatures features;
  const VP8StatusCode vp8_status =
      WebPGetFeatures(data, chunk_data->size_, &features);
  if (vp8_status != VP8_STATUS_OK) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 799 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 799 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "VP8/VP8L bitstream error."); } } while (0);
    return WEBP_INFO_BITSTREAM_ERROR;
  }
  if (!webp_info->quiet_) {
    
# 803 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   ((void) (0))
# 803 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
                                                       ;
    printf("  Width: %d\n  Height: %d\n  Alpha: %d\n  Animation: %d\n"
           "  Format: %s (%d)\n",
           features.width, features.height, features.has_alpha,
           features.has_animation, kFormats[features.format], features.format);
  }
  if (webp_info->is_processing_anim_frame_) {
    ++webp_info->anmf_subchunk_counts_[chunk_data->id_ == CHUNK_VP8 ? 0 : 1];
    if (chunk_data->id_ == CHUNK_VP8L && webp_info->seen_alpha_subchunk_) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 812 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 812 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Both VP8L and ALPH sub-chunks are present in an ANMF chunk."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (webp_info->frame_width_ != features.width ||
        webp_info->frame_height_ != features.height) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 817 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 817 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Frame size in VP8/VP8L sub-chunk differs from ANMF header."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (webp_info->seen_image_subchunk_) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 821 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 821 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Consecutive VP8/VP8L sub-chunks in an ANMF chunk."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    webp_info->seen_image_subchunk_ = 1;
  } else {
    if (webp_info->chunk_counts_[CHUNK_VP8] ||
        webp_info->chunk_counts_[CHUNK_VP8L]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 828 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 828 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Multiple VP8/VP8L chunks detected."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (chunk_data->id_ == CHUNK_VP8L &&
        webp_info->chunk_counts_[CHUNK_ALPHA]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 833 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 833 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Warning: %s\n", "Both VP8L and ALPH chunks are detected."); } ++webp_info->num_warnings_; } while (0);
    }
    if (webp_info->chunk_counts_[CHUNK_ANIM] ||
        webp_info->chunk_counts_[CHUNK_ANMF]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 837 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 837 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "VP8/VP8L chunk and ANIM/ANMF chunk are both detected."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (webp_info->chunk_counts_[CHUNK_VP8X]) {
      if (webp_info->canvas_width_ != features.width ||
          webp_info->canvas_height_ != features.height) {
        do { if (webp_info->show_diagnosis_) { fprintf(
# 843 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 843 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "Image size in VP8/VP8L chunk differs from VP8X chunk."); } } while (0);
        return WEBP_INFO_PARSE_ERROR;
      }
    } else {
      webp_info->canvas_width_ = features.width;
      webp_info->canvas_height_ = features.height;
      if (webp_info->canvas_width_ < 1 || webp_info->canvas_height_ < 1 ||
          webp_info->canvas_width_ > (1 << 24) ||
          webp_info->canvas_height_ > (1 << 24) ||
          (uint64_t)webp_info->canvas_width_ * webp_info->canvas_height_ >
              (1ULL << 32)) {
        do { if (webp_info->show_diagnosis_) { fprintf(
# 854 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 854 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Warning: %s\n", "Invalid parameters in VP8/VP8L chunk."); } ++webp_info->num_warnings_; } while (0);
      }
    }
    ++webp_info->chunk_counts_[chunk_data->id_];
  }
  ++webp_info->num_frames_;
  webp_info->has_alpha_ |= features.has_alpha;
  if (webp_info->parse_bitstream_) {
    const int is_lossy = (chunk_data->id_ == CHUNK_VP8);
    const WebPInfoStatus status =
        is_lossy ? ParseLossyHeader(chunk_data, webp_info)
                 : ParseLosslessHeader(chunk_data, webp_info);
    if (status != WEBP_INFO_OK) return status;
  }
  return WEBP_INFO_OK;
}

static WebPInfoStatus ProcessALPHChunk(const ChunkData* const chunk_data,
                                       WebPInfo* const webp_info) {
  if (webp_info->is_processing_anim_frame_) {
    ++webp_info->anmf_subchunk_counts_[2];
    if (webp_info->seen_alpha_subchunk_) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 876 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 876 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Consecutive ALPH sub-chunks in an ANMF chunk."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    webp_info->seen_alpha_subchunk_ = 1;

    if (webp_info->seen_image_subchunk_) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 882 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 882 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "ALPHA sub-chunk detected after VP8 sub-chunk " "in an ANMF chunk."); } } while (0)
                                    ;
      return WEBP_INFO_PARSE_ERROR;
    }
  } else {
    if (webp_info->chunk_counts_[CHUNK_ANIM] ||
        webp_info->chunk_counts_[CHUNK_ANMF]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 889 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 889 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "ALPHA chunk and ANIM/ANMF chunk are both detected."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (!webp_info->chunk_counts_[CHUNK_VP8X]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 893 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 893 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "ALPHA chunk detected before VP8X chunk."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (webp_info->chunk_counts_[CHUNK_VP8]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 897 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 897 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "ALPHA chunk detected after VP8 chunk."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (webp_info->chunk_counts_[CHUNK_ALPHA]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 901 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 901 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Multiple ALPHA chunks detected."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    ++webp_info->chunk_counts_[CHUNK_ALPHA];
  }
  webp_info->has_alpha_ = 1;
  if (webp_info->parse_bitstream_) {
    const WebPInfoStatus status = ParseAlphaHeader(chunk_data, webp_info);
    if (status != WEBP_INFO_OK) return status;
  }
  return WEBP_INFO_OK;
}

static WebPInfoStatus ProcessICCPChunk(const ChunkData* const chunk_data,
                                       WebPInfo* const webp_info) {
  (void)chunk_data;
  if (!webp_info->chunk_counts_[CHUNK_VP8X]) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 918 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 918 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "ICCP chunk detected before VP8X chunk."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  if (webp_info->chunk_counts_[CHUNK_VP8] ||
      webp_info->chunk_counts_[CHUNK_VP8L] ||
      webp_info->chunk_counts_[CHUNK_ANIM]) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 924 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 924 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "ICCP chunk detected after image data."); } } while (0);
    return WEBP_INFO_PARSE_ERROR;
  }
  ++webp_info->chunk_counts_[CHUNK_ICCP];
  return WEBP_INFO_OK;
}

static WebPInfoStatus ProcessChunk(const ChunkData* const chunk_data,
                                   WebPInfo* const webp_info) {
  WebPInfoStatus status = WEBP_INFO_OK;
  ChunkID id = chunk_data->id_;
  if (chunk_data->id_ == CHUNK_UNKNOWN) {
    char error_message[50];
    snprintf(error_message, 50, "Unknown chunk at offset %6d, length %6d",
            (int)chunk_data->offset_, (int)chunk_data->size_);
    do { if (webp_info->show_diagnosis_) { fprintf(
# 939 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 939 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Warning: %s\n", error_message); } ++webp_info->num_warnings_; } while (0);
  } else {
    if (!webp_info->quiet_) {
      char tag[4];
      uint32_t fourcc = kWebPChunkTags[chunk_data->id_];




      memcpy(tag, &fourcc, sizeof(tag));
      printf("Chunk %c%c%c%c at offset %6d, length %6d\n",
             tag[0], tag[1], tag[2], tag[3], (int)chunk_data->offset_,
             (int)chunk_data->size_);
    }
  }
  switch (id) {
    case CHUNK_VP8:
    case CHUNK_VP8L:
      status = ProcessImageChunk(chunk_data, webp_info);
      break;
    case CHUNK_VP8X:
      status = ProcessVP8XChunk(chunk_data, webp_info);
      break;
    case CHUNK_ALPHA:
      status = ProcessALPHChunk(chunk_data, webp_info);
      break;
    case CHUNK_ANIM:
      status = ProcessANIMChunk(chunk_data, webp_info);
      break;
    case CHUNK_ANMF:
      status = ProcessANMFChunk(chunk_data, webp_info);
      break;
    case CHUNK_ICCP:
      status = ProcessICCPChunk(chunk_data, webp_info);
      break;
    case CHUNK_EXIF:
    case CHUNK_XMP:
      ++webp_info->chunk_counts_[id];
      break;
    case CHUNK_UNKNOWN:
    default:
      break;
  }
  if (webp_info->is_processing_anim_frame_ && id != CHUNK_ANMF) {
    if (webp_info->anim_frame_data_size_ == chunk_data->size_) {
      if (!webp_info->seen_image_subchunk_) {
        do { if (webp_info->show_diagnosis_) { fprintf(
# 985 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
       stderr
# 985 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
       , "Error: %s\n", "No VP8/VP8L chunk detected in an ANMF chunk."); } } while (0);
        return WEBP_INFO_PARSE_ERROR;
      }
      webp_info->is_processing_anim_frame_ = 0;
    } else if (webp_info->anim_frame_data_size_ > chunk_data->size_) {
      webp_info->anim_frame_data_size_ -= chunk_data->size_;
    } else {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 992 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 992 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Truncated data detected when parsing ANMF chunk."); } } while (0);
      return WEBP_INFO_TRUNCATED_DATA;
    }
  }
  return status;
}

static WebPInfoStatus Validate(WebPInfo* const webp_info) {
  if (webp_info->num_frames_ < 1) {
    do { if (webp_info->show_diagnosis_) { fprintf(
# 1001 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
   stderr
# 1001 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
   , "Error: %s\n", "No image/frame detected."); } } while (0);
    return WEBP_INFO_MISSING_DATA;
  }
  if (webp_info->chunk_counts_[CHUNK_VP8X]) {
    const int iccp = !!(webp_info->feature_flags_ & ICCP_FLAG);
    const int exif = !!(webp_info->feature_flags_ & EXIF_FLAG);
    const int xmp = !!(webp_info->feature_flags_ & XMP_FLAG);
    const int animation = !!(webp_info->feature_flags_ & ANIMATION_FLAG);
    const int alpha = !!(webp_info->feature_flags_ & ALPHA_FLAG);
    if (!alpha && webp_info->has_alpha_) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1011 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1011 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Unexpected alpha data detected."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (alpha && !webp_info->has_alpha_) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1015 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1015 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Warning: %s\n", "Alpha flag is set with no alpha data present."); } ++webp_info->num_warnings_; } while (0);
    }
    if (iccp && !webp_info->chunk_counts_[CHUNK_ICCP]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1018 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1018 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Missing ICCP chunk."); } } while (0);
      return WEBP_INFO_MISSING_DATA;
    }
    if (exif && !webp_info->chunk_counts_[CHUNK_EXIF]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1022 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1022 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Missing EXIF chunk."); } } while (0);
      return WEBP_INFO_MISSING_DATA;
    }
    if (xmp && !webp_info->chunk_counts_[CHUNK_XMP]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1026 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1026 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Missing XMP chunk."); } } while (0);
      return WEBP_INFO_MISSING_DATA;
    }
    if (!iccp && webp_info->chunk_counts_[CHUNK_ICCP]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1030 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1030 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Unexpected ICCP chunk detected."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (!exif && webp_info->chunk_counts_[CHUNK_EXIF]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1034 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1034 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Unexpected EXIF chunk detected."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (!xmp && webp_info->chunk_counts_[CHUNK_XMP]) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1038 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1038 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "Unexpected XMP chunk detected."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }

    if (webp_info->is_processing_anim_frame_) return WEBP_INFO_MISSING_DATA;
    if (!animation && webp_info->num_frames_ > 1) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1044 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1044 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "More than 1 frame detected in non-animation file."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
    if (animation && (!webp_info->chunk_counts_[CHUNK_ANIM] ||
        !webp_info->chunk_counts_[CHUNK_ANMF])) {
      do { if (webp_info->show_diagnosis_) { fprintf(
# 1049 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1049 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Error: %s\n", "No ANIM/ANMF chunk detected in animation file."); } } while (0);
      return WEBP_INFO_PARSE_ERROR;
    }
  }
  return WEBP_INFO_OK;
}

static void ShowSummary(const WebPInfo* const webp_info) {
  int i;
  printf("Summary:\n");
  printf("Number of frames: %d\n", webp_info->num_frames_);
  printf("Chunk type  :  VP8 VP8L VP8X ALPH ANIM ANMF(VP8 /VP8L/ALPH) ICCP "
      "EXIF  XMP\n");
  printf("Chunk counts: ");
  for (i = 0; i < CHUNK_TYPES; ++i) {
    printf("%4d ", webp_info->chunk_counts_[i]);
    if (i == CHUNK_ANMF) {
      printf("%4d %4d %4d  ",
             webp_info->anmf_subchunk_counts_[0],
             webp_info->anmf_subchunk_counts_[1],
             webp_info->anmf_subchunk_counts_[2]);
    }
  }
  printf("\n");
}

static WebPInfoStatus AnalyzeWebP(WebPInfo* const webp_info,
                                  const WebPData* webp_data) {
  ChunkData chunk_data;
  MemBuffer mem_buffer;
  WebPInfoStatus webp_info_status = WEBP_INFO_OK;

  InitMemBuffer(&mem_buffer, webp_data);
  webp_info_status = ParseRIFFHeader(webp_info, &mem_buffer);
  if (webp_info_status != WEBP_INFO_OK) goto Error;


  while (webp_info_status == WEBP_INFO_OK && MemDataSize(&mem_buffer) > 0) {
    webp_info_status = ParseChunk(webp_info, &mem_buffer, &chunk_data);
    if (webp_info_status != WEBP_INFO_OK) goto Error;
    webp_info_status = ProcessChunk(&chunk_data, webp_info);
  }
  if (webp_info_status != WEBP_INFO_OK) goto Error;
  if (webp_info->show_summary_) ShowSummary(webp_info);


  webp_info_status = Validate(webp_info);

 Error:
  if (!webp_info->quiet_) {
    if (webp_info_status == WEBP_INFO_OK) {
      printf("No error detected.\n");
    } else {
      printf("Errors detected.\n");
    }
    if (webp_info->num_warnings_ > 0) {
      printf("There were %d warning(s).\n", webp_info->num_warnings_);
    }
  }
  return webp_info_status;
}

static void Help(void) {
  printf("Usage: webpinfo [options] in_files\n"
         "Note: there could be multiple input files;\n"
         "      options must come before input files.\n"
         "Options:\n"
         "  -version ........... Print version number and exit.\n"
         "  -quiet ............. Do not show chunk parsing information.\n"
         "  -diag .............. Show parsing error diagnosis.\n"
         "  -summary ........... Show chunk stats summary.\n"
         "  -bitstream_info .... Parse bitstream header.\n");
}

int main(int argc, const char* argv[]) {
  int c, quiet = 0, show_diag = 0, show_summary = 0;
  int parse_bitstream = 0;
  WebPInfoStatus webp_info_status = WEBP_INFO_OK;
  WebPInfo webp_info;

  ;

  if (argc == 1) {
    Help();
    do { ; return (WEBP_INFO_OK); } while (0);
  }


  for (c = 1; c < argc; ++c) {
    if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help") ||
        !strcmp(argv[c], "-H") || !strcmp(argv[c], "-longhelp")) {
      Help();
      do { ; return (WEBP_INFO_OK); } while (0);
    } else if (!strcmp(argv[c], "-quiet")) {
      quiet = 1;
    } else if (!strcmp(argv[c], "-diag")) {
      show_diag = 1;
    } else if (!strcmp(argv[c], "-summary")) {
      show_summary = 1;
    } else if (!strcmp(argv[c], "-bitstream_info")) {
      parse_bitstream = 1;
    } else if (!strcmp(argv[c], "-version")) {
      const int version = WebPGetDecoderVersion();
      printf("WebP Decoder version: %d.%d.%d\n",
             (version >> 16) & 0xff, (version >> 8) & 0xff, version & 0xff);
      do { ; return (0); } while (0);
    } else {
      break;
    }
  }

  if (c == argc) {
    Help();
    do { ; return (WEBP_INFO_INVALID_COMMAND); } while (0);
  }


  for (; c < argc; ++c) {
    WebPData webp_data;
    const char* in_file = 
# 1168 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
                           ((void *)0)
# 1168 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
                               ;
    WebPInfoInit(&webp_info);
    webp_info.quiet_ = quiet;
    webp_info.show_diagnosis_ = show_diag;
    webp_info.show_summary_ = show_summary;
    webp_info.parse_bitstream_ = parse_bitstream;
    in_file = (argv)[c];
    if (in_file == 
# 1175 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
                  ((void *)0) 
# 1175 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
                       ||
        !ReadFileToWebPData((const char*)in_file, &webp_data)) {
      webp_info_status = WEBP_INFO_INVALID_COMMAND;
      fprintf(
# 1178 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c" 3 4
     stderr
# 1178 "/doner/libwebp/libwebp-31bea324/examples/webpinfo.c"
     , "Failed to open input file %s.\n", in_file);
      continue;
    }
    if (!webp_info.quiet_) printf("File: %s\n", in_file);
    webp_info_status = AnalyzeWebP(&webp_info, &webp_data);
    WebPDataClear(&webp_data);
  }
  do { ; return (webp_info_status); } while (0);
}
