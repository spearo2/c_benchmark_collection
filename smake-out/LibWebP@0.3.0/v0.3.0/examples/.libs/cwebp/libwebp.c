/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef unsigned long size_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__0 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__0 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_1 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_1 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_2 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_2 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_3 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_3 lldiv_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_4 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_4 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_5 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_5 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_6 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_6 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_8 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_7 {
   unsigned long long __wseq ;
   struct __anonstruct_8 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_10 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_9 {
   unsigned long long __g1_start ;
   struct __anonstruct_10 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_7  ;
   unsigned long long __wseq ;
   struct __anonstruct_8 __wseq32 ;
   union __anonunion_9  ;
   unsigned long long __g1_start ;
   struct __anonstruct_10 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_barrierattr_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef long ptrdiff_t;
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
struct __anonstruct_19 {
   long long __max_align_ll ;
   long double __max_align_ld ;
};
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef struct __anonstruct_19 max_align_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 87 "/usr/include/stdint.h"
typedef long intptr_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 271 "/usr/include/inttypes.h"
struct __anonstruct_20 {
   long quot ;
   long rem ;
};
#line 275 "/usr/include/inttypes.h"
typedef struct __anonstruct_20 imaxdiv_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_22 {
   __cpu_mask __bits[16] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_22 cpu_set_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/pthread.h"
enum __anonenum__35 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 43
enum __anonenum__36 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
#line 65
enum __anonenum__37 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 77
enum __anonenum__38 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 100
enum __anonenum__39 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 120
enum __anonenum__40 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 130
enum __anonenum__41 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 140
enum __anonenum__42 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 155 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 164
enum __anonenum__43 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 171
enum __anonenum__44 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 501 "/usr/include/pthread.h"
struct __anonstruct_46 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 499 "/usr/include/pthread.h"
struct __anonstruct_45 {
   struct __anonstruct_46 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 507 "/usr/include/pthread.h"
typedef struct __anonstruct_45 __pthread_unwind_buf_t;
#line 516 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 718
struct __jmp_buf_tag ;
#line 44 "/doner/libwebp/libwebp-v0.3.0/src/utils/./thread.h"
enum __anonenum__47 {
    NOT_OK = 0,
    OK = 1,
    WORK = 2
} ;
#line 48 "/doner/libwebp/libwebp-v0.3.0/src/utils/./thread.h"
typedef enum __anonenum__47 WebPWorkerStatus;
#line 52 "/doner/libwebp/libwebp-v0.3.0/src/utils/./thread.h"
typedef int (*WebPWorkerHook)(void * , void * );
#line 55 "/doner/libwebp/libwebp-v0.3.0/src/utils/./thread.h"
struct __anonstruct_48 {
   pthread_mutex_t mutex_ ;
   pthread_cond_t condition_ ;
   pthread_t thread_ ;
   WebPWorkerStatus status_ ;
   WebPWorkerHook hook ;
   void *data1 ;
   void *data2 ;
   int had_error ;
};
#line 66 "/doner/libwebp/libwebp-v0.3.0/src/utils/./thread.h"
typedef struct __anonstruct_48 WebPWorker;
#line 22 "/doner/libwebp/libwebp-v0.3.0/src/utils/./rescaler.h"
struct __anonstruct_69 {
   int x_expand ;
   int num_channels ;
   int fy_scale ;
   int fx_scale ;
   int64_t fxy_scale ;
   int y_accum ;
   int y_add ;
   int y_sub ;
   int x_add ;
   int x_sub ;
   int src_width ;
   int src_height ;
   int dst_width ;
   int dst_height ;
   uint8_t *dst ;
   int dst_stride ;
   int32_t *irow ;
   int32_t *frow ;
};
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/utils/./rescaler.h"
typedef struct __anonstruct_69 WebPRescaler;
#line 22 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman_encode.h"
struct __anonstruct_75 {
   uint8_t code ;
   uint8_t extra_bits ;
};
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman_encode.h"
typedef struct __anonstruct_75 HuffmanTreeToken;
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman_encode.h"
struct __anonstruct_76 {
   int num_symbols ;
   uint8_t *code_lengths ;
   uint16_t *codes ;
};
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman_encode.h"
typedef struct __anonstruct_76 HuffmanTreeCode;
#line 53 "/doner/libwebp/libwebp-v0.3.0/src/utils/../webp/format_constants.h"
enum __anonenum__77 {
    PREDICTOR_TRANSFORM = 0,
    CROSS_COLOR_TRANSFORM = 1,
    SUBTRACT_GREEN = 2,
    COLOR_INDEXING_TRANSFORM = 3
} ;
#line 58 "/doner/libwebp/libwebp-v0.3.0/src/utils/../webp/format_constants.h"
typedef enum __anonenum__77 VP8LImageTransformType;
#line 124 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
struct __anonstruct_78 {
   int total_count_ ;
   int value_ ;
   int pool_index_left_ ;
   int pool_index_right_ ;
};
#line 129 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
typedef struct __anonstruct_78 HuffmanTree;
#line 23 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman.h"
struct __anonstruct_69___0 {
   int symbol_ ;
   int children_ ;
};
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman.h"
typedef struct __anonstruct_69___0 HuffmanTreeNode;
#line 29
struct HuffmanTree ;
#line 29 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman.h"
typedef struct HuffmanTree HuffmanTree___0;
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman.h"
struct HuffmanTree {
   HuffmanTreeNode *root_ ;
   int max_nodes_ ;
   int num_nodes_ ;
};
#line 22 "/doner/libwebp/libwebp-v0.3.0/src/utils/./filters.h"
enum __anonenum__80 {
    WEBP_FILTER_NONE = 0,
    WEBP_FILTER_HORIZONTAL = 1,
    WEBP_FILTER_VERTICAL = 2,
    WEBP_FILTER_GRADIENT = 3,
    WEBP_FILTER_LAST = 4,
    WEBP_FILTER_BEST = 5,
    WEBP_FILTER_FAST = 6
} ;
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/utils/./filters.h"
typedef enum __anonenum__80 WEBP_FILTER_TYPE;
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/utils/./filters.h"
typedef void (*WebPFilterFunc)(uint8_t * , int  , int  , int  , uint8_t * );
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/utils/./filters.h"
typedef void (*WebPUnfilterFunc)(int  , int  , int  , uint8_t * );
#line 23 "/doner/libwebp/libwebp-v0.3.0/src/utils/./color_cache.h"
struct __anonstruct_69___1 {
   uint32_t *colors_ ;
   int hash_shift_ ;
};
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/utils/./color_cache.h"
typedef struct __anonstruct_69___1 VP8LColorCache;
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
struct VP8BitWriter ;
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
typedef struct VP8BitWriter VP8BitWriter;
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
struct VP8BitWriter {
   int32_t range_ ;
   int32_t value_ ;
   int run_ ;
   int nb_bits_ ;
   uint8_t *buf_ ;
   size_t pos_ ;
   size_t max_pos_ ;
   int error_ ;
};
#line 73 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
struct __anonstruct_120 {
   uint8_t *buf_ ;
   size_t bit_pos_ ;
   size_t max_bytes_ ;
   int error_ ;
};
#line 83 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
typedef struct __anonstruct_120 VP8LBitWriter;
#line 93 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
typedef uint64_t bit_t;
#line 94 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
typedef uint64_t lbit_t;
#line 113 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
typedef uint32_t range_t;
#line 119
struct VP8BitReader ;
#line 119 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
typedef struct VP8BitReader VP8BitReader;
#line 120 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
struct VP8BitReader {
   uint8_t *buf_ ;
   uint8_t *buf_end_ ;
   int eof_ ;
   range_t range_ ;
   bit_t value_ ;
   int bits_ ;
};
#line 286 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
typedef uint64_t vp8l_val_t;
#line 288 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
struct __anonstruct_124 {
   vp8l_val_t val_ ;
   uint8_t *buf_ ;
   size_t len_ ;
   size_t pos_ ;
   int bit_pos_ ;
   int eos_ ;
   int error_ ;
};
#line 296 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
typedef struct __anonstruct_124 VP8LBitReader;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__125 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
enum WebPImageHint {
    WEBP_HINT_DEFAULT = 0,
    WEBP_HINT_PICTURE = 1,
    WEBP_HINT_PHOTO = 2,
    WEBP_HINT_GRAPH = 3,
    WEBP_HINT_LAST = 4
} ;
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef enum WebPImageHint WebPImageHint;
#line 25
enum WebPEncCSP {
    WEBP_YUV420 = 0,
    WEBP_YUV422 = 1,
    WEBP_YUV444 = 2,
    WEBP_YUV400 = 3,
    WEBP_CSP_UV_MASK = 3,
    WEBP_YUV420A = 4,
    WEBP_YUV422A = 5,
    WEBP_YUV444A = 6,
    WEBP_YUV400A = 7,
    WEBP_CSP_ALPHA_BIT = 4
} ;
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef enum WebPEncCSP WebPEncCSP;
#line 26
enum WebPPreset {
    WEBP_PRESET_DEFAULT = 0,
    WEBP_PRESET_PICTURE = 1,
    WEBP_PRESET_PHOTO = 2,
    WEBP_PRESET_DRAWING = 3,
    WEBP_PRESET_ICON = 4,
    WEBP_PRESET_TEXT = 5
} ;
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef enum WebPPreset WebPPreset;
#line 27
enum WebPEncodingError {
    VP8_ENC_OK = 0,
    VP8_ENC_ERROR_OUT_OF_MEMORY = 1,
    VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 2,
    VP8_ENC_ERROR_NULL_PARAMETER = 3,
    VP8_ENC_ERROR_INVALID_CONFIGURATION = 4,
    VP8_ENC_ERROR_BAD_DIMENSION = 5,
    VP8_ENC_ERROR_PARTITION0_OVERFLOW = 6,
    VP8_ENC_ERROR_PARTITION_OVERFLOW = 7,
    VP8_ENC_ERROR_BAD_WRITE = 8,
    VP8_ENC_ERROR_FILE_TOO_BIG = 9,
    VP8_ENC_ERROR_USER_ABORT = 10,
    VP8_ENC_ERROR_LAST = 11
} ;
#line 27 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef enum WebPEncodingError WebPEncodingError;
#line 29
struct WebPConfig ;
#line 29 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef struct WebPConfig WebPConfig;
#line 30
struct WebPPicture ;
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef struct WebPPicture WebPPicture;
#line 31
struct WebPAuxStats ;
#line 31 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef struct WebPAuxStats WebPAuxStats;
#line 32
struct WebPMemoryWriter ;
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef struct WebPMemoryWriter WebPMemoryWriter;
#line 80
enum WebPImageHint___0 {
    WEBP_HINT_DEFAULT___0 = 0,
    WEBP_HINT_PICTURE___0 = 1,
    WEBP_HINT_PHOTO___0 = 2,
    WEBP_HINT_GRAPH___0 = 3,
    WEBP_HINT_LAST___0 = 4
} ;
#line 89 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
struct WebPConfig {
   int lossless ;
   float quality ;
   int method ;
   enum WebPImageHint___0 image_hint ;
   int target_size ;
   float target_PSNR ;
   int segments ;
   int sns_strength ;
   int filter_strength ;
   int filter_sharpness ;
   int filter_type ;
   int autofilter ;
   int alpha_compression ;
   int alpha_filtering ;
   int alpha_quality ;
   int pass ;
   int show_compressed ;
   int preprocessing ;
   int partitions ;
   int partition_limit ;
   int emulate_jpeg_size ;
   int thread_level ;
   int low_memory ;
   uint32_t pad[5] ;
};
#line 136
enum WebPPreset___0 {
    WEBP_PRESET_DEFAULT___0 = 0,
    WEBP_PRESET_PICTURE___0 = 1,
    WEBP_PRESET_PHOTO___0 = 2,
    WEBP_PRESET_DRAWING___0 = 3,
    WEBP_PRESET_ICON___0 = 4,
    WEBP_PRESET_TEXT___0 = 5
} ;
#line 175 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
struct WebPAuxStats {
   int coded_size ;
   float PSNR[5] ;
   int block_count[3] ;
   int header_bytes[2] ;
   int residual_bytes[3][4] ;
   int segment_size[4] ;
   int segment_quant[4] ;
   int segment_level[4] ;
   int alpha_data_size ;
   int layer_data_size ;
   uint32_t lossless_features ;
   int histogram_bits ;
   int transform_bits ;
   int cache_bits ;
   int palette_size ;
   int lossless_size ;
   uint32_t pad[4] ;
};
#line 206 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef int (*WebPWriterFunction)(uint8_t * , size_t  , WebPPicture * );
#line 211 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
struct WebPMemoryWriter {
   uint8_t *mem ;
   size_t size ;
   size_t max_size ;
   uint32_t pad[1] ;
};
#line 230 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
typedef int (*WebPProgressHook)(int  , WebPPicture * );
#line 233
enum WebPEncCSP___0 {
    WEBP_YUV420___0 = 0,
    WEBP_YUV422___0 = 1,
    WEBP_YUV444___0 = 2,
    WEBP_YUV400___0 = 3,
    WEBP_CSP_UV_MASK___0 = 3,
    WEBP_YUV420A___0 = 4,
    WEBP_YUV422A___0 = 5,
    WEBP_YUV444A___0 = 6,
    WEBP_YUV400A___0 = 7,
    WEBP_CSP_ALPHA_BIT___0 = 4
} ;
#line 249
enum WebPEncodingError___0 {
    VP8_ENC_OK___0 = 0,
    VP8_ENC_ERROR_OUT_OF_MEMORY___0 = 1,
    VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY___0 = 2,
    VP8_ENC_ERROR_NULL_PARAMETER___0 = 3,
    VP8_ENC_ERROR_INVALID_CONFIGURATION___0 = 4,
    VP8_ENC_ERROR_BAD_DIMENSION___0 = 5,
    VP8_ENC_ERROR_PARTITION0_OVERFLOW___0 = 6,
    VP8_ENC_ERROR_PARTITION_OVERFLOW___0 = 7,
    VP8_ENC_ERROR_BAD_WRITE___0 = 8,
    VP8_ENC_ERROR_FILE_TOO_BIG___0 = 9,
    VP8_ENC_ERROR_USER_ABORT___0 = 10,
    VP8_ENC_ERROR_LAST___0 = 11
} ;
#line 268 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
struct WebPPicture {
   int use_argb ;
   enum WebPEncCSP___0 colorspace ;
   int width ;
   int height ;
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   int y_stride ;
   int uv_stride ;
   uint8_t *a ;
   int a_stride ;
   uint32_t pad1[2] ;
   uint32_t *argb ;
   int argb_stride ;
   uint32_t pad2[3] ;
   WebPWriterFunction writer ;
   void *custom_ptr ;
   int extra_info_type ;
   uint8_t *extra_info ;
   WebPAuxStats *stats ;
   enum WebPEncodingError___0 error_code ;
   WebPProgressHook progress_hook ;
   void *user_data ;
   uint32_t pad3[3] ;
   uint8_t *u0 ;
   uint8_t *v0 ;
   int uv0_stride ;
   uint32_t pad4[7] ;
   void *memory_ ;
   void *memory_argb_ ;
   void *pad5[2] ;
};
#line 40 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
enum __anonenum__128 {
    kSSE2 = 0,
    kSSE3 = 1,
    kNEON = 2
} ;
#line 44 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef enum __anonenum__128 CPUFeature;
#line 46 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef int (*VP8CPUInfo)(CPUFeature  );
#line 55 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8Idct)(uint8_t * , int16_t * , uint8_t * , int  );
#line 57 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8Fdct)(uint8_t * , uint8_t * , int16_t * );
#line 58 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8WHT)(int16_t * , int16_t * );
#line 65 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8IntraPreds)(uint8_t * , uint8_t * , uint8_t * );
#line 67 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8Intra4Preds)(uint8_t * , uint8_t * );
#line 72 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef int (*VP8Metric)(uint8_t * , uint8_t * );
#line 74 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef int (*VP8WMetric)(uint8_t * , uint8_t * , uint16_t * const   );
#line 78 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8BlockCopy)(uint8_t * , uint8_t * );
#line 81
struct VP8Matrix ;
#line 82 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef int (*VP8QuantizeBlock)(int16_t [16] , int16_t [16] , int  , struct VP8Matrix * const   );
#line 87
struct VP8Histogram ;
#line 88 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8CHisto)(uint8_t * , uint8_t * , int  , int  , struct VP8Histogram * const   );
#line 99 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8DecIdct)(int16_t * , uint8_t * );
#line 101 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8DecIdct2)(int16_t * , uint8_t * , int  );
#line 110 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8PredFunc)(uint8_t * );
#line 116 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8SimpleFilterFunc)(uint8_t * , int  , int  );
#line 123 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8LumaFilterFunc)(uint8_t * , int  , int  , int  , int  );
#line 125 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*VP8ChromaFilterFunc)(uint8_t * , uint8_t * , int  , int  , int  , int  );
#line 147 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*WebPUpsampleLinePairFunc)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                         uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                         int  );
#line 167 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*WebPSampleLinePairFunc)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                       uint8_t * , uint8_t * , int  );
#line 180 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
typedef void (*WebPYUV444Converter)(uint8_t * , uint8_t * , uint8_t * , uint8_t * ,
                                    int  );
#line 33 "/usr/include/pthread.h"
enum __anonenum__131 {
    PTHREAD_CREATE_JOINABLE___0 = 0,
    PTHREAD_CREATE_DETACHED___0 = 1
} ;
#line 43
enum __anonenum__132 {
    PTHREAD_MUTEX_TIMED_NP___0 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___0 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___0 = 3,
    PTHREAD_MUTEX_NORMAL___0 = 0,
    PTHREAD_MUTEX_RECURSIVE___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK___0 = 2,
    PTHREAD_MUTEX_DEFAULT___0 = 0
} ;
#line 65
enum __anonenum__133 {
    PTHREAD_MUTEX_STALLED___0 = 0,
    PTHREAD_MUTEX_STALLED_NP___0 = 0,
    PTHREAD_MUTEX_ROBUST___0 = 1,
    PTHREAD_MUTEX_ROBUST_NP___0 = 1
} ;
#line 77
enum __anonenum__134 {
    PTHREAD_PRIO_NONE___0 = 0,
    PTHREAD_PRIO_INHERIT___0 = 1,
    PTHREAD_PRIO_PROTECT___0 = 2
} ;
#line 100
enum __anonenum__135 {
    PTHREAD_RWLOCK_PREFER_READER_NP___0 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___0 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___0 = 0
} ;
#line 120
enum __anonenum__136 {
    PTHREAD_INHERIT_SCHED___0 = 0,
    PTHREAD_EXPLICIT_SCHED___0 = 1
} ;
#line 130
enum __anonenum__137 {
    PTHREAD_SCOPE_SYSTEM___0 = 0,
    PTHREAD_SCOPE_PROCESS___0 = 1
} ;
#line 140
enum __anonenum__138 {
    PTHREAD_PROCESS_PRIVATE___0 = 0,
    PTHREAD_PROCESS_SHARED___0 = 1
} ;
#line 164
enum __anonenum__139 {
    PTHREAD_CANCEL_ENABLE___0 = 0,
    PTHREAD_CANCEL_DISABLE___0 = 1
} ;
#line 171
enum __anonenum__140 {
    PTHREAD_CANCEL_DEFERRED___0 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___0 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__145 {
    B_DC_PRED = 0,
    B_TM_PRED = 1,
    B_VE_PRED = 2,
    B_HE_PRED = 3,
    B_RD_PRED = 4,
    B_VR_PRED = 5,
    B_LD_PRED = 6,
    B_VL_PRED = 7,
    B_HD_PRED = 8,
    B_HU_PRED = 9,
    NUM_BMODES = 10,
    DC_PRED = 0,
    V_PRED = 2,
    H_PRED = 3,
    TM_PRED = 1,
    NUM_PRED_MODES = 4
} ;
#line 52
enum __anonenum__146 {
    NUM_MB_SEGMENTS = 4,
    MAX_NUM_PARTITIONS = 8,
    NUM_TYPES = 4,
    NUM_BANDS = 8,
    NUM_CTX = 3,
    NUM_PROBAS = 11,
    MAX_LF_LEVELS = 64,
    MAX_VARIABLE_LEVEL = 67,
    MAX_LEVEL = 2047
} ;
#line 63
enum __anonenum__147 {
    RD_OPT_NONE = 0,
    RD_OPT_BASIC = 1,
    RD_OPT_TRELLIS = 2,
    RD_OPT_TRELLIS_ALL = 3
} ;
#line 68 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef enum __anonenum__147 VP8RDLevel;
#line 160 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef int64_t score_t;
#line 173 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct VP8Histogram VP8Histogram;
#line 174 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct VP8Histogram {
   int distribution[32] ;
};
#line 185 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef uint32_t proba_t;
#line 186 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef uint8_t ProbaArray[3][11];
#line 187 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef proba_t StatsArray[3][11];
#line 188 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef uint16_t CostArray[3][68];
#line 189 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef double LFStats[4][64];
#line 191
struct VP8Encoder ;
#line 191 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct VP8Encoder VP8Encoder;
#line 194 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct __anonstruct_148 {
   int num_segments_ ;
   int update_map_ ;
   int size_ ;
};
#line 199 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct __anonstruct_148 VP8SegmentHeader;
#line 202 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct __anonstruct_149 {
   uint8_t segments_[3] ;
   uint8_t skip_proba_ ;
   ProbaArray coeffs_[4][8] ;
   StatsArray stats_[4][8] ;
   CostArray level_cost_[4][8] ;
   int dirty_ ;
   int use_skip_proba_ ;
   int nb_skip_ ;
};
#line 211 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct __anonstruct_149 VP8Proba;
#line 215 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct __anonstruct_150 {
   int simple_ ;
   int level_ ;
   int sharpness_ ;
   int i4x4_lf_delta_ ;
};
#line 220 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct __anonstruct_150 VP8FilterHeader;
#line 225 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct __anonstruct_151 {
   unsigned int type_ ;
   unsigned int uv_mode_ ;
   unsigned int skip_ ;
   unsigned int segment_ ;
   uint8_t alpha_ ;
};
#line 232 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct __anonstruct_151 VP8MBInfo;
#line 234 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct VP8Matrix {
   uint16_t q_[16] ;
   uint16_t iq_[16] ;
   uint16_t bias_[16] ;
   uint16_t zthresh_[16] ;
   uint16_t sharpen_[16] ;
};
#line 240 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct VP8Matrix VP8Matrix;
#line 242 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct __anonstruct_152 {
   VP8Matrix y1_ ;
   VP8Matrix y2_ ;
   VP8Matrix uv_ ;
   int alpha_ ;
   int beta_ ;
   int quant_ ;
   int fstrength_ ;
   int lambda_i16_ ;
   int lambda_i4_ ;
   int lambda_uv_ ;
   int lambda_mode_ ;
   int lambda_trellis_ ;
   int tlambda_ ;
   int lambda_trellis_i16_ ;
   int lambda_trellis_i4_ ;
   int lambda_trellis_uv_ ;
};
#line 253 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct __anonstruct_152 VP8SegmentInfo;
#line 257 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct __anonstruct_153 {
   score_t D ;
   score_t SD ;
   score_t R ;
   score_t score ;
   int16_t y_dc_levels[16] ;
   int16_t y_ac_levels[16][16] ;
   int16_t uv_levels[8][16] ;
   int mode_i16 ;
   uint8_t modes_i4[16] ;
   int mode_uv ;
   uint32_t nz ;
};
#line 266 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct __anonstruct_153 VP8ModeScore;
#line 270 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct __anonstruct_154 {
   int x_ ;
   int y_ ;
   int y_offset_ ;
   int uv_offset_ ;
   int y_stride_ ;
   int uv_stride_ ;
   uint8_t *yuv_in_ ;
   uint8_t *yuv_out_ ;
   uint8_t *yuv_out2_ ;
   uint8_t *yuv_p_ ;
   VP8Encoder *enc_ ;
   VP8MBInfo *mb_ ;
   VP8BitWriter *bw_ ;
   uint8_t *preds_ ;
   uint32_t *nz_ ;
   uint8_t i4_boundary_[37] ;
   uint8_t *i4_top_ ;
   int i4_ ;
   int top_nz_[9] ;
   int left_nz_[9] ;
   uint64_t bit_count_[4][3] ;
   uint64_t luma_bits_ ;
   uint64_t uv_bits_ ;
   LFStats *lf_stats_ ;
   int do_trellis_ ;
   int done_ ;
   int percent0_ ;
};
#line 295 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct __anonstruct_154 VP8EncIterator;
#line 334
struct VP8Tokens ;
#line 334 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct VP8Tokens VP8Tokens;
#line 336 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct __anonstruct_155 {
   VP8Tokens *pages_ ;
   VP8Tokens **last_page_ ;
   uint16_t *tokens_ ;
   int left_ ;
   int error_ ;
};
#line 344 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct __anonstruct_155 VP8TBuffer;
#line 369 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct VP8Encoder {
   WebPConfig *config_ ;
   WebPPicture *pic_ ;
   VP8FilterHeader filter_hdr_ ;
   VP8SegmentHeader segment_hdr_ ;
   int profile_ ;
   int mb_w_ ;
   int mb_h_ ;
   int preds_w_ ;
   int num_parts_ ;
   VP8BitWriter bw_ ;
   VP8BitWriter parts_[8] ;
   VP8TBuffer tokens_ ;
   int percent_ ;
   int has_alpha_ ;
   uint8_t *alpha_data_ ;
   uint32_t alpha_data_size_ ;
   WebPWorker alpha_worker_ ;
   int use_layer_ ;
   VP8BitWriter layer_bw_ ;
   uint8_t *layer_data_ ;
   size_t layer_data_size_ ;
   VP8SegmentInfo dqm_[4] ;
   int base_quant_ ;
   int alpha_ ;
   int uv_alpha_ ;
   int dq_y1_dc_ ;
   int dq_y2_dc_ ;
   int dq_y2_ac_ ;
   int dq_uv_dc_ ;
   int dq_uv_ac_ ;
   VP8Proba proba_ ;
   uint64_t sse_[4] ;
   uint64_t sse_count_ ;
   int coded_size_ ;
   int residual_bytes_[3][4] ;
   int block_count_[3] ;
   int method_ ;
   VP8RDLevel rd_opt_level_ ;
   int max_i4_header_bits_ ;
   int thread_level_ ;
   int do_search_ ;
   int use_tokens_ ;
   VP8MBInfo *mb_info_ ;
   uint8_t *preds_ ;
   uint32_t *nz_ ;
   uint8_t *yuv_in_ ;
   uint8_t *yuv_out_ ;
   uint8_t *yuv_out2_ ;
   uint8_t *yuv_p_ ;
   uint8_t *y_top_ ;
   uint8_t *uv_top_ ;
   uint8_t *y_left_ ;
   uint8_t *u_left_ ;
   uint8_t *v_left_ ;
   LFStats *lf_stats_ ;
};
#line 527 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
struct __anonstruct_156 {
   double w ;
   double xm ;
   double ym ;
   double xxm ;
   double xym ;
   double yym ;
};
#line 529 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
typedef struct __anonstruct_156 DistoStats;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_158 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_157 {
   int __count ;
   union __anonunion_158 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_157 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 101 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
enum Mode {
    kLiteral = 0,
    kCacheIdx = 1,
    kCopy = 2,
    kNone = 3
} ;
#line 108 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
struct __anonstruct_160 {
   uint8_t mode ;
   uint16_t len ;
   uint32_t argb_or_distance ;
};
#line 113 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
typedef struct __anonstruct_160 PixOrCopy;
#line 183 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
struct __anonstruct_161 {
   PixOrCopy *refs ;
   int size ;
   int max_size ;
};
#line 187 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
typedef struct __anonstruct_161 VP8LBackwardRefs;
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/enc/././histogram.h"
struct __anonstruct_162 {
   int literal_[792] ;
   int red_[256] ;
   int blue_[256] ;
   int alpha_[256] ;
   int distance_[40] ;
   int palette_code_bits_ ;
   double bit_cost_ ;
};
#line 41 "/doner/libwebp/libwebp-v0.3.0/src/enc/././histogram.h"
typedef struct __anonstruct_162 VP8LHistogram;
#line 45 "/doner/libwebp/libwebp-v0.3.0/src/enc/././histogram.h"
struct __anonstruct_163 {
   int size ;
   int max_size ;
   VP8LHistogram **histograms ;
};
#line 49 "/doner/libwebp/libwebp-v0.3.0/src/enc/././histogram.h"
typedef struct __anonstruct_163 VP8LHistogramSet;
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8li.h"
struct __anonstruct_164 {
   WebPConfig *config_ ;
   WebPPicture *pic_ ;
   uint32_t *argb_ ;
   uint32_t *argb_scratch_ ;
   uint32_t *transform_data_ ;
   int current_width_ ;
   int histo_bits_ ;
   int transform_bits_ ;
   int cache_bits_ ;
   int use_cross_color_ ;
   int use_subtract_green_ ;
   int use_predict_ ;
   int use_palette_ ;
   int palette_size_ ;
   uint32_t palette_[256] ;
};
#line 46 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8li.h"
typedef struct __anonstruct_164 VP8LEncoder;
#line 33 "/usr/include/pthread.h"
enum __anonenum__194 {
    PTHREAD_CREATE_JOINABLE___1 = 0,
    PTHREAD_CREATE_DETACHED___1 = 1
} ;
#line 43
enum __anonenum__195 {
    PTHREAD_MUTEX_TIMED_NP___1 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___1 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___1 = 3,
    PTHREAD_MUTEX_NORMAL___1 = 0,
    PTHREAD_MUTEX_RECURSIVE___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK___1 = 2,
    PTHREAD_MUTEX_DEFAULT___1 = 0
} ;
#line 65
enum __anonenum__196 {
    PTHREAD_MUTEX_STALLED___1 = 0,
    PTHREAD_MUTEX_STALLED_NP___1 = 0,
    PTHREAD_MUTEX_ROBUST___1 = 1,
    PTHREAD_MUTEX_ROBUST_NP___1 = 1
} ;
#line 77
enum __anonenum__197 {
    PTHREAD_PRIO_NONE___1 = 0,
    PTHREAD_PRIO_INHERIT___1 = 1,
    PTHREAD_PRIO_PROTECT___1 = 2
} ;
#line 100
enum __anonenum__198 {
    PTHREAD_RWLOCK_PREFER_READER_NP___1 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___1 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___1 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___1 = 0
} ;
#line 120
enum __anonenum__199 {
    PTHREAD_INHERIT_SCHED___1 = 0,
    PTHREAD_EXPLICIT_SCHED___1 = 1
} ;
#line 130
enum __anonenum__200 {
    PTHREAD_SCOPE_SYSTEM___1 = 0,
    PTHREAD_SCOPE_PROCESS___1 = 1
} ;
#line 140
enum __anonenum__201 {
    PTHREAD_PROCESS_PRIVATE___1 = 0,
    PTHREAD_PROCESS_SHARED___1 = 1
} ;
#line 164
enum __anonenum__202 {
    PTHREAD_CANCEL_ENABLE___1 = 0,
    PTHREAD_CANCEL_DISABLE___1 = 1
} ;
#line 171
enum __anonenum__203 {
    PTHREAD_CANCEL_DEFERRED___1 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___1 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__208 {
    B_DC_PRED___0 = 0,
    B_TM_PRED___0 = 1,
    B_VE_PRED___0 = 2,
    B_HE_PRED___0 = 3,
    B_RD_PRED___0 = 4,
    B_VR_PRED___0 = 5,
    B_LD_PRED___0 = 6,
    B_VL_PRED___0 = 7,
    B_HD_PRED___0 = 8,
    B_HU_PRED___0 = 9,
    NUM_BMODES___0 = 10,
    DC_PRED___0 = 0,
    V_PRED___0 = 2,
    H_PRED___0 = 3,
    TM_PRED___0 = 1,
    NUM_PRED_MODES___0 = 4
} ;
#line 52
enum __anonenum__209 {
    NUM_MB_SEGMENTS___0 = 4,
    MAX_NUM_PARTITIONS___0 = 8,
    NUM_TYPES___0 = 4,
    NUM_BANDS___0 = 8,
    NUM_CTX___0 = 3,
    NUM_PROBAS___0 = 11,
    MAX_LF_LEVELS___0 = 64,
    MAX_VARIABLE_LEVEL___0 = 67,
    MAX_LEVEL___0 = 2047
} ;
#line 23 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
struct WebPRGBABuffer ;
#line 23 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
typedef struct WebPRGBABuffer WebPRGBABuffer;
#line 24
struct WebPYUVABuffer ;
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
typedef struct WebPYUVABuffer WebPYUVABuffer;
#line 25
struct WebPDecBuffer ;
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
typedef struct WebPDecBuffer WebPDecBuffer;
#line 27
enum VP8StatusCode {
    VP8_STATUS_OK = 0,
    VP8_STATUS_OUT_OF_MEMORY = 1,
    VP8_STATUS_INVALID_PARAM = 2,
    VP8_STATUS_BITSTREAM_ERROR = 3,
    VP8_STATUS_UNSUPPORTED_FEATURE = 4,
    VP8_STATUS_SUSPENDED = 5,
    VP8_STATUS_USER_ABORT = 6,
    VP8_STATUS_NOT_ENOUGH_DATA = 7
} ;
#line 27 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
typedef enum VP8StatusCode VP8StatusCode;
#line 28
enum WEBP_CSP_MODE {
    MODE_RGB = 0,
    MODE_RGBA = 1,
    MODE_BGR = 2,
    MODE_BGRA = 3,
    MODE_ARGB = 4,
    MODE_RGBA_4444 = 5,
    MODE_RGB_565 = 6,
    MODE_rgbA = 7,
    MODE_bgrA = 8,
    MODE_Argb = 9,
    MODE_rgbA_4444 = 10,
    MODE_YUV = 11,
    MODE_YUVA = 12,
    MODE_LAST = 13
} ;
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
typedef enum WEBP_CSP_MODE WEBP_CSP_MODE;
#line 30
struct WebPIDecoder ;
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
typedef struct WebPIDecoder WebPIDecoder;
#line 31
struct WebPBitstreamFeatures ;
#line 31 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
typedef struct WebPBitstreamFeatures WebPBitstreamFeatures;
#line 32
struct WebPDecoderOptions ;
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
typedef struct WebPDecoderOptions WebPDecoderOptions;
#line 33
struct WebPDecoderConfig ;
#line 33 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
typedef struct WebPDecoderConfig WebPDecoderConfig;
#line 141
enum WEBP_CSP_MODE___0 {
    MODE_RGB___0 = 0,
    MODE_RGBA___0 = 1,
    MODE_BGR___0 = 2,
    MODE_BGRA___0 = 3,
    MODE_ARGB___0 = 4,
    MODE_RGBA_4444___0 = 5,
    MODE_RGB_565___0 = 6,
    MODE_rgbA___0 = 7,
    MODE_bgrA___0 = 8,
    MODE_Argb___0 = 9,
    MODE_rgbA_4444___0 = 10,
    MODE_YUV___0 = 11,
    MODE_YUVA___0 = 12,
    MODE_LAST___0 = 13
} ;
#line 175 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
struct WebPRGBABuffer {
   uint8_t *rgba ;
   int stride ;
   size_t size ;
};
#line 181 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
struct WebPYUVABuffer {
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   uint8_t *a ;
   int y_stride ;
   int u_stride ;
   int v_stride ;
   int a_stride ;
   size_t y_size ;
   size_t u_size ;
   size_t v_size ;
   size_t a_size ;
};
#line 196 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
union __anonunion_223 {
   WebPRGBABuffer RGBA ;
   WebPYUVABuffer YUVA ;
};
#line 192 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
struct WebPDecBuffer {
   enum WEBP_CSP_MODE___0 colorspace ;
   int width ;
   int height ;
   int is_external_memory ;
   union __anonunion_223 u ;
   uint32_t pad[4] ;
   uint8_t *private_memory ;
};
#line 223
enum VP8StatusCode___0 {
    VP8_STATUS_OK___0 = 0,
    VP8_STATUS_OUT_OF_MEMORY___0 = 1,
    VP8_STATUS_INVALID_PARAM___0 = 2,
    VP8_STATUS_BITSTREAM_ERROR___0 = 3,
    VP8_STATUS_UNSUPPORTED_FEATURE___0 = 4,
    VP8_STATUS_SUSPENDED___0 = 5,
    VP8_STATUS_USER_ABORT___0 = 6,
    VP8_STATUS_NOT_ENOUGH_DATA___0 = 7
} ;
#line 394 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
struct WebPBitstreamFeatures {
   int width ;
   int height ;
   int has_alpha ;
   int has_animation ;
   int bitstream_version ;
   int no_incremental_decoding ;
   int rotate ;
   int uv_sampling ;
   uint32_t pad[2] ;
};
#line 426 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
struct WebPDecoderOptions {
   int bypass_filtering ;
   int no_fancy_upsampling ;
   int use_cropping ;
   int crop_left ;
   int crop_top ;
   int crop_width ;
   int crop_height ;
   int use_scaling ;
   int scaled_width ;
   int scaled_height ;
   int use_threads ;
   int force_rotation ;
   int no_enhancement ;
   uint32_t pad[6] ;
};
#line 444 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
struct WebPDecoderConfig {
   WebPBitstreamFeatures input ;
   WebPDecBuffer output ;
   WebPDecoderOptions options ;
};
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/lossless.h"
struct VP8LTransform ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__244 {
    PTHREAD_CREATE_JOINABLE___2 = 0,
    PTHREAD_CREATE_DETACHED___2 = 1
} ;
#line 43
enum __anonenum__245 {
    PTHREAD_MUTEX_TIMED_NP___2 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___2 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___2 = 3,
    PTHREAD_MUTEX_NORMAL___2 = 0,
    PTHREAD_MUTEX_RECURSIVE___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK___2 = 2,
    PTHREAD_MUTEX_DEFAULT___2 = 0
} ;
#line 65
enum __anonenum__246 {
    PTHREAD_MUTEX_STALLED___2 = 0,
    PTHREAD_MUTEX_STALLED_NP___2 = 0,
    PTHREAD_MUTEX_ROBUST___2 = 1,
    PTHREAD_MUTEX_ROBUST_NP___2 = 1
} ;
#line 77
enum __anonenum__247 {
    PTHREAD_PRIO_NONE___2 = 0,
    PTHREAD_PRIO_INHERIT___2 = 1,
    PTHREAD_PRIO_PROTECT___2 = 2
} ;
#line 100
enum __anonenum__248 {
    PTHREAD_RWLOCK_PREFER_READER_NP___2 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___2 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___2 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___2 = 0
} ;
#line 120
enum __anonenum__249 {
    PTHREAD_INHERIT_SCHED___2 = 0,
    PTHREAD_EXPLICIT_SCHED___2 = 1
} ;
#line 130
enum __anonenum__250 {
    PTHREAD_SCOPE_SYSTEM___2 = 0,
    PTHREAD_SCOPE_PROCESS___2 = 1
} ;
#line 140
enum __anonenum__251 {
    PTHREAD_PROCESS_PRIVATE___2 = 0,
    PTHREAD_PROCESS_SHARED___2 = 1
} ;
#line 164
enum __anonenum__252 {
    PTHREAD_CANCEL_ENABLE___2 = 0,
    PTHREAD_CANCEL_DISABLE___2 = 1
} ;
#line 171
enum __anonenum__253 {
    PTHREAD_CANCEL_DEFERRED___2 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___2 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__258 {
    B_DC_PRED___1 = 0,
    B_TM_PRED___1 = 1,
    B_VE_PRED___1 = 2,
    B_HE_PRED___1 = 3,
    B_RD_PRED___1 = 4,
    B_VR_PRED___1 = 5,
    B_LD_PRED___1 = 6,
    B_VL_PRED___1 = 7,
    B_HD_PRED___1 = 8,
    B_HU_PRED___1 = 9,
    NUM_BMODES___1 = 10,
    DC_PRED___1 = 0,
    V_PRED___1 = 2,
    H_PRED___1 = 3,
    TM_PRED___1 = 1,
    NUM_PRED_MODES___1 = 4
} ;
#line 52
enum __anonenum__259 {
    NUM_MB_SEGMENTS___1 = 4,
    MAX_NUM_PARTITIONS___1 = 8,
    NUM_TYPES___1 = 4,
    NUM_BANDS___1 = 8,
    NUM_CTX___1 = 3,
    NUM_PROBAS___1 = 11,
    MAX_LF_LEVELS___1 = 64,
    MAX_VARIABLE_LEVEL___1 = 67,
    MAX_LEVEL___1 = 2047
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__273 {
    PTHREAD_CREATE_JOINABLE___3 = 0,
    PTHREAD_CREATE_DETACHED___3 = 1
} ;
#line 43
enum __anonenum__274 {
    PTHREAD_MUTEX_TIMED_NP___3 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___3 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___3 = 3,
    PTHREAD_MUTEX_NORMAL___3 = 0,
    PTHREAD_MUTEX_RECURSIVE___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK___3 = 2,
    PTHREAD_MUTEX_DEFAULT___3 = 0
} ;
#line 65
enum __anonenum__275 {
    PTHREAD_MUTEX_STALLED___3 = 0,
    PTHREAD_MUTEX_STALLED_NP___3 = 0,
    PTHREAD_MUTEX_ROBUST___3 = 1,
    PTHREAD_MUTEX_ROBUST_NP___3 = 1
} ;
#line 77
enum __anonenum__276 {
    PTHREAD_PRIO_NONE___3 = 0,
    PTHREAD_PRIO_INHERIT___3 = 1,
    PTHREAD_PRIO_PROTECT___3 = 2
} ;
#line 100
enum __anonenum__277 {
    PTHREAD_RWLOCK_PREFER_READER_NP___3 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___3 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___3 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___3 = 0
} ;
#line 120
enum __anonenum__278 {
    PTHREAD_INHERIT_SCHED___3 = 0,
    PTHREAD_EXPLICIT_SCHED___3 = 1
} ;
#line 130
enum __anonenum__279 {
    PTHREAD_SCOPE_SYSTEM___3 = 0,
    PTHREAD_SCOPE_PROCESS___3 = 1
} ;
#line 140
enum __anonenum__280 {
    PTHREAD_PROCESS_PRIVATE___3 = 0,
    PTHREAD_PROCESS_SHARED___3 = 1
} ;
#line 164
enum __anonenum__281 {
    PTHREAD_CANCEL_ENABLE___3 = 0,
    PTHREAD_CANCEL_DISABLE___3 = 1
} ;
#line 171
enum __anonenum__282 {
    PTHREAD_CANCEL_DEFERRED___3 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___3 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__287 {
    B_DC_PRED___2 = 0,
    B_TM_PRED___2 = 1,
    B_VE_PRED___2 = 2,
    B_HE_PRED___2 = 3,
    B_RD_PRED___2 = 4,
    B_VR_PRED___2 = 5,
    B_LD_PRED___2 = 6,
    B_VL_PRED___2 = 7,
    B_HD_PRED___2 = 8,
    B_HU_PRED___2 = 9,
    NUM_BMODES___2 = 10,
    DC_PRED___2 = 0,
    V_PRED___2 = 2,
    H_PRED___2 = 3,
    TM_PRED___2 = 1,
    NUM_PRED_MODES___2 = 4
} ;
#line 52
enum __anonenum__288 {
    NUM_MB_SEGMENTS___2 = 4,
    MAX_NUM_PARTITIONS___2 = 8,
    NUM_TYPES___2 = 4,
    NUM_BANDS___2 = 8,
    NUM_CTX___2 = 3,
    NUM_PROBAS___2 = 11,
    MAX_LF_LEVELS___2 = 64,
    MAX_VARIABLE_LEVEL___2 = 67,
    MAX_LEVEL___2 = 2047
} ;
#line 33 "/doner/libwebp/libwebp-v0.3.0/src/enc/token.c"
struct VP8Tokens {
   uint16_t tokens_[8192] ;
   VP8Tokens *next_ ;
};
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/enc/../webp/mux_types.h"
enum WebPFeatureFlags {
    FRAGMENTS_FLAG = 1,
    ANIMATION_FLAG = 2,
    XMP_FLAG = 4,
    EXIF_FLAG = 8,
    ALPHA_FLAG = 16,
    ICCP_FLAG = 32
} ;
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/enc/../webp/mux_types.h"
typedef enum WebPFeatureFlags WebPFeatureFlags;
#line 25
enum WebPMuxAnimDispose {
    WEBP_MUX_DISPOSE_NONE = 0,
    WEBP_MUX_DISPOSE_BACKGROUND = 1
} ;
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/enc/../webp/mux_types.h"
typedef enum WebPMuxAnimDispose WebPMuxAnimDispose;
#line 29
enum WebPFeatureFlags___0 {
    FRAGMENTS_FLAG___0 = 1,
    ANIMATION_FLAG___0 = 2,
    XMP_FLAG___0 = 4,
    EXIF_FLAG___0 = 8,
    ALPHA_FLAG___0 = 16,
    ICCP_FLAG___0 = 32
} ;
#line 40
enum WebPMuxAnimDispose___0 {
    WEBP_MUX_DISPOSE_NONE___0 = 0,
    WEBP_MUX_DISPOSE_BACKGROUND___0 = 1
} ;
#line 47
struct WebPData ;
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/enc/../webp/mux_types.h"
typedef struct WebPData WebPData;
#line 48 "/doner/libwebp/libwebp-v0.3.0/src/enc/../webp/mux_types.h"
struct WebPData {
   uint8_t *bytes ;
   size_t size ;
};
#line 33 "/usr/include/pthread.h"
enum __anonenum__324 {
    PTHREAD_CREATE_JOINABLE___4 = 0,
    PTHREAD_CREATE_DETACHED___4 = 1
} ;
#line 43
enum __anonenum__325 {
    PTHREAD_MUTEX_TIMED_NP___4 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___4 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___4 = 3,
    PTHREAD_MUTEX_NORMAL___4 = 0,
    PTHREAD_MUTEX_RECURSIVE___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK___4 = 2,
    PTHREAD_MUTEX_DEFAULT___4 = 0
} ;
#line 65
enum __anonenum__326 {
    PTHREAD_MUTEX_STALLED___4 = 0,
    PTHREAD_MUTEX_STALLED_NP___4 = 0,
    PTHREAD_MUTEX_ROBUST___4 = 1,
    PTHREAD_MUTEX_ROBUST_NP___4 = 1
} ;
#line 77
enum __anonenum__327 {
    PTHREAD_PRIO_NONE___4 = 0,
    PTHREAD_PRIO_INHERIT___4 = 1,
    PTHREAD_PRIO_PROTECT___4 = 2
} ;
#line 100
enum __anonenum__328 {
    PTHREAD_RWLOCK_PREFER_READER_NP___4 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___4 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___4 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___4 = 0
} ;
#line 120
enum __anonenum__329 {
    PTHREAD_INHERIT_SCHED___4 = 0,
    PTHREAD_EXPLICIT_SCHED___4 = 1
} ;
#line 130
enum __anonenum__330 {
    PTHREAD_SCOPE_SYSTEM___4 = 0,
    PTHREAD_SCOPE_PROCESS___4 = 1
} ;
#line 140
enum __anonenum__331 {
    PTHREAD_PROCESS_PRIVATE___4 = 0,
    PTHREAD_PROCESS_SHARED___4 = 1
} ;
#line 164
enum __anonenum__332 {
    PTHREAD_CANCEL_ENABLE___4 = 0,
    PTHREAD_CANCEL_DISABLE___4 = 1
} ;
#line 171
enum __anonenum__333 {
    PTHREAD_CANCEL_DEFERRED___4 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___4 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__338 {
    B_DC_PRED___3 = 0,
    B_TM_PRED___3 = 1,
    B_VE_PRED___3 = 2,
    B_HE_PRED___3 = 3,
    B_RD_PRED___3 = 4,
    B_VR_PRED___3 = 5,
    B_LD_PRED___3 = 6,
    B_VL_PRED___3 = 7,
    B_HD_PRED___3 = 8,
    B_HU_PRED___3 = 9,
    NUM_BMODES___3 = 10,
    DC_PRED___3 = 0,
    V_PRED___3 = 2,
    H_PRED___3 = 3,
    TM_PRED___3 = 1,
    NUM_PRED_MODES___3 = 4
} ;
#line 52
enum __anonenum__339 {
    NUM_MB_SEGMENTS___3 = 4,
    MAX_NUM_PARTITIONS___3 = 8,
    NUM_TYPES___3 = 4,
    NUM_BANDS___3 = 8,
    NUM_CTX___3 = 3,
    NUM_PROBAS___3 = 11,
    MAX_LF_LEVELS___3 = 64,
    MAX_VARIABLE_LEVEL___3 = 67,
    MAX_LEVEL___3 = 2047
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__351 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__369 {
    PTHREAD_CREATE_JOINABLE___5 = 0,
    PTHREAD_CREATE_DETACHED___5 = 1
} ;
#line 43
enum __anonenum__370 {
    PTHREAD_MUTEX_TIMED_NP___5 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___5 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___5 = 3,
    PTHREAD_MUTEX_NORMAL___5 = 0,
    PTHREAD_MUTEX_RECURSIVE___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK___5 = 2,
    PTHREAD_MUTEX_DEFAULT___5 = 0
} ;
#line 65
enum __anonenum__371 {
    PTHREAD_MUTEX_STALLED___5 = 0,
    PTHREAD_MUTEX_STALLED_NP___5 = 0,
    PTHREAD_MUTEX_ROBUST___5 = 1,
    PTHREAD_MUTEX_ROBUST_NP___5 = 1
} ;
#line 77
enum __anonenum__372 {
    PTHREAD_PRIO_NONE___5 = 0,
    PTHREAD_PRIO_INHERIT___5 = 1,
    PTHREAD_PRIO_PROTECT___5 = 2
} ;
#line 100
enum __anonenum__373 {
    PTHREAD_RWLOCK_PREFER_READER_NP___5 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___5 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___5 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___5 = 0
} ;
#line 120
enum __anonenum__374 {
    PTHREAD_INHERIT_SCHED___5 = 0,
    PTHREAD_EXPLICIT_SCHED___5 = 1
} ;
#line 130
enum __anonenum__375 {
    PTHREAD_SCOPE_SYSTEM___5 = 0,
    PTHREAD_SCOPE_PROCESS___5 = 1
} ;
#line 140
enum __anonenum__376 {
    PTHREAD_PROCESS_PRIVATE___5 = 0,
    PTHREAD_PROCESS_SHARED___5 = 1
} ;
#line 164
enum __anonenum__377 {
    PTHREAD_CANCEL_ENABLE___5 = 0,
    PTHREAD_CANCEL_DISABLE___5 = 1
} ;
#line 171
enum __anonenum__199___0 {
    PTHREAD_CANCEL_DEFERRED___5 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___5 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__382 {
    B_DC_PRED___4 = 0,
    B_TM_PRED___4 = 1,
    B_VE_PRED___4 = 2,
    B_HE_PRED___4 = 3,
    B_RD_PRED___4 = 4,
    B_VR_PRED___4 = 5,
    B_LD_PRED___4 = 6,
    B_VL_PRED___4 = 7,
    B_HD_PRED___4 = 8,
    B_HU_PRED___4 = 9,
    NUM_BMODES___4 = 10,
    DC_PRED___4 = 0,
    V_PRED___4 = 2,
    H_PRED___4 = 3,
    TM_PRED___4 = 1,
    NUM_PRED_MODES___4 = 4
} ;
#line 52
enum __anonenum__383 {
    NUM_MB_SEGMENTS___4 = 4,
    MAX_NUM_PARTITIONS___4 = 8,
    NUM_TYPES___4 = 4,
    NUM_BANDS___4 = 8,
    NUM_CTX___4 = 3,
    NUM_PROBAS___4 = 11,
    MAX_LF_LEVELS___4 = 64,
    MAX_VARIABLE_LEVEL___4 = 67,
    MAX_LEVEL___4 = 2047
} ;
#line 458 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
struct __anonstruct_394 {
   int prev ;
   int level ;
   int sign ;
   score_t cost ;
   score_t error ;
   int ctx ;
};
#line 465 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
typedef struct __anonstruct_394 Node;
#line 853 "/usr/include/math.h"
enum __anonenum__395 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__401 {
    PTHREAD_CREATE_JOINABLE___6 = 0,
    PTHREAD_CREATE_DETACHED___6 = 1
} ;
#line 43
enum __anonenum__402 {
    PTHREAD_MUTEX_TIMED_NP___6 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___6 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___6 = 3,
    PTHREAD_MUTEX_NORMAL___6 = 0,
    PTHREAD_MUTEX_RECURSIVE___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK___6 = 2,
    PTHREAD_MUTEX_DEFAULT___6 = 0
} ;
#line 65
enum __anonenum__403 {
    PTHREAD_MUTEX_STALLED___6 = 0,
    PTHREAD_MUTEX_STALLED_NP___6 = 0,
    PTHREAD_MUTEX_ROBUST___6 = 1,
    PTHREAD_MUTEX_ROBUST_NP___6 = 1
} ;
#line 77
enum __anonenum__404 {
    PTHREAD_PRIO_NONE___6 = 0,
    PTHREAD_PRIO_INHERIT___6 = 1,
    PTHREAD_PRIO_PROTECT___6 = 2
} ;
#line 100
enum __anonenum__405 {
    PTHREAD_RWLOCK_PREFER_READER_NP___6 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___6 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___6 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___6 = 0
} ;
#line 120
enum __anonenum__406 {
    PTHREAD_INHERIT_SCHED___6 = 0,
    PTHREAD_EXPLICIT_SCHED___6 = 1
} ;
#line 130
enum __anonenum__407 {
    PTHREAD_SCOPE_SYSTEM___6 = 0,
    PTHREAD_SCOPE_PROCESS___6 = 1
} ;
#line 140
enum __anonenum__408 {
    PTHREAD_PROCESS_PRIVATE___6 = 0,
    PTHREAD_PROCESS_SHARED___6 = 1
} ;
#line 164
enum __anonenum__409 {
    PTHREAD_CANCEL_ENABLE___6 = 0,
    PTHREAD_CANCEL_DISABLE___6 = 1
} ;
#line 171
enum __anonenum__139___0 {
    PTHREAD_CANCEL_DEFERRED___6 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___6 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__414 {
    B_DC_PRED___5 = 0,
    B_TM_PRED___5 = 1,
    B_VE_PRED___5 = 2,
    B_HE_PRED___5 = 3,
    B_RD_PRED___5 = 4,
    B_VR_PRED___5 = 5,
    B_LD_PRED___5 = 6,
    B_VL_PRED___5 = 7,
    B_HD_PRED___5 = 8,
    B_HU_PRED___5 = 9,
    NUM_BMODES___5 = 10,
    DC_PRED___5 = 0,
    V_PRED___5 = 2,
    H_PRED___5 = 3,
    TM_PRED___5 = 1,
    NUM_PRED_MODES___5 = 4
} ;
#line 52
enum __anonenum__415 {
    NUM_MB_SEGMENTS___5 = 4,
    MAX_NUM_PARTITIONS___5 = 8,
    NUM_TYPES___5 = 4,
    NUM_BANDS___5 = 8,
    NUM_CTX___5 = 3,
    NUM_PROBAS___5 = 11,
    MAX_LF_LEVELS___5 = 64,
    MAX_VARIABLE_LEVEL___5 = 67,
    MAX_LEVEL___5 = 2047
} ;
#line 40 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/decode_vp8.h"
struct VP8Io ;
#line 40 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/decode_vp8.h"
typedef struct VP8Io VP8Io;
#line 41 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/decode_vp8.h"
typedef int (*VP8IoPutHook)(VP8Io * );
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/decode_vp8.h"
typedef int (*VP8IoSetupHook)(VP8Io * );
#line 43 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/decode_vp8.h"
typedef void (*VP8IoTeardownHook)(VP8Io * );
#line 45 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/decode_vp8.h"
struct VP8Io {
   int width ;
   int height ;
   int mb_y ;
   int mb_w ;
   int mb_h ;
   uint8_t *y ;
   uint8_t *u ;
   uint8_t *v ;
   int y_stride ;
   int uv_stride ;
   void *opaque ;
   VP8IoPutHook put ;
   VP8IoSetupHook setup ;
   VP8IoTeardownHook teardown ;
   int fancy_upsampling ;
   size_t data_size ;
   uint8_t *data ;
   int bypass_filtering ;
   int use_cropping ;
   int crop_left ;
   int crop_right ;
   int crop_top ;
   int crop_bottom ;
   int use_scaling ;
   int scaled_width ;
   int scaled_height ;
   uint8_t *a ;
};
#line 121
struct VP8Decoder ;
#line 121 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/decode_vp8.h"
typedef struct VP8Decoder VP8Decoder;
#line 57 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
enum __anonenum__428 {
    YUV_FIX = 16,
    YUV_HALF = 32768,
    YUV_MASK = 16777215,
    YUV_RANGE_MIN = -227,
    YUV_RANGE_MAX = 482
} ;
#line 29 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
union __anonunion_429 {
   uint32_t argb ;
   uint8_t bytes[4] ;
};
#line 1049 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
typedef int (*Importer)(WebPPicture * const   , uint8_t * const   , int  );
#line 33 "/usr/include/pthread.h"
enum __anonenum__435 {
    PTHREAD_CREATE_JOINABLE___7 = 0,
    PTHREAD_CREATE_DETACHED___7 = 1
} ;
#line 43
enum __anonenum__436 {
    PTHREAD_MUTEX_TIMED_NP___7 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___7 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___7 = 3,
    PTHREAD_MUTEX_NORMAL___7 = 0,
    PTHREAD_MUTEX_RECURSIVE___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK___7 = 2,
    PTHREAD_MUTEX_DEFAULT___7 = 0
} ;
#line 65
enum __anonenum__437 {
    PTHREAD_MUTEX_STALLED___7 = 0,
    PTHREAD_MUTEX_STALLED_NP___7 = 0,
    PTHREAD_MUTEX_ROBUST___7 = 1,
    PTHREAD_MUTEX_ROBUST_NP___7 = 1
} ;
#line 77
enum __anonenum__438 {
    PTHREAD_PRIO_NONE___7 = 0,
    PTHREAD_PRIO_INHERIT___7 = 1,
    PTHREAD_PRIO_PROTECT___7 = 2
} ;
#line 100
enum __anonenum__439 {
    PTHREAD_RWLOCK_PREFER_READER_NP___7 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___7 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___7 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___7 = 0
} ;
#line 120
enum __anonenum__440 {
    PTHREAD_INHERIT_SCHED___7 = 0,
    PTHREAD_EXPLICIT_SCHED___7 = 1
} ;
#line 130
enum __anonenum__441 {
    PTHREAD_SCOPE_SYSTEM___7 = 0,
    PTHREAD_SCOPE_PROCESS___7 = 1
} ;
#line 140
enum __anonenum__442 {
    PTHREAD_PROCESS_PRIVATE___7 = 0,
    PTHREAD_PROCESS_SHARED___7 = 1
} ;
#line 164
enum __anonenum__443 {
    PTHREAD_CANCEL_ENABLE___7 = 0,
    PTHREAD_CANCEL_DISABLE___7 = 1
} ;
#line 171
enum __anonenum__444 {
    PTHREAD_CANCEL_DEFERRED___7 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___7 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonstruct_286 {
    B_DC_PRED___6 = 0,
    B_TM_PRED___6 = 1,
    B_VE_PRED___6 = 2,
    B_HE_PRED___6 = 3,
    B_RD_PRED___6 = 4,
    B_VR_PRED___6 = 5,
    B_LD_PRED___6 = 6,
    B_VL_PRED___6 = 7,
    B_HD_PRED___6 = 8,
    B_HU_PRED___6 = 9,
    NUM_BMODES___6 = 10,
    DC_PRED___6 = 0,
    V_PRED___6 = 2,
    H_PRED___6 = 3,
    TM_PRED___6 = 1,
    NUM_PRED_MODES___6 = 4
} ;
#line 52
enum __anonenum__449 {
    NUM_MB_SEGMENTS___6 = 4,
    MAX_NUM_PARTITIONS___6 = 8,
    NUM_TYPES___6 = 4,
    NUM_BANDS___6 = 8,
    NUM_CTX___6 = 3,
    NUM_PROBAS___6 = 11,
    MAX_LF_LEVELS___6 = 64,
    MAX_VARIABLE_LEVEL___6 = 67,
    MAX_LEVEL___6 = 2047
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__244___0 {
    PTHREAD_CREATE_JOINABLE___8 = 0,
    PTHREAD_CREATE_DETACHED___8 = 1
} ;
#line 43
enum __anonenum__245___0 {
    PTHREAD_MUTEX_TIMED_NP___8 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___8 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___8 = 3,
    PTHREAD_MUTEX_NORMAL___8 = 0,
    PTHREAD_MUTEX_RECURSIVE___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK___8 = 2,
    PTHREAD_MUTEX_DEFAULT___8 = 0
} ;
#line 65
enum __anonenum__246___0 {
    PTHREAD_MUTEX_STALLED___8 = 0,
    PTHREAD_MUTEX_STALLED_NP___8 = 0,
    PTHREAD_MUTEX_ROBUST___8 = 1,
    PTHREAD_MUTEX_ROBUST_NP___8 = 1
} ;
#line 77
enum __anonenum__247___0 {
    PTHREAD_PRIO_NONE___8 = 0,
    PTHREAD_PRIO_INHERIT___8 = 1,
    PTHREAD_PRIO_PROTECT___8 = 2
} ;
#line 100
enum __anonenum__248___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___8 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___8 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___8 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___8 = 0
} ;
#line 120
enum __anonenum__249___0 {
    PTHREAD_INHERIT_SCHED___8 = 0,
    PTHREAD_EXPLICIT_SCHED___8 = 1
} ;
#line 130
enum __anonenum__250___0 {
    PTHREAD_SCOPE_SYSTEM___8 = 0,
    PTHREAD_SCOPE_PROCESS___8 = 1
} ;
#line 140
enum __anonenum__251___0 {
    PTHREAD_PROCESS_PRIVATE___8 = 0,
    PTHREAD_PROCESS_SHARED___8 = 1
} ;
#line 164
enum __anonenum__252___0 {
    PTHREAD_CANCEL_ENABLE___8 = 0,
    PTHREAD_CANCEL_DISABLE___8 = 1
} ;
#line 171
enum __anonenum__253___0 {
    PTHREAD_CANCEL_DEFERRED___8 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___8 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__258___0 {
    B_DC_PRED___7 = 0,
    B_TM_PRED___7 = 1,
    B_VE_PRED___7 = 2,
    B_HE_PRED___7 = 3,
    B_RD_PRED___7 = 4,
    B_VR_PRED___7 = 5,
    B_LD_PRED___7 = 6,
    B_VL_PRED___7 = 7,
    B_HD_PRED___7 = 8,
    B_HU_PRED___7 = 9,
    NUM_BMODES___7 = 10,
    DC_PRED___7 = 0,
    V_PRED___7 = 2,
    H_PRED___7 = 3,
    TM_PRED___7 = 1,
    NUM_PRED_MODES___7 = 4
} ;
#line 52
enum __anonenum__259___0 {
    NUM_MB_SEGMENTS___7 = 4,
    MAX_NUM_PARTITIONS___7 = 8,
    NUM_TYPES___7 = 4,
    NUM_BANDS___7 = 8,
    NUM_CTX___7 = 3,
    NUM_PROBAS___7 = 11,
    MAX_LF_LEVELS___7 = 64,
    MAX_VARIABLE_LEVEL___7 = 67,
    MAX_LEVEL___7 = 2047
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__461 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 853
enum __anonenum__125___0 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__131___0 {
    PTHREAD_CREATE_JOINABLE___9 = 0,
    PTHREAD_CREATE_DETACHED___9 = 1
} ;
#line 43
enum __anonenum__132___0 {
    PTHREAD_MUTEX_TIMED_NP___9 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___9 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___9 = 3,
    PTHREAD_MUTEX_NORMAL___9 = 0,
    PTHREAD_MUTEX_RECURSIVE___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK___9 = 2,
    PTHREAD_MUTEX_DEFAULT___9 = 0
} ;
#line 65
enum __anonenum__133___0 {
    PTHREAD_MUTEX_STALLED___9 = 0,
    PTHREAD_MUTEX_STALLED_NP___9 = 0,
    PTHREAD_MUTEX_ROBUST___9 = 1,
    PTHREAD_MUTEX_ROBUST_NP___9 = 1
} ;
#line 77
enum __anonenum__134___0 {
    PTHREAD_PRIO_NONE___9 = 0,
    PTHREAD_PRIO_INHERIT___9 = 1,
    PTHREAD_PRIO_PROTECT___9 = 2
} ;
#line 100
enum __anonenum__135___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___9 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___9 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___9 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___9 = 0
} ;
#line 120
enum __anonenum__136___0 {
    PTHREAD_INHERIT_SCHED___9 = 0,
    PTHREAD_EXPLICIT_SCHED___9 = 1
} ;
#line 130
enum __anonenum__137___0 {
    PTHREAD_SCOPE_SYSTEM___9 = 0,
    PTHREAD_SCOPE_PROCESS___9 = 1
} ;
#line 140
enum __anonenum__138___0 {
    PTHREAD_PROCESS_PRIVATE___9 = 0,
    PTHREAD_PROCESS_SHARED___9 = 1
} ;
#line 164
enum __anonenum__139___1 {
    PTHREAD_CANCEL_ENABLE___9 = 0,
    PTHREAD_CANCEL_DISABLE___9 = 1
} ;
#line 171
enum __anonenum__140___0 {
    PTHREAD_CANCEL_DEFERRED___9 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___9 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__145___0 {
    B_DC_PRED___8 = 0,
    B_TM_PRED___8 = 1,
    B_VE_PRED___8 = 2,
    B_HE_PRED___8 = 3,
    B_RD_PRED___8 = 4,
    B_VR_PRED___8 = 5,
    B_LD_PRED___8 = 6,
    B_VL_PRED___8 = 7,
    B_HD_PRED___8 = 8,
    B_HU_PRED___8 = 9,
    NUM_BMODES___8 = 10,
    DC_PRED___8 = 0,
    V_PRED___8 = 2,
    H_PRED___8 = 3,
    TM_PRED___8 = 1,
    NUM_PRED_MODES___8 = 4
} ;
#line 52
enum __anonenum__146___0 {
    NUM_MB_SEGMENTS___8 = 4,
    MAX_NUM_PARTITIONS___8 = 8,
    NUM_TYPES___8 = 4,
    NUM_BANDS___8 = 8,
    NUM_CTX___8 = 3,
    NUM_PROBAS___8 = 11,
    MAX_LF_LEVELS___8 = 64,
    MAX_VARIABLE_LEVEL___8 = 67,
    MAX_LEVEL___8 = 2047
} ;
#line 29 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
struct __anonstruct_490 {
   int first ;
   int last ;
   int16_t *coeffs ;
   int coeff_type ;
   ProbaArray *prob ;
   StatsArray *stats ;
   CostArray *cost ;
};
#line 38 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
typedef struct __anonstruct_490 VP8Residual;
#line 33 "/usr/include/pthread.h"
enum __anonenum__244___1 {
    PTHREAD_CREATE_JOINABLE___10 = 0,
    PTHREAD_CREATE_DETACHED___10 = 1
} ;
#line 43
enum __anonenum__245___1 {
    PTHREAD_MUTEX_TIMED_NP___10 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___10 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___10 = 3,
    PTHREAD_MUTEX_NORMAL___10 = 0,
    PTHREAD_MUTEX_RECURSIVE___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK___10 = 2,
    PTHREAD_MUTEX_DEFAULT___10 = 0
} ;
#line 65
enum __anonenum__246___1 {
    PTHREAD_MUTEX_STALLED___10 = 0,
    PTHREAD_MUTEX_STALLED_NP___10 = 0,
    PTHREAD_MUTEX_ROBUST___10 = 1,
    PTHREAD_MUTEX_ROBUST_NP___10 = 1
} ;
#line 77
enum __anonenum__247___1 {
    PTHREAD_PRIO_NONE___10 = 0,
    PTHREAD_PRIO_INHERIT___10 = 1,
    PTHREAD_PRIO_PROTECT___10 = 2
} ;
#line 100
enum __anonenum__248___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___10 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___10 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___10 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___10 = 0
} ;
#line 120
enum __anonenum__249___1 {
    PTHREAD_INHERIT_SCHED___10 = 0,
    PTHREAD_EXPLICIT_SCHED___10 = 1
} ;
#line 130
enum __anonenum__250___1 {
    PTHREAD_SCOPE_SYSTEM___10 = 0,
    PTHREAD_SCOPE_PROCESS___10 = 1
} ;
#line 140
enum __anonenum__251___1 {
    PTHREAD_PROCESS_PRIVATE___10 = 0,
    PTHREAD_PROCESS_SHARED___10 = 1
} ;
#line 164
enum __anonenum__252___1 {
    PTHREAD_CANCEL_ENABLE___10 = 0,
    PTHREAD_CANCEL_DISABLE___10 = 1
} ;
#line 171
enum __anonenum__253___1 {
    PTHREAD_CANCEL_DEFERRED___10 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___10 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__258___1 {
    B_DC_PRED___9 = 0,
    B_TM_PRED___9 = 1,
    B_VE_PRED___9 = 2,
    B_HE_PRED___9 = 3,
    B_RD_PRED___9 = 4,
    B_VR_PRED___9 = 5,
    B_LD_PRED___9 = 6,
    B_VL_PRED___9 = 7,
    B_HD_PRED___9 = 8,
    B_HU_PRED___9 = 9,
    NUM_BMODES___9 = 10,
    DC_PRED___9 = 0,
    V_PRED___9 = 2,
    H_PRED___9 = 3,
    TM_PRED___9 = 1,
    NUM_PRED_MODES___9 = 4
} ;
#line 52
enum __anonenum__259___1 {
    NUM_MB_SEGMENTS___9 = 4,
    MAX_NUM_PARTITIONS___9 = 8,
    NUM_TYPES___9 = 4,
    NUM_BANDS___9 = 8,
    NUM_CTX___9 = 3,
    NUM_PROBAS___9 = 11,
    MAX_LF_LEVELS___9 = 64,
    MAX_VARIABLE_LEVEL___9 = 67,
    MAX_LEVEL___9 = 2047
} ;
#line 236 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
enum __anonenum__491 {
    KERNEL = 3
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__244___2 {
    PTHREAD_CREATE_JOINABLE___11 = 0,
    PTHREAD_CREATE_DETACHED___11 = 1
} ;
#line 43
enum __anonenum__245___2 {
    PTHREAD_MUTEX_TIMED_NP___11 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___11 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___11 = 3,
    PTHREAD_MUTEX_NORMAL___11 = 0,
    PTHREAD_MUTEX_RECURSIVE___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK___11 = 2,
    PTHREAD_MUTEX_DEFAULT___11 = 0
} ;
#line 65
enum __anonenum__246___2 {
    PTHREAD_MUTEX_STALLED___11 = 0,
    PTHREAD_MUTEX_STALLED_NP___11 = 0,
    PTHREAD_MUTEX_ROBUST___11 = 1,
    PTHREAD_MUTEX_ROBUST_NP___11 = 1
} ;
#line 77
enum __anonenum__247___2 {
    PTHREAD_PRIO_NONE___11 = 0,
    PTHREAD_PRIO_INHERIT___11 = 1,
    PTHREAD_PRIO_PROTECT___11 = 2
} ;
#line 100
enum __anonenum__248___2 {
    PTHREAD_RWLOCK_PREFER_READER_NP___11 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___11 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___11 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___11 = 0
} ;
#line 120
enum __anonenum__249___2 {
    PTHREAD_INHERIT_SCHED___11 = 0,
    PTHREAD_EXPLICIT_SCHED___11 = 1
} ;
#line 130
enum __anonenum__250___2 {
    PTHREAD_SCOPE_SYSTEM___11 = 0,
    PTHREAD_SCOPE_PROCESS___11 = 1
} ;
#line 140
enum __anonenum__251___2 {
    PTHREAD_PROCESS_PRIVATE___11 = 0,
    PTHREAD_PROCESS_SHARED___11 = 1
} ;
#line 164
enum __anonenum__252___2 {
    PTHREAD_CANCEL_ENABLE___11 = 0,
    PTHREAD_CANCEL_DISABLE___11 = 1
} ;
#line 171
enum __anonenum__253___2 {
    PTHREAD_CANCEL_DEFERRED___11 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___11 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/././vp8enci.h"
enum __anonenum__258___2 {
    B_DC_PRED___10 = 0,
    B_TM_PRED___10 = 1,
    B_VE_PRED___10 = 2,
    B_HE_PRED___10 = 3,
    B_RD_PRED___10 = 4,
    B_VR_PRED___10 = 5,
    B_LD_PRED___10 = 6,
    B_VL_PRED___10 = 7,
    B_HD_PRED___10 = 8,
    B_HU_PRED___10 = 9,
    NUM_BMODES___10 = 10,
    DC_PRED___10 = 0,
    V_PRED___10 = 2,
    H_PRED___10 = 3,
    TM_PRED___10 = 1,
    NUM_PRED_MODES___10 = 4
} ;
#line 52
enum __anonenum__259___2 {
    NUM_MB_SEGMENTS___10 = 4,
    MAX_NUM_PARTITIONS___10 = 8,
    NUM_TYPES___10 = 4,
    NUM_BANDS___10 = 8,
    NUM_CTX___10 = 3,
    NUM_PROBAS___10 = 11,
    MAX_LF_LEVELS___10 = 64,
    MAX_VARIABLE_LEVEL___10 = 67,
    MAX_LEVEL___10 = 2047
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__351___0 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
struct __anonstruct_512 {
   int32_t hash_to_first_index_[262144] ;
   int32_t *chain_ ;
};
#line 40 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
typedef struct __anonstruct_512 HashChain;
#line 376 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
struct __anonstruct_513 {
   double alpha_[256] ;
   double red_[256] ;
   double literal_[792] ;
   double blue_[256] ;
   double distance_[40] ;
};
#line 382 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
typedef struct __anonstruct_513 CostModel;
#line 33 "/usr/include/pthread.h"
enum __anonenum__517 {
    PTHREAD_CREATE_JOINABLE___12 = 0,
    PTHREAD_CREATE_DETACHED___12 = 1
} ;
#line 43
enum __anonenum__518 {
    PTHREAD_MUTEX_TIMED_NP___12 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___12 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___12 = 3,
    PTHREAD_MUTEX_NORMAL___12 = 0,
    PTHREAD_MUTEX_RECURSIVE___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK___12 = 2,
    PTHREAD_MUTEX_DEFAULT___12 = 0
} ;
#line 65
enum __anonenum__519 {
    PTHREAD_MUTEX_STALLED___12 = 0,
    PTHREAD_MUTEX_STALLED_NP___12 = 0,
    PTHREAD_MUTEX_ROBUST___12 = 1,
    PTHREAD_MUTEX_ROBUST_NP___12 = 1
} ;
#line 77
enum __anonenum__443___0 {
    PTHREAD_PRIO_NONE___12 = 0,
    PTHREAD_PRIO_INHERIT___12 = 1,
    PTHREAD_PRIO_PROTECT___12 = 2
} ;
#line 100
enum __anonenum__520 {
    PTHREAD_RWLOCK_PREFER_READER_NP___12 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___12 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___12 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___12 = 0
} ;
#line 120
enum __anonenum__521 {
    PTHREAD_INHERIT_SCHED___12 = 0,
    PTHREAD_EXPLICIT_SCHED___12 = 1
} ;
#line 130
enum __anonenum__522 {
    PTHREAD_SCOPE_SYSTEM___12 = 0,
    PTHREAD_SCOPE_PROCESS___12 = 1
} ;
#line 140
enum __anonenum__523 {
    PTHREAD_PROCESS_PRIVATE___12 = 0,
    PTHREAD_PROCESS_SHARED___12 = 1
} ;
#line 164
enum __anonenum__524 {
    PTHREAD_CANCEL_ENABLE___12 = 0,
    PTHREAD_CANCEL_DISABLE___12 = 1
} ;
#line 171
enum __anonenum__525 {
    PTHREAD_CANCEL_DEFERRED___12 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___12 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__287___0 {
    B_DC_PRED___11 = 0,
    B_TM_PRED___11 = 1,
    B_VE_PRED___11 = 2,
    B_HE_PRED___11 = 3,
    B_RD_PRED___11 = 4,
    B_VR_PRED___11 = 5,
    B_LD_PRED___11 = 6,
    B_VL_PRED___11 = 7,
    B_HD_PRED___11 = 8,
    B_HU_PRED___11 = 9,
    NUM_BMODES___11 = 10,
    DC_PRED___11 = 0,
    V_PRED___11 = 2,
    H_PRED___11 = 3,
    TM_PRED___11 = 1,
    NUM_PRED_MODES___11 = 4
} ;
#line 52
enum __anonenum__288___0 {
    NUM_MB_SEGMENTS___11 = 4,
    MAX_NUM_PARTITIONS___11 = 8,
    NUM_TYPES___11 = 4,
    NUM_BANDS___11 = 8,
    NUM_CTX___11 = 3,
    NUM_PROBAS___11 = 11,
    MAX_LF_LEVELS___11 = 64,
    MAX_VARIABLE_LEVEL___11 = 67,
    MAX_LEVEL___11 = 2047
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__273___0 {
    PTHREAD_CREATE_JOINABLE___13 = 0,
    PTHREAD_CREATE_DETACHED___13 = 1
} ;
#line 43
enum __anonenum__274___0 {
    PTHREAD_MUTEX_TIMED_NP___13 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___13 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___13 = 3,
    PTHREAD_MUTEX_NORMAL___13 = 0,
    PTHREAD_MUTEX_RECURSIVE___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK___13 = 2,
    PTHREAD_MUTEX_DEFAULT___13 = 0
} ;
#line 65
enum __anonenum__275___0 {
    PTHREAD_MUTEX_STALLED___13 = 0,
    PTHREAD_MUTEX_STALLED_NP___13 = 0,
    PTHREAD_MUTEX_ROBUST___13 = 1,
    PTHREAD_MUTEX_ROBUST_NP___13 = 1
} ;
#line 77
enum __anonenum__276___0 {
    PTHREAD_PRIO_NONE___13 = 0,
    PTHREAD_PRIO_INHERIT___13 = 1,
    PTHREAD_PRIO_PROTECT___13 = 2
} ;
#line 100
enum __anonenum__277___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___13 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___13 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___13 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___13 = 0
} ;
#line 120
enum __anonenum__278___0 {
    PTHREAD_INHERIT_SCHED___13 = 0,
    PTHREAD_EXPLICIT_SCHED___13 = 1
} ;
#line 130
enum __anonenum__279___0 {
    PTHREAD_SCOPE_SYSTEM___13 = 0,
    PTHREAD_SCOPE_PROCESS___13 = 1
} ;
#line 140
enum __anonenum__280___0 {
    PTHREAD_PROCESS_PRIVATE___13 = 0,
    PTHREAD_PROCESS_SHARED___13 = 1
} ;
#line 164
enum __anonenum__281___0 {
    PTHREAD_CANCEL_ENABLE___13 = 0,
    PTHREAD_CANCEL_DISABLE___13 = 1
} ;
#line 171
enum __anonenum__282___0 {
    PTHREAD_CANCEL_DEFERRED___13 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___13 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
enum __anonenum__287___1 {
    B_DC_PRED___12 = 0,
    B_TM_PRED___12 = 1,
    B_VE_PRED___12 = 2,
    B_HE_PRED___12 = 3,
    B_RD_PRED___12 = 4,
    B_VR_PRED___12 = 5,
    B_LD_PRED___12 = 6,
    B_VL_PRED___12 = 7,
    B_HD_PRED___12 = 8,
    B_HU_PRED___12 = 9,
    NUM_BMODES___12 = 10,
    DC_PRED___12 = 0,
    V_PRED___12 = 2,
    H_PRED___12 = 3,
    TM_PRED___12 = 1,
    NUM_PRED_MODES___12 = 4
} ;
#line 52
enum __anonenum__288___1 {
    NUM_MB_SEGMENTS___12 = 4,
    MAX_NUM_PARTITIONS___12 = 8,
    NUM_TYPES___12 = 4,
    NUM_BANDS___12 = 8,
    NUM_CTX___12 = 3,
    NUM_PROBAS___12 = 11,
    MAX_LF_LEVELS___12 = 64,
    MAX_VARIABLE_LEVEL___12 = 67,
    MAX_LEVEL___12 = 2047
} ;
#line 57 "/doner/libwebp/libwebp-v0.3.0/src/dsp/./yuv.h"
enum __anonenum__539 {
    YUV_FIX___0 = 16,
    YUV_HALF___0 = 32768,
    YUV_MASK___0 = 16777215,
    YUV_RANGE_MIN___0 = -227,
    YUV_RANGE_MAX___0 = 482
} ;
#line 57
enum __anonenum__541 {
    YUV_FIX___1 = 16,
    YUV_HALF___1 = 32768,
    YUV_MASK___1 = 16777215,
    YUV_RANGE_MIN___1 = -227,
    YUV_RANGE_MAX___1 = 482
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__542 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./webpi.h"
struct WebPDecParams ;
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./webpi.h"
typedef struct WebPDecParams WebPDecParams;
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./webpi.h"
typedef int (*OutputFunc)(VP8Io * const   , WebPDecParams * const   );
#line 27 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./webpi.h"
typedef int (*OutputRowFunc)(WebPDecParams * const   , int  );
#line 29 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./webpi.h"
struct WebPDecParams {
   WebPDecBuffer *output ;
   uint8_t *tmp_y ;
   uint8_t *tmp_u ;
   uint8_t *tmp_v ;
   int last_y ;
   WebPDecoderOptions *options ;
   WebPRescaler scaler_y ;
   WebPRescaler scaler_u ;
   WebPRescaler scaler_v ;
   WebPRescaler scaler_a ;
   void *memory ;
   OutputFunc emit ;
   OutputFunc emit_alpha ;
   OutputRowFunc emit_alpha_row ;
};
#line 52 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./webpi.h"
struct __anonstruct_563 {
   uint8_t *data ;
   size_t data_size ;
   size_t offset ;
   uint8_t *alpha_data ;
   size_t alpha_data_size ;
   size_t compressed_size ;
   size_t riff_size ;
   int is_lossless ;
};
#line 61 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./webpi.h"
typedef struct __anonstruct_563 WebPHeaderStructure;
#line 27 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
enum __anonenum__568 {
    READ_DATA = 0,
    READ_HDR = 1,
    READ_DIM = 2
} ;
#line 31 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
typedef enum __anonenum__568 VP8LDecodeState;
#line 33 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
typedef struct VP8LTransform VP8LTransform;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
struct VP8LTransform {
   VP8LImageTransformType type_ ;
   int bits_ ;
   int xsize_ ;
   int ysize_ ;
   uint32_t *data_ ;
};
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
struct __anonstruct_569 {
   HuffmanTree___0 htrees_[5] ;
};
#line 44 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
typedef struct __anonstruct_569 HTreeGroup;
#line 46 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
struct __anonstruct_570 {
   int color_cache_size_ ;
   VP8LColorCache color_cache_ ;
   int huffman_mask_ ;
   int huffman_subsample_bits_ ;
   int huffman_xsize_ ;
   uint32_t *huffman_image_ ;
   int num_htree_groups_ ;
   HTreeGroup *htree_groups_ ;
};
#line 56 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
typedef struct __anonstruct_570 VP8LMetadata;
#line 58 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
struct __anonstruct_571 {
   enum VP8StatusCode status_ ;
   VP8LDecodeState action_ ;
   VP8LDecodeState state_ ;
   VP8Io *io_ ;
   WebPDecBuffer *output_ ;
   uint32_t *argb_ ;
   uint32_t *argb_cache_ ;
   VP8LBitReader br_ ;
   int width_ ;
   int height_ ;
   int last_row_ ;
   int last_out_row_ ;
   VP8LMetadata hdr_ ;
   int next_transform_ ;
   VP8LTransform transforms_[4] ;
   uint32_t transforms_seen_ ;
   uint8_t *rescaler_memory ;
   WebPRescaler *rescaler ;
};
#line 85 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
typedef struct __anonstruct_571 VP8LDecoder;
#line 57 "/doner/libwebp/libwebp-v0.3.0/src/dsp/./yuv.h"
enum __anonenum__572 {
    YUV_FIX___2 = 16,
    YUV_HALF___2 = 32768,
    YUV_MASK___2 = 16777215,
    YUV_RANGE_MIN___2 = -227,
    YUV_RANGE_MAX___2 = 482
} ;
#line 462 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
typedef uint32_t (*PredictorFunc)(uint32_t  , uint32_t * const   );
#line 770 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
struct __anonstruct_573 {
   uint8_t green_to_red_ ;
   uint8_t green_to_blue_ ;
   uint8_t red_to_blue_ ;
};
#line 776 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
typedef struct __anonstruct_573 Multipliers;
#line 1175 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
union __anonunion_574 {
   uint16_t w ;
   uint8_t b[2] ;
};
#line 33 "/usr/include/pthread.h"
enum __anonenum__580 {
    PTHREAD_CREATE_JOINABLE___14 = 0,
    PTHREAD_CREATE_DETACHED___14 = 1
} ;
#line 43
enum __anonenum__581 {
    PTHREAD_MUTEX_TIMED_NP___14 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___14 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___14 = 3,
    PTHREAD_MUTEX_NORMAL___14 = 0,
    PTHREAD_MUTEX_RECURSIVE___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK___14 = 2,
    PTHREAD_MUTEX_DEFAULT___14 = 0
} ;
#line 65
enum __anonenum__582 {
    PTHREAD_MUTEX_STALLED___14 = 0,
    PTHREAD_MUTEX_STALLED_NP___14 = 0,
    PTHREAD_MUTEX_ROBUST___14 = 1,
    PTHREAD_MUTEX_ROBUST_NP___14 = 1
} ;
#line 77
enum __anonenum__583 {
    PTHREAD_PRIO_NONE___14 = 0,
    PTHREAD_PRIO_INHERIT___14 = 1,
    PTHREAD_PRIO_PROTECT___14 = 2
} ;
#line 100
enum __anonenum__584 {
    PTHREAD_RWLOCK_PREFER_READER_NP___14 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___14 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___14 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___14 = 0
} ;
#line 120
enum __anonenum__585 {
    PTHREAD_INHERIT_SCHED___14 = 0,
    PTHREAD_EXPLICIT_SCHED___14 = 1
} ;
#line 130
enum __anonenum__586 {
    PTHREAD_SCOPE_SYSTEM___14 = 0,
    PTHREAD_SCOPE_PROCESS___14 = 1
} ;
#line 140
enum __anonenum__587 {
    PTHREAD_PROCESS_PRIVATE___14 = 0,
    PTHREAD_PROCESS_SHARED___14 = 1
} ;
#line 164
enum __anonenum__276___1 {
    PTHREAD_CANCEL_ENABLE___14 = 0,
    PTHREAD_CANCEL_DISABLE___14 = 1
} ;
#line 171
enum __anonenum__588 {
    PTHREAD_CANCEL_DEFERRED___14 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___14 = 1
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../enc/vp8enci.h"
enum __anonenum__593 {
    B_DC_PRED___13 = 0,
    B_TM_PRED___13 = 1,
    B_VE_PRED___13 = 2,
    B_HE_PRED___13 = 3,
    B_RD_PRED___13 = 4,
    B_VR_PRED___13 = 5,
    B_LD_PRED___13 = 6,
    B_VL_PRED___13 = 7,
    B_HD_PRED___13 = 8,
    B_HU_PRED___13 = 9,
    NUM_BMODES___13 = 10,
    DC_PRED___13 = 0,
    V_PRED___13 = 2,
    H_PRED___13 = 3,
    TM_PRED___13 = 1,
    NUM_PRED_MODES___13 = 4
} ;
#line 52
enum __anonenum__594 {
    NUM_MB_SEGMENTS___13 = 4,
    MAX_NUM_PARTITIONS___13 = 8,
    NUM_TYPES___13 = 4,
    NUM_BANDS___13 = 8,
    NUM_CTX___13 = 3,
    NUM_PROBAS___13 = 11,
    MAX_LF_LEVELS___13 = 64,
    MAX_VARIABLE_LEVEL___13 = 67,
    MAX_LEVEL___13 = 2047
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__629 {
    PTHREAD_CREATE_JOINABLE___15 = 0,
    PTHREAD_CREATE_DETACHED___15 = 1
} ;
#line 43
enum __anonenum__630 {
    PTHREAD_MUTEX_TIMED_NP___15 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___15 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___15 = 3,
    PTHREAD_MUTEX_NORMAL___15 = 0,
    PTHREAD_MUTEX_RECURSIVE___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK___15 = 2,
    PTHREAD_MUTEX_DEFAULT___15 = 0
} ;
#line 65
enum __anonenum__631 {
    PTHREAD_MUTEX_STALLED___15 = 0,
    PTHREAD_MUTEX_STALLED_NP___15 = 0,
    PTHREAD_MUTEX_ROBUST___15 = 1,
    PTHREAD_MUTEX_ROBUST_NP___15 = 1
} ;
#line 77
enum __anonenum__632 {
    PTHREAD_PRIO_NONE___15 = 0,
    PTHREAD_PRIO_INHERIT___15 = 1,
    PTHREAD_PRIO_PROTECT___15 = 2
} ;
#line 100
enum __anonenum__633 {
    PTHREAD_RWLOCK_PREFER_READER_NP___15 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___15 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___15 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___15 = 0
} ;
#line 120
enum __anonenum__634 {
    PTHREAD_INHERIT_SCHED___15 = 0,
    PTHREAD_EXPLICIT_SCHED___15 = 1
} ;
#line 130
enum __anonenum__635 {
    PTHREAD_SCOPE_SYSTEM___15 = 0,
    PTHREAD_SCOPE_PROCESS___15 = 1
} ;
#line 140
enum __anonenum__636 {
    PTHREAD_PROCESS_PRIVATE___15 = 0,
    PTHREAD_PROCESS_SHARED___15 = 1
} ;
#line 164
enum __anonenum__637 {
    PTHREAD_CANCEL_ENABLE___15 = 0,
    PTHREAD_CANCEL_DISABLE___15 = 1
} ;
#line 171
enum __anonenum__638 {
    PTHREAD_CANCEL_DEFERRED___15 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___15 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
enum __anonenum__643 {
    B_DC_PRED___14 = 0,
    B_TM_PRED___14 = 1,
    B_VE_PRED___14 = 2,
    B_HE_PRED___14 = 3,
    B_RD_PRED___14 = 4,
    B_VR_PRED___14 = 5,
    B_LD_PRED___14 = 6,
    B_VL_PRED___14 = 7,
    B_HD_PRED___14 = 8,
    B_HU_PRED___14 = 9,
    NUM_BMODES___14 = 10,
    DC_PRED___14 = 0,
    V_PRED___14 = 2,
    H_PRED___14 = 3,
    TM_PRED___14 = 1,
    B_PRED = 10,
    B_DC_PRED_NOTOP = 4,
    B_DC_PRED_NOLEFT = 5,
    B_DC_PRED_NOTOPLEFT = 6,
    NUM_B_DC_MODES = 7
} ;
#line 59
enum __anonenum__644 {
    MB_FEATURE_TREE_PROBS = 3,
    NUM_MB_SEGMENTS___14 = 4,
    NUM_REF_LF_DELTAS = 4,
    NUM_MODE_LF_DELTAS = 4,
    MAX_NUM_PARTITIONS___14 = 8,
    NUM_TYPES___14 = 4,
    NUM_BANDS___14 = 8,
    NUM_CTX___14 = 3,
    NUM_PROBAS___14 = 11,
    NUM_MV_PROBAS = 19
} ;
#line 104 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct __anonstruct_645 {
   uint8_t key_frame_ ;
   uint8_t profile_ ;
   uint8_t show_ ;
   uint32_t partition_length_ ;
};
#line 109 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_645 VP8FrameHeader;
#line 111 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct __anonstruct_646 {
   uint16_t width_ ;
   uint16_t height_ ;
   uint8_t xscale_ ;
   uint8_t yscale_ ;
   uint8_t colorspace_ ;
   uint8_t clamp_type_ ;
};
#line 118 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_646 VP8PictureHeader;
#line 121 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct __anonstruct_647 {
   int use_segment_ ;
   int update_map_ ;
   int absolute_delta_ ;
   int8_t quantizer_[4] ;
   int8_t filter_strength_[4] ;
};
#line 127 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_647 VP8SegmentHeader___0;
#line 130 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct __anonstruct_648 {
   uint8_t segments_[3] ;
   uint8_t coeffs_[4][8][3][11] ;
};
#line 138 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_648 VP8Proba___0;
#line 141 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct __anonstruct_649 {
   int simple_ ;
   int level_ ;
   int sharpness_ ;
   int use_lf_delta_ ;
   int ref_lf_delta_[4] ;
   int mode_lf_delta_[4] ;
};
#line 148 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_649 VP8FilterHeader___0;
#line 153 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct __anonstruct_650 {
   unsigned int f_level_ ;
   unsigned int f_ilevel_ ;
   unsigned int f_inner_ ;
};
#line 157 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_650 VP8FInfo;
#line 159 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct __anonstruct_651 {
   unsigned int nz_ ;
   unsigned int dc_nz_ ;
   unsigned int skip_ ;
};
#line 163 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_651 VP8MB;
#line 166 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef int quant_t[2];
#line 167 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct __anonstruct_652 {
   quant_t y1_mat_ ;
   quant_t y2_mat_ ;
   quant_t uv_mat_ ;
};
#line 169 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_652 VP8QuantMatrix;
#line 172 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct __anonstruct_653 {
   int id_ ;
   int mb_y_ ;
   int filter_row_ ;
   VP8FInfo *f_info_ ;
   VP8Io io_ ;
};
#line 178 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
typedef struct __anonstruct_653 VP8ThreadContext;
#line 183 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
struct VP8Decoder {
   enum VP8StatusCode status_ ;
   int ready_ ;
   char const   *error_msg_ ;
   VP8BitReader br_ ;
   VP8FrameHeader frm_hdr_ ;
   VP8PictureHeader pic_hdr_ ;
   VP8FilterHeader___0 filter_hdr_ ;
   VP8SegmentHeader___0 segment_hdr_ ;
   WebPWorker worker_ ;
   int use_threads_ ;
   int cache_id_ ;
   int num_caches_ ;
   VP8ThreadContext thread_ctx_ ;
   int mb_w_ ;
   int mb_h_ ;
   int tl_mb_x_ ;
   int tl_mb_y_ ;
   int br_mb_x_ ;
   int br_mb_y_ ;
   int num_parts_ ;
   VP8BitReader parts_[8] ;
   uint32_t buffer_flags_ ;
   VP8QuantMatrix dqm_[4] ;
   VP8Proba___0 proba_ ;
   int use_skip_proba_ ;
   uint8_t skip_p_ ;
   uint8_t *intra_t_ ;
   uint8_t intra_l_[4] ;
   uint8_t *y_t_ ;
   uint8_t *u_t_ ;
   uint8_t *v_t_ ;
   VP8MB *mb_info_ ;
   VP8FInfo *f_info_ ;
   uint8_t *yuv_b_ ;
   int16_t *coeffs_ ;
   uint8_t *cache_y_ ;
   uint8_t *cache_u_ ;
   uint8_t *cache_v_ ;
   int cache_y_stride_ ;
   int cache_uv_stride_ ;
   void *mem_ ;
   size_t mem_size_ ;
   int mb_x_ ;
   int mb_y_ ;
   uint8_t is_i4x4_ ;
   uint8_t imodes_[16] ;
   uint8_t uvmode_ ;
   uint8_t segment_ ;
   uint32_t non_zero_ ;
   uint32_t non_zero_ac_ ;
   int filter_type_ ;
   int filter_row_ ;
   VP8FInfo fstrengths_[4][2] ;
   uint8_t *alpha_data_ ;
   size_t alpha_data_size_ ;
   uint8_t *alpha_plane_ ;
   int layer_colorspace_ ;
   uint8_t *layer_data_ ;
   size_t layer_data_size_ ;
};
#line 33 "/usr/include/pthread.h"
enum __anonenum__666 {
    PTHREAD_CREATE_JOINABLE___16 = 0,
    PTHREAD_CREATE_DETACHED___16 = 1
} ;
#line 43
enum __anonenum__667 {
    PTHREAD_MUTEX_TIMED_NP___16 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___16 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___16 = 3,
    PTHREAD_MUTEX_NORMAL___16 = 0,
    PTHREAD_MUTEX_RECURSIVE___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK___16 = 2,
    PTHREAD_MUTEX_DEFAULT___16 = 0
} ;
#line 65
enum __anonenum__668 {
    PTHREAD_MUTEX_STALLED___16 = 0,
    PTHREAD_MUTEX_STALLED_NP___16 = 0,
    PTHREAD_MUTEX_ROBUST___16 = 1,
    PTHREAD_MUTEX_ROBUST_NP___16 = 1
} ;
#line 77
enum __anonenum__669 {
    PTHREAD_PRIO_NONE___16 = 0,
    PTHREAD_PRIO_INHERIT___16 = 1,
    PTHREAD_PRIO_PROTECT___16 = 2
} ;
#line 100
enum __anonenum__670 {
    PTHREAD_RWLOCK_PREFER_READER_NP___16 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___16 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___16 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___16 = 0
} ;
#line 120
enum __anonenum__671 {
    PTHREAD_INHERIT_SCHED___16 = 0,
    PTHREAD_EXPLICIT_SCHED___16 = 1
} ;
#line 130
enum __anonenum__672 {
    PTHREAD_SCOPE_SYSTEM___16 = 0,
    PTHREAD_SCOPE_PROCESS___16 = 1
} ;
#line 140
enum __anonenum__673 {
    PTHREAD_PROCESS_PRIVATE___16 = 0,
    PTHREAD_PROCESS_SHARED___16 = 1
} ;
#line 164
enum __anonenum__674 {
    PTHREAD_CANCEL_ENABLE___16 = 0,
    PTHREAD_CANCEL_DISABLE___16 = 1
} ;
#line 171
enum __anonenum__675 {
    PTHREAD_CANCEL_DEFERRED___16 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___16 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./vp8i.h"
enum __anonenum__681 {
    B_DC_PRED___15 = 0,
    B_TM_PRED___15 = 1,
    B_VE_PRED___15 = 2,
    B_HE_PRED___15 = 3,
    B_RD_PRED___15 = 4,
    B_VR_PRED___15 = 5,
    B_LD_PRED___15 = 6,
    B_VL_PRED___15 = 7,
    B_HD_PRED___15 = 8,
    B_HU_PRED___15 = 9,
    NUM_BMODES___15 = 10,
    DC_PRED___15 = 0,
    V_PRED___15 = 2,
    H_PRED___15 = 3,
    TM_PRED___15 = 1,
    B_PRED___0 = 10,
    B_DC_PRED_NOTOP___0 = 4,
    B_DC_PRED_NOLEFT___0 = 5,
    B_DC_PRED_NOTOPLEFT___0 = 6,
    NUM_B_DC_MODES___0 = 7
} ;
#line 59
enum __anonenum__682 {
    MB_FEATURE_TREE_PROBS___0 = 3,
    NUM_MB_SEGMENTS___15 = 4,
    NUM_REF_LF_DELTAS___0 = 4,
    NUM_MODE_LF_DELTAS___0 = 4,
    MAX_NUM_PARTITIONS___15 = 8,
    NUM_TYPES___15 = 4,
    NUM_BANDS___15 = 8,
    NUM_CTX___15 = 3,
    NUM_PROBAS___15 = 11,
    NUM_MV_PROBAS___0 = 19
} ;
#line 57 "/doner/libwebp/libwebp-v0.3.0/src/dec/../dsp/yuv.h"
enum __anonenum__726 {
    YUV_FIX___3 = 16,
    YUV_HALF___3 = 32768,
    YUV_MASK___3 = 16777215,
    YUV_RANGE_MIN___3 = -227,
    YUV_RANGE_MAX___3 = 482
} ;
#line 39 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
enum __anonenum__727 {
    GREEN = 0,
    RED = 1,
    BLUE = 2,
    ALPHA = 3,
    DIST = 4
} ;
#line 45 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
typedef enum __anonenum__727 HuffIndex;
#line 607 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
typedef void (*ProcessRowsFunc)(VP8LDecoder * const   , int  );
#line 33 "/usr/include/pthread.h"
enum __anonenum__666___0 {
    PTHREAD_CREATE_JOINABLE___17 = 0,
    PTHREAD_CREATE_DETACHED___17 = 1
} ;
#line 43
enum __anonenum__667___0 {
    PTHREAD_MUTEX_TIMED_NP___17 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___17 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___17 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___17 = 3,
    PTHREAD_MUTEX_NORMAL___17 = 0,
    PTHREAD_MUTEX_RECURSIVE___17 = 1,
    PTHREAD_MUTEX_ERRORCHECK___17 = 2,
    PTHREAD_MUTEX_DEFAULT___17 = 0
} ;
#line 65
enum __anonenum__668___0 {
    PTHREAD_MUTEX_STALLED___17 = 0,
    PTHREAD_MUTEX_STALLED_NP___17 = 0,
    PTHREAD_MUTEX_ROBUST___17 = 1,
    PTHREAD_MUTEX_ROBUST_NP___17 = 1
} ;
#line 77
enum __anonenum__669___0 {
    PTHREAD_PRIO_NONE___17 = 0,
    PTHREAD_PRIO_INHERIT___17 = 1,
    PTHREAD_PRIO_PROTECT___17 = 2
} ;
#line 100
enum __anonenum__670___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___17 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___17 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___17 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___17 = 0
} ;
#line 120
enum __anonenum__671___0 {
    PTHREAD_INHERIT_SCHED___17 = 0,
    PTHREAD_EXPLICIT_SCHED___17 = 1
} ;
#line 130
enum __anonenum__672___0 {
    PTHREAD_SCOPE_SYSTEM___17 = 0,
    PTHREAD_SCOPE_PROCESS___17 = 1
} ;
#line 140
enum __anonenum__673___0 {
    PTHREAD_PROCESS_PRIVATE___17 = 0,
    PTHREAD_PROCESS_SHARED___17 = 1
} ;
#line 164
enum __anonenum__674___0 {
    PTHREAD_CANCEL_ENABLE___17 = 0,
    PTHREAD_CANCEL_DISABLE___17 = 1
} ;
#line 171
enum __anonenum__675___0 {
    PTHREAD_CANCEL_DEFERRED___17 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___17 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./vp8i.h"
enum __anonenum__681___0 {
    B_DC_PRED___16 = 0,
    B_TM_PRED___16 = 1,
    B_VE_PRED___16 = 2,
    B_HE_PRED___16 = 3,
    B_RD_PRED___16 = 4,
    B_VR_PRED___16 = 5,
    B_LD_PRED___16 = 6,
    B_VL_PRED___16 = 7,
    B_HD_PRED___16 = 8,
    B_HU_PRED___16 = 9,
    NUM_BMODES___16 = 10,
    DC_PRED___16 = 0,
    V_PRED___16 = 2,
    H_PRED___16 = 3,
    TM_PRED___16 = 1,
    B_PRED___1 = 10,
    B_DC_PRED_NOTOP___1 = 4,
    B_DC_PRED_NOLEFT___1 = 5,
    B_DC_PRED_NOTOPLEFT___1 = 6,
    NUM_B_DC_MODES___1 = 7
} ;
#line 59
enum __anonenum__682___0 {
    MB_FEATURE_TREE_PROBS___1 = 3,
    NUM_MB_SEGMENTS___16 = 4,
    NUM_REF_LF_DELTAS___1 = 4,
    NUM_MODE_LF_DELTAS___1 = 4,
    MAX_NUM_PARTITIONS___16 = 8,
    NUM_TYPES___16 = 4,
    NUM_BANDS___16 = 8,
    NUM_CTX___16 = 3,
    NUM_PROBAS___16 = 11,
    NUM_MV_PROBAS___1 = 19
} ;
#line 462 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
typedef uint8_t (*ProbaArray___0)[3][11];
#line 463 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
typedef uint8_t (*ProbaCtxArray)[11];
#line 529 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
union __anonunion_728 {
   uint8_t i8[4] ;
   uint32_t i32 ;
};
#line 532 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
typedef union __anonunion_728 PackedNz;
#line 33 "/usr/include/pthread.h"
enum __anonenum__753 {
    PTHREAD_CREATE_JOINABLE___18 = 0,
    PTHREAD_CREATE_DETACHED___18 = 1
} ;
#line 43
enum __anonenum__754 {
    PTHREAD_MUTEX_TIMED_NP___18 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___18 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___18 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___18 = 3,
    PTHREAD_MUTEX_NORMAL___18 = 0,
    PTHREAD_MUTEX_RECURSIVE___18 = 1,
    PTHREAD_MUTEX_ERRORCHECK___18 = 2,
    PTHREAD_MUTEX_DEFAULT___18 = 0
} ;
#line 65
enum __anonenum__755 {
    PTHREAD_MUTEX_STALLED___18 = 0,
    PTHREAD_MUTEX_STALLED_NP___18 = 0,
    PTHREAD_MUTEX_ROBUST___18 = 1,
    PTHREAD_MUTEX_ROBUST_NP___18 = 1
} ;
#line 77
enum __anonenum__756 {
    PTHREAD_PRIO_NONE___18 = 0,
    PTHREAD_PRIO_INHERIT___18 = 1,
    PTHREAD_PRIO_PROTECT___18 = 2
} ;
#line 100
enum __anonenum__757 {
    PTHREAD_RWLOCK_PREFER_READER_NP___18 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___18 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___18 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___18 = 0
} ;
#line 120
enum __anonenum__758 {
    PTHREAD_INHERIT_SCHED___18 = 0,
    PTHREAD_EXPLICIT_SCHED___18 = 1
} ;
#line 130
enum __anonenum__759 {
    PTHREAD_SCOPE_SYSTEM___18 = 0,
    PTHREAD_SCOPE_PROCESS___18 = 1
} ;
#line 140
enum __anonenum__760 {
    PTHREAD_PROCESS_PRIVATE___18 = 0,
    PTHREAD_PROCESS_SHARED___18 = 1
} ;
#line 164
enum __anonenum__761 {
    PTHREAD_CANCEL_ENABLE___18 = 0,
    PTHREAD_CANCEL_DISABLE___18 = 1
} ;
#line 171
enum __anonenum__762 {
    PTHREAD_CANCEL_DEFERRED___18 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___18 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8i.h"
enum __anonenum__768 {
    B_DC_PRED___17 = 0,
    B_TM_PRED___17 = 1,
    B_VE_PRED___17 = 2,
    B_HE_PRED___17 = 3,
    B_RD_PRED___17 = 4,
    B_VR_PRED___17 = 5,
    B_LD_PRED___17 = 6,
    B_VL_PRED___17 = 7,
    B_HD_PRED___17 = 8,
    B_HU_PRED___17 = 9,
    NUM_BMODES___17 = 10,
    DC_PRED___17 = 0,
    V_PRED___17 = 2,
    H_PRED___17 = 3,
    TM_PRED___17 = 1,
    B_PRED___2 = 10,
    B_DC_PRED_NOTOP___2 = 4,
    B_DC_PRED_NOLEFT___2 = 5,
    B_DC_PRED_NOTOPLEFT___2 = 6,
    NUM_B_DC_MODES___2 = 7
} ;
#line 59
enum __anonenum__769 {
    MB_FEATURE_TREE_PROBS___2 = 3,
    NUM_MB_SEGMENTS___17 = 4,
    NUM_REF_LF_DELTAS___2 = 4,
    NUM_MODE_LF_DELTAS___2 = 4,
    MAX_NUM_PARTITIONS___17 = 8,
    NUM_TYPES___17 = 4,
    NUM_BANDS___17 = 8,
    NUM_CTX___17 = 3,
    NUM_PROBAS___17 = 11,
    NUM_MV_PROBAS___2 = 19
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__753___0 {
    PTHREAD_CREATE_JOINABLE___19 = 0,
    PTHREAD_CREATE_DETACHED___19 = 1
} ;
#line 43
enum __anonenum__754___0 {
    PTHREAD_MUTEX_TIMED_NP___19 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___19 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___19 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___19 = 3,
    PTHREAD_MUTEX_NORMAL___19 = 0,
    PTHREAD_MUTEX_RECURSIVE___19 = 1,
    PTHREAD_MUTEX_ERRORCHECK___19 = 2,
    PTHREAD_MUTEX_DEFAULT___19 = 0
} ;
#line 65
enum __anonenum__755___0 {
    PTHREAD_MUTEX_STALLED___19 = 0,
    PTHREAD_MUTEX_STALLED_NP___19 = 0,
    PTHREAD_MUTEX_ROBUST___19 = 1,
    PTHREAD_MUTEX_ROBUST_NP___19 = 1
} ;
#line 77
enum __anonenum__756___0 {
    PTHREAD_PRIO_NONE___19 = 0,
    PTHREAD_PRIO_INHERIT___19 = 1,
    PTHREAD_PRIO_PROTECT___19 = 2
} ;
#line 100
enum __anonenum__757___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___19 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___19 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___19 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___19 = 0
} ;
#line 120
enum __anonenum__758___0 {
    PTHREAD_INHERIT_SCHED___19 = 0,
    PTHREAD_EXPLICIT_SCHED___19 = 1
} ;
#line 130
enum __anonenum__759___0 {
    PTHREAD_SCOPE_SYSTEM___19 = 0,
    PTHREAD_SCOPE_PROCESS___19 = 1
} ;
#line 140
enum __anonenum__760___0 {
    PTHREAD_PROCESS_PRIVATE___19 = 0,
    PTHREAD_PROCESS_SHARED___19 = 1
} ;
#line 164
enum __anonenum__761___0 {
    PTHREAD_CANCEL_ENABLE___19 = 0,
    PTHREAD_CANCEL_DISABLE___19 = 1
} ;
#line 171
enum __anonenum__762___0 {
    PTHREAD_CANCEL_DEFERRED___19 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___19 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./vp8i.h"
enum __anonenum__768___0 {
    B_DC_PRED___18 = 0,
    B_TM_PRED___18 = 1,
    B_VE_PRED___18 = 2,
    B_HE_PRED___18 = 3,
    B_RD_PRED___18 = 4,
    B_VR_PRED___18 = 5,
    B_LD_PRED___18 = 6,
    B_VL_PRED___18 = 7,
    B_HD_PRED___18 = 8,
    B_HU_PRED___18 = 9,
    NUM_BMODES___18 = 10,
    DC_PRED___18 = 0,
    V_PRED___18 = 2,
    H_PRED___18 = 3,
    TM_PRED___18 = 1,
    B_PRED___3 = 10,
    B_DC_PRED_NOTOP___3 = 4,
    B_DC_PRED_NOLEFT___3 = 5,
    B_DC_PRED_NOTOPLEFT___3 = 6,
    NUM_B_DC_MODES___3 = 7
} ;
#line 59
enum __anonenum__769___0 {
    MB_FEATURE_TREE_PROBS___3 = 3,
    NUM_MB_SEGMENTS___18 = 4,
    NUM_REF_LF_DELTAS___3 = 4,
    NUM_MODE_LF_DELTAS___3 = 4,
    MAX_NUM_PARTITIONS___18 = 8,
    NUM_TYPES___18 = 4,
    NUM_BANDS___18 = 8,
    NUM_CTX___18 = 3,
    NUM_PROBAS___18 = 11,
    NUM_MV_PROBAS___3 = 19
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__790 {
    PTHREAD_CREATE_JOINABLE___20 = 0,
    PTHREAD_CREATE_DETACHED___20 = 1
} ;
#line 43
enum __anonenum__791 {
    PTHREAD_MUTEX_TIMED_NP___20 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___20 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___20 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___20 = 3,
    PTHREAD_MUTEX_NORMAL___20 = 0,
    PTHREAD_MUTEX_RECURSIVE___20 = 1,
    PTHREAD_MUTEX_ERRORCHECK___20 = 2,
    PTHREAD_MUTEX_DEFAULT___20 = 0
} ;
#line 65
enum __anonenum__792 {
    PTHREAD_MUTEX_STALLED___20 = 0,
    PTHREAD_MUTEX_STALLED_NP___20 = 0,
    PTHREAD_MUTEX_ROBUST___20 = 1,
    PTHREAD_MUTEX_ROBUST_NP___20 = 1
} ;
#line 77
enum __anonenum__793 {
    PTHREAD_PRIO_NONE___20 = 0,
    PTHREAD_PRIO_INHERIT___20 = 1,
    PTHREAD_PRIO_PROTECT___20 = 2
} ;
#line 100
enum __anonenum__794 {
    PTHREAD_RWLOCK_PREFER_READER_NP___20 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___20 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___20 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___20 = 0
} ;
#line 120
enum __anonenum__795 {
    PTHREAD_INHERIT_SCHED___20 = 0,
    PTHREAD_EXPLICIT_SCHED___20 = 1
} ;
#line 130
enum __anonenum__796 {
    PTHREAD_SCOPE_SYSTEM___20 = 0,
    PTHREAD_SCOPE_PROCESS___20 = 1
} ;
#line 140
enum __anonenum__797 {
    PTHREAD_PROCESS_PRIVATE___20 = 0,
    PTHREAD_PROCESS_SHARED___20 = 1
} ;
#line 164
enum __anonenum__798 {
    PTHREAD_CANCEL_ENABLE___20 = 0,
    PTHREAD_CANCEL_DISABLE___20 = 1
} ;
#line 171
enum __anonenum__799 {
    PTHREAD_CANCEL_DEFERRED___20 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___20 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./vp8i.h"
enum __anonenum__805 {
    B_DC_PRED___19 = 0,
    B_TM_PRED___19 = 1,
    B_VE_PRED___19 = 2,
    B_HE_PRED___19 = 3,
    B_RD_PRED___19 = 4,
    B_VR_PRED___19 = 5,
    B_LD_PRED___19 = 6,
    B_VL_PRED___19 = 7,
    B_HD_PRED___19 = 8,
    B_HU_PRED___19 = 9,
    NUM_BMODES___19 = 10,
    DC_PRED___19 = 0,
    V_PRED___19 = 2,
    H_PRED___19 = 3,
    TM_PRED___19 = 1,
    B_PRED___4 = 10,
    B_DC_PRED_NOTOP___4 = 4,
    B_DC_PRED_NOLEFT___4 = 5,
    B_DC_PRED_NOTOPLEFT___4 = 6,
    NUM_B_DC_MODES___4 = 7
} ;
#line 59
enum __anonenum__806 {
    MB_FEATURE_TREE_PROBS___4 = 3,
    NUM_MB_SEGMENTS___19 = 4,
    NUM_REF_LF_DELTAS___4 = 4,
    NUM_MODE_LF_DELTAS___4 = 4,
    MAX_NUM_PARTITIONS___19 = 8,
    NUM_TYPES___19 = 4,
    NUM_BANDS___19 = 8,
    NUM_CTX___19 = 3,
    NUM_PROBAS___19 = 11,
    NUM_MV_PROBAS___4 = 19
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__790___0 {
    PTHREAD_CREATE_JOINABLE___21 = 0,
    PTHREAD_CREATE_DETACHED___21 = 1
} ;
#line 43
enum __anonenum__791___0 {
    PTHREAD_MUTEX_TIMED_NP___21 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___21 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___21 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___21 = 3,
    PTHREAD_MUTEX_NORMAL___21 = 0,
    PTHREAD_MUTEX_RECURSIVE___21 = 1,
    PTHREAD_MUTEX_ERRORCHECK___21 = 2,
    PTHREAD_MUTEX_DEFAULT___21 = 0
} ;
#line 65
enum __anonenum__792___0 {
    PTHREAD_MUTEX_STALLED___21 = 0,
    PTHREAD_MUTEX_STALLED_NP___21 = 0,
    PTHREAD_MUTEX_ROBUST___21 = 1,
    PTHREAD_MUTEX_ROBUST_NP___21 = 1
} ;
#line 77
enum __anonenum__793___0 {
    PTHREAD_PRIO_NONE___21 = 0,
    PTHREAD_PRIO_INHERIT___21 = 1,
    PTHREAD_PRIO_PROTECT___21 = 2
} ;
#line 100
enum __anonenum__794___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___21 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___21 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___21 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___21 = 0
} ;
#line 120
enum __anonenum__795___0 {
    PTHREAD_INHERIT_SCHED___21 = 0,
    PTHREAD_EXPLICIT_SCHED___21 = 1
} ;
#line 130
enum __anonenum__796___0 {
    PTHREAD_SCOPE_SYSTEM___21 = 0,
    PTHREAD_SCOPE_PROCESS___21 = 1
} ;
#line 140
enum __anonenum__797___0 {
    PTHREAD_PROCESS_PRIVATE___21 = 0,
    PTHREAD_PROCESS_SHARED___21 = 1
} ;
#line 164
enum __anonenum__798___0 {
    PTHREAD_CANCEL_ENABLE___21 = 0,
    PTHREAD_CANCEL_DISABLE___21 = 1
} ;
#line 171
enum __anonenum__799___0 {
    PTHREAD_CANCEL_DEFERRED___21 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___21 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/../dec/vp8i.h"
enum __anonenum__805___0 {
    B_DC_PRED___20 = 0,
    B_TM_PRED___20 = 1,
    B_VE_PRED___20 = 2,
    B_HE_PRED___20 = 3,
    B_RD_PRED___20 = 4,
    B_VR_PRED___20 = 5,
    B_LD_PRED___20 = 6,
    B_VL_PRED___20 = 7,
    B_HD_PRED___20 = 8,
    B_HU_PRED___20 = 9,
    NUM_BMODES___20 = 10,
    DC_PRED___20 = 0,
    V_PRED___20 = 2,
    H_PRED___20 = 3,
    TM_PRED___20 = 1,
    B_PRED___5 = 10,
    B_DC_PRED_NOTOP___5 = 4,
    B_DC_PRED_NOLEFT___5 = 5,
    B_DC_PRED_NOTOPLEFT___5 = 6,
    NUM_B_DC_MODES___5 = 7
} ;
#line 59
enum __anonenum__806___0 {
    MB_FEATURE_TREE_PROBS___5 = 3,
    NUM_MB_SEGMENTS___20 = 4,
    NUM_REF_LF_DELTAS___5 = 4,
    NUM_MODE_LF_DELTAS___5 = 4,
    MAX_NUM_PARTITIONS___20 = 8,
    NUM_TYPES___20 = 4,
    NUM_BANDS___20 = 8,
    NUM_CTX___20 = 3,
    NUM_PROBAS___20 = 11,
    NUM_MV_PROBAS___5 = 19
} ;
#line 57 "/doner/libwebp/libwebp-v0.3.0/src/dec/../dsp/yuv.h"
enum __anonenum__821 {
    YUV_FIX___4 = 16,
    YUV_HALF___4 = 32768,
    YUV_MASK___4 = 16777215,
    YUV_RANGE_MIN___4 = -227,
    YUV_RANGE_MAX___4 = 482
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__833 {
    PTHREAD_CREATE_JOINABLE___22 = 0,
    PTHREAD_CREATE_DETACHED___22 = 1
} ;
#line 43
enum __anonenum__834 {
    PTHREAD_MUTEX_TIMED_NP___22 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___22 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___22 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___22 = 3,
    PTHREAD_MUTEX_NORMAL___22 = 0,
    PTHREAD_MUTEX_RECURSIVE___22 = 1,
    PTHREAD_MUTEX_ERRORCHECK___22 = 2,
    PTHREAD_MUTEX_DEFAULT___22 = 0
} ;
#line 65
enum __anonenum__835 {
    PTHREAD_MUTEX_STALLED___22 = 0,
    PTHREAD_MUTEX_STALLED_NP___22 = 0,
    PTHREAD_MUTEX_ROBUST___22 = 1,
    PTHREAD_MUTEX_ROBUST_NP___22 = 1
} ;
#line 77
enum __anonenum__836 {
    PTHREAD_PRIO_NONE___22 = 0,
    PTHREAD_PRIO_INHERIT___22 = 1,
    PTHREAD_PRIO_PROTECT___22 = 2
} ;
#line 100
enum __anonenum__837 {
    PTHREAD_RWLOCK_PREFER_READER_NP___22 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___22 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___22 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___22 = 0
} ;
#line 120
enum __anonenum__838 {
    PTHREAD_INHERIT_SCHED___22 = 0,
    PTHREAD_EXPLICIT_SCHED___22 = 1
} ;
#line 130
enum __anonenum__839 {
    PTHREAD_SCOPE_SYSTEM___22 = 0,
    PTHREAD_SCOPE_PROCESS___22 = 1
} ;
#line 140
enum __anonenum__840 {
    PTHREAD_PROCESS_PRIVATE___22 = 0,
    PTHREAD_PROCESS_SHARED___22 = 1
} ;
#line 164
enum __anonenum__841 {
    PTHREAD_CANCEL_ENABLE___22 = 0,
    PTHREAD_CANCEL_DISABLE___22 = 1
} ;
#line 171
enum __anonenum__842 {
    PTHREAD_CANCEL_DEFERRED___22 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___22 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./vp8i.h"
enum __anonenum__848 {
    B_DC_PRED___21 = 0,
    B_TM_PRED___21 = 1,
    B_VE_PRED___21 = 2,
    B_HE_PRED___21 = 3,
    B_RD_PRED___21 = 4,
    B_VR_PRED___21 = 5,
    B_LD_PRED___21 = 6,
    B_VL_PRED___21 = 7,
    B_HD_PRED___21 = 8,
    B_HU_PRED___21 = 9,
    NUM_BMODES___21 = 10,
    DC_PRED___21 = 0,
    V_PRED___21 = 2,
    H_PRED___21 = 3,
    TM_PRED___21 = 1,
    B_PRED___6 = 10,
    B_DC_PRED_NOTOP___6 = 4,
    B_DC_PRED_NOLEFT___6 = 5,
    B_DC_PRED_NOTOPLEFT___6 = 6,
    NUM_B_DC_MODES___6 = 7
} ;
#line 59
enum __anonenum__849 {
    MB_FEATURE_TREE_PROBS___6 = 3,
    NUM_MB_SEGMENTS___21 = 4,
    NUM_REF_LF_DELTAS___6 = 4,
    NUM_MODE_LF_DELTAS___6 = 4,
    MAX_NUM_PARTITIONS___21 = 8,
    NUM_TYPES___21 = 4,
    NUM_BANDS___21 = 8,
    NUM_CTX___21 = 3,
    NUM_PROBAS___21 = 11,
    NUM_MV_PROBAS___6 = 19
} ;
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
enum __anonenum__859 {
    STATE_PRE_VP8 = 0,
    STATE_VP8_FRAME_HEADER = 1,
    STATE_VP8_PARTS0 = 2,
    STATE_VP8_DATA = 3,
    STATE_VP8L_HEADER = 4,
    STATE_VP8L_DATA = 5,
    STATE_DONE = 6,
    STATE_ERROR = 7
} ;
#line 43 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
typedef enum __anonenum__859 DecState;
#line 46
enum __anonenum__860 {
    MEM_MODE_NONE = 0,
    MEM_MODE_APPEND = 1,
    MEM_MODE_MAP = 2
} ;
#line 50 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
typedef enum __anonenum__860 MemBufferMode;
#line 53 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
struct __anonstruct_861 {
   MemBufferMode mode_ ;
   size_t start_ ;
   size_t end_ ;
   size_t buf_size_ ;
   uint8_t *buf_ ;
   size_t part0_size_ ;
   uint8_t *part0_buf_ ;
};
#line 62 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
typedef struct __anonstruct_861 MemBuffer;
#line 64 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
struct WebPIDecoder {
   DecState state_ ;
   WebPDecParams params_ ;
   int is_lossless_ ;
   void *dec_ ;
   VP8Io io_ ;
   MemBuffer mem_ ;
   WebPDecBuffer output_ ;
   size_t chunk_size_ ;
};
#line 77 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
struct __anonstruct_862 {
   VP8MB left_ ;
   VP8MB info_ ;
   uint8_t intra_t_[4] ;
   uint8_t intra_l_[4] ;
   VP8BitReader br_ ;
   VP8BitReader token_br_ ;
};
#line 84 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
typedef struct __anonstruct_862 MBContext;
#line 33 "/usr/include/pthread.h"
enum __anonenum__666___1 {
    PTHREAD_CREATE_JOINABLE___23 = 0,
    PTHREAD_CREATE_DETACHED___23 = 1
} ;
#line 43
enum __anonenum__667___1 {
    PTHREAD_MUTEX_TIMED_NP___23 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___23 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___23 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___23 = 3,
    PTHREAD_MUTEX_NORMAL___23 = 0,
    PTHREAD_MUTEX_RECURSIVE___23 = 1,
    PTHREAD_MUTEX_ERRORCHECK___23 = 2,
    PTHREAD_MUTEX_DEFAULT___23 = 0
} ;
#line 65
enum __anonenum__668___1 {
    PTHREAD_MUTEX_STALLED___23 = 0,
    PTHREAD_MUTEX_STALLED_NP___23 = 0,
    PTHREAD_MUTEX_ROBUST___23 = 1,
    PTHREAD_MUTEX_ROBUST_NP___23 = 1
} ;
#line 77
enum __anonenum__669___1 {
    PTHREAD_PRIO_NONE___23 = 0,
    PTHREAD_PRIO_INHERIT___23 = 1,
    PTHREAD_PRIO_PROTECT___23 = 2
} ;
#line 100
enum __anonenum__670___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___23 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___23 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___23 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___23 = 0
} ;
#line 120
enum __anonenum__671___1 {
    PTHREAD_INHERIT_SCHED___23 = 0,
    PTHREAD_EXPLICIT_SCHED___23 = 1
} ;
#line 130
enum __anonenum__672___1 {
    PTHREAD_SCOPE_SYSTEM___23 = 0,
    PTHREAD_SCOPE_PROCESS___23 = 1
} ;
#line 140
enum __anonenum__673___1 {
    PTHREAD_PROCESS_PRIVATE___23 = 0,
    PTHREAD_PROCESS_SHARED___23 = 1
} ;
#line 164
enum __anonenum__674___1 {
    PTHREAD_CANCEL_ENABLE___23 = 0,
    PTHREAD_CANCEL_DISABLE___23 = 1
} ;
#line 171
enum __anonenum__675___1 {
    PTHREAD_CANCEL_DEFERRED___23 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___23 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./vp8i.h"
enum __anonenum__681___1 {
    B_DC_PRED___22 = 0,
    B_TM_PRED___22 = 1,
    B_VE_PRED___22 = 2,
    B_HE_PRED___22 = 3,
    B_RD_PRED___22 = 4,
    B_VR_PRED___22 = 5,
    B_LD_PRED___22 = 6,
    B_VL_PRED___22 = 7,
    B_HD_PRED___22 = 8,
    B_HU_PRED___22 = 9,
    NUM_BMODES___22 = 10,
    DC_PRED___22 = 0,
    V_PRED___22 = 2,
    H_PRED___22 = 3,
    TM_PRED___22 = 1,
    B_PRED___7 = 10,
    B_DC_PRED_NOTOP___7 = 4,
    B_DC_PRED_NOLEFT___7 = 5,
    B_DC_PRED_NOTOPLEFT___7 = 6,
    NUM_B_DC_MODES___7 = 7
} ;
#line 59
enum __anonenum__682___1 {
    MB_FEATURE_TREE_PROBS___7 = 3,
    NUM_MB_SEGMENTS___22 = 4,
    NUM_REF_LF_DELTAS___7 = 4,
    NUM_MODE_LF_DELTAS___7 = 4,
    MAX_NUM_PARTITIONS___22 = 8,
    NUM_TYPES___22 = 4,
    NUM_BANDS___22 = 8,
    NUM_CTX___22 = 3,
    NUM_PROBAS___22 = 11,
    NUM_MV_PROBAS___7 = 19
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__666___2 {
    PTHREAD_CREATE_JOINABLE___24 = 0,
    PTHREAD_CREATE_DETACHED___24 = 1
} ;
#line 43
enum __anonenum__667___2 {
    PTHREAD_MUTEX_TIMED_NP___24 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___24 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___24 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___24 = 3,
    PTHREAD_MUTEX_NORMAL___24 = 0,
    PTHREAD_MUTEX_RECURSIVE___24 = 1,
    PTHREAD_MUTEX_ERRORCHECK___24 = 2,
    PTHREAD_MUTEX_DEFAULT___24 = 0
} ;
#line 65
enum __anonenum__668___2 {
    PTHREAD_MUTEX_STALLED___24 = 0,
    PTHREAD_MUTEX_STALLED_NP___24 = 0,
    PTHREAD_MUTEX_ROBUST___24 = 1,
    PTHREAD_MUTEX_ROBUST_NP___24 = 1
} ;
#line 77
enum __anonenum__669___2 {
    PTHREAD_PRIO_NONE___24 = 0,
    PTHREAD_PRIO_INHERIT___24 = 1,
    PTHREAD_PRIO_PROTECT___24 = 2
} ;
#line 100
enum __anonenum__670___2 {
    PTHREAD_RWLOCK_PREFER_READER_NP___24 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___24 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___24 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___24 = 0
} ;
#line 120
enum __anonenum__671___2 {
    PTHREAD_INHERIT_SCHED___24 = 0,
    PTHREAD_EXPLICIT_SCHED___24 = 1
} ;
#line 130
enum __anonenum__672___2 {
    PTHREAD_SCOPE_SYSTEM___24 = 0,
    PTHREAD_SCOPE_PROCESS___24 = 1
} ;
#line 140
enum __anonenum__673___2 {
    PTHREAD_PROCESS_PRIVATE___24 = 0,
    PTHREAD_PROCESS_SHARED___24 = 1
} ;
#line 164
enum __anonenum__674___2 {
    PTHREAD_CANCEL_ENABLE___24 = 0,
    PTHREAD_CANCEL_DISABLE___24 = 1
} ;
#line 171
enum __anonenum__675___2 {
    PTHREAD_CANCEL_DEFERRED___24 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___24 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./vp8i.h"
enum __anonenum__681___2 {
    B_DC_PRED___23 = 0,
    B_TM_PRED___23 = 1,
    B_VE_PRED___23 = 2,
    B_HE_PRED___23 = 3,
    B_RD_PRED___23 = 4,
    B_VR_PRED___23 = 5,
    B_LD_PRED___23 = 6,
    B_VL_PRED___23 = 7,
    B_HD_PRED___23 = 8,
    B_HU_PRED___23 = 9,
    NUM_BMODES___23 = 10,
    DC_PRED___23 = 0,
    V_PRED___23 = 2,
    H_PRED___23 = 3,
    TM_PRED___23 = 1,
    B_PRED___8 = 10,
    B_DC_PRED_NOTOP___8 = 4,
    B_DC_PRED_NOLEFT___8 = 5,
    B_DC_PRED_NOTOPLEFT___8 = 6,
    NUM_B_DC_MODES___8 = 7
} ;
#line 59
enum __anonenum__682___2 {
    MB_FEATURE_TREE_PROBS___8 = 3,
    NUM_MB_SEGMENTS___23 = 4,
    NUM_REF_LF_DELTAS___8 = 4,
    NUM_MODE_LF_DELTAS___8 = 4,
    MAX_NUM_PARTITIONS___23 = 8,
    NUM_TYPES___23 = 4,
    NUM_BANDS___23 = 8,
    NUM_CTX___23 = 3,
    NUM_PROBAS___23 = 11,
    NUM_MV_PROBAS___8 = 19
} ;
#line 33 "/usr/include/pthread.h"
enum __anonenum__666___3 {
    PTHREAD_CREATE_JOINABLE___25 = 0,
    PTHREAD_CREATE_DETACHED___25 = 1
} ;
#line 43
enum __anonenum__667___3 {
    PTHREAD_MUTEX_TIMED_NP___25 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___25 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___25 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___25 = 3,
    PTHREAD_MUTEX_NORMAL___25 = 0,
    PTHREAD_MUTEX_RECURSIVE___25 = 1,
    PTHREAD_MUTEX_ERRORCHECK___25 = 2,
    PTHREAD_MUTEX_DEFAULT___25 = 0
} ;
#line 65
enum __anonenum__668___3 {
    PTHREAD_MUTEX_STALLED___25 = 0,
    PTHREAD_MUTEX_STALLED_NP___25 = 0,
    PTHREAD_MUTEX_ROBUST___25 = 1,
    PTHREAD_MUTEX_ROBUST_NP___25 = 1
} ;
#line 77
enum __anonenum__669___3 {
    PTHREAD_PRIO_NONE___25 = 0,
    PTHREAD_PRIO_INHERIT___25 = 1,
    PTHREAD_PRIO_PROTECT___25 = 2
} ;
#line 100
enum __anonenum__670___3 {
    PTHREAD_RWLOCK_PREFER_READER_NP___25 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___25 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___25 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___25 = 0
} ;
#line 120
enum __anonenum__671___3 {
    PTHREAD_INHERIT_SCHED___25 = 0,
    PTHREAD_EXPLICIT_SCHED___25 = 1
} ;
#line 130
enum __anonenum__672___3 {
    PTHREAD_SCOPE_SYSTEM___25 = 0,
    PTHREAD_SCOPE_PROCESS___25 = 1
} ;
#line 140
enum __anonenum__673___3 {
    PTHREAD_PROCESS_PRIVATE___25 = 0,
    PTHREAD_PROCESS_SHARED___25 = 1
} ;
#line 164
enum __anonenum__674___3 {
    PTHREAD_CANCEL_ENABLE___25 = 0,
    PTHREAD_CANCEL_DISABLE___25 = 1
} ;
#line 171
enum __anonenum__675___3 {
    PTHREAD_CANCEL_DEFERRED___25 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___25 = 1
} ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./vp8i.h"
enum __anonenum__681___3 {
    B_DC_PRED___24 = 0,
    B_TM_PRED___24 = 1,
    B_VE_PRED___24 = 2,
    B_HE_PRED___24 = 3,
    B_RD_PRED___24 = 4,
    B_VR_PRED___24 = 5,
    B_LD_PRED___24 = 6,
    B_VL_PRED___24 = 7,
    B_HD_PRED___24 = 8,
    B_HU_PRED___24 = 9,
    NUM_BMODES___24 = 10,
    DC_PRED___24 = 0,
    V_PRED___24 = 2,
    H_PRED___24 = 3,
    TM_PRED___24 = 1,
    B_PRED___9 = 10,
    B_DC_PRED_NOTOP___9 = 4,
    B_DC_PRED_NOLEFT___9 = 5,
    B_DC_PRED_NOTOPLEFT___9 = 6,
    NUM_B_DC_MODES___9 = 7
} ;
#line 59
enum __anonenum__682___3 {
    MB_FEATURE_TREE_PROBS___9 = 3,
    NUM_MB_SEGMENTS___24 = 4,
    NUM_REF_LF_DELTAS___9 = 4,
    NUM_MODE_LF_DELTAS___9 = 4,
    MAX_NUM_PARTITIONS___24 = 8,
    NUM_TYPES___24 = 4,
    NUM_BANDS___24 = 8,
    NUM_CTX___24 = 3,
    NUM_PROBAS___24 = 11,
    NUM_MV_PROBAS___9 = 19
} ;
#line 17 "/doner/libwebp/libwebp-v0.3.0/examples/./wicdec.h"
struct Metadata ;
#line 66 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef signed char int8;
#line 67 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned char uint8;
#line 69 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef short int16;
#line 70 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned short uint16;
#line 72 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef int int32;
#line 73 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned int uint32;
#line 75 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef long int64;
#line 76 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef unsigned long uint64;
#line 86 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef int uint16_vap;
#line 91 "/usr/include/x86_64-linux-gnu/tiff.h"
struct __anonenum__168 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
};
#line 94 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef struct __anonenum__168 TIFFHeaderCommon;
#line 95 "/usr/include/x86_64-linux-gnu/tiff.h"
struct __anonstruct_867 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
   uint32 tiff_diroff ;
};
#line 99 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef struct __anonstruct_867 TIFFHeaderClassic;
#line 100 "/usr/include/x86_64-linux-gnu/tiff.h"
struct __anonstruct_868 {
   uint16 tiff_magic ;
   uint16 tiff_version ;
   uint16 tiff_offsetsize ;
   uint16 tiff_unused ;
   uint64 tiff_diroff ;
};
#line 106 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef struct __anonstruct_868 TIFFHeaderBig;
#line 123
enum __anonenum__869 {
    TIFF_NOTYPE = 0,
    TIFF_BYTE = 1,
    TIFF_ASCII = 2,
    TIFF_SHORT = 3,
    TIFF_LONG = 4,
    TIFF_RATIONAL = 5,
    TIFF_SBYTE = 6,
    TIFF_UNDEFINED = 7,
    TIFF_SSHORT = 8,
    TIFF_SLONG = 9,
    TIFF_SRATIONAL = 10,
    TIFF_FLOAT = 11,
    TIFF_DOUBLE = 12,
    TIFF_IFD = 13,
    TIFF_LONG8 = 16,
    TIFF_SLONG8 = 17,
    TIFF_IFD8 = 18
} ;
#line 141 "/usr/include/x86_64-linux-gnu/tiff.h"
typedef enum __anonenum__869 TIFFDataType;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct tiff ;
#line 38 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct tiff TIFF;
#line 65 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef long tmsize_t;
#line 66 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint64 toff_t;
#line 69 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 ttag_t;
#line 70 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint16 tdir_t;
#line 71 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint16 tsample_t;
#line 72 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef uint32 tstrile_t;
#line 73 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t tstrip_t;
#line 74 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tstrile_t ttile_t;
#line 75 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t tsize_t;
#line 76 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *tdata_t;
#line 104 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void *thandle_t;
#line 136 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef unsigned char TIFFRGBValue;
#line 138 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_870 {
   float d_mat[3][3] ;
   float d_YCR ;
   float d_YCG ;
   float d_YCB ;
   uint32 d_Vrwr ;
   uint32 d_Vrwg ;
   uint32 d_Vrwb ;
   float d_Y0R ;
   float d_Y0G ;
   float d_Y0B ;
   float d_gammaR ;
   float d_gammaG ;
   float d_gammaB ;
};
#line 152 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_870 TIFFDisplay;
#line 154 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_871 {
   TIFFRGBValue *clamptab ;
   int *Cr_r_tab ;
   int *Cb_b_tab ;
   int32 *Cr_g_tab ;
   int32 *Cb_g_tab ;
   int32 *Y_tab ;
};
#line 161 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_871 TIFFYCbCrToRGB;
#line 163 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_872 {
   int range ;
   float rstep ;
   float gstep ;
   float bstep ;
   float X0 ;
   float Y0 ;
   float Z0 ;
   TIFFDisplay display ;
   float Yr2r[1501] ;
   float Yg2g[1501] ;
   float Yb2b[1501] ;
};
#line 172 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_872 TIFFCIELabToRGB;
#line 177
struct _TIFFRGBAImage ;
#line 177 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct _TIFFRGBAImage TIFFRGBAImage;
#line 188 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*tileContigRoutine)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ,
                                  uint32  , uint32  , int32  , int32  , unsigned char * );
#line 191 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*tileSeparateRoutine)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ,
                                    uint32  , uint32  , int32  , int32  , unsigned char * ,
                                    unsigned char * , unsigned char * , unsigned char * );
#line 215 "/usr/include/x86_64-linux-gnu/tiffio.h"
union __anonunion_873 {
   void (*any)(TIFFRGBAImage * ) ;
   tileContigRoutine contig ;
   tileSeparateRoutine separate ;
};
#line 197 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct _TIFFRGBAImage {
   TIFF *tif ;
   int stoponerr ;
   int isContig ;
   int alpha ;
   uint32 width ;
   uint32 height ;
   uint16 bitspersample ;
   uint16 samplesperpixel ;
   uint16 orientation ;
   uint16 req_orientation ;
   uint16 photometric ;
   uint16 *redcmap ;
   uint16 *greencmap ;
   uint16 *bluecmap ;
   int (*get)(TIFFRGBAImage * , uint32 * , uint32  , uint32  ) ;
   union __anonunion_873 put ;
   TIFFRGBValue *Map ;
   uint32 **BWmap ;
   uint32 **PALmap ;
   TIFFYCbCrToRGB *ycbcr ;
   TIFFCIELabToRGB *cielab ;
   uint8 *UaToAa ;
   uint8 *Bitdepth16To8 ;
   int row_offset ;
   int col_offset ;
};
#line 249 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFInitMethod)(TIFF * , int  );
#line 250 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_874 {
   char *name ;
   uint16 scheme ;
   TIFFInitMethod init ;
};
#line 254 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_874 TIFFCodec;
#line 271 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFErrorHandler)(char const   * , char const   * , va_list  );
#line 272 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFErrorHandlerExt)(thandle_t  , char const   * , char const   * ,
                                    va_list  );
#line 273 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef tmsize_t (*TIFFReadWriteProc)(thandle_t  , void * , tmsize_t  );
#line 274 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef toff_t (*TIFFSeekProc)(thandle_t  , toff_t  , int  );
#line 275 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFCloseProc)(thandle_t  );
#line 276 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef toff_t (*TIFFSizeProc)(thandle_t  );
#line 277 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFMapFileProc)(thandle_t  , void ** , toff_t * );
#line 278 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFUnmapFileProc)(thandle_t  , void * , toff_t  );
#line 279 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFExtendProc)(TIFF * );
#line 314
struct _TIFFField ;
#line 314 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct _TIFFField TIFFField;
#line 315
struct _TIFFFieldArray ;
#line 315 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct _TIFFFieldArray TIFFFieldArray;
#line 328 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFVSetMethod)(TIFF * , uint32  , va_list  );
#line 329 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef int (*TIFFVGetMethod)(TIFF * , uint32  , va_list  );
#line 330 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef void (*TIFFPrintMethod)(TIFF * , FILE * , long  );
#line 332 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_875 {
   TIFFVSetMethod vsetfield ;
   TIFFVGetMethod vgetfield ;
   TIFFPrintMethod printdir ;
};
#line 336 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_875 TIFFTagMethods;
#line 542 "/usr/include/x86_64-linux-gnu/tiffio.h"
struct __anonstruct_876 {
   ttag_t field_tag ;
   short field_readcount ;
   short field_writecount ;
   TIFFDataType field_type ;
   unsigned short field_bit ;
   unsigned char field_oktochange ;
   unsigned char field_passcount ;
   char *field_name ;
};
#line 551 "/usr/include/x86_64-linux-gnu/tiffio.h"
typedef struct __anonstruct_876 TIFFFieldInfo;
#line 20 "/doner/libwebp/libwebp-v0.3.0/examples/./metadata.h"
struct MetadataPayload {
   uint8_t *bytes ;
   size_t size ;
};
#line 23 "/doner/libwebp/libwebp-v0.3.0/examples/./metadata.h"
typedef struct MetadataPayload MetadataPayload;
#line 25 "/doner/libwebp/libwebp-v0.3.0/examples/./metadata.h"
struct Metadata {
   MetadataPayload exif ;
   MetadataPayload iccp ;
   MetadataPayload xmp ;
};
#line 29 "/doner/libwebp/libwebp-v0.3.0/examples/./metadata.h"
typedef struct Metadata Metadata;
#line 24 "/doner/libwebp/libwebp-v0.3.0/examples/tiffdec.c"
struct __anonstruct_879 {
   ttag_t tag ;
   size_t storage_offset ;
};
#line 51 "/usr/include/jmorecfg.h"
typedef unsigned char JSAMPLE;
#line 91 "/usr/include/jmorecfg.h"
typedef short JCOEF;
#line 102 "/usr/include/jmorecfg.h"
typedef unsigned char JOCTET;
#line 127 "/usr/include/jmorecfg.h"
typedef unsigned char UINT8;
#line 139 "/usr/include/jmorecfg.h"
typedef unsigned short UINT16;
#line 147 "/usr/include/jmorecfg.h"
typedef short INT16;
#line 179 "/usr/include/jmorecfg.h"
typedef long INT32;
#line 194 "/usr/include/jmorecfg.h"
typedef unsigned int JDIMENSION;
#line 242 "/usr/include/jmorecfg.h"
typedef int boolean;
#line 69 "/usr/include/jpeglib.h"
typedef JSAMPLE *JSAMPROW;
#line 70 "/usr/include/jpeglib.h"
typedef JSAMPROW *JSAMPARRAY;
#line 71 "/usr/include/jpeglib.h"
typedef JSAMPARRAY *JSAMPIMAGE;
#line 73 "/usr/include/jpeglib.h"
typedef JCOEF JBLOCK[64];
#line 74 "/usr/include/jpeglib.h"
typedef JBLOCK *JBLOCKROW;
#line 75 "/usr/include/jpeglib.h"
typedef JBLOCKROW *JBLOCKARRAY;
#line 76 "/usr/include/jpeglib.h"
typedef JBLOCKARRAY *JBLOCKIMAGE;
#line 78 "/usr/include/jpeglib.h"
typedef JCOEF *JCOEFPTR;
#line 86 "/usr/include/jpeglib.h"
struct __anonstruct_881 {
   UINT16 quantval[64] ;
   boolean sent_table ;
};
#line 98 "/usr/include/jpeglib.h"
typedef struct __anonstruct_881 JQUANT_TBL;
#line 103 "/usr/include/jpeglib.h"
struct __anonstruct_882 {
   UINT8 bits[17] ;
   UINT8 huffval[256] ;
   boolean sent_table ;
};
#line 114 "/usr/include/jpeglib.h"
typedef struct __anonstruct_882 JHUFF_TBL;
#line 119 "/usr/include/jpeglib.h"
struct __anonstruct_883 {
   int component_id ;
   int component_index ;
   int h_samp_factor ;
   int v_samp_factor ;
   int quant_tbl_no ;
   int dc_tbl_no ;
   int ac_tbl_no ;
   JDIMENSION width_in_blocks ;
   JDIMENSION height_in_blocks ;
   int DCT_h_scaled_size ;
   int DCT_v_scaled_size ;
   JDIMENSION downsampled_width ;
   JDIMENSION downsampled_height ;
   boolean component_needed ;
   int MCU_width ;
   int MCU_height ;
   int MCU_blocks ;
   int MCU_sample_width ;
   int last_col_width ;
   int last_row_height ;
   JQUANT_TBL *quant_table ;
   void *dct_table ;
};
#line 187 "/usr/include/jpeglib.h"
typedef struct __anonstruct_883 jpeg_component_info;
#line 192 "/usr/include/jpeglib.h"
struct __anonstruct_884 {
   int comps_in_scan ;
   int component_index[4] ;
   int Ss ;
   int Se ;
   int Ah ;
   int Al ;
};
#line 197 "/usr/include/jpeglib.h"
typedef struct __anonstruct_884 jpeg_scan_info;
#line 201
struct jpeg_marker_struct ;
#line 201 "/usr/include/jpeglib.h"
typedef struct jpeg_marker_struct *jpeg_saved_marker_ptr;
#line 203 "/usr/include/jpeglib.h"
struct jpeg_marker_struct {
   jpeg_saved_marker_ptr next ;
   UINT8 marker ;
   unsigned int original_length ;
   unsigned int data_length ;
   JOCTET *data ;
};
#line 217
enum __anonenum__885 {
    JCS_UNKNOWN = 0,
    JCS_GRAYSCALE = 1,
    JCS_RGB = 2,
    JCS_YCbCr = 3,
    JCS_CMYK = 4,
    JCS_YCCK = 5,
    JCS_EXT_RGB = 6,
    JCS_EXT_RGBX = 7,
    JCS_EXT_BGR = 8,
    JCS_EXT_BGRX = 9,
    JCS_EXT_XBGR = 10,
    JCS_EXT_XRGB = 11,
    JCS_EXT_RGBA = 12,
    JCS_EXT_BGRA = 13,
    JCS_EXT_ABGR = 14,
    JCS_EXT_ARGB = 15,
    JCS_RGB565 = 16
} ;
#line 242 "/usr/include/jpeglib.h"
typedef enum __anonenum__885 J_COLOR_SPACE;
#line 246
enum __anonenum__886 {
    JDCT_ISLOW = 0,
    JDCT_IFAST = 1,
    JDCT_FLOAT = 2
} ;
#line 250 "/usr/include/jpeglib.h"
typedef enum __anonenum__886 J_DCT_METHOD;
#line 261
enum __anonenum__887 {
    JDITHER_NONE = 0,
    JDITHER_ORDERED = 1,
    JDITHER_FS = 2
} ;
#line 265 "/usr/include/jpeglib.h"
typedef enum __anonenum__887 J_DITHER_MODE;
#line 283
struct jpeg_error_mgr ;
#line 283
struct jpeg_memory_mgr ;
#line 283
struct jpeg_progress_mgr ;
#line 282 "/usr/include/jpeglib.h"
struct jpeg_common_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
};
#line 290 "/usr/include/jpeglib.h"
typedef struct jpeg_common_struct *j_common_ptr;
#line 291
struct jpeg_compress_struct ;
#line 291 "/usr/include/jpeglib.h"
typedef struct jpeg_compress_struct *j_compress_ptr;
#line 292
struct jpeg_decompress_struct ;
#line 292 "/usr/include/jpeglib.h"
typedef struct jpeg_decompress_struct *j_decompress_ptr;
#line 301
struct jpeg_destination_mgr ;
#line 456
struct jpeg_comp_master ;
#line 457
struct jpeg_c_main_controller ;
#line 458
struct jpeg_c_prep_controller ;
#line 459
struct jpeg_c_coef_controller ;
#line 460
struct jpeg_marker_writer ;
#line 461
struct jpeg_color_converter ;
#line 462
struct jpeg_downsampler ;
#line 463
struct jpeg_forward_dct ;
#line 464
struct jpeg_entropy_encoder ;
#line 297 "/usr/include/jpeglib.h"
struct jpeg_compress_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
   struct jpeg_destination_mgr *dest ;
   JDIMENSION image_width ;
   JDIMENSION image_height ;
   int input_components ;
   J_COLOR_SPACE in_color_space ;
   double input_gamma ;
   unsigned int scale_num ;
   unsigned int scale_denom ;
   JDIMENSION jpeg_width ;
   JDIMENSION jpeg_height ;
   int data_precision ;
   int num_components ;
   J_COLOR_SPACE jpeg_color_space ;
   jpeg_component_info *comp_info ;
   JQUANT_TBL *quant_tbl_ptrs[4] ;
   int q_scale_factor[4] ;
   JHUFF_TBL *dc_huff_tbl_ptrs[4] ;
   JHUFF_TBL *ac_huff_tbl_ptrs[4] ;
   UINT8 arith_dc_L[16] ;
   UINT8 arith_dc_U[16] ;
   UINT8 arith_ac_K[16] ;
   int num_scans ;
   jpeg_scan_info *scan_info ;
   boolean raw_data_in ;
   boolean arith_code ;
   boolean optimize_coding ;
   boolean CCIR601_sampling ;
   boolean do_fancy_downsampling ;
   int smoothing_factor ;
   J_DCT_METHOD dct_method ;
   unsigned int restart_interval ;
   int restart_in_rows ;
   boolean write_JFIF_header ;
   UINT8 JFIF_major_version ;
   UINT8 JFIF_minor_version ;
   UINT8 density_unit ;
   UINT16 X_density ;
   UINT16 Y_density ;
   boolean write_Adobe_marker ;
   JDIMENSION next_scanline ;
   boolean progressive_mode ;
   int max_h_samp_factor ;
   int max_v_samp_factor ;
   int min_DCT_h_scaled_size ;
   int min_DCT_v_scaled_size ;
   JDIMENSION total_iMCU_rows ;
   int comps_in_scan ;
   jpeg_component_info *cur_comp_info[4] ;
   JDIMENSION MCUs_per_row ;
   JDIMENSION MCU_rows_in_scan ;
   int blocks_in_MCU ;
   int MCU_membership[10] ;
   int Ss ;
   int Se ;
   int Ah ;
   int Al ;
   int block_size ;
   int const   *natural_order ;
   int lim_Se ;
   struct jpeg_comp_master *master ;
   struct jpeg_c_main_controller *main ;
   struct jpeg_c_prep_controller *prep ;
   struct jpeg_c_coef_controller *coef ;
   struct jpeg_marker_writer *marker ;
   struct jpeg_color_converter *cconvert ;
   struct jpeg_downsampler *downsample ;
   struct jpeg_forward_dct *fdct ;
   struct jpeg_entropy_encoder *entropy ;
   jpeg_scan_info *script_space ;
   int script_space_size ;
};
#line 476
struct jpeg_source_mgr ;
#line 696
struct jpeg_decomp_master ;
#line 697
struct jpeg_d_main_controller ;
#line 698
struct jpeg_d_coef_controller ;
#line 699
struct jpeg_d_post_controller ;
#line 700
struct jpeg_input_controller ;
#line 701
struct jpeg_marker_reader ;
#line 702
struct jpeg_entropy_decoder ;
#line 703
struct jpeg_inverse_dct ;
#line 704
struct jpeg_upsampler ;
#line 705
struct jpeg_color_deconverter ;
#line 706
struct jpeg_color_quantizer ;
#line 472 "/usr/include/jpeglib.h"
struct jpeg_decompress_struct {
   struct jpeg_error_mgr *err ;
   struct jpeg_memory_mgr *mem ;
   struct jpeg_progress_mgr *progress ;
   void *client_data ;
   boolean is_decompressor ;
   int global_state ;
   struct jpeg_source_mgr *src ;
   JDIMENSION image_width ;
   JDIMENSION image_height ;
   int num_components ;
   J_COLOR_SPACE jpeg_color_space ;
   J_COLOR_SPACE out_color_space ;
   unsigned int scale_num ;
   unsigned int scale_denom ;
   double output_gamma ;
   boolean buffered_image ;
   boolean raw_data_out ;
   J_DCT_METHOD dct_method ;
   boolean do_fancy_upsampling ;
   boolean do_block_smoothing ;
   boolean quantize_colors ;
   J_DITHER_MODE dither_mode ;
   boolean two_pass_quantize ;
   int desired_number_of_colors ;
   boolean enable_1pass_quant ;
   boolean enable_external_quant ;
   boolean enable_2pass_quant ;
   JDIMENSION output_width ;
   JDIMENSION output_height ;
   int out_color_components ;
   int output_components ;
   int rec_outbuf_height ;
   int actual_number_of_colors ;
   JSAMPARRAY colormap ;
   JDIMENSION output_scanline ;
   int input_scan_number ;
   JDIMENSION input_iMCU_row ;
   int output_scan_number ;
   JDIMENSION output_iMCU_row ;
   int (*coef_bits)[64] ;
   JQUANT_TBL *quant_tbl_ptrs[4] ;
   JHUFF_TBL *dc_huff_tbl_ptrs[4] ;
   JHUFF_TBL *ac_huff_tbl_ptrs[4] ;
   int data_precision ;
   jpeg_component_info *comp_info ;
   boolean is_baseline ;
   boolean progressive_mode ;
   boolean arith_code ;
   UINT8 arith_dc_L[16] ;
   UINT8 arith_dc_U[16] ;
   UINT8 arith_ac_K[16] ;
   unsigned int restart_interval ;
   boolean saw_JFIF_marker ;
   UINT8 JFIF_major_version ;
   UINT8 JFIF_minor_version ;
   UINT8 density_unit ;
   UINT16 X_density ;
   UINT16 Y_density ;
   boolean saw_Adobe_marker ;
   UINT8 Adobe_transform ;
   boolean CCIR601_sampling ;
   jpeg_saved_marker_ptr marker_list ;
   int max_h_samp_factor ;
   int max_v_samp_factor ;
   int min_DCT_h_scaled_size ;
   int min_DCT_v_scaled_size ;
   JDIMENSION total_iMCU_rows ;
   JSAMPLE *sample_range_limit ;
   int comps_in_scan ;
   jpeg_component_info *cur_comp_info[4] ;
   JDIMENSION MCUs_per_row ;
   JDIMENSION MCU_rows_in_scan ;
   int blocks_in_MCU ;
   int MCU_membership[10] ;
   int Ss ;
   int Se ;
   int Ah ;
   int Al ;
   int block_size ;
   int const   *natural_order ;
   int lim_Se ;
   int unread_marker ;
   struct jpeg_decomp_master *master ;
   struct jpeg_d_main_controller *main ;
   struct jpeg_d_coef_controller *coef ;
   struct jpeg_d_post_controller *post ;
   struct jpeg_input_controller *inputctl ;
   struct jpeg_marker_reader *marker ;
   struct jpeg_entropy_decoder *entropy ;
   struct jpeg_inverse_dct *idct ;
   struct jpeg_upsampler *upsample ;
   struct jpeg_color_deconverter *cconvert ;
   struct jpeg_color_quantizer *cquantize ;
};
#line 738 "/usr/include/jpeglib.h"
union __anonunion_888 {
   int i[8] ;
   char s[80] ;
};
#line 720 "/usr/include/jpeglib.h"
struct jpeg_error_mgr {
   void (*error_exit)(j_common_ptr  ) ;
   void (*emit_message)(j_common_ptr  , int  ) ;
   void (*output_message)(j_common_ptr  ) ;
   void (*format_message)(j_common_ptr  , char * ) ;
   void (*reset_error_mgr)(j_common_ptr  ) ;
   int msg_code ;
   union __anonunion_888 msg_parm ;
   int trace_level ;
   long num_warnings ;
   char const   * const  *jpeg_message_table ;
   int last_jpeg_message ;
   char const   * const  *addon_message_table ;
   int first_addon_message ;
   int last_addon_message ;
};
#line 778 "/usr/include/jpeglib.h"
struct jpeg_progress_mgr {
   void (*progress_monitor)(j_common_ptr  ) ;
   long pass_counter ;
   long pass_limit ;
   int completed_passes ;
   int total_passes ;
};
#line 790 "/usr/include/jpeglib.h"
struct jpeg_destination_mgr {
   JOCTET *next_output_byte ;
   size_t free_in_buffer ;
   void (*init_destination)(j_compress_ptr  ) ;
   boolean (*empty_output_buffer)(j_compress_ptr  ) ;
   void (*term_destination)(j_compress_ptr  ) ;
};
#line 802 "/usr/include/jpeglib.h"
struct jpeg_source_mgr {
   JOCTET *next_input_byte ;
   size_t bytes_in_buffer ;
   void (*init_source)(j_decompress_ptr  ) ;
   boolean (*fill_input_buffer)(j_decompress_ptr  ) ;
   void (*skip_input_data)(j_decompress_ptr  , long  ) ;
   boolean (*resync_to_restart)(j_decompress_ptr  , int  ) ;
   void (*term_source)(j_decompress_ptr  ) ;
};
#line 829
struct jvirt_sarray_control ;
#line 829 "/usr/include/jpeglib.h"
typedef struct jvirt_sarray_control *jvirt_sarray_ptr;
#line 830
struct jvirt_barray_control ;
#line 830 "/usr/include/jpeglib.h"
typedef struct jvirt_barray_control *jvirt_barray_ptr;
#line 833 "/usr/include/jpeglib.h"
struct jpeg_memory_mgr {
   void *(*alloc_small)(j_common_ptr  , int  , size_t  ) ;
   void *(*alloc_large)(j_common_ptr  , int  , size_t  ) ;
   JSAMPARRAY (*alloc_sarray)(j_common_ptr  , int  , JDIMENSION  , JDIMENSION  ) ;
   JBLOCKARRAY (*alloc_barray)(j_common_ptr  , int  , JDIMENSION  , JDIMENSION  ) ;
   jvirt_sarray_ptr (*request_virt_sarray)(j_common_ptr  , int  , boolean  , JDIMENSION  ,
                                           JDIMENSION  , JDIMENSION  ) ;
   jvirt_barray_ptr (*request_virt_barray)(j_common_ptr  , int  , boolean  , JDIMENSION  ,
                                           JDIMENSION  , JDIMENSION  ) ;
   void (*realize_virt_arrays)(j_common_ptr  ) ;
   JSAMPARRAY (*access_virt_sarray)(j_common_ptr  , jvirt_sarray_ptr  , JDIMENSION  ,
                                    JDIMENSION  , boolean  ) ;
   JBLOCKARRAY (*access_virt_barray)(j_common_ptr  , jvirt_barray_ptr  , JDIMENSION  ,
                                     JDIMENSION  , boolean  ) ;
   void (*free_pool)(j_common_ptr  , int  ) ;
   void (*self_destruct)(j_common_ptr  ) ;
   long max_memory_to_use ;
   long max_alloc_chunk ;
};
#line 877 "/usr/include/jpeglib.h"
typedef boolean (*jpeg_marker_parser_method)(j_decompress_ptr  );
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 83 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 37 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
struct __anonstruct_906 {
   uint8_t *data ;
   size_t data_length ;
   int seq ;
};
#line 41 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
typedef struct __anonstruct_906 ICCPSegment;
#line 198 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
struct my_error_mgr {
   struct jpeg_error_mgr pub ;
   jmp_buf setjmp_buffer ;
};
#line 148 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
struct __anonstruct_907 {
   int marker ;
   char const   *signature ;
   size_t signature_length ;
   size_t storage_offset ;
};
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 89
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 36 "/doner/libwebp/libwebp-v0.3.0/examples/./stopwatch.h"
typedef struct timeval Stopwatch;
#line 103 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
enum __anonenum__926 {
    PNG_ = 0,
    JPEG_ = 1,
    TIFF_ = 2,
    UNSUPPORTED = 3
} ;
#line 108 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
typedef enum __anonenum__926 InputFileFormat;
#line 367
enum __anonenum__927 {
    METADATA_EXIF = 1,
    METADATA_ICC = 2,
    METADATA_XMP = 4,
    METADATA_ALL = 7
} ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 290 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t imaxabs(intmax_t __n ) ;
#line 293
extern  __attribute__((__nothrow__)) imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) ;
#line 297
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   *nptr , char **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t strtoumax(char const   *nptr , char **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t wcstoimax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t wcstoumax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/utils/./utils.h"
void *WebPSafeMalloc(uint64_t nmemb , size_t size ) ;
#line 39
void *WebPSafeCalloc(uint64_t nmemb , size_t size ) ;
#line 45 "/doner/libwebp/libwebp-v0.3.0/src/utils/./utils.h"
__inline static int GetLE16(uint8_t *data ) 
{ 


  {
#line 46
  return ((int )((int )*(data + 0)) | ((int )*(data + 1) << 8));
}
}
#line 49 "/doner/libwebp/libwebp-v0.3.0/src/utils/./utils.h"
__inline static int GetLE24(uint8_t *data ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 50
  __cil_tmp2 = GetLE16(data);
  }
#line 50
  return (__cil_tmp2 | ((int )*(data + 2) << 16));
}
}
#line 53 "/doner/libwebp/libwebp-v0.3.0/src/utils/./utils.h"
__inline static uint32_t GetLE32(uint8_t *data ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 54
  __cil_tmp3 = GetLE16(data + 2);
  }
  {
#line 54
  __cil_tmp2 = GetLE16(data);
  }
#line 54
  return ((uint32_t )__cil_tmp2 | (unsigned int )(__cil_tmp3 << 16));
}
}
#line 58 "/doner/libwebp/libwebp-v0.3.0/src/utils/./utils.h"
__inline static void PutLE16(uint8_t *data , int val ) 
{ 
  int tmp ;

  {
#line 60
  *(data + 0) = (uint8_t )val;
#line 61
  *(data + 1) = (uint8_t )(val >> 8);
  return;
}
}
#line 64 "/doner/libwebp/libwebp-v0.3.0/src/utils/./utils.h"
__inline static void PutLE24(uint8_t *data , int val ) 
{ 
  int tmp ;

  {
  {
#line 66
  PutLE16(data, val & 65535);
#line 67
  *(data + 2) = (uint8_t )(val >> 16);
  }
  return;
}
}
#line 70 "/doner/libwebp/libwebp-v0.3.0/src/utils/./utils.h"
__inline static void PutLE32(uint8_t *data , uint32_t val ) 
{ 


  {
  {
#line 71
  PutLE16(data, (int )(val & 65535U));
#line 72
  PutLE16(data + 2, (int )(val >> 16));
  }
  return;
}
}
#line 23 "/doner/libwebp/libwebp-v0.3.0/src/utils/utils.c"
static int CheckSizeArgumentsOverflow(uint64_t nmemb , size_t size ) 
{ 
  uint64_t total_size ;

  {
#line 24
  total_size = nmemb * size;
#line 25
  if (nmemb == 0UL) {
#line 25
    return (1);
  }
#line 26
  if ((unsigned long long )((uint64_t )size) > (1ULL << 40) / (unsigned long long )nmemb) {
#line 26
    return (0);
  }
#line 27
  if (total_size != (size_t )total_size) {
#line 27
    return (0);
  }
#line 28
  return (1);
}
}
#line 31 "/doner/libwebp/libwebp-v0.3.0/src/utils/utils.c"
void *WebPSafeMalloc(uint64_t nmemb , size_t size ) 
{ 
  int __cil_tmp3 ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 32
  __cil_tmp3 = CheckSizeArgumentsOverflow(nmemb, size);
  }
#line 32
  if (! __cil_tmp3) {
#line 32
    return ((void *)0);
  }
  {
#line 34
  __cil_tmp5 = malloc((size_t )(nmemb * size));
  }
#line 34
  return (__cil_tmp5);
}
}
#line 37 "/doner/libwebp/libwebp-v0.3.0/src/utils/utils.c"
void *WebPSafeCalloc(uint64_t nmemb , size_t size ) 
{ 
  int __cil_tmp3 ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 38
  __cil_tmp3 = CheckSizeArgumentsOverflow(nmemb, size);
  }
#line 38
  if (! __cil_tmp3) {
#line 38
    return ((void *)0);
  }
  {
#line 40
  __cil_tmp5 = calloc((size_t )nmemb, size);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t *__setp ) ;
#line 119
extern  __attribute__((__nothrow__)) cpu_set_t *__sched_cpualloc(size_t __count ) ;
#line 120
extern  __attribute__((__nothrow__)) void __sched_cpufree(cpu_set_t *__set ) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param *__param ) ;
#line 58
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 61
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param *__param ) ;
#line 65
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 68
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 71
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 74
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 77
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 174
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 193
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 257
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 198 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 207
extern void pthread_exit(void *__retval ) ;
#line 215
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 247
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 251
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 254
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 263
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 266
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 270
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t *__attr ,
                                                                     int *__detachstate ) ;
#line 275
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 281
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t *__attr ,
                                                                   size_t *__guardsize ) ;
#line 286
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 302
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t *__attr ,
                                                                     int *__policy ) ;
#line 307
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy ) ;
#line 311
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t *__attr ,
                                                                      int *__inherit ) ;
#line 316
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 322
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t *__attr ,
                                                               int *__scope ) ;
#line 327
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope ) ;
#line 331
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t *__attr ,
                                                                   void **__stackaddr ) ;
#line 339
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr ) ;
#line 344
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t *__attr ,
                                                                   size_t *__stacksize ) ;
#line 351
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 357
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t *__attr ,
                                                               void **__stackaddr ,
                                                               size_t *__stacksize ) ;
#line 365
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize ) ;
#line 405
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param *__param ) ;
#line 410
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int *__policy , struct sched_param *__param ) ;
#line 416
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 470
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 482
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 486
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 489
extern int pthread_cancel(pthread_t __th ) ;
#line 494
extern void pthread_testcancel(void) ;
#line 656
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 668
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) ;
#line 719
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 725
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 730
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 734
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
#line 738
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 743
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t *__mutex ,
                                                                 struct timespec *__abstime ) ;
#line 756
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 761
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t *__mutex ,
                                                                      int *__prioceiling ) ;
#line 768
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex ,
                                                                      int __prioceiling ,
                                                                      int *__old_ceiling ) ;
#line 776
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent(pthread_mutex_t *__mutex ) ;
#line 789
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
#line 793
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
#line 797
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t *__attr ,
                                                                      int *__pshared ) ;
#line 803
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared ) ;
#line 809
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t *__attr ,
                                                                   int *__kind ) ;
#line 816
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind ) ;
#line 821
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t *__attr ,
                                                                       int *__protocol ) ;
#line 828
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol ) ;
#line 833
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int *__prioceiling ) ;
#line 839
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling ) ;
#line 845
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust(pthread_mutexattr_t *__attr ,
                                                                     int *__robustness ) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr ,
                                                                     int __robustness ) ;
#line 871
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t *__rwlock ,
                                                             pthread_rwlockattr_t *__attr ) ;
#line 876
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 880
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 884
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
#line 889
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 902
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 906
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
#line 911
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 924
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 931
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr ) ;
#line 935
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr ) ;
#line 939
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *__attr ,
                                                                       int *__pshared ) ;
#line 945
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared ) ;
#line 950
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int *__pref ) ;
#line 956
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref ) ;
#line 965
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 970
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 974
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 978
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 986
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 997
extern int pthread_cond_timedwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  struct timespec *__abstime ) ;
#line 1020
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
#line 1024
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
#line 1028
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t *__attr ,
                                                                     int *__pshared ) ;
#line 1034
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared ) ;
#line 1039
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t *__clock_id ) ;
#line 1045
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id ) ;
#line 1056
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared ) ;
#line 1060
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock ) ;
#line 1064
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock ) ;
#line 1068
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock ) ;
#line 1072
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock ) ;
#line 1080
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t *__barrier ,
                                                              pthread_barrierattr_t *__attr ,
                                                              unsigned int __count ) ;
#line 1086
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier ) ;
#line 1090
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier ) ;
#line 1095
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr ) ;
#line 1099
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr ) ;
#line 1103
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t *__attr ,
                                                                        int *__pshared ) ;
#line 1109
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared ) ;
#line 1123
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 1128
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1131
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1134
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1140
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id ) ;
#line 1157
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1165
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 1165 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
#line 1167
  return (__thread1 == __thread2);
}
}
#line 69 "/doner/libwebp/libwebp-v0.3.0/src/utils/./thread.h"
void WebPWorkerInit(WebPWorker *worker ) ;
#line 72
int WebPWorkerReset(WebPWorker *worker ) ;
#line 75
int WebPWorkerSync(WebPWorker *worker ) ;
#line 79
void WebPWorkerLaunch(WebPWorker *worker ) ;
#line 82
void WebPWorkerEnd(WebPWorker *worker ) ;
#line 134 "/doner/libwebp/libwebp-v0.3.0/src/utils/thread.c"
static void *WebPWorkerThreadLoop(void *ptr ) 
{ 
  WebPWorker *worker ;
  int done___0 ;
  int __cil_tmp4 ;

  {
#line 135
  worker = (WebPWorker *)ptr;
#line 136
  done___0 = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (! done___0)) {
#line 137
      goto while_break;
    }
    {
#line 138
    pthread_mutex_lock(& worker->mutex_);
    }
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 139
      if (! ((unsigned int )worker->status_ == 1U)) {
#line 139
        goto while_break___0;
      }
      {
#line 140
      pthread_cond_wait(& worker->condition_, & worker->mutex_);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 142
    if ((unsigned int )worker->status_ == 2U) {
#line 143
      if (worker->hook) {
        {
#line 144
        __cil_tmp4 = (*(worker->hook))(worker->data1, worker->data2);
        }
#line 144
        worker->had_error |= ! __cil_tmp4;
      }
#line 146
      worker->status_ = (WebPWorkerStatus )1;
    } else
#line 147
    if ((unsigned int )worker->status_ == 0U) {
#line 148
      done___0 = 1;
    }
    {
#line 151
    pthread_cond_signal(& worker->condition_);
#line 152
    pthread_mutex_unlock(& worker->mutex_);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return ((void *)0);
}
}
#line 158 "/doner/libwebp/libwebp-v0.3.0/src/utils/thread.c"
static void WebPWorkerChangeState(WebPWorker *worker , WebPWorkerStatus new_status ) 
{ 


  {
#line 161
  if ((unsigned int )worker->status_ < 1U) {
#line 161
    return;
  }
  {
#line 163
  pthread_mutex_lock(& worker->mutex_);
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((unsigned int )worker->status_ != 1U)) {
#line 165
      goto while_break;
    }
    {
#line 166
    pthread_cond_wait(& worker->condition_, & worker->mutex_);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  if ((unsigned int )new_status != 1U) {
    {
#line 170
    worker->status_ = new_status;
#line 171
    pthread_cond_signal(& worker->condition_);
    }
  }
  {
#line 173
  pthread_mutex_unlock(& worker->mutex_);
  }
  return;
}
}
#line 180 "/doner/libwebp/libwebp-v0.3.0/src/utils/thread.c"
void WebPWorkerInit(WebPWorker *worker ) 
{ 


  {
  {
#line 181
  memset(worker, 0, sizeof(*worker));
#line 182
  worker->status_ = (WebPWorkerStatus )0;
  }
  return;
}
}
#line 185 "/doner/libwebp/libwebp-v0.3.0/src/utils/thread.c"
int WebPWorkerSync(WebPWorker *worker ) 
{ 
  int tmp ;

  {
  {
#line 187
  WebPWorkerChangeState(worker, (WebPWorkerStatus )1);
  }
#line 190
  return (! worker->had_error);
}
}
#line 193 "/doner/libwebp/libwebp-v0.3.0/src/utils/thread.c"
int WebPWorkerReset(WebPWorker *worker ) 
{ 
  int ok ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int tmp ;

  {
#line 194
  ok = 1;
#line 195
  worker->had_error = 0;
#line 196
  if ((unsigned int )worker->status_ < 1U) {
    {
#line 198
    __cil_tmp4 = pthread_cond_init(& worker->condition_, (pthread_condattr_t *)((void *)0));
    }
    {
#line 198
    __cil_tmp3 = pthread_mutex_init(& worker->mutex_, (pthread_mutexattr_t *)((void *)0));
    }
#line 198
    if (__cil_tmp3) {
#line 200
      return (0);
    } else
#line 198
    if (__cil_tmp4) {
#line 200
      return (0);
    }
    {
#line 202
    pthread_mutex_lock(& worker->mutex_);
#line 203
    __cil_tmp5 = pthread_create(& worker->thread_, (pthread_attr_t *)((void *)0),
                                & WebPWorkerThreadLoop, worker);
#line 203
    ok = ! __cil_tmp5;
    }
#line 204
    if (ok) {
#line 204
      worker->status_ = (WebPWorkerStatus )1;
    }
    {
#line 205
    pthread_mutex_unlock(& worker->mutex_);
    }
  } else
#line 209
  if ((unsigned int )worker->status_ > 1U) {
    {
#line 210
    ok = WebPWorkerSync(worker);
    }
  }
#line 213
  return (ok);
}
}
#line 216 "/doner/libwebp/libwebp-v0.3.0/src/utils/thread.c"
void WebPWorkerLaunch(WebPWorker *worker ) 
{ 


  {
  {
#line 218
  WebPWorkerChangeState(worker, (WebPWorkerStatus )2);
  }
  return;
}
}
#line 225 "/doner/libwebp/libwebp-v0.3.0/src/utils/thread.c"
void WebPWorkerEnd(WebPWorker *worker ) 
{ 
  int tmp ;

  {
#line 226
  if ((unsigned int )worker->status_ >= 1U) {
    {
#line 228
    WebPWorkerChangeState(worker, (WebPWorkerStatus )0);
#line 229
    pthread_join(worker->thread_, (void **)((void *)0));
#line 230
    pthread_mutex_destroy(& worker->mutex_);
#line 231
    pthread_cond_destroy(& worker->condition_);
    }
  }
  return;
}
}
#line 39 "/doner/libwebp/libwebp-v0.3.0/src/utils/./rescaler.h"
void WebPRescalerInit(WebPRescaler *wrk , int src_width , int src_height , uint8_t *dst ,
                      int dst_width , int dst_height , int dst_stride , int num_channels ,
                      int x_add , int x_sub , int y_add , int y_sub , int32_t *work ) ;
#line 49
void WebPRescalerImportRow(WebPRescaler *wrk , uint8_t *src , int channel ) ;
#line 54
int WebPRescalerImport(WebPRescaler *wrk , int num_lines , uint8_t *src , int src_stride ) ;
#line 59 "/doner/libwebp/libwebp-v0.3.0/src/utils/./rescaler.h"
__inline static int WebPRescalerHasPendingOutput(WebPRescaler *rescaler ) 
{ 


  {
#line 60
  return (rescaler->y_accum <= 0);
}
}
#line 65
uint8_t *WebPRescalerExportRow(WebPRescaler *wrk ) ;
#line 68
int WebPRescalerExport(WebPRescaler *rescaler ) ;
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/utils/rescaler.c"
void WebPRescalerInit(WebPRescaler *wrk , int src_width , int src_height , uint8_t *dst ,
                      int dst_width , int dst_height , int dst_stride , int num_channels ,
                      int x_add , int x_sub , int y_add , int y_sub , int32_t *work ) 
{ 
  int tmp ;
  int tmp___0 ;
  int64_t tmp___1 ;

  {
#line 29
  wrk->x_expand = src_width < dst_width;
#line 30
  wrk->src_width = src_width;
#line 31
  wrk->src_height = src_height;
#line 32
  wrk->dst_width = dst_width;
#line 33
  wrk->dst_height = dst_height;
#line 34
  wrk->dst = dst;
#line 35
  wrk->dst_stride = dst_stride;
#line 36
  wrk->num_channels = num_channels;
#line 38
  if (wrk->x_expand) {
#line 38
    tmp = x_sub - 1;
  } else {
#line 38
    tmp = x_add - x_sub;
  }
#line 38
  wrk->x_add = tmp;
#line 39
  if (wrk->x_expand) {
#line 39
    tmp___0 = x_add - 1;
  } else {
#line 39
    tmp___0 = x_sub;
  }
#line 39
  wrk->x_sub = tmp___0;
#line 40
  wrk->y_accum = y_add;
#line 41
  wrk->y_add = y_add;
#line 42
  wrk->y_sub = y_sub;
#line 43
  wrk->fx_scale = (1 << 30) / x_sub;
#line 44
  wrk->fy_scale = (1 << 30) / y_sub;
#line 45
  if (wrk->x_expand) {
#line 45
    tmp___1 = ((int64_t )dst_height << 30) / (long )(x_sub * src_height);
  } else {
#line 45
    tmp___1 = ((int64_t )dst_height << 30) / (long )(x_add * src_height);
  }
#line 45
  wrk->fxy_scale = tmp___1;
#line 48
  wrk->irow = work;
#line 49
  wrk->frow = work + num_channels * dst_width;
  return;
}
}
#line 52 "/doner/libwebp/libwebp-v0.3.0/src/utils/rescaler.c"
void WebPRescalerImportRow(WebPRescaler *wrk , uint8_t *src , int channel ) 
{ 
  int x_stride ;
  int x_out_max ;
  int x_in ;
  int x_out ;
  int accum ;
  int sum ;
  int32_t base ;
  int32_t frac ;
  int left ;
  int right ;

  {
#line 54
  x_stride = wrk->num_channels;
#line 55
  x_out_max = wrk->dst_width * wrk->num_channels;
#line 56
  x_in = channel;
#line 58
  accum = 0;
#line 59
  if (! wrk->x_expand) {
#line 60
    sum = 0;
#line 61
    x_out = channel;
    {
#line 61
    while (1) {
      while_continue: /* CIL Label */ ;
#line 61
      if (! (x_out < x_out_max)) {
#line 61
        goto while_break;
      }
#line 62
      accum += wrk->x_add;
      {
#line 63
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 63
        if (! (accum > 0)) {
#line 63
          goto while_break___0;
        }
#line 64
        sum += (int )*(src + x_in);
#line 65
        x_in += x_stride;
#line 63
        accum -= wrk->x_sub;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      base = (int32_t )*(src + x_in);
#line 69
      frac = base * - accum;
#line 70
      x_in += x_stride;
#line 71
      *(wrk->frow + x_out) = (sum + base) * wrk->x_sub - frac;
#line 73
      sum = (int )(((int64_t )frac * (long )wrk->fx_scale + (long )(1 << 29)) >> 30);
#line 61
      x_out += x_stride;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 77
    left = (int )*(src + channel);
#line 77
    right = (int )*(src + channel);
#line 78
    x_out = channel;
    {
#line 78
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 78
      if (! (x_out < x_out_max)) {
#line 78
        goto while_break___1;
      }
#line 79
      if (accum < 0) {
#line 80
        left = right;
#line 81
        x_in += x_stride;
#line 82
        right = (int )*(src + x_in);
#line 83
        accum += wrk->x_add;
      }
#line 85
      *(wrk->frow + x_out) = right * wrk->x_add + (left - right) * accum;
#line 86
      accum -= wrk->x_sub;
#line 78
      x_out += x_stride;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 90
  x_out = channel;
  {
#line 90
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 90
    if (! (x_out < x_out_max)) {
#line 90
      goto while_break___2;
    }
#line 91
    *(wrk->irow + x_out) += *(wrk->frow + x_out);
#line 90
    x_out += x_stride;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 95 "/doner/libwebp/libwebp-v0.3.0/src/utils/rescaler.c"
uint8_t *WebPRescalerExportRow(WebPRescaler *wrk ) 
{ 
  int x_out ;
  uint8_t *dst ;
  int32_t *irow ;
  int32_t *frow ;
  int yscale ;
  int x_out_max ;
  int frac ;
  int v ;
  int tmp ;
  int tmp___0 ;

  {
#line 96
  if (wrk->y_accum <= 0) {
#line 98
    dst = wrk->dst;
#line 99
    irow = wrk->irow;
#line 100
    frow = wrk->frow;
#line 101
    yscale = wrk->fy_scale * - wrk->y_accum;
#line 102
    x_out_max = wrk->dst_width * wrk->num_channels;
#line 104
    x_out = 0;
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! (x_out < x_out_max)) {
#line 104
        goto while_break;
      }
#line 105
      frac = (int )(((int64_t )*(frow + x_out) * (long )yscale + (long )(1 << 29)) >> 30);
#line 106
      v = (int )(((int64_t )(*(irow + x_out) - frac) * wrk->fxy_scale + (long )(1 << 29)) >> 30);
#line 107
      if (! (v & -256)) {
#line 107
        tmp___0 = v;
      } else {
#line 107
        if (v < 0) {
#line 107
          tmp = 0;
        } else {
#line 107
          tmp = 255;
        }
#line 107
        tmp___0 = tmp;
      }
#line 107
      *(dst + x_out) = (uint8_t )tmp___0;
#line 108
      *(irow + x_out) = frac;
#line 104
      x_out ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 110
    wrk->y_accum += wrk->y_add;
#line 111
    wrk->dst += wrk->dst_stride;
#line 112
    return (dst);
  } else {
#line 114
    return ((uint8_t *)((void *)0));
  }
}
}
#line 124 "/doner/libwebp/libwebp-v0.3.0/src/utils/rescaler.c"
int WebPRescalerImport(WebPRescaler *wrk , int num_lines , uint8_t *src , int src_stride ) 
{ 
  int total_imported ;
  int channel ;

  {
#line 126
  total_imported = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (total_imported < num_lines && wrk->y_accum > 0)) {
#line 127
      goto while_break;
    }
#line 129
    channel = 0;
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! (channel < wrk->num_channels)) {
#line 129
        goto while_break___0;
      }
      {
#line 130
      WebPRescalerImportRow(wrk, src, channel);
      }
#line 129
      channel ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 132
    src += src_stride;
#line 133
    total_imported ++;
#line 134
    wrk->y_accum -= wrk->y_sub;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return (total_imported);
}
}
#line 139 "/doner/libwebp/libwebp-v0.3.0/src/utils/rescaler.c"
int WebPRescalerExport(WebPRescaler *rescaler ) 
{ 
  int total_exported ;
  int __cil_tmp3 ;

  {
#line 140
  total_exported = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    __cil_tmp3 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 141
    if (! __cil_tmp3) {
#line 141
      goto while_break;
    }
    {
#line 142
    WebPRescalerExportRow(rescaler);
#line 143
    total_exported ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (total_exported);
}
}
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/utils/./quant_levels_dec.h"
int DequantizeLevels(uint8_t *data , int width , int height ) ;
#line 18 "/doner/libwebp/libwebp-v0.3.0/src/utils/quant_levels_dec.c"
int DequantizeLevels(uint8_t *data , int width , int height ) 
{ 


  {
#line 19
  if (data == (void *)0) {
#line 19
    return (0);
  } else
#line 19
  if (width <= 0) {
#line 19
    return (0);
  } else
#line 19
  if (height <= 0) {
#line 19
    return (0);
  }
#line 23
  return (1);
}
}
#line 27 "/doner/libwebp/libwebp-v0.3.0/src/utils/./quant_levels.h"
int QuantizeLevels(uint8_t *data , int width , int height , int num_levels , uint64_t *sse ) ;
#line 29 "/doner/libwebp/libwebp-v0.3.0/src/utils/quant_levels.c"
int QuantizeLevels(uint8_t *data , int width , int height , int num_levels , uint64_t *sse ) 
{ 
  int freq[256] ;
  unsigned int tmp ;
  int q_level[256] ;
  unsigned int tmp___0 ;
  double inv_q_level[256] ;
  unsigned int tmp___1 ;
  int min_s ;
  int max_s ;
  size_t data_size ;
  int i ;
  int num_levels_in ;
  int iter ;
  double last_err ;
  double err ;
  double err_threshold ;
  size_t n ;
  int tmp___2 ;
  int tmp___3 ;
  double q_sum[256] ;
  unsigned int tmp___4 ;
  double q_count[256] ;
  unsigned int tmp___5 ;
  int s ;
  int slot ;
  double count ;
  double error ;
  uint8_t map[256] ;
  int s___0 ;
  size_t n___0 ;
  int slot___0 ;

  {
#line 31
  freq[0] = 0;
#line 31
  tmp = (unsigned int )1;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (tmp >= 256) {
#line 31
      goto while_break;
    }
#line 31
    freq[tmp] = 0;
#line 31
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  q_level[0] = 0;
#line 32
  tmp___0 = (unsigned int )1;
  {
#line 32
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 32
    if (tmp___0 >= 256) {
#line 32
      goto while_break___0;
    }
#line 32
    q_level[tmp___0] = 0;
#line 32
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 33
  inv_q_level[0] = (double )0;
#line 33
  tmp___1 = (unsigned int )1;
  {
#line 33
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 33
    if (tmp___1 >= 256) {
#line 33
      goto while_break___1;
    }
#line 33
    inv_q_level[tmp___1] = 0;
#line 33
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 34
  min_s = 255;
#line 34
  max_s = 0;
#line 35
  data_size = (size_t )(height * width);
#line 37
  last_err = 1e+38;
#line 37
  err = 0.;
#line 38
  err_threshold = 0.000100000000001 * (double )data_size;
#line 40
  if (data == (void *)0) {
#line 41
    return (0);
  }
#line 44
  if (width <= 0) {
#line 45
    return (0);
  } else
#line 44
  if (height <= 0) {
#line 45
    return (0);
  }
#line 48
  if (num_levels < 2) {
#line 49
    return (0);
  } else
#line 48
  if (num_levels > 256) {
#line 49
    return (0);
  }
#line 54
  num_levels_in = 0;
#line 55
  n = (size_t )0;
  {
#line 55
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 55
    if (! (n < data_size)) {
#line 55
      goto while_break___2;
    }
#line 56
    num_levels_in += freq[*(data + n)] == 0;
#line 57
    if (min_s > (int )*(data + n)) {
#line 57
      min_s = (int )*(data + n);
    }
#line 58
    if (max_s < (int )*(data + n)) {
#line 58
      max_s = (int )*(data + n);
    }
#line 59
    (freq[*(data + n)]) ++;
#line 55
    n ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 63
  if (num_levels_in <= num_levels) {
#line 63
    goto End;
  }
#line 66
  i = 0;
  {
#line 66
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 66
    if (! (i < num_levels)) {
#line 66
      goto while_break___3;
    }
#line 67
    inv_q_level[i] = (double )min_s + ((double )(max_s - min_s) * (double )i) / (double )(num_levels - 1);
#line 66
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 71
  q_level[min_s] = 0;
#line 72
  q_level[max_s] = num_levels - 1;
#line 77
  iter = 0;
  {
#line 77
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 77
    if (! (iter < 6)) {
#line 77
      goto while_break___4;
    }
#line 78
    q_sum[0] = (double )0;
#line 78
    tmp___4 = (unsigned int )1;
    {
#line 78
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 78
      if (tmp___4 >= 256) {
#line 78
        goto while_break___5;
      }
#line 78
      q_sum[tmp___4] = 0;
#line 78
      tmp___4 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 79
    q_count[0] = (double )0;
#line 79
    tmp___5 = (unsigned int )1;
    {
#line 79
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 79
      if (tmp___5 >= 256) {
#line 79
        goto while_break___6;
      }
#line 79
      q_count[tmp___5] = 0;
#line 79
      tmp___5 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 80
    slot = 0;
#line 83
    s = min_s;
    {
#line 83
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 83
      if (! (s <= max_s)) {
#line 83
        goto while_break___7;
      }
      {
#line 85
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 85
        if (! (slot < num_levels - 1 && (double )(2 * s) > inv_q_level[slot] + inv_q_level[slot + 1])) {
#line 85
          goto while_break___8;
        }
#line 87
        slot ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 89
      if (freq[s] > 0) {
#line 90
        q_sum[slot] += (double )(s * freq[s]);
#line 91
        q_count[slot] += (double )freq[s];
      }
#line 93
      q_level[s] = slot;
#line 83
      s ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 97
    if (num_levels > 2) {
#line 98
      slot = 1;
      {
#line 98
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 98
        if (! (slot < num_levels - 1)) {
#line 98
          goto while_break___9;
        }
#line 99
        count = q_count[slot];
#line 100
        if (count > 0.) {
#line 101
          inv_q_level[slot] = q_sum[slot] / count;
        }
#line 98
        slot ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 107
    err = 0.;
#line 108
    s = min_s;
    {
#line 108
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 108
      if (! (s <= max_s)) {
#line 108
        goto while_break___10;
      }
#line 109
      error = (double )s - inv_q_level[q_level[s]];
#line 110
      err += ((double )freq[s] * error) * error;
#line 108
      s ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 115
    if (last_err - err < err_threshold) {
#line 115
      goto while_break___4;
    }
#line 116
    last_err = err;
#line 77
    iter ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 127
  s___0 = min_s;
  {
#line 127
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 127
    if (! (s___0 <= max_s)) {
#line 127
      goto while_break___11;
    }
#line 128
    slot___0 = q_level[s___0];
#line 129
    map[s___0] = (uint8_t )(inv_q_level[slot___0] + 0.5);
#line 127
    s___0 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 132
  n___0 = (size_t )0;
  {
#line 132
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 132
    if (! (n___0 < data_size)) {
#line 132
      goto while_break___12;
    }
#line 133
    *(data + n___0) = map[*(data + n___0)];
#line 132
    n___0 ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  End: 
#line 138
  if (sse != (void *)0) {
#line 138
    *sse = (uint64_t )err;
  }
#line 140
  return (1);
}
}
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman_encode.h"
int VP8LCreateCompressedHuffmanTree(HuffmanTreeCode *tree , HuffmanTreeToken *tokens ,
                                    int max_tokens ) ;
#line 40
int VP8LCreateHuffmanTree(int *histogram , int tree_depth_limit , HuffmanTreeCode *tree ) ;
#line 23 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static int ValuesShouldBeCollapsedToStrideAverage(int a , int b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 24
  __cil_tmp3 = abs(a - b);
  }
#line 24
  return (__cil_tmp3 < 4);
}
}
#line 29 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static int OptimizeHuffmanForRle(int length , int *counts ) 
{ 
  uint8_t *good_for_rle ;
  int i ;
  void *__cil_tmp5 ;
  int symbol ;
  int stride ;
  int k ;
  int stride___0 ;
  int limit ;
  int sum ;
  int __cil_tmp12 ;
  int k___0 ;
  int count ;

  {
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! (length >= 0)) {
#line 33
      goto while_break;
    }
#line 34
    if (length == 0) {
#line 35
      return (1);
    }
#line 37
    if (*(counts + (length - 1)) != 0) {
#line 39
      goto while_break;
    }
#line 33
    length --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  __cil_tmp5 = calloc((unsigned long )length, (unsigned long )1);
#line 44
  good_for_rle = (uint8_t *)__cil_tmp5;
  }
#line 45
  if (good_for_rle == (void *)0) {
#line 46
    return (0);
  }
#line 52
  symbol = *(counts + 0);
#line 53
  stride = 0;
#line 54
  i = 0;
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! (i < length + 1)) {
#line 54
      goto while_break___0;
    }
#line 55
    if (i == length) {
      _L___1: /* CIL Label */ 
#line 56
      if (symbol == 0) {
#line 56
        if (stride >= 5) {
          _L: /* CIL Label */ 
#line 59
          k = 0;
          {
#line 59
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 59
            if (! (k < stride)) {
#line 59
              goto while_break___1;
            }
#line 60
            *(good_for_rle + ((i - k) - 1)) = (uint8_t )1;
#line 59
            k ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 56
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 56
      if (symbol != 0) {
#line 56
        if (stride >= 7) {
#line 56
          goto _L;
        }
      }
#line 63
      stride = 1;
#line 64
      if (i != length) {
#line 65
        symbol = *(counts + i);
      }
    } else
#line 55
    if (*(counts + i) != symbol) {
#line 55
      goto _L___1;
    } else {
#line 68
      stride ++;
    }
#line 54
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 74
  stride___0 = 0;
#line 75
  limit = *(counts + 0);
#line 76
  sum = 0;
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 77
    if (! (i < length + 1)) {
#line 77
      goto while_break___2;
    }
    {
#line 78
    __cil_tmp12 = ValuesShouldBeCollapsedToStrideAverage(*(counts + i), limit);
    }
#line 78
    if (i == length) {
      _L___3: /* CIL Label */ 
      _L___4: /* CIL Label */ 
      _L___6: /* CIL Label */ 
#line 81
      if (stride___0 >= 4) {
        _L___2: /* CIL Label */ 
#line 84
        count = (sum + stride___0 / 2) / stride___0;
#line 85
        if (count < 1) {
#line 86
          count = 1;
        }
#line 88
        if (sum == 0) {
#line 90
          count = 0;
        }
#line 92
        k___0 = 0;
        {
#line 92
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 92
          if (! (k___0 < stride___0)) {
#line 92
            goto while_break___3;
          }
#line 95
          *(counts + ((i - k___0) - 1)) = count;
#line 92
          k___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 81
      if (stride___0 >= 3) {
#line 81
        if (sum == 0) {
#line 81
          goto _L___2;
        }
      }
#line 98
      stride___0 = 0;
#line 99
      sum = 0;
#line 100
      if (i < length - 3) {
#line 103
        limit = ((((*(counts + i) + *(counts + (i + 1))) + *(counts + (i + 2))) + *(counts + (i + 3))) + 2) / 4;
      } else
#line 105
      if (i < length) {
#line 106
        limit = *(counts + i);
      } else {
#line 108
        limit = 0;
      }
    } else
#line 78
    if ((int )*(good_for_rle + i)) {
#line 78
      goto _L___3;
    } else
#line 78
    if (i != 0) {
#line 78
      if ((int )*(good_for_rle + (i - 1))) {
#line 78
        goto _L___3;
      } else {
#line 78
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 78
    if (! __cil_tmp12) {
#line 78
      goto _L___3;
    }
#line 111
    stride___0 ++;
#line 112
    if (i != length) {
#line 113
      sum += *(counts + i);
#line 114
      if (stride___0 >= 4) {
#line 115
        limit = (sum + stride___0 / 2) / stride___0;
      }
    }
#line 77
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 120
  free(good_for_rle);
  }
#line 121
  return (1);
}
}
#line 133 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static int CompareHuffmanTrees(void const   *ptr1 , void const   *ptr2 ) 
{ 
  HuffmanTree *t1 ;
  HuffmanTree *t2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 134
  t1 = (HuffmanTree *)ptr1;
#line 135
  t2 = (HuffmanTree *)ptr2;
#line 136
  if (t1->total_count_ > t2->total_count_) {
#line 137
    return (- 1);
  } else
#line 138
  if (t1->total_count_ < t2->total_count_) {
#line 139
    return (1);
  } else {
#line 142
    if (t1->value_ < t2->value_) {
#line 142
      tmp___0 = - 1;
    } else {
#line 142
      tmp___0 = 1;
    }
#line 142
    return (tmp___0);
  }
}
}
#line 146 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static void SetBitDepths(HuffmanTree *tree , HuffmanTree *pool , uint8_t *bit_depths ,
                         int level ) 
{ 


  {
#line 149
  if (tree->pool_index_left_ >= 0) {
    {
#line 150
    SetBitDepths(pool + tree->pool_index_left_, pool, bit_depths, level + 1);
#line 151
    SetBitDepths(pool + tree->pool_index_right_, pool, bit_depths, level + 1);
    }
  } else {
#line 153
    *(bit_depths + tree->value_) = (uint8_t )level;
  }
  return;
}
}
#line 176 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static int GenerateOptimalTree(int const   *histogram , int histogram_size , int tree_depth_limit ,
                               uint8_t *bit_depths ) 
{ 
  int count_min ;
  HuffmanTree *tree_pool ;
  HuffmanTree *tree ;
  int tree_size_orig ;
  int i ;
  void *__cil_tmp10 ;
  int tmp ;
  int tree_size ;
  int idx ;
  int j ;
  int count ;
  int tmp___0 ;
  int tree_pool_size ;
  int count___0 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int k ;
  int max_depth ;

  {
#line 182
  tree_size_orig = 0;
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < histogram_size)) {
#line 185
      goto while_break;
    }
#line 186
    if (*(histogram + i) != 0) {
#line 187
      tree_size_orig ++;
    }
#line 185
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  if (tree_size_orig == 0) {
#line 192
    return (1);
  }
  {
#line 199
  __cil_tmp10 = WebPSafeMalloc((uint64_t )(3ULL * (unsigned long long )tree_size_orig),
                               sizeof(*tree));
#line 199
  tree = (HuffmanTree *)__cil_tmp10;
  }
#line 200
  if (tree == (void *)0) {
#line 200
    return (0);
  }
#line 201
  tree_pool = tree + tree_size_orig;
#line 208
  count_min = 1;
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 208
    if (! 1) {
#line 208
      goto while_break___0;
    }
#line 209
    tree_size = tree_size_orig;
#line 212
    idx = 0;
#line 214
    j = 0;
    {
#line 214
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 214
      if (! (j < histogram_size)) {
#line 214
        goto while_break___1;
      }
#line 215
      if (*(histogram + j) != 0) {
#line 216
        if (*(histogram + j) < count_min) {
#line 216
          tmp___0 = count_min;
        } else {
#line 216
          tmp___0 = (int )*(histogram + j);
        }
#line 216
        count = (int )tmp___0;
#line 218
        (tree + idx)->total_count_ = count;
#line 219
        (tree + idx)->value_ = j;
#line 220
        (tree + idx)->pool_index_left_ = - 1;
#line 221
        (tree + idx)->pool_index_right_ = - 1;
#line 222
        idx ++;
      }
#line 214
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 227
    qsort(tree, (size_t )tree_size, sizeof(*tree), & CompareHuffmanTrees);
    }
#line 229
    if (tree_size > 1) {
#line 230
      tree_pool_size = 0;
      {
#line 231
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 231
        if (! (tree_size > 1)) {
#line 231
          goto while_break___2;
        }
#line 233
        __cil_tmp19 = tree_pool_size;
#line 233
        tree_pool_size ++;
#line 233
        *(tree_pool + __cil_tmp19) = *(tree + (tree_size - 1));
#line 234
        __cil_tmp20 = tree_pool_size;
#line 234
        tree_pool_size ++;
#line 234
        *(tree_pool + __cil_tmp20) = *(tree + (tree_size - 2));
#line 235
        count___0 = (tree_pool + (tree_pool_size - 1))->total_count_ + (tree_pool + (tree_pool_size - 2))->total_count_;
#line 237
        tree_size -= 2;
#line 241
        k = 0;
        {
#line 241
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 241
          if (! (k < tree_size)) {
#line 241
            goto while_break___3;
          }
#line 242
          if ((tree + k)->total_count_ <= count___0) {
#line 243
            goto while_break___3;
          }
#line 241
          k ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 246
        memmove(tree + (k + 1), tree + k, (unsigned long )(tree_size - k) * sizeof(*tree));
#line 247
        (tree + k)->total_count_ = count___0;
#line 248
        (tree + k)->value_ = - 1;
#line 250
        (tree + k)->pool_index_left_ = tree_pool_size - 1;
#line 251
        (tree + k)->pool_index_right_ = tree_pool_size - 2;
#line 252
        tree_size ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 255
      SetBitDepths(tree + 0, tree_pool, bit_depths, 0);
      }
    } else
#line 256
    if (tree_size == 1) {
#line 257
      *(bit_depths + (tree + 0)->value_) = (uint8_t )1;
    }
#line 262
    max_depth = (int )*(bit_depths + 0);
#line 263
    j = 1;
    {
#line 263
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 263
      if (! (j < histogram_size)) {
#line 263
        goto while_break___4;
      }
#line 264
      if (max_depth < (int )*(bit_depths + j)) {
#line 265
        max_depth = (int )*(bit_depths + j);
      }
#line 263
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 268
    if (max_depth <= tree_depth_limit) {
#line 269
      goto while_break___0;
    }
#line 208
    count_min *= 2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 273
  free(tree);
  }
#line 274
  return (1);
}
}
#line 280 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static HuffmanTreeToken *CodeRepeatedValues(int repetitions , HuffmanTreeToken *tokens ,
                                            int value , int prev_value ) 
{ 
  int tmp ;
  int i ;

  {
#line 284
  if (value != prev_value) {
#line 285
    tokens->code = (uint8_t )value;
#line 286
    tokens->extra_bits = (uint8_t )0;
#line 287
    tokens ++;
#line 288
    repetitions --;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (repetitions >= 1)) {
#line 290
      goto while_break;
    }
#line 291
    if (repetitions < 3) {
#line 293
      i = 0;
      {
#line 293
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 293
        if (! (i < repetitions)) {
#line 293
          goto while_break___0;
        }
#line 294
        tokens->code = (uint8_t )value;
#line 295
        tokens->extra_bits = (uint8_t )0;
#line 296
        tokens ++;
#line 293
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 298
      goto while_break;
    } else
#line 299
    if (repetitions < 7) {
#line 300
      tokens->code = (uint8_t )16;
#line 301
      tokens->extra_bits = (uint8_t )(repetitions - 3);
#line 302
      tokens ++;
#line 303
      goto while_break;
    } else {
#line 305
      tokens->code = (uint8_t )16;
#line 306
      tokens->extra_bits = (uint8_t )3;
#line 307
      tokens ++;
#line 308
      repetitions -= 6;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return (tokens);
}
}
#line 314 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static HuffmanTreeToken *CodeRepeatedZeros(int repetitions , HuffmanTreeToken *tokens ) 
{ 
  int i ;

  {
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (repetitions >= 1)) {
#line 316
      goto while_break;
    }
#line 317
    if (repetitions < 3) {
#line 319
      i = 0;
      {
#line 319
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 319
        if (! (i < repetitions)) {
#line 319
          goto while_break___0;
        }
#line 320
        tokens->code = (uint8_t )0;
#line 321
        tokens->extra_bits = (uint8_t )0;
#line 322
        tokens ++;
#line 319
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 324
      goto while_break;
    } else
#line 325
    if (repetitions < 11) {
#line 326
      tokens->code = (uint8_t )17;
#line 327
      tokens->extra_bits = (uint8_t )(repetitions - 3);
#line 328
      tokens ++;
#line 329
      goto while_break;
    } else
#line 330
    if (repetitions < 139) {
#line 331
      tokens->code = (uint8_t )18;
#line 332
      tokens->extra_bits = (uint8_t )(repetitions - 11);
#line 333
      tokens ++;
#line 334
      goto while_break;
    } else {
#line 336
      tokens->code = (uint8_t )18;
#line 337
      tokens->extra_bits = (uint8_t )127;
#line 338
      tokens ++;
#line 339
      repetitions -= 138;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return (tokens);
}
}
#line 345 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
int VP8LCreateCompressedHuffmanTree(HuffmanTreeCode *tree , HuffmanTreeToken *tokens ,
                                    int max_tokens ) 
{ 
  HuffmanTreeToken *starting_token ;
  HuffmanTreeToken *ending_token ;
  int depth_size ;
  int prev_value ;
  int i ;
  int tmp ;
  int value ;
  int k ;
  int runs ;
  HuffmanTreeToken *__cil_tmp13 ;
  HuffmanTreeToken *__cil_tmp14 ;
  int tmp___0 ;

  {
#line 347
  starting_token = tokens;
#line 348
  ending_token = tokens + max_tokens;
#line 349
  depth_size = tree->num_symbols;
#line 350
  prev_value = 8;
#line 351
  i = 0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (i < depth_size)) {
#line 353
      goto while_break;
    }
#line 354
    value = (int )*(tree->code_lengths + i);
#line 355
    k = i + 1;
    {
#line 357
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 357
      if (! (k < depth_size && (int )*(tree->code_lengths + k) == value)) {
#line 357
        goto while_break___0;
      }
#line 357
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 358
    runs = k - i;
#line 359
    if (value == 0) {
      {
#line 360
      tokens = CodeRepeatedZeros(runs, tokens);
      }
    } else {
      {
#line 362
      tokens = CodeRepeatedValues(runs, tokens, value, prev_value);
#line 363
      prev_value = value;
      }
    }
#line 365
    i += runs;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return ((int )(tokens - starting_token));
}
}
#line 375 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static uint8_t kReversedBits[16]  = 
#line 375
  {      (uint8_t )0,      (uint8_t )8,      (uint8_t )4,      (uint8_t )12, 
        (uint8_t )2,      (uint8_t )10,      (uint8_t )6,      (uint8_t )14, 
        (uint8_t )1,      (uint8_t )9,      (uint8_t )5,      (uint8_t )13, 
        (uint8_t )3,      (uint8_t )11,      (uint8_t )7,      (uint8_t )15};
#line 380 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static uint32_t ReverseBits(int num_bits , uint32_t bits ) 
{ 
  uint32_t retval ;
  int i ;

  {
#line 381
  retval = (uint32_t )0;
#line 382
  i = 0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (i < num_bits)) {
#line 383
      goto while_break;
    }
#line 384
    i += 4;
#line 385
    retval |= (unsigned int )((int )kReversedBits[bits & 15U] << (16 - i));
#line 386
    bits >>= 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  retval >>= 16 - num_bits;
#line 389
  return (retval);
}
}
#line 393 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
static void ConvertBitDepthsToSymbols(HuffmanTreeCode *tree ) 
{ 
  int i ;
  int len ;
  uint32_t next_code[16] ;
  int depth_count[16] ;
  unsigned int tmp ;
  int tmp___0 ;
  int code_length ;
  int tmp___1 ;
  uint32_t code ;
  int code_length___0 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;

  {
#line 398
  depth_count[0] = 0;
#line 398
  tmp = (unsigned int )1;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (tmp >= 16) {
#line 398
      goto while_break;
    }
#line 398
    depth_count[tmp] = 0;
#line 398
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  len = tree->num_symbols;
#line 402
  i = 0;
  {
#line 402
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 402
    if (! (i < len)) {
#line 402
      goto while_break___0;
    }
#line 403
    code_length = (int )*(tree->code_lengths + i);
#line 405
    (depth_count[code_length]) ++;
#line 402
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  depth_count[0] = 0;
#line 408
  next_code[0] = (uint32_t )0;
#line 410
  code = (uint32_t )0;
#line 411
  i = 1;
  {
#line 411
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 411
    if (! (i <= 15)) {
#line 411
      goto while_break___1;
    }
#line 412
    code = (code + (unsigned int )depth_count[i - 1]) << 1;
#line 413
    next_code[i] = code;
#line 411
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 416
  i = 0;
  {
#line 416
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 416
    if (! (i < len)) {
#line 416
      goto while_break___2;
    }
    {
#line 417
    code_length___0 = (int )*(tree->code_lengths + i);
#line 418
    __cil_tmp12 = next_code[code_length___0];
#line 418
    (next_code[code_length___0]) ++;
#line 418
    __cil_tmp13 = ReverseBits(code_length___0, __cil_tmp12);
#line 418
    *(tree->codes + i) = (uint16_t )__cil_tmp13;
    }
#line 416
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 425 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman_encode.c"
int VP8LCreateHuffmanTree(int *histogram , int tree_depth_limit , HuffmanTreeCode *tree ) 
{ 
  int num_symbols ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 427
  num_symbols = tree->num_symbols;
#line 428
  __cil_tmp5 = OptimizeHuffmanForRle(num_symbols, histogram);
  }
#line 428
  if (! __cil_tmp5) {
#line 429
    return (0);
  }
  {
#line 431
  __cil_tmp6 = GenerateOptimalTree((int const   *)histogram, num_symbols, tree_depth_limit,
                                   tree->code_lengths);
  }
#line 431
  if (! __cil_tmp6) {
#line 433
    return (0);
  }
  {
#line 436
  ConvertBitDepthsToSymbols(tree);
  }
#line 437
  return (1);
}
}
#line 37 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman.h"
__inline static int HuffmanTreeNodeIsLeaf(HuffmanTreeNode *node ) 
{ 


  {
#line 39
  return (node->children_ == 0);
}
}
#line 43 "/doner/libwebp/libwebp-v0.3.0/src/utils/./huffman.h"
__inline static HuffmanTreeNode *HuffmanTreeNextNode(HuffmanTreeNode *node , int right_child ) 
{ 


  {
#line 45
  return ((node + node->children_) + right_child);
}
}
#line 50
void HuffmanTreeRelease(HuffmanTree___0 *tree ) ;
#line 54
int HuffmanTreeBuildImplicit(HuffmanTree___0 *tree , int const   *code_lengths , int code_lengths_size ) ;
#line 61
int HuffmanTreeBuildExplicit(HuffmanTree___0 *tree , int const   *code_lengths , int const   *codes ,
                             int const   *symbols , int max_symbol , int num_symbols ) ;
#line 70
int HuffmanCodeLengthsToCodes(int const   *code_lengths , int code_lengths_size ,
                              int *huff_codes ) ;
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
static void TreeNodeInit(HuffmanTreeNode *node ) 
{ 


  {
#line 25
  node->children_ = - 1;
  return;
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
static int NodeIsEmpty(HuffmanTreeNode *node ) 
{ 


  {
#line 29
  return (node->children_ < 0);
}
}
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
static int IsFull(HuffmanTree___0 *tree ) 
{ 


  {
#line 33
  return (tree->num_nodes_ == tree->max_nodes_);
}
}
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
static void AssignChildren(HuffmanTree___0 *tree , HuffmanTreeNode *node ) 
{ 
  HuffmanTreeNode *children ;
  int tmp ;

  {
  {
#line 38
  children = tree->root_ + tree->num_nodes_;
#line 39
  node->children_ = (int )(children - node);
#line 41
  tree->num_nodes_ += 2;
#line 42
  TreeNodeInit(children + 0);
#line 43
  TreeNodeInit(children + 1);
  }
  return;
}
}
#line 46 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
static int TreeInit(HuffmanTree___0 *tree , int num_leaves ) 
{ 
  int tmp ;
  void *__cil_tmp4 ;

  {
#line 48
  if (num_leaves == 0) {
#line 48
    return (0);
  }
  {
#line 52
  tree->max_nodes_ = 2 * num_leaves - 1;
#line 53
  __cil_tmp4 = WebPSafeMalloc((uint64_t )tree->max_nodes_, sizeof(*(tree->root_)));
#line 53
  tree->root_ = (HuffmanTreeNode *)__cil_tmp4;
  }
#line 55
  if (tree->root_ == (void *)0) {
#line 55
    return (0);
  }
  {
#line 56
  TreeNodeInit(tree->root_);
#line 57
  tree->num_nodes_ = 1;
  }
#line 58
  return (1);
}
}
#line 61 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
void HuffmanTreeRelease(HuffmanTree___0 *tree ) 
{ 


  {
#line 62
  if (tree != (void *)0) {
    {
#line 63
    free(tree->root_);
#line 64
    tree->root_ = (HuffmanTreeNode *)((void *)0);
#line 65
    tree->max_nodes_ = 0;
#line 66
    tree->num_nodes_ = 0;
    }
  }
  return;
}
}
#line 70 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
int HuffmanCodeLengthsToCodes(int const   *code_lengths , int code_lengths_size ,
                              int *huff_codes ) 
{ 
  int symbol ;
  int code_len ;
  int code_length_hist[16] ;
  unsigned int tmp ;
  int curr_code ;
  int next_codes[16] ;
  unsigned int tmp___0 ;
  int max_code_length ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp15 ;

  {
#line 74
  code_length_hist[0] = 0;
#line 74
  tmp = (unsigned int )1;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (tmp >= 16) {
#line 74
      goto while_break;
    }
#line 74
    code_length_hist[tmp] = 0;
#line 74
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  next_codes[0] = 0;
#line 76
  tmp___0 = (unsigned int )1;
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if (tmp___0 >= 16) {
#line 76
      goto while_break___0;
    }
#line 76
    next_codes[tmp___0] = 0;
#line 76
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 77
  max_code_length = 0;
#line 84
  symbol = 0;
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 84
    if (! (symbol < code_lengths_size)) {
#line 84
      goto while_break___1;
    }
#line 85
    if (*(code_lengths + symbol) > max_code_length) {
#line 86
      max_code_length = *(code_lengths + symbol);
    }
#line 84
    symbol ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 89
  if (max_code_length > 15) {
#line 89
    return (0);
  }
#line 92
  symbol = 0;
  {
#line 92
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 92
    if (! (symbol < code_lengths_size)) {
#line 92
      goto while_break___2;
    }
#line 93
    (code_length_hist[*(code_lengths + symbol)]) ++;
#line 92
    symbol ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 95
  code_length_hist[0] = 0;
#line 100
  curr_code = 0;
#line 101
  next_codes[0] = - 1;
#line 102
  code_len = 1;
  {
#line 102
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 102
    if (! (code_len <= max_code_length)) {
#line 102
      goto while_break___3;
    }
#line 103
    curr_code = (curr_code + code_length_hist[code_len - 1]) << 1;
#line 104
    next_codes[code_len] = curr_code;
#line 102
    code_len ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 108
  symbol = 0;
  {
#line 108
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 108
    if (! (symbol < code_lengths_size)) {
#line 108
      goto while_break___4;
    }
#line 109
    if (*(code_lengths + symbol) > 0) {
#line 110
      __cil_tmp15 = next_codes[*(code_lengths + symbol)];
#line 110
      (next_codes[*(code_lengths + symbol)]) ++;
#line 110
      *(huff_codes + symbol) = __cil_tmp15;
    } else {
#line 112
      *(huff_codes + symbol) = - 1;
    }
#line 108
    symbol ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 115
  return (1);
}
}
#line 118 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
static int TreeAddSymbol(HuffmanTree___0 *tree , int symbol , int code , int code_length ) 
{ 
  HuffmanTreeNode *node ;
  HuffmanTreeNode *max_node ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 120
  node = tree->root_;
#line 121
  max_node = tree->root_ + tree->max_nodes_;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    __cil_tmp7 = code_length;
#line 122
    code_length --;
#line 122
    if (! (__cil_tmp7 > 0)) {
#line 122
      goto while_break;
    }
#line 123
    if (node >= max_node) {
#line 124
      return (0);
    }
    {
#line 126
    __cil_tmp8 = NodeIsEmpty(node);
    }
#line 126
    if (__cil_tmp8) {
      {
#line 127
      __cil_tmp9 = IsFull(tree);
      }
#line 127
      if (__cil_tmp9) {
#line 127
        return (0);
      }
      {
#line 128
      AssignChildren(tree, node);
      }
    } else {
      {
#line 129
      __cil_tmp10 = HuffmanTreeNodeIsLeaf(node);
      }
#line 129
      if (__cil_tmp10) {
#line 130
        return (0);
      }
    }
#line 132
    node += node->children_ + ((code >> code_length) & 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  __cil_tmp11 = NodeIsEmpty(node);
  }
#line 134
  if (__cil_tmp11) {
#line 135
    node->children_ = 0;
  } else {
    {
#line 136
    __cil_tmp12 = HuffmanTreeNodeIsLeaf(node);
    }
#line 136
    if (! __cil_tmp12) {
#line 137
      return (0);
    }
  }
#line 139
  node->symbol_ = symbol;
#line 140
  return (1);
}
}
#line 143 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
int HuffmanTreeBuildImplicit(HuffmanTree___0 *tree , int const   *code_lengths , int code_lengths_size ) 
{ 
  int symbol ;
  int num_symbols ;
  int root_symbol ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp9 ;
  int max_symbol ;
  int __cil_tmp11 ;
  int ok ;
  int *codes ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 147
  num_symbols = 0;
#line 148
  root_symbol = 0;
#line 154
  symbol = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (symbol < code_lengths_size)) {
#line 154
      goto while_break;
    }
#line 155
    if (*(code_lengths + symbol) > 0) {
#line 157
      num_symbols ++;
#line 158
      root_symbol = symbol;
    }
#line 154
    symbol ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  __cil_tmp9 = TreeInit(tree, num_symbols);
  }
#line 163
  if (! __cil_tmp9) {
#line 163
    return (0);
  }
#line 166
  if (num_symbols == 1) {
#line 167
    max_symbol = code_lengths_size;
#line 168
    if (root_symbol < 0) {
      {
      {
#line 169
      HuffmanTreeRelease(tree);
      }
      }
#line 170
      return (0);
    } else
#line 168
    if (root_symbol >= max_symbol) {
      {
      {
#line 169
      HuffmanTreeRelease(tree);
      }
      }
#line 170
      return (0);
    }
    {
#line 172
    __cil_tmp11 = TreeAddSymbol(tree, root_symbol, 0, 0);
    }
#line 172
    return (__cil_tmp11);
  } else {
    {
#line 174
    ok = 0;
#line 177
    __cil_tmp14 = WebPSafeMalloc((uint64_t )code_lengths_size, sizeof(*codes));
#line 177
    codes = (int *)__cil_tmp14;
    }
#line 179
    if (codes == (void *)0) {
#line 179
      goto End;
    }
    {
#line 181
    __cil_tmp15 = HuffmanCodeLengthsToCodes(code_lengths, code_lengths_size, codes);
    }
#line 181
    if (! __cil_tmp15) {
#line 182
      goto End;
    }
#line 186
    symbol = 0;
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! (symbol < code_lengths_size)) {
#line 186
        goto while_break___0;
      }
#line 187
      if (*(code_lengths + symbol) > 0) {
        {
#line 188
        __cil_tmp16 = TreeAddSymbol(tree, symbol, *(codes + symbol), *(code_lengths + symbol));
        }
#line 188
        if (! __cil_tmp16) {
#line 189
          goto End;
        }
      }
#line 186
      symbol ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 193
    ok = 1;
    End: 
    {
#line 195
    free(codes);
    }
    {
#line 196
    __cil_tmp17 = IsFull(tree);
#line 196
    ok = ok && __cil_tmp17;
    }
#line 197
    if (! ok) {
      {
#line 197
      HuffmanTreeRelease(tree);
      }
    }
#line 198
    return (ok);
  }
}
}
#line 202 "/doner/libwebp/libwebp-v0.3.0/src/utils/huffman.c"
int HuffmanTreeBuildExplicit(HuffmanTree___0 *tree , int const   *code_lengths , int const   *codes ,
                             int const   *symbols , int max_symbol , int num_symbols ) 
{ 
  int ok ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 207
  ok = 0;
#line 216
  __cil_tmp13 = TreeInit(tree, num_symbols);
  }
#line 216
  if (! __cil_tmp13) {
#line 216
    return (0);
  }
#line 219
  i = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (i < num_symbols)) {
#line 219
      goto while_break;
    }
#line 220
    if (*(codes + i) != -1) {
#line 221
      if (*(symbols + i) < 0) {
#line 222
        goto End;
      } else
#line 221
      if (*(symbols + i) >= max_symbol) {
#line 222
        goto End;
      }
      {
#line 224
      __cil_tmp14 = TreeAddSymbol(tree, *(symbols + i), *(codes + i), *(code_lengths + i));
      }
#line 224
      if (! __cil_tmp14) {
#line 225
        goto End;
      }
    }
#line 219
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  ok = 1;
  End: 
  {
#line 231
  __cil_tmp15 = IsFull(tree);
#line 231
  ok = ok && __cil_tmp15;
  }
#line 232
  if (! ok) {
    {
#line 232
    HuffmanTreeRelease(tree);
    }
  }
#line 233
  return (ok);
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/utils/./filters.h"
WebPFilterFunc WebPFilters[4] ;
#line 45
WebPUnfilterFunc WebPUnfilters[4] ;
#line 48
WEBP_FILTER_TYPE EstimateBestFilter(uint8_t *data , int width , int height , int stride ) ;
#line 31 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
__inline static void PredictLine(uint8_t *src , uint8_t *pred , uint8_t *dst , int length ,
                                 int inverse ) 
{ 
  int i ;

  {
#line 34
  if (inverse) {
#line 35
    i = 0;
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;
#line 35
      if (! (i < length)) {
#line 35
        goto while_break;
      }
#line 35
      *(dst + i) = (uint8_t )((int )*(src + i) + (int )*(pred + i));
#line 35
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 37
      if (! (i < length)) {
#line 37
        goto while_break___0;
      }
#line 37
      *(dst + i) = (uint8_t )((int )*(src + i) - (int )*(pred + i));
#line 37
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 44 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
__inline static void DoHorizontalFilter(uint8_t *in , int width , int height , int stride ,
                                        int inverse , uint8_t *out ) 
{ 
  int h ;
  uint8_t *preds ;
  uint8_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 48
  if (inverse) {
#line 48
    tmp = out;
  } else {
#line 48
    tmp = in;
  }
#line 48
  preds = tmp;
#line 52
  h = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (h < height)) {
#line 52
      goto while_break;
    }
#line 54
    if (h == 0) {
#line 55
      *(out + 0) = *(in + 0);
    } else {
      {
#line 57
      PredictLine(in, preds - stride, out, 1, inverse);
      }
    }
    {
#line 59
    PredictLine(in + 1, preds, out + 1, width - 1, inverse);
#line 60
    preds += stride;
#line 61
    in += stride;
#line 62
    out += stride;
    }
#line 52
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 66 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
static void HorizontalFilter(uint8_t *data , int width , int height , int stride ,
                             uint8_t *filtered_data ) 
{ 


  {
  {
#line 68
  DoHorizontalFilter(data, width, height, stride, 0, filtered_data);
  }
  return;
}
}
#line 71 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
static void HorizontalUnfilter(int width , int height , int stride , uint8_t *data ) 
{ 


  {
  {
#line 73
  DoHorizontalFilter(data, width, height, stride, 1, data);
  }
  return;
}
}
#line 79 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
__inline static void DoVerticalFilter(uint8_t *in , int width , int height , int stride ,
                                      int inverse , uint8_t *out ) 
{ 
  int h ;
  uint8_t *preds ;
  uint8_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 83
  if (inverse) {
#line 83
    tmp = out;
  } else {
#line 83
    tmp = in;
  }
  {
#line 83
  preds = tmp;
#line 87
  *(out + 0) = *(in + 0);
#line 89
  PredictLine(in + 1, preds, out + 1, width - 1, inverse);
#line 92
  h = 1;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (h < height)) {
#line 92
      goto while_break;
    }
    {
#line 93
    in += stride;
#line 94
    out += stride;
#line 95
    PredictLine(in, preds, out, width, inverse);
#line 96
    preds += stride;
    }
#line 92
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 100 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
static void VerticalFilter(uint8_t *data , int width , int height , int stride , uint8_t *filtered_data ) 
{ 


  {
  {
#line 102
  DoVerticalFilter(data, width, height, stride, 0, filtered_data);
  }
  return;
}
}
#line 105 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
static void VerticalUnfilter(int width , int height , int stride , uint8_t *data ) 
{ 


  {
  {
#line 106
  DoVerticalFilter(data, width, height, stride, 1, data);
  }
  return;
}
}
#line 112 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
__inline static int GradientPredictor(uint8_t a , uint8_t b , uint8_t c ) 
{ 
  int g ;
  int tmp ;
  int tmp___0 ;

  {
#line 113
  g = ((int )a + (int )b) - (int )c;
#line 114
  if ((g & -256) == 0) {
#line 114
    tmp___0 = g;
  } else {
#line 114
    if (g < 0) {
#line 114
      tmp = 0;
    } else {
#line 114
      tmp = 255;
    }
#line 114
    tmp___0 = tmp;
  }
#line 114
  return (tmp___0);
}
}
#line 118 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
__inline static void DoGradientFilter(uint8_t *in , int width , int height , int stride ,
                                      int inverse , uint8_t *out ) 
{ 
  uint8_t *preds ;
  uint8_t *tmp ;
  int h ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int w ;
  int pred ;
  int __cil_tmp17 ;
  int tmp___5 ;

  {
#line 120
  if (inverse) {
#line 120
    tmp = out;
  } else {
#line 120
    tmp = in;
  }
  {
#line 120
  preds = tmp;
#line 125
  *(out + 0) = *(in + 0);
#line 126
  PredictLine(in + 1, preds, out + 1, width - 1, inverse);
#line 129
  h = 1;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (h < height)) {
#line 129
      goto while_break;
    }
    {
#line 131
    preds += stride;
#line 132
    in += stride;
#line 133
    out += stride;
#line 135
    PredictLine(in, preds - stride, out, 1, inverse);
#line 136
    w = 1;
    }
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (w < width)) {
#line 136
        goto while_break___0;
      }
      {
#line 137
      __cil_tmp17 = GradientPredictor(*(preds + (w - 1)), *(preds + (w - stride)),
                                      *(preds + ((w - stride) - 1)));
#line 137
      pred = __cil_tmp17;
      }
#line 140
      if (inverse) {
#line 140
        tmp___5 = pred;
      } else {
#line 140
        tmp___5 = - pred;
      }
#line 140
      *(out + w) = (uint8_t )((int )*(in + w) + tmp___5);
#line 136
      w ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 129
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 145 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
static void GradientFilter(uint8_t *data , int width , int height , int stride , uint8_t *filtered_data ) 
{ 


  {
  {
#line 147
  DoGradientFilter(data, width, height, stride, 0, filtered_data);
  }
  return;
}
}
#line 150 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
static void GradientUnfilter(int width , int height , int stride , uint8_t *data ) 
{ 


  {
  {
#line 151
  DoGradientFilter(data, width, height, stride, 1, data);
  }
  return;
}
}
#line 163 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
WEBP_FILTER_TYPE EstimateBestFilter(uint8_t *data , int width , int height , int stride ) 
{ 
  int i ;
  int j ;
  int bins[4][16] ;
  uint8_t *p ;
  int mean ;
  int diff0 ;
  int __cil_tmp11 ;
  int diff1 ;
  int __cil_tmp13 ;
  int diff2 ;
  int __cil_tmp15 ;
  int grad_pred ;
  int __cil_tmp17 ;
  int diff3 ;
  int __cil_tmp19 ;
  WEBP_FILTER_TYPE filter ;
  WEBP_FILTER_TYPE best_filter ;
  int best_score ;
  int score ;

  {
  {
#line 167
  memset((int (*)[16])bins, 0, sizeof(bins));
#line 169
  j = 2;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! (j < height - 1)) {
#line 169
      goto while_break;
    }
#line 170
    p = data + j * stride;
#line 171
    mean = (int )*(p + 0);
#line 172
    i = 2;
    {
#line 172
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 172
      if (! (i < width - 1)) {
#line 172
        goto while_break___0;
      }
      {
#line 173
      __cil_tmp11 = abs((int )*(p + i) - mean);
#line 173
      diff0 = __cil_tmp11 >> 4;
#line 174
      __cil_tmp13 = abs((int )*(p + i) - (int )*(p + (i - 1)));
#line 174
      diff1 = __cil_tmp13 >> 4;
#line 175
      __cil_tmp15 = abs((int )*(p + i) - (int )*(p + (i - width)));
#line 175
      diff2 = __cil_tmp15 >> 4;
#line 176
      __cil_tmp17 = GradientPredictor(*(p + (i - 1)), *(p + (i - width)), *(p + ((i - width) - 1)));
#line 176
      grad_pred = __cil_tmp17;
#line 178
      __cil_tmp19 = abs((int )*(p + i) - grad_pred);
#line 178
      diff3 = __cil_tmp19 >> 4;
#line 179
      bins[0][diff0] = 1;
#line 180
      bins[1][diff1] = 1;
#line 181
      bins[2][diff2] = 1;
#line 182
      bins[3][diff3] = 1;
#line 183
      mean = ((3 * mean + (int )*(p + i)) + 2) >> 2;
      }
#line 172
      i += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 169
    j += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  best_filter = (WEBP_FILTER_TYPE )0;
#line 188
  best_score = 2147483647;
#line 189
  filter = (WEBP_FILTER_TYPE )0;
  {
#line 189
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 189
    if (! ((unsigned int )filter < 4U)) {
#line 189
      goto while_break___1;
    }
#line 190
    score = 0;
#line 191
    i = 0;
    {
#line 191
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 191
      if (! (i < 16)) {
#line 191
        goto while_break___2;
      }
#line 192
      if (bins[filter][i] > 0) {
#line 193
        score += i;
      }
#line 191
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 196
    if (score < best_score) {
#line 197
      best_score = score;
#line 198
      best_filter = filter;
    }
#line 189
    filter ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 201
  return (best_filter);
}
}
#line 210 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
WebPFilterFunc WebPFilters[4]  = {      (WebPFilterFunc )((void *)0),      & HorizontalFilter,      & VerticalFilter,      & GradientFilter};
#line 217 "/doner/libwebp/libwebp-v0.3.0/src/utils/filters.c"
WebPUnfilterFunc WebPUnfilters[4]  = {      (WebPUnfilterFunc )((void *)0),      & HorizontalUnfilter,      & VerticalUnfilter,      & GradientUnfilter};
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/utils/./color_cache.h"
static uint32_t kHashMul  =    (uint32_t )506832829;
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/utils/./color_cache.h"
__inline static uint32_t VP8LColorCacheLookup(VP8LColorCache *cc , uint32_t key ) 
{ 
  int tmp ;

  {
#line 33
  return (*(cc->colors_ + key));
}
}
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/utils/./color_cache.h"
__inline static void VP8LColorCacheInsert(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/utils/./color_cache.h"
__inline static int VP8LColorCacheGetIndex(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/utils/./color_cache.h"
__inline static int VP8LColorCacheContains(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 57
int VP8LColorCacheInit(VP8LColorCache *cc , int hash_bits ) ;
#line 60
void VP8LColorCacheClear(VP8LColorCache *cc ) ;
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/utils/color_cache.c"
int VP8LColorCacheInit(VP8LColorCache *cc , int hash_bits ) 
{ 
  int hash_size ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp6 ;

  {
  {
#line 25
  hash_size = 1 << hash_bits;
#line 28
  __cil_tmp6 = WebPSafeCalloc((uint64_t )hash_size, sizeof(*(cc->colors_)));
#line 28
  cc->colors_ = (uint32_t *)__cil_tmp6;
  }
#line 30
  if (cc->colors_ == (void *)0) {
#line 30
    return (0);
  }
#line 31
  cc->hash_shift_ = 32 - hash_bits;
#line 32
  return (1);
}
}
#line 35 "/doner/libwebp/libwebp-v0.3.0/src/utils/color_cache.c"
void VP8LColorCacheClear(VP8LColorCache *cc ) 
{ 


  {
#line 36
  if (cc != (void *)0) {
    {
#line 37
    free(cc->colors_);
#line 38
    cc->colors_ = (uint32_t *)((void *)0);
    }
  }
  return;
}
}
#line 37 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
int VP8BitWriterInit(VP8BitWriter *bw , size_t expected_size ) ;
#line 39
uint8_t *VP8BitWriterFinish(VP8BitWriter *bw ) ;
#line 42
void VP8BitWriterWipeOut(VP8BitWriter *bw ) ;
#line 44
int VP8PutBit(VP8BitWriter *bw , int bit , int prob ) ;
#line 45
int VP8PutBitUniform(VP8BitWriter *bw , int bit ) ;
#line 46
void VP8PutValue(VP8BitWriter *bw , int value , int nb_bits ) ;
#line 47
void VP8PutSignedValue(VP8BitWriter *bw , int value , int nb_bits ) ;
#line 50
int VP8BitWriterAppend(VP8BitWriter *bw , uint8_t *data , size_t size ) ;
#line 54 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
__inline static uint64_t VP8BitWriterPos(VP8BitWriter *bw ) 
{ 


  {
#line 55
  return (((uint64_t )(bw->pos_ + (unsigned long )bw->run_) * 8UL + 8UL) + (unsigned long )bw->nb_bits_);
}
}
#line 59 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
__inline static uint8_t *VP8BitWriterBuf(VP8BitWriter *bw ) 
{ 


  {
#line 60
  return (bw->buf_);
}
}
#line 63 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
__inline static size_t VP8BitWriterSize(VP8BitWriter *bw ) 
{ 


  {
#line 64
  return (bw->pos_);
}
}
#line 85 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
__inline static size_t VP8LBitWriterNumBytes(VP8LBitWriter *bw ) 
{ 


  {
#line 86
  return ((bw->bit_pos_ + 7UL) >> 3);
}
}
#line 89 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_writer.h"
__inline static uint8_t *VP8LBitWriterFinish(VP8LBitWriter *bw ) 
{ 


  {
#line 90
  return (bw->buf_);
}
}
#line 94
int VP8LBitWriterInit(VP8LBitWriter *bw , size_t expected_size ) ;
#line 96
void VP8LBitWriterDestroy(VP8LBitWriter *bw ) ;
#line 115
void VP8LWriteBits(VP8LBitWriter *bw , int n_bits , uint32_t bits ) ;
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
static int BitWriterResize(VP8BitWriter *bw , size_t extra_size ) 
{ 
  uint8_t *new_buf ;
  size_t new_size ;
  uint64_t needed_size_64b ;
  size_t needed_size ;
  void *__cil_tmp7 ;

  {
#line 28
  needed_size_64b = (uint64_t )bw->pos_ + extra_size;
#line 29
  needed_size = (size_t )needed_size_64b;
#line 30
  if (needed_size_64b != needed_size) {
#line 31
    bw->error_ = 1;
#line 32
    return (0);
  }
#line 34
  if (needed_size <= bw->max_pos_) {
#line 34
    return (1);
  }
#line 36
  new_size = 2UL * bw->max_pos_;
#line 37
  if (new_size < needed_size) {
#line 37
    new_size = needed_size;
  }
#line 38
  if (new_size < 1024UL) {
#line 38
    new_size = (size_t )1024;
  }
  {
#line 39
  __cil_tmp7 = malloc(new_size);
#line 39
  new_buf = (uint8_t *)__cil_tmp7;
  }
#line 40
  if (new_buf == (void *)0) {
#line 41
    bw->error_ = 1;
#line 42
    return (0);
  }
  {
#line 44
  memcpy(new_buf, bw->buf_, bw->pos_);
#line 45
  free(bw->buf_);
#line 46
  bw->buf_ = new_buf;
#line 47
  bw->max_pos_ = new_size;
  }
#line 48
  return (1);
}
}
#line 51 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
static void kFlush(VP8BitWriter *bw ) 
{ 
  int s ;
  int32_t bits ;
  int tmp ;
  size_t pos ;
  int __cil_tmp6 ;
  uint8_t __cil_tmp7 ;
  int value ;
  int tmp___0 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 52
  s = 8 + bw->nb_bits_;
#line 53
  bits = bw->value_ >> s;
#line 55
  bw->value_ -= bits << s;
#line 56
  bw->nb_bits_ -= 8;
#line 57
  if ((bits & 255) != 255) {
    {
#line 58
    pos = bw->pos_;
#line 59
    __cil_tmp6 = BitWriterResize(bw, (size_t )(bw->run_ + 1));
    }
#line 59
    if (! __cil_tmp6) {
#line 60
      return;
    }
#line 62
    if (bits & 256) {
#line 63
      if (pos > 0UL) {
#line 63
        (*(bw->buf_ + (pos - 1UL))) ++;
      }
    }
#line 65
    if (bw->run_ > 0) {
#line 66
      if (bits & 256) {
#line 66
        tmp___0 = 0;
      } else {
#line 66
        tmp___0 = 255;
      }
#line 66
      value = tmp___0;
      {
#line 67
      while (1) {
        while_continue: /* CIL Label */ ;
#line 67
        if (! (bw->run_ > 0)) {
#line 67
          goto while_break;
        }
#line 67
        __cil_tmp10 = pos;
#line 67
        pos ++;
#line 67
        *(bw->buf_ + __cil_tmp10) = (uint8_t )value;
#line 67
        (bw->run_) --;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 69
    __cil_tmp11 = pos;
#line 69
    pos ++;
#line 69
    *(bw->buf_ + __cil_tmp11) = (uint8_t )bits;
#line 70
    bw->pos_ = pos;
  } else {
#line 72
    (bw->run_) ++;
  }
  return;
}
}
#line 79 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
static uint8_t kNorm[128]  = 
#line 79
  {      (uint8_t )7,      (uint8_t )6,      (uint8_t )6,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )0};
#line 92 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
static uint8_t kNewRange[128]  = 
#line 92
  {      (uint8_t )127,      (uint8_t )127,      (uint8_t )191,      (uint8_t )127, 
        (uint8_t )159,      (uint8_t )191,      (uint8_t )223,      (uint8_t )127, 
        (uint8_t )143,      (uint8_t )159,      (uint8_t )175,      (uint8_t )191, 
        (uint8_t )207,      (uint8_t )223,      (uint8_t )239,      (uint8_t )127, 
        (uint8_t )135,      (uint8_t )143,      (uint8_t )151,      (uint8_t )159, 
        (uint8_t )167,      (uint8_t )175,      (uint8_t )183,      (uint8_t )191, 
        (uint8_t )199,      (uint8_t )207,      (uint8_t )215,      (uint8_t )223, 
        (uint8_t )231,      (uint8_t )239,      (uint8_t )247,      (uint8_t )127, 
        (uint8_t )131,      (uint8_t )135,      (uint8_t )139,      (uint8_t )143, 
        (uint8_t )147,      (uint8_t )151,      (uint8_t )155,      (uint8_t )159, 
        (uint8_t )163,      (uint8_t )167,      (uint8_t )171,      (uint8_t )175, 
        (uint8_t )179,      (uint8_t )183,      (uint8_t )187,      (uint8_t )191, 
        (uint8_t )195,      (uint8_t )199,      (uint8_t )203,      (uint8_t )207, 
        (uint8_t )211,      (uint8_t )215,      (uint8_t )219,      (uint8_t )223, 
        (uint8_t )227,      (uint8_t )231,      (uint8_t )235,      (uint8_t )239, 
        (uint8_t )243,      (uint8_t )247,      (uint8_t )251,      (uint8_t )127, 
        (uint8_t )129,      (uint8_t )131,      (uint8_t )133,      (uint8_t )135, 
        (uint8_t )137,      (uint8_t )139,      (uint8_t )141,      (uint8_t )143, 
        (uint8_t )145,      (uint8_t )147,      (uint8_t )149,      (uint8_t )151, 
        (uint8_t )153,      (uint8_t )155,      (uint8_t )157,      (uint8_t )159, 
        (uint8_t )161,      (uint8_t )163,      (uint8_t )165,      (uint8_t )167, 
        (uint8_t )169,      (uint8_t )171,      (uint8_t )173,      (uint8_t )175, 
        (uint8_t )177,      (uint8_t )179,      (uint8_t )181,      (uint8_t )183, 
        (uint8_t )185,      (uint8_t )187,      (uint8_t )189,      (uint8_t )191, 
        (uint8_t )193,      (uint8_t )195,      (uint8_t )197,      (uint8_t )199, 
        (uint8_t )201,      (uint8_t )203,      (uint8_t )205,      (uint8_t )207, 
        (uint8_t )209,      (uint8_t )211,      (uint8_t )213,      (uint8_t )215, 
        (uint8_t )217,      (uint8_t )219,      (uint8_t )221,      (uint8_t )223, 
        (uint8_t )225,      (uint8_t )227,      (uint8_t )229,      (uint8_t )231, 
        (uint8_t )233,      (uint8_t )235,      (uint8_t )237,      (uint8_t )239, 
        (uint8_t )241,      (uint8_t )243,      (uint8_t )245,      (uint8_t )247, 
        (uint8_t )249,      (uint8_t )251,      (uint8_t )253,      (uint8_t )127};
#line 104 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
int VP8PutBit(VP8BitWriter *bw , int bit , int prob ) 
{ 
  int split ;
  int shift ;

  {
#line 105
  split = bw->range_ * prob >> 8;
#line 106
  if (bit) {
#line 107
    bw->value_ += split + 1;
#line 108
    bw->range_ -= split + 1;
  } else {
#line 110
    bw->range_ = split;
  }
#line 112
  if (bw->range_ < 127) {
#line 113
    shift = (int )kNorm[bw->range_];
#line 114
    bw->range_ = (int32_t )kNewRange[bw->range_];
#line 115
    bw->value_ <<= shift;
#line 116
    bw->nb_bits_ += shift;
#line 117
    if (bw->nb_bits_ > 0) {
      {
#line 117
      kFlush(bw);
      }
    }
  }
#line 119
  return (bit);
}
}
#line 122 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
int VP8PutBitUniform(VP8BitWriter *bw , int bit ) 
{ 
  int split ;

  {
#line 123
  split = bw->range_ >> 1;
#line 124
  if (bit) {
#line 125
    bw->value_ += split + 1;
#line 126
    bw->range_ -= split + 1;
  } else {
#line 128
    bw->range_ = split;
  }
#line 130
  if (bw->range_ < 127) {
#line 131
    bw->range_ = (int32_t )kNewRange[bw->range_];
#line 132
    bw->value_ <<= 1;
#line 133
    (bw->nb_bits_) ++;
#line 134
    if (bw->nb_bits_ > 0) {
      {
#line 134
      kFlush(bw);
      }
    }
  }
#line 136
  return (bit);
}
}
#line 139 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
void VP8PutValue(VP8BitWriter *bw , int value , int nb_bits ) 
{ 
  int mask ;

  {
#line 141
  mask = 1 << (nb_bits - 1);
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! mask) {
#line 141
      goto while_break;
    }
    {
#line 142
    VP8PutBitUniform(bw, value & mask);
    }
#line 141
    mask >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 145 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
void VP8PutSignedValue(VP8BitWriter *bw , int value , int nb_bits ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 146
  __cil_tmp4 = VP8PutBitUniform(bw, value != 0);
  }
#line 146
  if (! __cil_tmp4) {
#line 147
    return;
  }
#line 148
  if (value < 0) {
    {
#line 149
    VP8PutValue(bw, (- value << 1) | 1, nb_bits + 1);
    }
  } else {
    {
#line 151
    VP8PutValue(bw, value << 1, nb_bits + 1);
    }
  }
  return;
}
}
#line 157 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
int VP8BitWriterInit(VP8BitWriter *bw , size_t expected_size ) 
{ 
  int __cil_tmp3 ;
  int tmp ;

  {
#line 158
  bw->range_ = 254;
#line 159
  bw->value_ = 0;
#line 160
  bw->run_ = 0;
#line 161
  bw->nb_bits_ = - 8;
#line 162
  bw->pos_ = (size_t )0;
#line 163
  bw->max_pos_ = (size_t )0;
#line 164
  bw->error_ = 0;
#line 165
  bw->buf_ = (uint8_t *)((void *)0);
#line 166
  if (expected_size > 0UL) {
    {
#line 166
    __cil_tmp3 = BitWriterResize(bw, expected_size);
#line 166
    tmp = __cil_tmp3;
    }
  } else {
#line 166
    tmp = 1;
  }
#line 166
  return (tmp);
}
}
#line 169 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
uint8_t *VP8BitWriterFinish(VP8BitWriter *bw ) 
{ 


  {
  {
#line 170
  VP8PutValue(bw, 0, 9 - bw->nb_bits_);
#line 171
  bw->nb_bits_ = 0;
#line 172
  kFlush(bw);
  }
#line 173
  return (bw->buf_);
}
}
#line 176 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
int VP8BitWriterAppend(VP8BitWriter *bw , uint8_t *data , size_t size ) 
{ 
  int tmp ;
  int __cil_tmp5 ;

  {
#line 179
  if (bw->nb_bits_ != -8) {
#line 179
    return (0);
  }
  {
#line 180
  __cil_tmp5 = BitWriterResize(bw, size);
  }
#line 180
  if (! __cil_tmp5) {
#line 180
    return (0);
  }
  {
#line 181
  memcpy(bw->buf_ + bw->pos_, data, size);
#line 182
  bw->pos_ += size;
  }
#line 183
  return (1);
}
}
#line 186 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
void VP8BitWriterWipeOut(VP8BitWriter *bw ) 
{ 


  {
#line 187
  if (bw) {
    {
#line 188
    free(bw->buf_);
#line 189
    memset(bw, 0, sizeof(*bw));
    }
  }
  return;
}
}
#line 197 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
static int VP8LBitWriterResize(VP8LBitWriter *bw , size_t extra_size ) 
{ 
  uint8_t *allocated_buf ;
  size_t allocated_size ;
  size_t current_size ;
  size_t __cil_tmp6 ;
  uint64_t size_required_64b ;
  size_t size_required ;
  void *__cil_tmp9 ;

  {
  {
#line 200
  __cil_tmp6 = VP8LBitWriterNumBytes(bw);
#line 200
  current_size = __cil_tmp6;
#line 201
  size_required_64b = (uint64_t )current_size + extra_size;
#line 202
  size_required = (size_t )size_required_64b;
  }
#line 203
  if (size_required != size_required_64b) {
#line 204
    bw->error_ = 1;
#line 205
    return (0);
  }
#line 207
  if (bw->max_bytes_ > 0UL) {
#line 207
    if (size_required <= bw->max_bytes_) {
#line 207
      return (1);
    }
  }
#line 208
  allocated_size = 3UL * bw->max_bytes_ >> 1;
#line 209
  if (allocated_size < size_required) {
#line 209
    allocated_size = size_required;
  }
  {
#line 211
  allocated_size = ((allocated_size >> 10) + 1UL) << 10;
#line 212
  __cil_tmp9 = malloc(allocated_size);
#line 212
  allocated_buf = (uint8_t *)__cil_tmp9;
  }
#line 213
  if (allocated_buf == (void *)0) {
#line 214
    bw->error_ = 1;
#line 215
    return (0);
  }
  {
#line 217
  memcpy(allocated_buf, bw->buf_, current_size);
#line 218
  free(bw->buf_);
#line 219
  bw->buf_ = allocated_buf;
#line 220
  bw->max_bytes_ = allocated_size;
#line 221
  memset(allocated_buf + current_size, 0, allocated_size - current_size);
  }
#line 222
  return (1);
}
}
#line 225 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
int VP8LBitWriterInit(VP8LBitWriter *bw , size_t expected_size ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 226
  memset(bw, 0, sizeof(*bw));
#line 227
  __cil_tmp3 = VP8LBitWriterResize(bw, expected_size);
  }
#line 227
  return (__cil_tmp3);
}
}
#line 230 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
void VP8LBitWriterDestroy(VP8LBitWriter *bw ) 
{ 


  {
#line 231
  if (bw != (void *)0) {
    {
#line 232
    free(bw->buf_);
#line 233
    memset(bw, 0, sizeof(*bw));
    }
  }
  return;
}
}
#line 237 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_writer.c"
void VP8LWriteBits(VP8LBitWriter *bw , int n_bits , uint32_t bits ) 
{ 
  uint8_t *p ;
  uint32_t v ;
  uint64_t extra_size ;
  int __cil_tmp7 ;

  {
#line 238
  if (n_bits < 1) {
#line 238
    return;
  }
#line 243
  p = bw->buf_ + (bw->bit_pos_ >> 3);
#line 244
  v = *((uint32_t *)p);
#line 245
  v |= bits << (bw->bit_pos_ & 7UL);
#line 246
  *((uint32_t *)p) = v;
#line 247
  bw->bit_pos_ += (unsigned long )n_bits;
#line 270
  if (bw->bit_pos_ >> 3 > bw->max_bytes_ - 8UL) {
    {
#line 271
    extra_size = (uint64_t )(32768ULL + (unsigned long long )bw->max_bytes_);
#line 272
    __cil_tmp7 = VP8LBitWriterResize(bw, (size_t )extra_size);
    }
#line 272
    if (extra_size != (size_t )extra_size) {
#line 274
      bw->bit_pos_ = (size_t )0;
#line 275
      bw->error_ = 1;
    } else
#line 272
    if (! __cil_tmp7) {
#line 274
      bw->bit_pos_ = (size_t )0;
#line 275
      bw->error_ = 1;
    }
  }
  return;
}
}
#line 132 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
void VP8InitBitReader(VP8BitReader *br , uint8_t *start , uint8_t *end ) ;
#line 136
uint32_t VP8GetValue(VP8BitReader *br , int bits ) ;
#line 137 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
__inline static uint32_t VP8Get(VP8BitReader *br ) 
{ 
  uint32_t __cil_tmp2 ;

  {
  {
#line 138
  __cil_tmp2 = VP8GetValue(br, 1);
  }
#line 138
  return (__cil_tmp2);
}
}
#line 142
int32_t VP8GetSignedValue(VP8BitReader *br , int bits ) ;
#line 145
uint8_t kVP8Log2Range[128] ;
#line 146
range_t kVP8NewRange[128] ;
#line 148
void VP8LoadFinalBytes(VP8BitReader *br ) ;
#line 150 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
__inline static void VP8LoadNewBytes(VP8BitReader *br ) 
{ 
  int tmp ;
  bit_t bits ;
  lbit_t in_bits ;
  long __cil_tmp5 ;

  {
#line 153
  if (br->buf_ + sizeof(lbit_t ) <= br->buf_end_) {
    {
#line 156
    in_bits = *((lbit_t *)br->buf_);
#line 157
    br->buf_ += 56 >> 3;
#line 163
    __cil_tmp5 = __builtin_bswap64(in_bits);
#line 163
    bits = (bit_t )__cil_tmp5;
#line 177
    bits >>= 8;
#line 201
    br->value_ = bits | (br->value_ << 56);
#line 203
    br->bits_ += 56;
    }
  } else {
    {
#line 205
    VP8LoadFinalBytes(br);
    }
  }
  return;
}
}
#line 209 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
__inline static int VP8BitUpdate(VP8BitReader *br , range_t split ) 
{ 
  int pos ;
  range_t value ;

  {
#line 210
  if (br->bits_ < 0) {
    {
#line 211
    VP8LoadNewBytes(br);
    }
  }
#line 225
  pos = br->bits_;
#line 226
  value = (range_t )(br->value_ >> pos);
#line 227
  if (value > split) {
#line 228
    br->range_ -= split + 1U;
#line 229
    br->value_ -= (bit_t )(split + 1U) << pos;
#line 230
    return (1);
  } else {
#line 232
    br->range_ = split;
#line 233
    return (0);
  }
}
}
#line 239 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
__inline static void VP8Shift(VP8BitReader *br ) 
{ 
  int shift ;
  int tmp ;

  {
#line 248
  shift = (int )kVP8Log2Range[br->range_];
#line 250
  br->range_ = kVP8NewRange[br->range_];
#line 251
  br->bits_ -= shift;
  return;
}
}
#line 254 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
__inline static int VP8GetBit(VP8BitReader *br , int prob ) 
{ 
  range_t split ;
  int bit ;
  int __cil_tmp5 ;

  {
  {
#line 266
  split = br->range_ * (unsigned int )prob >> 8;
#line 267
  __cil_tmp5 = VP8BitUpdate(br, split);
#line 267
  bit = __cil_tmp5;
  }
#line 268
  if (br->range_ <= 126U) {
    {
#line 269
    VP8Shift(br);
    }
  }
#line 271
  return (bit);
}
}
#line 275 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
__inline static int VP8GetSigned(VP8BitReader *br , int v ) 
{ 
  range_t split ;
  int bit ;
  int __cil_tmp5 ;
  int tmp ;

  {
  {
#line 276
  split = br->range_ >> 1;
#line 277
  __cil_tmp5 = VP8BitUpdate(br, split);
#line 277
  bit = __cil_tmp5;
#line 278
  VP8Shift(br);
  }
#line 279
  if (bit) {
#line 279
    tmp = - v;
  } else {
#line 279
    tmp = v;
  }
#line 279
  return (tmp);
}
}
#line 298
void VP8LInitBitReader(VP8LBitReader *br , uint8_t *start , size_t length ) ;
#line 303
void VP8LBitReaderSetBuffer(VP8LBitReader *br , uint8_t *buf , size_t len ) ;
#line 309
uint32_t VP8LReadBits(VP8LBitReader *br , int n_bits ) ;
#line 312 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
__inline static uint32_t VP8LPrefetchBits(VP8LBitReader *br ) 
{ 


  {
#line 313
  return ((uint32_t )(br->val_ >> br->bit_pos_));
}
}
#line 317 "/doner/libwebp/libwebp-v0.3.0/src/utils/./bit_reader.h"
__inline static void VP8LDiscardBits(VP8LBitReader *br , int num_bits ) 
{ 


  {
#line 318
  br->bit_pos_ += num_bits;
  return;
}
}
#line 322
void VP8LFillBitWindow(VP8LBitReader *br ) ;
#line 27 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
void VP8InitBitReader(VP8BitReader *br , uint8_t *start , uint8_t *end ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 32
  br->range_ = (range_t )254;
#line 33
  br->buf_ = start;
#line 34
  br->buf_end_ = end;
#line 35
  br->value_ = (bit_t )0;
#line 36
  br->bits_ = - 8;
#line 37
  br->eof_ = 0;
  return;
}
}
#line 40 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
uint8_t kVP8Log2Range[128]  = 
#line 40
  {      (uint8_t )7,      (uint8_t )6,      (uint8_t )6,      (uint8_t )5, 
        (uint8_t )5,      (uint8_t )5,      (uint8_t )5,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )4, 
        (uint8_t )4,      (uint8_t )4,      (uint8_t )4,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )3, 
        (uint8_t )3,      (uint8_t )3,      (uint8_t )3,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )2, 
        (uint8_t )2,      (uint8_t )2,      (uint8_t )2,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )1, 
        (uint8_t )1,      (uint8_t )1,      (uint8_t )1,      (uint8_t )0};
#line 53 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
range_t kVP8NewRange[128]  = 
#line 53
  {      (range_t )127,      (range_t )127,      (range_t )191,      (range_t )127, 
        (range_t )159,      (range_t )191,      (range_t )223,      (range_t )127, 
        (range_t )143,      (range_t )159,      (range_t )175,      (range_t )191, 
        (range_t )207,      (range_t )223,      (range_t )239,      (range_t )127, 
        (range_t )135,      (range_t )143,      (range_t )151,      (range_t )159, 
        (range_t )167,      (range_t )175,      (range_t )183,      (range_t )191, 
        (range_t )199,      (range_t )207,      (range_t )215,      (range_t )223, 
        (range_t )231,      (range_t )239,      (range_t )247,      (range_t )127, 
        (range_t )131,      (range_t )135,      (range_t )139,      (range_t )143, 
        (range_t )147,      (range_t )151,      (range_t )155,      (range_t )159, 
        (range_t )163,      (range_t )167,      (range_t )171,      (range_t )175, 
        (range_t )179,      (range_t )183,      (range_t )187,      (range_t )191, 
        (range_t )195,      (range_t )199,      (range_t )203,      (range_t )207, 
        (range_t )211,      (range_t )215,      (range_t )219,      (range_t )223, 
        (range_t )227,      (range_t )231,      (range_t )235,      (range_t )239, 
        (range_t )243,      (range_t )247,      (range_t )251,      (range_t )127, 
        (range_t )129,      (range_t )131,      (range_t )133,      (range_t )135, 
        (range_t )137,      (range_t )139,      (range_t )141,      (range_t )143, 
        (range_t )145,      (range_t )147,      (range_t )149,      (range_t )151, 
        (range_t )153,      (range_t )155,      (range_t )157,      (range_t )159, 
        (range_t )161,      (range_t )163,      (range_t )165,      (range_t )167, 
        (range_t )169,      (range_t )171,      (range_t )173,      (range_t )175, 
        (range_t )177,      (range_t )179,      (range_t )181,      (range_t )183, 
        (range_t )185,      (range_t )187,      (range_t )189,      (range_t )191, 
        (range_t )193,      (range_t )195,      (range_t )197,      (range_t )199, 
        (range_t )201,      (range_t )203,      (range_t )205,      (range_t )207, 
        (range_t )209,      (range_t )211,      (range_t )213,      (range_t )215, 
        (range_t )217,      (range_t )219,      (range_t )221,      (range_t )223, 
        (range_t )225,      (range_t )227,      (range_t )229,      (range_t )231, 
        (range_t )233,      (range_t )235,      (range_t )237,      (range_t )239, 
        (range_t )241,      (range_t )243,      (range_t )245,      (range_t )247, 
        (range_t )249,      (range_t )251,      (range_t )253,      (range_t )127};
#line 74 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
void VP8LoadFinalBytes(VP8BitReader *br ) 
{ 
  int tmp ;
  uint8_t *__cil_tmp3 ;

  {
#line 77
  if (br->buf_ < br->buf_end_) {
#line 81
    __cil_tmp3 = br->buf_;
#line 81
    (br->buf_) ++;
#line 81
    br->value_ = (bit_t )*__cil_tmp3 | (br->value_ << 8);
#line 83
    br->bits_ += 8;
  } else
#line 84
  if (! br->eof_) {
#line 88
    br->value_ <<= 8;
#line 89
    br->bits_ += 8;
#line 91
    br->eof_ = 1;
  }
  return;
}
}
#line 98 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
uint32_t VP8GetValue(VP8BitReader *br , int bits ) 
{ 
  uint32_t v ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 99
  v = (uint32_t )0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    __cil_tmp4 = bits;
#line 100
    bits --;
#line 100
    if (! (__cil_tmp4 > 0)) {
#line 100
      goto while_break;
    }
    {
#line 101
    __cil_tmp5 = VP8GetBit(br, 128);
    }
#line 101
    v |= (unsigned int )(__cil_tmp5 << bits);
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (v);
}
}
#line 106 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
int32_t VP8GetSignedValue(VP8BitReader *br , int bits ) 
{ 
  int value ;
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  int tmp ;

  {
  {
#line 107
  __cil_tmp4 = VP8GetValue(br, bits);
#line 107
  value = (int )__cil_tmp4;
#line 108
  __cil_tmp5 = VP8Get(br);
  }
#line 108
  if (__cil_tmp5) {
#line 108
    tmp = - value;
  } else {
#line 108
    tmp = value;
  }
#line 108
  return (tmp);
}
}
#line 120 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
static uint32_t kBitMask[25]  = 
#line 120
  {      (uint32_t )0,      (uint32_t )1,      (uint32_t )3,      (uint32_t )7, 
        (uint32_t )15,      (uint32_t )31,      (uint32_t )63,      (uint32_t )127, 
        (uint32_t )255,      (uint32_t )511,      (uint32_t )1023,      (uint32_t )2047, 
        (uint32_t )4095,      (uint32_t )8191,      (uint32_t )16383,      (uint32_t )32767, 
        (uint32_t )65535,      (uint32_t )131071,      (uint32_t )262143,      (uint32_t )524287, 
        (uint32_t )1048575,      (uint32_t )2097151,      (uint32_t )4194303,      (uint32_t )8388607, 
        (uint32_t )16777215};
#line 125 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
void VP8LInitBitReader(VP8LBitReader *br , uint8_t *start , size_t length ) 
{ 
  size_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 133
  br->buf_ = start;
#line 134
  br->len_ = length;
#line 135
  br->val_ = (vp8l_val_t )0;
#line 136
  br->pos_ = (size_t )0;
#line 137
  br->bit_pos_ = 0;
#line 138
  br->eos_ = 0;
#line 139
  br->error_ = 0;
#line 140
  i = (size_t )0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < sizeof(br->val_) && i < br->len_)) {
#line 140
      goto while_break;
    }
#line 141
    br->val_ |= (vp8l_val_t )*(br->buf_ + br->pos_) << 8UL * i;
#line 142
    (br->pos_) ++;
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 146 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
void VP8LBitReaderSetBuffer(VP8LBitReader *br , uint8_t *buf , size_t len ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 151
  br->eos_ = br->pos_ >= len;
#line 152
  br->buf_ = buf;
#line 153
  br->len_ = len;
  return;
}
}
#line 157 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
static void ShiftBytes(VP8LBitReader *br ) 
{ 


  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (br->bit_pos_ >= 8 && br->pos_ < br->len_)) {
#line 158
      goto while_break;
    }
#line 159
    br->val_ >>= 8;
#line 160
    br->val_ |= (vp8l_val_t )*(br->buf_ + br->pos_) << 56;
#line 161
    (br->pos_) ++;
#line 162
    br->bit_pos_ -= 8;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 166 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
void VP8LFillBitWindow(VP8LBitReader *br ) 
{ 


  {
#line 167
  if (br->bit_pos_ >= 32) {
#line 169
    if (br->pos_ + sizeof(br->val_) < br->len_) {
#line 170
      br->val_ >>= 32;
#line 171
      br->bit_pos_ -= 32;
#line 174
      br->val_ |= *((vp8l_val_t *)(br->buf_ + br->pos_)) << 32;
#line 175
      br->pos_ += (unsigned long )4;
#line 176
      return;
    }
    {
#line 179
    ShiftBytes(br);
    }
#line 180
    if (br->pos_ == br->len_) {
#line 180
      if (br->bit_pos_ == 64) {
#line 181
        br->eos_ = 1;
      }
    }
  }
  return;
}
}
#line 186 "/doner/libwebp/libwebp-v0.3.0/src/utils/bit_reader.c"
uint32_t VP8LReadBits(VP8LBitReader *br , int n_bits ) 
{ 
  int tmp ;
  uint32_t val ;
  int new_bits ;

  {
#line 189
  if (! br->eos_) {
#line 189
    if (n_bits < 25) {
#line 190
      val = (uint32_t )(br->val_ >> br->bit_pos_) & kBitMask[n_bits];
#line 192
      new_bits = br->bit_pos_ + n_bits;
#line 193
      br->bit_pos_ = new_bits;
#line 195
      if (br->pos_ == br->len_) {
#line 196
        if (new_bits >= 64) {
#line 197
          br->eos_ = 1;
        }
      }
      {
#line 200
      ShiftBytes(br);
      }
#line 201
      return (val);
    } else {
#line 203
      br->error_ = 1;
#line 204
      return ((uint32_t )0);
    }
  } else {
#line 203
    br->error_ = 1;
#line 204
    return ((uint32_t )0);
  }
}
}
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
int WebPGetEncoderVersion(void) ;
#line 47
size_t WebPEncodeRGB(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 50
size_t WebPEncodeBGR(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 53
size_t WebPEncodeRGBA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 56
size_t WebPEncodeBGRA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) ;
#line 63
size_t WebPEncodeLosslessRGB(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 66
size_t WebPEncodeLosslessBGR(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 69
size_t WebPEncodeLosslessRGBA(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 72
size_t WebPEncodeLosslessBGRA(uint8_t *in , int w , int h , int bps , uint8_t **out ) ;
#line 146
int WebPConfigInitInternal(WebPConfig *config , enum WebPPreset preset , float quality ,
                           int version ) ;
#line 152 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
__inline static int WebPConfigInit(WebPConfig *config ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 153
  __cil_tmp2 = WebPConfigInitInternal(config, (enum WebPPreset___0 )0, 75.f, 513);
  }
#line 153
  return (__cil_tmp2);
}
}
#line 161 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
__inline static int WebPConfigPreset(WebPConfig *config , enum WebPPreset___0 preset ,
                                     float quality ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 163
  __cil_tmp4 = WebPConfigInitInternal(config, preset, quality, 513);
  }
#line 163
  return (__cil_tmp4);
}
}
#line 169
int WebPValidateConfig(WebPConfig *config ) ;
#line 219
void WebPMemoryWriterInit(WebPMemoryWriter *writer ) ;
#line 224
int WebPMemoryWrite(uint8_t *data , size_t data_size , WebPPicture *picture ) ;
#line 337
int WebPPictureInitInternal(WebPPicture *picture , int version ) ;
#line 343 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
__inline static int WebPPictureInit(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 344
  __cil_tmp2 = WebPPictureInitInternal(picture, 513);
  }
#line 344
  return (__cil_tmp2);
}
}
#line 354
int WebPPictureAlloc(WebPPicture *picture ) ;
#line 361
void WebPPictureFree(WebPPicture *picture ) ;
#line 366
int WebPPictureCopy(WebPPicture *src , WebPPicture *dst ) ;
#line 372
int WebPPictureDistortion(WebPPicture *src , WebPPicture *ref , int type , float result[5] ) ;
#line 385
int WebPPictureCrop(WebPPicture *pic , int left , int top , int width , int height ) ;
#line 397
int WebPPictureView(WebPPicture *src , int left , int top , int width , int height ,
                    WebPPicture *dst ) ;
#line 403
int WebPPictureIsView(WebPPicture *picture ) ;
#line 408
int WebPPictureRescale(WebPPicture *pic , int width , int height ) ;
#line 414
int WebPPictureImportRGB(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) ;
#line 417
int WebPPictureImportRGBA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 422
int WebPPictureImportRGBX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 426
int WebPPictureImportBGR(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) ;
#line 428
int WebPPictureImportBGRA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 430
int WebPPictureImportBGRX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) ;
#line 438
int WebPPictureARGBToYUVA(WebPPicture *picture , enum WebPEncCSP colorspace ) ;
#line 447
int WebPPictureYUVAToARGB(WebPPicture *picture ) ;
#line 452
void WebPCleanupTransparentArea(WebPPicture *pic ) ;
#line 457
int WebPPictureHasTransparency(WebPPicture *picture ) ;
#line 472
int WebPEncode(WebPConfig *config , WebPPicture *pic ) ;
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../dsp/dsp.h"
VP8CPUInfo VP8GetCPUInfo ;
#line 59
VP8Idct VP8ITransform ;
#line 60
VP8Fdct VP8FTransform ;
#line 61
VP8WHT VP8ITransformWHT ;
#line 62
VP8WHT VP8FTransformWHT ;
#line 68
VP8Intra4Preds VP8EncPredLuma4 ;
#line 69
VP8IntraPreds VP8EncPredLuma16 ;
#line 70
VP8IntraPreds VP8EncPredChroma8 ;
#line 73
VP8Metric VP8SSE16x16 ;
#line 73
VP8Metric VP8SSE16x8 ;
#line 73
VP8Metric VP8SSE8x8 ;
#line 73
VP8Metric VP8SSE4x4 ;
#line 76
VP8WMetric VP8TDisto4x4 ;
#line 76
VP8WMetric VP8TDisto16x16 ;
#line 79
VP8BlockCopy VP8Copy4x4 ;
#line 84
VP8QuantizeBlock VP8EncQuantizeBlock ;
#line 91
int const   VP8DspScan[24] ;
#line 92
VP8CHisto VP8CollectHistogram ;
#line 94
void VP8EncDspInit(void) ;
#line 102
VP8DecIdct2 VP8Transform ;
#line 103
VP8DecIdct VP8TransformUV ;
#line 104
VP8DecIdct VP8TransformDC ;
#line 105
VP8DecIdct VP8TransformDCUV ;
#line 106
VP8WHT VP8TransformWHT ;
#line 111
VP8PredFunc VP8PredLuma16[7] ;
#line 112
VP8PredFunc VP8PredChroma8[7] ;
#line 113
VP8PredFunc VP8PredLuma4[10] ;
#line 117
VP8SimpleFilterFunc VP8SimpleVFilter16 ;
#line 118
VP8SimpleFilterFunc VP8SimpleHFilter16 ;
#line 119
VP8SimpleFilterFunc VP8SimpleVFilter16i ;
#line 120
VP8SimpleFilterFunc VP8SimpleHFilter16i ;
#line 128
VP8LumaFilterFunc VP8VFilter16 ;
#line 129
VP8LumaFilterFunc VP8HFilter16 ;
#line 130
VP8ChromaFilterFunc VP8VFilter8 ;
#line 131
VP8ChromaFilterFunc VP8HFilter8 ;
#line 134
VP8LumaFilterFunc VP8VFilter16i ;
#line 135
VP8LumaFilterFunc VP8HFilter16i ;
#line 136
VP8ChromaFilterFunc VP8VFilter8i ;
#line 137
VP8ChromaFilterFunc VP8HFilter8i ;
#line 140
void VP8DspInit(void) ;
#line 156
WebPUpsampleLinePairFunc WebPUpsamplers[13] ;
#line 159
void WebPInitUpsamplersSSE2(void) ;
#line 162
void WebPInitUpsamplersNEON(void) ;
#line 172
WebPSampleLinePairFunc WebPSamplers[13] ;
#line 177
WebPUpsampleLinePairFunc WebPGetLinePairConverter(int alpha_is_last ) ;
#line 184
WebPYUV444Converter WebPYUV444Converters[13] ;
#line 187
void WebPInitUpsamplers(void) ;
#line 194
void (*WebPApplyAlphaMultiply)(uint8_t * , int  , int  , int  , int  ) ;
#line 198
void (*WebPApplyAlphaMultiply4444)(uint8_t * , int  , int  , int  ) ;
#line 202
void WebPInitPremultiply(void) ;
#line 204
void WebPInitPremultiplySSE2(void) ;
#line 205
void WebPInitPremultiplyNEON(void) ;
#line 131 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
int const   VP8Scan[24] ;
#line 132
int const   VP8UVModeOffsets[4] ;
#line 133
int const   VP8I16ModeOffsets[4] ;
#line 134
int const   VP8I4ModeOffsets[10] ;
#line 167 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8enci.h"
__inline static int QUANTDIV(int n , int iQ , int B ) 
{ 


  {
#line 168
  return ((n * iQ + B) >> 17);
}
}
#line 299
void VP8IteratorInit(VP8Encoder *enc , VP8EncIterator *it ) ;
#line 301
void VP8IteratorReset(VP8EncIterator *it ) ;
#line 303
void VP8IteratorImport(VP8EncIterator *it ) ;
#line 305
void VP8IteratorExport(VP8EncIterator *it ) ;
#line 309
int VP8IteratorNext(VP8EncIterator *it , uint8_t *block_to_save ) ;
#line 312
int VP8IteratorProgress(VP8EncIterator *it , int delta ) ;
#line 315
void VP8IteratorStartI4(VP8EncIterator *it ) ;
#line 317
int VP8IteratorRotateI4(VP8EncIterator *it , uint8_t *yuv_out ) ;
#line 321
void VP8IteratorNzToBytes(VP8EncIterator *it ) ;
#line 322
void VP8IteratorBytesToNz(VP8EncIterator *it ) ;
#line 325
void VP8SetIntra16Mode(VP8EncIterator *it , int mode ) ;
#line 326
void VP8SetIntra4Mode(VP8EncIterator *it , uint8_t *modes ) ;
#line 327
void VP8SetIntraUVMode(VP8EncIterator *it , int mode ) ;
#line 328
void VP8SetSkip(VP8EncIterator *it , int skip ) ;
#line 329
void VP8SetSegment(VP8EncIterator *it , int segment ) ;
#line 346
void VP8TBufferInit(VP8TBuffer *b ) ;
#line 347
void VP8TBufferClear(VP8TBuffer *b ) ;
#line 353
int VP8EmitTokens(VP8TBuffer *b , VP8BitWriter *bw , uint8_t *probas , int final_pass ) ;
#line 357
int VP8RecordCoeffTokens(int ctx , int coeff_type , int first , int last , int16_t *coeffs ,
                         VP8TBuffer *tokens ) ;
#line 362
void VP8TokenToStats(VP8TBuffer * const  b , proba_t * const  stats ) ;
#line 454
uint8_t VP8CoeffsProba0[4][8][3][11] ;
#line 456
uint8_t VP8CoeffsUpdateProba[4][8][3][11] ;
#line 458
void VP8DefaultProbas(VP8Encoder *enc ) ;
#line 460
void VP8WriteProbas(VP8BitWriter *bw , VP8Proba *probas ) ;
#line 462
void VP8CodeIntraModes(VP8Encoder *enc ) ;
#line 468
int VP8EncWrite(VP8Encoder *enc ) ;
#line 470
void VP8EncFreeBitWriters(VP8Encoder *enc ) ;
#line 473
uint8_t VP8EncBands[17] ;
#line 474
uint8_t VP8Cat3[3] ;
#line 475
uint8_t VP8Cat4[4] ;
#line 476
uint8_t VP8Cat5[5] ;
#line 477
uint8_t VP8Cat6[11] ;
#line 480
void VP8MakeLuma16Preds(VP8EncIterator *it ) ;
#line 482
void VP8MakeChroma8Preds(VP8EncIterator *it ) ;
#line 485
void VP8MakeIntra4Preds(VP8EncIterator *it ) ;
#line 487
int VP8GetCostLuma16(VP8EncIterator *it , VP8ModeScore *rd ) ;
#line 488
int VP8GetCostLuma4(VP8EncIterator *it , int16_t levels[16] ) ;
#line 489
int VP8GetCostUV(VP8EncIterator *it , VP8ModeScore *rd ) ;
#line 491
int VP8EncLoop(VP8Encoder *enc ) ;
#line 492
int VP8EncTokenLoop(VP8Encoder *enc ) ;
#line 496
int WebPEncodingSetError(WebPPicture *pic , enum WebPEncodingError___0 error ) ;
#line 497
int WebPReportProgress(WebPPicture *pic , int percent , int *percent_store ) ;
#line 503
int VP8EncAnalyze(VP8Encoder *enc ) ;
#line 507
void VP8SetSegmentParams(VP8Encoder *enc , float quality ) ;
#line 509
int VP8Decimate(VP8EncIterator *it , VP8ModeScore *rd , VP8RDLevel rd_opt ) ;
#line 513
void VP8EncInitAlpha(VP8Encoder *enc ) ;
#line 514
int VP8EncStartAlpha(VP8Encoder *enc ) ;
#line 515
int VP8EncFinishAlpha(VP8Encoder *enc ) ;
#line 516
int VP8EncDeleteAlpha(VP8Encoder *enc ) ;
#line 519
void VP8EncInitLayer(VP8Encoder *enc ) ;
#line 520
void VP8EncCodeLayerBlock(VP8EncIterator *it ) ;
#line 521
int VP8EncFinishLayer(VP8Encoder *enc ) ;
#line 522
void VP8EncDeleteLayer(VP8Encoder *enc ) ;
#line 530
void VP8SSIMAddStats(DistoStats *src , DistoStats *dst ) ;
#line 531
void VP8SSIMAccumulatePlane(uint8_t *src1 , int stride1 , uint8_t *src2 , int stride2 ,
                            int W , int H , DistoStats *stats ) ;
#line 534
double VP8SSIMGet(DistoStats *stats ) ;
#line 535
double VP8SSIMGetSquaredError(DistoStats *s ) ;
#line 538
void VP8InitFilter(VP8EncIterator *it ) ;
#line 539
void VP8StoreFilterStats(VP8EncIterator *it ) ;
#line 540
void VP8AdjustFilterStrength(VP8EncIterator *it ) ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 37 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static int BitsLog2Floor(uint32_t n ) 
{ 
  int tmp ;
  int __cil_tmp3 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_clz(n);
  }
#line 39
  return (31 ^ __cil_tmp3);
}
}
#line 71 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static int VP8LBitsLog2Ceiling(uint32_t n ) 
{ 
  int log_floor ;
  int __cil_tmp3 ;

  {
  {
#line 72
  __cil_tmp3 = BitsLog2Floor(n);
#line 72
  log_floor = __cil_tmp3;
  }
#line 73
  if (n == (n & ~ (n - 1U))) {
#line 74
    return (log_floor);
  } else {
#line 76
    return (log_floor + 1);
  }
}
}
#line 82 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static void PrefixEncode(int distance , int *code , int *extra_bits_count ,
                                  int *extra_bits_value ) 
{ 
  int highest_bit ;
  int __cil_tmp6 ;
  int second_highest_bit ;
  int tmp ;

  {
#line 85
  if (distance > 2) {
    {
#line 86
    distance --;
#line 86
    __cil_tmp6 = BitsLog2Floor((uint32_t )distance);
#line 86
    highest_bit = __cil_tmp6;
#line 87
    second_highest_bit = (distance >> (highest_bit - 1)) & 1;
#line 88
    *extra_bits_count = highest_bit - 1;
#line 89
    *extra_bits_value = distance & ((1 << *extra_bits_count) - 1);
#line 90
    *code = 2 * highest_bit + second_highest_bit;
    }
  } else {
#line 92
    *extra_bits_count = 0;
#line 93
    *extra_bits_value = 0;
#line 94
    if (distance == 2) {
#line 94
      tmp = 1;
    } else {
#line 94
      tmp = 0;
    }
#line 94
    *code = tmp;
  }
  return;
}
}
#line 115 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static PixOrCopy PixOrCopyCreateCopy(uint32_t distance , uint16_t len ) 
{ 
  PixOrCopy retval ;

  {
#line 118
  retval.mode = (uint8_t )2;
#line 119
  retval.argb_or_distance = distance;
#line 120
  retval.len = len;
#line 121
  return (retval);
}
}
#line 124 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static PixOrCopy PixOrCopyCreateCacheIdx(int idx ) 
{ 
  PixOrCopy retval ;
  int tmp ;
  int tmp___0 ;

  {
#line 128
  retval.mode = (uint8_t )1;
#line 129
  retval.argb_or_distance = (uint32_t )idx;
#line 130
  retval.len = (uint16_t )1;
#line 131
  return (retval);
}
}
#line 134 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static PixOrCopy PixOrCopyCreateLiteral(uint32_t argb ) 
{ 
  PixOrCopy retval ;

  {
#line 136
  retval.mode = (uint8_t )0;
#line 137
  retval.argb_or_distance = argb;
#line 138
  retval.len = (uint16_t )1;
#line 139
  return (retval);
}
}
#line 142 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static int PixOrCopyIsLiteral(PixOrCopy *p ) 
{ 


  {
#line 143
  return ((int )p->mode == 0);
}
}
#line 146 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static int PixOrCopyIsCacheIdx(PixOrCopy *p ) 
{ 


  {
#line 147
  return ((int )p->mode == 1);
}
}
#line 150 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static int PixOrCopyIsCopy(PixOrCopy *p ) 
{ 


  {
#line 151
  return ((int )p->mode == 2);
}
}
#line 154 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static uint32_t PixOrCopyLiteral(PixOrCopy *p , int component ) 
{ 
  int tmp ;

  {
#line 157
  return ((p->argb_or_distance >> component * 8) & 255U);
}
}
#line 160 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static uint32_t PixOrCopyLength(PixOrCopy *p ) 
{ 


  {
#line 161
  return ((uint32_t )p->len);
}
}
#line 164 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static uint32_t PixOrCopyArgb(PixOrCopy *p ) 
{ 
  int tmp ;

  {
#line 166
  return (p->argb_or_distance);
}
}
#line 169 "/doner/libwebp/libwebp-v0.3.0/src/enc/./././backward_references.h"
__inline static uint32_t PixOrCopyCacheIdx(PixOrCopy *p ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 172
  return (p->argb_or_distance);
}
}
#line 190
void VP8LInitBackwardRefs(VP8LBackwardRefs *refs ) ;
#line 193
void VP8LClearBackwardRefs(VP8LBackwardRefs *refs ) ;
#line 196
int VP8LBackwardRefsAlloc(VP8LBackwardRefs *refs , int max_size ) ;
#line 203
int VP8LGetBackwardReferences(int width , int height , uint32_t *argb , int quality ,
                              int cache_bits , int use_2d_locality , VP8LBackwardRefs *best ) ;
#line 209
int VP8LCalculateEstimateForCacheSize(uint32_t *argb , int xsize , int ysize , int *best_cache_bits ) ;
#line 56 "/doner/libwebp/libwebp-v0.3.0/src/enc/././histogram.h"
void VP8LHistogramCreate(VP8LHistogram *p , VP8LBackwardRefs *refs , int palette_code_bits ) ;
#line 61
void VP8LHistogramInit(VP8LHistogram *p , int palette_code_bits ) ;
#line 64
void VP8LHistogramStoreRefs(VP8LBackwardRefs *refs , VP8LHistogram *histo ) ;
#line 69
VP8LHistogramSet *VP8LAllocateHistogramSet(int size , int cache_bits ) ;
#line 72
void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram *histo , PixOrCopy *v ) ;
#line 77
double VP8LHistogramEstimateBits(VP8LHistogram *p ) ;
#line 81
double VP8LHistogramEstimateBitsBulk(VP8LHistogram *p ) ;
#line 83 "/doner/libwebp/libwebp-v0.3.0/src/enc/././histogram.h"
__inline static int VP8LHistogramNumCodes(VP8LHistogram *p ) 
{ 
  int tmp ;

  {
#line 84
  if (p->palette_code_bits_ > 0) {
#line 84
    tmp = 1 << p->palette_code_bits_;
  } else {
#line 84
    tmp = 0;
  }
#line 84
  return (280 + tmp);
}
}
#line 89
int VP8LGetHistoImageSymbols(int xsize , int ysize , VP8LBackwardRefs *refs , int quality ,
                             int histo_bits , int cache_bits , VP8LHistogramSet *image_in ,
                             uint16_t *histogram_symbols ) ;
#line 54 "/doner/libwebp/libwebp-v0.3.0/src/enc/./vp8li.h"
int VP8LEncodeImage(WebPConfig *config , WebPPicture *picture ) ;
#line 58
enum WebPEncodingError___0 VP8LEncodeStream(WebPConfig *config , WebPPicture *picture ,
                                            VP8LBitWriter *bw ) ;
#line 33 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
int WebPGetEncoderVersion(void) 
{ 


  {
#line 34
  return (3 << 8);
}
}
#line 41 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static int DummyWriter(uint8_t *data , size_t data_size , WebPPicture *picture ) 
{ 


  {
#line 47
  return (1);
}
}
#line 50 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
int WebPPictureInitInternal(WebPPicture *picture , int version ) 
{ 


  {
#line 51
  if (version >> 8 != 513 >> 8) {
#line 52
    return (0);
  }
#line 54
  if (picture != (void *)0) {
    {
#line 55
    memset(picture, 0, sizeof(*picture));
#line 56
    picture->writer = & DummyWriter;
#line 57
    WebPEncodingSetError(picture, (enum WebPEncodingError___0 )0);
    }
  }
#line 59
  return (1);
}
}
#line 66 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static void ResetSegmentHeader(VP8Encoder *enc ) 
{ 
  VP8SegmentHeader *hdr ;

  {
#line 67
  hdr = & enc->segment_hdr_;
#line 68
  hdr->num_segments_ = (enc->config_)->segments;
#line 69
  hdr->update_map_ = hdr->num_segments_ > 1;
#line 70
  hdr->size_ = 0;
  return;
}
}
#line 73 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static void ResetFilterHeader(VP8Encoder *enc ) 
{ 
  VP8FilterHeader *hdr ;

  {
#line 74
  hdr = & enc->filter_hdr_;
#line 75
  hdr->simple_ = 1;
#line 76
  hdr->level_ = 0;
#line 77
  hdr->sharpness_ = 0;
#line 78
  hdr->i4x4_lf_delta_ = 0;
  return;
}
}
#line 81 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static void ResetBoundaryPredictions(VP8Encoder *enc ) 
{ 
  int i ;
  uint8_t *top ;
  uint8_t *left ;

  {
#line 85
  top = enc->preds_ - enc->preds_w_;
#line 86
  left = enc->preds_ - 1;
#line 87
  i = - 1;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 4 * enc->mb_w_)) {
#line 87
      goto while_break;
    }
#line 88
    *(top + i) = (uint8_t )0;
#line 87
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (i < 4 * enc->mb_h_)) {
#line 90
      goto while_break___0;
    }
#line 91
    *(left + i * enc->preds_w_) = (uint8_t )0;
#line 90
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 93
  *(enc->nz_ + - 1) = (uint32_t )0;
  return;
}
}
#line 119 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static void MapConfigToTools(VP8Encoder *enc ) 
{ 
  WebPConfig *config ;
  int method ;
  int limit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 120
  config = enc->config_;
#line 121
  method = config->method;
#line 122
  limit = 100 - config->partition_limit;
#line 123
  enc->method_ = method;
#line 124
  if (method >= 6) {
#line 124
    tmp___1 = 3;
  } else {
#line 124
    if (method >= 5) {
#line 124
      tmp___0 = 2;
    } else {
#line 124
      if (method >= 3) {
#line 124
        tmp = 1;
      } else {
#line 124
        tmp = 0;
      }
#line 124
      tmp___0 = tmp;
    }
#line 124
    tmp___1 = tmp___0;
  }
#line 124
  enc->rd_opt_level_ = (VP8RDLevel )tmp___1;
#line 128
  enc->max_i4_header_bits_ = (65536 * (limit * limit)) / 10000;
#line 132
  enc->thread_level_ = config->thread_level;
#line 134
  enc->do_search_ = config->target_size > 0 || config->target_PSNR > (float )0;
#line 135
  if (! config->low_memory) {
#line 137
    enc->use_tokens_ = method >= 3 && ! enc->do_search_;
#line 139
    if (enc->use_tokens_) {
#line 140
      enc->num_parts_ = 1;
    }
  }
  return;
}
}
#line 166 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static VP8Encoder *InitVP8Encoder(WebPConfig *config , WebPPicture *picture ) 
{ 
  int use_filter ;
  int mb_w ;
  int mb_h ;
  int preds_w ;
  int preds_h ;
  size_t preds_size ;
  int top_stride ;
  size_t nz_size ;
  size_t cache_size ;
  size_t info_size ;
  size_t samples_size ;
  size_t lf_stats_size ;
  unsigned long tmp ;
  VP8Encoder *enc ;
  uint8_t *mem ;
  uint64_t size ;
  void *__cil_tmp19 ;
  LFStats *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 168
  use_filter = config->filter_strength > 0 || config->autofilter > 0;
#line 170
  mb_w = (picture->width + 15) >> 4;
#line 171
  mb_h = (picture->height + 15) >> 4;
#line 172
  preds_w = 4 * mb_w + 1;
#line 173
  preds_h = 4 * mb_h + 1;
#line 174
  preds_size = (unsigned long )(preds_w * preds_h) * sizeof(uint8_t );
#line 175
  top_stride = mb_w * 16;
#line 176
  nz_size = (unsigned long )(mb_w + 1) * sizeof(uint32_t );
#line 177
  cache_size = 2880UL * sizeof(uint8_t );
#line 178
  info_size = (unsigned long )(mb_w * mb_h) * sizeof(VP8MBInfo );
#line 179
  samples_size = (unsigned long )((((((2 * top_stride + 16) + 16) + 16) + 8) + 1) + 30) * sizeof(uint8_t );
#line 183
  if (config->autofilter) {
#line 183
    tmp = sizeof(LFStats ) + 15UL;
  } else {
#line 183
    tmp = (unsigned long )0;
  }
  {
#line 183
  lf_stats_size = tmp;
#line 187
  size = (((((((uint64_t )sizeof(VP8Encoder ) + 15UL) + cache_size) + info_size) + preds_size) + samples_size) + nz_size) + lf_stats_size;
#line 222
  __cil_tmp19 = WebPSafeMalloc(size, sizeof(*mem));
#line 222
  mem = (uint8_t *)__cil_tmp19;
  }
#line 223
  if (mem == (void *)0) {
    {
#line 224
    WebPEncodingSetError(picture, (enum WebPEncodingError___0 )1);
    }
#line 225
    return ((VP8Encoder *)((void *)0));
  }
  {
#line 227
  enc = (VP8Encoder *)mem;
#line 228
  mem = (uint8_t *)((uintptr_t )((mem + sizeof(*enc)) + 15) & 0xfffffffffffffff0UL);
#line 229
  memset(enc, 0, sizeof(*enc));
#line 230
  enc->num_parts_ = 1 << config->partitions;
#line 231
  enc->mb_w_ = mb_w;
#line 232
  enc->mb_h_ = mb_h;
#line 233
  enc->preds_w_ = preds_w;
#line 234
  enc->yuv_in_ = (uint8_t *)mem;
#line 235
  mem += 384;
#line 236
  enc->yuv_out_ = (uint8_t *)mem;
#line 237
  mem += 384;
#line 238
  enc->yuv_out2_ = (uint8_t *)mem;
#line 239
  mem += 384;
#line 240
  enc->yuv_p_ = (uint8_t *)mem;
#line 241
  mem += 1728;
#line 242
  enc->mb_info_ = (VP8MBInfo *)mem;
#line 243
  mem += info_size;
#line 244
  enc->preds_ = ((uint8_t *)mem + 1) + enc->preds_w_;
#line 245
  mem += (unsigned long )(preds_w * preds_h) * sizeof(uint8_t );
#line 246
  enc->nz_ = (uint32_t *)mem + 1;
#line 247
  mem += nz_size;
  }
#line 248
  if (lf_stats_size) {
#line 248
    tmp___0 = (LFStats *)((LFStats *)((uintptr_t )(mem + 15) & 0xfffffffffffffff0UL));
  } else {
#line 248
    tmp___0 = (LFStats *)((LFStats *)((void *)0));
  }
#line 248
  enc->lf_stats_ = (int )tmp___0;
#line 249
  mem += lf_stats_size;
#line 252
  mem = (uint8_t *)((uintptr_t )(mem + 15) & 0xfffffffffffffff0UL);
#line 253
  enc->y_top_ = (uint8_t *)mem;
#line 254
  enc->uv_top_ = enc->y_top_ + top_stride;
#line 255
  mem += 2 * top_stride;
#line 256
  mem = (uint8_t *)((uintptr_t )((mem + 1) + 15) & 0xfffffffffffffff0UL);
#line 257
  enc->y_left_ = (uint8_t *)mem;
#line 258
  mem += 32;
#line 259
  enc->u_left_ = (uint8_t *)mem;
#line 260
  mem += 16;
#line 261
  enc->v_left_ = (uint8_t *)mem;
#line 262
  mem += 8;
#line 264
  enc->config_ = config;
#line 265
  if (use_filter) {
#line 265
    if (config->filter_type == 1) {
#line 265
      tmp___1 = 0;
    } else {
#line 265
      tmp___1 = 1;
    }
#line 265
    tmp___2 = tmp___1;
  } else {
#line 265
    tmp___2 = 2;
  }
  {
#line 265
  enc->profile_ = tmp___2;
#line 266
  enc->pic_ = picture;
#line 267
  enc->percent_ = 0;
#line 269
  MapConfigToTools(enc);
#line 270
  VP8EncDspInit();
#line 271
  VP8DefaultProbas(enc);
#line 272
  ResetSegmentHeader(enc);
#line 273
  ResetFilterHeader(enc);
#line 274
  ResetBoundaryPredictions(enc);
#line 276
  VP8EncInitAlpha(enc);
#line 281
  VP8TBufferInit(& enc->tokens_);
  }
#line 282
  return (enc);
}
}
#line 285 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static int DeleteVP8Encoder(VP8Encoder *enc ) 
{ 
  int ok ;
  int __cil_tmp3 ;

  {
#line 286
  ok = 1;
#line 287
  if (enc != (void *)0) {
    {
#line 288
    ok = VP8EncDeleteAlpha(enc);
#line 292
    VP8TBufferClear(& enc->tokens_);
#line 293
    free(enc);
    }
  }
#line 295
  return (ok);
}
}
#line 300 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static double GetPSNR(uint64_t err , uint64_t size ) 
{ 
  double __cil_tmp3 ;
  double tmp ;

  {
#line 301
  if (err) {
    {
#line 301
    __cil_tmp3 = log10(((255. * 255.) * (double )size) / (double )err);
#line 301
    tmp = 10. * __cil_tmp3;
    }
  } else {
#line 301
    tmp = 99.;
  }
#line 301
  return (tmp);
}
}
#line 304 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static void FinalizePSNR(VP8Encoder *enc ) 
{ 
  WebPAuxStats *stats ;
  uint64_t size ;
  uint64_t *sse ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;

  {
  {
#line 305
  stats = (enc->pic_)->stats;
#line 306
  size = enc->sse_count_;
#line 307
  sse = (uint64_t *)enc->sse_;
#line 308
  __cil_tmp5 = GetPSNR(*(sse + 0), size);
#line 308
  stats->PSNR[0] = (float )__cil_tmp5;
#line 309
  __cil_tmp6 = GetPSNR(*(sse + 1), size / 4UL);
#line 309
  stats->PSNR[1] = (float )__cil_tmp6;
#line 310
  __cil_tmp7 = GetPSNR(*(sse + 2), size / 4UL);
#line 310
  stats->PSNR[2] = (float )__cil_tmp7;
#line 311
  __cil_tmp8 = GetPSNR((*(sse + 0) + *(sse + 1)) + *(sse + 2), (size * 3UL) / 2UL);
#line 311
  stats->PSNR[3] = (float )__cil_tmp8;
#line 312
  __cil_tmp9 = GetPSNR(*(sse + 3), size);
#line 312
  stats->PSNR[4] = (float )__cil_tmp9;
  }
  return;
}
}
#line 315 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
static void StoreStats(VP8Encoder *enc ) 
{ 
  WebPAuxStats *stats ;
  int i ;
  int s ;

  {
#line 316
  stats = (enc->pic_)->stats;
#line 317
  if (stats != (void *)0) {
#line 319
    i = 0;
    {
#line 319
    while (1) {
      while_continue: /* CIL Label */ ;
#line 319
      if (! (i < 4)) {
#line 319
        goto while_break;
      }
#line 320
      stats->segment_level[i] = enc->dqm_[i].fstrength_;
#line 321
      stats->segment_quant[i] = enc->dqm_[i].quant_;
#line 322
      s = 0;
      {
#line 322
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 322
        if (! (s <= 2)) {
#line 322
          goto while_break___0;
        }
#line 323
        stats->residual_bytes[s][i] = enc->residual_bytes_[s][i];
#line 322
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 319
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 326
    FinalizePSNR(enc);
#line 327
    stats->coded_size = enc->coded_size_;
#line 328
    i = 0;
    }
    {
#line 328
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 328
      if (! (i < 3)) {
#line 328
        goto while_break___1;
      }
#line 329
      stats->block_count[i] = enc->block_count_[i];
#line 328
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 332
  WebPReportProgress(enc->pic_, 100, & enc->percent_);
  }
  return;
}
}
#line 335 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
int WebPEncodingSetError(WebPPicture *pic , enum WebPEncodingError___0 error ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 339
  ((WebPPicture *)pic)->error_code = error;
#line 340
  return (0);
}
}
#line 343 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
int WebPReportProgress(WebPPicture *pic , int percent , int *percent_store ) 
{ 
  int __cil_tmp4 ;

  {
#line 345
  if (percent_store != (void *)0) {
#line 345
    if (percent != *percent_store) {
      {
#line 346
      *percent_store = percent;
#line 347
      __cil_tmp4 = (*(pic->progress_hook))(percent, pic);
      }
#line 347
      if (pic->progress_hook) {
#line 347
        if (! __cil_tmp4) {
          {
#line 349
          WebPEncodingSetError(pic, (enum WebPEncodingError___0 )10);
          }
#line 350
          return (0);
        }
      }
    }
  }
#line 353
  return (1);
}
}
#line 357 "/doner/libwebp/libwebp-v0.3.0/src/enc/webpenc.c"
int WebPEncode(WebPConfig *config , WebPPicture *pic ) 
{ 
  int ok ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  VP8Encoder *enc ;
  int __cil_tmp10 ;
  VP8Encoder *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 358
  ok = 0;
#line 360
  if (pic == (void *)0) {
#line 361
    return (0);
  }
  {
#line 362
  WebPEncodingSetError(pic, (enum WebPEncodingError___0 )0);
  }
#line 363
  if (config == (void *)0) {
    {
#line 364
    __cil_tmp4 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )3);
    }
#line 364
    return (__cil_tmp4);
  }
  {
#line 365
  __cil_tmp5 = WebPValidateConfig(config);
  }
#line 365
  if (! __cil_tmp5) {
    {
#line 366
    __cil_tmp6 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )4);
    }
#line 366
    return (__cil_tmp6);
  }
#line 367
  if (pic->width <= 0) {
    {
    {
#line 368
    __cil_tmp7 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )5);
    }
    }
#line 368
    return (__cil_tmp7);
  } else
#line 367
  if (pic->height <= 0) {
    {
    {
#line 368
    __cil_tmp7 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )5);
    }
    }
#line 368
    return (__cil_tmp7);
  }
#line 369
  if (pic->width > 16383) {
    {
    {
#line 370
    __cil_tmp8 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )5);
    }
    }
#line 370
    return (__cil_tmp8);
  } else
#line 369
  if (pic->height > 16383) {
    {
    {
#line 370
    __cil_tmp8 = WebPEncodingSetError(pic, (enum WebPEncodingError___0 )5);
    }
    }
#line 370
    return (__cil_tmp8);
  }
#line 372
  if (pic->stats != (void *)0) {
    {
#line 372
    memset(pic->stats, 0, sizeof(*(pic->stats)));
    }
  }
#line 374
  if (! config->lossless) {
#line 375
    enc = (VP8Encoder *)((void *)0);
#line 376
    if (pic->y == (void *)0) {
      _L: /* CIL Label */ 
      _L___7: /* CIL Label */ 
      {
#line 378
      __cil_tmp10 = WebPPictureARGBToYUVA(pic, (enum WebPEncCSP___0 )0);
      }
#line 378
      if (! __cil_tmp10) {
#line 378
        return (0);
      }
    } else
#line 376
    if (pic->u == (void *)0) {
#line 376
      goto _L;
    } else
#line 376
    if (pic->v == (void *)0) {
#line 376
      goto _L;
    }
    {
#line 381
    enc = InitVP8Encoder(config, pic);
    }
#line 382
    if (enc == (void *)0) {
#line 382
      return (0);
    }
    {
#line 384
    ok = VP8EncAnalyze(enc);
#line 387
    __cil_tmp13 = VP8EncStartAlpha(enc);
#line 387
    ok = ok && __cil_tmp13;
    }
#line 388
    if (! enc->use_tokens_) {
      {
#line 389
      ok = VP8EncLoop(enc);
      }
    } else {
      {
#line 391
      ok = VP8EncTokenLoop(enc);
      }
    }
    {
#line 393
    __cil_tmp16 = VP8EncFinishAlpha(enc);
#line 393
    ok = ok && __cil_tmp16;
#line 398
    __cil_tmp17 = VP8EncWrite(enc);
#line 398
    ok = ok && __cil_tmp17;
#line 399
    StoreStats(enc);
    }
#line 400
    if (! ok) {
      {
#line 401
      VP8EncFreeBitWriters(enc);
      }
    }
    {
#line 403
    __cil_tmp18 = DeleteVP8Encoder(enc);
    }
#line 403
    ok &= __cil_tmp18;
  } else {
    {
#line 406
    __cil_tmp19 = WebPPictureYUVAToARGB(pic);
    }
#line 406
    if (pic->argb == (void *)0) {
#line 406
      if (! __cil_tmp19) {
#line 407
        return (0);
      }
    }
    {
#line 410
    ok = VP8LEncodeImage(config, pic);
    }
  }
#line 413
  return (ok);
}
}
#line 152 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
__inline static int WebPConfigInit___0(WebPConfig *config ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 153
  __cil_tmp2 = WebPConfigInitInternal(config, (enum WebPPreset )0, 75.f, 513);
  }
#line 153
  return (__cil_tmp2);
}
}
#line 161 "/doner/libwebp/libwebp-v0.3.0/src/enc/./../webp/encode.h"
__inline static int WebPConfigPreset___0(WebPConfig *config , enum WebPPreset preset ,
                                         float quality ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 163
  __cil_tmp4 = WebPConfigInitInternal(config, preset, quality, 513);
  }
#line 163
  return (__cil_tmp4);
}
}
#line 37 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
int WebPGetDecoderVersion(void) ;
#line 43
int WebPGetInfo(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 51
uint8_t *WebPDecodeRGBA(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 55
uint8_t *WebPDecodeARGB(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 59
uint8_t *WebPDecodeBGRA(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 64
uint8_t *WebPDecodeRGB(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 68
uint8_t *WebPDecodeBGR(uint8_t *data , size_t data_size , int *width , int *height ) ;
#line 81
uint8_t *WebPDecodeYUV(uint8_t *data , size_t data_size , int *width , int *height ,
                       uint8_t **u , uint8_t **v , int *stride , int *uv_stride ) ;
#line 94
uint8_t *WebPDecodeRGBAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) ;
#line 97
uint8_t *WebPDecodeARGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) ;
#line 100
uint8_t *WebPDecodeBGRAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) ;
#line 106
uint8_t *WebPDecodeRGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) ;
#line 109
uint8_t *WebPDecodeBGRInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) ;
#line 120
uint8_t *WebPDecodeYUVInto(uint8_t *data , size_t data_size , uint8_t *luma , size_t luma_size ,
                           int luma_stride , uint8_t *u , size_t u_size , int u_stride ,
                           uint8_t *v , size_t v_size , int v_stride ) ;
#line 157 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
__inline static int WebPIsPremultipliedMode(enum WEBP_CSP_MODE___0 mode ) 
{ 


  {
#line 158
  return ((((unsigned int )mode == 7U || (unsigned int )mode == 8U) || (unsigned int )mode == 9U) || (unsigned int )mode == 10U);
}
}
#line 162 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
__inline static int WebPIsAlphaMode(enum WEBP_CSP_MODE___0 mode ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 163
  __cil_tmp2 = WebPIsPremultipliedMode(mode);
  }
#line 163
  return ((((((unsigned int )mode == 1U || (unsigned int )mode == 3U) || (unsigned int )mode == 4U) || (unsigned int )mode == 5U) || (unsigned int )mode == 12U) || __cil_tmp2);
}
}
#line 168 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
__inline static int WebPIsRGBMode(enum WEBP_CSP_MODE___0 mode ) 
{ 


  {
#line 169
  return ((unsigned int )mode < 11U);
}
}
#line 208
int WebPInitDecBufferInternal(WebPDecBuffer *buffer , int version ) ;
#line 212 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
__inline static int WebPInitDecBuffer(WebPDecBuffer *buffer ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 213
  __cil_tmp2 = WebPInitDecBufferInternal(buffer, 513);
  }
#line 213
  return (__cil_tmp2);
}
}
#line 218
void WebPFreeDecBuffer(WebPDecBuffer *buffer ) ;
#line 266
WebPIDecoder *WebPINewDecoder(WebPDecBuffer *output_buffer ) ;
#line 278
WebPIDecoder *WebPINewRGB(enum WEBP_CSP_MODE mode , uint8_t *output_buffer , size_t output_buffer_size ,
                          int output_stride ) ;
#line 293
WebPIDecoder *WebPINewYUVA(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                           size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                           int v_stride , uint8_t *a , size_t a_size , int a_stride ) ;
#line 301
WebPIDecoder *WebPINewYUV(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                          size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                          int v_stride ) ;
#line 308
void WebPIDelete(WebPIDecoder *idec ) ;
#line 313
enum VP8StatusCode___0 WebPIAppend(WebPIDecoder *idec , uint8_t *data , size_t data_size ) ;
#line 321
enum VP8StatusCode___0 WebPIUpdate(WebPIDecoder *idec , uint8_t *data , size_t data_size ) ;
#line 330
uint8_t *WebPIDecGetRGB(WebPIDecoder *idec , int *last_y , int *width , int *height ,
                        int *stride ) ;
#line 337
uint8_t *WebPIDecGetYUVA(WebPIDecoder *idec , int *last_y , uint8_t **u , uint8_t **v ,
                         uint8_t **a , int *width , int *height , int *stride , int *uv_stride ,
                         int *a_stride ) ;
#line 344 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
__inline static uint8_t *WebPIDecGetYUV(WebPIDecoder *idec , int *last_y , uint8_t **u ,
                                        uint8_t **v , int *width , int *height , int *stride ,
                                        int *uv_stride ) 
{ 
  uint8_t *__cil_tmp9 ;

  {
  {
#line 347
  __cil_tmp9 = WebPIDecGetYUVA(idec, last_y, u, v, (uint8_t **)((void *)0), width,
                               height, stride, uv_stride, (int *)((void *)0));
  }
#line 347
  return (__cil_tmp9);
}
}
#line 357
WebPDecBuffer *WebPIDecodedArea(WebPIDecoder *idec , int *left , int *top , int *width ,
                                int *height ) ;
#line 410
enum VP8StatusCode___0 WebPGetFeaturesInternal(uint8_t *data , size_t data_size ,
                                               WebPBitstreamFeatures *features , int version ) ;
#line 418 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
__inline static enum VP8StatusCode___0 WebPGetFeatures(uint8_t *data , size_t data_size ,
                                                       WebPBitstreamFeatures *features ) 
{ 
  enum VP8StatusCode___0 __cil_tmp4 ;

  {
  {
#line 421
  __cil_tmp4 = WebPGetFeaturesInternal(data, data_size, features, 513);
  }
#line 421
  return (__cil_tmp4);
}
}
#line 451
int WebPInitDecoderConfigInternal(WebPDecoderConfig *config , int version ) ;
#line 456 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../webp/decode.h"
__inline static int WebPInitDecoderConfig(WebPDecoderConfig *config ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 457
  __cil_tmp2 = WebPInitDecoderConfigInternal(config, 513);
  }
#line 457
  return (__cil_tmp2);
}
}
#line 469
WebPIDecoder *WebPIDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 475
enum VP8StatusCode___0 WebPDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) ;
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/lossless.h"
void VP8LInverseTransform(VP8LTransform *transform , int row_start , int row_end ,
                          uint32_t *in , uint32_t *out ) ;
#line 37
void VP8LSubtractGreenFromBlueAndRed(uint32_t *argb_data , int num_pixs ) ;
#line 39
void VP8LResidualImage(int width , int height , int bits , uint32_t *argb , uint32_t *argb_scratch ,
                       uint32_t *image ) ;
#line 43
void VP8LColorSpaceTransform(int width , int height , int bits , int step , uint32_t *argb ,
                             uint32_t *image ) ;
#line 50
void VP8LConvertFromBGRA(uint32_t *in_data , int num_pixels , enum WEBP_CSP_MODE out_colorspace ,
                         uint8_t *rgba ) ;
#line 57 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/lossless.h"
__inline static uint32_t VP8LSubSampleSize(uint32_t size , uint32_t sampling_bits ) 
{ 


  {
#line 59
  return (((size + (unsigned int )(1 << sampling_bits)) - 1U) >> sampling_bits);
}
}
#line 64
float const   kLog2Table[256] ;
#line 65
float const   kSLog2Table[256] ;
#line 66
float VP8LFastLog2Slow(int v ) ;
#line 67
float VP8LFastSLog2Slow(int v ) ;
#line 68 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/lossless.h"
__inline static float VP8LFastLog2(int v ) 
{ 
  float __cil_tmp2 ;
  float tmp ;

  {
#line 69
  if (v < 256) {
#line 69
    tmp = kLog2Table[v];
  } else {
    {
#line 69
    __cil_tmp2 = VP8LFastLog2Slow(v);
#line 69
    tmp = (float const   )__cil_tmp2;
    }
  }
#line 69
  return ((int )tmp);
}
}
#line 72 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/lossless.h"
__inline static float VP8LFastSLog2(int v ) 
{ 
  float __cil_tmp2 ;
  float tmp ;

  {
#line 73
  if (v < 256) {
#line 73
    tmp = kSLog2Table[v];
  } else {
    {
#line 73
    __cil_tmp2 = VP8LFastSLog2Slow(v);
#line 73
    tmp = (float const   )__cil_tmp2;
    }
  }
#line 73
  return ((int )tmp);
}
}
#line 78 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/lossless.h"
__inline static uint32_t VP8LSubPixels(uint32_t a , uint32_t b ) 
{ 
  uint32_t alpha_and_green ;
  uint32_t red_and_blue ;

  {
#line 79
  alpha_and_green = (16711935U + (a & 4278255360U)) - (b & 4278255360U);
#line 81
  red_and_blue = (4278255360U + (a & 16711935U)) - (b & 16711935U);
#line 83
  return ((alpha_and_green & 4278255360U) | (red_and_blue & 16711935U));
}
}
#line 37 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int CompareColors(void const   *p1 , void const   *p2 ) 
{ 
  uint32_t a ;
  uint32_t b ;
  int tmp ;
  int tmp___0 ;

  {
#line 38
  a = *((uint32_t *)p1);
#line 39
  b = *((uint32_t *)p2);
#line 41
  if (a < b) {
#line 41
    tmp___0 = - 1;
  } else {
#line 41
    tmp___0 = 1;
  }
#line 41
  return (tmp___0);
}
}
#line 46 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int AnalyzeAndCreatePalette(WebPPicture *pic , uint32_t palette[256] , int *palette_size ) 
{ 
  int i ;
  int x ;
  int y ;
  int key ;
  int num_colors ;
  uint8_t in_use[1024] ;
  unsigned int tmp ;
  uint32_t colors[1024] ;
  static uint32_t kHashMul___14 ;
  uint32_t *argb ;
  int width ;
  int height ;
  uint32_t last_pix ;

  {
#line 50
  num_colors = 0;
#line 51
  in_use[0] = (uint8_t )0;
#line 51
  tmp = (unsigned int )1;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (tmp >= 1024) {
#line 51
      goto while_break;
    }
#line 51
    in_use[tmp] = 0;
#line 51
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  kHashMul___14 = (uint32_t )506832829;
#line 54
  argb = pic->argb;
#line 55
  width = pic->width;
#line 56
  height = pic->height;
#line 57
  last_pix = ~ *(argb + 0);
#line 59
  y = 0;
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 59
    if (! (y < height)) {
#line 59
      goto while_break___0;
    }
#line 60
    x = 0;
    {
#line 60
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 60
      if (! (x < width)) {
#line 60
        goto while_break___1;
      }
#line 61
      if (*(argb + x) == last_pix) {
#line 62
        goto while_continue___1;
      }
#line 64
      last_pix = *(argb + x);
#line 65
      key = (int )(kHashMul___14 * last_pix >> 22);
      {
#line 66
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 67
        if (! in_use[key]) {
#line 68
          colors[key] = last_pix;
#line 69
          in_use[key] = (uint8_t )1;
#line 70
          num_colors ++;
#line 71
          if (num_colors > 256) {
#line 72
            return (0);
          }
#line 74
          goto while_break___2;
        } else
#line 75
        if (colors[key] == last_pix) {
#line 77
          goto while_break___2;
        } else {
#line 81
          key ++;
#line 82
          key &= 1023;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 60
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 86
    argb += pic->argb_stride;
#line 59
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 90
  num_colors = 0;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 91
    if (! (i < (int )(sizeof(in_use) / sizeof(in_use[0])))) {
#line 91
      goto while_break___3;
    }
#line 92
    if (in_use[i]) {
#line 93
      palette[num_colors] = colors[i];
#line 94
      num_colors ++;
    }
#line 91
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 98
  qsort(palette, (size_t )num_colors, sizeof(palette[0]), & CompareColors);
#line 99
  *palette_size = num_colors;
  }
#line 100
  return (1);
}
}
#line 103 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int AnalyzeEntropy(uint32_t *argb , int width , int height , int argb_stride ,
                          double *nonpredicted_bits , double *predicted_bits ) 
{ 
  int x ;
  int y ;
  uint32_t *last_line ;
  uint32_t last_pix ;
  VP8LHistogram *nonpredicted ;
  VP8LHistogram *predicted ;
  void *__cil_tmp13 ;
  uint32_t pix ;
  uint32_t pix_diff ;
  uint32_t __cil_tmp16 ;
  PixOrCopy pix_token ;
  PixOrCopy __cil_tmp18 ;
  PixOrCopy pix_diff_token ;
  PixOrCopy __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;

  {
  {
#line 108
  last_line = (uint32_t *)((void *)0);
#line 109
  last_pix = *(argb + 0);
#line 111
  nonpredicted = (VP8LHistogram *)((void *)0);
#line 112
  __cil_tmp13 = malloc(2UL * sizeof(*predicted));
#line 112
  predicted = (VP8LHistogram *)__cil_tmp13;
  }
#line 114
  if (predicted == (void *)0) {
#line 114
    return (0);
  }
  {
#line 115
  nonpredicted = predicted + 1;
#line 117
  VP8LHistogramInit(predicted, 0);
#line 118
  VP8LHistogramInit(nonpredicted, 0);
#line 119
  y = 0;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (y < height)) {
#line 119
      goto while_break;
    }
#line 120
    x = 0;
    {
#line 120
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 120
      if (! (x < width)) {
#line 120
        goto while_break___0;
      }
      {
#line 121
      pix = *(argb + x);
#line 122
      __cil_tmp16 = VP8LSubPixels(pix, last_pix);
#line 122
      pix_diff = __cil_tmp16;
      }
#line 123
      if (pix_diff == 0U) {
#line 123
        goto while_continue___0;
      }
#line 124
      if (last_line != (void *)0) {
#line 124
        if (pix == *(last_line + x)) {
#line 125
          goto while_continue___0;
        }
      }
      {
#line 127
      last_pix = pix;
#line 129
      __cil_tmp18 = PixOrCopyCreateLiteral(pix);
#line 129
      pix_token = __cil_tmp18;
#line 130
      __cil_tmp20 = PixOrCopyCreateLiteral(pix_diff);
#line 130
      pix_diff_token = __cil_tmp20;
#line 131
      VP8LHistogramAddSinglePixOrCopy(nonpredicted, & pix_token);
#line 132
      VP8LHistogramAddSinglePixOrCopy(predicted, & pix_diff_token);
      }
#line 120
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 135
    last_line = argb;
#line 136
    argb += argb_stride;
#line 119
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  *nonpredicted_bits = VP8LHistogramEstimateBitsBulk(nonpredicted);
#line 139
  *predicted_bits = VP8LHistogramEstimateBitsBulk(predicted);
#line 140
  free(predicted);
  }
#line 141
  return (1);
}
}
#line 144 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int VP8LEncAnalyze(VP8LEncoder *enc , enum WebPImageHint image_hint ) 
{ 
  WebPPicture *pic ;
  int tmp ;
  int __cil_tmp5 ;
  double non_pred_entropy ;
  double pred_entropy ;
  int __cil_tmp8 ;

  {
  {
#line 145
  pic = enc->pic_;
#line 148
  enc->use_palette_ = AnalyzeAndCreatePalette(pic, (uint32_t *)enc->palette_, & enc->palette_size_);
  }
#line 151
  if ((unsigned int )image_hint == 3U) {
#line 152
    if (enc->use_palette_) {
#line 152
      if (enc->palette_size_ < 64) {
#line 153
        enc->use_palette_ = 0;
      }
    }
  }
#line 157
  if (! enc->use_palette_) {
#line 158
    if ((unsigned int )image_hint == 2U) {
#line 159
      enc->use_predict_ = 1;
#line 160
      enc->use_cross_color_ = 1;
    } else {
      {
#line 163
      __cil_tmp8 = AnalyzeEntropy(pic->argb, pic->width, pic->height, pic->argb_stride,
                                  & non_pred_entropy, & pred_entropy);
      }
#line 163
      if (! __cil_tmp8) {
#line 165
        return (0);
      }
#line 167
      if (pred_entropy < 0.95 * non_pred_entropy) {
#line 168
        enc->use_predict_ = 1;
#line 172
        enc->use_cross_color_ = 1;
      }
    }
  }
#line 177
  return (1);
}
}
#line 180 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int GetHuffBitLengthsAndCodes(VP8LHistogramSet *histogram_image , HuffmanTreeCode *huffman_codes ) 
{ 
  int i ;
  int k ;
  int ok ;
  uint64_t total_length_size ;
  uint8_t *mem_buf ;
  int histogram_image_size ;
  VP8LHistogram *histo ;
  HuffmanTreeCode *codes ;
  int num_symbols ;
  int __cil_tmp12 ;
  int tmp ;
  int tmp___0 ;
  uint16_t *codes___0 ;
  uint8_t *lengths ;
  void *__cil_tmp17 ;
  int bit_length ;
  HuffmanTreeCode *codes___1 ;
  VP8LHistogram *histo___0 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;

  {
#line 184
  ok = 1;
#line 185
  total_length_size = (uint64_t )0;
#line 186
  mem_buf = (uint8_t *)((void *)0);
#line 187
  histogram_image_size = histogram_image->size;
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < histogram_image_size)) {
#line 190
      goto while_break;
    }
#line 191
    histo = *(histogram_image->histograms + i);
#line 192
    codes = huffman_codes + 5 * i;
#line 193
    k = 0;
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! (k < 5)) {
#line 193
        goto while_break___0;
      }
#line 194
      if (k == 0) {
        {
#line 194
        __cil_tmp12 = VP8LHistogramNumCodes(histo);
#line 194
        tmp___0 = __cil_tmp12;
        }
      } else {
#line 194
        if (k == 4) {
#line 194
          tmp = 40;
        } else {
#line 194
          tmp = 256;
        }
#line 194
        tmp___0 = tmp;
      }
#line 194
      num_symbols = tmp___0;
#line 197
      (codes + k)->num_symbols = num_symbols;
#line 198
      total_length_size += (unsigned long )num_symbols;
#line 193
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  __cil_tmp17 = WebPSafeCalloc(total_length_size, sizeof(*lengths) + sizeof(*codes___0));
#line 206
  mem_buf = (uint8_t *)__cil_tmp17;
  }
#line 208
  if (mem_buf == (void *)0) {
#line 209
    ok = 0;
#line 210
    goto End;
  }
#line 212
  codes___0 = (uint16_t *)mem_buf;
#line 213
  lengths = (uint8_t *)(codes___0 + total_length_size);
#line 214
  i = 0;
  {
#line 214
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 214
    if (! (i < 5 * histogram_image_size)) {
#line 214
      goto while_break___1;
    }
#line 215
    bit_length = (huffman_codes + i)->num_symbols;
#line 216
    (huffman_codes + i)->codes = codes___0;
#line 217
    (huffman_codes + i)->code_lengths = lengths;
#line 218
    codes___0 += bit_length;
#line 219
    lengths += bit_length;
#line 214
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 224
  i = 0;
  {
#line 224
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 224
    if (! (ok && i < histogram_image_size)) {
#line 224
      goto while_break___2;
    }
    {
#line 225
    codes___1 = huffman_codes + 5 * i;
#line 226
    histo___0 = *(histogram_image->histograms + i);
#line 227
    __cil_tmp21 = VP8LCreateHuffmanTree((int *)histo___0->literal_, 15, codes___1 + 0);
#line 227
    ok = ok && __cil_tmp21;
#line 228
    __cil_tmp22 = VP8LCreateHuffmanTree((int *)histo___0->red_, 15, codes___1 + 1);
#line 228
    ok = ok && __cil_tmp22;
#line 229
    __cil_tmp23 = VP8LCreateHuffmanTree((int *)histo___0->blue_, 15, codes___1 + 2);
#line 229
    ok = ok && __cil_tmp23;
#line 230
    __cil_tmp24 = VP8LCreateHuffmanTree((int *)histo___0->alpha_, 15, codes___1 + 3);
#line 230
    ok = ok && __cil_tmp24;
#line 231
    __cil_tmp25 = VP8LCreateHuffmanTree((int *)histo___0->distance_, 15, codes___1 + 4);
#line 231
    ok = ok && __cil_tmp25;
    }
#line 224
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  End: 
#line 235
  if (! ok) {
    {
#line 236
    free(mem_buf);
#line 238
    memset(huffman_codes, 0, (unsigned long )(5 * histogram_image_size) * sizeof(*huffman_codes));
    }
  }
#line 240
  return (ok);
}
}
#line 243 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static void StoreHuffmanTreeOfHuffmanTreeToBitMask(VP8LBitWriter *bw , uint8_t *code_length_bitdepth ) 
{ 
  static uint8_t kStorageOrder[19] ;
  int i ;
  int codes_to_store ;

  {
#line 248
  kStorageOrder[0] = (uint8_t )17;
#line 248
  kStorageOrder[1] = (uint8_t )18;
#line 248
  kStorageOrder[2] = (uint8_t )0;
#line 248
  kStorageOrder[3] = (uint8_t )1;
#line 248
  kStorageOrder[4] = (uint8_t )2;
#line 248
  kStorageOrder[5] = (uint8_t )3;
#line 248
  kStorageOrder[6] = (uint8_t )4;
#line 248
  kStorageOrder[7] = (uint8_t )5;
#line 248
  kStorageOrder[8] = (uint8_t )16;
#line 248
  kStorageOrder[9] = (uint8_t )6;
#line 248
  kStorageOrder[10] = (uint8_t )7;
#line 248
  kStorageOrder[11] = (uint8_t )8;
#line 248
  kStorageOrder[12] = (uint8_t )9;
#line 248
  kStorageOrder[13] = (uint8_t )10;
#line 248
  kStorageOrder[14] = (uint8_t )11;
#line 248
  kStorageOrder[15] = (uint8_t )12;
#line 248
  kStorageOrder[16] = (uint8_t )13;
#line 248
  kStorageOrder[17] = (uint8_t )14;
#line 248
  kStorageOrder[18] = (uint8_t )15;
#line 253
  codes_to_store = 19;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (codes_to_store > 4)) {
#line 254
      goto while_break;
    }
#line 255
    if ((int )*(code_length_bitdepth + kStorageOrder[codes_to_store - 1]) != 0) {
#line 256
      goto while_break;
    }
#line 254
    codes_to_store --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  VP8LWriteBits(bw, 4, (uint32_t )(codes_to_store - 4));
#line 260
  i = 0;
  }
  {
#line 260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 260
    if (! (i < codes_to_store)) {
#line 260
      goto while_break___0;
    }
    {
#line 261
    VP8LWriteBits(bw, 3, (uint32_t )*(code_length_bitdepth + kStorageOrder[i]));
    }
#line 260
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 265 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static void ClearHuffmanTreeIfOnlyOneSymbol(HuffmanTreeCode *huffman_code ) 
{ 
  int k ;
  int count ;

  {
#line 268
  count = 0;
#line 269
  k = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (k < huffman_code->num_symbols)) {
#line 269
      goto while_break;
    }
#line 270
    if ((int )*(huffman_code->code_lengths + k) != 0) {
#line 271
      count ++;
#line 272
      if (count > 1) {
#line 272
        return;
      }
    }
#line 269
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  k = 0;
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 275
    if (! (k < huffman_code->num_symbols)) {
#line 275
      goto while_break___0;
    }
#line 276
    *(huffman_code->code_lengths + k) = (uint8_t )0;
#line 277
    *(huffman_code->codes + k) = (uint16_t )0;
#line 275
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 281 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static void StoreHuffmanTreeToBitMask(VP8LBitWriter *bw , HuffmanTreeToken *tokens ,
                                      int num_tokens , HuffmanTreeCode *huffman_code ) 
{ 
  int i ;
  int ix ;
  int extra_bits ;

  {
#line 286
  i = 0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (i < num_tokens)) {
#line 286
      goto while_break;
    }
    {
#line 287
    ix = (int )(tokens + i)->code;
#line 288
    extra_bits = (int )(tokens + i)->extra_bits;
#line 289
    VP8LWriteBits(bw, (int )*(huffman_code->code_lengths + ix), (uint32_t )*(huffman_code->codes + ix));
    }
    {
#line 291
    if (ix == 16) {
#line 291
      goto case_16;
    }
#line 294
    if (ix == 17) {
#line 294
      goto case_17;
    }
#line 297
    if (ix == 18) {
#line 297
      goto case_18;
    }
#line 290
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 292
    VP8LWriteBits(bw, 2, (uint32_t )extra_bits);
    }
#line 293
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 295
    VP8LWriteBits(bw, 3, (uint32_t )extra_bits);
    }
#line 296
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 298
    VP8LWriteBits(bw, 7, (uint32_t )extra_bits);
    }
#line 299
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 286
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 304 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int StoreFullHuffmanCode(VP8LBitWriter *bw , HuffmanTreeCode *tree ) 
{ 
  int ok ;
  uint8_t code_length_bitdepth[19] ;
  unsigned int tmp ;
  uint16_t code_length_bitdepth_symbols[19] ;
  unsigned int tmp___0 ;
  int max_tokens ;
  int num_tokens ;
  HuffmanTreeCode huffman_code ;
  HuffmanTreeToken *tokens ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  int histogram[19] ;
  unsigned int tmp___1 ;
  int i ;
  int __cil_tmp17 ;
  int trailing_zero_bits ;
  int trimmed_length ;
  int write_trimmed_length ;
  int length ;
  int i___0 ;
  int __cil_tmp23 ;
  int ix ;
  int tmp___2 ;
  int nbits ;
  int __cil_tmp27 ;
  int nbitpairs ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 306
  ok = 0;
#line 307
  code_length_bitdepth[0] = (uint8_t )0;
#line 307
  tmp = (unsigned int )1;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (tmp >= 19) {
#line 307
      goto while_break;
    }
#line 307
    code_length_bitdepth[tmp] = 0;
#line 307
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  code_length_bitdepth_symbols[0] = (uint16_t )0;
#line 308
  tmp___0 = (unsigned int )1;
  {
#line 308
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 308
    if (tmp___0 >= 19) {
#line 308
      goto while_break___0;
    }
#line 308
    code_length_bitdepth_symbols[tmp___0] = 0;
#line 308
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 309
  max_tokens = tree->num_symbols;
#line 312
  __cil_tmp12 = WebPSafeMalloc((uint64_t )max_tokens, sizeof(*tokens));
#line 312
  tokens = (HuffmanTreeToken *)__cil_tmp12;
  }
#line 314
  if (tokens == (void *)0) {
#line 314
    return (0);
  }
  {
#line 316
  huffman_code.num_symbols = 19;
#line 317
  huffman_code.code_lengths = (uint8_t *)code_length_bitdepth;
#line 318
  huffman_code.codes = (uint16_t *)code_length_bitdepth_symbols;
#line 320
  VP8LWriteBits(bw, 1, (uint32_t )0);
#line 321
  num_tokens = VP8LCreateCompressedHuffmanTree(tree, tokens, max_tokens);
#line 323
  histogram[0] = 0;
  }
#line 323
  tmp___1 = (unsigned int )1;
  {
#line 323
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 323
    if (tmp___1 >= 19) {
#line 323
      goto while_break___1;
    }
#line 323
    histogram[tmp___1] = 0;
#line 323
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 325
    if (! (i < num_tokens)) {
#line 325
      goto while_break___2;
    }
#line 326
    (histogram[(tokens + i)->code]) ++;
#line 325
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 329
  __cil_tmp17 = VP8LCreateHuffmanTree((int *)histogram, 7, & huffman_code);
  }
#line 329
  if (! __cil_tmp17) {
#line 330
    goto End;
  }
  {
#line 334
  StoreHuffmanTreeOfHuffmanTreeToBitMask(bw, (uint8_t *)code_length_bitdepth);
#line 335
  ClearHuffmanTreeIfOnlyOneSymbol(& huffman_code);
#line 337
  trailing_zero_bits = 0;
#line 338
  trimmed_length = num_tokens;
#line 341
  i___0 = num_tokens;
  }
  {
#line 342
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 342
    __cil_tmp23 = i___0;
#line 342
    i___0 --;
#line 342
    if (! (__cil_tmp23 > 0)) {
#line 342
      goto while_break___3;
    }
#line 343
    ix = (int )(tokens + i___0)->code;
#line 344
    if (ix == 0) {
      _L: /* CIL Label */ 
      _L___8: /* CIL Label */ 
#line 345
      trimmed_length --;
#line 346
      trailing_zero_bits += (int )code_length_bitdepth[ix];
#line 347
      if (ix == 17) {
#line 348
        trailing_zero_bits += 3;
      } else
#line 349
      if (ix == 18) {
#line 350
        trailing_zero_bits += 7;
      }
    } else
#line 344
    if (ix == 17) {
#line 344
      goto _L;
    } else
#line 344
    if (ix == 18) {
#line 344
      goto _L;
    } else {
#line 353
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 356
  write_trimmed_length = trimmed_length > 1 && trailing_zero_bits > 12;
#line 357
  if (write_trimmed_length) {
#line 357
    tmp___2 = trimmed_length;
  } else {
#line 357
    tmp___2 = num_tokens;
  }
  {
#line 357
  length = tmp___2;
#line 358
  VP8LWriteBits(bw, 1, (uint32_t )write_trimmed_length);
  }
#line 359
  if (write_trimmed_length) {
    {
#line 360
    __cil_tmp27 = VP8LBitsLog2Ceiling((uint32_t )(trimmed_length - 1));
#line 360
    nbits = __cil_tmp27;
    }
#line 361
    if (nbits == 0) {
#line 361
      tmp___3 = 1;
    } else {
#line 361
      tmp___3 = (nbits + 1) / 2;
    }
    {
#line 361
    nbitpairs = tmp___3;
#line 362
    VP8LWriteBits(bw, 3, (uint32_t )(nbitpairs - 1));
#line 364
    VP8LWriteBits(bw, nbitpairs * 2, (uint32_t )(trimmed_length - 2));
    }
  }
  {
#line 366
  StoreHuffmanTreeToBitMask(bw, tokens, length, & huffman_code);
#line 368
  ok = 1;
  }
  End: 
  {
#line 370
  free(tokens);
  }
#line 371
  return (ok);
}
}
#line 374 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int StoreHuffmanCode(VP8LBitWriter *bw , HuffmanTreeCode *huffman_code ) 
{ 
  int i ;
  int count ;
  int symbols[2] ;
  int kMaxBits ;
  int kMaxSymbol ;
  int __cil_tmp8 ;

  {
#line 377
  count = 0;
#line 378
  symbols[0] = 0;
#line 378
  symbols[1] = 0;
#line 379
  kMaxBits = 8;
#line 380
  kMaxSymbol = 1 << kMaxBits;
#line 383
  i = 0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (i < huffman_code->num_symbols && count < 3)) {
#line 383
      goto while_break;
    }
#line 384
    if ((int )*(huffman_code->code_lengths + i) != 0) {
#line 385
      if (count < 2) {
#line 385
        symbols[count] = i;
      }
#line 386
      count ++;
    }
#line 383
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  if (count == 0) {
    {
#line 392
    VP8LWriteBits(bw, 4, (uint32_t )1);
    }
#line 393
    return (1);
  } else
#line 394
  if (count <= 2) {
#line 394
    if (symbols[0] < kMaxSymbol) {
#line 394
      if (symbols[1] < kMaxSymbol) {
        {
#line 395
        VP8LWriteBits(bw, 1, (uint32_t )1);
#line 396
        VP8LWriteBits(bw, 1, (uint32_t )(count - 1));
        }
#line 397
        if (symbols[0] <= 1) {
          {
#line 398
          VP8LWriteBits(bw, 1, (uint32_t )0);
#line 399
          VP8LWriteBits(bw, 1, (uint32_t )symbols[0]);
          }
        } else {
          {
#line 401
          VP8LWriteBits(bw, 1, (uint32_t )1);
#line 402
          VP8LWriteBits(bw, 8, (uint32_t )symbols[0]);
          }
        }
#line 404
        if (count == 2) {
          {
#line 405
          VP8LWriteBits(bw, 8, (uint32_t )symbols[1]);
          }
        }
#line 407
        return (1);
      } else {
        {
        {
        {
#line 409
        __cil_tmp8 = StoreFullHuffmanCode(bw, huffman_code);
        }
        }
        }
#line 409
        return (__cil_tmp8);
      }
    } else {
      {
      {
      {
#line 409
      __cil_tmp8 = StoreFullHuffmanCode(bw, huffman_code);
      }
      }
      }
#line 409
      return (__cil_tmp8);
    }
  } else {
    {
    {
    {
#line 409
    __cil_tmp8 = StoreFullHuffmanCode(bw, huffman_code);
    }
    }
    }
#line 409
    return (__cil_tmp8);
  }
}
}
#line 413 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static void WriteHuffmanCode(VP8LBitWriter *bw , HuffmanTreeCode *code , int code_index ) 
{ 
  int depth ;
  int symbol ;

  {
  {
#line 416
  depth = (int )*(code->code_lengths + code_index);
#line 417
  symbol = (int )*(code->codes + code_index);
#line 418
  VP8LWriteBits(bw, depth, (uint32_t )symbol);
  }
  return;
}
}
#line 421 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static void StoreImageToBitMask(VP8LBitWriter *bw , int width , int histo_bits , VP8LBackwardRefs *refs ,
                                uint16_t *histogram_symbols , HuffmanTreeCode *huffman_codes ) 
{ 
  int x ;
  int y ;
  int histo_xsize ;
  uint32_t __cil_tmp10 ;
  uint32_t tmp ;
  int i ;
  PixOrCopy *v ;
  int histogram_ix ;
  int tmp___0 ;
  HuffmanTreeCode *codes ;
  int __cil_tmp17 ;
  int code ;
  uint32_t __cil_tmp19 ;
  int literal_ix ;
  int __cil_tmp21 ;
  static int const   order[4] ;
  int k ;
  int code___0 ;
  uint32_t __cil_tmp25 ;
  int bits ;
  int n_bits ;
  int code___1 ;
  int distance ;
  uint32_t __cil_tmp30 ;
  uint32_t __cil_tmp31 ;

  {
#line 427
  x = 0;
#line 428
  y = 0;
#line 429
  if (histo_bits) {
    {
#line 429
    __cil_tmp10 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histo_bits);
#line 429
    tmp = __cil_tmp10;
    }
  } else {
#line 429
    tmp = (unsigned int )1;
  }
#line 429
  histo_xsize = (int )tmp;
#line 431
  i = 0;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (i < refs->size)) {
#line 431
      goto while_break;
    }
#line 432
    v = refs->refs + i;
#line 433
    if (histo_bits) {
#line 433
      tmp___0 = (y >> histo_bits) * histo_xsize + (x >> histo_bits);
    } else {
#line 433
      tmp___0 = 0;
    }
    {
#line 433
    histogram_ix = (int )*(histogram_symbols + tmp___0);
#line 436
    codes = huffman_codes + 5 * histogram_ix;
#line 437
    __cil_tmp17 = PixOrCopyIsCacheIdx(v);
    }
#line 437
    if (__cil_tmp17) {
      {
#line 438
      __cil_tmp19 = PixOrCopyCacheIdx(v);
#line 438
      code = (int )__cil_tmp19;
#line 439
      literal_ix = 280 + code;
#line 440
      WriteHuffmanCode(bw, codes, literal_ix);
      }
    } else {
      {
#line 441
      __cil_tmp21 = PixOrCopyIsLiteral(v);
      }
#line 441
      if (__cil_tmp21) {
#line 442
        order[0] = 1;
#line 442
        order[1] = 2;
#line 442
        order[2] = 0;
#line 442
        order[3] = 3;
#line 444
        k = 0;
        {
#line 444
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 444
          if (! (k < 4)) {
#line 444
            goto while_break___0;
          }
          {
#line 445
          __cil_tmp25 = PixOrCopyLiteral(v, order[k]);
#line 445
          code___0 = (int )__cil_tmp25;
#line 446
          WriteHuffmanCode(bw, codes + k, code___0);
          }
#line 444
          k ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 452
        PrefixEncode((int )v->len, & code___1, & n_bits, & bits);
#line 453
        WriteHuffmanCode(bw, codes, 256 + code___1);
#line 454
        VP8LWriteBits(bw, n_bits, (uint32_t )bits);
#line 456
        __cil_tmp30 = PixOrCopyArgb(v);
#line 456
        distance = (int )__cil_tmp30;
#line 457
        PrefixEncode(distance, & code___1, & n_bits, & bits);
#line 458
        WriteHuffmanCode(bw, codes + 4, code___1);
#line 459
        VP8LWriteBits(bw, n_bits, (uint32_t )bits);
        }
      }
    }
    {
#line 461
    __cil_tmp31 = PixOrCopyLength(v);
    }
#line 461
    x += __cil_tmp31;
    {
#line 462
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 462
      if (! (x >= width)) {
#line 462
        goto while_break___1;
      }
#line 463
      x -= width;
#line 464
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 431
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 470 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int EncodeImageNoHuffman(VP8LBitWriter *bw , uint32_t *argb , int width , int height ,
                                int quality ) 
{ 
  int i ;
  int ok ;
  VP8LBackwardRefs refs ;
  HuffmanTreeCode huffman_codes[5] ;
  uint16_t histogram_symbols[1] ;
  VP8LHistogramSet *histogram_image ;
  VP8LHistogramSet *__cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp ;
  int __cil_tmp15 ;
  HuffmanTreeCode *codes ;
  int __cil_tmp17 ;

  {
#line 474
  ok = 0;
#line 476
  huffman_codes[0].num_symbols = 0;
#line 476
  huffman_codes[0].code_lengths = (uint8_t *)((void *)0);
  {
#line 476
  huffman_codes[0].codes = (uint16_t *)((void *)0);
#line 477
  histogram_symbols[0] = (uint16_t )0;
#line 478
  __cil_tmp12 = VP8LAllocateHistogramSet(1, 0);
#line 478
  histogram_image = __cil_tmp12;
  }
#line 479
  if (histogram_image == (void *)0) {
#line 479
    return (0);
  }
  {
#line 482
  __cil_tmp13 = VP8LGetBackwardReferences(width, height, argb, quality, 0, 1, & refs);
  }
#line 482
  if (! __cil_tmp13) {
#line 483
    goto Error;
  }
  {
#line 486
  VP8LHistogramStoreRefs(& refs, *(histogram_image->histograms + 0));
#line 490
  __cil_tmp15 = GetHuffBitLengthsAndCodes(histogram_image, (HuffmanTreeCode *)huffman_codes);
  }
#line 490
  if (! __cil_tmp15) {
#line 491
    goto Error;
  }
  {
#line 495
  VP8LWriteBits(bw, 1, (uint32_t )0);
#line 498
  i = 0;
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (i < 5)) {
#line 498
      goto while_break;
    }
    {
#line 499
    codes = & huffman_codes[i];
#line 500
    __cil_tmp17 = StoreHuffmanCode(bw, codes);
    }
#line 500
    if (! __cil_tmp17) {
#line 501
      goto Error;
    }
    {
#line 503
    ClearHuffmanTreeIfOnlyOneSymbol(codes);
    }
#line 498
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 507
  StoreImageToBitMask(bw, width, 0, & refs, (uint16_t *)histogram_symbols, (HuffmanTreeCode *)huffman_codes);
#line 508
  ok = 1;
  }
  Error: 
  {
#line 511
  free(histogram_image);
  }
  {
#line 512
  VP8LClearBackwardRefs(& refs);
#line 513
  free(huffman_codes[0].codes);
  }
#line 514
  return (ok);
}
}
#line 517 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int EncodeImageInternal(VP8LBitWriter *bw , uint32_t *argb , int width , int height ,
                               int quality , int cache_bits , int histogram_bits ) 
{ 
  int ok ;
  int use_2d_locality ;
  int use_color_cache ;
  uint32_t histogram_image_xysize ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;
  VP8LHistogramSet *histogram_image ;
  VP8LHistogramSet *__cil_tmp15 ;
  int histogram_image_size ;
  size_t bit_array_size ;
  HuffmanTreeCode *huffman_codes ;
  VP8LBackwardRefs refs ;
  uint16_t *histogram_symbols ;
  void *__cil_tmp21 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  int write_histogram_image ;
  uint32_t *histogram_argb ;
  void *__cil_tmp30 ;
  int max_index ;
  uint32_t i ;
  int symbol_index ;
  uint32_t __cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  int __cil_tmp36 ;
  int i___0 ;
  HuffmanTreeCode *codes ;
  int __cil_tmp39 ;

  {
  {
#line 521
  ok = 0;
#line 522
  use_2d_locality = 1;
#line 523
  use_color_cache = cache_bits > 0;
#line 524
  __cil_tmp13 = VP8LSubSampleSize((uint32_t )height, (uint32_t )histogram_bits);
  }
  {
#line 524
  __cil_tmp12 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histogram_bits);
#line 524
  histogram_image_xysize = __cil_tmp12 * __cil_tmp13;
#line 527
  __cil_tmp15 = VP8LAllocateHistogramSet((int )histogram_image_xysize, 0);
#line 527
  histogram_image = __cil_tmp15;
#line 529
  histogram_image_size = 0;
#line 530
  bit_array_size = (size_t )0;
#line 531
  huffman_codes = (HuffmanTreeCode *)((void *)0);
#line 533
  __cil_tmp21 = WebPSafeMalloc((uint64_t )histogram_image_xysize, sizeof(*histogram_symbols));
#line 533
  histogram_symbols = (uint16_t *)__cil_tmp21;
  }
#line 539
  if (histogram_image == (void *)0) {
    {
    {
#line 540
    free(histogram_image);
    }
    {
#line 541
    free(histogram_symbols);
    }
    }
#line 542
    return (0);
  } else
#line 539
  if (histogram_symbols == (void *)0) {
    {
    {
#line 540
    free(histogram_image);
    }
    {
#line 541
    free(histogram_symbols);
    }
    }
#line 542
    return (0);
  }
  {
#line 546
  __cil_tmp24 = VP8LGetBackwardReferences(width, height, argb, quality, cache_bits,
                                          use_2d_locality, & refs);
  }
#line 546
  if (! __cil_tmp24) {
#line 548
    goto Error;
  }
  {
#line 551
  __cil_tmp25 = VP8LGetHistoImageSymbols(width, height, & refs, quality, histogram_bits,
                                         cache_bits, histogram_image, histogram_symbols);
  }
#line 551
  if (! __cil_tmp25) {
#line 555
    goto Error;
  }
  {
#line 558
  histogram_image_size = histogram_image->size;
#line 559
  bit_array_size = (size_t )(5 * histogram_image_size);
#line 560
  __cil_tmp26 = WebPSafeCalloc(bit_array_size, sizeof(*huffman_codes));
#line 560
  huffman_codes = (HuffmanTreeCode *)__cil_tmp26;
#line 562
  __cil_tmp27 = GetHuffBitLengthsAndCodes(histogram_image, huffman_codes);
  }
#line 562
  if (huffman_codes == (void *)0) {
#line 564
    goto Error;
  } else
#line 562
  if (! __cil_tmp27) {
#line 564
    goto Error;
  }
  {
#line 567
  free(histogram_image);
#line 568
  histogram_image = (VP8LHistogramSet *)((void *)0);
#line 571
  VP8LWriteBits(bw, 1, (uint32_t )use_color_cache);
  }
#line 572
  if (use_color_cache) {
    {
#line 573
    VP8LWriteBits(bw, 4, (uint32_t )cache_bits);
    }
  }
  {
#line 578
  write_histogram_image = histogram_image_size > 1;
#line 579
  VP8LWriteBits(bw, 1, (uint32_t )write_histogram_image);
  }
#line 580
  if (write_histogram_image) {
    {
#line 581
    __cil_tmp30 = WebPSafeMalloc((uint64_t )histogram_image_xysize, sizeof(*histogram_argb));
#line 581
    histogram_argb = (uint32_t *)__cil_tmp30;
#line 584
    max_index = 0;
    }
#line 586
    if (histogram_argb == (void *)0) {
#line 586
      goto Error;
    }
#line 587
    i = (uint32_t )0;
    {
#line 587
    while (1) {
      while_continue: /* CIL Label */ ;
#line 587
      if (! (i < histogram_image_xysize)) {
#line 587
        goto while_break;
      }
#line 588
      symbol_index = (int )*(histogram_symbols + i) & 65535;
#line 589
      *(histogram_argb + i) = 4278190080U | (unsigned int )(symbol_index << 8);
#line 590
      if (symbol_index >= max_index) {
#line 591
        max_index = symbol_index + 1;
      }
#line 587
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 594
    histogram_image_size = max_index;
#line 596
    VP8LWriteBits(bw, 3, (uint32_t )(histogram_bits - 2));
#line 597
    __cil_tmp34 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histogram_bits);
    }
    {
#line 597
    __cil_tmp35 = VP8LSubSampleSize((uint32_t )height, (uint32_t )histogram_bits);
#line 597
    __cil_tmp36 = EncodeImageNoHuffman(bw, histogram_argb, (int )__cil_tmp34, (int )__cil_tmp35,
                                       quality);
#line 597
    ok = __cil_tmp36;
#line 601
    free(histogram_argb);
    }
#line 602
    if (! ok) {
#line 602
      goto Error;
    }
  }
#line 609
  i___0 = 0;
  {
#line 609
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 609
    if (! (i___0 < 5 * histogram_image_size)) {
#line 609
      goto while_break___0;
    }
    {
#line 610
    codes = huffman_codes + i___0;
#line 611
    __cil_tmp39 = StoreHuffmanCode(bw, codes);
    }
#line 611
    if (! __cil_tmp39) {
#line 611
      goto Error;
    }
    {
#line 612
    ClearHuffmanTreeIfOnlyOneSymbol(codes);
    }
#line 609
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 617
  StoreImageToBitMask(bw, width, histogram_bits, & refs, histogram_symbols, huffman_codes);
#line 619
  ok = 1;
  }
  Error: 
  {
#line 622
  free(histogram_image);
  }
  {
#line 624
  VP8LClearBackwardRefs(& refs);
  }
#line 625
  if (huffman_codes != (void *)0) {
    {
#line 626
    free(huffman_codes->codes);
#line 627
    free(huffman_codes);
    }
  }
  {
#line 629
  free(histogram_symbols);
  }
#line 630
  return (ok);
}
}
#line 638 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int EvalAndApplySubtractGreen(VP8LEncoder *enc , int width , int height , VP8LBitWriter *bw ) 
{ 
  int i ;
  uint32_t *argb ;
  double bit_cost_before ;
  double bit_cost_after ;
  VP8LHistogram *histo ;
  void *__cil_tmp10 ;
  uint32_t c ;
  double __cil_tmp12 ;
  uint32_t c___0 ;
  int green ;
  double __cil_tmp15 ;

  {
#line 641
  if (! enc->use_palette_) {
    {
#line 643
    argb = enc->argb_;
#line 645
    __cil_tmp10 = malloc(sizeof(*histo));
#line 645
    histo = (VP8LHistogram *)__cil_tmp10;
    }
#line 646
    if (histo == (void *)0) {
#line 646
      return (0);
    }
    {
#line 648
    VP8LHistogramInit(histo, 1);
#line 649
    i = 0;
    }
    {
#line 649
    while (1) {
      while_continue: /* CIL Label */ ;
#line 649
      if (! (i < width * height)) {
#line 649
        goto while_break;
      }
#line 650
      c = *(argb + i);
#line 651
      (histo->red_[(c >> 16) & 255U]) ++;
#line 652
      (histo->blue_[c & 255U]) ++;
#line 649
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 654
    bit_cost_before = VP8LHistogramEstimateBits(histo);
#line 656
    VP8LHistogramInit(histo, 1);
#line 657
    i = 0;
    }
    {
#line 657
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 657
      if (! (i < width * height)) {
#line 657
        goto while_break___0;
      }
#line 658
      c___0 = *(argb + i);
#line 659
      green = (int )((c___0 >> 8) & 255U);
#line 660
      (histo->red_[((c___0 >> 16) - (unsigned int )green) & 255U]) ++;
#line 661
      (histo->blue_[(c___0 - (unsigned int )green) & 255U]) ++;
#line 657
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 663
    bit_cost_after = VP8LHistogramEstimateBits(histo);
#line 664
    free(histo);
#line 667
    enc->use_subtract_green_ = bit_cost_after < bit_cost_before;
    }
#line 668
    if (enc->use_subtract_green_) {
      {
#line 669
      VP8LWriteBits(bw, 1, (uint32_t )1);
#line 670
      VP8LWriteBits(bw, 2, (uint32_t )2);
#line 671
      VP8LSubtractGreenFromBlueAndRed(enc->argb_, width * height);
      }
    }
  }
#line 674
  return (1);
}
}
#line 677 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int ApplyPredictFilter(VP8LEncoder *enc , int width , int height , int quality ,
                              VP8LBitWriter *bw ) 
{ 
  int pred_bits ;
  int transform_width ;
  uint32_t __cil_tmp8 ;
  int transform_height ;
  uint32_t __cil_tmp10 ;
  int tmp ;
  int __cil_tmp12 ;

  {
  {
#line 680
  pred_bits = enc->transform_bits_;
#line 681
  __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )pred_bits);
#line 681
  transform_width = (int )__cil_tmp8;
#line 682
  __cil_tmp10 = VP8LSubSampleSize((uint32_t )height, (uint32_t )pred_bits);
#line 682
  transform_height = (int )__cil_tmp10;
#line 684
  VP8LResidualImage(width, height, pred_bits, enc->argb_, enc->argb_scratch_, enc->transform_data_);
#line 686
  VP8LWriteBits(bw, 1, (uint32_t )1);
#line 687
  VP8LWriteBits(bw, 2, (uint32_t )0);
#line 689
  VP8LWriteBits(bw, 3, (uint32_t )(pred_bits - 2));
#line 690
  __cil_tmp12 = EncodeImageNoHuffman(bw, enc->transform_data_, transform_width, transform_height,
                                     quality);
  }
#line 690
  if (! __cil_tmp12) {
#line 692
    return (0);
  }
#line 694
  return (1);
}
}
#line 697 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int ApplyCrossColorFilter(VP8LEncoder *enc , int width , int height , int quality ,
                                 VP8LBitWriter *bw ) 
{ 
  int ccolor_transform_bits ;
  int transform_width ;
  uint32_t __cil_tmp8 ;
  int transform_height ;
  uint32_t __cil_tmp10 ;
  int step ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp14 ;

  {
  {
#line 700
  ccolor_transform_bits = enc->transform_bits_;
#line 701
  __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )ccolor_transform_bits);
#line 701
  transform_width = (int )__cil_tmp8;
#line 702
  __cil_tmp10 = VP8LSubSampleSize((uint32_t )height, (uint32_t )ccolor_transform_bits);
#line 702
  transform_height = (int )__cil_tmp10;
  }
#line 703
  if (quality == 0) {
#line 703
    tmp = 32;
  } else {
#line 703
    tmp = 8;
  }
  {
#line 703
  step = tmp;
#line 705
  VP8LColorSpaceTransform(width, height, ccolor_transform_bits, step, enc->argb_,
                          enc->transform_data_);
#line 707
  VP8LWriteBits(bw, 1, (uint32_t )1);
#line 708
  VP8LWriteBits(bw, 2, (uint32_t )1);
#line 710
  VP8LWriteBits(bw, 3, (uint32_t )(ccolor_transform_bits - 2));
#line 711
  __cil_tmp14 = EncodeImageNoHuffman(bw, enc->transform_data_, transform_width, transform_height,
                                     quality);
  }
#line 711
  if (! __cil_tmp14) {
#line 713
    return (0);
  }
#line 715
  return (1);
}
}
#line 720 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static enum WebPEncodingError WriteRiffHeader(WebPPicture *pic , size_t riff_size ,
                                              size_t vp8l_size ) 
{ 
  uint8_t riff[21] ;
  int __cil_tmp5 ;

  {
  {
#line 722
  riff[0] = (uint8_t )'R';
#line 722
  riff[1] = (uint8_t )'I';
#line 722
  riff[2] = (uint8_t )'F';
#line 722
  riff[3] = (uint8_t )'F';
#line 722
  riff[4] = (uint8_t )0;
#line 722
  riff[5] = (uint8_t )0;
#line 722
  riff[6] = (uint8_t )0;
#line 722
  riff[7] = (uint8_t )0;
#line 722
  riff[8] = (uint8_t )'W';
#line 722
  riff[9] = (uint8_t )'E';
#line 722
  riff[10] = (uint8_t )'B';
#line 722
  riff[11] = (uint8_t )'P';
#line 722
  riff[12] = (uint8_t )'V';
#line 722
  riff[13] = (uint8_t )'P';
#line 722
  riff[14] = (uint8_t )'8';
#line 722
  riff[15] = (uint8_t )'L';
#line 722
  riff[16] = (uint8_t )0;
#line 722
  riff[17] = (uint8_t )0;
#line 722
  riff[18] = (uint8_t )0;
#line 722
  riff[19] = (uint8_t )0;
#line 722
  riff[20] = (uint8_t )47;
#line 726
  PutLE32((uint8_t *)riff + 4, (uint32_t )riff_size);
#line 727
  PutLE32(((uint8_t *)riff + 12) + 4, (uint32_t )vp8l_size);
#line 728
  __cil_tmp5 = (*(pic->writer))((uint8_t *)riff, sizeof(riff), pic);
  }
#line 728
  if (! __cil_tmp5) {
#line 729
    return ((enum WebPEncodingError )8);
  }
#line 731
  return ((enum WebPEncodingError )0);
}
}
#line 734 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int WriteImageSize(WebPPicture *pic , VP8LBitWriter *bw ) 
{ 
  int width ;
  int height ;
  int tmp ;

  {
  {
#line 736
  width = pic->width - 1;
#line 737
  height = pic->height - 1;
#line 740
  VP8LWriteBits(bw, 14, (uint32_t )width);
#line 741
  VP8LWriteBits(bw, 14, (uint32_t )height);
  }
#line 742
  return (! bw->error_);
}
}
#line 745 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int WriteRealAlphaAndVersion(VP8LBitWriter *bw , int has_alpha ) 
{ 


  {
  {
#line 746
  VP8LWriteBits(bw, 1, (uint32_t )has_alpha);
#line 747
  VP8LWriteBits(bw, 3, (uint32_t )0);
  }
#line 748
  return (! bw->error_);
}
}
#line 751 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static enum WebPEncodingError WriteImage(WebPPicture *pic , VP8LBitWriter *bw , size_t *coded_size ) 
{ 
  enum WebPEncodingError err ;
  uint8_t *webpll_data ;
  uint8_t *__cil_tmp6 ;
  size_t webpll_size ;
  size_t __cil_tmp8 ;
  size_t vp8l_size ;
  size_t pad ;
  size_t riff_size ;
  enum WebPEncodingError __cil_tmp12 ;
  int __cil_tmp13 ;
  uint8_t pad_byte[1] ;
  int __cil_tmp15 ;

  {
  {
#line 754
  err = (enum WebPEncodingError )0;
#line 755
  __cil_tmp6 = VP8LBitWriterFinish(bw);
#line 755
  webpll_data = __cil_tmp6;
#line 756
  __cil_tmp8 = VP8LBitWriterNumBytes(bw);
#line 756
  webpll_size = __cil_tmp8;
#line 757
  vp8l_size = 1UL + webpll_size;
#line 758
  pad = vp8l_size & 1UL;
#line 759
  riff_size = (12UL + vp8l_size) + pad;
#line 761
  err = WriteRiffHeader(pic, riff_size, vp8l_size);
  }
#line 762
  if ((unsigned int )err != 0U) {
#line 762
    goto Error;
  }
  {
#line 764
  __cil_tmp13 = (*(pic->writer))(webpll_data, webpll_size, pic);
  }
#line 764
  if (! __cil_tmp13) {
#line 765
    err = (enum WebPEncodingError )8;
#line 766
    goto Error;
  }
#line 769
  if (pad) {
    {
#line 770
    pad_byte[0] = (uint8_t )0;
#line 771
    __cil_tmp15 = (*(pic->writer))((uint8_t *)pad_byte, (size_t )1, pic);
    }
#line 771
    if (! __cil_tmp15) {
#line 772
      err = (enum WebPEncodingError )8;
#line 773
      goto Error;
    }
  }
#line 776
  *coded_size = 8UL + riff_size;
#line 777
  return ((enum WebPEncodingError )0);
  Error: 
#line 780
  return (err);
}
}
#line 787 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static enum WebPEncodingError AllocateTransformBuffer(VP8LEncoder *enc , int width ,
                                                      int height ) 
{ 
  enum WebPEncodingError err ;
  int tile_size ;
  uint64_t image_size ;
  uint64_t argb_scratch_size ;
  uint64_t transform_data_size ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint64_t total_size ;
  uint32_t *mem ;
  void *__cil_tmp13 ;

  {
  {
#line 789
  err = (enum WebPEncodingError )0;
#line 790
  tile_size = 1 << enc->transform_bits_;
#line 791
  image_size = (uint64_t )(width * height);
#line 792
  argb_scratch_size = (uint64_t )(tile_size * width + width);
#line 793
  __cil_tmp10 = VP8LSubSampleSize((uint32_t )height, (uint32_t )enc->transform_bits_);
  }
  {
#line 793
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )enc->transform_bits_);
#line 793
  transform_data_size = (uint64_t )__cil_tmp9 * (uint64_t )__cil_tmp10;
#line 796
  total_size = (image_size + argb_scratch_size) + transform_data_size;
#line 798
  __cil_tmp13 = WebPSafeMalloc(total_size, sizeof(*mem));
#line 798
  mem = (uint32_t *)__cil_tmp13;
  }
#line 799
  if (mem == (void *)0) {
#line 800
    err = (enum WebPEncodingError )1;
#line 801
    goto Error;
  }
#line 803
  enc->argb_ = mem;
#line 804
  mem += image_size;
#line 805
  enc->argb_scratch_ = mem;
#line 806
  mem += argb_scratch_size;
#line 807
  enc->transform_data_ = mem;
#line 808
  enc->current_width_ = width;
  Error: 
#line 811
  return (err);
}
}
#line 815 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static void BundleColorMap(uint8_t *row , int width , int xbits , uint32_t *dst ) 
{ 
  int x ;
  int bit_depth ;
  int mask ;
  uint32_t code ;
  int xsub ;

  {
#line 818
  if (xbits > 0) {
#line 819
    bit_depth = 1 << (3 - xbits);
#line 820
    mask = (1 << xbits) - 1;
#line 821
    code = 4278190080U;
#line 822
    x = 0;
    {
#line 822
    while (1) {
      while_continue: /* CIL Label */ ;
#line 822
      if (! (x < width)) {
#line 822
        goto while_break;
      }
#line 823
      xsub = x & mask;
#line 824
      if (xsub == 0) {
#line 825
        code = 4278190080U;
      }
#line 827
      code |= (unsigned int )((int )*(row + x) << (8 + bit_depth * xsub));
#line 828
      *(dst + (x >> xbits)) = code;
#line 822
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 831
    x = 0;
    {
#line 831
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 831
      if (! (x < width)) {
#line 831
        goto while_break___0;
      }
#line 831
      *(dst + x) = 4278190080U | (unsigned int )((int )*(row + x) << 8);
#line 831
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 838 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static enum WebPEncodingError ApplyPalette(VP8LBitWriter *bw , VP8LEncoder *enc ,
                                           int quality ) 
{ 
  enum WebPEncodingError err ;
  int i ;
  int x ;
  int y ;
  WebPPicture *pic ;
  uint32_t *src ;
  uint32_t *dst ;
  int width ;
  int height ;
  uint32_t *palette ;
  int palette_size ;
  uint8_t *row ;
  int xbits ;
  int tmp ;
  int tmp___0 ;
  uint32_t __cil_tmp19 ;
  enum WebPEncodingError __cil_tmp20 ;
  void *__cil_tmp21 ;
  uint32_t pix ;
  int tmp___1 ;
  uint32_t __cil_tmp24 ;
  int __cil_tmp25 ;

  {
#line 840
  err = (enum WebPEncodingError )0;
#line 842
  pic = enc->pic_;
#line 843
  src = pic->argb;
#line 845
  width = pic->width;
#line 846
  height = pic->height;
#line 847
  palette = (uint32_t *)enc->palette_;
#line 848
  palette_size = enc->palette_size_;
#line 849
  row = (uint8_t *)((void *)0);
#line 854
  if (palette_size <= 4) {
#line 855
    if (palette_size <= 2) {
#line 855
      tmp = 3;
    } else {
#line 855
      tmp = 2;
    }
#line 855
    xbits = tmp;
  } else {
#line 857
    if (palette_size <= 16) {
#line 857
      tmp___0 = 1;
    } else {
#line 857
      tmp___0 = 0;
    }
#line 857
    xbits = tmp___0;
  }
  {
#line 860
  __cil_tmp19 = VP8LSubSampleSize((uint32_t )width, (uint32_t )xbits);
#line 860
  __cil_tmp20 = AllocateTransformBuffer(enc, (int )__cil_tmp19, height);
#line 860
  err = __cil_tmp20;
  }
#line 861
  if ((unsigned int )err != 0U) {
#line 861
    goto Error;
  }
  {
#line 862
  dst = enc->argb_;
#line 864
  row = (uint8_t *)WebPSafeMalloc((uint64_t )width, sizeof(*row));
  }
#line 865
  if (row == (void *)0) {
#line 865
    return ((enum WebPEncodingError )1);
  }
#line 867
  y = 0;
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (! (y < height)) {
#line 867
      goto while_break;
    }
#line 868
    x = 0;
    {
#line 868
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 868
      if (! (x < width)) {
#line 868
        goto while_break___0;
      }
#line 869
      pix = *(src + x);
#line 870
      i = 0;
      {
#line 870
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 870
        if (! (i < palette_size)) {
#line 870
          goto while_break___1;
        }
#line 871
        if (pix == *(palette + i)) {
#line 872
          *(row + x) = (uint8_t )i;
#line 873
          goto while_break___1;
        }
#line 870
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 868
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 877
    BundleColorMap(row, width, xbits, dst);
#line 878
    src += pic->argb_stride;
#line 879
    dst += enc->current_width_;
    }
#line 867
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 883
  VP8LWriteBits(bw, 1, (uint32_t )1);
#line 884
  VP8LWriteBits(bw, 2, (uint32_t )3);
#line 886
  VP8LWriteBits(bw, 8, (uint32_t )(palette_size - 1));
#line 887
  i = palette_size - 1;
  }
  {
#line 887
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 887
    if (! (i >= 1)) {
#line 887
      goto while_break___2;
    }
    {
#line 888
    *(palette + i) = VP8LSubPixels(*(palette + i), *(palette + (i - 1)));
    }
#line 887
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 890
  __cil_tmp25 = EncodeImageNoHuffman(bw, palette, palette_size, 1, quality);
  }
#line 890
  if (! __cil_tmp25) {
#line 891
    err = (enum WebPEncodingError )4;
#line 892
    goto Error;
  }
  Error: 
  {
#line 896
  free(row);
  }
#line 897
  return (err);
}
}
#line 902 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static int GetHistoBits(WebPConfig *config , WebPPicture *pic ) 
{ 
  int width ;
  int height ;
  uint64_t hist_size ;
  int histo_bits ;
  uint64_t huff_image_size ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  int tmp ;
  int tmp___0 ;

  {
#line 904
  width = pic->width;
#line 905
  height = pic->height;
#line 906
  hist_size = sizeof(VP8LHistogram );
#line 908
  histo_bits = 7 - config->method;
  {
#line 909
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 910
    __cil_tmp9 = VP8LSubSampleSize((uint32_t )height, (uint32_t )histo_bits);
    }
    {
#line 910
    __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )histo_bits);
#line 910
    huff_image_size = (unsigned long )(__cil_tmp8 * __cil_tmp9) * hist_size;
    }
#line 913
    if (huff_image_size <= 16777216UL) {
#line 913
      goto while_break;
    }
#line 914
    histo_bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 916
  if (histo_bits < 2) {
#line 916
    tmp___0 = 2;
  } else {
#line 916
    if (histo_bits > 9) {
#line 916
      tmp = 9;
    } else {
#line 916
      tmp = histo_bits;
    }
#line 916
    tmp___0 = tmp;
  }
#line 916
  return (tmp___0);
}
}
#line 920 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static void InitEncParams(VP8LEncoder *enc ) 
{ 
  WebPConfig *config ;
  WebPPicture *picture ;
  int method ;
  float quality ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp8 ;
  int tmp___1 ;

  {
#line 921
  config = enc->config_;
#line 922
  picture = enc->pic_;
#line 923
  method = config->method;
#line 924
  quality = config->quality;
#line 925
  if (method < 4) {
#line 925
    tmp___0 = 5;
  } else {
#line 925
    if (method > 4) {
#line 925
      tmp = 3;
    } else {
#line 925
      tmp = 4;
    }
#line 925
    tmp___0 = tmp;
  }
  {
#line 925
  enc->transform_bits_ = tmp___0;
#line 926
  enc->histo_bits_ = GetHistoBits(config, picture);
  }
#line 927
  if (quality <= 25.f) {
#line 927
    tmp___1 = 0;
  } else {
#line 927
    tmp___1 = 7;
  }
#line 927
  enc->cache_bits_ = tmp___1;
  return;
}
}
#line 933 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static VP8LEncoder *VP8LEncoderNew(WebPConfig *config , WebPPicture *picture ) 
{ 
  VP8LEncoder *enc ;
  void *__cil_tmp4 ;

  {
  {
#line 935
  __cil_tmp4 = calloc((unsigned long )1, sizeof(*enc));
#line 935
  enc = (VP8LEncoder *)__cil_tmp4;
  }
#line 936
  if (enc == (void *)0) {
    {
#line 937
    WebPEncodingSetError(picture, (enum WebPEncodingError )1);
    }
#line 938
    return ((VP8LEncoder *)((void *)0));
  }
#line 940
  enc->config_ = config;
#line 941
  enc->pic_ = picture;
#line 942
  return (enc);
}
}
#line 945 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
static void VP8LEncoderDelete(VP8LEncoder *enc ) 
{ 


  {
  {
#line 946
  free(enc->argb_);
#line 947
  free(enc);
  }
  return;
}
}
#line 953 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
enum WebPEncodingError___0 VP8LEncodeStream(WebPConfig *config , WebPPicture *picture ,
                                            VP8LBitWriter *bw ) 
{ 
  enum WebPEncodingError err ;
  int quality ;
  int width ;
  int height ;
  VP8LEncoder *enc ;
  VP8LEncoder *__cil_tmp9 ;
  size_t byte_position ;
  size_t __cil_tmp11 ;
  int __cil_tmp12 ;
  enum WebPEncodingError __cil_tmp13 ;
  int y ;
  enum WebPEncodingError __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  WebPAuxStats *stats ;
  size_t __cil_tmp22 ;

  {
  {
#line 956
  err = (enum WebPEncodingError )0;
#line 957
  quality = (int )config->quality;
#line 958
  width = picture->width;
#line 959
  height = picture->height;
#line 960
  __cil_tmp9 = VP8LEncoderNew(config, picture);
#line 960
  enc = __cil_tmp9;
#line 961
  __cil_tmp11 = VP8LBitWriterNumBytes(bw);
#line 961
  byte_position = __cil_tmp11;
  }
#line 963
  if (enc == (void *)0) {
#line 964
    err = (enum WebPEncodingError )1;
#line 965
    goto Error;
  }
  {
#line 968
  InitEncParams(enc);
#line 973
  __cil_tmp12 = VP8LEncAnalyze(enc, config->image_hint);
  }
#line 973
  if (! __cil_tmp12) {
#line 974
    err = (enum WebPEncodingError )1;
#line 975
    goto Error;
  }
#line 978
  if (enc->use_palette_) {
    {
#line 979
    err = ApplyPalette(bw, enc, quality);
    }
#line 980
    if ((unsigned int )err != 0U) {
#line 980
      goto Error;
    }
#line 982
    enc->cache_bits_ = 0;
  }
#line 986
  if (enc->argb_ == (void *)0) {
    {
#line 988
    err = AllocateTransformBuffer(enc, width, height);
    }
#line 989
    if ((unsigned int )err != 0U) {
#line 989
      goto Error;
    }
#line 990
    y = 0;
    {
#line 990
    while (1) {
      while_continue: /* CIL Label */ ;
#line 990
      if (! (y < height)) {
#line 990
        goto while_break;
      }
      {
#line 991
      memcpy(enc->argb_ + y * width, picture->argb + y * picture->argb_stride, (unsigned long )width * sizeof(*(enc->argb_)));
      }
#line 990
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 995
    enc->current_width_ = width;
  }
  {
#line 1001
  __cil_tmp16 = EvalAndApplySubtractGreen(enc, enc->current_width_, height, bw);
  }
#line 1001
  if (! __cil_tmp16) {
#line 1002
    err = (enum WebPEncodingError )1;
#line 1003
    goto Error;
  }
#line 1006
  if (enc->use_predict_) {
    {
#line 1007
    __cil_tmp17 = ApplyPredictFilter(enc, enc->current_width_, height, quality, bw);
    }
#line 1007
    if (! __cil_tmp17) {
#line 1008
      err = (enum WebPEncodingError )4;
#line 1009
      goto Error;
    }
  }
#line 1013
  if (enc->use_cross_color_) {
    {
#line 1014
    __cil_tmp18 = ApplyCrossColorFilter(enc, enc->current_width_, height, quality,
                                        bw);
    }
#line 1014
    if (! __cil_tmp18) {
#line 1015
      err = (enum WebPEncodingError )4;
#line 1016
      goto Error;
    }
  }
  {
#line 1020
  VP8LWriteBits(bw, 1, (uint32_t )(! 1));
  }
#line 1025
  if (enc->cache_bits_ > 0) {
    {
#line 1026
    __cil_tmp19 = VP8LCalculateEstimateForCacheSize(enc->argb_, enc->current_width_,
                                                    height, & enc->cache_bits_);
    }
#line 1026
    if (! __cil_tmp19) {
#line 1028
      err = (enum WebPEncodingError )4;
#line 1029
      goto Error;
    }
  }
  {
#line 1036
  __cil_tmp20 = EncodeImageInternal(bw, enc->argb_, enc->current_width_, height, quality,
                                    enc->cache_bits_, enc->histo_bits_);
  }
#line 1036
  if (! __cil_tmp20) {
#line 1038
    err = (enum WebPEncodingError )1;
#line 1039
    goto Error;
  }
#line 1042
  if (picture->stats != (void *)0) {
#line 1043
    stats = picture->stats;
#line 1044
    stats->lossless_features = (uint32_t )0;
#line 1045
    if (enc->use_predict_) {
#line 1045
      stats->lossless_features |= (unsigned int )1;
    }
#line 1046
    if (enc->use_cross_color_) {
#line 1046
      stats->lossless_features |= (unsigned int )2;
    }
#line 1047
    if (enc->use_subtract_green_) {
#line 1047
      stats->lossless_features |= (unsigned int )4;
    }
#line 1048
    if (enc->use_palette_) {
#line 1048
      stats->lossless_features |= (unsigned int )8;
    }
    {
#line 1049
    stats->histogram_bits = enc->histo_bits_;
#line 1050
    stats->transform_bits = enc->transform_bits_;
#line 1051
    stats->cache_bits = enc->cache_bits_;
#line 1052
    stats->palette_size = enc->palette_size_;
#line 1053
    __cil_tmp22 = VP8LBitWriterNumBytes(bw);
#line 1053
    stats->lossless_size = (int )(__cil_tmp22 - byte_position);
    }
  }
  Error: 
  {
#line 1057
  VP8LEncoderDelete(enc);
  }
#line 1058
  return (err);
}
}
#line 1061 "/doner/libwebp/libwebp-v0.3.0/src/enc/vp8l.c"
int VP8LEncodeImage(WebPConfig *config , WebPPicture *picture ) 
{ 
  int width ;
  int height ;
  int has_alpha ;
  size_t coded_size ;
  int percent ;
  enum WebPEncodingError err ;
  VP8LBitWriter bw ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  WebPAuxStats *stats ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  enum WebPEncodingError __cil_tmp17 ;
  int __cil_tmp18 ;
  enum WebPEncodingError __cil_tmp19 ;
  int __cil_tmp20 ;
  int mb_w ;
  int mb_h ;

  {
#line 1066
  percent = 0;
#line 1067
  err = (enum WebPEncodingError )0;
#line 1070
  if (picture == (void *)0) {
#line 1070
    return (0);
  }
#line 1072
  if (config == (void *)0) {
    {
#line 1073
    err = (enum WebPEncodingError )3;
    {
#line 1074
    WebPEncodingSetError(picture, err);
    }
    }
#line 1075
    return (0);
  } else
#line 1072
  if (picture->argb == (void *)0) {
    {
#line 1073
    err = (enum WebPEncodingError )3;
    {
#line 1074
    WebPEncodingSetError(picture, err);
    }
    }
#line 1075
    return (0);
  }
  {
#line 1078
  width = picture->width;
#line 1079
  height = picture->height;
#line 1080
  __cil_tmp10 = VP8LBitWriterInit(& bw, (size_t )(width * height >> 1));
  }
#line 1080
  if (! __cil_tmp10) {
#line 1081
    err = (enum WebPEncodingError )1;
#line 1082
    goto Error;
  }
  {
#line 1085
  __cil_tmp11 = WebPReportProgress(picture, 1, & percent);
  }
#line 1085
  if (! __cil_tmp11) {
    UserAbort: 
#line 1087
    err = (enum WebPEncodingError )10;
#line 1088
    goto Error;
  }
#line 1091
  if (picture->stats != (void *)0) {
    {
#line 1092
    stats = picture->stats;
#line 1093
    memset(stats, 0, sizeof(*stats));
#line 1094
    stats->PSNR[0] = 99.f;
#line 1095
    stats->PSNR[1] = 99.f;
#line 1096
    stats->PSNR[2] = 99.f;
#line 1097
    stats->PSNR[3] = 99.f;
#line 1098
    stats->PSNR[4] = 99.f;
    }
  }
  {
#line 1102
  __cil_tmp13 = WriteImageSize(picture, & bw);
  }
#line 1102
  if (! __cil_tmp13) {
#line 1103
    err = (enum WebPEncodingError )1;
#line 1104
    goto Error;
  }
  {
#line 1107
  has_alpha = WebPPictureHasTransparency(picture);
#line 1109
  __cil_tmp15 = WriteRealAlphaAndVersion(& bw, has_alpha);
  }
#line 1109
  if (! __cil_tmp15) {
#line 1110
    err = (enum WebPEncodingError )1;
#line 1111
    goto Error;
  }
  {
#line 1114
  __cil_tmp16 = WebPReportProgress(picture, 5, & percent);
  }
#line 1114
  if (! __cil_tmp16) {
#line 1114
    goto UserAbort;
  }
  {
#line 1117
  err = (enum WebPEncodingError )VP8LEncodeStream(config, picture, & bw);
  }
#line 1118
  if ((unsigned int )err != 0U) {
#line 1118
    goto Error;
  }
  {
#line 1121
  __cil_tmp18 = WebPReportProgress(picture, 90, & percent);
  }
#line 1121
  if (! __cil_tmp18) {
#line 1121
    goto UserAbort;
  }
  {
#line 1124
  err = WriteImage(picture, & bw, & coded_size);
  }
#line 1125
  if ((unsigned int )err != 0U) {
#line 1125
    goto Error;
  }
  {
#line 1127
  __cil_tmp20 = WebPReportProgress(picture, 100, & percent);
  }
#line 1127
  if (! __cil_tmp20) {
#line 1127
    goto UserAbort;
  }
#line 1130
  if (picture->stats != (void *)0) {
#line 1131
    (picture->stats)->coded_size += (int )coded_size;
#line 1132
    (picture->stats)->lossless_size = (int )coded_size;
  }
#line 1135
  if (picture->extra_info != (void *)0) {
    {
#line 1136
    mb_w = (width + 15) >> 4;
#line 1137
    mb_h = (height + 15) >> 4;
#line 1138
    memset(picture->extra_info, 0, (unsigned long )(mb_w * mb_h) * sizeof(*(picture->extra_info)));
    }
  }
  Error: 
#line 1142
  if (bw.error_) {
#line 1142
    err = (enum WebPEncodingError )1;
  }
  {
#line 1143
  VP8LBitWriterDestroy(& bw);
  }
#line 1144
  if ((unsigned int )err != 0U) {
    {
#line 1145
    WebPEncodingSetError(picture, err);
    }
#line 1146
    return (0);
  }
#line 1148
  return (1);
}
}
#line 23 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
uint8_t VP8CoeffsProba0[4][8][3][11]  = { { { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )253,            (uint8_t )136,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )228,            (uint8_t )219,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )189,            (uint8_t )129,            (uint8_t )242,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )213,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )106,            (uint8_t )126,            (uint8_t )227,            (uint8_t )252, 
                    (uint8_t )214,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )98,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )226,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )181,            (uint8_t )133,            (uint8_t )238,            (uint8_t )254, 
                    (uint8_t )221,            (uint8_t )234,            (uint8_t )255,            (uint8_t )154, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )78,            (uint8_t )134,            (uint8_t )202,            (uint8_t )247, 
                    (uint8_t )198,            (uint8_t )180,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )185,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )243,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )150,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )77,            (uint8_t )110,            (uint8_t )216,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )230,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )101,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )241,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )170,            (uint8_t )139,            (uint8_t )241,            (uint8_t )252, 
                    (uint8_t )236,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )37,            (uint8_t )116,            (uint8_t )196,            (uint8_t )243, 
                    (uint8_t )228,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )204,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )245,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )207,            (uint8_t )160,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )238,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )102,            (uint8_t )103,            (uint8_t )231,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )171,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )152,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )240,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )177,            (uint8_t )135,            (uint8_t )243,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )225,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )80,            (uint8_t )129,            (uint8_t )211,            (uint8_t )255, 
                    (uint8_t )194,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )246,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )198,            (uint8_t )35,            (uint8_t )237,            (uint8_t )223, 
                    (uint8_t )193,            (uint8_t )187,            (uint8_t )162,            (uint8_t )160, 
                    (uint8_t )145,            (uint8_t )155,            (uint8_t )62}, 
       {            (uint8_t )131,            (uint8_t )45,            (uint8_t )198,            (uint8_t )221, 
                    (uint8_t )172,            (uint8_t )176,            (uint8_t )220,            (uint8_t )157, 
                    (uint8_t )252,            (uint8_t )221,            (uint8_t )1}, 
       {            (uint8_t )68,            (uint8_t )47,            (uint8_t )146,            (uint8_t )208, 
                    (uint8_t )149,            (uint8_t )167,            (uint8_t )221,            (uint8_t )162, 
                    (uint8_t )255,            (uint8_t )223,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )149,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )221,            (uint8_t )224,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )141,            (uint8_t )234,            (uint8_t )253, 
                    (uint8_t )222,            (uint8_t )220,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )81,            (uint8_t )99,            (uint8_t )181,            (uint8_t )242, 
                    (uint8_t )176,            (uint8_t )190,            (uint8_t )249,            (uint8_t )202, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )129,            (uint8_t )232,            (uint8_t )253, 
                    (uint8_t )214,            (uint8_t )197,            (uint8_t )242,            (uint8_t )196, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )99,            (uint8_t )121,            (uint8_t )210,            (uint8_t )250, 
                    (uint8_t )201,            (uint8_t )198,            (uint8_t )255,            (uint8_t )202, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )23,            (uint8_t )91,            (uint8_t )163,            (uint8_t )242, 
                    (uint8_t )170,            (uint8_t )187,            (uint8_t )247,            (uint8_t )210, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )200,            (uint8_t )246,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )109,            (uint8_t )178,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )231,            (uint8_t )245,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )44,            (uint8_t )130,            (uint8_t )201,            (uint8_t )253, 
                    (uint8_t )205,            (uint8_t )192,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )132,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )219,            (uint8_t )209,            (uint8_t )255,            (uint8_t )165, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )94,            (uint8_t )136,            (uint8_t )225,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )190,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )22,            (uint8_t )100,            (uint8_t )174,            (uint8_t )245, 
                    (uint8_t )186,            (uint8_t )161,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )232,            (uint8_t )235,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )143,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )234,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )35,            (uint8_t )77,            (uint8_t )181,            (uint8_t )251, 
                    (uint8_t )193,            (uint8_t )211,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )157,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )231,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )121,            (uint8_t )141,            (uint8_t )235,            (uint8_t )255, 
                    (uint8_t )225,            (uint8_t )227,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )45,            (uint8_t )99,            (uint8_t )188,            (uint8_t )251, 
                    (uint8_t )195,            (uint8_t )217,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )203,            (uint8_t )1,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )137,            (uint8_t )1,            (uint8_t )177,            (uint8_t )255, 
                    (uint8_t )224,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )253,            (uint8_t )9,            (uint8_t )248,            (uint8_t )251, 
                    (uint8_t )207,            (uint8_t )208,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )175,            (uint8_t )13,            (uint8_t )224,            (uint8_t )243, 
                    (uint8_t )193,            (uint8_t )185,            (uint8_t )249,            (uint8_t )198, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )73,            (uint8_t )17,            (uint8_t )171,            (uint8_t )221, 
                    (uint8_t )161,            (uint8_t )179,            (uint8_t )236,            (uint8_t )167, 
                    (uint8_t )255,            (uint8_t )234,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )95,            (uint8_t )247,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )183,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )239,            (uint8_t )90,            (uint8_t )244,            (uint8_t )250, 
                    (uint8_t )211,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )155,            (uint8_t )77,            (uint8_t )195,            (uint8_t )248, 
                    (uint8_t )188,            (uint8_t )195,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )24,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )219,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )201,            (uint8_t )51,            (uint8_t )219,            (uint8_t )255, 
                    (uint8_t )196,            (uint8_t )186,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )69,            (uint8_t )46,            (uint8_t )190,            (uint8_t )239, 
                    (uint8_t )201,            (uint8_t )218,            (uint8_t )255,            (uint8_t )228, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )191,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )223,            (uint8_t )165,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )124,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )16,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )190,            (uint8_t )36,            (uint8_t )230,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )226,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )247,            (uint8_t )192,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )240,            (uint8_t )128,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )134,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )213,            (uint8_t )62,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )55,            (uint8_t )93,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )202,            (uint8_t )24,            (uint8_t )213,            (uint8_t )235, 
                    (uint8_t )186,            (uint8_t )191,            (uint8_t )220,            (uint8_t )160, 
                    (uint8_t )240,            (uint8_t )175,            (uint8_t )255}, 
       {            (uint8_t )126,            (uint8_t )38,            (uint8_t )182,            (uint8_t )232, 
                    (uint8_t )169,            (uint8_t )184,            (uint8_t )228,            (uint8_t )174, 
                    (uint8_t )255,            (uint8_t )187,            (uint8_t )128}, 
       {            (uint8_t )61,            (uint8_t )46,            (uint8_t )138,            (uint8_t )219, 
                    (uint8_t )151,            (uint8_t )178,            (uint8_t )240,            (uint8_t )170, 
                    (uint8_t )255,            (uint8_t )216,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )112,            (uint8_t )230,            (uint8_t )250, 
                    (uint8_t )199,            (uint8_t )191,            (uint8_t )247,            (uint8_t )159, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )166,            (uint8_t )109,            (uint8_t )228,            (uint8_t )252, 
                    (uint8_t )211,            (uint8_t )215,            (uint8_t )255,            (uint8_t )174, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )39,            (uint8_t )77,            (uint8_t )162,            (uint8_t )232, 
                    (uint8_t )172,            (uint8_t )180,            (uint8_t )245,            (uint8_t )178, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )52,            (uint8_t )220,            (uint8_t )246, 
                    (uint8_t )198,            (uint8_t )199,            (uint8_t )249,            (uint8_t )220, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )74,            (uint8_t )191,            (uint8_t )243, 
                    (uint8_t )183,            (uint8_t )193,            (uint8_t )250,            (uint8_t )221, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )24,            (uint8_t )71,            (uint8_t )130,            (uint8_t )219, 
                    (uint8_t )154,            (uint8_t )170,            (uint8_t )243,            (uint8_t )182, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )225,            (uint8_t )249, 
                    (uint8_t )219,            (uint8_t )240,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )150,            (uint8_t )226,            (uint8_t )252, 
                    (uint8_t )216,            (uint8_t )205,            (uint8_t )255,            (uint8_t )171, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )28,            (uint8_t )108,            (uint8_t )170,            (uint8_t )242, 
                    (uint8_t )183,            (uint8_t )194,            (uint8_t )254,            (uint8_t )223, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )81,            (uint8_t )230,            (uint8_t )252, 
                    (uint8_t )204,            (uint8_t )203,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )123,            (uint8_t )102,            (uint8_t )209,            (uint8_t )247, 
                    (uint8_t )188,            (uint8_t )196,            (uint8_t )255,            (uint8_t )233, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )20,            (uint8_t )95,            (uint8_t )153,            (uint8_t )243, 
                    (uint8_t )164,            (uint8_t )173,            (uint8_t )255,            (uint8_t )203, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )222,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )216,            (uint8_t )213,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )168,            (uint8_t )175,            (uint8_t )246,            (uint8_t )252, 
                    (uint8_t )235,            (uint8_t )205,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )47,            (uint8_t )116,            (uint8_t )215,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )212,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )121,            (uint8_t )236,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )214,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )84,            (uint8_t )213,            (uint8_t )252, 
                    (uint8_t )201,            (uint8_t )202,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )42,            (uint8_t )80,            (uint8_t )160,            (uint8_t )240, 
                    (uint8_t )162,            (uint8_t )185,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )244,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )238,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}};
#line 159 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
void VP8DefaultProbas(VP8Encoder *enc ) 
{ 
  VP8Proba *probas ;

  {
  {
#line 160
  probas = & enc->proba_;
#line 161
  probas->use_skip_proba_ = 0;
#line 162
  memset((uint8_t *)probas->segments_, (int )255U, sizeof(probas->segments_));
#line 163
  memcpy((ProbaArray (*)[8])probas->coeffs_, (uint8_t (*)[8][3][11])VP8CoeffsProba0,
         sizeof(VP8CoeffsProba0));
#line 166
  probas->dirty_ = 1;
  }
  return;
}
}
#line 170 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
static uint8_t kBModesProba[10][10][9]  = 
#line 170
  { { {          (uint8_t )231,          (uint8_t )120,          (uint8_t )48,          (uint8_t )89, 
                (uint8_t )115,          (uint8_t )113,          (uint8_t )120,          (uint8_t )152, 
                (uint8_t )112}, 
     {          (uint8_t )152,          (uint8_t )179,          (uint8_t )64,          (uint8_t )126, 
                (uint8_t )170,          (uint8_t )118,          (uint8_t )46,          (uint8_t )70, 
                (uint8_t )95}, 
     {          (uint8_t )175,          (uint8_t )69,          (uint8_t )143,          (uint8_t )80, 
                (uint8_t )85,          (uint8_t )82,          (uint8_t )72,          (uint8_t )155, 
                (uint8_t )103}, 
     {          (uint8_t )56,          (uint8_t )58,          (uint8_t )10,          (uint8_t )171, 
                (uint8_t )218,          (uint8_t )189,          (uint8_t )17,          (uint8_t )13, 
                (uint8_t )152}, 
     {          (uint8_t )114,          (uint8_t )26,          (uint8_t )17,          (uint8_t )163, 
                (uint8_t )44,          (uint8_t )195,          (uint8_t )21,          (uint8_t )10, 
                (uint8_t )173}, 
     {          (uint8_t )121,          (uint8_t )24,          (uint8_t )80,          (uint8_t )195, 
                (uint8_t )26,          (uint8_t )62,          (uint8_t )44,          (uint8_t )64, 
                (uint8_t )85}, 
     {          (uint8_t )144,          (uint8_t )71,          (uint8_t )10,          (uint8_t )38, 
                (uint8_t )171,          (uint8_t )213,          (uint8_t )144,          (uint8_t )34, 
                (uint8_t )26}, 
     {          (uint8_t )170,          (uint8_t )46,          (uint8_t )55,          (uint8_t )19, 
                (uint8_t )136,          (uint8_t )160,          (uint8_t )33,          (uint8_t )206, 
                (uint8_t )71}, 
     {          (uint8_t )63,          (uint8_t )20,          (uint8_t )8,          (uint8_t )114, 
                (uint8_t )114,          (uint8_t )208,          (uint8_t )12,          (uint8_t )9, 
                (uint8_t )226}, 
     {          (uint8_t )81,          (uint8_t )40,          (uint8_t )11,          (uint8_t )96, 
                (uint8_t )182,          (uint8_t )84,          (uint8_t )29,          (uint8_t )16, 
                (uint8_t )36}}, 
   { {          (uint8_t )134,          (uint8_t )183,          (uint8_t )89,          (uint8_t )137, 
                (uint8_t )98,          (uint8_t )101,          (uint8_t )106,          (uint8_t )165, 
                (uint8_t )148}, 
     {          (uint8_t )72,          (uint8_t )187,          (uint8_t )100,          (uint8_t )130, 
                (uint8_t )157,          (uint8_t )111,          (uint8_t )32,          (uint8_t )75, 
                (uint8_t )80}, 
     {          (uint8_t )66,          (uint8_t )102,          (uint8_t )167,          (uint8_t )99, 
                (uint8_t )74,          (uint8_t )62,          (uint8_t )40,          (uint8_t )234, 
                (uint8_t )128}, 
     {          (uint8_t )41,          (uint8_t )53,          (uint8_t )9,          (uint8_t )178, 
                (uint8_t )241,          (uint8_t )141,          (uint8_t )26,          (uint8_t )8, 
                (uint8_t )107}, 
     {          (uint8_t )74,          (uint8_t )43,          (uint8_t )26,          (uint8_t )146, 
                (uint8_t )73,          (uint8_t )166,          (uint8_t )49,          (uint8_t )23, 
                (uint8_t )157}, 
     {          (uint8_t )65,          (uint8_t )38,          (uint8_t )105,          (uint8_t )160, 
                (uint8_t )51,          (uint8_t )52,          (uint8_t )31,          (uint8_t )115, 
                (uint8_t )128}, 
     {          (uint8_t )104,          (uint8_t )79,          (uint8_t )12,          (uint8_t )27, 
                (uint8_t )217,          (uint8_t )255,          (uint8_t )87,          (uint8_t )17, 
                (uint8_t )7}, 
     {          (uint8_t )87,          (uint8_t )68,          (uint8_t )71,          (uint8_t )44, 
                (uint8_t )114,          (uint8_t )51,          (uint8_t )15,          (uint8_t )186, 
                (uint8_t )23}, 
     {          (uint8_t )47,          (uint8_t )41,          (uint8_t )14,          (uint8_t )110, 
                (uint8_t )182,          (uint8_t )183,          (uint8_t )21,          (uint8_t )17, 
                (uint8_t )194}, 
     {          (uint8_t )66,          (uint8_t )45,          (uint8_t )25,          (uint8_t )102, 
                (uint8_t )197,          (uint8_t )189,          (uint8_t )23,          (uint8_t )18, 
                (uint8_t )22}}, 
   { {          (uint8_t )88,          (uint8_t )88,          (uint8_t )147,          (uint8_t )150, 
                (uint8_t )42,          (uint8_t )46,          (uint8_t )45,          (uint8_t )196, 
                (uint8_t )205}, 
     {          (uint8_t )43,          (uint8_t )97,          (uint8_t )183,          (uint8_t )117, 
                (uint8_t )85,          (uint8_t )38,          (uint8_t )35,          (uint8_t )179, 
                (uint8_t )61}, 
     {          (uint8_t )39,          (uint8_t )53,          (uint8_t )200,          (uint8_t )87, 
                (uint8_t )26,          (uint8_t )21,          (uint8_t )43,          (uint8_t )232, 
                (uint8_t )171}, 
     {          (uint8_t )56,          (uint8_t )34,          (uint8_t )51,          (uint8_t )104, 
                (uint8_t )114,          (uint8_t )102,          (uint8_t )29,          (uint8_t )93, 
                (uint8_t )77}, 
     {          (uint8_t )39,          (uint8_t )28,          (uint8_t )85,          (uint8_t )171, 
                (uint8_t )58,          (uint8_t )165,          (uint8_t )90,          (uint8_t )98, 
                (uint8_t )64}, 
     {          (uint8_t )34,          (uint8_t )22,          (uint8_t )116,          (uint8_t )206, 
                (uint8_t )23,          (uint8_t )34,          (uint8_t )43,          (uint8_t )166, 
                (uint8_t )73}, 
     {          (uint8_t )107,          (uint8_t )54,          (uint8_t )32,          (uint8_t )26, 
                (uint8_t )51,          (uint8_t )1,          (uint8_t )81,          (uint8_t )43, 
                (uint8_t )31}, 
     {          (uint8_t )68,          (uint8_t )25,          (uint8_t )106,          (uint8_t )22, 
                (uint8_t )64,          (uint8_t )171,          (uint8_t )36,          (uint8_t )225, 
                (uint8_t )114}, 
     {          (uint8_t )34,          (uint8_t )19,          (uint8_t )21,          (uint8_t )102, 
                (uint8_t )132,          (uint8_t )188,          (uint8_t )16,          (uint8_t )76, 
                (uint8_t )124}, 
     {          (uint8_t )62,          (uint8_t )18,          (uint8_t )78,          (uint8_t )95, 
                (uint8_t )85,          (uint8_t )57,          (uint8_t )50,          (uint8_t )48, 
                (uint8_t )51}}, 
   { {          (uint8_t )193,          (uint8_t )101,          (uint8_t )35,          (uint8_t )159, 
                (uint8_t )215,          (uint8_t )111,          (uint8_t )89,          (uint8_t )46, 
                (uint8_t )111}, 
     {          (uint8_t )60,          (uint8_t )148,          (uint8_t )31,          (uint8_t )172, 
                (uint8_t )219,          (uint8_t )228,          (uint8_t )21,          (uint8_t )18, 
                (uint8_t )111}, 
     {          (uint8_t )112,          (uint8_t )113,          (uint8_t )77,          (uint8_t )85, 
                (uint8_t )179,          (uint8_t )255,          (uint8_t )38,          (uint8_t )120, 
                (uint8_t )114}, 
     {          (uint8_t )40,          (uint8_t )42,          (uint8_t )1,          (uint8_t )196, 
                (uint8_t )245,          (uint8_t )209,          (uint8_t )10,          (uint8_t )25, 
                (uint8_t )109}, 
     {          (uint8_t )88,          (uint8_t )43,          (uint8_t )29,          (uint8_t )140, 
                (uint8_t )166,          (uint8_t )213,          (uint8_t )37,          (uint8_t )43, 
                (uint8_t )154}, 
     {          (uint8_t )61,          (uint8_t )63,          (uint8_t )30,          (uint8_t )155, 
                (uint8_t )67,          (uint8_t )45,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )100,          (uint8_t )80,          (uint8_t )8,          (uint8_t )43, 
                (uint8_t )154,          (uint8_t )1,          (uint8_t )51,          (uint8_t )26, 
                (uint8_t )71}, 
     {          (uint8_t )142,          (uint8_t )78,          (uint8_t )78,          (uint8_t )16, 
                (uint8_t )255,          (uint8_t )128,          (uint8_t )34,          (uint8_t )197, 
                (uint8_t )171}, 
     {          (uint8_t )41,          (uint8_t )40,          (uint8_t )5,          (uint8_t )102, 
                (uint8_t )211,          (uint8_t )183,          (uint8_t )4,          (uint8_t )1, 
                (uint8_t )221}, 
     {          (uint8_t )51,          (uint8_t )50,          (uint8_t )17,          (uint8_t )168, 
                (uint8_t )209,          (uint8_t )192,          (uint8_t )23,          (uint8_t )25, 
                (uint8_t )82}}, 
   { {          (uint8_t )138,          (uint8_t )31,          (uint8_t )36,          (uint8_t )171, 
                (uint8_t )27,          (uint8_t )166,          (uint8_t )38,          (uint8_t )44, 
                (uint8_t )229}, 
     {          (uint8_t )67,          (uint8_t )87,          (uint8_t )58,          (uint8_t )169, 
                (uint8_t )82,          (uint8_t )115,          (uint8_t )26,          (uint8_t )59, 
                (uint8_t )179}, 
     {          (uint8_t )63,          (uint8_t )59,          (uint8_t )90,          (uint8_t )180, 
                (uint8_t )59,          (uint8_t )166,          (uint8_t )93,          (uint8_t )73, 
                (uint8_t )154}, 
     {          (uint8_t )40,          (uint8_t )40,          (uint8_t )21,          (uint8_t )116, 
                (uint8_t )143,          (uint8_t )209,          (uint8_t )34,          (uint8_t )39, 
                (uint8_t )175}, 
     {          (uint8_t )47,          (uint8_t )15,          (uint8_t )16,          (uint8_t )183, 
                (uint8_t )34,          (uint8_t )223,          (uint8_t )49,          (uint8_t )45, 
                (uint8_t )183}, 
     {          (uint8_t )46,          (uint8_t )17,          (uint8_t )33,          (uint8_t )183, 
                (uint8_t )6,          (uint8_t )98,          (uint8_t )15,          (uint8_t )32, 
                (uint8_t )183}, 
     {          (uint8_t )57,          (uint8_t )46,          (uint8_t )22,          (uint8_t )24, 
                (uint8_t )128,          (uint8_t )1,          (uint8_t )54,          (uint8_t )17, 
                (uint8_t )37}, 
     {          (uint8_t )65,          (uint8_t )32,          (uint8_t )73,          (uint8_t )115, 
                (uint8_t )28,          (uint8_t )128,          (uint8_t )23,          (uint8_t )128, 
                (uint8_t )205}, 
     {          (uint8_t )40,          (uint8_t )3,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )51,          (uint8_t )192,          (uint8_t )18,          (uint8_t )6, 
                (uint8_t )223}, 
     {          (uint8_t )87,          (uint8_t )37,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )59,          (uint8_t )77,          (uint8_t )64,          (uint8_t )21, 
                (uint8_t )47}}, 
   { {          (uint8_t )104,          (uint8_t )55,          (uint8_t )44,          (uint8_t )218, 
                (uint8_t )9,          (uint8_t )54,          (uint8_t )53,          (uint8_t )130, 
                (uint8_t )226}, 
     {          (uint8_t )64,          (uint8_t )90,          (uint8_t )70,          (uint8_t )205, 
                (uint8_t )40,          (uint8_t )41,          (uint8_t )23,          (uint8_t )26, 
                (uint8_t )57}, 
     {          (uint8_t )54,          (uint8_t )57,          (uint8_t )112,          (uint8_t )184, 
                (uint8_t )5,          (uint8_t )41,          (uint8_t )38,          (uint8_t )166, 
                (uint8_t )213}, 
     {          (uint8_t )30,          (uint8_t )34,          (uint8_t )26,          (uint8_t )133, 
                (uint8_t )152,          (uint8_t )116,          (uint8_t )10,          (uint8_t )32, 
                (uint8_t )134}, 
     {          (uint8_t )39,          (uint8_t )19,          (uint8_t )53,          (uint8_t )221, 
                (uint8_t )26,          (uint8_t )114,          (uint8_t )32,          (uint8_t )73, 
                (uint8_t )255}, 
     {          (uint8_t )31,          (uint8_t )9,          (uint8_t )65,          (uint8_t )234, 
                (uint8_t )2,          (uint8_t )15,          (uint8_t )1,          (uint8_t )118, 
                (uint8_t )73}, 
     {          (uint8_t )75,          (uint8_t )32,          (uint8_t )12,          (uint8_t )51, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )160,          (uint8_t )43, 
                (uint8_t )51}, 
     {          (uint8_t )88,          (uint8_t )31,          (uint8_t )35,          (uint8_t )67, 
                (uint8_t )102,          (uint8_t )85,          (uint8_t )55,          (uint8_t )186, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )23,          (uint8_t )111, 
                (uint8_t )59,          (uint8_t )205,          (uint8_t )45,          (uint8_t )37, 
                (uint8_t )192}, 
     {          (uint8_t )55,          (uint8_t )38,          (uint8_t )70,          (uint8_t )124, 
                (uint8_t )73,          (uint8_t )102,          (uint8_t )1,          (uint8_t )34, 
                (uint8_t )98}}, 
   { {          (uint8_t )125,          (uint8_t )98,          (uint8_t )42,          (uint8_t )88, 
                (uint8_t )104,          (uint8_t )85,          (uint8_t )117,          (uint8_t )175, 
                (uint8_t )82}, 
     {          (uint8_t )95,          (uint8_t )84,          (uint8_t )53,          (uint8_t )89, 
                (uint8_t )128,          (uint8_t )100,          (uint8_t )113,          (uint8_t )101, 
                (uint8_t )45}, 
     {          (uint8_t )75,          (uint8_t )79,          (uint8_t )123,          (uint8_t )47, 
                (uint8_t )51,          (uint8_t )128,          (uint8_t )81,          (uint8_t )171, 
                (uint8_t )1}, 
     {          (uint8_t )57,          (uint8_t )17,          (uint8_t )5,          (uint8_t )71, 
                (uint8_t )102,          (uint8_t )57,          (uint8_t )53,          (uint8_t )41, 
                (uint8_t )49}, 
     {          (uint8_t )38,          (uint8_t )33,          (uint8_t )13,          (uint8_t )121, 
                (uint8_t )57,          (uint8_t )73,          (uint8_t )26,          (uint8_t )1, 
                (uint8_t )85}, 
     {          (uint8_t )41,          (uint8_t )10,          (uint8_t )67,          (uint8_t )138, 
                (uint8_t )77,          (uint8_t )110,          (uint8_t )90,          (uint8_t )47, 
                (uint8_t )114}, 
     {          (uint8_t )115,          (uint8_t )21,          (uint8_t )2,          (uint8_t )10, 
                (uint8_t )102,          (uint8_t )255,          (uint8_t )166,          (uint8_t )23, 
                (uint8_t )6}, 
     {          (uint8_t )101,          (uint8_t )29,          (uint8_t )16,          (uint8_t )10, 
                (uint8_t )85,          (uint8_t )128,          (uint8_t )101,          (uint8_t )196, 
                (uint8_t )26}, 
     {          (uint8_t )57,          (uint8_t )18,          (uint8_t )10,          (uint8_t )102, 
                (uint8_t )102,          (uint8_t )213,          (uint8_t )34,          (uint8_t )20, 
                (uint8_t )43}, 
     {          (uint8_t )117,          (uint8_t )20,          (uint8_t )15,          (uint8_t )36, 
                (uint8_t )163,          (uint8_t )128,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )26}}, 
   { {          (uint8_t )102,          (uint8_t )61,          (uint8_t )71,          (uint8_t )37, 
                (uint8_t )34,          (uint8_t )53,          (uint8_t )31,          (uint8_t )243, 
                (uint8_t )192}, 
     {          (uint8_t )69,          (uint8_t )60,          (uint8_t )71,          (uint8_t )38, 
                (uint8_t )73,          (uint8_t )119,          (uint8_t )28,          (uint8_t )222, 
                (uint8_t )37}, 
     {          (uint8_t )68,          (uint8_t )45,          (uint8_t )128,          (uint8_t )34, 
                (uint8_t )1,          (uint8_t )47,          (uint8_t )11,          (uint8_t )245, 
                (uint8_t )171}, 
     {          (uint8_t )62,          (uint8_t )17,          (uint8_t )19,          (uint8_t )70, 
                (uint8_t )146,          (uint8_t )85,          (uint8_t )55,          (uint8_t )62, 
                (uint8_t )70}, 
     {          (uint8_t )37,          (uint8_t )43,          (uint8_t )37,          (uint8_t )154, 
                (uint8_t )100,          (uint8_t )163,          (uint8_t )85,          (uint8_t )160, 
                (uint8_t )1}, 
     {          (uint8_t )63,          (uint8_t )9,          (uint8_t )92,          (uint8_t )136, 
                (uint8_t )28,          (uint8_t )64,          (uint8_t )32,          (uint8_t )201, 
                (uint8_t )85}, 
     {          (uint8_t )75,          (uint8_t )15,          (uint8_t )9,          (uint8_t )9, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )184,          (uint8_t )119, 
                (uint8_t )16}, 
     {          (uint8_t )86,          (uint8_t )6,          (uint8_t )28,          (uint8_t )5, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )25,          (uint8_t )248, 
                (uint8_t )1}, 
     {          (uint8_t )56,          (uint8_t )8,          (uint8_t )17,          (uint8_t )132, 
                (uint8_t )137,          (uint8_t )255,          (uint8_t )55,          (uint8_t )116, 
                (uint8_t )128}, 
     {          (uint8_t )58,          (uint8_t )15,          (uint8_t )20,          (uint8_t )82, 
                (uint8_t )135,          (uint8_t )57,          (uint8_t )26,          (uint8_t )121, 
                (uint8_t )40}}, 
   { {          (uint8_t )164,          (uint8_t )50,          (uint8_t )31,          (uint8_t )137, 
                (uint8_t )154,          (uint8_t )133,          (uint8_t )25,          (uint8_t )35, 
                (uint8_t )218}, 
     {          (uint8_t )51,          (uint8_t )103,          (uint8_t )44,          (uint8_t )131, 
                (uint8_t )131,          (uint8_t )123,          (uint8_t )31,          (uint8_t )6, 
                (uint8_t )158}, 
     {          (uint8_t )86,          (uint8_t )40,          (uint8_t )64,          (uint8_t )135, 
                (uint8_t )148,          (uint8_t )224,          (uint8_t )45,          (uint8_t )183, 
                (uint8_t )128}, 
     {          (uint8_t )22,          (uint8_t )26,          (uint8_t )17,          (uint8_t )131, 
                (uint8_t )240,          (uint8_t )154,          (uint8_t )14,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )45,          (uint8_t )16,          (uint8_t )21,          (uint8_t )91, 
                (uint8_t )64,          (uint8_t )222,          (uint8_t )7,          (uint8_t )1, 
                (uint8_t )197}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )39,          (uint8_t )155, 
                (uint8_t )60,          (uint8_t )138,          (uint8_t )23,          (uint8_t )102, 
                (uint8_t )213}, 
     {          (uint8_t )83,          (uint8_t )12,          (uint8_t )13,          (uint8_t )54, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )68,          (uint8_t )47, 
                (uint8_t )28}, 
     {          (uint8_t )85,          (uint8_t )26,          (uint8_t )85,          (uint8_t )85, 
                (uint8_t )128,          (uint8_t )128,          (uint8_t )32,          (uint8_t )146, 
                (uint8_t )171}, 
     {          (uint8_t )18,          (uint8_t )11,          (uint8_t )7,          (uint8_t )63, 
                (uint8_t )144,          (uint8_t )171,          (uint8_t )4,          (uint8_t )4, 
                (uint8_t )246}, 
     {          (uint8_t )35,          (uint8_t )27,          (uint8_t )10,          (uint8_t )146, 
                (uint8_t )174,          (uint8_t )171,          (uint8_t )12,          (uint8_t )26, 
                (uint8_t )128}}, 
   { {          (uint8_t )190,          (uint8_t )80,          (uint8_t )35,          (uint8_t )99, 
                (uint8_t )180,          (uint8_t )80,          (uint8_t )126,          (uint8_t )54, 
                (uint8_t )45}, 
     {          (uint8_t )85,          (uint8_t )126,          (uint8_t )47,          (uint8_t )87, 
                (uint8_t )176,          (uint8_t )51,          (uint8_t )41,          (uint8_t )20, 
                (uint8_t )32}, 
     {          (uint8_t )101,          (uint8_t )75,          (uint8_t )128,          (uint8_t )139, 
                (uint8_t )118,          (uint8_t )146,          (uint8_t )116,          (uint8_t )128, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )41,          (uint8_t )15,          (uint8_t )176, 
                (uint8_t )236,          (uint8_t )85,          (uint8_t )37,          (uint8_t )9, 
                (uint8_t )62}, 
     {          (uint8_t )71,          (uint8_t )30,          (uint8_t )17,          (uint8_t )119, 
                (uint8_t )118,          (uint8_t )255,          (uint8_t )17,          (uint8_t )18, 
                (uint8_t )138}, 
     {          (uint8_t )101,          (uint8_t )38,          (uint8_t )60,          (uint8_t )138, 
                (uint8_t )55,          (uint8_t )70,          (uint8_t )43,          (uint8_t )26, 
                (uint8_t )142}, 
     {          (uint8_t )146,          (uint8_t )36,          (uint8_t )19,          (uint8_t )30, 
                (uint8_t )171,          (uint8_t )255,          (uint8_t )97,          (uint8_t )27, 
                (uint8_t )20}, 
     {          (uint8_t )138,          (uint8_t )45,          (uint8_t )61,          (uint8_t )62, 
                (uint8_t )219,          (uint8_t )1,          (uint8_t )81,          (uint8_t )188, 
                (uint8_t )64}, 
     {          (uint8_t )32,          (uint8_t )41,          (uint8_t )20,          (uint8_t )117, 
                (uint8_t )151,          (uint8_t )142,          (uint8_t )20,          (uint8_t )21, 
                (uint8_t )163}, 
     {          (uint8_t )112,          (uint8_t )19,          (uint8_t )12,          (uint8_t )61, 
                (uint8_t )195,          (uint8_t )128,          (uint8_t )48,          (uint8_t )4, 
                (uint8_t )24}}};
#line 273 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
static int PutI4Mode(VP8BitWriter *bw , int mode , uint8_t *prob ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 275
  __cil_tmp4 = VP8PutBit(bw, mode != 0, (int )*(prob + 0));
  }
#line 275
  if (__cil_tmp4) {
    {
#line 276
    __cil_tmp5 = VP8PutBit(bw, mode != 1, (int )*(prob + 1));
    }
#line 276
    if (__cil_tmp5) {
      {
#line 277
      __cil_tmp6 = VP8PutBit(bw, mode != 2, (int )*(prob + 2));
      }
#line 277
      if (__cil_tmp6) {
        {
#line 278
        __cil_tmp7 = VP8PutBit(bw, mode >= 6, (int )*(prob + 3));
        }
#line 278
        if (! __cil_tmp7) {
          {
#line 279
          __cil_tmp8 = VP8PutBit(bw, mode != 3, (int )*(prob + 4));
          }
#line 279
          if (__cil_tmp8) {
            {
#line 280
            VP8PutBit(bw, mode != 4, (int )*(prob + 5));
            }
          }
        } else {
          {
#line 283
          __cil_tmp9 = VP8PutBit(bw, mode != 6, (int )*(prob + 6));
          }
#line 283
          if (__cil_tmp9) {
            {
#line 284
            __cil_tmp10 = VP8PutBit(bw, mode != 7, (int )*(prob + 7));
            }
#line 284
            if (__cil_tmp10) {
              {
#line 285
              VP8PutBit(bw, mode != 8, (int )*(prob + 8));
              }
            }
          }
        }
      }
    }
  }
#line 292
  return (mode);
}
}
#line 295 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
static void PutI16Mode(VP8BitWriter *bw , int mode ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 296
  __cil_tmp3 = VP8PutBit(bw, mode == 1 || mode == 3, 156);
  }
#line 296
  if (__cil_tmp3) {
    {
#line 297
    VP8PutBit(bw, mode == 1, 128);
    }
  } else {
    {
#line 299
    VP8PutBit(bw, mode == 2, 163);
    }
  }
  return;
}
}
#line 303 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
static void PutUVMode(VP8BitWriter *bw , int uv_mode ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 304
  __cil_tmp3 = VP8PutBit(bw, uv_mode != 0, 142);
  }
#line 304
  if (__cil_tmp3) {
    {
#line 305
    __cil_tmp4 = VP8PutBit(bw, uv_mode != 2, 114);
    }
#line 305
    if (__cil_tmp4) {
      {
#line 306
      VP8PutBit(bw, uv_mode != 3, 183);
      }
    }
  }
  return;
}
}
#line 311 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
static void PutSegment(VP8BitWriter *bw , int s , uint8_t *p ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 312
  __cil_tmp4 = VP8PutBit(bw, s >= 2, (int )*(p + 0));
  }
#line 312
  if (__cil_tmp4) {
#line 312
    p ++;
  }
  {
#line 313
  VP8PutBit(bw, s & 1, (int )*(p + 1));
  }
  return;
}
}
#line 316 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
void VP8CodeIntraModes(VP8Encoder *enc ) 
{ 
  VP8BitWriter *bw ;
  VP8EncIterator it ;
  int __cil_tmp4 ;
  VP8MBInfo *mb ;
  uint8_t *preds ;
  int __cil_tmp7 ;
  int preds_w ;
  uint8_t *top_pred ;
  int x ;
  int y ;
  int left ;
  uint8_t *probas ;
  int __cil_tmp14 ;

  {
  {
#line 317
  bw = & enc->bw_;
#line 319
  VP8IteratorInit(enc, & it);
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    mb = it.mb_;
#line 322
    preds = it.preds_;
#line 323
    if (enc->segment_hdr_.update_map_) {
      {
#line 324
      PutSegment(bw, (int )mb->segment_, (uint8_t *)enc->proba_.segments_);
      }
    }
#line 326
    if (enc->proba_.use_skip_proba_) {
      {
#line 327
      VP8PutBit(bw, (int )mb->skip_, (int )enc->proba_.skip_proba_);
      }
    }
    {
#line 329
    __cil_tmp7 = VP8PutBit(bw, (int )mb->type_ != 0, 145);
    }
#line 329
    if (__cil_tmp7) {
      {
#line 330
      PutI16Mode(bw, (int )*(preds + 0));
      }
    } else {
#line 332
      preds_w = enc->preds_w_;
#line 333
      top_pred = preds - preds_w;
#line 335
      y = 0;
      {
#line 335
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 335
        if (! (y < 4)) {
#line 335
          goto while_break___0;
        }
#line 336
        left = (int )*(preds + - 1);
#line 337
        x = 0;
        {
#line 337
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 337
          if (! (x < 4)) {
#line 337
            goto while_break___1;
          }
          {
#line 338
          probas = (uint8_t *)kBModesProba[*(top_pred + x)][left];
#line 339
          left = PutI4Mode(bw, (int )*(preds + x), probas);
          }
#line 337
          x ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 341
        top_pred = preds;
#line 342
        preds += preds_w;
#line 335
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 345
    PutUVMode(bw, (int )mb->uv_mode_);
    }
#line 320
    if (! __cil_tmp4) {
#line 320
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 353 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
uint8_t VP8CoeffsUpdateProba[4][8][3][11]  = { { { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )176,            (uint8_t )246,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )241,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )244,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )246,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )239,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )217,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )225,            (uint8_t )252,            (uint8_t )241,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )250,            (uint8_t )241,            (uint8_t )250, 
                    (uint8_t )253,            (uint8_t )255,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )238,            (uint8_t )253,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )247,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )186,            (uint8_t )251,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )251,            (uint8_t )244,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )251,            (uint8_t )243,            (uint8_t )253, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )236,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )253,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )248,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )254,            (uint8_t )252,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )249,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )246,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )254,            (uint8_t )251,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )245,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )252,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}};
#line 488 "/doner/libwebp/libwebp-v0.3.0/src/enc/tree.c"
void VP8WriteProbas(VP8BitWriter *bw , VP8Proba *probas ) 
{ 
  int t ;
  int b ;
  int c ;
  int p ;
  uint8_t p0 ;
  int update ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 490
  t = 0;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (t < 4)) {
#line 490
      goto while_break;
    }
#line 491
    b = 0;
    {
#line 491
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 491
      if (! (b < 8)) {
#line 491
        goto while_break___0;
      }
#line 492
      c = 0;
      {
#line 492
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 492
        if (! (c < 3)) {
#line 492
          goto while_break___1;
        }
#line 493
        p = 0;
        {
#line 493
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 493
          if (! (p < 11)) {
#line 493
            goto while_break___2;
          }
          {
#line 494
          p0 = probas->coeffs_[t][b][c][p];
#line 495
          update = (int )p0 != (int )VP8CoeffsProba0[t][b][c][p];
#line 496
          __cil_tmp9 = VP8PutBit(bw, update, (int )VP8CoeffsUpdateProba[t][b][c][p]);
          }
#line 496
          if (__cil_tmp9) {
            {
#line 497
            VP8PutValue(bw, (int )p0, 8);
            }
          }
#line 493
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 492
        c ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 491
      b ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 490
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 503
  __cil_tmp10 = VP8PutBitUniform(bw, probas->use_skip_proba_);
  }
#line 503
  if (__cil_tmp10) {
    {
#line 504
    VP8PutValue(bw, (int )probas->skip_proba_, 8);
    }
  }
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/enc/token.c"
void VP8TBufferInit(VP8TBuffer *b ) 
{ 


  {
#line 43
  b->tokens_ = (uint16_t *)((void *)0);
#line 44
  b->pages_ = (VP8Tokens *)((void *)0);
#line 45
  b->last_page_ = & b->pages_;
#line 46
  b->left_ = 0;
#line 47
  b->error_ = 0;
  return;
}
}
#line 50 "/doner/libwebp/libwebp-v0.3.0/src/enc/token.c"
void VP8TBufferClear(VP8TBuffer *b ) 
{ 
  VP8Tokens *p ;
  VP8Tokens *next ;

  {
#line 51
  if (b != (void *)0) {
#line 52
    p = b->pages_;
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
#line 53
      if (! (p != (void *)0)) {
#line 53
        goto while_break;
      }
      {
#line 54
      next = p->next_;
#line 55
      free((void *)p);
#line 56
      p = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 58
    VP8TBufferInit(b);
    }
  }
  return;
}
}
#line 62 "/doner/libwebp/libwebp-v0.3.0/src/enc/token.c"
static int TBufferNewPage(VP8TBuffer *b ) 
{ 
  VP8Tokens *page ;
  void *__cil_tmp3 ;
  VP8Tokens *tmp ;

  {
#line 63
  if (b->error_) {
#line 63
    tmp = (VP8Tokens *)((void *)0);
  } else {
    {
#line 63
    __cil_tmp3 = malloc(sizeof(*page));
#line 63
    tmp = (VP8Tokens *)__cil_tmp3;
    }
  }
#line 63
  page = tmp;
#line 64
  if (page == (void *)0) {
#line 65
    b->error_ = 1;
#line 66
    return (0);
  }
#line 68
  *(b->last_page_) = page;
#line 69
  b->last_page_ = & page->next_;
#line 70
  b->left_ = 8192;
#line 71
  b->tokens_ = (uint16_t *)page->tokens_;
#line 72
  page->next_ = (VP8Tokens *)((void *)0);
#line 73
  return (1);
}
}
#line 81 "/doner/libwebp/libwebp-v0.3.0/src/enc/token.c"
__inline static int AddToken(VP8TBuffer *b , int bit , uint32_t proba_idx ) 
{ 
  int tmp ;
  int tmp___0 ;
  int __cil_tmp6 ;
  int slot ;

  {
  {
#line 85
  __cil_tmp6 = TBufferNewPage(b);
  }
#line 85
  if (b->left_ > 0) {
#line 86
    (b->left_) --;
#line 86
    slot = b->left_;
#line 87
    *(b->tokens_ + slot) = (uint16_t )((unsigned int )(bit << 15) | proba_idx);
  } else
#line 85
  if (__cil_tmp6) {
#line 86
    (b->left_) --;
#line 86
    slot = b->left_;
#line 87
    *(b->tokens_ + slot) = (uint16_t )((unsigned int )(bit << 15) | proba_idx);
  }
#line 89
  return (bit);
}
}
#line 92 "/doner/libwebp/libwebp-v0.3.0/src/enc/token.c"
__inline static void AddConstantToken(VP8TBuffer *b , int bit , int proba ) 
{ 
  int tmp ;
  int tmp___0 ;
  int __cil_tmp6 ;
  int slot ;

  {
  {
#line 96
  __cil_tmp6 = TBufferNewPage(b);
  }
#line 96
  if (b->left_ > 0) {
#line 97
    (b->left_) --;
#line 97
    slot = b->left_;
#line 98
    *(b->tokens_ + slot) = (uint16_t )(((unsigned int )(bit << 15) | (1U << 14)) | (unsigned int )proba);
  } else
#line 96
  if (__cil_tmp6) {
#line 97
    (b->left_) --;
#line 97
    slot = b->left_;
#line 98
    *(b->tokens_ + slot) = (uint16_t )(((unsigned int )(bit << 15) | (1U << 14)) | (unsigned int )proba);
  }
  return;
}
}
#line 102 "/doner/libwebp/libwebp-v0.3.0/src/enc/token.c"
int VP8RecordCoeffTokens(int ctx , int coeff_type , int first , int last , int16_t *coeffs ,
                         VP8TBuffer *tokens ) 
{ 
  int n ;
  uint32_t base_id ;
  int __cil_tmp9 ;
  int c ;
  int __cil_tmp11 ;
  int sign ;
  int v ;
  int tmp ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int mask ;
  uint8_t *tab ;
  uint8_t *__cil_tmp23 ;
  int __cil_tmp24 ;

  {
  {
#line 105
  n = first;
#line 106
  base_id = (uint32_t )(11 * (ctx + 3 * (n + 8 * coeff_type)));
#line 107
  __cil_tmp9 = AddToken(tokens, last >= 0, base_id);
  }
#line 107
  if (! __cil_tmp9) {
#line 108
    return (0);
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (n < 16)) {
#line 111
      goto while_break;
    }
#line 112
    __cil_tmp11 = n;
#line 112
    n ++;
#line 112
    c = (int )*(coeffs + __cil_tmp11);
#line 113
    sign = c < 0;
#line 114
    if (sign) {
#line 114
      tmp = - c;
    } else {
#line 114
      tmp = c;
    }
    {
#line 114
    v = tmp;
#line 115
    __cil_tmp15 = AddToken(tokens, v != 0, base_id + 1U);
    }
#line 115
    if (! __cil_tmp15) {
#line 116
      ctx = 0;
#line 117
      base_id = (uint32_t )(11 * (ctx + 3 * ((int )VP8EncBands[n] + 8 * coeff_type)));
#line 118
      goto while_continue;
    }
    {
#line 120
    __cil_tmp16 = AddToken(tokens, v > 1, base_id + 2U);
    }
#line 120
    if (! __cil_tmp16) {
#line 121
      ctx = 1;
    } else {
      {
#line 123
      __cil_tmp17 = AddToken(tokens, v > 4, base_id + 3U);
      }
#line 123
      if (! __cil_tmp17) {
        {
#line 124
        __cil_tmp18 = AddToken(tokens, v != 2, base_id + 4U);
        }
#line 124
        if (__cil_tmp18) {
          {
#line 125
          AddToken(tokens, v == 4, base_id + 5U);
          }
        }
      } else {
        {
#line 126
        __cil_tmp19 = AddToken(tokens, v > 10, base_id + 6U);
        }
#line 126
        if (! __cil_tmp19) {
          {
#line 127
          __cil_tmp20 = AddToken(tokens, v > 6, base_id + 7U);
          }
#line 127
          if (! __cil_tmp20) {
            {
#line 128
            AddConstantToken(tokens, v == 6, 159);
            }
          } else {
            {
#line 130
            AddConstantToken(tokens, v >= 9, 165);
#line 131
            AddConstantToken(tokens, ! (v & 1), 145);
            }
          }
        } else {
#line 136
          if (v < 3 + (8 << 1)) {
            {
#line 137
            AddToken(tokens, 0, base_id + 8U);
#line 138
            AddToken(tokens, 0, base_id + 9U);
#line 139
            v -= 11;
#line 140
            mask = 1 << 2;
#line 141
            tab = (uint8_t *)VP8Cat3;
            }
          } else
#line 142
          if (v < 3 + (8 << 2)) {
            {
#line 143
            AddToken(tokens, 0, base_id + 8U);
#line 144
            AddToken(tokens, 1, base_id + 9U);
#line 145
            v -= 3 + (8 << 1);
#line 146
            mask = 1 << 3;
#line 147
            tab = (uint8_t *)VP8Cat4;
            }
          } else
#line 148
          if (v < 3 + (8 << 3)) {
            {
#line 149
            AddToken(tokens, 1, base_id + 8U);
#line 150
            AddToken(tokens, 0, base_id + 10U);
#line 151
            v -= 3 + (8 << 2);
#line 152
            mask = 1 << 4;
#line 153
            tab = (uint8_t *)VP8Cat5;
            }
          } else {
            {
#line 155
            AddToken(tokens, 1, base_id + 8U);
#line 156
            AddToken(tokens, 1, base_id + 10U);
#line 157
            v -= 3 + (8 << 3);
#line 158
            mask = 1 << 10;
#line 159
            tab = (uint8_t *)VP8Cat6;
            }
          }
          {
#line 161
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 161
            if (! mask) {
#line 161
              goto while_break___0;
            }
            {
#line 162
            __cil_tmp23 = tab;
#line 162
            tab ++;
#line 162
            AddConstantToken(tokens, ! (! (v & mask)), (int )*__cil_tmp23);
#line 163
            mask >>= 1;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 166
      ctx = 2;
    }
    {
#line 168
    AddConstantToken(tokens, sign, 128);
#line 169
    base_id = (uint32_t )(11 * (ctx + 3 * ((int )VP8EncBands[n] + 8 * coeff_type)));
#line 170
    __cil_tmp24 = AddToken(tokens, n <= last, base_id);
    }
#line 170
    if (n == 16) {
#line 171
      return (1);
    } else
#line 170
    if (! __cil_tmp24) {
#line 171
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (1);
}
}
#line 214 "/doner/libwebp/libwebp-v0.3.0/src/enc/token.c"
int VP8EmitTokens(VP8TBuffer *b , VP8BitWriter *bw , uint8_t *probas , int final_pass ) 
{ 
  VP8Tokens *p ;
  VP8Tokens *next ;
  int N ;
  int tmp ;
  int n ;
  int __cil_tmp10 ;
  uint16_t token ;
  int bit ;

  {
#line 216
  p = b->pages_;
#line 218
  if (b->error_) {
#line 218
    return (0);
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (p != (void *)0)) {
#line 219
      goto while_break;
    }
#line 220
    next = p->next_;
#line 221
    if (next == (void *)0) {
#line 221
      tmp = b->left_;
    } else {
#line 221
      tmp = 0;
    }
#line 221
    N = tmp;
#line 222
    n = 8192;
    {
#line 223
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 223
      __cil_tmp10 = n;
#line 223
      n --;
#line 223
      if (! (__cil_tmp10 > N)) {
#line 223
        goto while_break___0;
      }
#line 224
      token = p->tokens_[n];
#line 225
      bit = ((int )token >> 15) & 1;
#line 226
      if ((unsigned int )token & (1U << 14)) {
        {
#line 227
        VP8PutBit(bw, bit, (int )((unsigned int )token & 255U));
        }
      } else {
        {
#line 229
        VP8PutBit(bw, bit, (int )*(probas + ((unsigned int )token & 16383U)));
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 232
    if (final_pass) {
      {
#line 232
      free((void *)p);
      }
    }
#line 233
    p = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  if (final_pass) {
#line 235
    b->pages_ = (VP8Tokens *)((void *)0);
  }
#line 236
  return (1);
}
}
#line 54 "/doner/libwebp/libwebp-v0.3.0/src/enc/../webp/mux_types.h"
__inline static void WebPDataInit(WebPData *webp_data ) 
{ 


  {
#line 55
  if (webp_data != (void *)0) {
    {
#line 56
    memset(webp_data, 0, sizeof(*webp_data));
    }
  }
  return;
}
}
#line 62 "/doner/libwebp/libwebp-v0.3.0/src/enc/../webp/mux_types.h"
__inline static void WebPDataClear(WebPData *webp_data ) 
{ 


  {
#line 63
  if (webp_data != (void *)0) {
    {
#line 64
    free((void *)webp_data->bytes);
#line 65
    WebPDataInit(webp_data);
    }
  }
  return;
}
}
#line 71 "/doner/libwebp/libwebp-v0.3.0/src/enc/../webp/mux_types.h"
__inline static int WebPDataCopy(WebPData *src , WebPData *dst ) 
{ 
  void *__cil_tmp3 ;

  {
#line 72
  if (src == (void *)0) {
#line 72
    return (0);
  } else
#line 72
  if (dst == (void *)0) {
#line 72
    return (0);
  }
  {
#line 73
  WebPDataInit(dst);
  }
#line 74
  if (src->bytes != (void *)0) {
#line 74
    if (src->size != 0UL) {
      {
#line 75
      __cil_tmp3 = malloc(src->size);
#line 75
      dst->bytes = (uint8_t *)__cil_tmp3;
      }
#line 76
      if (dst->bytes == (void *)0) {
#line 76
        return (0);
      }
      {
#line 77
      memcpy((void *)dst->bytes, src->bytes, src->size);
#line 78
      dst->size = src->size;
      }
    }
  }
#line 80
  return (1);
}
}
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static int IsVP8XNeeded(VP8Encoder *enc ) 
{ 


  {
#line 27
  return (! (! enc->has_alpha_));
}
}
#line 31 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static int PutPaddingByte(WebPPicture *pic ) 
{ 
  uint8_t pad_byte[1] ;
  int __cil_tmp3 ;

  {
  {
#line 32
  pad_byte[0] = (uint8_t )0;
#line 33
  __cil_tmp3 = (*(pic->writer))((uint8_t *)pad_byte, (size_t )1, pic);
  }
#line 33
  return (! (! __cil_tmp3));
}
}
#line 39 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static enum WebPEncodingError PutRIFFHeader(VP8Encoder *enc , size_t riff_size ) 
{ 
  WebPPicture *pic ;
  uint8_t riff[12] ;
  int tmp ;
  int __cil_tmp6 ;

  {
  {
#line 41
  pic = enc->pic_;
#line 42
  riff[0] = (uint8_t )'R';
#line 42
  riff[1] = (uint8_t )'I';
#line 42
  riff[2] = (uint8_t )'F';
#line 42
  riff[3] = (uint8_t )'F';
#line 42
  riff[4] = (uint8_t )0;
#line 42
  riff[5] = (uint8_t )0;
#line 42
  riff[6] = (uint8_t )0;
#line 42
  riff[7] = (uint8_t )0;
#line 42
  riff[8] = (uint8_t )'W';
#line 42
  riff[9] = (uint8_t )'E';
#line 42
  riff[10] = (uint8_t )'B';
#line 42
  riff[11] = (uint8_t )'P';
#line 46
  PutLE32((uint8_t *)riff + 4, (uint32_t )riff_size);
#line 47
  __cil_tmp6 = (*(pic->writer))((uint8_t *)riff, sizeof(riff), pic);
  }
#line 47
  if (! __cil_tmp6) {
#line 48
    return ((enum WebPEncodingError )8);
  }
#line 50
  return ((enum WebPEncodingError )0);
}
}
#line 53 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static enum WebPEncodingError PutVP8XHeader(VP8Encoder *enc ) 
{ 
  WebPPicture *pic ;
  uint8_t vp8x[18] ;
  unsigned int tmp ;
  uint32_t flags ;
  int __cil_tmp6 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp10 ;

  {
#line 54
  pic = enc->pic_;
#line 55
  vp8x[0] = (uint8_t )'V';
#line 55
  vp8x[1] = (uint8_t )'P';
#line 55
  vp8x[2] = (uint8_t )'8';
#line 55
  vp8x[3] = (uint8_t )'X';
#line 55
  tmp = (unsigned int )4;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (tmp >= 18) {
#line 55
      goto while_break;
    }
#line 55
    vp8x[tmp] = 0;
#line 55
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  flags = (uint32_t )0;
#line 64
  if (enc->has_alpha_) {
#line 65
    flags |= (unsigned int )16;
  }
  {
#line 68
  PutLE32((uint8_t *)vp8x + 4, (uint32_t )10);
#line 69
  PutLE32((uint8_t *)vp8x + 8, flags);
#line 70
  PutLE24(((uint8_t *)vp8x + 8) + 4, pic->width - 1);
#line 71
  PutLE24(((uint8_t *)vp8x + 8) + 7, pic->height - 1);
#line 72
  __cil_tmp10 = (*(pic->writer))((uint8_t *)vp8x, sizeof(vp8x), pic);
  }
#line 72
  if (! __cil_tmp10) {
#line 73
    return ((enum WebPEncodingError )8);
  }
#line 75
  return ((enum WebPEncodingError )0);
}
}
#line 78 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static enum WebPEncodingError PutAlphaChunk(VP8Encoder *enc ) 
{ 
  WebPPicture *pic ;
  uint8_t alpha_chunk_hdr[8] ;
  unsigned int tmp ;
  int tmp___0 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 79
  pic = enc->pic_;
#line 80
  alpha_chunk_hdr[0] = (uint8_t )'A';
#line 80
  alpha_chunk_hdr[1] = (uint8_t )'L';
#line 80
  alpha_chunk_hdr[2] = (uint8_t )'P';
#line 80
  alpha_chunk_hdr[3] = (uint8_t )'H';
#line 80
  tmp = (unsigned int )4;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (tmp >= 8) {
#line 80
      goto while_break;
    }
#line 80
    alpha_chunk_hdr[tmp] = 0;
#line 80
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  PutLE32((uint8_t *)alpha_chunk_hdr + 4, enc->alpha_data_size_);
#line 88
  __cil_tmp6 = (*(pic->writer))((uint8_t *)alpha_chunk_hdr, sizeof(alpha_chunk_hdr),
                                pic);
  }
#line 88
  if (! __cil_tmp6) {
#line 89
    return ((enum WebPEncodingError )8);
  }
  {
#line 93
  __cil_tmp7 = (*(pic->writer))(enc->alpha_data_, (size_t )enc->alpha_data_size_,
                                pic);
  }
#line 93
  if (! __cil_tmp7) {
#line 94
    return ((enum WebPEncodingError )8);
  }
  {
#line 98
  __cil_tmp8 = PutPaddingByte(pic);
  }
#line 98
  if (enc->alpha_data_size_ & 1U) {
#line 98
    if (! __cil_tmp8) {
#line 99
      return ((enum WebPEncodingError )8);
    }
  }
#line 101
  return ((enum WebPEncodingError )0);
}
}
#line 104 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static enum WebPEncodingError PutVP8Header(WebPPicture *pic , size_t vp8_size ) 
{ 
  uint8_t vp8_chunk_hdr[8] ;
  unsigned int tmp ;
  int tmp___0 ;
  int __cil_tmp6 ;

  {
#line 106
  vp8_chunk_hdr[0] = (uint8_t )'V';
#line 106
  vp8_chunk_hdr[1] = (uint8_t )'P';
#line 106
  vp8_chunk_hdr[2] = (uint8_t )'8';
#line 106
  vp8_chunk_hdr[3] = (uint8_t )' ';
#line 106
  tmp = (unsigned int )4;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (tmp >= 8) {
#line 106
      goto while_break;
    }
#line 106
    vp8_chunk_hdr[tmp] = 0;
#line 106
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  PutLE32((uint8_t *)vp8_chunk_hdr + 4, (uint32_t )vp8_size);
#line 111
  __cil_tmp6 = (*(pic->writer))((uint8_t *)vp8_chunk_hdr, sizeof(vp8_chunk_hdr), pic);
  }
#line 111
  if (! __cil_tmp6) {
#line 112
    return ((enum WebPEncodingError )8);
  }
#line 114
  return ((enum WebPEncodingError )0);
}
}
#line 117 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static enum WebPEncodingError PutVP8FrameHeader(WebPPicture *pic , int profile , size_t size0 ) 
{ 
  uint8_t vp8_frm_hdr[10] ;
  uint32_t bits ;
  int __cil_tmp6 ;

  {
#line 122
  if (size0 >= (unsigned long )(1 << 19)) {
#line 123
    return ((enum WebPEncodingError )6);
  }
  {
#line 127
  bits = (unsigned int )((profile << 1) | (1 << 4)) | ((uint32_t )size0 << 5);
#line 131
  vp8_frm_hdr[0] = (uint8_t )(bits & 255U);
#line 132
  vp8_frm_hdr[1] = (uint8_t )((bits >> 8) & 255U);
#line 133
  vp8_frm_hdr[2] = (uint8_t )((bits >> 16) & 255U);
#line 135
  vp8_frm_hdr[3] = (uint8_t )((10289450 >> 16) & 255);
#line 136
  vp8_frm_hdr[4] = (uint8_t )((10289450 >> 8) & 255);
#line 137
  vp8_frm_hdr[5] = (uint8_t )42;
#line 139
  vp8_frm_hdr[6] = (uint8_t )(pic->width & 255);
#line 140
  vp8_frm_hdr[7] = (uint8_t )(pic->width >> 8);
#line 141
  vp8_frm_hdr[8] = (uint8_t )(pic->height & 255);
#line 142
  vp8_frm_hdr[9] = (uint8_t )(pic->height >> 8);
#line 144
  __cil_tmp6 = (*(pic->writer))((uint8_t *)vp8_frm_hdr, sizeof(vp8_frm_hdr), pic);
  }
#line 144
  if (! __cil_tmp6) {
#line 145
    return ((enum WebPEncodingError )8);
  }
#line 147
  return ((enum WebPEncodingError )0);
}
}
#line 151 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static int PutWebPHeaders(VP8Encoder *enc , size_t size0 , size_t vp8_size , size_t riff_size ) 
{ 
  WebPPicture *pic ;
  enum WebPEncodingError err ;
  enum WebPEncodingError __cil_tmp7 ;
  int __cil_tmp8 ;
  enum WebPEncodingError __cil_tmp9 ;
  enum WebPEncodingError __cil_tmp10 ;
  enum WebPEncodingError __cil_tmp11 ;
  enum WebPEncodingError __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 153
  pic = enc->pic_;
#line 154
  err = (enum WebPEncodingError )0;
#line 157
  err = PutRIFFHeader(enc, riff_size);
  }
#line 158
  if ((unsigned int )err != 0U) {
#line 158
    goto Error;
  }
  {
#line 161
  __cil_tmp8 = IsVP8XNeeded(enc);
  }
#line 161
  if (__cil_tmp8) {
    {
#line 162
    err = PutVP8XHeader(enc);
    }
#line 163
    if ((unsigned int )err != 0U) {
#line 163
      goto Error;
    }
  }
#line 167
  if (enc->has_alpha_) {
    {
#line 168
    err = PutAlphaChunk(enc);
    }
#line 169
    if ((unsigned int )err != 0U) {
#line 169
      goto Error;
    }
  }
  {
#line 173
  err = PutVP8Header(pic, vp8_size);
  }
#line 174
  if ((unsigned int )err != 0U) {
#line 174
    goto Error;
  }
  {
#line 177
  err = PutVP8FrameHeader(pic, enc->profile_, size0);
  }
#line 178
  if ((unsigned int )err != 0U) {
#line 178
    goto Error;
  }
#line 181
  return (1);
  Error: 
  {
#line 185
  __cil_tmp13 = WebPEncodingSetError(pic, err);
  }
#line 185
  return (__cil_tmp13);
}
}
#line 189 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static void PutSegmentHeader(VP8BitWriter *bw , VP8Encoder *enc ) 
{ 
  VP8SegmentHeader *hdr ;
  VP8Proba *proba ;
  int __cil_tmp5 ;
  int update_data ;
  int s ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 191
  hdr = & enc->segment_hdr_;
#line 192
  proba = & enc->proba_;
#line 193
  __cil_tmp5 = VP8PutBitUniform(bw, hdr->num_segments_ > 1);
  }
#line 193
  if (__cil_tmp5) {
    {
#line 195
    update_data = 1;
#line 197
    VP8PutBitUniform(bw, hdr->update_map_);
#line 198
    __cil_tmp8 = VP8PutBitUniform(bw, update_data);
    }
#line 198
    if (__cil_tmp8) {
      {
#line 200
      VP8PutBitUniform(bw, 1);
#line 201
      s = 0;
      }
      {
#line 201
      while (1) {
        while_continue: /* CIL Label */ ;
#line 201
        if (! (s < 4)) {
#line 201
          goto while_break;
        }
        {
#line 202
        VP8PutSignedValue(bw, enc->dqm_[s].quant_, 7);
        }
#line 201
        s ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 204
      s = 0;
      {
#line 204
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 204
        if (! (s < 4)) {
#line 204
          goto while_break___0;
        }
        {
#line 205
        VP8PutSignedValue(bw, enc->dqm_[s].fstrength_, 6);
        }
#line 204
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 208
    if (hdr->update_map_) {
#line 209
      s = 0;
      {
#line 209
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 209
        if (! (s < 3)) {
#line 209
          goto while_break___1;
        }
        {
#line 210
        __cil_tmp9 = VP8PutBitUniform(bw, (unsigned int )proba->segments_[s] != 255U);
        }
#line 210
        if (__cil_tmp9) {
          {
#line 211
          VP8PutValue(bw, (int )proba->segments_[s], 8);
          }
        }
#line 209
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 219 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static void PutFilterHeader(VP8BitWriter *bw , VP8FilterHeader *hdr ) 
{ 
  int use_lf_delta ;
  int __cil_tmp4 ;
  int need_update ;
  int __cil_tmp6 ;

  {
  {
#line 221
  use_lf_delta = hdr->i4x4_lf_delta_ != 0;
#line 222
  VP8PutBitUniform(bw, hdr->simple_);
#line 223
  VP8PutValue(bw, hdr->level_, 6);
#line 224
  VP8PutValue(bw, hdr->sharpness_, 3);
#line 225
  __cil_tmp4 = VP8PutBitUniform(bw, use_lf_delta);
  }
#line 225
  if (__cil_tmp4) {
    {
#line 227
    need_update = hdr->i4x4_lf_delta_ != 0;
#line 228
    __cil_tmp6 = VP8PutBitUniform(bw, need_update);
    }
#line 228
    if (__cil_tmp6) {
      {
#line 230
      VP8PutValue(bw, 0, 4);
#line 232
      VP8PutSignedValue(bw, hdr->i4x4_lf_delta_, 6);
#line 233
      VP8PutValue(bw, 0, 3);
      }
    }
  }
  return;
}
}
#line 239 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static void PutQuant(VP8BitWriter *bw , VP8Encoder *enc ) 
{ 


  {
  {
#line 241
  VP8PutValue(bw, enc->base_quant_, 7);
#line 242
  VP8PutSignedValue(bw, enc->dq_y1_dc_, 4);
#line 243
  VP8PutSignedValue(bw, enc->dq_y2_dc_, 4);
#line 244
  VP8PutSignedValue(bw, enc->dq_y2_ac_, 4);
#line 245
  VP8PutSignedValue(bw, enc->dq_uv_dc_, 4);
#line 246
  VP8PutSignedValue(bw, enc->dq_uv_ac_, 4);
  }
  return;
}
}
#line 250 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static int EmitPartitionsSize(VP8Encoder *enc , WebPPicture *pic ) 
{ 
  uint8_t buf[21] ;
  int p ;
  size_t part_size ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;

  {
#line 254
  p = 0;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (p < enc->num_parts_ - 1)) {
#line 254
      goto while_break;
    }
    {
#line 255
    __cil_tmp6 = VP8BitWriterSize((VP8BitWriter *)enc->parts_ + p);
#line 255
    part_size = __cil_tmp6;
    }
#line 256
    if (part_size >= (unsigned long )(1 << 24)) {
      {
#line 257
      __cil_tmp7 = WebPEncodingSetError(pic, (enum WebPEncodingError )7);
      }
#line 257
      return (__cil_tmp7);
    }
#line 259
    buf[3 * p] = (uint8_t )(part_size & 255UL);
#line 260
    buf[3 * p + 1] = (uint8_t )((part_size >> 8) & 255UL);
#line 261
    buf[3 * p + 2] = (uint8_t )((part_size >> 16) & 255UL);
#line 254
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if (p) {
    {
#line 263
    __cil_tmp8 = (*(pic->writer))((uint8_t *)buf, (size_t )(3 * p), pic);
#line 263
    tmp = __cil_tmp8;
    }
  } else {
#line 263
    tmp = 1;
  }
#line 263
  return (tmp);
}
}
#line 300 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
static size_t GeneratePartition0(VP8Encoder *enc ) 
{ 
  VP8BitWriter *bw ;
  int mb_size ;
  uint64_t pos1 ;
  uint64_t pos2 ;
  uint64_t pos3 ;
  uint64_t __cil_tmp7 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint64_t __cil_tmp11 ;
  uint64_t __cil_tmp12 ;

  {
  {
#line 301
  bw = & enc->bw_;
#line 302
  mb_size = enc->mb_w_ * enc->mb_h_;
#line 308
  pos1 = VP8BitWriterPos(bw);
#line 309
  VP8BitWriterInit(bw, (size_t )((mb_size * 7) / 8));
#line 313
  VP8PutBitUniform(bw, 0);
#line 315
  VP8PutBitUniform(bw, 0);
#line 317
  PutSegmentHeader(bw, enc);
#line 318
  PutFilterHeader(bw, & enc->filter_hdr_);
  }
#line 319
  if (enc->num_parts_ == 8) {
#line 319
    tmp___1 = 3;
  } else {
#line 319
    if (enc->num_parts_ == 4) {
#line 319
      tmp___0 = 2;
    } else {
#line 319
      if (enc->num_parts_ == 2) {
#line 319
        tmp = 1;
      } else {
#line 319
        tmp = 0;
      }
#line 319
      tmp___0 = tmp;
    }
#line 319
    tmp___1 = tmp___0;
  }
  {
#line 319
  VP8PutValue(bw, tmp___1, 2);
#line 322
  PutQuant(bw, enc);
#line 323
  VP8PutBitUniform(bw, 0);
#line 324
  VP8WriteProbas(bw, & enc->proba_);
#line 325
  pos2 = VP8BitWriterPos(bw);
#line 326
  VP8CodeIntraModes(enc);
#line 327
  VP8BitWriterFinish(bw);
#line 335
  pos3 = VP8BitWriterPos(bw);
  }
#line 337
  if ((enc->pic_)->stats) {
#line 338
    ((enc->pic_)->stats)->header_bytes[0] = (int )(((pos2 - pos1) + 7UL) >> 3);
#line 339
    ((enc->pic_)->stats)->header_bytes[1] = (int )(((pos3 - pos2) + 7UL) >> 3);
#line 340
    ((enc->pic_)->stats)->alpha_data_size = (int )enc->alpha_data_size_;
#line 341
    ((enc->pic_)->stats)->layer_data_size = (int )enc->layer_data_size_;
  }
#line 343
  return ((size_t )(! bw->error_));
}
}
#line 346 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
void VP8EncFreeBitWriters(VP8Encoder *enc ) 
{ 
  int p ;

  {
  {
#line 348
  VP8BitWriterWipeOut(& enc->bw_);
#line 349
  p = 0;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! (p < enc->num_parts_)) {
#line 349
      goto while_break;
    }
    {
#line 350
    VP8BitWriterWipeOut((VP8BitWriter *)enc->parts_ + p);
    }
#line 349
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 354 "/doner/libwebp/libwebp-v0.3.0/src/enc/syntax.c"
int VP8EncWrite(VP8Encoder *enc ) 
{ 
  WebPPicture *pic ;
  VP8BitWriter *bw ;
  int task_percent ;
  int percent_per_part ;
  int final_percent ;
  int ok ;
  size_t vp8_size ;
  size_t pad ;
  size_t riff_size ;
  int p ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  int __cil_tmp15 ;
  uint32_t padded_alpha_size ;
  int __cil_tmp17 ;
  uint8_t *part0 ;
  uint8_t *__cil_tmp19 ;
  size_t size0 ;
  size_t __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  uint8_t *buf ;
  uint8_t *__cil_tmp26 ;
  size_t size ;
  size_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
  {
#line 355
  pic = enc->pic_;
#line 356
  bw = & enc->bw_;
#line 357
  task_percent = 19;
#line 358
  percent_per_part = task_percent / enc->num_parts_;
#line 359
  final_percent = enc->percent_ + task_percent;
#line 360
  ok = 0;
#line 365
  __cil_tmp12 = GeneratePartition0(enc);
#line 365
  ok = ! (! __cil_tmp12);
#line 368
  __cil_tmp13 = VP8BitWriterSize(bw);
#line 368
  vp8_size = (10UL + __cil_tmp13) + (unsigned long )(3 * (enc->num_parts_ - 1));
#line 371
  p = 0;
  }
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (p < enc->num_parts_)) {
#line 371
      goto while_break;
    }
    {
#line 372
    __cil_tmp14 = VP8BitWriterSize((VP8BitWriter *)enc->parts_ + p);
    }
#line 372
    vp8_size += __cil_tmp14;
#line 371
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  pad = vp8_size & 1UL;
#line 375
  vp8_size += pad;
#line 379
  riff_size = 12UL + vp8_size;
#line 380
  __cil_tmp15 = IsVP8XNeeded(enc);
  }
#line 380
  if (__cil_tmp15) {
#line 381
    riff_size += (unsigned long )18;
  }
#line 383
  if (enc->has_alpha_) {
#line 384
    padded_alpha_size = enc->alpha_data_size_ + (enc->alpha_data_size_ & 1U);
#line 386
    riff_size += (unsigned long )(8U + padded_alpha_size);
  }
#line 389
  if (riff_size > 4294967294UL) {
    {
#line 390
    __cil_tmp17 = WebPEncodingSetError(pic, (enum WebPEncodingError )9);
    }
#line 390
    return (__cil_tmp17);
  }
  {
#line 395
  __cil_tmp19 = VP8BitWriterBuf(bw);
#line 395
  part0 = __cil_tmp19;
#line 396
  __cil_tmp21 = VP8BitWriterSize(bw);
#line 396
  size0 = __cil_tmp21;
#line 397
  __cil_tmp24 = EmitPartitionsSize(enc, pic);
  }
  {
#line 397
  __cil_tmp23 = (*(pic->writer))(part0, size0, pic);
  }
  {
#line 397
  __cil_tmp22 = PutWebPHeaders(enc, size0, vp8_size, riff_size);
#line 397
  ok = ((ok && __cil_tmp22) && __cil_tmp23) && __cil_tmp24;
#line 400
  VP8BitWriterWipeOut(bw);
#line 404
  p = 0;
  }
  {
#line 404
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 404
    if (! (p < enc->num_parts_)) {
#line 404
      goto while_break___0;
    }
    {
#line 405
    __cil_tmp26 = VP8BitWriterBuf((VP8BitWriter *)enc->parts_ + p);
#line 405
    buf = __cil_tmp26;
#line 406
    __cil_tmp28 = VP8BitWriterSize((VP8BitWriter *)enc->parts_ + p);
#line 406
    size = __cil_tmp28;
    }
#line 407
    if (size) {
      {
#line 408
      __cil_tmp29 = (*(pic->writer))(buf, size, pic);
#line 408
      ok = ok && __cil_tmp29;
      }
    }
    {
#line 409
    VP8BitWriterWipeOut((VP8BitWriter *)enc->parts_ + p);
#line 410
    __cil_tmp30 = WebPReportProgress(pic, enc->percent_ + percent_per_part, & enc->percent_);
#line 410
    ok = ok && __cil_tmp30;
    }
#line 404
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 415
  if (ok) {
#line 415
    if (pad) {
      {
#line 416
      ok = PutPaddingByte(pic);
      }
    }
  }
  {
#line 419
  enc->coded_size_ = (int )(8UL + riff_size);
#line 420
  __cil_tmp32 = WebPReportProgress(pic, final_percent, & enc->percent_);
#line 420
  ok = ok && __cil_tmp32;
  }
#line 421
  return (ok);
}
}
#line 22 "/doner/libwebp/libwebp-v0.3.0/src/enc/./cost.h"
uint16_t VP8LevelFixedCosts[2048] ;
#line 23
uint16_t VP8EntropyCost[256] ;
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/enc/./cost.h"
__inline static int VP8BitCost(int bit , uint8_t proba ) 
{ 
  int tmp ;

  {
#line 27
  if (! bit) {
#line 27
    tmp = (int )VP8EntropyCost[proba];
  } else {
#line 27
    tmp = (int )VP8EntropyCost[255 - (int )proba];
  }
#line 27
  return (tmp);
}
}
#line 31
uint16_t VP8LevelCodes[67][2] ;
#line 32
void VP8CalculateLevelCosts(VP8Proba *proba ) ;
#line 33 "/doner/libwebp/libwebp-v0.3.0/src/enc/./cost.h"
__inline static int VP8LevelCost(uint16_t *table , int level ) 
{ 
  int tmp ;

  {
#line 34
  if (level > 67) {
#line 34
    tmp = 67;
  } else {
#line 34
    tmp = level;
  }
#line 34
  return ((int )VP8LevelFixedCosts[level] + (int )*(table + tmp));
}
}
#line 39
uint16_t VP8FixedCostsUV[4] ;
#line 40
uint16_t VP8FixedCostsI16[4] ;
#line 41
uint16_t VP8FixedCostsI4[10][10][10] ;
#line 40 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
__inline static int clip(int v , int m , int M ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 41
  if (v < m) {
#line 41
    tmp___0 = m;
  } else {
#line 41
    if (v > M) {
#line 41
      tmp = M;
    } else {
#line 41
      tmp = v;
    }
#line 41
    tmp___0 = tmp;
  }
#line 41
  return (tmp___0);
}
}
#line 44 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint8_t kZigzag[16]  = 
#line 44
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )4,      (uint8_t )8, 
        (uint8_t )5,      (uint8_t )2,      (uint8_t )3,      (uint8_t )6, 
        (uint8_t )9,      (uint8_t )12,      (uint8_t )13,      (uint8_t )10, 
        (uint8_t )7,      (uint8_t )11,      (uint8_t )14,      (uint8_t )15};
#line 48 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint8_t kDcTable[128]  = 
#line 48
  {      (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )17, 
        (uint8_t )18,      (uint8_t )19,      (uint8_t )20,      (uint8_t )20, 
        (uint8_t )21,      (uint8_t )21,      (uint8_t )22,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )23,      (uint8_t )24,      (uint8_t )25, 
        (uint8_t )25,      (uint8_t )26,      (uint8_t )27,      (uint8_t )28, 
        (uint8_t )29,      (uint8_t )30,      (uint8_t )31,      (uint8_t )32, 
        (uint8_t )33,      (uint8_t )34,      (uint8_t )35,      (uint8_t )36, 
        (uint8_t )37,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )64,      (uint8_t )65,      (uint8_t )66, 
        (uint8_t )67,      (uint8_t )68,      (uint8_t )69,      (uint8_t )70, 
        (uint8_t )71,      (uint8_t )72,      (uint8_t )73,      (uint8_t )74, 
        (uint8_t )75,      (uint8_t )76,      (uint8_t )76,      (uint8_t )77, 
        (uint8_t )78,      (uint8_t )79,      (uint8_t )80,      (uint8_t )81, 
        (uint8_t )82,      (uint8_t )83,      (uint8_t )84,      (uint8_t )85, 
        (uint8_t )86,      (uint8_t )87,      (uint8_t )88,      (uint8_t )89, 
        (uint8_t )91,      (uint8_t )93,      (uint8_t )95,      (uint8_t )96, 
        (uint8_t )98,      (uint8_t )100,      (uint8_t )101,      (uint8_t )102, 
        (uint8_t )104,      (uint8_t )106,      (uint8_t )108,      (uint8_t )110, 
        (uint8_t )112,      (uint8_t )114,      (uint8_t )116,      (uint8_t )118, 
        (uint8_t )122,      (uint8_t )124,      (uint8_t )126,      (uint8_t )128, 
        (uint8_t )130,      (uint8_t )132,      (uint8_t )134,      (uint8_t )136, 
        (uint8_t )138,      (uint8_t )140,      (uint8_t )143,      (uint8_t )145, 
        (uint8_t )148,      (uint8_t )151,      (uint8_t )154,      (uint8_t )157};
#line 67 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint16_t kAcTable[128]  = 
#line 67
  {      (uint16_t )4,      (uint16_t )5,      (uint16_t )6,      (uint16_t )7, 
        (uint16_t )8,      (uint16_t )9,      (uint16_t )10,      (uint16_t )11, 
        (uint16_t )12,      (uint16_t )13,      (uint16_t )14,      (uint16_t )15, 
        (uint16_t )16,      (uint16_t )17,      (uint16_t )18,      (uint16_t )19, 
        (uint16_t )20,      (uint16_t )21,      (uint16_t )22,      (uint16_t )23, 
        (uint16_t )24,      (uint16_t )25,      (uint16_t )26,      (uint16_t )27, 
        (uint16_t )28,      (uint16_t )29,      (uint16_t )30,      (uint16_t )31, 
        (uint16_t )32,      (uint16_t )33,      (uint16_t )34,      (uint16_t )35, 
        (uint16_t )36,      (uint16_t )37,      (uint16_t )38,      (uint16_t )39, 
        (uint16_t )40,      (uint16_t )41,      (uint16_t )42,      (uint16_t )43, 
        (uint16_t )44,      (uint16_t )45,      (uint16_t )46,      (uint16_t )47, 
        (uint16_t )48,      (uint16_t )49,      (uint16_t )50,      (uint16_t )51, 
        (uint16_t )52,      (uint16_t )53,      (uint16_t )54,      (uint16_t )55, 
        (uint16_t )56,      (uint16_t )57,      (uint16_t )58,      (uint16_t )60, 
        (uint16_t )62,      (uint16_t )64,      (uint16_t )66,      (uint16_t )68, 
        (uint16_t )70,      (uint16_t )72,      (uint16_t )74,      (uint16_t )76, 
        (uint16_t )78,      (uint16_t )80,      (uint16_t )82,      (uint16_t )84, 
        (uint16_t )86,      (uint16_t )88,      (uint16_t )90,      (uint16_t )92, 
        (uint16_t )94,      (uint16_t )96,      (uint16_t )98,      (uint16_t )100, 
        (uint16_t )102,      (uint16_t )104,      (uint16_t )106,      (uint16_t )108, 
        (uint16_t )110,      (uint16_t )112,      (uint16_t )114,      (uint16_t )116, 
        (uint16_t )119,      (uint16_t )122,      (uint16_t )125,      (uint16_t )128, 
        (uint16_t )131,      (uint16_t )134,      (uint16_t )137,      (uint16_t )140, 
        (uint16_t )143,      (uint16_t )146,      (uint16_t )149,      (uint16_t )152, 
        (uint16_t )155,      (uint16_t )158,      (uint16_t )161,      (uint16_t )164, 
        (uint16_t )167,      (uint16_t )170,      (uint16_t )173,      (uint16_t )177, 
        (uint16_t )181,      (uint16_t )185,      (uint16_t )189,      (uint16_t )193, 
        (uint16_t )197,      (uint16_t )201,      (uint16_t )205,      (uint16_t )209, 
        (uint16_t )213,      (uint16_t )217,      (uint16_t )221,      (uint16_t )225, 
        (uint16_t )229,      (uint16_t )234,      (uint16_t )239,      (uint16_t )245, 
        (uint16_t )249,      (uint16_t )254,      (uint16_t )259,      (uint16_t )264, 
        (uint16_t )269,      (uint16_t )274,      (uint16_t )279,      (uint16_t )284};
#line 86 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint16_t kAcTable2[128]  = 
#line 86
  {      (uint16_t )8,      (uint16_t )8,      (uint16_t )9,      (uint16_t )10, 
        (uint16_t )12,      (uint16_t )13,      (uint16_t )15,      (uint16_t )17, 
        (uint16_t )18,      (uint16_t )20,      (uint16_t )21,      (uint16_t )23, 
        (uint16_t )24,      (uint16_t )26,      (uint16_t )27,      (uint16_t )29, 
        (uint16_t )31,      (uint16_t )32,      (uint16_t )34,      (uint16_t )35, 
        (uint16_t )37,      (uint16_t )38,      (uint16_t )40,      (uint16_t )41, 
        (uint16_t )43,      (uint16_t )44,      (uint16_t )46,      (uint16_t )48, 
        (uint16_t )49,      (uint16_t )51,      (uint16_t )52,      (uint16_t )54, 
        (uint16_t )55,      (uint16_t )57,      (uint16_t )58,      (uint16_t )60, 
        (uint16_t )62,      (uint16_t )63,      (uint16_t )65,      (uint16_t )66, 
        (uint16_t )68,      (uint16_t )69,      (uint16_t )71,      (uint16_t )72, 
        (uint16_t )74,      (uint16_t )75,      (uint16_t )77,      (uint16_t )79, 
        (uint16_t )80,      (uint16_t )82,      (uint16_t )83,      (uint16_t )85, 
        (uint16_t )86,      (uint16_t )88,      (uint16_t )89,      (uint16_t )93, 
        (uint16_t )96,      (uint16_t )99,      (uint16_t )102,      (uint16_t )105, 
        (uint16_t )108,      (uint16_t )111,      (uint16_t )114,      (uint16_t )117, 
        (uint16_t )120,      (uint16_t )124,      (uint16_t )127,      (uint16_t )130, 
        (uint16_t )133,      (uint16_t )136,      (uint16_t )139,      (uint16_t )142, 
        (uint16_t )145,      (uint16_t )148,      (uint16_t )151,      (uint16_t )155, 
        (uint16_t )158,      (uint16_t )161,      (uint16_t )164,      (uint16_t )167, 
        (uint16_t )170,      (uint16_t )173,      (uint16_t )176,      (uint16_t )179, 
        (uint16_t )184,      (uint16_t )189,      (uint16_t )193,      (uint16_t )198, 
        (uint16_t )203,      (uint16_t )207,      (uint16_t )212,      (uint16_t )217, 
        (uint16_t )221,      (uint16_t )226,      (uint16_t )230,      (uint16_t )235, 
        (uint16_t )240,      (uint16_t )244,      (uint16_t )249,      (uint16_t )254, 
        (uint16_t )258,      (uint16_t )263,      (uint16_t )268,      (uint16_t )274, 
        (uint16_t )280,      (uint16_t )286,      (uint16_t )292,      (uint16_t )299, 
        (uint16_t )305,      (uint16_t )311,      (uint16_t )317,      (uint16_t )323, 
        (uint16_t )330,      (uint16_t )336,      (uint16_t )342,      (uint16_t )348, 
        (uint16_t )354,      (uint16_t )362,      (uint16_t )370,      (uint16_t )379, 
        (uint16_t )385,      (uint16_t )393,      (uint16_t )401,      (uint16_t )409, 
        (uint16_t )416,      (uint16_t )424,      (uint16_t )432,      (uint16_t )440};
#line 105 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint16_t kCoeffThresh[16]  = 
#line 105
  {      (uint16_t )0,      (uint16_t )10,      (uint16_t )20,      (uint16_t )30, 
        (uint16_t )10,      (uint16_t )20,      (uint16_t )30,      (uint16_t )30, 
        (uint16_t )20,      (uint16_t )30,      (uint16_t )30,      (uint16_t )30, 
        (uint16_t )30,      (uint16_t )30,      (uint16_t )30,      (uint16_t )30};
#line 113 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint8_t kBiasMatrices[3][16]  = { {        (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96}, 
   {        (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96}, 
   {        (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96, 
            (uint8_t )96,        (uint8_t )96,        (uint8_t )96,        (uint8_t )96}};
#line 130 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint8_t kFreqSharpening[16]  = 
#line 130
  {      (uint8_t )0,      (uint8_t )30,      (uint8_t )60,      (uint8_t )90, 
        (uint8_t )30,      (uint8_t )60,      (uint8_t )90,      (uint8_t )90, 
        (uint8_t )60,      (uint8_t )90,      (uint8_t )90,      (uint8_t )90, 
        (uint8_t )90,      (uint8_t )90,      (uint8_t )90,      (uint8_t )90};
#line 141 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static int ExpandMatrix(VP8Matrix *m , int type ) 
{ 
  int i ;
  int sum ;
  int j ;
  int bias ;

  {
#line 143
  sum = 0;
#line 144
  i = 2;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < 16)) {
#line 144
      goto while_break;
    }
#line 145
    m->q_[i] = m->q_[1];
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  i = 0;
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! (i < 16)) {
#line 147
      goto while_break___0;
    }
#line 148
    j = (int )kZigzag[i];
#line 149
    bias = (int )kBiasMatrices[type][j];
#line 150
    m->iq_[j] = (uint16_t )((1 << 17) / (int )m->q_[j]);
#line 151
    m->bias_[j] = (uint16_t )(bias << 9);
#line 153
    m->zthresh_[j] = (uint16_t )(((256 - bias) * (int )m->q_[j] + 127) >> 8);
#line 154
    m->sharpen_[j] = (uint16_t )((int )kFreqSharpening[j] * (int )m->q_[j] >> 11);
#line 155
    sum += (int )m->q_[j];
#line 147
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 157
  return ((sum + 8) >> 4);
}
}
#line 160 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void SetupMatrices(VP8Encoder *enc ) 
{ 
  int i ;
  int tlambda_scale ;
  int tmp ;
  int num_segments ;
  VP8SegmentInfo *m ;
  int q ;
  int q4 ;
  int q16 ;
  int quv ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 162
  if (enc->method_ >= 4) {
#line 162
    tmp = (enc->config_)->sns_strength;
  } else {
#line 162
    tmp = 0;
  }
#line 162
  tlambda_scale = tmp;
#line 165
  num_segments = enc->segment_hdr_.num_segments_;
#line 166
  i = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i < num_segments)) {
#line 166
      goto while_break;
    }
    {
#line 167
    m = & enc->dqm_[i];
#line 168
    q = m->quant_;
#line 170
    __cil_tmp11 = clip(q + enc->dq_y1_dc_, 0, 127);
#line 170
    m->y1_.q_[0] = (uint16_t )kDcTable[__cil_tmp11];
#line 171
    m->y1_.q_[1] = (uint16_t )clip(q, 0, 127);
#line 173
    __cil_tmp13 = clip(q + enc->dq_y2_dc_, 0, 127);
#line 173
    m->y2_.q_[0] = (uint16_t )((int )kDcTable[__cil_tmp13] * 2);
#line 174
    m->y2_.q_[1] = (uint16_t )clip(q + enc->dq_y2_ac_, 0, 127);
#line 176
    __cil_tmp15 = clip(q + enc->dq_uv_dc_, 0, 117);
#line 176
    m->uv_.q_[0] = (uint16_t )kDcTable[__cil_tmp15];
#line 177
    m->uv_.q_[1] = (uint16_t )clip(q + enc->dq_uv_ac_, 0, 127);
#line 179
    q4 = ExpandMatrix(& m->y1_, 0);
#line 180
    q16 = ExpandMatrix(& m->y2_, 1);
#line 181
    quv = ExpandMatrix(& m->uv_, 2);
#line 185
    m->lambda_i4_ = (3 * q4) * q4 >> 7;
#line 186
    m->lambda_i16_ = (3 * q16) * q16;
#line 187
    m->lambda_uv_ = (3 * quv) * quv >> 6;
#line 188
    m->lambda_mode_ = q4 * q4 >> 7;
#line 189
    m->lambda_trellis_i4_ = (7 * q4) * q4 >> 3;
#line 190
    m->lambda_trellis_i16_ = q16 * q16 >> 2;
#line 191
    m->lambda_trellis_uv_ = quv * quv << 1;
#line 192
    m->tlambda_ = tlambda_scale * q4 >> 5;
    }
#line 166
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 204 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void SetupFilterStrength(VP8Encoder *enc ) 
{ 
  int i ;
  int level0 ;
  int level ;
  int f ;
  int tmp ;
  int tmp___0 ;

  {
#line 206
  level0 = (enc->config_)->filter_strength;
#line 207
  i = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (i < 4)) {
#line 207
      goto while_break;
    }
#line 209
    level = ((level0 * 256) * enc->dqm_[i].quant_) / 128;
#line 210
    f = level / (256 + enc->dqm_[i].beta_);
#line 211
    if (f < 3) {
#line 211
      tmp___0 = 0;
    } else {
#line 211
      if (f > 63) {
#line 211
        tmp = 63;
      } else {
#line 211
        tmp = f;
      }
#line 211
      tmp___0 = tmp;
    }
#line 211
    enc->dqm_[i].fstrength_ = tmp___0;
#line 207
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  enc->filter_hdr_.level_ = enc->dqm_[0].fstrength_;
#line 215
  enc->filter_hdr_.simple_ = (enc->config_)->filter_type == 0;
#line 216
  enc->filter_hdr_.sharpness_ = (enc->config_)->filter_sharpness;
  return;
}
}
#line 229 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static double QualityToCompression(double c ) 
{ 
  double linear_c ;
  double tmp ;
  double v ;
  double __cil_tmp5 ;

  {
#line 230
  if (c < 0.75) {
#line 230
    tmp = c * (2. / 3.);
  } else {
#line 230
    tmp = 2. * c - 1.;
  }
  {
#line 230
  linear_c = tmp;
#line 237
  __cil_tmp5 = pow(linear_c, (double )1 / 3.);
#line 237
  v = __cil_tmp5;
  }
#line 238
  return (v);
}
}
#line 241 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static double QualityToJPEGCompression(double c , double alpha ) 
{ 
  double amin ;
  double amax ;
  double exp_min ;
  double exp_max ;
  double slope ;
  double expn ;
  double tmp ;
  double tmp___0 ;
  double v ;
  double __cil_tmp12 ;

  {
#line 246
  amin = 0.3;
#line 247
  amax = 0.85;
#line 248
  exp_min = 0.400000000001;
#line 249
  exp_max = 0.900000000001;
#line 250
  slope = (exp_min - exp_max) / (amax - amin);
#line 253
  if (alpha > amax) {
#line 253
    tmp___0 = exp_min;
  } else {
#line 253
    if (alpha < amin) {
#line 253
      tmp = exp_max;
    } else {
#line 253
      tmp = exp_max + slope * (alpha - amin);
    }
#line 253
    tmp___0 = tmp;
  }
  {
#line 253
  expn = tmp___0;
#line 256
  __cil_tmp12 = pow(c, expn);
#line 256
  v = __cil_tmp12;
  }
#line 257
  return (v);
}
}
#line 260 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static int SegmentsAreEquivalent(VP8SegmentInfo *S1 , VP8SegmentInfo *S2 ) 
{ 


  {
#line 262
  return (S1->quant_ == S2->quant_ && S1->fstrength_ == S2->fstrength_);
}
}
#line 265 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void SimplifySegments(VP8Encoder *enc ) 
{ 
  int map[4] ;
  int num_segments ;
  int num_final_segments ;
  int s1 ;
  int s2 ;
  VP8SegmentInfo *S1 ;
  int found ;
  VP8SegmentInfo *S2 ;
  int __cil_tmp10 ;
  int i ;
  int __cil_tmp12 ;

  {
#line 266
  map[0] = 0;
#line 266
  map[1] = 1;
#line 266
  map[2] = 2;
#line 266
  map[3] = 3;
#line 267
  num_segments = enc->segment_hdr_.num_segments_;
#line 268
  num_final_segments = 1;
#line 270
  s1 = 1;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (s1 < num_segments)) {
#line 270
      goto while_break;
    }
#line 271
    S1 = & enc->dqm_[s1];
#line 272
    found = 0;
#line 274
    s2 = 0;
    {
#line 274
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 274
      if (! (s2 < num_final_segments)) {
#line 274
        goto while_break___0;
      }
      {
#line 275
      S2 = & enc->dqm_[s2];
#line 276
      __cil_tmp10 = SegmentsAreEquivalent(S1, S2);
      }
#line 276
      if (__cil_tmp10) {
#line 277
        found = 1;
#line 278
        goto while_break___0;
      }
#line 274
      s2 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 281
    map[s1] = s2;
#line 282
    if (! found) {
#line 283
      if (num_final_segments != s1) {
#line 284
        enc->dqm_[num_final_segments] = enc->dqm_[s1];
      }
#line 286
      num_final_segments ++;
    }
#line 270
    s1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  if (num_final_segments < num_segments) {
#line 290
    i = enc->mb_w_ * enc->mb_h_;
    {
#line 291
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 291
      __cil_tmp12 = i;
#line 291
      i --;
#line 291
      if (! (__cil_tmp12 > 0)) {
#line 291
        goto while_break___1;
      }
#line 291
      (enc->mb_info_ + i)->segment_ = (unsigned int )map[(enc->mb_info_ + i)->segment_];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 292
    enc->segment_hdr_.num_segments_ = num_final_segments;
#line 294
    i = num_final_segments;
    {
#line 294
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 294
      if (! (i < num_segments)) {
#line 294
        goto while_break___2;
      }
#line 295
      enc->dqm_[i] = enc->dqm_[num_final_segments - 1];
#line 294
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 300 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
void VP8SetSegmentParams(VP8Encoder *enc , float quality ) 
{ 
  int i ;
  int dq_uv_ac ;
  int dq_uv_dc ;
  int num_segments ;
  double amp ;
  double Q ;
  double c_base ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  double tmp ;
  double expn ;
  double c ;
  double __cil_tmp15 ;
  int q ;
  int tmp___0 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 303
  num_segments = enc->segment_hdr_.num_segments_;
#line 304
  amp = ((0.900000000001 * (double )(enc->config_)->sns_strength) / 100.) / 128.;
#line 305
  Q = (double )quality / 100.;
#line 306
  if ((enc->config_)->emulate_jpeg_size) {
    {
#line 306
    __cil_tmp10 = QualityToJPEGCompression(Q, (double )enc->alpha_ / 255.);
#line 306
    tmp = __cil_tmp10;
    }
  } else {
    {
#line 306
    __cil_tmp11 = QualityToCompression(Q);
#line 306
    tmp = __cil_tmp11;
    }
  }
#line 306
  c_base = tmp;
#line 309
  i = 0;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i < num_segments)) {
#line 309
      goto while_break;
    }
    {
#line 312
    expn = 1. - amp * (double )enc->dqm_[i].alpha_;
#line 313
    __cil_tmp15 = pow(c_base, expn);
#line 313
    c = __cil_tmp15;
#line 314
    q = (int )(127. * (1. - c));
#line 316
    enc->dqm_[i].quant_ = clip(q, 0, 127);
    }
#line 309
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  enc->base_quant_ = enc->dqm_[0].quant_;
#line 323
  i = num_segments;
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    if (! (i < 4)) {
#line 323
      goto while_break___0;
    }
#line 324
    enc->dqm_[i].quant_ = enc->base_quant_;
#line 323
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 330
  dq_uv_ac = ((enc->uv_alpha_ - 64) * 10) / 70;
#line 333
  dq_uv_ac = (dq_uv_ac * (enc->config_)->sns_strength) / 100;
#line 335
  dq_uv_ac = clip(dq_uv_ac, - 4, 6);
#line 339
  dq_uv_dc = (-4 * (enc->config_)->sns_strength) / 100;
#line 340
  dq_uv_dc = clip(dq_uv_dc, - 15, 15);
#line 342
  enc->dq_y1_dc_ = 0;
#line 343
  enc->dq_y2_dc_ = 0;
#line 344
  enc->dq_y2_ac_ = 0;
#line 345
  enc->dq_uv_dc_ = dq_uv_dc;
#line 346
  enc->dq_uv_ac_ = dq_uv_ac;
#line 348
  SetupFilterStrength(enc);
  }
#line 350
  if (num_segments > 1) {
    {
#line 350
    SimplifySegments(enc);
    }
  }
  {
#line 352
  SetupMatrices(enc);
  }
  return;
}
}
#line 359 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
int const   VP8I16ModeOffsets[4]  = {      0,      256,      512,      768};
#line 360 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
int const   VP8UVModeOffsets[4]  = {      1024,      1152,      1280,      1408};
#line 363 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
int const   VP8I4ModeOffsets[10]  = 
#line 363
  {      1536,      1540,      1544,      1548, 
        1600,      1604,      1608,      1612, 
        1664,      1668};
#line 367 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
void VP8MakeLuma16Preds(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  uint8_t *left ;
  uint8_t *tmp ;
  uint8_t *top ;
  uint8_t *tmp___0 ;

  {
#line 368
  enc = it->enc_;
#line 369
  if (it->x_) {
#line 369
    tmp = enc->y_left_;
  } else {
#line 369
    tmp = (uint8_t *)((void *)0);
  }
#line 369
  left = tmp;
#line 370
  if (it->y_) {
#line 370
    tmp___0 = enc->y_top_ + it->x_ * 16;
  } else {
#line 370
    tmp___0 = (uint8_t *)((void *)0);
  }
  {
#line 370
  top = tmp___0;
#line 371
  (*VP8EncPredLuma16)(it->yuv_p_, left, top);
  }
  return;
}
}
#line 374 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
void VP8MakeChroma8Preds(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  uint8_t *left ;
  uint8_t *tmp ;
  uint8_t *top ;
  uint8_t *tmp___0 ;

  {
#line 375
  enc = it->enc_;
#line 376
  if (it->x_) {
#line 376
    tmp = enc->u_left_;
  } else {
#line 376
    tmp = (uint8_t *)((void *)0);
  }
#line 376
  left = tmp;
#line 377
  if (it->y_) {
#line 377
    tmp___0 = enc->uv_top_ + it->x_ * 16;
  } else {
#line 377
    tmp___0 = (uint8_t *)((void *)0);
  }
  {
#line 377
  top = tmp___0;
#line 378
  (*VP8EncPredChroma8)(it->yuv_p_, left, top);
  }
  return;
}
}
#line 381 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
void VP8MakeIntra4Preds(VP8EncIterator *it ) 
{ 


  {
  {
#line 382
  (*VP8EncPredLuma4)(it->yuv_p_, it->i4_top_);
  }
  return;
}
}
#line 399 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
int const   VP8Scan[24]  = 
#line 399
  {      0,      4,      8,      12, 
        64,      68,      72,      76, 
        128,      132,      136,      140, 
        192,      196,      200,      204, 
        0,      4,      64,      68, 
        8,      12,      72,      76};
#line 413 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint16_t kWeightY[16]  = 
#line 413
  {      (uint16_t )38,      (uint16_t )32,      (uint16_t )20,      (uint16_t )9, 
        (uint16_t )32,      (uint16_t )28,      (uint16_t )17,      (uint16_t )7, 
        (uint16_t )20,      (uint16_t )17,      (uint16_t )10,      (uint16_t )4, 
        (uint16_t )9,      (uint16_t )7,      (uint16_t )4,      (uint16_t )2};
#line 417 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint16_t kWeightTrellis[16]  = 
#line 417
  {      (uint16_t )30,      (uint16_t )27,      (uint16_t )19,      (uint16_t )11, 
        (uint16_t )27,      (uint16_t )24,      (uint16_t )17,      (uint16_t )10, 
        (uint16_t )19,      (uint16_t )17,      (uint16_t )12,      (uint16_t )8, 
        (uint16_t )11,      (uint16_t )10,      (uint16_t )8,      (uint16_t )6};
#line 429 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void InitScore(VP8ModeScore *rd ) 
{ 


  {
#line 430
  rd->D = (score_t )0;
#line 431
  rd->SD = (score_t )0;
#line 432
  rd->R = (score_t )0;
#line 433
  rd->nz = (uint32_t )0;
#line 434
  rd->score = (score_t )36028797018963967LL;
  return;
}
}
#line 437 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void CopyScore(VP8ModeScore *dst , VP8ModeScore *src ) 
{ 


  {
#line 438
  dst->D = src->D;
#line 439
  dst->SD = src->SD;
#line 440
  dst->R = src->R;
#line 441
  dst->nz = src->nz;
#line 442
  dst->score = src->score;
  return;
}
}
#line 445 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void AddScore(VP8ModeScore *dst , VP8ModeScore *src ) 
{ 


  {
#line 446
  dst->D += src->D;
#line 447
  dst->SD += src->SD;
#line 448
  dst->R += src->R;
#line 449
  dst->nz |= src->nz;
#line 450
  dst->score += src->score;
  return;
}
}
#line 475 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
__inline static void SetRDScore(int lambda , VP8ModeScore *rd ) 
{ 


  {
#line 477
  rd->score = rd->R * (long )lambda + 256L * (rd->D + rd->SD);
  return;
}
}
#line 480 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
__inline static score_t RDScoreTrellis(int lambda , score_t rate , score_t distortion ) 
{ 


  {
#line 482
  return (rate * (long )lambda + 256L * distortion);
}
}
#line 485 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static int TrellisQuantizeBlock(VP8EncIterator *it , int16_t in[16] , int16_t out[16] ,
                                int ctx0 , int coeff_type , VP8Matrix *mtx , int lambda ) 
{ 
  ProbaArray *last_costs ;
  CostArray *costs ;
  int first ;
  int tmp ;
  Node nodes[17][2] ;
  int best_path[3] ;
  score_t best_score ;
  int best_node ;
  int last ;
  int n ;
  int m ;
  int p ;
  int nz ;
  score_t cost ;
  score_t max_error ;
  int thresh ;
  int last_proba ;
  int j ;
  int err ;
  int __cil_tmp27 ;
  score_t __cil_tmp28 ;
  int j___0 ;
  int Q ;
  int iQ ;
  int B ;
  int sign ;
  int coeff0 ;
  int tmp___0 ;
  int level0 ;
  int __cil_tmp37 ;
  Node *cur ;
  int delta_error ;
  int new_error ;
  score_t cur_score ;
  int level ;
  int last_proba___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Node *prev ;
  int prev_ctx ;
  uint16_t *tcost ;
  score_t total_error ;
  score_t cost___0 ;
  score_t base_cost ;
  score_t score ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  score_t __cil_tmp55 ;
  int __cil_tmp56 ;
  score_t __cil_tmp57 ;
  Node *node ;
  int j___1 ;
  int tmp___3 ;

  {
#line 490
  last_costs = (ProbaArray *)(it->enc_)->proba_.coeffs_[coeff_type];
#line 491
  costs = (CostArray *)(it->enc_)->proba_.level_cost_[coeff_type];
#line 492
  if (coeff_type == 0) {
#line 492
    tmp = 1;
  } else {
#line 492
    tmp = 0;
  }
#line 492
  first = tmp;
#line 494
  best_path[0] = - 1;
#line 494
  best_path[1] = - 1;
#line 494
  best_path[2] = - 1;
#line 497
  last = first - 1;
#line 503
  thresh = ((int )mtx->q_[1] * (int )mtx->q_[1]) / 4;
#line 504
  last_proba = (int )(*(last_costs + VP8EncBands[first]))[ctx0][0];
#line 507
  max_error = (score_t )0;
#line 508
  n = first;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! (n < 16)) {
#line 508
      goto while_break;
    }
#line 509
    j = (int )kZigzag[n];
#line 510
    err = (int )in[j] * (int )in[j];
#line 511
    max_error += (long )((int )kWeightTrellis[j] * err);
#line 512
    if (err > thresh) {
#line 512
      last = n;
    }
#line 508
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 516
  if (last < 15) {
#line 516
    last ++;
  }
  {
#line 519
  __cil_tmp27 = VP8BitCost(0, (uint8_t )last_proba);
#line 519
  cost = (score_t )__cil_tmp27;
#line 520
  best_score = RDScoreTrellis(lambda, cost, max_error);
#line 523
  n = first - 1;
#line 524
  m = - 0;
  }
  {
#line 524
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 524
    if (! (m <= 1)) {
#line 524
      goto while_break___0;
    }
#line 525
    nodes[n + 1][m].cost = (score_t )0;
#line 526
    nodes[n + 1][m].error = max_error;
#line 527
    nodes[n + 1][m].ctx = ctx0;
#line 524
    m ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 532
  n = first;
  {
#line 532
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 532
    if (! (n <= last)) {
#line 532
      goto while_break___1;
    }
#line 533
    j___0 = (int )kZigzag[n];
#line 534
    Q = (int )mtx->q_[j___0];
#line 535
    iQ = (int )mtx->iq_[j___0];
#line 536
    B = 0;
#line 539
    sign = (int )in[j___0] < 0;
#line 540
    if (sign) {
#line 540
      tmp___0 = - ((int )in[j___0]);
    } else {
#line 540
      tmp___0 = (int )in[j___0];
    }
#line 540
    coeff0 = tmp___0 + (int )mtx->sharpen_[j___0];
#line 542
    if (coeff0 > 2047) {
#line 542
      coeff0 = 2047;
    }
    {
#line 544
    level0 = QUANTDIV(coeff0, iQ, B);
#line 546
    m = - 0;
    }
    {
#line 546
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 546
      if (! (m <= 1)) {
#line 546
        goto while_break___2;
      }
#line 547
      cur = & nodes[n + 1][m];
#line 549
      cur_score = (score_t )36028797018963967LL;
#line 550
      level = level0 + m;
#line 553
      cur->sign = sign;
#line 554
      cur->level = level;
#line 555
      if (level == 0) {
#line 555
        tmp___2 = 0;
      } else {
#line 555
        if (level == 1) {
#line 555
          tmp___1 = 1;
        } else {
#line 555
          tmp___1 = 2;
        }
#line 555
        tmp___2 = tmp___1;
      }
#line 555
      cur->ctx = tmp___2;
#line 556
      if (level >= 2048) {
#line 557
        cur->cost = (score_t )36028797018963967LL;
#line 558
        goto while_continue___2;
      } else
#line 556
      if (level < 0) {
#line 557
        cur->cost = (score_t )36028797018963967LL;
#line 558
        goto while_continue___2;
      }
#line 560
      last_proba___0 = (int )(*(last_costs + VP8EncBands[n + 1]))[cur->ctx][0];
#line 564
      new_error = coeff0 - level * Q;
#line 565
      delta_error = (int )kWeightTrellis[j___0] * (coeff0 * coeff0 - new_error * new_error);
#line 569
      p = - 0;
      {
#line 569
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 569
        if (! (p <= 1)) {
#line 569
          goto while_break___3;
        }
#line 570
        prev = & nodes[(n - 1) + 1][p];
#line 571
        prev_ctx = prev->ctx;
#line 572
        tcost = (uint16_t *)(*(costs + VP8EncBands[n]))[prev_ctx];
#line 573
        total_error = prev->error - (long )delta_error;
#line 576
        if (prev->cost >= 36028797018963967L) {
#line 577
          goto while_continue___3;
        }
        {
#line 581
        __cil_tmp53 = VP8LevelCost(tcost, level);
#line 581
        base_cost = prev->cost + (long )__cil_tmp53;
#line 584
        cost___0 = base_cost;
        }
#line 585
        if (level) {
#line 585
          if (n < 15) {
            {
#line 586
            __cil_tmp54 = VP8BitCost(1, (uint8_t )last_proba___0);
            }
#line 586
            cost___0 += (long )__cil_tmp54;
          }
        }
        {
#line 588
        score = RDScoreTrellis(lambda, cost___0, total_error);
        }
#line 589
        if (score < cur_score) {
#line 590
          cur_score = score;
#line 591
          cur->cost = cost___0;
#line 592
          cur->error = total_error;
#line 593
          cur->prev = p;
        }
#line 597
        if (level) {
#line 598
          cost___0 = base_cost;
#line 599
          if (n < 15) {
            {
#line 599
            __cil_tmp56 = VP8BitCost(0, (uint8_t )last_proba___0);
            }
#line 599
            cost___0 += (long )__cil_tmp56;
          }
          {
#line 600
          score = RDScoreTrellis(lambda, cost___0, total_error);
          }
#line 601
          if (score < best_score) {
#line 602
            best_score = score;
#line 603
            best_path[0] = n;
#line 604
            best_path[1] = m;
#line 605
            best_path[2] = p;
          }
        }
#line 569
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 546
      m ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 532
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 613
  memset(in + first, 0, (unsigned long )(16 - first) * sizeof(in[0]));
#line 614
  memset(out + first, 0, (unsigned long )(16 - first) * sizeof(out[0]));
  }
#line 615
  if (best_path[0] == -1) {
#line 616
    return (0);
  }
#line 622
  n = best_path[0];
#line 623
  best_node = best_path[1];
#line 624
  nodes[n + 1][best_node].prev = best_path[2];
#line 625
  nz = 0;
  {
#line 627
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 627
    if (! (n >= first)) {
#line 627
      goto while_break___4;
    }
#line 628
    node = & nodes[n + 1][best_node];
#line 629
    j___1 = (int )kZigzag[n];
#line 630
    if (node->sign) {
#line 630
      tmp___3 = - node->level;
    } else {
#line 630
      tmp___3 = node->level;
    }
#line 630
    out[n] = (int16_t )tmp___3;
#line 631
    nz |= node->level != 0;
#line 632
    in[j___1] = (int16_t )((int )out[n] * (int )mtx->q_[j___1]);
#line 633
    best_node = node->prev;
#line 627
    n --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 635
  return (nz);
}
}
#line 645 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static int ReconstructIntra16(VP8EncIterator *it , VP8ModeScore *rd , uint8_t *yuv_out ,
                              int mode ) 
{ 
  VP8Encoder *enc ;
  uint8_t *ref ;
  uint8_t *src ;
  VP8SegmentInfo *dqm ;
  int nz ;
  int n ;
  int16_t tmp[16][16] ;
  int16_t dc_tmp[16] ;
  int __cil_tmp13 ;
  int x ;
  int y ;
  int ctx ;
  int non_zero ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 649
  enc = it->enc_;
#line 650
  ref = it->yuv_p_ + VP8I16ModeOffsets[mode];
#line 651
  src = it->yuv_in_ + 0;
#line 652
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 653
  nz = 0;
#line 657
  n = 0;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! (n < 16)) {
#line 657
      goto while_break;
    }
    {
#line 658
    (*VP8FTransform)(src + VP8Scan[n], ref + VP8Scan[n], (int16_t *)tmp[n]);
    }
#line 657
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 660
  (*VP8FTransformWHT)((int16_t *)tmp[0], (int16_t *)dc_tmp);
#line 661
  __cil_tmp13 = (*VP8EncQuantizeBlock)((int16_t *)dc_tmp, (int16_t *)rd->y_dc_levels,
                                       0, & dqm->y2_);
  }
#line 661
  nz |= __cil_tmp13 << 24;
#line 663
  if (it->do_trellis_) {
    {
#line 665
    VP8IteratorNzToBytes(it);
#line 666
    n = 0;
    }
#line 666
    y = 0;
    {
#line 666
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 666
      if (! (y < 4)) {
#line 666
        goto while_break___0;
      }
#line 667
      x = 0;
      {
#line 667
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 667
        if (! (x < 4)) {
#line 667
          goto while_break___1;
        }
        {
#line 668
        ctx = it->top_nz_[x] + it->left_nz_[y];
#line 669
        __cil_tmp18 = TrellisQuantizeBlock(it, (int16_t *)tmp[n], (int16_t *)rd->y_ac_levels[n],
                                           ctx, 0, & dqm->y1_, dqm->lambda_trellis_i16_);
#line 669
        non_zero = __cil_tmp18;
#line 672
        it->left_nz_[y] = non_zero;
#line 672
        it->top_nz_[x] = it->left_nz_[y];
#line 673
        nz |= non_zero << n;
        }
#line 667
        n ++;
#line 667
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 666
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 677
    n = 0;
    {
#line 677
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 677
      if (! (n < 16)) {
#line 677
        goto while_break___2;
      }
      {
#line 678
      __cil_tmp19 = (*VP8EncQuantizeBlock)((int16_t *)tmp[n], (int16_t *)rd->y_ac_levels[n],
                                           1, & dqm->y1_);
      }
#line 678
      nz |= __cil_tmp19 << n;
#line 677
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 683
  (*VP8ITransformWHT)((int16_t *)dc_tmp, (int16_t *)tmp[0]);
#line 684
  n = 0;
  }
  {
#line 684
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 684
    if (! (n < 16)) {
#line 684
      goto while_break___3;
    }
    {
#line 685
    (*VP8ITransform)(ref + VP8Scan[n], (int16_t *)tmp[n], yuv_out + VP8Scan[n], 1);
    }
#line 684
    n += 2;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 688
  return (nz);
}
}
#line 691 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static int ReconstructIntra4(VP8EncIterator *it , int16_t levels[16] , uint8_t *src ,
                             uint8_t *yuv_out , int mode ) 
{ 
  VP8Encoder *enc ;
  uint8_t *ref ;
  VP8SegmentInfo *dqm ;
  int nz ;
  int16_t tmp[16] ;
  int x ;
  int y ;
  int ctx ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 696
  enc = it->enc_;
#line 697
  ref = it->yuv_p_ + VP8I4ModeOffsets[mode];
#line 698
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 699
  nz = 0;
#line 702
  (*VP8FTransform)(src, ref, (int16_t *)tmp);
  }
#line 703
  if (it->do_trellis_) {
#line 704
    x = it->i4_ & 3;
    {
#line 704
    y = it->i4_ >> 2;
#line 705
    ctx = it->top_nz_[x] + it->left_nz_[y];
#line 706
    nz = TrellisQuantizeBlock(it, (int16_t *)tmp, levels, ctx, 3, & dqm->y1_, dqm->lambda_trellis_i4_);
    }
  } else {
    {
#line 709
    nz = (*VP8EncQuantizeBlock)((int16_t *)tmp, levels, 0, & dqm->y1_);
    }
  }
  {
#line 711
  (*VP8ITransform)(ref, (int16_t *)tmp, yuv_out, 0);
  }
#line 712
  return (nz);
}
}
#line 715 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static int ReconstructUV(VP8EncIterator *it , VP8ModeScore *rd , uint8_t *yuv_out ,
                         int mode ) 
{ 
  VP8Encoder *enc ;
  uint8_t *ref ;
  uint8_t *src ;
  VP8SegmentInfo *dqm ;
  int nz ;
  int n ;
  int16_t tmp[8][16] ;
  int ch ;
  int x ;
  int y ;
  int ctx ;
  int non_zero ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 717
  enc = it->enc_;
#line 718
  ref = it->yuv_p_ + VP8UVModeOffsets[mode];
#line 719
  src = it->yuv_in_ + 256;
#line 720
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 721
  nz = 0;
#line 725
  n = 0;
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    if (! (n < 8)) {
#line 725
      goto while_break;
    }
    {
#line 726
    (*VP8FTransform)(src + VP8Scan[16 + n], ref + VP8Scan[16 + n], (int16_t *)tmp[n]);
    }
#line 725
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  if (0) {
#line 730
    n = 0;
#line 730
    ch = 0;
    {
#line 730
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 730
      if (! (ch <= 2)) {
#line 730
        goto while_break___0;
      }
#line 731
      y = 0;
      {
#line 731
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 731
        if (! (y < 2)) {
#line 731
          goto while_break___1;
        }
#line 732
        x = 0;
        {
#line 732
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 732
          if (! (x < 2)) {
#line 732
            goto while_break___2;
          }
          {
#line 733
          ctx = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 734
          __cil_tmp17 = TrellisQuantizeBlock(it, (int16_t *)tmp[n], (int16_t *)rd->uv_levels[n],
                                             ctx, 2, & dqm->uv_, dqm->lambda_trellis_uv_);
#line 734
          non_zero = __cil_tmp17;
#line 737
          it->left_nz_[(4 + ch) + y] = non_zero;
#line 737
          it->top_nz_[(4 + ch) + x] = it->left_nz_[(4 + ch) + y];
#line 738
          nz |= non_zero << n;
          }
#line 732
          n ++;
#line 732
          x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 731
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 730
      ch += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 743
    n = 0;
    {
#line 743
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 743
      if (! (n < 8)) {
#line 743
        goto while_break___3;
      }
      {
#line 744
      __cil_tmp18 = (*VP8EncQuantizeBlock)((int16_t *)tmp[n], (int16_t *)rd->uv_levels[n],
                                           0, & dqm->uv_);
      }
#line 744
      nz |= __cil_tmp18 << n;
#line 743
      n ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 748
  n = 0;
  {
#line 748
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 748
    if (! (n < 8)) {
#line 748
      goto while_break___4;
    }
    {
#line 749
    (*VP8ITransform)(ref + VP8Scan[16 + n], (int16_t *)tmp[n], yuv_out + VP8Scan[16 + n],
                     1);
    }
#line 748
    n += 2;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 751
  return (nz << 16);
}
}
#line 758 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void SwapPtr(uint8_t **a , uint8_t **b ) 
{ 
  uint8_t *tmp ;

  {
#line 759
  tmp = *a;
#line 760
  *a = *b;
#line 761
  *b = tmp;
  return;
}
}
#line 764 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void SwapOut(VP8EncIterator *it ) 
{ 


  {
  {
#line 765
  SwapPtr(& it->yuv_out_, & it->yuv_out2_);
  }
  return;
}
}
#line 768 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void PickBestIntra16(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  VP8SegmentInfo *dqm ;
  int lambda ;
  int tlambda ;
  uint8_t *src ;
  VP8ModeScore rd16 ;
  int mode ;
  uint8_t *tmp_dst ;
  int nz ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;

  {
#line 769
  enc = it->enc_;
#line 770
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 771
  lambda = dqm->lambda_i16_;
#line 772
  tlambda = dqm->tlambda_;
#line 773
  src = it->yuv_in_ + 0;
#line 777
  rd->mode_i16 = - 1;
#line 778
  mode = 0;
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 778
    if (! (mode < 4)) {
#line 778
      goto while_break;
    }
    {
#line 779
    tmp_dst = it->yuv_out2_ + 0;
#line 783
    nz = ReconstructIntra16(it, & rd16, tmp_dst, mode);
#line 786
    __cil_tmp13 = (*VP8SSE16x16)(src, tmp_dst);
#line 786
    rd16.D = (score_t )__cil_tmp13;
    }
#line 787
    if (tlambda) {
      {
#line 787
      __cil_tmp14 = (*VP8TDisto16x16)(src, tmp_dst, (uint16_t *)kWeightY);
#line 787
      tmp = (tlambda * __cil_tmp14 + 128) >> 8;
      }
    } else {
#line 787
      tmp = 0;
    }
    {
#line 787
    rd16.SD = (score_t )tmp;
#line 789
    __cil_tmp16 = VP8GetCostLuma16(it, & rd16);
#line 789
    rd16.R = (score_t )__cil_tmp16;
#line 790
    rd16.R += (long )VP8FixedCostsI16[mode];
#line 793
    SetRDScore(lambda, & rd16);
    }
#line 794
    if (mode == 0) {
      _L: /* CIL Label */ 
      {
#line 795
      CopyScore(rd, & rd16);
#line 796
      rd->mode_i16 = mode;
#line 797
      rd->nz = (uint32_t )nz;
#line 798
      memcpy((int16_t (*)[16])rd->y_ac_levels, (int16_t (*)[16])rd16.y_ac_levels,
             sizeof(rd16.y_ac_levels));
#line 799
      memcpy((int16_t *)rd->y_dc_levels, (int16_t *)rd16.y_dc_levels, sizeof(rd16.y_dc_levels));
#line 800
      SwapOut(it);
      }
    } else
#line 794
    if (rd16.score < rd->score) {
#line 794
      goto _L;
    }
#line 778
    mode ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 803
  SetRDScore(dqm->lambda_mode_, rd);
#line 804
  VP8SetIntra16Mode(it, rd->mode_i16);
  }
  return;
}
}
#line 810 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static uint16_t *GetCostModeI4(VP8EncIterator *it , uint8_t modes[16] ) 
{ 
  int preds_w ;
  int x ;
  int y ;
  int left ;
  int tmp ;
  int top ;
  int tmp___0 ;

  {
#line 812
  preds_w = (it->enc_)->preds_w_;
#line 813
  x = it->i4_ & 3;
#line 813
  y = it->i4_ >> 2;
#line 814
  if (x == 0) {
#line 814
    tmp = (int )*(it->preds_ + (y * preds_w - 1));
  } else {
#line 814
    tmp = (int )modes[it->i4_ - 1];
  }
#line 814
  left = tmp;
#line 815
  if (y == 0) {
#line 815
    tmp___0 = (int )*(it->preds_ + (- preds_w + x));
  } else {
#line 815
    tmp___0 = (int )modes[it->i4_ - 4];
  }
#line 815
  top = tmp___0;
#line 816
  return ((uint16_t *)VP8FixedCostsI4[top][left]);
}
}
#line 819 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static int PickBestIntra4(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  VP8SegmentInfo *dqm ;
  int lambda ;
  int tlambda ;
  uint8_t *src0 ;
  uint8_t *best_blocks ;
  int total_header_bits ;
  VP8ModeScore rd_best ;
  int __cil_tmp11 ;
  VP8ModeScore rd_i4 ;
  int mode ;
  int best_mode ;
  uint8_t *src ;
  uint16_t *mode_costs ;
  uint16_t *__cil_tmp17 ;
  uint8_t *best_block ;
  uint8_t *tmp_dst ;
  VP8ModeScore rd_tmp ;
  int16_t tmp_levels[16] ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int tmp ;
  int __cil_tmp26 ;
  int tmp___0 ;

  {
#line 820
  enc = it->enc_;
#line 821
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 822
  lambda = dqm->lambda_i4_;
#line 823
  tlambda = dqm->tlambda_;
#line 824
  src0 = it->yuv_in_ + 0;
#line 825
  best_blocks = it->yuv_out2_ + 0;
#line 826
  total_header_bits = 0;
#line 829
  if (enc->max_i4_header_bits_ == 0) {
#line 830
    return (0);
  }
  {
#line 833
  InitScore(& rd_best);
#line 834
  rd_best.score = (score_t )211;
#line 835
  VP8IteratorStartI4(it);
  }
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 839
    best_mode = - 1;
#line 840
    src = src0 + VP8Scan[it->i4_];
#line 841
    __cil_tmp17 = GetCostModeI4(it, (uint8_t [16])((uint8_t *)rd->modes_i4));
#line 841
    mode_costs = __cil_tmp17;
#line 842
    best_block = best_blocks + VP8Scan[it->i4_];
#line 843
    tmp_dst = it->yuv_p_ + 1672;
#line 845
    InitScore(& rd_i4);
#line 846
    VP8MakeIntra4Preds(it);
#line 847
    mode = 0;
    }
    {
#line 847
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 847
      if (! (mode < 10)) {
#line 847
        goto while_break___0;
      }
      {
#line 852
      __cil_tmp22 = ReconstructIntra4(it, (int16_t *)tmp_levels, src, tmp_dst, mode);
#line 852
      rd_tmp.nz = (uint32_t )(__cil_tmp22 << it->i4_);
#line 856
      __cil_tmp23 = (*VP8SSE4x4)(src, tmp_dst);
#line 856
      rd_tmp.D = (score_t )__cil_tmp23;
      }
#line 857
      if (tlambda) {
        {
#line 857
        __cil_tmp24 = (*VP8TDisto4x4)(src, tmp_dst, (uint16_t *)kWeightY);
#line 857
        tmp = (tlambda * __cil_tmp24 + 128) >> 8;
        }
      } else {
#line 857
        tmp = 0;
      }
      {
#line 857
      rd_tmp.SD = (score_t )tmp;
#line 860
      __cil_tmp26 = VP8GetCostLuma4(it, (int16_t [16])((int16_t *)tmp_levels));
#line 860
      rd_tmp.R = (score_t )__cil_tmp26;
#line 861
      rd_tmp.R += (long )*(mode_costs + mode);
#line 863
      SetRDScore(lambda, & rd_tmp);
      }
#line 864
      if (best_mode < 0) {
        {
        {
#line 865
        CopyScore(& rd_i4, & rd_tmp);
        }
#line 866
        best_mode = mode;
        {
#line 867
        SwapPtr(& tmp_dst, & best_block);
        }
        {
#line 868
        memcpy((int16_t *)rd_best.y_ac_levels[it->i4_], (int16_t *)tmp_levels, sizeof(tmp_levels));
        }
        }
      } else
#line 864
      if (rd_tmp.score < rd_i4.score) {
        {
        {
#line 865
        CopyScore(& rd_i4, & rd_tmp);
        }
#line 866
        best_mode = mode;
        {
#line 867
        SwapPtr(& tmp_dst, & best_block);
        }
        {
#line 868
        memcpy((int16_t *)rd_best.y_ac_levels[it->i4_], (int16_t *)tmp_levels, sizeof(tmp_levels));
        }
        }
      }
#line 847
      mode ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 871
    SetRDScore(dqm->lambda_mode_, & rd_i4);
#line 872
    AddScore(& rd_best, & rd_i4);
#line 873
    total_header_bits += (int )*(mode_costs + best_mode);
    }
#line 874
    if (rd_best.score >= rd->score) {
#line 876
      return (0);
    } else
#line 874
    if (total_header_bits > enc->max_i4_header_bits_) {
#line 876
      return (0);
    }
#line 879
    if (best_block != best_blocks + VP8Scan[it->i4_]) {
      {
#line 880
      (*VP8Copy4x4)(best_block, best_blocks + VP8Scan[it->i4_]);
      }
    }
#line 881
    rd->modes_i4[it->i4_] = (uint8_t )best_mode;
#line 882
    if (rd_i4.nz) {
#line 882
      tmp___0 = 1;
    } else {
#line 882
      tmp___0 = 0;
    }
#line 882
    it->left_nz_[it->i4_ >> 2] = tmp___0;
#line 882
    it->top_nz_[it->i4_ & 3] = it->left_nz_[it->i4_ >> 2];
#line 836
    if (! __cil_tmp11) {
#line 836
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 886
  CopyScore(rd, & rd_best);
#line 887
  VP8SetIntra4Mode(it, (uint8_t *)rd->modes_i4);
#line 888
  SwapOut(it);
#line 889
  memcpy((int16_t (*)[16])rd->y_ac_levels, (int16_t (*)[16])rd_best.y_ac_levels, sizeof(rd->y_ac_levels));
  }
#line 890
  return (1);
}
}
#line 895 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void PickBestUV(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  VP8SegmentInfo *dqm ;
  int lambda ;
  uint8_t *src ;
  uint8_t *tmp_dst ;
  uint8_t *dst0 ;
  VP8ModeScore rd_best ;
  int mode ;
  VP8ModeScore rd_uv ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 896
  enc = it->enc_;
#line 897
  dqm = & enc->dqm_[(it->mb_)->segment_];
#line 898
  lambda = dqm->lambda_uv_;
#line 899
  src = it->yuv_in_ + 256;
#line 900
  tmp_dst = it->yuv_out2_ + 256;
#line 901
  dst0 = it->yuv_out_ + 256;
#line 905
  rd->mode_uv = - 1;
#line 906
  InitScore(& rd_best);
#line 907
  mode = 0;
  }
  {
#line 907
  while (1) {
    while_continue: /* CIL Label */ ;
#line 907
    if (! (mode < 4)) {
#line 907
      goto while_break;
    }
    {
#line 911
    __cil_tmp12 = ReconstructUV(it, & rd_uv, tmp_dst, mode);
#line 911
    rd_uv.nz = (uint32_t )__cil_tmp12;
#line 914
    __cil_tmp13 = (*VP8SSE16x8)(src, tmp_dst);
#line 914
    rd_uv.D = (score_t )__cil_tmp13;
#line 915
    rd_uv.SD = (score_t )0;
#line 916
    __cil_tmp14 = VP8GetCostUV(it, & rd_uv);
#line 916
    rd_uv.R = (score_t )__cil_tmp14;
#line 917
    rd_uv.R += (long )VP8FixedCostsUV[mode];
#line 919
    SetRDScore(lambda, & rd_uv);
    }
#line 920
    if (mode == 0) {
      {
      {
#line 921
      CopyScore(& rd_best, & rd_uv);
      }
#line 922
      rd->mode_uv = mode;
      {
#line 923
      memcpy((int16_t (*)[16])rd->uv_levels, (int16_t (*)[16])rd_uv.uv_levels, sizeof(rd->uv_levels));
      }
      {
#line 924
      memcpy(dst0, tmp_dst, (unsigned long )128);
      }
      }
    } else
#line 920
    if (rd_uv.score < rd_best.score) {
      {
      {
#line 921
      CopyScore(& rd_best, & rd_uv);
      }
#line 922
      rd->mode_uv = mode;
      {
#line 923
      memcpy((int16_t (*)[16])rd->uv_levels, (int16_t (*)[16])rd_uv.uv_levels, sizeof(rd->uv_levels));
      }
      {
#line 924
      memcpy(dst0, tmp_dst, (unsigned long )128);
      }
      }
    }
#line 907
    mode ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 927
  VP8SetIntraUVMode(it, rd->mode_uv);
#line 928
  AddScore(rd, & rd_best);
  }
  return;
}
}
#line 934 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void SimpleQuantize(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Encoder *enc ;
  int is_i16 ;
  int nz ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int mode ;
  uint8_t *src ;
  uint8_t *dst ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 935
  enc = it->enc_;
#line 936
  is_i16 = (int )(it->mb_)->type_ == 1;
#line 937
  nz = 0;
#line 939
  if (is_i16) {
    {
#line 940
    nz = ReconstructIntra16(it, rd, it->yuv_out_ + 0, (int )*(it->preds_ + 0));
    }
  } else {
    {
#line 942
    VP8IteratorStartI4(it);
    }
    {
#line 943
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 944
      mode = (int )*(it->preds_ + ((it->i4_ & 3) + (it->i4_ >> 2) * enc->preds_w_));
#line 946
      src = (it->yuv_in_ + 0) + VP8Scan[it->i4_];
#line 947
      dst = (it->yuv_out_ + 0) + VP8Scan[it->i4_];
#line 948
      VP8MakeIntra4Preds(it);
#line 949
      __cil_tmp11 = ReconstructIntra4(it, (int16_t *)rd->y_ac_levels[it->i4_], src,
                                      dst, mode);
      }
#line 949
      nz |= __cil_tmp11 << it->i4_;
#line 943
      if (! __cil_tmp7) {
#line 943
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 954
  __cil_tmp12 = ReconstructUV(it, rd, it->yuv_out_ + 256, (int )(it->mb_)->uv_mode_);
  }
#line 954
  nz |= __cil_tmp12;
#line 955
  rd->nz = (uint32_t )nz;
  return;
}
}
#line 959 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
static void DistoRefine(VP8EncIterator *it , int try_both_i4_i16 ) 
{ 
  int is_i16 ;
  score_t best_score ;
  int mode ;
  int best_mode ;
  uint8_t *ref ;
  uint8_t *src ;
  score_t score ;
  int __cil_tmp10 ;
  uint8_t modes_i4[16] ;
  score_t score_i4 ;
  int __cil_tmp13 ;
  int mode___0 ;
  int best_sub_mode ;
  score_t best_sub_score ;
  uint8_t *src___0 ;
  uint8_t *ref___0 ;
  score_t score___0 ;
  int __cil_tmp20 ;

  {
#line 960
  is_i16 = (int )(it->mb_)->type_ == 1;
#line 961
  best_score = (score_t )36028797018963967LL;
#line 963
  if (try_both_i4_i16) {
    _L: /* CIL Label */ 
#line 965
    best_mode = - 1;
#line 966
    mode = 0;
    {
#line 966
    while (1) {
      while_continue: /* CIL Label */ ;
#line 966
      if (! (mode < 4)) {
#line 966
        goto while_break;
      }
      {
#line 967
      ref = it->yuv_p_ + VP8I16ModeOffsets[mode];
#line 968
      src = it->yuv_in_ + 0;
#line 969
      __cil_tmp10 = (*VP8SSE16x16)(src, ref);
#line 969
      score = (score_t )__cil_tmp10;
      }
#line 970
      if (score < best_score) {
#line 971
        best_mode = mode;
#line 972
        best_score = score;
      }
#line 966
      mode ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 975
    VP8SetIntra16Mode(it, best_mode);
    }
  } else
#line 963
  if (is_i16) {
#line 963
    goto _L;
  }
#line 977
  if (try_both_i4_i16) {
    _L___9: /* CIL Label */ 
    {
#line 981
    score_i4 = (score_t )4000;
#line 983
    VP8IteratorStartI4(it);
    }
    {
#line 984
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 986
      best_sub_mode = - 1;
#line 987
      best_sub_score = (score_t )36028797018963967LL;
#line 988
      src___0 = (it->yuv_in_ + 0) + VP8Scan[it->i4_];
#line 992
      VP8MakeIntra4Preds(it);
#line 993
      mode___0 = 0;
      }
      {
#line 993
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 993
        if (! (mode___0 < 10)) {
#line 993
          goto while_break___1;
        }
        {
#line 994
        ref___0 = it->yuv_p_ + VP8I4ModeOffsets[mode___0];
#line 995
        __cil_tmp20 = (*VP8SSE4x4)(src___0, ref___0);
#line 995
        score___0 = (score_t )__cil_tmp20;
        }
#line 996
        if (score___0 < best_sub_score) {
#line 997
          best_sub_mode = mode___0;
#line 998
          best_sub_score = score___0;
        }
#line 993
        mode___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1001
      modes_i4[it->i4_] = (uint8_t )best_sub_mode;
#line 1002
      score_i4 += best_sub_score;
#line 1003
      if (score_i4 >= best_score) {
#line 1003
        goto while_break___0;
      }
#line 984
      if (! __cil_tmp13) {
#line 984
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1005
    if (score_i4 < best_score) {
      {
#line 1006
      VP8SetIntra4Mode(it, (uint8_t *)modes_i4);
      }
    }
  } else
#line 977
  if (! is_i16) {
#line 977
    goto _L___9;
  }
  return;
}
}
#line 1014 "/doner/libwebp/libwebp-v0.3.0/src/enc/quant.c"
int VP8Decimate(VP8EncIterator *it , VP8ModeScore *rd , VP8RDLevel rd_opt ) 
{ 
  int is_skipped ;
  int method ;

  {
  {
#line 1017
  method = (it->enc_)->method_;
#line 1019
  InitScore(rd);
#line 1023
  VP8MakeLuma16Preds(it);
#line 1024
  VP8MakeChroma8Preds(it);
  }
#line 1026
  if ((unsigned int )rd_opt > 0U) {
    {
#line 1027
    it->do_trellis_ = (unsigned int )rd_opt >= 3U;
#line 1028
    PickBestIntra16(it, rd);
    }
#line 1029
    if (method >= 2) {
      {
#line 1030
      PickBestIntra4(it, rd);
      }
    }
    {
#line 1032
    PickBestUV(it, rd);
    }
#line 1033
    if ((unsigned int )rd_opt == 2U) {
      {
#line 1034
      it->do_trellis_ = 1;
#line 1035
      SimpleQuantize(it, rd);
      }
    }
  } else {
    {
#line 1040
    DistoRefine(it, method >= 2);
#line 1041
    SimpleQuantize(it, rd);
    }
  }
  {
#line 1043
  is_skipped = rd->nz == 0U;
#line 1044
  VP8SetSkip(it, is_skipped);
  }
#line 1045
  return (is_skipped);
}
}
#line 157 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/../webp/decode.h"
__inline static int WebPIsPremultipliedMode___0(enum WEBP_CSP_MODE mode ) 
{ 


  {
#line 158
  return ((((unsigned int )mode == 7U || (unsigned int )mode == 8U) || (unsigned int )mode == 9U) || (unsigned int )mode == 10U);
}
}
#line 162 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/../webp/decode.h"
__inline static int WebPIsAlphaMode___0(enum WEBP_CSP_MODE mode ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 163
  __cil_tmp2 = WebPIsPremultipliedMode___0(mode);
  }
#line 163
  return ((((((unsigned int )mode == 1U || (unsigned int )mode == 3U) || (unsigned int )mode == 4U) || (unsigned int )mode == 5U) || (unsigned int )mode == 12U) || __cil_tmp2);
}
}
#line 168 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/../webp/decode.h"
__inline static int WebPIsRGBMode___0(enum WEBP_CSP_MODE mode ) 
{ 


  {
#line 169
  return ((unsigned int )mode < 11U);
}
}
#line 418 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/../webp/decode.h"
__inline static enum VP8StatusCode WebPGetFeatures___0(uint8_t *data , size_t data_size ,
                                                       WebPBitstreamFeatures *features ) 
{ 
  enum VP8StatusCode __cil_tmp4 ;

  {
  {
#line 421
  __cil_tmp4 = (enum VP8StatusCode )WebPGetFeaturesInternal(data, data_size, features,
                                                            513);
  }
#line 421
  return (__cil_tmp4);
}
}
#line 109 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/decode_vp8.h"
int VP8InitIoInternal(VP8Io *io , int version ) ;
#line 114
int WebPISetIOHooks(WebPIDecoder *idec , VP8IoPutHook put , VP8IoSetupHook setup ,
                    VP8IoTeardownHook teardown , void *user_data ) ;
#line 124
VP8Decoder *VP8New(void) ;
#line 129 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/../dec/decode_vp8.h"
__inline static int VP8InitIo(VP8Io *io ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 130
  __cil_tmp2 = VP8InitIoInternal(io, 513);
  }
#line 130
  return (__cil_tmp2);
}
}
#line 134
int VP8GetHeaders(VP8Decoder *dec , VP8Io *io ) ;
#line 138
int VP8Decode(VP8Decoder *dec , VP8Io *io ) ;
#line 141
enum VP8StatusCode VP8Status(VP8Decoder *dec ) ;
#line 144
char const   *VP8StatusMessage(VP8Decoder *dec ) ;
#line 148
void VP8Clear(VP8Decoder *dec ) ;
#line 151
void VP8Delete(VP8Decoder *dec ) ;
#line 157
int VP8CheckSignature(uint8_t *data , size_t data_size ) ;
#line 162
int VP8GetInfo(uint8_t *data , size_t data_size , size_t chunk_size , int *width ,
               int *height ) ;
#line 169
int VP8LCheckSignature(uint8_t *data , size_t size ) ;
#line 174
int VP8LGetInfo(uint8_t *data , size_t data_size , int *width , int *height , int *has_alpha ) ;
#line 66 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
int16_t VP8kVToR[256] ;
#line 66
int16_t VP8kUToB[256] ;
#line 67
int32_t VP8kVToG[256] ;
#line 67
int32_t VP8kUToG[256] ;
#line 68
uint8_t VP8kClip[709] ;
#line 69
uint8_t VP8kClip4Bits[709] ;
#line 71 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToRgb(uint8_t y , uint8_t u , uint8_t v , uint8_t *rgb ) 
{ 
  int r_off ;
  int g_off ;
  int b_off ;

  {
#line 73
  r_off = (int )VP8kVToR[v];
#line 74
  g_off = (VP8kVToG[v] + VP8kUToG[u]) >> 16;
#line 75
  b_off = (int )VP8kUToB[u];
#line 76
  *(rgb + 0) = VP8kClip[((int )y + r_off) - -227];
#line 77
  *(rgb + 1) = VP8kClip[((int )y + g_off) - -227];
#line 78
  *(rgb + 2) = VP8kClip[((int )y + b_off) - -227];
  return;
}
}
#line 81 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToBgr(uint8_t y , uint8_t u , uint8_t v , uint8_t *bgr ) 
{ 
  int r_off ;
  int g_off ;
  int b_off ;

  {
#line 83
  r_off = (int )VP8kVToR[v];
#line 84
  g_off = (VP8kVToG[v] + VP8kUToG[u]) >> 16;
#line 85
  b_off = (int )VP8kUToB[u];
#line 86
  *(bgr + 0) = VP8kClip[((int )y + b_off) - -227];
#line 87
  *(bgr + 1) = VP8kClip[((int )y + g_off) - -227];
#line 88
  *(bgr + 2) = VP8kClip[((int )y + r_off) - -227];
  return;
}
}
#line 91 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToRgb565(uint8_t y , uint8_t u , uint8_t v , uint8_t *rgb ) 
{ 
  int r_off ;
  int g_off ;
  int b_off ;
  uint8_t rg ;
  uint8_t gb ;

  {
#line 93
  r_off = (int )VP8kVToR[v];
#line 94
  g_off = (VP8kVToG[v] + VP8kUToG[u]) >> 16;
#line 95
  b_off = (int )VP8kUToB[u];
#line 96
  rg = (uint8_t )(((int )VP8kClip[((int )y + r_off) - -227] & 248) | ((int )VP8kClip[((int )y + g_off) - -227] >> 5));
#line 98
  gb = (uint8_t )((((int )VP8kClip[((int )y + g_off) - -227] << 3) & 224) | ((int )VP8kClip[((int )y + b_off) - -227] >> 3));
#line 104
  *(rgb + 0) = rg;
#line 105
  *(rgb + 1) = gb;
  return;
}
}
#line 109 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToRgba4444(uint8_t y , uint8_t u , uint8_t v , uint8_t *argb ) 
{ 
  int r_off ;
  int g_off ;
  int b_off ;
  uint8_t rg ;
  uint8_t ba ;

  {
#line 111
  r_off = (int )VP8kVToR[v];
#line 112
  g_off = (VP8kVToG[v] + VP8kUToG[u]) >> 16;
#line 113
  b_off = (int )VP8kUToB[u];
#line 114
  rg = (uint8_t )(((int )VP8kClip4Bits[((int )y + r_off) - -227] << 4) | (int )VP8kClip4Bits[((int )y + g_off) - -227]);
#line 116
  ba = (uint8_t )(((int )VP8kClip4Bits[((int )y + b_off) - -227] << 4) | 15);
#line 121
  *(argb + 0) = rg;
#line 122
  *(argb + 1) = ba;
  return;
}
}
#line 208 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToArgb(uint8_t y , uint8_t u , uint8_t v , uint8_t *argb ) 
{ 


  {
  {
#line 210
  *(argb + 0) = (uint8_t )255;
#line 211
  VP8YuvToRgb(y, u, v, argb + 1);
  }
  return;
}
}
#line 214 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToBgra(uint8_t y , uint8_t u , uint8_t v , uint8_t *bgra ) 
{ 


  {
  {
#line 216
  VP8YuvToBgr(y, u, v, bgra);
#line 217
  *(bgra + 3) = (uint8_t )255;
  }
  return;
}
}
#line 220 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static void VP8YuvToRgba(uint8_t y , uint8_t u , uint8_t v , uint8_t *rgba ) 
{ 


  {
  {
#line 222
  VP8YuvToRgb(y, u, v, rgba);
#line 223
  *(rgba + 3) = (uint8_t )255;
  }
  return;
}
}
#line 227
void VP8YUVInit(void) ;
#line 232 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static int VP8ClipUV(int v ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 233
  v = (v + (257 << 17)) >> 18;
#line 234
  if ((v & -256) == 0) {
#line 234
    tmp___0 = v;
  } else {
#line 234
    if (v < 0) {
#line 234
      tmp = 0;
    } else {
#line 234
      tmp = 255;
    }
#line 234
    tmp___0 = tmp;
  }
#line 234
  return (tmp___0);
}
}
#line 239 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static int VP8RGBToY(int r , int g , int b ) 
{ 
  int kRound ;
  int luma ;

  {
#line 240
  kRound = (1 << 15) + (16 << 16);
#line 241
  luma = (16839 * r + 33059 * g) + 6420 * b;
#line 242
  return ((luma + kRound) >> 16);
}
}
#line 245 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static int VP8RGBToU(int r , int g , int b ) 
{ 
  int u ;
  int __cil_tmp5 ;

  {
  {
#line 246
  u = (-9719 * r - 19081 * g) + 28800 * b;
#line 247
  __cil_tmp5 = VP8ClipUV(u);
  }
#line 247
  return (__cil_tmp5);
}
}
#line 250 "/doner/libwebp/libwebp-v0.3.0/src/enc/../dsp/yuv.h"
__inline static int VP8RGBToV(int r , int g , int b ) 
{ 
  int v ;
  int __cil_tmp5 ;

  {
  {
#line 251
  v = (28800 * r - 24116 * g) - 4684 * b;
#line 252
  __cil_tmp5 = VP8ClipUV(v);
  }
#line 252
  return (__cil_tmp5);
}
}
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static union __anonunion_429 test_endian  =    {4278190080U};
#line 39 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureAlloc(WebPPicture *picture ) 
{ 
  enum WebPEncCSP uv_csp ;
  int has_alpha ;
  int width ;
  int height ;
  int y_stride ;
  int uv_width ;
  int uv_height ;
  int uv_stride ;
  int uv0_stride ;
  int a_width ;
  int a_stride ;
  uint64_t y_size ;
  uint64_t uv_size ;
  uint64_t uv0_size ;
  uint64_t a_size ;
  uint64_t total_size ;
  uint8_t *mem ;
  int tmp ;
  void *__cil_tmp20 ;
  void *memory ;
  uint64_t argb_size ;
  void *__cil_tmp23 ;

  {
#line 40
  if (picture != (void *)0) {
#line 41
    uv_csp = (enum WebPEncCSP )((unsigned int )picture->colorspace & 3U);
#line 42
    has_alpha = (int )((unsigned int )picture->colorspace & 4U);
#line 43
    width = picture->width;
#line 44
    height = picture->height;
#line 46
    if (! picture->use_argb) {
#line 47
      y_stride = width;
#line 48
      uv_width = (width + 1) >> 1;
#line 49
      uv_height = (height + 1) >> 1;
#line 50
      uv_stride = uv_width;
#line 51
      uv0_stride = 0;
      {
#line 58
      if ((unsigned int )uv_csp == (unsigned int )0) {
#line 58
        goto case_0;
      }
#line 70
      goto switch_default;
      case_0: /* CIL Label */ 
#line 59
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 71
      return (0);
      switch_break: /* CIL Label */ ;
      }
#line 73
      uv0_size = (uint64_t )(height * uv0_stride);
#line 76
      if (has_alpha) {
#line 76
        tmp = width;
      } else {
#line 76
        tmp = 0;
      }
#line 76
      a_width = tmp;
#line 77
      a_stride = a_width;
#line 78
      y_size = (uint64_t )y_stride * (unsigned long )height;
#line 79
      uv_size = (uint64_t )uv_stride * (unsigned long )uv_height;
#line 80
      a_size = (uint64_t )a_stride * (unsigned long )height;
#line 82
      total_size = ((y_size + a_size) + 2UL * uv_size) + 2UL * uv0_size;
#line 85
      if (width <= 0) {
#line 87
        return (0);
      } else
#line 85
      if (height <= 0) {
#line 87
        return (0);
      } else
#line 85
      if (uv_width < 0) {
#line 87
        return (0);
      } else
#line 85
      if (uv_height < 0) {
#line 87
        return (0);
      }
      {
#line 90
      WebPPictureFree(picture);
#line 91
      __cil_tmp20 = WebPSafeMalloc(total_size, sizeof(*mem));
#line 91
      mem = (uint8_t *)__cil_tmp20;
      }
#line 92
      if (mem == (void *)0) {
#line 92
        return (0);
      }
#line 95
      picture->memory_ = (void *)mem;
#line 96
      picture->y_stride = y_stride;
#line 97
      picture->uv_stride = uv_stride;
#line 98
      picture->a_stride = a_stride;
#line 99
      picture->uv0_stride = uv0_stride;
#line 101
      picture->y = mem;
#line 102
      mem += y_size;
#line 104
      picture->u = mem;
#line 105
      mem += uv_size;
#line 106
      picture->v = mem;
#line 107
      mem += uv_size;
#line 109
      if (a_size) {
#line 110
        picture->a = mem;
#line 111
        mem += a_size;
      }
#line 113
      if (uv0_size) {
#line 114
        picture->u0 = mem;
#line 115
        mem += uv0_size;
#line 116
        picture->v0 = mem;
#line 117
        mem += uv0_size;
      }
    } else {
#line 121
      argb_size = (uint64_t )width * (unsigned long )height;
#line 122
      if (width <= 0) {
#line 123
        return (0);
      } else
#line 122
      if (height <= 0) {
#line 123
        return (0);
      }
      {
#line 126
      WebPPictureFree(picture);
#line 127
      memory = WebPSafeMalloc(argb_size, sizeof(*(picture->argb)));
      }
#line 128
      if (memory == (void *)0) {
#line 128
        return (0);
      }
#line 131
      picture->memory_argb_ = memory;
#line 132
      picture->argb = (uint32_t *)memory;
#line 133
      picture->argb_stride = width;
    }
  }
#line 136
  return (1);
}
}
#line 140 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static void PictureResetARGB(WebPPicture *picture ) 
{ 


  {
#line 141
  picture->memory_argb_ = (void *)0;
#line 142
  picture->argb = (uint32_t *)((void *)0);
#line 143
  picture->argb_stride = 0;
  return;
}
}
#line 147 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static void PictureResetYUVA(WebPPicture *picture ) 
{ 


  {
#line 148
  picture->memory_ = (void *)0;
#line 149
  picture->a = (uint8_t *)((void *)0);
#line 149
  picture->v = picture->a;
#line 149
  picture->u = picture->v;
#line 149
  picture->y = picture->u;
#line 150
  picture->v0 = (uint8_t *)((void *)0);
#line 150
  picture->u0 = picture->v0;
#line 151
  picture->uv_stride = 0;
#line 151
  picture->y_stride = picture->uv_stride;
#line 152
  picture->a_stride = 0;
#line 153
  picture->uv0_stride = 0;
  return;
}
}
#line 158 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static void WebPPictureGrabSpecs(WebPPicture *src , WebPPicture *dst ) 
{ 
  int tmp ;

  {
  {
#line 161
  *dst = *src;
#line 162
  PictureResetYUVA(dst);
#line 163
  PictureResetARGB(dst);
  }
  return;
}
}
#line 168 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static int PictureAllocARGB(WebPPicture *picture ) 
{ 
  WebPPicture tmp ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 170
  free(picture->memory_argb_);
#line 171
  PictureResetARGB(picture);
#line 172
  picture->use_argb = 1;
#line 173
  WebPPictureGrabSpecs(picture, & tmp);
#line 174
  __cil_tmp3 = WebPPictureAlloc(& tmp);
  }
#line 174
  if (! __cil_tmp3) {
    {
#line 175
    __cil_tmp4 = WebPEncodingSetError(picture, (enum WebPEncodingError )1);
    }
#line 175
    return (__cil_tmp4);
  }
#line 177
  picture->memory_argb_ = tmp.memory_argb_;
#line 178
  picture->argb = tmp.argb;
#line 179
  picture->argb_stride = tmp.argb_stride;
#line 180
  return (1);
}
}
#line 184 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
void WebPPictureFree(WebPPicture *picture ) 
{ 


  {
#line 185
  if (picture != (void *)0) {
    {
#line 186
    free(picture->memory_);
#line 187
    free(picture->memory_argb_);
#line 188
    PictureResetYUVA(picture);
#line 189
    PictureResetARGB(picture);
    }
  }
  return;
}
}
#line 197 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static void CopyPlane(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                      int width , int height ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    __cil_tmp7 = height;
#line 199
    height --;
#line 199
    if (! (__cil_tmp7 > 0)) {
#line 199
      goto while_break;
    }
    {
#line 200
    memcpy(dst, src, (unsigned long )width);
#line 201
    src += src_stride;
#line 202
    dst += dst_stride;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 207 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static void SnapTopLeftPosition(WebPPicture *pic , int *left , int *top ) 
{ 
  int is_yuv422 ;

  {
#line 209
  if (! pic->use_argb) {
#line 210
    is_yuv422 = ((unsigned int )pic->colorspace & 3U) == 1U;
#line 211
    if (((unsigned int )pic->colorspace & 3U) == 0U) {
      _L: /* CIL Label */ 
#line 212
      *left &= ~ 1;
#line 213
      if (! is_yuv422) {
#line 213
        *top &= ~ 1;
      }
    } else
#line 211
    if (is_yuv422) {
#line 211
      goto _L;
    }
  }
  return;
}
}
#line 219 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static int AdjustAndCheckRectangle(WebPPicture *pic , int *left , int *top , int width ,
                                   int height ) 
{ 


  {
  {
#line 222
  SnapTopLeftPosition(pic, left, top);
  }
#line 223
  if (*left < 0) {
#line 223
    return (0);
  } else
#line 223
  if (*top < 0) {
#line 223
    return (0);
  }
#line 224
  if (width <= 0) {
#line 224
    return (0);
  } else
#line 224
  if (height <= 0) {
#line 224
    return (0);
  }
#line 225
  if (*left + width > pic->width) {
#line 225
    return (0);
  }
#line 226
  if (*top + height > pic->height) {
#line 226
    return (0);
  }
#line 227
  return (1);
}
}
#line 230 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureCopy(WebPPicture *src , WebPPicture *dst ) 
{ 
  int __cil_tmp3 ;

  {
#line 231
  if (src == (void *)0) {
#line 231
    return (0);
  } else
#line 231
  if (dst == (void *)0) {
#line 231
    return (0);
  }
#line 232
  if (src == dst) {
#line 232
    return (1);
  }
  {
#line 234
  WebPPictureGrabSpecs(src, dst);
#line 235
  __cil_tmp3 = WebPPictureAlloc(dst);
  }
#line 235
  if (! __cil_tmp3) {
#line 235
    return (0);
  }
#line 237
  if (! src->use_argb) {
    {
#line 238
    CopyPlane(src->y, src->y_stride, dst->y, dst->y_stride, dst->width, dst->height);
#line 240
    CopyPlane(src->u, src->uv_stride, dst->u, dst->uv_stride, (dst->width + 1) >> 1,
              (dst->height + 1) >> 1);
#line 242
    CopyPlane(src->v, src->uv_stride, dst->v, dst->uv_stride, (dst->width + 1) >> 1,
              (dst->height + 1) >> 1);
    }
#line 244
    if (dst->a != (void *)0) {
      {
#line 245
      CopyPlane(src->a, src->a_stride, dst->a, dst->a_stride, dst->width, dst->height);
      }
    }
  } else {
    {
#line 261
    CopyPlane((uint8_t *)src->argb, 4 * src->argb_stride, (uint8_t *)dst->argb, 4 * dst->argb_stride,
              4 * dst->width, dst->height);
    }
  }
#line 265
  return (1);
}
}
#line 268 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureIsView(WebPPicture *picture ) 
{ 


  {
#line 269
  if (picture == (void *)0) {
#line 269
    return (0);
  }
#line 270
  if (picture->use_argb) {
#line 271
    return (picture->memory_argb_ == (void *)0);
  }
#line 273
  return (picture->memory_ == (void *)0);
}
}
#line 276 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureView(WebPPicture *src , int left , int top , int width , int height ,
                    WebPPicture *dst ) 
{ 
  int __cil_tmp7 ;

  {
#line 279
  if (src == (void *)0) {
#line 279
    return (0);
  } else
#line 279
  if (dst == (void *)0) {
#line 279
    return (0);
  }
  {
#line 282
  __cil_tmp7 = AdjustAndCheckRectangle(src, & left, & top, width, height);
  }
#line 282
  if (! __cil_tmp7) {
#line 282
    return (0);
  }
#line 284
  if (src != dst) {
    {
#line 285
    WebPPictureGrabSpecs(src, dst);
    }
  }
#line 287
  dst->width = width;
#line 288
  dst->height = height;
#line 289
  if (! src->use_argb) {
#line 290
    dst->y = (src->y + top * src->y_stride) + left;
#line 291
    dst->u = (src->u + (top >> 1) * src->uv_stride) + (left >> 1);
#line 292
    dst->v = (src->v + (top >> 1) * src->uv_stride) + (left >> 1);
#line 293
    dst->y_stride = src->y_stride;
#line 294
    dst->uv_stride = src->uv_stride;
#line 295
    if (src->a != (void *)0) {
#line 296
      dst->a = (src->a + top * src->a_stride) + left;
#line 297
      dst->a_stride = src->a_stride;
    }
  } else {
#line 309
    dst->argb = (src->argb + top * src->argb_stride) + left;
#line 310
    dst->argb_stride = src->argb_stride;
  }
#line 312
  return (1);
}
}
#line 318 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureCrop(WebPPicture *pic , int left , int top , int width , int height ) 
{ 
  WebPPicture tmp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int y_offset ;
  int uv_offset ;
  int a_offset ;
  uint8_t *src ;

  {
#line 322
  if (pic == (void *)0) {
#line 322
    return (0);
  }
  {
#line 323
  __cil_tmp7 = AdjustAndCheckRectangle(pic, & left, & top, width, height);
  }
#line 323
  if (! __cil_tmp7) {
#line 323
    return (0);
  }
  {
#line 325
  WebPPictureGrabSpecs(pic, & tmp);
#line 326
  tmp.width = width;
#line 327
  tmp.height = height;
#line 328
  __cil_tmp8 = WebPPictureAlloc(& tmp);
  }
#line 328
  if (! __cil_tmp8) {
#line 328
    return (0);
  }
#line 330
  if (! pic->use_argb) {
    {
#line 331
    y_offset = top * pic->y_stride + left;
#line 332
    uv_offset = (top / 2) * pic->uv_stride + left / 2;
#line 333
    CopyPlane(pic->y + y_offset, pic->y_stride, tmp.y, tmp.y_stride, width, height);
#line 335
    CopyPlane(pic->u + uv_offset, pic->uv_stride, tmp.u, tmp.uv_stride, (width + 1) >> 1,
              (height + 1) >> 1);
#line 337
    CopyPlane(pic->v + uv_offset, pic->uv_stride, tmp.v, tmp.uv_stride, (width + 1) >> 1,
              (height + 1) >> 1);
    }
#line 340
    if (tmp.a != (void *)0) {
      {
#line 341
      a_offset = top * pic->a_stride + left;
#line 342
      CopyPlane(pic->a + a_offset, pic->a_stride, tmp.a, tmp.a_stride, width, height);
      }
    }
  } else {
    {
#line 360
    src = (uint8_t *)((pic->argb + top * pic->argb_stride) + left);
#line 362
    CopyPlane(src, pic->argb_stride * 4, (uint8_t *)tmp.argb, tmp.argb_stride * 4,
              width * 4, height);
    }
  }
  {
#line 366
  WebPPictureFree(pic);
#line 367
  *pic = tmp;
  }
#line 368
  return (1);
}
}
#line 374 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static void RescalePlane(uint8_t *src , int src_width , int src_height , int src_stride ,
                         uint8_t *dst , int dst_width , int dst_height , int dst_stride ,
                         int32_t *work , int num_channels ) 
{ 
  WebPRescaler rescaler ;
  int y ;
  int __cil_tmp13 ;

  {
  {
#line 381
  y = 0;
#line 382
  WebPRescalerInit(& rescaler, src_width, src_height, dst, dst_width, dst_height,
                   dst_stride, num_channels, src_width, dst_width, src_height, dst_height,
                   work);
#line 388
  memset(work, 0, (unsigned long )((2 * dst_width) * num_channels) * sizeof(*work));
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (y < src_height)) {
#line 389
      goto while_break;
    }
    {
#line 390
    __cil_tmp13 = WebPRescalerImport(& rescaler, src_height - y, src + y * src_stride,
                                     src_stride);
    }
    {
#line 390
    y += __cil_tmp13;
#line 392
    WebPRescalerExport(& rescaler);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 396 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureRescale(WebPPicture *pic , int width , int height ) 
{ 
  WebPPicture tmp ;
  int prev_width ;
  int prev_height ;
  int32_t *work ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
#line 401
  if (pic == (void *)0) {
#line 401
    return (0);
  }
#line 402
  prev_width = pic->width;
#line 403
  prev_height = pic->height;
#line 405
  if (width == 0) {
#line 406
    width = (prev_width * height + prev_height / 2) / prev_height;
  }
#line 409
  if (height == 0) {
#line 410
    height = (prev_height * width + prev_width / 2) / prev_width;
  }
#line 413
  if (width <= 0) {
#line 413
    return (0);
  } else
#line 413
  if (height <= 0) {
#line 413
    return (0);
  }
  {
#line 415
  WebPPictureGrabSpecs(pic, & tmp);
#line 416
  tmp.width = width;
#line 417
  tmp.height = height;
#line 418
  __cil_tmp8 = WebPPictureAlloc(& tmp);
  }
#line 418
  if (! __cil_tmp8) {
#line 418
    return (0);
  }
#line 420
  if (! pic->use_argb) {
    {
#line 421
    __cil_tmp9 = WebPSafeMalloc((uint64_t )(2ULL * (unsigned long long )width), sizeof(*work));
#line 421
    work = (int32_t *)__cil_tmp9;
    }
#line 422
    if (work == (void *)0) {
      {
#line 423
      WebPPictureFree(& tmp);
      }
#line 424
      return (0);
    }
    {
#line 427
    RescalePlane(pic->y, prev_width, prev_height, pic->y_stride, tmp.y, width, height,
                 tmp.y_stride, work, 1);
#line 429
    RescalePlane(pic->u, (prev_width + 1) >> 1, (prev_height + 1) >> 1, pic->uv_stride,
                 tmp.u, (width + 1) >> 1, (height + 1) >> 1, tmp.uv_stride, work,
                 1);
#line 433
    RescalePlane(pic->v, (prev_width + 1) >> 1, (prev_height + 1) >> 1, pic->uv_stride,
                 tmp.v, (width + 1) >> 1, (height + 1) >> 1, tmp.uv_stride, work,
                 1);
    }
#line 438
    if (tmp.a != (void *)0) {
      {
#line 439
      RescalePlane(pic->a, prev_width, prev_height, pic->a_stride, tmp.a, width, height,
                   tmp.a_stride, work, 1);
      }
    }
  } else {
    {
#line 454
    __cil_tmp10 = WebPSafeMalloc((uint64_t )((2ULL * (unsigned long long )width) * 4ULL),
                                 sizeof(*work));
#line 454
    work = (int32_t *)__cil_tmp10;
    }
#line 455
    if (work == (void *)0) {
      {
#line 456
      WebPPictureFree(& tmp);
      }
#line 457
      return (0);
    }
    {
#line 460
    RescalePlane((uint8_t *)pic->argb, prev_width, prev_height, pic->argb_stride * 4,
                 (uint8_t *)tmp.argb, width, height, tmp.argb_stride * 4, work, 4);
    }
  }
  {
#line 466
  WebPPictureFree(pic);
#line 467
  free(work);
#line 468
  *pic = tmp;
  }
#line 469
  return (1);
}
}
#line 475 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
void WebPMemoryWriterInit(WebPMemoryWriter *writer ) 
{ 


  {
#line 476
  writer->mem = (uint8_t *)((void *)0);
#line 477
  writer->size = (size_t )0;
#line 478
  writer->max_size = (size_t )0;
  return;
}
}
#line 481 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPMemoryWrite(uint8_t *data , size_t data_size , WebPPicture *picture ) 
{ 
  WebPMemoryWriter *w ;
  uint64_t next_size ;
  uint8_t *new_mem ;
  uint64_t next_max_size ;
  void *__cil_tmp8 ;

  {
#line 483
  w = (WebPMemoryWriter *)picture->custom_ptr;
#line 485
  if (w == (void *)0) {
#line 486
    return (1);
  }
#line 488
  next_size = (uint64_t )w->size + data_size;
#line 489
  if (next_size > w->max_size) {
#line 491
    next_max_size = (uint64_t )(2ULL * (unsigned long long )w->max_size);
#line 492
    if (next_max_size < next_size) {
#line 492
      next_max_size = next_size;
    }
#line 493
    if ((unsigned long long )next_max_size < 8192ULL) {
#line 493
      next_max_size = (uint64_t )8192ULL;
    }
    {
#line 494
    __cil_tmp8 = WebPSafeMalloc(next_max_size, (size_t )1);
#line 494
    new_mem = (uint8_t *)__cil_tmp8;
    }
#line 495
    if (new_mem == (void *)0) {
#line 496
      return (0);
    }
#line 498
    if (w->size > 0UL) {
      {
#line 499
      memcpy(new_mem, w->mem, w->size);
      }
    }
    {
#line 501
    free(w->mem);
#line 502
    w->mem = new_mem;
#line 504
    w->max_size = (size_t )next_max_size;
    }
  }
#line 506
  if (data_size > 0UL) {
    {
#line 507
    memcpy(w->mem + w->size, data, data_size);
#line 508
    w->size += data_size;
    }
  }
#line 510
  return (1);
}
}
#line 517 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static int CheckNonOpaque(uint8_t *alpha , int width , int height , int x_step , int y_step ) 
{ 
  int __cil_tmp6 ;
  int x ;

  {
#line 519
  if (alpha == (void *)0) {
#line 519
    return (0);
  }
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    __cil_tmp6 = height;
#line 520
    height --;
#line 520
    if (! (__cil_tmp6 > 0)) {
#line 520
      goto while_break;
    }
#line 522
    x = 0;
    {
#line 522
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 522
      if (! (x < width * x_step)) {
#line 522
        goto while_break___0;
      }
#line 523
      if ((int )*(alpha + x) != 255) {
#line 523
        return (1);
      }
#line 522
      x += x_step;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 525
    alpha += y_step;
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  return (0);
}
}
#line 531 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureHasTransparency(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;
  int x ;
  int y ;
  uint32_t *argb ;

  {
#line 532
  if (picture == (void *)0) {
#line 532
    return (0);
  }
#line 533
  if (! picture->use_argb) {
    {
#line 534
    __cil_tmp2 = CheckNonOpaque(picture->a, picture->width, picture->height, 1, picture->a_stride);
    }
#line 534
    return (__cil_tmp2);
  } else {
#line 538
    argb = picture->argb;
#line 539
    if (argb == (void *)0) {
#line 539
      return (0);
    }
#line 540
    y = 0;
    {
#line 540
    while (1) {
      while_continue: /* CIL Label */ ;
#line 540
      if (! (y < picture->height)) {
#line 540
        goto while_break;
      }
#line 541
      x = 0;
      {
#line 541
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 541
        if (! (x < picture->width)) {
#line 541
          goto while_break___0;
        }
#line 542
        if (*(argb + x) < 4278190080U) {
#line 542
          return (1);
        }
#line 541
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 544
      argb += picture->argb_stride;
#line 540
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 547
  return (0);
}
}
#line 579 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static void MakeGray(WebPPicture *picture ) 
{ 
  int y ;
  int uv_width ;
  int uv_height ;

  {
#line 581
  uv_width = (picture->width + 1) >> 1;
#line 582
  uv_height = (picture->height + 1) >> 1;
#line 583
  y = 0;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (y < uv_height)) {
#line 583
      goto while_break;
    }
    {
#line 584
    memset(picture->u + y * picture->uv_stride, 128, (unsigned long )uv_width);
#line 585
    memset(picture->v + y * picture->uv_stride, 128, (unsigned long )uv_width);
    }
#line 583
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 589 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static int ImportYUVAFromRGBA(uint8_t *r_ptr , uint8_t *g_ptr , uint8_t *b_ptr , uint8_t *a_ptr ,
                              int step , int rgb_stride , WebPPicture *picture ) 
{ 
  enum WebPEncCSP uv_csp ;
  int x ;
  int y ;
  int width ;
  int height ;
  int has_alpha ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int offset ;
  int __cil_tmp17 ;
  int src ;
  int dst ;
  int r ;
  int g ;
  int b ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int src___0 ;
  int dst___0 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int src___1 ;
  int dst___1 ;
  int r___1 ;
  int g___1 ;
  int b___1 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int src___2 ;
  int dst___2 ;
  int r___2 ;
  int g___2 ;
  int b___2 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int tmp ;

  {
  {
#line 596
  uv_csp = (enum WebPEncCSP )((unsigned int )picture->colorspace & 3U);
#line 598
  width = picture->width;
#line 599
  height = picture->height;
#line 600
  __cil_tmp14 = CheckNonOpaque(a_ptr, width, height, step, rgb_stride);
#line 600
  has_alpha = __cil_tmp14;
#line 602
  picture->colorspace = uv_csp;
#line 603
  picture->use_argb = 0;
  }
#line 604
  if (has_alpha) {
#line 605
    picture->colorspace |= (unsigned int )4;
  }
  {
#line 607
  __cil_tmp15 = WebPPictureAlloc(picture);
  }
#line 607
  if (! __cil_tmp15) {
#line 607
    return (0);
  }
#line 610
  y = 0;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (y < height)) {
#line 610
      goto while_break;
    }
#line 611
    x = 0;
    {
#line 611
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 611
      if (! (x < width)) {
#line 611
        goto while_break___0;
      }
      {
#line 612
      offset = step * x + y * rgb_stride;
#line 613
      __cil_tmp17 = VP8RGBToY((int )*(r_ptr + offset), (int )*(g_ptr + offset), (int )*(b_ptr + offset));
#line 613
      *(picture->y + (x + y * picture->y_stride)) = (uint8_t )__cil_tmp17;
      }
#line 611
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 610
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  if ((unsigned int )uv_csp != 3U) {
#line 620
    y = 0;
    {
#line 620
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 620
      if (! (y < height >> 1)) {
#line 620
        goto while_break___1;
      }
#line 621
      x = 0;
      {
#line 621
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 621
        if (! (x < width >> 1)) {
#line 621
          goto while_break___2;
        }
        {
#line 622
        src = 2 * (step * x + y * rgb_stride);
#line 622
        dst = x + y * picture->uv_stride;
#line 622
        r = (((int )*((r_ptr + src) + 0) + (int )*((r_ptr + src) + step)) + (int )*((r_ptr + src) + rgb_stride)) + (int )*((r_ptr + src) + (rgb_stride + step));
#line 622
        g = (((int )*((g_ptr + src) + 0) + (int )*((g_ptr + src) + step)) + (int )*((g_ptr + src) + rgb_stride)) + (int )*((g_ptr + src) + (rgb_stride + step));
#line 622
        b = (((int )*((b_ptr + src) + 0) + (int )*((b_ptr + src) + step)) + (int )*((b_ptr + src) + rgb_stride)) + (int )*((b_ptr + src) + (rgb_stride + step));
#line 622
        __cil_tmp23 = VP8RGBToU(r, g, b);
#line 622
        *(picture->u + dst) = (uint8_t )__cil_tmp23;
#line 622
        __cil_tmp24 = VP8RGBToV(r, g, b);
#line 622
        *(picture->v + dst) = (uint8_t )__cil_tmp24;
        }
#line 621
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 624
      if (width & 1) {
        {
#line 625
        src___0 = 2 * (step * x + y * rgb_stride);
#line 625
        dst___0 = x + y * picture->uv_stride;
#line 625
        r___0 = 2 * (int )*((r_ptr + src___0) + 0) + 2 * (int )*((r_ptr + src___0) + rgb_stride);
#line 625
        g___0 = 2 * (int )*((g_ptr + src___0) + 0) + 2 * (int )*((g_ptr + src___0) + rgb_stride);
#line 625
        b___0 = 2 * (int )*((b_ptr + src___0) + 0) + 2 * (int )*((b_ptr + src___0) + rgb_stride);
#line 625
        __cil_tmp30 = VP8RGBToU(r___0, g___0, b___0);
#line 625
        *(picture->u + dst___0) = (uint8_t )__cil_tmp30;
#line 625
        __cil_tmp31 = VP8RGBToV(r___0, g___0, b___0);
#line 625
        *(picture->v + dst___0) = (uint8_t )__cil_tmp31;
        }
      }
#line 620
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 628
    if (height & 1) {
#line 629
      x = 0;
      {
#line 629
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 629
        if (! (x < width >> 1)) {
#line 629
          goto while_break___3;
        }
        {
#line 630
        src___1 = 2 * (step * x + y * rgb_stride);
#line 630
        dst___1 = x + y * picture->uv_stride;
#line 630
        r___1 = 2 * (int )*((r_ptr + src___1) + 0) + 2 * (int )*((r_ptr + src___1) + step);
#line 630
        g___1 = 2 * (int )*((g_ptr + src___1) + 0) + 2 * (int )*((g_ptr + src___1) + step);
#line 630
        b___1 = 2 * (int )*((b_ptr + src___1) + 0) + 2 * (int )*((b_ptr + src___1) + step);
#line 630
        __cil_tmp37 = VP8RGBToU(r___1, g___1, b___1);
#line 630
        *(picture->u + dst___1) = (uint8_t )__cil_tmp37;
#line 630
        __cil_tmp38 = VP8RGBToV(r___1, g___1, b___1);
#line 630
        *(picture->v + dst___1) = (uint8_t )__cil_tmp38;
        }
#line 629
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 632
      if (width & 1) {
        {
#line 633
        src___2 = 2 * (step * x + y * rgb_stride);
#line 633
        dst___2 = x + y * picture->uv_stride;
#line 633
        r___2 = 4 * (int )*((r_ptr + src___2) + 0);
#line 633
        g___2 = 4 * (int )*((g_ptr + src___2) + 0);
#line 633
        b___2 = 4 * (int )*((b_ptr + src___2) + 0);
#line 633
        __cil_tmp44 = VP8RGBToU(r___2, g___2, b___2);
#line 633
        *(picture->u + dst___2) = (uint8_t )__cil_tmp44;
#line 633
        __cil_tmp45 = VP8RGBToV(r___2, g___2, b___2);
#line 633
        *(picture->v + dst___2) = (uint8_t )__cil_tmp45;
        }
      }
    }
  } else {
    {
#line 657
    MakeGray(picture);
    }
  }
#line 660
  if (has_alpha) {
#line 662
    y = 0;
    {
#line 662
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 662
      if (! (y < height)) {
#line 662
        goto while_break___4;
      }
#line 663
      x = 0;
      {
#line 663
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 663
        if (! (x < width)) {
#line 663
          goto while_break___5;
        }
#line 664
        *(picture->a + (x + y * picture->a_stride)) = *(a_ptr + (step * x + y * rgb_stride));
#line 663
        x ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 662
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 669
  return (1);
}
}
#line 672 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static int Import(WebPPicture *picture , uint8_t *rgb , int rgb_stride , int step ,
                  int swap_rb , int import_alpha ) 
{ 
  uint8_t *r_ptr ;
  int tmp ;
  uint8_t *g_ptr ;
  uint8_t *b_ptr ;
  int tmp___0 ;
  uint8_t *a_ptr ;
  uint8_t *tmp___1 ;
  int width ;
  int height ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int x ;
  int y ;
  int offset ;
  uint32_t argb ;
  int x___0 ;
  int y___0 ;
  int tmp___2 ;
  int offset___0 ;
  uint32_t argb___0 ;

  {
#line 675
  if (swap_rb) {
#line 675
    tmp = 2;
  } else {
#line 675
    tmp = 0;
  }
#line 675
  r_ptr = rgb + tmp;
#line 676
  g_ptr = rgb + 1;
#line 677
  if (swap_rb) {
#line 677
    tmp___0 = 0;
  } else {
#line 677
    tmp___0 = 2;
  }
#line 677
  b_ptr = rgb + tmp___0;
#line 678
  if (import_alpha) {
#line 678
    tmp___1 = rgb + 3;
  } else {
#line 678
    tmp___1 = (uint8_t *)((void *)0);
  }
#line 678
  a_ptr = tmp___1;
#line 679
  width = picture->width;
#line 680
  height = picture->height;
#line 682
  if (! picture->use_argb) {
    {
#line 683
    __cil_tmp16 = ImportYUVAFromRGBA(r_ptr, g_ptr, b_ptr, a_ptr, step, rgb_stride,
                                     picture);
    }
#line 683
    return (__cil_tmp16);
  }
#line 686
  if (import_alpha) {
#line 687
    picture->colorspace |= (unsigned int )4;
  } else {
#line 689
    picture->colorspace &= (unsigned int )(~ 4);
  }
  {
#line 691
  __cil_tmp17 = WebPPictureAlloc(picture);
  }
#line 691
  if (! __cil_tmp17) {
#line 691
    return (0);
  }
#line 693
  if (! import_alpha) {
#line 695
    y = 0;
    {
#line 695
    while (1) {
      while_continue: /* CIL Label */ ;
#line 695
      if (! (y < height)) {
#line 695
        goto while_break;
      }
#line 696
      x = 0;
      {
#line 696
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 696
        if (! (x < width)) {
#line 696
          goto while_break___0;
        }
#line 697
        offset = step * x + y * rgb_stride;
#line 698
        argb = ((4278190080U | (unsigned int )((int )*(r_ptr + offset) << 16)) | (unsigned int )((int )*(g_ptr + offset) << 8)) | (unsigned int )*(b_ptr + offset);
#line 703
        *(picture->argb + (x + y * picture->argb_stride)) = argb;
#line 696
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 695
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 709
    y___0 = 0;
    {
#line 709
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 709
      if (! (y___0 < height)) {
#line 709
        goto while_break___1;
      }
#line 710
      x___0 = 0;
      {
#line 710
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 710
        if (! (x___0 < width)) {
#line 710
          goto while_break___2;
        }
#line 711
        offset___0 = step * x___0 + y___0 * rgb_stride;
#line 712
        argb___0 = (uint32_t )(((((int )*(a_ptr + offset___0) << 24) | ((int )*(r_ptr + offset___0) << 16)) | ((int )*(g_ptr + offset___0) << 8)) | (int )*(b_ptr + offset___0));
#line 716
        *(picture->argb + (x___0 + y___0 * picture->argb_stride)) = argb___0;
#line 710
        x___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 709
      y___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 720
  return (1);
}
}
#line 728 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureImportRGB(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 730
  __cil_tmp4 = Import(picture, rgb, rgb_stride, 3, 0, 0);
  }
#line 730
  return (__cil_tmp4);
}
}
#line 733 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureImportBGR(WebPPicture *picture , uint8_t *rgb , int rgb_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 735
  __cil_tmp4 = Import(picture, rgb, rgb_stride, 3, 1, 0);
  }
#line 735
  return (__cil_tmp4);
}
}
#line 738 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureImportRGBA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 740
  __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 0, 1);
  }
#line 740
  return (__cil_tmp4);
}
}
#line 743 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureImportBGRA(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 745
  __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 1, 1);
  }
#line 745
  return (__cil_tmp4);
}
}
#line 748 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureImportRGBX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 750
  __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 0, 0);
  }
#line 750
  return (__cil_tmp4);
}
}
#line 753 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureImportBGRX(WebPPicture *picture , uint8_t *rgba , int rgba_stride ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 755
  __cil_tmp4 = Import(picture, rgba, rgba_stride, 4, 1, 0);
  }
#line 755
  return (__cil_tmp4);
}
}
#line 761 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureYUVAToARGB(WebPPicture *picture ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int y ;
  int width ;
  int height ;
  int argb_stride ;
  uint8_t *dst ;
  uint8_t *cur_u ;
  uint8_t *cur_v ;
  uint8_t *cur_y ;
  WebPUpsampleLinePairFunc upsample ;
  WebPUpsampleLinePairFunc __cil_tmp15 ;
  uint8_t *top_u ;
  uint8_t *top_v ;
  uint32_t *argb_dst ;
  uint8_t *src ;
  int x ;

  {
#line 762
  if (picture == (void *)0) {
#line 762
    return (0);
  }
#line 763
  if (picture->memory_ == (void *)0) {
    {
    {
    {
    {
#line 765
    __cil_tmp2 = WebPEncodingSetError(picture, (enum WebPEncodingError )3);
    }
    }
    }
    }
#line 765
    return (__cil_tmp2);
  } else
#line 763
  if (picture->y == (void *)0) {
    {
    {
    {
    {
#line 765
    __cil_tmp2 = WebPEncodingSetError(picture, (enum WebPEncodingError )3);
    }
    }
    }
    }
#line 765
    return (__cil_tmp2);
  } else
#line 763
  if (picture->u == (void *)0) {
    {
    {
    {
    {
#line 765
    __cil_tmp2 = WebPEncodingSetError(picture, (enum WebPEncodingError )3);
    }
    }
    }
    }
#line 765
    return (__cil_tmp2);
  } else
#line 763
  if (picture->v == (void *)0) {
    {
    {
    {
    {
#line 765
    __cil_tmp2 = WebPEncodingSetError(picture, (enum WebPEncodingError )3);
    }
    }
    }
    }
#line 765
    return (__cil_tmp2);
  }
#line 767
  if (picture->a == (void *)0) {
#line 767
    if ((unsigned int )picture->colorspace & 4U) {
      {
#line 768
      __cil_tmp3 = WebPEncodingSetError(picture, (enum WebPEncodingError )3);
      }
#line 768
      return (__cil_tmp3);
    }
  }
#line 770
  if (((unsigned int )picture->colorspace & 3U) != 0U) {
    {
#line 771
    __cil_tmp4 = WebPEncodingSetError(picture, (enum WebPEncodingError )4);
    }
#line 771
    return (__cil_tmp4);
  }
  {
#line 774
  __cil_tmp5 = PictureAllocARGB(picture);
  }
#line 774
  if (! __cil_tmp5) {
#line 774
    return (0);
  }
#line 779
  width = picture->width;
#line 780
  height = picture->height;
#line 781
  argb_stride = 4 * picture->argb_stride;
#line 782
  dst = (uint8_t *)picture->argb;
#line 783
  cur_u = picture->u;
#line 783
  cur_v = picture->v;
  {
#line 783
  cur_y = picture->y;
#line 784
  __cil_tmp15 = WebPGetLinePairConverter((int )test_endian.bytes[3] == 255);
#line 784
  upsample = __cil_tmp15;
#line 787
  (*upsample)((uint8_t *)((void *)0), cur_y, cur_u, cur_v, cur_u, cur_v, (uint8_t *)((void *)0),
              dst, width);
#line 788
  cur_y += picture->y_stride;
#line 789
  dst += argb_stride;
#line 791
  y = 1;
  }
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 791
    if (! (y + 1 < height)) {
#line 791
      goto while_break;
    }
    {
#line 792
    top_u = cur_u;
#line 793
    top_v = cur_v;
#line 794
    cur_u += picture->uv_stride;
#line 795
    cur_v += picture->uv_stride;
#line 796
    (*upsample)(cur_y, cur_y + picture->y_stride, top_u, top_v, cur_u, cur_v, dst,
                dst + argb_stride, width);
#line 798
    cur_y += 2 * picture->y_stride;
#line 799
    dst += 2 * argb_stride;
    }
#line 791
    y += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 802
  if (height > 1) {
#line 802
    if (! (height & 1)) {
      {
#line 803
      (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst,
                  (uint8_t *)((void *)0), width);
      }
    }
  }
#line 806
  if ((unsigned int )picture->colorspace & 4U) {
#line 807
    y = 0;
    {
#line 807
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 807
      if (! (y < height)) {
#line 807
        goto while_break___0;
      }
#line 808
      argb_dst = picture->argb + y * picture->argb_stride;
#line 809
      src = picture->a + y * picture->a_stride;
#line 811
      x = 0;
      {
#line 811
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 811
        if (! (x < width)) {
#line 811
          goto while_break___1;
        }
#line 812
        *(argb_dst + x) = (*(argb_dst + x) & 16777215U) | (unsigned int )((int )*(src + x) << 24);
#line 811
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 807
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 817
  return (1);
}
}
#line 820 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureARGBToYUVA(WebPPicture *picture , enum WebPEncCSP colorspace ) 
{ 
  int __cil_tmp3 ;
  uint8_t *argb ;
  uint8_t *r ;
  uint8_t *tmp ;
  uint8_t *g ;
  uint8_t *tmp___0 ;
  uint8_t *b ;
  uint8_t *tmp___1 ;
  uint8_t *a ;
  uint8_t *tmp___2 ;
  WebPPicture tmp___3 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 821
  if (picture == (void *)0) {
#line 821
    return (0);
  }
#line 822
  if (picture->argb == (void *)0) {
    {
#line 823
    __cil_tmp3 = WebPEncodingSetError(picture, (enum WebPEncodingError )3);
    }
#line 823
    return (__cil_tmp3);
  } else {
#line 825
    argb = (uint8_t *)picture->argb;
#line 826
    if ((int )test_endian.bytes[3] == 255) {
#line 826
      tmp = argb + 2;
    } else {
#line 826
      tmp = argb + 1;
    }
#line 826
    r = tmp;
#line 827
    if ((int )test_endian.bytes[3] == 255) {
#line 827
      tmp___0 = argb + 1;
    } else {
#line 827
      tmp___0 = argb + 2;
    }
#line 827
    g = tmp___0;
#line 828
    if ((int )test_endian.bytes[3] == 255) {
#line 828
      tmp___1 = argb + 0;
    } else {
#line 828
      tmp___1 = argb + 3;
    }
#line 828
    b = tmp___1;
#line 829
    if ((int )test_endian.bytes[3] == 255) {
#line 829
      tmp___2 = argb + 3;
    } else {
#line 829
      tmp___2 = argb + 0;
    }
    {
#line 829
    a = tmp___2;
#line 832
    tmp___3 = *picture;
#line 833
    PictureResetARGB(& tmp___3);
#line 834
    tmp___3.use_argb = 0;
#line 835
    tmp___3.colorspace = (enum WebPEncCSP )((unsigned int )colorspace & 3U);
#line 836
    __cil_tmp14 = ImportYUVAFromRGBA(r, g, b, a, 4, 4 * picture->argb_stride, & tmp___3);
    }
#line 836
    if (! __cil_tmp14) {
      {
#line 837
      __cil_tmp15 = WebPEncodingSetError(picture, (enum WebPEncodingError )1);
      }
#line 837
      return (__cil_tmp15);
    }
#line 840
    tmp___3.argb = picture->argb;
#line 841
    tmp___3.argb_stride = picture->argb_stride;
#line 842
    tmp___3.memory_argb_ = picture->memory_argb_;
#line 843
    *picture = tmp___3;
  }
#line 845
  return (1);
}
}
#line 853 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static int is_transparent_area(uint8_t *ptr , int stride , int size ) 
{ 
  int y ;
  int x ;

  {
#line 855
  y = 0;
  {
#line 855
  while (1) {
    while_continue: /* CIL Label */ ;
#line 855
    if (! (y < size)) {
#line 855
      goto while_break;
    }
#line 856
    x = 0;
    {
#line 856
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 856
      if (! (x < size)) {
#line 856
        goto while_break___0;
      }
#line 857
      if (*(ptr + x)) {
#line 858
        return (0);
      }
#line 856
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 861
    ptr += stride;
#line 855
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  return (1);
}
}
#line 866 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
__inline static void flatten(uint8_t *ptr , int v , int stride , int size ) 
{ 
  int y ;

  {
#line 868
  y = 0;
  {
#line 868
  while (1) {
    while_continue: /* CIL Label */ ;
#line 868
    if (! (y < size)) {
#line 868
      goto while_break;
    }
    {
#line 869
    memset(ptr, v, (unsigned long )size);
#line 870
    ptr += stride;
    }
#line 868
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 874 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
void WebPCleanupTransparentArea(WebPPicture *pic ) 
{ 
  int x ;
  int y ;
  int w ;
  int h ;
  uint8_t *a_ptr ;
  int values[3] ;
  unsigned int tmp ;
  int need_reset ;
  int off_a ;
  int off_y ;
  int off_uv ;
  int __cil_tmp13 ;

  {
#line 877
  values[0] = 0;
#line 877
  tmp = (unsigned int )1;
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (tmp >= 3) {
#line 877
      goto while_break;
    }
#line 877
    values[tmp] = 0;
#line 877
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 879
  if (pic == (void *)0) {
#line 879
    return;
  }
#line 881
  a_ptr = pic->a;
#line 882
  if (a_ptr == (void *)0) {
#line 882
    return;
  }
#line 884
  w = pic->width / 8;
#line 885
  h = pic->height / 8;
#line 886
  y = 0;
  {
#line 886
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 886
    if (! (y < h)) {
#line 886
      goto while_break___0;
    }
#line 887
    need_reset = 1;
#line 888
    x = 0;
    {
#line 888
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 888
      if (! (x < w)) {
#line 888
        goto while_break___1;
      }
      {
#line 889
      off_a = (y * pic->a_stride + x) * 8;
#line 890
      off_y = (y * pic->y_stride + x) * 8;
#line 891
      off_uv = (y * pic->uv_stride + x) * 4;
#line 892
      __cil_tmp13 = is_transparent_area(a_ptr + off_a, pic->a_stride, 8);
      }
#line 892
      if (__cil_tmp13) {
#line 893
        if (need_reset) {
#line 894
          values[0] = (int )*(pic->y + off_y);
#line 895
          values[1] = (int )*(pic->u + off_uv);
#line 896
          values[2] = (int )*(pic->v + off_uv);
#line 897
          need_reset = 0;
        }
        {
#line 899
        flatten(pic->y + off_y, values[0], pic->y_stride, 8);
#line 900
        flatten(pic->u + off_uv, values[1], pic->uv_stride, 4);
#line 901
        flatten(pic->v + off_uv, values[2], pic->uv_stride, 4);
        }
      } else {
#line 903
        need_reset = 1;
      }
#line 888
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 886
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 922 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static float AccumulateLSIM(uint8_t *src , int src_stride , uint8_t *ref , int ref_stride ,
                            int w , int h ) 
{ 
  int x ;
  int y ;
  double total_sse ;
  int y_0 ;
  int tmp ;
  int y_1 ;
  int tmp___0 ;
  int x_0 ;
  int tmp___1 ;
  int x_1 ;
  int tmp___2 ;
  double best_sse ;
  double value ;
  int i ;
  int j ;
  uint8_t *s ;
  double sse ;

  {
#line 926
  total_sse = 0.;
#line 927
  y = 0;
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;
#line 927
    if (! (y < h)) {
#line 927
      goto while_break;
    }
#line 928
    if (y - 2 < 0) {
#line 928
      tmp = 0;
    } else {
#line 928
      tmp = y - 2;
    }
#line 928
    y_0 = tmp;
#line 929
    if ((y + 2) + 1 >= h) {
#line 929
      tmp___0 = h;
    } else {
#line 929
      tmp___0 = (y + 2) + 1;
    }
#line 929
    y_1 = tmp___0;
#line 930
    x = 0;
    {
#line 930
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 930
      if (! (x < w)) {
#line 930
        goto while_break___0;
      }
#line 931
      if (x - 2 < 0) {
#line 931
        tmp___1 = 0;
      } else {
#line 931
        tmp___1 = x - 2;
      }
#line 931
      x_0 = tmp___1;
#line 932
      if ((x + 2) + 1 >= w) {
#line 932
        tmp___2 = w;
      } else {
#line 932
        tmp___2 = (x + 2) + 1;
      }
#line 932
      x_1 = tmp___2;
#line 933
      best_sse = 255. * 255.;
#line 934
      value = (double )*(ref + (y * ref_stride + x));
#line 936
      j = y_0;
      {
#line 936
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 936
        if (! (j < y_1)) {
#line 936
          goto while_break___1;
        }
#line 937
        s = src + j * src_stride;
#line 938
        i = x_0;
        {
#line 938
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 938
          if (! (i < x_1)) {
#line 938
            goto while_break___2;
          }
#line 939
          sse = (double )((double )((int )*(s + i)) - value) * ((double )((int )*(s + i)) - value);
#line 940
          if (sse < best_sse) {
#line 940
            best_sse = sse;
          }
#line 938
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 936
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 943
      total_sse += best_sse;
#line 930
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 927
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 946
  return ((float )total_sse);
}
}
#line 954 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static double const   kMinDistortion_dB  =    99.;
#line 955 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static float GetPSNR___0(double v ) 
{ 
  double __cil_tmp2 ;
  double tmp ;

  {
#line 956
  if (v > 0.) {
    {
#line 956
    __cil_tmp2 = log(v / ((double )255 * 255.));
#line 956
    tmp = - 4.3429448 * __cil_tmp2;
    }
  } else {
#line 956
    tmp = (double )kMinDistortion_dB;
  }
#line 956
  return ((float )((int )tmp));
}
}
#line 960 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
int WebPPictureDistortion(WebPPicture *src , WebPPicture *ref , int type , float result[5] ) 
{ 
  DistoStats stats[5] ;
  int has_alpha ;
  int uv_w ;
  int uv_h ;
  float sse[4] ;
  float __cil_tmp10 ;
  float __cil_tmp11 ;
  float __cil_tmp12 ;
  float __cil_tmp13 ;
  float tmp ;
  float __cil_tmp15 ;
  float __cil_tmp16 ;
  float __cil_tmp17 ;
  float __cil_tmp18 ;
  double total_sse ;
  int total_pixels ;
  float __cil_tmp21 ;
  int c ;
  double v ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;
  double tmp___0 ;
  double v___0 ;
  double __cil_tmp28 ;
  float __cil_tmp29 ;

  {
#line 966
  if (src == (void *)0) {
#line 972
    return (0);
  } else
#line 966
  if (ref == (void *)0) {
#line 972
    return (0);
  } else
#line 966
  if (src->width != ref->width) {
#line 972
    return (0);
  } else
#line 966
  if (src->height != ref->height) {
#line 972
    return (0);
  } else
#line 966
  if (src->y == (void *)0) {
#line 972
    return (0);
  } else
#line 966
  if (ref->y == (void *)0) {
#line 972
    return (0);
  } else
#line 966
  if (src->u == (void *)0) {
#line 972
    return (0);
  } else
#line 966
  if (ref->u == (void *)0) {
#line 972
    return (0);
  } else
#line 966
  if (src->v == (void *)0) {
#line 972
    return (0);
  } else
#line 966
  if (ref->v == (void *)0) {
#line 972
    return (0);
  } else
#line 966
  if (result == (void *)0) {
#line 972
    return (0);
  }
#line 975
  if (src->use_argb == 1) {
#line 976
    return (0);
  } else
#line 975
  if (src->use_argb != ref->use_argb) {
#line 976
    return (0);
  }
#line 979
  has_alpha = ! (! ((unsigned int )src->colorspace & 4U));
#line 980
  if (src->a == (void *)0) {
    _L___10: /* CIL Label */ 
#line 980
    if (has_alpha) {
#line 982
      return (0);
    } else {
#line 980
      goto _L;
    }
  } else
#line 980
  if (ref->a == (void *)0) {
#line 980
    goto _L___10;
  } else
  _L: /* CIL Label */ 
#line 980
  if (has_alpha != ! (! ((unsigned int )ref->colorspace & 4U))) {
#line 982
    return (0);
  }
  {
#line 985
  memset((DistoStats *)stats, 0, sizeof(stats));
#line 987
  uv_w = (src->width + 1) >> 1;
#line 988
  uv_h = (src->height + 1) >> 1;
  }
#line 989
  if (type >= 2) {
    {
#line 991
    sse[0] = AccumulateLSIM(src->y, src->y_stride, ref->y, ref->y_stride, src->width,
                            src->height);
#line 993
    sse[1] = AccumulateLSIM(src->u, src->uv_stride, ref->u, ref->uv_stride, uv_w,
                            uv_h);
#line 995
    sse[2] = AccumulateLSIM(src->v, src->uv_stride, ref->v, ref->uv_stride, uv_w,
                            uv_h);
    }
#line 997
    if (has_alpha) {
      {
#line 997
      __cil_tmp13 = AccumulateLSIM(src->a, src->a_stride, ref->a, ref->a_stride, src->width,
                                   src->height);
#line 997
      tmp = __cil_tmp13;
      }
    } else {
#line 997
      tmp = 0.f;
    }
    {
#line 997
    sse[3] = tmp;
#line 1001
    result[0] = GetPSNR___0((double )(sse[0] / (float )(src->width * src->height)));
#line 1002
    result[1] = GetPSNR___0((double )(sse[1] / (float )(uv_w * uv_h)));
#line 1003
    result[2] = GetPSNR___0((double )(sse[2] / (float )(uv_w * uv_h)));
#line 1004
    result[3] = GetPSNR___0((double )(sse[3] / (float )(src->width * src->height)));
#line 1006
    total_sse = (double )((sse[0] + sse[1]) + sse[2]);
#line 1007
    total_pixels = src->width * src->height + (2 * uv_w) * uv_h;
    }
#line 1008
    if (has_alpha) {
#line 1009
      total_pixels += src->width * src->height;
#line 1010
      total_sse += (double )sse[3];
    }
    {
#line 1012
    result[4] = GetPSNR___0(total_sse / (double )total_pixels);
    }
  } else {
    {
#line 1016
    VP8SSIMAccumulatePlane(src->y, src->y_stride, ref->y, ref->y_stride, src->width,
                           src->height, & stats[0]);
#line 1019
    VP8SSIMAccumulatePlane(src->u, src->uv_stride, ref->u, ref->uv_stride, uv_w, uv_h,
                           & stats[1]);
#line 1022
    VP8SSIMAccumulatePlane(src->v, src->uv_stride, ref->v, ref->uv_stride, uv_w, uv_h,
                           & stats[2]);
    }
#line 1025
    if (has_alpha) {
      {
#line 1026
      VP8SSIMAccumulatePlane(src->a, src->a_stride, ref->a, ref->a_stride, src->width,
                             src->height, & stats[3]);
      }
    }
#line 1030
    c = 0;
    {
#line 1030
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1030
      if (! (c <= 4)) {
#line 1030
        goto while_break;
      }
#line 1031
      if (type == 1) {
        {
#line 1032
        __cil_tmp24 = VP8SSIMGet(& stats[c]);
#line 1032
        v = __cil_tmp24;
        }
#line 1033
        if (v < 1.) {
          {
#line 1033
          __cil_tmp25 = log10(1. - v);
#line 1033
          tmp___0 = - 10. * __cil_tmp25;
          }
        } else {
#line 1033
          tmp___0 = (double )kMinDistortion_dB;
        }
#line 1033
        result[c] = (float )((int )tmp___0);
      } else {
        {
#line 1036
        __cil_tmp28 = VP8SSIMGetSquaredError(& stats[c]);
#line 1036
        v___0 = __cil_tmp28;
#line 1037
        result[c] = GetPSNR___0(v___0);
        }
      }
#line 1040
      if (c < 4) {
        {
#line 1040
        VP8SSIMAddStats(& stats[c], & stats[4]);
        }
      }
#line 1030
      c ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1043
  return (1);
}
}
#line 1051 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
static size_t Encode(uint8_t *rgba , int width , int height , int stride , Importer import ,
                     float quality_factor , int lossless , uint8_t **output ) 
{ 
  WebPPicture pic ;
  WebPConfig config ;
  WebPMemoryWriter wrt ;
  int ok ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 1059
  __cil_tmp14 = WebPPictureInit(& pic);
  }
  {
#line 1059
  __cil_tmp13 = WebPConfigPreset___0(& config, (enum WebPPreset )0, quality_factor);
  }
#line 1059
  if (! __cil_tmp13) {
#line 1061
    return ((size_t )0);
  } else
#line 1059
  if (! __cil_tmp14) {
#line 1061
    return ((size_t )0);
  }
  {
#line 1064
  config.lossless = ! (! lossless);
#line 1065
  pic.use_argb = ! (! lossless);
#line 1066
  pic.width = width;
#line 1067
  pic.height = height;
#line 1068
  pic.writer = & WebPMemoryWrite;
#line 1069
  pic.custom_ptr = & wrt;
#line 1070
  WebPMemoryWriterInit(& wrt);
#line 1072
  __cil_tmp16 = WebPEncode(& config, & pic);
  }
  {
#line 1072
  __cil_tmp15 = (*import)(& pic, rgba, stride);
#line 1072
  ok = __cil_tmp15 && __cil_tmp16;
#line 1073
  WebPPictureFree(& pic);
  }
#line 1074
  if (! ok) {
    {
#line 1075
    free(wrt.mem);
#line 1076
    *output = (uint8_t *)((void *)0);
    }
#line 1077
    return ((size_t )0);
  }
#line 1079
  *output = wrt.mem;
#line 1080
  return (wrt.size);
}
}
#line 1089 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
size_t WebPEncodeRGB(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 1089
  __cil_tmp7 = Encode(in, w, h, bps, & WebPPictureImportRGB, q, 0, out);
  }
#line 1089
  return (__cil_tmp7);
}
}
#line 1090 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
size_t WebPEncodeBGR(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 1090
  __cil_tmp7 = Encode(in, w, h, bps, & WebPPictureImportBGR, q, 0, out);
  }
#line 1090
  return (__cil_tmp7);
}
}
#line 1091 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
size_t WebPEncodeRGBA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 1091
  __cil_tmp7 = Encode(in, w, h, bps, & WebPPictureImportRGBA, q, 0, out);
  }
#line 1091
  return (__cil_tmp7);
}
}
#line 1092 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
size_t WebPEncodeBGRA(uint8_t *in , int w , int h , int bps , float q , uint8_t **out ) 
{ 
  size_t __cil_tmp7 ;

  {
  {
#line 1092
  __cil_tmp7 = Encode(in, w, h, bps, & WebPPictureImportBGRA, q, 0, out);
  }
#line 1092
  return (__cil_tmp7);
}
}
#line 1102 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
size_t WebPEncodeLosslessRGB(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 1102
  __cil_tmp6 = Encode(in, w, h, bps, & WebPPictureImportRGB, (float )70., 1, out);
  }
#line 1102
  return (__cil_tmp6);
}
}
#line 1103 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
size_t WebPEncodeLosslessBGR(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 1103
  __cil_tmp6 = Encode(in, w, h, bps, & WebPPictureImportBGR, (float )70., 1, out);
  }
#line 1103
  return (__cil_tmp6);
}
}
#line 1104 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
size_t WebPEncodeLosslessRGBA(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 1104
  __cil_tmp6 = Encode(in, w, h, bps, & WebPPictureImportRGBA, (float )70., 1, out);
  }
#line 1104
  return (__cil_tmp6);
}
}
#line 1105 "/doner/libwebp/libwebp-v0.3.0/src/enc/picture.c"
size_t WebPEncodeLosslessBGRA(uint8_t *in , int w , int h , int bps , uint8_t **out ) 
{ 
  size_t __cil_tmp6 ;

  {
  {
#line 1105
  __cil_tmp6 = Encode(in, w, h, bps, & WebPPictureImportBGRA, (float )70., 1, out);
  }
#line 1105
  return (__cil_tmp6);
}
}
#line 22 "/doner/libwebp/libwebp-v0.3.0/src/enc/layer.c"
void VP8EncInitLayer(VP8Encoder *enc ) 
{ 


  {
#line 23
  enc->use_layer_ = (enc->pic_)->u0 != (void *)0;
#line 24
  enc->layer_data_size_ = (size_t )0;
#line 25
  enc->layer_data_ = (uint8_t *)((void *)0);
#line 26
  if (enc->use_layer_) {
    {
#line 27
    VP8BitWriterInit(& enc->layer_bw_, (size_t )((enc->mb_w_ * enc->mb_h_) * 3));
    }
  }
  return;
}
}
#line 31 "/doner/libwebp/libwebp-v0.3.0/src/enc/layer.c"
void VP8EncCodeLayerBlock(VP8EncIterator *it ) 
{ 


  {
  return;
}
}
#line 35 "/doner/libwebp/libwebp-v0.3.0/src/enc/layer.c"
int VP8EncFinishLayer(VP8Encoder *enc ) 
{ 
  uint8_t *__cil_tmp2 ;
  size_t __cil_tmp3 ;

  {
#line 36
  if (enc->use_layer_) {
    {
#line 37
    enc->layer_data_ = VP8BitWriterFinish(& enc->layer_bw_);
#line 38
    enc->layer_data_size_ = VP8BitWriterSize(& enc->layer_bw_);
    }
  }
#line 40
  return (1);
}
}
#line 43 "/doner/libwebp/libwebp-v0.3.0/src/enc/layer.c"
void VP8EncDeleteLayer(VP8Encoder *enc ) 
{ 


  {
  {
#line 44
  free(enc->layer_data_);
  }
  return;
}
}
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
static void InitLeft(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int tmp ;

  {
#line 25
  enc = it->enc_;
#line 26
  if (it->y_ > 0) {
#line 26
    tmp = 129;
  } else {
#line 26
    tmp = 127;
  }
  {
#line 26
  *(enc->v_left_ + - 1) = (uint8_t )tmp;
#line 26
  *(enc->u_left_ + - 1) = *(enc->v_left_ + - 1);
#line 26
  *(enc->y_left_ + - 1) = *(enc->u_left_ + - 1);
#line 28
  memset(enc->y_left_, 129, (unsigned long )16);
#line 29
  memset(enc->u_left_, 129, (unsigned long )8);
#line 30
  memset(enc->v_left_, 129, (unsigned long )8);
#line 31
  it->left_nz_[8] = 0;
  }
  return;
}
}
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
static void InitTop(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  size_t top_size ;

  {
  {
#line 35
  enc = it->enc_;
#line 36
  top_size = (size_t )(enc->mb_w_ * 16);
#line 37
  memset(enc->y_top_, 127, 2UL * top_size);
#line 38
  memset(enc->nz_, 0, (unsigned long )enc->mb_w_ * sizeof(*(enc->nz_)));
  }
  return;
}
}
#line 41 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8IteratorReset(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;

  {
  {
#line 42
  enc = it->enc_;
#line 43
  it->x_ = 0;
#line 44
  it->y_ = 0;
#line 45
  it->y_offset_ = 0;
#line 46
  it->uv_offset_ = 0;
#line 47
  it->mb_ = enc->mb_info_;
#line 48
  it->preds_ = enc->preds_;
#line 49
  it->nz_ = enc->nz_;
#line 50
  it->bw_ = & enc->parts_[0];
#line 51
  it->done_ = enc->mb_w_ * enc->mb_h_;
#line 52
  InitTop(it);
#line 53
  InitLeft(it);
#line 54
  memset((uint64_t (*)[3])it->bit_count_, 0, sizeof(it->bit_count_));
#line 55
  it->do_trellis_ = 0;
  }
  return;
}
}
#line 58 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8IteratorInit(VP8Encoder *enc , VP8EncIterator *it ) 
{ 


  {
  {
#line 59
  it->enc_ = enc;
#line 60
  it->y_stride_ = (enc->pic_)->y_stride;
#line 61
  it->uv_stride_ = (enc->pic_)->uv_stride;
#line 63
  it->yuv_in_ = enc->yuv_in_;
#line 64
  it->yuv_out_ = enc->yuv_out_;
#line 65
  it->yuv_out2_ = enc->yuv_out2_;
#line 66
  it->yuv_p_ = enc->yuv_p_;
#line 67
  it->lf_stats_ = enc->lf_stats_;
#line 68
  it->percent0_ = enc->percent_;
#line 69
  VP8IteratorReset(it);
  }
  return;
}
}
#line 72 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
int VP8IteratorProgress(VP8EncIterator *it , int delta ) 
{ 
  VP8Encoder *enc ;
  int percent ;
  int tmp ;
  int __cil_tmp6 ;

  {
#line 73
  enc = it->enc_;
#line 74
  if ((enc->pic_)->progress_hook) {
#line 74
    if (delta) {
#line 75
      if (enc->mb_h_ <= 1) {
#line 75
        tmp = it->percent0_;
      } else {
#line 75
        tmp = it->percent0_ + (delta * it->y_) / (enc->mb_h_ - 1);
      }
      {
#line 75
      percent = tmp;
#line 78
      __cil_tmp6 = WebPReportProgress(enc->pic_, percent, & enc->percent_);
      }
#line 78
      return (__cil_tmp6);
    }
  }
#line 80
  return (1);
}
}
#line 87 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
static void ImportBlock(uint8_t *src , int src_stride , uint8_t *dst , int w , int h ,
                        int size ) 
{ 
  int i ;

  {
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i < h)) {
#line 90
      goto while_break;
    }
    {
#line 91
    memcpy(dst, src, (unsigned long )w);
    }
#line 92
    if (w < size) {
      {
#line 93
      memset(dst + w, (int )*(dst + (w - 1)), (unsigned long )(size - w));
      }
    }
#line 95
    dst += 16;
#line 96
    src += src_stride;
#line 90
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  i = h;
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 98
    if (! (i < size)) {
#line 98
      goto while_break___0;
    }
    {
#line 99
    memcpy(dst, dst - 16, (unsigned long )size);
#line 100
    dst += 16;
    }
#line 98
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 104 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8IteratorImport(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int x ;
  int y ;
  WebPPicture *pic ;
  uint8_t *ysrc ;
  uint8_t *usrc ;
  uint8_t *vsrc ;
  uint8_t *ydst ;
  uint8_t *udst ;
  uint8_t *vdst ;
  int w ;
  int h ;
  int uv_w ;
  int uv_h ;

  {
#line 105
  enc = it->enc_;
#line 106
  x = it->x_;
#line 106
  y = it->y_;
#line 107
  pic = enc->pic_;
#line 108
  ysrc = pic->y + (y * pic->y_stride + x) * 16;
#line 109
  usrc = pic->u + (y * pic->uv_stride + x) * 8;
#line 110
  vsrc = pic->v + (y * pic->uv_stride + x) * 8;
#line 111
  ydst = it->yuv_in_ + 0;
#line 112
  udst = it->yuv_in_ + 256;
#line 113
  vdst = it->yuv_in_ + 264;
#line 114
  w = pic->width - x * 16;
#line 115
  h = pic->height - y * 16;
#line 117
  if (w > 16) {
#line 117
    w = 16;
  }
#line 118
  if (h > 16) {
#line 118
    h = 16;
  }
  {
#line 121
  ImportBlock(ysrc, pic->y_stride, ydst, w, h, 16);
#line 124
  uv_w = (w + 1) >> 1;
#line 125
  uv_h = (h + 1) >> 1;
#line 126
  ImportBlock(usrc, pic->uv_stride, udst, uv_w, uv_h, 8);
#line 127
  ImportBlock(vsrc, pic->uv_stride, vdst, uv_w, uv_h, 8);
  }
  return;
}
}
#line 134 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
static void ExportBlock(uint8_t *src , uint8_t *dst , int dst_stride , int w , int h ) 
{ 
  int __cil_tmp6 ;

  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    __cil_tmp6 = h;
#line 136
    h --;
#line 136
    if (! (__cil_tmp6 > 0)) {
#line 136
      goto while_break;
    }
    {
#line 137
    memcpy(dst, src, (unsigned long )w);
#line 138
    dst += dst_stride;
#line 139
    src += 16;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 143 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8IteratorExport(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int x ;
  int y ;
  uint8_t *ysrc ;
  uint8_t *usrc ;
  uint8_t *vsrc ;
  WebPPicture *pic ;
  uint8_t *ydst ;
  uint8_t *udst ;
  uint8_t *vdst ;
  int w ;
  int h ;
  int uv_w ;
  int uv_h ;

  {
#line 144
  enc = it->enc_;
#line 145
  if ((enc->config_)->show_compressed) {
#line 146
    x = it->x_;
#line 146
    y = it->y_;
#line 147
    ysrc = it->yuv_out_ + 0;
#line 148
    usrc = it->yuv_out_ + 256;
#line 149
    vsrc = it->yuv_out_ + 264;
#line 150
    pic = enc->pic_;
#line 151
    ydst = pic->y + (y * pic->y_stride + x) * 16;
#line 152
    udst = pic->u + (y * pic->uv_stride + x) * 8;
#line 153
    vdst = pic->v + (y * pic->uv_stride + x) * 8;
#line 154
    w = pic->width - x * 16;
#line 155
    h = pic->height - y * 16;
#line 157
    if (w > 16) {
#line 157
      w = 16;
    }
#line 158
    if (h > 16) {
#line 158
      h = 16;
    }
    {
#line 161
    ExportBlock(ysrc, ydst, pic->y_stride, w, h);
#line 164
    uv_w = (w + 1) >> 1;
#line 165
    uv_h = (h + 1) >> 1;
#line 166
    ExportBlock(usrc, udst, pic->uv_stride, uv_w, uv_h);
#line 167
    ExportBlock(vsrc, vdst, pic->uv_stride, uv_w, uv_h);
    }
  }
  return;
}
}
#line 189 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8IteratorNzToBytes(VP8EncIterator *it ) 
{ 
  int tnz ;
  int lnz ;
  int *top_nz ;
  int *left_nz ;

  {
#line 190
  tnz = (int )*(it->nz_ + 0);
#line 190
  lnz = (int )*(it->nz_ + - 1);
#line 191
  top_nz = (int *)it->top_nz_;
#line 192
  left_nz = (int *)it->left_nz_;
#line 195
  *(top_nz + 0) = ! (! (tnz & (1 << 12)));
#line 196
  *(top_nz + 1) = ! (! (tnz & (1 << 13)));
#line 197
  *(top_nz + 2) = ! (! (tnz & (1 << 14)));
#line 198
  *(top_nz + 3) = ! (! (tnz & (1 << 15)));
#line 200
  *(top_nz + 4) = ! (! (tnz & (1 << 18)));
#line 201
  *(top_nz + 5) = ! (! (tnz & (1 << 19)));
#line 203
  *(top_nz + 6) = ! (! (tnz & (1 << 22)));
#line 204
  *(top_nz + 7) = ! (! (tnz & (1 << 23)));
#line 206
  *(top_nz + 8) = ! (! (tnz & (1 << 24)));
#line 209
  *(left_nz + 0) = ! (! (lnz & (1 << 3)));
#line 210
  *(left_nz + 1) = ! (! (lnz & (1 << 7)));
#line 211
  *(left_nz + 2) = ! (! (lnz & (1 << 11)));
#line 212
  *(left_nz + 3) = ! (! (lnz & (1 << 15)));
#line 214
  *(left_nz + 4) = ! (! (lnz & (1 << 17)));
#line 215
  *(left_nz + 5) = ! (! (lnz & (1 << 19)));
#line 217
  *(left_nz + 6) = ! (! (lnz & (1 << 21)));
#line 218
  *(left_nz + 7) = ! (! (lnz & (1 << 23)));
  return;
}
}
#line 222 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8IteratorBytesToNz(VP8EncIterator *it ) 
{ 
  uint32_t nz ;
  int const   *top_nz ;
  int const   *left_nz ;

  {
#line 223
  nz = (uint32_t )0;
#line 224
  top_nz = (int const   *)((int *)it->top_nz_);
#line 225
  left_nz = (int const   *)((int *)it->left_nz_);
#line 227
  nz |= (unsigned int )((*(top_nz + 0) << 12) | (*(top_nz + 1) << 13));
#line 228
  nz |= (unsigned int )((*(top_nz + 2) << 14) | (*(top_nz + 3) << 15));
#line 229
  nz |= (unsigned int )((*(top_nz + 4) << 18) | (*(top_nz + 5) << 19));
#line 230
  nz |= (unsigned int )((*(top_nz + 6) << 22) | (*(top_nz + 7) << 23));
#line 231
  nz |= (unsigned int )(*(top_nz + 8) << 24);
#line 233
  nz |= (unsigned int )((*(left_nz + 0) << 3) | (*(left_nz + 1) << 7));
#line 234
  nz |= (unsigned int )(*(left_nz + 2) << 11);
#line 235
  nz |= (unsigned int )((*(left_nz + 4) << 17) | (*(left_nz + 6) << 21));
#line 237
  *(it->nz_) = nz;
  return;
}
}
#line 245 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
int VP8IteratorNext(VP8EncIterator *it , uint8_t *block_to_save ) 
{ 
  VP8Encoder *enc ;
  int x ;
  int y ;
  uint8_t *ysrc ;
  uint8_t *usrc ;
  int i ;
  VP8MBInfo *__cil_tmp9 ;
  uint32_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 247
  enc = it->enc_;
#line 248
  if (block_to_save) {
#line 249
    x = it->x_;
#line 249
    y = it->y_;
#line 250
    ysrc = block_to_save + 0;
#line 251
    usrc = block_to_save + 256;
#line 252
    if (x < enc->mb_w_ - 1) {
#line 254
      i = 0;
      {
#line 254
      while (1) {
        while_continue: /* CIL Label */ ;
#line 254
        if (! (i < 16)) {
#line 254
          goto while_break;
        }
#line 255
        *(enc->y_left_ + i) = *(ysrc + (15 + i * 16));
#line 254
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 257
      i = 0;
      {
#line 257
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 257
        if (! (i < 8)) {
#line 257
          goto while_break___0;
        }
#line 258
        *(enc->u_left_ + i) = *(usrc + (7 + i * 16));
#line 259
        *(enc->v_left_ + i) = *(usrc + (15 + i * 16));
#line 257
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 262
      *(enc->y_left_ + - 1) = *(enc->y_top_ + (x * 16 + 15));
#line 263
      *(enc->u_left_ + - 1) = *(enc->uv_top_ + (x * 16 + 7));
#line 264
      *(enc->v_left_ + - 1) = *(enc->uv_top_ + ((x * 16 + 8) + 7));
    }
#line 266
    if (y < enc->mb_h_ - 1) {
      {
#line 267
      memcpy(enc->y_top_ + x * 16, ysrc + 240, (unsigned long )16);
#line 268
      memcpy(enc->uv_top_ + x * 16, usrc + 112, (unsigned long )16);
      }
    }
  }
#line 272
  (it->mb_) ++;
#line 273
  it->preds_ += 4;
#line 274
  (it->nz_) ++;
#line 275
  (it->x_) ++;
#line 276
  if (it->x_ == enc->mb_w_) {
    {
#line 277
    it->x_ = 0;
#line 278
    (it->y_) ++;
#line 279
    it->bw_ = & enc->parts_[it->y_ & (enc->num_parts_ - 1)];
#line 280
    it->preds_ = enc->preds_ + (it->y_ * 4) * enc->preds_w_;
#line 281
    it->nz_ = enc->nz_;
#line 282
    InitLeft(it);
    }
  }
#line 284
  (it->done_) --;
#line 284
  return (0 < it->done_);
}
}
#line 290 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8SetIntra16Mode(VP8EncIterator *it , int mode ) 
{ 
  uint8_t *preds ;
  int y ;

  {
#line 291
  preds = it->preds_;
#line 293
  y = 0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! (y < 4)) {
#line 293
      goto while_break;
    }
    {
#line 294
    memset(preds, mode, (unsigned long )4);
#line 295
    preds += (it->enc_)->preds_w_;
    }
#line 293
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  (it->mb_)->type_ = (unsigned int )1;
  return;
}
}
#line 300 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8SetIntra4Mode(VP8EncIterator *it , uint8_t *modes ) 
{ 
  uint8_t *preds ;
  int y ;

  {
#line 301
  preds = it->preds_;
#line 303
  y = 4;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (y > 0)) {
#line 303
      goto while_break;
    }
    {
#line 304
    memcpy(preds, modes, 4UL * sizeof(*modes));
#line 305
    preds += (it->enc_)->preds_w_;
#line 306
    modes += 4;
    }
#line 303
    y --;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  (it->mb_)->type_ = (unsigned int )0;
  return;
}
}
#line 311 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8SetIntraUVMode(VP8EncIterator *it , int mode ) 
{ 


  {
#line 312
  (it->mb_)->uv_mode_ = (unsigned int )mode;
  return;
}
}
#line 315 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8SetSkip(VP8EncIterator *it , int skip ) 
{ 


  {
#line 316
  (it->mb_)->skip_ = (unsigned int )skip;
  return;
}
}
#line 319 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8SetSegment(VP8EncIterator *it , int segment ) 
{ 


  {
#line 320
  (it->mb_)->segment_ = (unsigned int )segment;
  return;
}
}
#line 355 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
static uint8_t VP8TopLeftI4[16]  = 
#line 355
  {      (uint8_t )17,      (uint8_t )21,      (uint8_t )25,      (uint8_t )29, 
        (uint8_t )13,      (uint8_t )17,      (uint8_t )21,      (uint8_t )25, 
        (uint8_t )9,      (uint8_t )13,      (uint8_t )17,      (uint8_t )21, 
        (uint8_t )5,      (uint8_t )9,      (uint8_t )13,      (uint8_t )17};
#line 362 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
void VP8IteratorStartI4(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  int i ;

  {
#line 363
  enc = it->enc_;
#line 366
  it->i4_ = 0;
#line 367
  it->i4_top_ = (uint8_t *)it->i4_boundary_ + (int )VP8TopLeftI4[0];
#line 370
  i = 0;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (i < 17)) {
#line 370
      goto while_break;
    }
#line 371
    it->i4_boundary_[i] = *(enc->y_left_ + (15 - i));
#line 370
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  i = 0;
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 373
    if (! (i < 16)) {
#line 373
      goto while_break___0;
    }
#line 374
    it->i4_boundary_[17 + i] = *(enc->y_top_ + (it->x_ * 16 + i));
#line 373
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 377
  if (it->x_ < enc->mb_w_ - 1) {
#line 378
    i = 16;
    {
#line 378
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 378
      if (! (i < 20)) {
#line 378
        goto while_break___1;
      }
#line 379
      it->i4_boundary_[17 + i] = *(enc->y_top_ + (it->x_ * 16 + i));
#line 378
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 382
    i = 16;
    {
#line 382
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 382
      if (! (i < 20)) {
#line 382
        goto while_break___2;
      }
#line 383
      it->i4_boundary_[17 + i] = it->i4_boundary_[32];
#line 382
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 386
  VP8IteratorNzToBytes(it);
  }
  return;
}
}
#line 389 "/doner/libwebp/libwebp-v0.3.0/src/enc/iterator.c"
int VP8IteratorRotateI4(VP8EncIterator *it , uint8_t *yuv_out ) 
{ 
  uint8_t *blk ;
  uint8_t *top ;
  int i ;

  {
#line 391
  blk = yuv_out + VP8Scan[it->i4_];
#line 392
  top = it->i4_top_;
#line 396
  i = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (i <= 3)) {
#line 396
      goto while_break;
    }
#line 397
    *(top + (-4 + i)) = *(blk + (i + 48));
#line 396
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  if ((it->i4_ & 3) != 3) {
#line 400
    i = 0;
    {
#line 400
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 400
      if (! (i <= 2)) {
#line 400
        goto while_break___0;
      }
#line 401
      *(top + i) = *(blk + (3 + (2 - i) * 16));
#line 400
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 404
    i = 0;
    {
#line 404
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 404
      if (! (i <= 3)) {
#line 404
        goto while_break___1;
      }
#line 405
      *(top + i) = *(top + (i + 4));
#line 404
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 409
  (it->i4_) ++;
#line 410
  if (it->i4_ == 16) {
#line 411
    return (0);
  }
#line 414
  it->i4_top_ = (uint8_t *)it->i4_boundary_ + (int )VP8TopLeftI4[it->i4_];
#line 415
  return (1);
}
}
#line 22 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static void HistogramClear(VP8LHistogram *p ) 
{ 


  {
  {
#line 23
  memset((int *)p->literal_, 0, sizeof(p->literal_));
#line 24
  memset((int *)p->red_, 0, sizeof(p->red_));
#line 25
  memset((int *)p->blue_, 0, sizeof(p->blue_));
#line 26
  memset((int *)p->alpha_, 0, sizeof(p->alpha_));
#line 27
  memset((int *)p->distance_, 0, sizeof(p->distance_));
#line 28
  p->bit_cost_ = (double )0;
  }
  return;
}
}
#line 31 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
void VP8LHistogramStoreRefs(VP8LBackwardRefs *refs , VP8LHistogram *histo ) 
{ 
  int i ;

  {
#line 34
  i = 0;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < refs->size)) {
#line 34
      goto while_break;
    }
    {
#line 35
    VP8LHistogramAddSinglePixOrCopy(histo, refs->refs + i);
    }
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 39 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
void VP8LHistogramCreate(VP8LHistogram *p , VP8LBackwardRefs *refs , int palette_code_bits ) 
{ 


  {
#line 42
  if (palette_code_bits >= 0) {
#line 43
    p->palette_code_bits_ = palette_code_bits;
  }
  {
#line 45
  HistogramClear(p);
#line 46
  VP8LHistogramStoreRefs(refs, p);
  }
  return;
}
}
#line 49 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
void VP8LHistogramInit(VP8LHistogram *p , int palette_code_bits ) 
{ 


  {
  {
#line 50
  p->palette_code_bits_ = palette_code_bits;
#line 51
  HistogramClear(p);
  }
  return;
}
}
#line 54 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
VP8LHistogramSet *VP8LAllocateHistogramSet(int size , int cache_bits ) 
{ 
  int i ;
  VP8LHistogramSet *set ;
  VP8LHistogram *bulk ;
  uint64_t total_size ;
  uint8_t *memory ;
  void *__cil_tmp8 ;

  {
  {
#line 58
  total_size = (sizeof(*set) + (uint64_t )size * sizeof(*(set->histograms))) + (uint64_t )size * sizeof(*(*(set->histograms)));
#line 61
  __cil_tmp8 = WebPSafeMalloc(total_size, sizeof(*memory));
#line 61
  memory = (uint8_t *)__cil_tmp8;
  }
#line 62
  if (memory == (void *)0) {
#line 62
    return ((VP8LHistogramSet *)((void *)0));
  }
#line 64
  set = (VP8LHistogramSet *)memory;
#line 65
  memory += sizeof(*set);
#line 66
  set->histograms = (VP8LHistogram **)memory;
#line 67
  memory += (unsigned long )size * sizeof(*(set->histograms));
#line 68
  bulk = (VP8LHistogram *)memory;
#line 69
  set->max_size = size;
#line 70
  set->size = size;
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < size)) {
#line 71
      goto while_break;
    }
    {
#line 72
    *(set->histograms + i) = bulk + i;
#line 73
    VP8LHistogramInit(*(set->histograms + i), cache_bits);
    }
#line 71
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return (set);
}
}
#line 80 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
void VP8LHistogramAddSinglePixOrCopy(VP8LHistogram *histo , PixOrCopy *v ) 
{ 
  int __cil_tmp3 ;
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  int __cil_tmp8 ;
  int literal_ix ;
  uint32_t __cil_tmp10 ;
  int code ;
  int extra_bits_count ;
  int extra_bits_value ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;

  {
  {
#line 82
  __cil_tmp3 = PixOrCopyIsLiteral(v);
  }
#line 82
  if (__cil_tmp3) {
    {
#line 83
    __cil_tmp4 = PixOrCopyLiteral(v, 3);
    }
    {
#line 83
    (histo->alpha_[__cil_tmp4]) ++;
#line 84
    __cil_tmp5 = PixOrCopyLiteral(v, 2);
    }
    {
#line 84
    (histo->red_[__cil_tmp5]) ++;
#line 85
    __cil_tmp6 = PixOrCopyLiteral(v, 1);
    }
    {
#line 85
    (histo->literal_[__cil_tmp6]) ++;
#line 86
    __cil_tmp7 = PixOrCopyLiteral(v, 0);
    }
#line 86
    (histo->blue_[__cil_tmp7]) ++;
  } else {
    {
#line 87
    __cil_tmp8 = PixOrCopyIsCacheIdx(v);
    }
#line 87
    if (__cil_tmp8) {
      {
#line 88
      __cil_tmp10 = PixOrCopyCacheIdx(v);
#line 88
      literal_ix = (int )(280U + __cil_tmp10);
#line 89
      (histo->literal_[literal_ix]) ++;
      }
    } else {
      {
#line 92
      __cil_tmp14 = PixOrCopyLength(v);
#line 92
      PrefixEncode((int )__cil_tmp14, & code, & extra_bits_count, & extra_bits_value);
#line 94
      (histo->literal_[256 + code]) ++;
#line 95
      __cil_tmp15 = PixOrCopyArgb(v);
#line 95
      PrefixEncode((int )__cil_tmp15, & code, & extra_bits_count, & extra_bits_value);
#line 97
      (histo->distance_[code]) ++;
      }
    }
  }
  return;
}
}
#line 101 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static double BitsEntropy(int const   *array , int n ) 
{ 
  double retval ;
  int sum ;
  int nonzeros ;
  int max_val ;
  int i ;
  double mix ;
  float __cil_tmp9 ;
  float __cil_tmp10 ;
  double min_limit ;
  double tmp ;

  {
#line 102
  retval = 0.;
#line 103
  sum = 0;
#line 104
  nonzeros = 0;
#line 105
  max_val = 0;
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i < n)) {
#line 108
      goto while_break;
    }
#line 109
    if (*(array + i) != 0) {
      {
#line 110
      sum += *(array + i);
#line 111
      nonzeros ++;
#line 112
      __cil_tmp9 = VP8LFastSLog2(*(array + i));
      }
#line 112
      retval -= (double )__cil_tmp9;
#line 113
      if (max_val < *(array + i)) {
#line 114
        max_val = *(array + i);
      }
    }
#line 108
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  __cil_tmp10 = VP8LFastSLog2(sum);
  }
#line 118
  retval += (double )__cil_tmp10;
#line 120
  if (nonzeros < 5) {
#line 121
    if (nonzeros <= 1) {
#line 122
      return ((double )0);
    }
#line 127
    if (nonzeros == 2) {
#line 128
      return (0.99 * (double )sum + 0.0100000000001 * retval);
    }
#line 134
    if (nonzeros == 3) {
#line 135
      mix = 0.95;
    } else {
#line 137
      mix = 0.7;
    }
  } else {
#line 140
    mix = 0.627000000001;
  }
#line 144
  min_limit = (double )(2 * sum - max_val);
#line 145
  min_limit = mix * min_limit + (1. - mix) * retval;
#line 146
  if (retval < min_limit) {
#line 146
    tmp = min_limit;
  } else {
#line 146
    tmp = retval;
  }
#line 146
  return (tmp);
}
}
#line 152 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static double HuffmanCost(int const   *population , int length ) 
{ 
  static int kHuffmanCodeOfHuffmanCodeSize ;
  static double kSmallBias ;
  double retval ;
  int streak ;
  int i ;

  {
#line 155
  kHuffmanCodeOfHuffmanCodeSize = 57;
#line 156
  kSmallBias = 9.1;
#line 157
  retval = (double )kHuffmanCodeOfHuffmanCodeSize - kSmallBias;
#line 158
  streak = 0;
#line 159
  i = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < length - 1)) {
#line 160
      goto while_break;
    }
#line 161
    streak ++;
#line 162
    if (*(population + i) == *(population + (i + 1))) {
#line 163
      goto while_continue;
    }
    last_streak_hack: 
#line 167
    if (streak > 3) {
#line 168
      if (*(population + i) == 0) {
#line 169
        retval += 1.5625 + 0.234375 * (double )streak;
      } else {
#line 171
        retval += 2.578125 + 0.703125 * (double )streak;
      }
    } else
#line 174
    if (*(population + i) == 0) {
#line 175
      retval += 1.796875 * (double )streak;
    } else {
#line 177
      retval += 3.28125 * (double )streak;
    }
#line 180
    streak = 0;
#line 160
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  if (i == length - 1) {
#line 183
    streak ++;
#line 184
    goto last_streak_hack;
  }
#line 186
  return (retval);
}
}
#line 189 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static double PopulationCost(int const   *population , int length ) 
{ 
  double __cil_tmp3 ;
  double __cil_tmp4 ;

  {
  {
#line 190
  __cil_tmp4 = HuffmanCost(population, length);
  }
  {
#line 190
  __cil_tmp3 = BitsEntropy(population, length);
  }
#line 190
  return (__cil_tmp3 + __cil_tmp4);
}
}
#line 193 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static double ExtraCost(int const   *population , int length ) 
{ 
  int i ;
  double cost ;

  {
#line 195
  cost = 0.;
#line 196
  i = 2;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < length - 2)) {
#line 196
      goto while_break;
    }
#line 196
    cost += (double )((i >> 1) * *(population + (i + 2)));
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (cost);
}
}
#line 201 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
double VP8LHistogramEstimateBits(VP8LHistogram *p ) 
{ 
  int __cil_tmp2 ;
  double __cil_tmp3 ;
  double __cil_tmp4 ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;

  {
  {
#line 202
  __cil_tmp9 = ExtraCost((int const   *)p->distance_, 40);
  }
  {
#line 202
  __cil_tmp8 = ExtraCost((int const   *)p->literal_ + 256, 24);
  }
  {
#line 202
  __cil_tmp7 = PopulationCost((int const   *)p->distance_, 40);
  }
  {
#line 202
  __cil_tmp6 = PopulationCost((int const   *)p->alpha_, 256);
  }
  {
#line 202
  __cil_tmp5 = PopulationCost((int const   *)p->blue_, 256);
  }
  {
#line 202
  __cil_tmp4 = PopulationCost((int const   *)p->red_, 256);
  }
  {
#line 202
  __cil_tmp2 = VP8LHistogramNumCodes(p);
#line 202
  __cil_tmp3 = PopulationCost((int const   *)p->literal_, __cil_tmp2);
  }
#line 202
  return ((((((__cil_tmp3 + __cil_tmp4) + __cil_tmp5) + __cil_tmp6) + __cil_tmp7) + __cil_tmp8) + __cil_tmp9);
}
}
#line 211 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
double VP8LHistogramEstimateBitsBulk(VP8LHistogram *p ) 
{ 
  int __cil_tmp2 ;
  double __cil_tmp3 ;
  double __cil_tmp4 ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;

  {
  {
#line 212
  __cil_tmp9 = ExtraCost((int const   *)p->distance_, 40);
  }
  {
#line 212
  __cil_tmp8 = ExtraCost((int const   *)p->literal_ + 256, 24);
  }
  {
#line 212
  __cil_tmp7 = BitsEntropy((int const   *)p->distance_, 40);
  }
  {
#line 212
  __cil_tmp6 = BitsEntropy((int const   *)p->alpha_, 256);
  }
  {
#line 212
  __cil_tmp5 = BitsEntropy((int const   *)p->blue_, 256);
  }
  {
#line 212
  __cil_tmp4 = BitsEntropy((int const   *)p->red_, 256);
  }
  {
#line 212
  __cil_tmp2 = VP8LHistogramNumCodes(p);
#line 212
  __cil_tmp3 = BitsEntropy((int const   *)p->literal_, __cil_tmp2);
  }
#line 212
  return ((((((__cil_tmp3 + __cil_tmp4) + __cil_tmp5) + __cil_tmp6) + __cil_tmp7) + __cil_tmp8) + __cil_tmp9);
}
}
#line 225 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static void HistogramAdd(VP8LHistogram *in , VP8LHistogram *out ) 
{ 
  int i ;

  {
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (i < 280 + (1 << 9))) {
#line 228
      goto while_break;
    }
#line 229
    out->literal_[i] += in->literal_[i];
#line 228
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  i = 0;
  {
#line 231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 231
    if (! (i < 40)) {
#line 231
      goto while_break___0;
    }
#line 232
    out->distance_[i] += in->distance_[i];
#line 231
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 234
  i = 0;
  {
#line 234
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 234
    if (! (i < 256)) {
#line 234
      goto while_break___1;
    }
#line 235
    out->red_[i] += in->red_[i];
#line 236
    out->blue_[i] += in->blue_[i];
#line 237
    out->alpha_[i] += in->alpha_[i];
#line 234
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 247 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static double HistogramAddEval(VP8LHistogram *a , VP8LHistogram *b , VP8LHistogram *out ,
                               double cost_threshold ) 
{ 
  double cost ;
  double sum_cost ;
  int i ;
  int tmp ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;

  {
#line 251
  cost = (double )0;
#line 252
  sum_cost = a->bit_cost_ + b->bit_cost_;
#line 255
  cost_threshold += sum_cost;
#line 259
  if (a->palette_code_bits_ > b->palette_code_bits_) {
#line 259
    tmp = a->palette_code_bits_;
  } else {
#line 259
    tmp = b->palette_code_bits_;
  }
#line 259
  out->palette_code_bits_ = tmp;
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (i < 280 + (1 << 9))) {
#line 262
      goto while_break;
    }
#line 263
    out->literal_[i] = a->literal_[i] + b->literal_[i];
#line 262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  __cil_tmp9 = VP8LHistogramNumCodes(out);
#line 265
  __cil_tmp10 = PopulationCost((int const   *)((int *)out->literal_), __cil_tmp9);
  }
  {
#line 265
  cost += __cil_tmp10;
#line 266
  __cil_tmp11 = ExtraCost((int const   *)((int *)out->literal_ + 256), 24);
  }
#line 266
  cost += __cil_tmp11;
#line 267
  if (cost > cost_threshold) {
#line 267
    return (cost);
  }
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! (i < 256)) {
#line 269
      goto while_break___0;
    }
#line 269
    out->red_[i] = a->red_[i] + b->red_[i];
#line 269
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 270
  __cil_tmp12 = PopulationCost((int const   *)((int *)out->red_), 256);
  }
#line 270
  cost += __cil_tmp12;
#line 271
  if (cost > cost_threshold) {
#line 271
    return (cost);
  }
#line 273
  i = 0;
  {
#line 273
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 273
    if (! (i < 256)) {
#line 273
      goto while_break___1;
    }
#line 273
    out->blue_[i] = a->blue_[i] + b->blue_[i];
#line 273
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 274
  __cil_tmp13 = PopulationCost((int const   *)((int *)out->blue_), 256);
  }
#line 274
  cost += __cil_tmp13;
#line 275
  if (cost > cost_threshold) {
#line 275
    return (cost);
  }
#line 277
  i = 0;
  {
#line 277
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 277
    if (! (i < 40)) {
#line 277
      goto while_break___2;
    }
#line 278
    out->distance_[i] = a->distance_[i] + b->distance_[i];
#line 277
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 280
  __cil_tmp14 = PopulationCost((int const   *)((int *)out->distance_), 40);
  }
  {
#line 280
  cost += __cil_tmp14;
#line 281
  __cil_tmp15 = ExtraCost((int const   *)((int *)out->distance_), 40);
  }
#line 281
  cost += __cil_tmp15;
#line 282
  if (cost > cost_threshold) {
#line 282
    return (cost);
  }
#line 284
  i = 0;
  {
#line 284
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 284
    if (! (i < 256)) {
#line 284
      goto while_break___3;
    }
#line 284
    out->alpha_[i] = a->alpha_[i] + b->alpha_[i];
#line 284
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 285
  __cil_tmp16 = PopulationCost((int const   *)((int *)out->alpha_), 256);
  }
#line 285
  cost += __cil_tmp16;
#line 287
  out->bit_cost_ = cost;
#line 288
  return (cost - sum_cost);
}
}
#line 294 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static double HistogramAddThresh(VP8LHistogram *a , VP8LHistogram *b , double cost_threshold ) 
{ 
  int tmp[792] ;
  int i ;
  double cost ;
  int __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;

  {
#line 299
  cost = - a->bit_cost_;
#line 301
  i = 0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (i < 280 + (1 << 9))) {
#line 301
      goto while_break;
    }
#line 302
    tmp[i] = a->literal_[i] + b->literal_[i];
#line 301
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 306
  __cil_tmp7 = VP8LHistogramNumCodes(a);
#line 306
  __cil_tmp8 = PopulationCost((int const   *)((int *)tmp), __cil_tmp7);
  }
  {
#line 306
  cost += __cil_tmp8;
#line 307
  __cil_tmp9 = ExtraCost((int const   *)((int *)tmp + 256), 24);
  }
#line 307
  cost += __cil_tmp9;
#line 308
  if (cost > cost_threshold) {
#line 308
    return (cost);
  }
#line 310
  i = 0;
  {
#line 310
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 310
    if (! (i < 256)) {
#line 310
      goto while_break___0;
    }
#line 310
    tmp[i] = a->red_[i] + b->red_[i];
#line 310
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 311
  __cil_tmp10 = PopulationCost((int const   *)((int *)tmp), 256);
  }
#line 311
  cost += __cil_tmp10;
#line 312
  if (cost > cost_threshold) {
#line 312
    return (cost);
  }
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 314
    if (! (i < 256)) {
#line 314
      goto while_break___1;
    }
#line 314
    tmp[i] = a->blue_[i] + b->blue_[i];
#line 314
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 315
  __cil_tmp11 = PopulationCost((int const   *)((int *)tmp), 256);
  }
#line 315
  cost += __cil_tmp11;
#line 316
  if (cost > cost_threshold) {
#line 316
    return (cost);
  }
#line 318
  i = 0;
  {
#line 318
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 318
    if (! (i < 40)) {
#line 318
      goto while_break___2;
    }
#line 319
    tmp[i] = a->distance_[i] + b->distance_[i];
#line 318
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 321
  __cil_tmp12 = PopulationCost((int const   *)((int *)tmp), 40);
  }
  {
#line 321
  cost += __cil_tmp12;
#line 322
  __cil_tmp13 = ExtraCost((int const   *)((int *)tmp), 40);
  }
#line 322
  cost += __cil_tmp13;
#line 323
  if (cost > cost_threshold) {
#line 323
    return (cost);
  }
#line 325
  i = 0;
  {
#line 325
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 325
    if (! (i < 256)) {
#line 325
      goto while_break___3;
    }
#line 325
    tmp[i] = a->alpha_[i] + b->alpha_[i];
#line 325
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 326
  __cil_tmp14 = PopulationCost((int const   *)((int *)tmp), 256);
  }
#line 326
  cost += __cil_tmp14;
#line 328
  return (cost);
}
}
#line 333 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static void HistogramBuildImage(int xsize , int histo_bits , VP8LBackwardRefs *backward_refs ,
                                VP8LHistogramSet *image ) 
{ 
  int i ;
  int x ;
  int y ;
  int histo_xsize ;
  uint32_t __cil_tmp9 ;
  VP8LHistogram **histograms ;
  int tmp ;
  PixOrCopy *v ;
  int ix ;
  uint32_t __cil_tmp14 ;

  {
#line 337
  x = 0;
  {
#line 337
  y = 0;
#line 338
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )xsize, (uint32_t )histo_bits);
#line 338
  histo_xsize = (int )__cil_tmp9;
#line 339
  histograms = image->histograms;
#line 341
  i = 0;
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (i < backward_refs->size)) {
#line 341
      goto while_break;
    }
    {
#line 342
    v = backward_refs->refs + i;
#line 343
    ix = (y >> histo_bits) * histo_xsize + (x >> histo_bits);
#line 344
    VP8LHistogramAddSinglePixOrCopy(*(histograms + ix), v);
#line 345
    __cil_tmp14 = PixOrCopyLength(v);
    }
#line 345
    x += __cil_tmp14;
    {
#line 346
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 346
      if (! (x >= xsize)) {
#line 346
        goto while_break___0;
      }
#line 347
      x -= xsize;
#line 348
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 353 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static uint32_t MyRand(uint32_t *seed ) 
{ 


  {
#line 354
  *seed *= 16807U;
#line 355
  if (*seed == 0U) {
#line 356
    *seed = (uint32_t )1;
  }
#line 358
  return (*seed);
}
}
#line 361 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static int HistogramCombine(VP8LHistogramSet *in , VP8LHistogramSet *out , int iter_mult ,
                            int num_pairs , int num_tries_no_success ) 
{ 
  int ok ;
  int i ;
  int iter ;
  uint32_t seed ;
  int tries_with_no_success ;
  int out_size ;
  int outer_iters ;
  int min_cluster_size ;
  VP8LHistogram *histos ;
  void *__cil_tmp15 ;
  VP8LHistogram *cur_combo ;
  VP8LHistogram *best_combo ;
  int tmp ;
  double __cil_tmp19 ;
  double best_cost_diff ;
  int best_idx1 ;
  int best_idx2 ;
  int j ;
  int num_tries ;
  int tmp___0 ;
  double curr_cost_diff ;
  uint32_t idx1 ;
  uint32_t __cil_tmp28 ;
  uint32_t tmp___1 ;
  uint32_t diff ;
  uint32_t __cil_tmp31 ;
  uint32_t tmp___11 ;
  uint32_t idx2 ;
  double __cil_tmp34 ;
  VP8LHistogram *tmp_histo ;

  {
  {
#line 364
  ok = 0;
#line 366
  seed = (uint32_t )0;
#line 367
  tries_with_no_success = 0;
#line 368
  out_size = in->size;
#line 369
  outer_iters = in->size * iter_mult;
#line 370
  min_cluster_size = 2;
#line 371
  __cil_tmp15 = malloc(2UL * sizeof(*histos));
#line 371
  histos = (VP8LHistogram *)__cil_tmp15;
#line 372
  cur_combo = histos + 0;
#line 373
  best_combo = histos + 1;
  }
#line 374
  if (histos == (void *)0) {
#line 374
    goto End;
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! (i < in->size)) {
#line 378
      goto while_break;
    }
    {
#line 379
    (*(in->histograms + i))->bit_cost_ = VP8LHistogramEstimateBits(*(in->histograms + i));
#line 380
    *(*(out->histograms + i)) = *(*(in->histograms + i));
    }
#line 378
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  iter = 0;
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 384
    if (! (iter < outer_iters && out_size >= min_cluster_size)) {
#line 384
      goto while_break___0;
    }
#line 385
    best_cost_diff = 0.;
#line 386
    best_idx1 = - 1;
#line 386
    best_idx2 = 1;
#line 388
    if (num_pairs < out_size) {
#line 388
      tmp___0 = num_pairs;
    } else {
#line 388
      tmp___0 = out_size;
    }
#line 388
    num_tries = tmp___0;
#line 389
    seed += (unsigned int )iter;
#line 390
    j = 0;
    {
#line 390
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 390
      if (! (j < num_tries)) {
#line 390
        goto while_break___1;
      }
      {
#line 393
      __cil_tmp28 = MyRand(& seed);
#line 393
      idx1 = __cil_tmp28 % (unsigned int )out_size;
#line 394
      tmp___1 = (uint32_t )((j & 7) + 1);
      }
#line 395
      if (tmp___1 < 3U) {
#line 395
        tmp___11 = tmp___1;
      } else {
        {
#line 395
        __cil_tmp31 = MyRand(& seed);
#line 395
        tmp___11 = __cil_tmp31 % (unsigned int )(out_size - 1);
        }
      }
#line 395
      diff = tmp___11;
#line 396
      idx2 = ((idx1 + diff) + 1U) % (unsigned int )out_size;
#line 397
      if (idx1 == idx2) {
#line 398
        goto while_continue___1;
      }
      {
#line 401
      curr_cost_diff = HistogramAddEval(*(out->histograms + idx1), *(out->histograms + idx2),
                                        cur_combo, best_cost_diff);
      }
#line 404
      if (curr_cost_diff < best_cost_diff) {
#line 406
        tmp_histo = cur_combo;
#line 407
        cur_combo = best_combo;
#line 408
        best_combo = tmp_histo;
#line 410
        best_cost_diff = curr_cost_diff;
#line 411
        best_idx1 = (int )idx1;
#line 412
        best_idx2 = (int )idx2;
      }
#line 390
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 416
    if (best_idx1 >= 0) {
#line 417
      *(*(out->histograms + best_idx1)) = *best_combo;
#line 419
      out_size --;
#line 420
      if (best_idx2 != out_size) {
#line 421
        *(out->histograms + best_idx2) = *(out->histograms + out_size);
#line 422
        *(out->histograms + out_size) = (VP8LHistogram *)((void *)0);
      }
#line 424
      tries_with_no_success = 0;
    }
#line 426
    tries_with_no_success ++;
#line 426
    if (tries_with_no_success >= num_tries_no_success) {
#line 427
      goto while_break___0;
    }
#line 384
    iter ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 430
  out->size = out_size;
#line 431
  ok = 1;
  End: 
  {
#line 434
  free(histos);
  }
#line 435
  return (ok);
}
}
#line 442 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static double HistogramDistance(VP8LHistogram *square_histogram , VP8LHistogram *candidate ,
                                double cost_threshold ) 
{ 
  double __cil_tmp4 ;

  {
  {
#line 445
  __cil_tmp4 = HistogramAddThresh(candidate, square_histogram, cost_threshold);
  }
#line 445
  return (__cil_tmp4);
}
}
#line 450 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
static void HistogramRemap(VP8LHistogramSet *in , VP8LHistogramSet *out , uint16_t *symbols ) 
{ 
  int i ;
  int best_out ;
  double best_bits ;
  double __cil_tmp7 ;
  int k ;
  double cur_bits ;
  double __cil_tmp10 ;

  {
#line 454
  i = 0;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! (i < in->size)) {
#line 454
      goto while_break;
    }
    {
#line 455
    best_out = 0;
#line 456
    __cil_tmp7 = HistogramDistance(*(in->histograms + i), *(out->histograms + 0),
                                   1e+38);
#line 456
    best_bits = __cil_tmp7;
#line 459
    k = 1;
    }
    {
#line 459
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 459
      if (! (k < out->size)) {
#line 459
        goto while_break___0;
      }
      {
#line 460
      __cil_tmp10 = HistogramDistance(*(in->histograms + i), *(out->histograms + k),
                                      best_bits);
#line 460
      cur_bits = __cil_tmp10;
      }
#line 462
      if (cur_bits < best_bits) {
#line 463
        best_bits = cur_bits;
#line 464
        best_out = k;
      }
#line 459
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 467
    *(symbols + i) = (uint16_t )best_out;
#line 454
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  i = 0;
  {
#line 471
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 471
    if (! (i < out->size)) {
#line 471
      goto while_break___1;
    }
    {
#line 472
    HistogramClear(*(out->histograms + i));
    }
#line 471
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 474
  i = 0;
  {
#line 474
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 474
    if (! (i < in->size)) {
#line 474
      goto while_break___2;
    }
    {
#line 475
    HistogramAdd(*(in->histograms + i), *(out->histograms + *(symbols + i)));
    }
#line 474
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 479 "/doner/libwebp/libwebp-v0.3.0/src/enc/histogram.c"
int VP8LGetHistoImageSymbols(int xsize , int ysize , VP8LBackwardRefs *refs , int quality ,
                             int histo_bits , int cache_bits , VP8LHistogramSet *image_in ,
                             uint16_t *histogram_symbols ) 
{ 
  int ok ;
  int histo_xsize ;
  uint32_t __cil_tmp11 ;
  uint32_t tmp ;
  int histo_ysize ;
  uint32_t __cil_tmp14 ;
  uint32_t tmp___0 ;
  int histo_image_raw_size ;
  int num_tries_no_success ;
  int iter_mult ;
  int tmp___1 ;
  int num_pairs ;
  int tmp___2 ;
  VP8LHistogramSet *image_out ;
  VP8LHistogramSet *__cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 484
  ok = 0;
#line 485
  if (histo_bits) {
    {
#line 485
    __cil_tmp11 = VP8LSubSampleSize((uint32_t )xsize, (uint32_t )histo_bits);
#line 485
    tmp = __cil_tmp11;
    }
  } else {
#line 485
    tmp = (unsigned int )1;
  }
#line 485
  histo_xsize = (int )tmp;
#line 486
  if (histo_bits) {
    {
#line 486
    __cil_tmp14 = VP8LSubSampleSize((uint32_t )ysize, (uint32_t )histo_bits);
#line 486
    tmp___0 = __cil_tmp14;
    }
  } else {
#line 486
    tmp___0 = (unsigned int )1;
  }
#line 486
  histo_ysize = (int )tmp___0;
#line 487
  histo_image_raw_size = histo_xsize * histo_ysize;
#line 490
  num_tries_no_success = 8 + (quality >> 1);
#line 491
  if (quality < 27) {
#line 491
    tmp___1 = 1;
  } else {
#line 491
    tmp___1 = 1 + ((quality - 27) >> 4);
  }
#line 491
  iter_mult = tmp___1;
#line 492
  if (quality < 25) {
#line 492
    tmp___2 = 10;
  } else {
#line 492
    tmp___2 = 5 * quality >> 3;
  }
  {
#line 492
  num_pairs = tmp___2;
#line 494
  __cil_tmp23 = VP8LAllocateHistogramSet(histo_image_raw_size, cache_bits);
#line 494
  image_out = __cil_tmp23;
  }
#line 496
  if (image_out == (void *)0) {
#line 496
    return (0);
  }
  {
#line 499
  HistogramBuildImage(xsize, histo_bits, refs, image_out);
#line 501
  __cil_tmp24 = HistogramCombine(image_out, image_in, iter_mult, num_pairs, num_tries_no_success);
  }
#line 501
  if (! __cil_tmp24) {
#line 503
    goto Error;
  }
  {
#line 506
  HistogramRemap(image_out, image_in, histogram_symbols);
#line 507
  ok = 1;
  }
  Error: 
  {
#line 510
  free(image_out);
  }
#line 511
  return (ok);
}
}
#line 43 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
uint8_t VP8EncBands[17]  = 
#line 43 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )2,      (uint8_t )3, 
        (uint8_t )6,      (uint8_t )4,      (uint8_t )5,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )6, 
        (uint8_t )6,      (uint8_t )6,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )0};
#line 48 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
uint8_t VP8Cat3[3]  = {      (uint8_t )173,      (uint8_t )148,      (uint8_t )140};
#line 49 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
uint8_t VP8Cat4[4]  = {      (uint8_t )176,      (uint8_t )155,      (uint8_t )140,      (uint8_t )135};
#line 50 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
uint8_t VP8Cat5[5]  = {      (uint8_t )180,      (uint8_t )157,      (uint8_t )141,      (uint8_t )134, 
        (uint8_t )130};
#line 51 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
uint8_t VP8Cat6[11]  = 
#line 51
  {      (uint8_t )254,      (uint8_t )254,      (uint8_t )243,      (uint8_t )230, 
        (uint8_t )196,      (uint8_t )177,      (uint8_t )153,      (uint8_t )140, 
        (uint8_t )133,      (uint8_t )130,      (uint8_t )129};
#line 57 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void ResetStats(VP8Encoder *enc ) 
{ 
  VP8Proba *proba ;

  {
  {
#line 58
  proba = & enc->proba_;
#line 59
  VP8CalculateLevelCosts(proba);
#line 60
  proba->nb_skip_ = 0;
  }
  return;
}
}
#line 68 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int CalcSkipProba(uint64_t nb , uint64_t total ) 
{ 
  uint64_t tmp ;

  {
#line 69
  if (total) {
#line 69
    tmp = ((total - nb) * 255UL) / total;
  } else {
#line 69
    tmp = (unsigned long )255;
  }
#line 69
  return ((int )tmp);
}
}
#line 73 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int FinalizeSkipProba(VP8Encoder *enc ) 
{ 
  VP8Proba *proba ;
  int nb_mbs ;
  int nb_events ;
  int size ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 74
  proba = & enc->proba_;
#line 75
  nb_mbs = enc->mb_w_ * enc->mb_h_;
#line 76
  nb_events = proba->nb_skip_;
#line 78
  __cil_tmp6 = CalcSkipProba((uint64_t )nb_events, (uint64_t )nb_mbs);
#line 78
  proba->skip_proba_ = (uint8_t )__cil_tmp6;
#line 79
  proba->use_skip_proba_ = (int )proba->skip_proba_ < 250;
#line 80
  size = 256;
  }
#line 81
  if (proba->use_skip_proba_) {
    {
#line 82
    __cil_tmp8 = VP8BitCost(0, proba->skip_proba_);
    }
    {
#line 82
    __cil_tmp7 = VP8BitCost(1, proba->skip_proba_);
    }
#line 82
    size += nb_events * __cil_tmp7 + (nb_mbs - nb_events) * __cil_tmp8;
#line 84
    size += 2048;
  }
#line 86
  return (size);
}
}
#line 92 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void ResetTokenStats(VP8Encoder *enc ) 
{ 
  VP8Proba *proba ;

  {
  {
#line 93
  proba = & enc->proba_;
#line 94
  memset((StatsArray (*)[8])proba->stats_, 0, sizeof(proba->stats_));
  }
  return;
}
}
#line 98 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int Record(int bit , proba_t *stats ) 
{ 
  proba_t p ;

  {
#line 99
  p = *stats;
#line 100
  if (p >= 4294901760U) {
#line 101
    p = ((p + 1U) >> 1) & 2147450879U;
  }
#line 104
  p += 65536U + (unsigned int )bit;
#line 105
  *stats = p;
#line 106
  return (bit);
}
}
#line 114 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int RecordCoeffs(int ctx , VP8Residual *res ) 
{ 
  int n ;
  proba_t *s ;
  int v ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int bits ;
  int pattern ;
  int i ;
  int mask ;

  {
#line 115
  n = res->first;
#line 117
  s = (proba_t *)(*(res->stats + n))[ctx];
#line 118
  if (res->last < 0) {
    {
#line 119
    Record(0, s + 0);
    }
#line 120
    return (0);
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (n <= res->last)) {
#line 122
      goto while_break;
    }
    {
#line 124
    Record(1, s + 0);
    }
    {
#line 125
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 125
      __cil_tmp6 = n;
#line 125
      n ++;
#line 125
      v = (int )*(res->coeffs + __cil_tmp6);
#line 125
      if (! (v == 0)) {
#line 125
        goto while_break___0;
      }
      {
#line 126
      Record(0, s + 1);
#line 127
      s = (proba_t *)(*(res->stats + VP8EncBands[n]))[0];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 129
    Record(1, s + 1);
#line 130
    __cil_tmp7 = Record(2U < (unsigned int )(v + 1), s + 2);
    }
#line 130
    if (! __cil_tmp7) {
#line 131
      s = (proba_t *)(*(res->stats + VP8EncBands[n]))[1];
    } else {
      {
#line 133
      v = abs(v);
      }
#line 146
      if (v > 67) {
#line 147
        v = 67;
      }
#line 150
      bits = (int )VP8LevelCodes[v - 1][1];
#line 151
      pattern = (int )VP8LevelCodes[v - 1][0];
#line 153
      i = 0;
      {
#line 153
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 153
        if (! (pattern != 0)) {
#line 153
          goto while_break___1;
        }
#line 154
        mask = 2 << i;
#line 155
        if (pattern & 1) {
          {
#line 155
          Record(! (! (bits & mask)), (s + 3) + i);
          }
        }
#line 153
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 159
      s = (proba_t *)(*(res->stats + VP8EncBands[n]))[2];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if (n < 16) {
    {
#line 162
    Record(0, s + 0);
    }
  }
#line 163
  return (1);
}
}
#line 168 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int CalcTokenProba(int nb , int total ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 170
  if (nb) {
#line 170
    tmp___0 = 255 - (nb * 255) / total;
  } else {
#line 170
    tmp___0 = 255;
  }
#line 170
  return (tmp___0);
}
}
#line 174 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int BranchCost(int nb , int total , int proba ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 175
  __cil_tmp5 = VP8BitCost(0, (uint8_t )proba);
  }
  {
#line 175
  __cil_tmp4 = VP8BitCost(1, (uint8_t )proba);
  }
#line 175
  return (nb * __cil_tmp4 + (total - nb) * __cil_tmp5);
}
}
#line 178 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int FinalizeTokenProbas(VP8Proba *proba ) 
{ 
  int has_changed ;
  int size ;
  int t ;
  int b ;
  int c ;
  int p ;
  proba_t stats ;
  int nb ;
  int total ;
  int update_proba ;
  int old_p ;
  int new_p ;
  int __cil_tmp14 ;
  int old_cost ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int new_cost ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int use_new_p ;
  int __cil_tmp22 ;

  {
#line 179
  has_changed = 0;
#line 180
  size = 0;
#line 182
  t = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (t < 4)) {
#line 182
      goto while_break;
    }
#line 183
    b = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      if (! (b < 8)) {
#line 183
        goto while_break___0;
      }
#line 184
      c = 0;
      {
#line 184
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 184
        if (! (c < 3)) {
#line 184
          goto while_break___1;
        }
#line 185
        p = 0;
        {
#line 185
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 185
          if (! (p < 11)) {
#line 185
            goto while_break___2;
          }
          {
#line 186
          stats = proba->stats_[t][b][c][p];
#line 187
          nb = (int )(stats & 65535U);
#line 188
          total = (int )((stats >> 16) & 65535U);
#line 189
          update_proba = (int )VP8CoeffsUpdateProba[t][b][c][p];
#line 190
          old_p = (int )VP8CoeffsProba0[t][b][c][p];
#line 191
          __cil_tmp14 = CalcTokenProba(nb, total);
#line 191
          new_p = __cil_tmp14;
#line 192
          __cil_tmp17 = VP8BitCost(0, (uint8_t )update_proba);
          }
          {
#line 192
          __cil_tmp16 = BranchCost(nb, total, old_p);
#line 192
          old_cost = __cil_tmp16 + __cil_tmp17;
#line 194
          __cil_tmp20 = VP8BitCost(1, (uint8_t )update_proba);
          }
          {
#line 194
          __cil_tmp19 = BranchCost(nb, total, new_p);
#line 194
          new_cost = (__cil_tmp19 + __cil_tmp20) + 2048;
#line 197
          use_new_p = old_cost > new_cost;
#line 198
          __cil_tmp22 = VP8BitCost(use_new_p, (uint8_t )update_proba);
          }
#line 198
          size += __cil_tmp22;
#line 199
          if (use_new_p) {
#line 200
            proba->coeffs_[t][b][c][p] = (uint8_t )new_p;
#line 201
            has_changed |= new_p != old_p;
#line 202
            size += 2048;
          } else {
#line 204
            proba->coeffs_[t][b][c][p] = (uint8_t )old_p;
          }
#line 185
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 184
        c ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 183
      b ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 182
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  proba->dirty_ = has_changed;
#line 211
  return (size);
}
}
#line 217 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int GetProba(int a , int b ) 
{ 
  int total ;
  int tmp ;

  {
#line 218
  total = a + b;
#line 219
  if (total == 0) {
#line 219
    tmp = 255;
  } else {
#line 219
    tmp = (255 * a + total / 2) / total;
  }
#line 219
  return (tmp);
}
}
#line 223 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void SetSegmentProbas(VP8Encoder *enc ) 
{ 
  int p[4] ;
  unsigned int tmp ;
  int n ;
  VP8MBInfo *mb ;
  int __cil_tmp6 ;
  uint8_t *probas ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 224
  p[0] = 0;
#line 224
  tmp = (unsigned int )1;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (tmp >= 4) {
#line 224
      goto while_break;
    }
#line 224
    p[tmp] = 0;
#line 224
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  n = 0;
  {
#line 227
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 227
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 227
      goto while_break___0;
    }
#line 228
    mb = enc->mb_info_ + n;
#line 229
    (p[mb->segment_]) ++;
#line 227
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  if ((enc->pic_)->stats != (void *)0) {
#line 232
    n = 0;
    {
#line 232
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 232
      if (! (n < 4)) {
#line 232
        goto while_break___1;
      }
#line 233
      ((enc->pic_)->stats)->segment_size[n] = p[n];
#line 232
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 236
  if (enc->segment_hdr_.num_segments_ > 1) {
    {
#line 237
    probas = (uint8_t *)enc->proba_.segments_;
#line 238
    __cil_tmp8 = GetProba(p[0] + p[1], p[2] + p[3]);
#line 238
    *(probas + 0) = (uint8_t )__cil_tmp8;
#line 239
    __cil_tmp9 = GetProba(p[0], p[1]);
#line 239
    *(probas + 1) = (uint8_t )__cil_tmp9;
#line 240
    __cil_tmp10 = GetProba(p[2], p[3]);
#line 240
    *(probas + 2) = (uint8_t )__cil_tmp10;
#line 242
    enc->segment_hdr_.update_map_ = ((int )*(probas + 0) != 255 || (int )*(probas + 1) != 255) || (int )*(probas + 2) != 255;
#line 244
    __cil_tmp18 = VP8BitCost(1, *(probas + 2));
    }
    {
#line 244
    __cil_tmp17 = VP8BitCost(1, *(probas + 0));
    }
    {
#line 244
    __cil_tmp16 = VP8BitCost(0, *(probas + 2));
    }
    {
#line 244
    __cil_tmp15 = VP8BitCost(1, *(probas + 0));
    }
    {
#line 244
    __cil_tmp14 = VP8BitCost(1, *(probas + 1));
    }
    {
#line 244
    __cil_tmp13 = VP8BitCost(0, *(probas + 0));
    }
    {
#line 244
    __cil_tmp12 = VP8BitCost(0, *(probas + 1));
    }
    {
#line 244
    __cil_tmp11 = VP8BitCost(0, *(probas + 0));
#line 244
    enc->segment_hdr_.size_ = ((p[0] * (__cil_tmp11 + __cil_tmp12) + p[1] * (__cil_tmp13 + __cil_tmp14)) + p[2] * (__cil_tmp15 + __cil_tmp16)) + p[3] * (__cil_tmp17 + __cil_tmp18);
    }
  } else {
#line 250
    enc->segment_hdr_.update_map_ = 0;
#line 251
    enc->segment_hdr_.size_ = 0;
  }
  return;
}
}
#line 258 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void InitResidual(int first , int coeff_type , VP8Encoder *enc , VP8Residual *res ) 
{ 


  {
#line 260
  res->coeff_type = coeff_type;
#line 261
  res->prob = (ProbaArray *)enc->proba_.coeffs_[coeff_type];
#line 262
  res->stats = (StatsArray *)enc->proba_.stats_[coeff_type];
#line 263
  res->cost = (CostArray *)enc->proba_.level_cost_[coeff_type];
#line 264
  res->first = first;
  return;
}
}
#line 267 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void SetResidualCoeffs(int16_t *coeffs , VP8Residual *res ) 
{ 
  int n ;

  {
#line 270
  res->last = - 1;
#line 271
  n = 15;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (n >= res->first)) {
#line 271
      goto while_break;
    }
#line 272
    if (*(coeffs + n)) {
#line 273
      res->last = n;
#line 274
      goto while_break;
    }
#line 271
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  res->coeffs = coeffs;
  return;
}
}
#line 283 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int GetResidualCost(int ctx0 , VP8Residual *res ) 
{ 
  int n ;
  int p0 ;
  uint16_t *t ;
  int cost ;
  int __cil_tmp7 ;
  int v ;
  int b ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int ctx ;
  int tmp ;
  int v___0 ;
  int __cil_tmp16 ;
  int tmp___0 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int b___0 ;
  int ctx___0 ;
  int tmp___1 ;
  int last_p0 ;
  int __cil_tmp24 ;

  {
#line 284
  n = res->first;
#line 286
  p0 = (int )(*(res->prob + n))[ctx0][0];
#line 287
  t = (uint16_t *)(*(res->cost + n))[ctx0];
#line 290
  if (res->last < 0) {
    {
#line 291
    __cil_tmp7 = VP8BitCost(0, (uint8_t )p0);
    }
#line 291
    return (__cil_tmp7);
  }
#line 293
  cost = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (n < res->last)) {
#line 294
      goto while_break;
    }
#line 295
    v = (int )*(res->coeffs + n);
#line 296
    b = (int )VP8EncBands[n + 1];
#line 297
    n ++;
#line 298
    if (v == 0) {
#line 300
      cost += (int )*(t + 0);
#line 301
      t = (uint16_t *)(*(res->cost + b))[0];
#line 302
      goto while_continue;
    }
    {
#line 304
    v = abs(v);
#line 305
    __cil_tmp11 = VP8BitCost(1, (uint8_t )p0);
    }
    {
#line 305
    cost += __cil_tmp11;
#line 306
    __cil_tmp12 = VP8LevelCost(t, v);
    }
#line 306
    cost += __cil_tmp12;
#line 308
    if (v == 1) {
#line 308
      tmp = 1;
    } else {
#line 308
      tmp = 2;
    }
#line 308
    ctx = tmp;
#line 309
    p0 = (int )(*(res->prob + b))[ctx][0];
#line 310
    t = (uint16_t *)(*(res->cost + b))[ctx];
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  __cil_tmp16 = abs((int )*(res->coeffs + n));
#line 315
  v___0 = __cil_tmp16;
#line 317
  __cil_tmp18 = VP8BitCost(1, (uint8_t )p0);
  }
  {
#line 317
  cost += __cil_tmp18;
#line 318
  __cil_tmp19 = VP8LevelCost(t, v___0);
  }
#line 318
  cost += __cil_tmp19;
#line 319
  if (n < 15) {
#line 320
    b___0 = (int )VP8EncBands[n + 1];
#line 321
    if (v___0 == 1) {
#line 321
      tmp___1 = 1;
    } else {
#line 321
      tmp___1 = 2;
    }
    {
#line 321
    ctx___0 = tmp___1;
#line 322
    last_p0 = (int )(*(res->prob + b___0))[ctx___0][0];
#line 323
    __cil_tmp24 = VP8BitCost(0, (uint8_t )last_p0);
    }
#line 323
    cost += __cil_tmp24;
  }
#line 326
  return (cost);
}
}
#line 329 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
int VP8GetCostLuma4(VP8EncIterator *it , int16_t levels[16] ) 
{ 
  int x ;
  int y ;
  VP8Residual res ;
  VP8Encoder *enc ;
  int R ;
  int ctx ;
  int __cil_tmp9 ;

  {
#line 330
  x = it->i4_ & 3;
  {
#line 330
  y = it->i4_ >> 2;
#line 332
  enc = it->enc_;
#line 333
  R = 0;
#line 336
  InitResidual(0, 3, enc, & res);
#line 337
  ctx = it->top_nz_[x] + it->left_nz_[y];
#line 338
  SetResidualCoeffs(levels, & res);
#line 339
  __cil_tmp9 = GetResidualCost(ctx, & res);
  }
#line 339
  R += __cil_tmp9;
#line 340
  return (R);
}
}
#line 343 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
int VP8GetCostLuma16(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Residual res ;
  VP8Encoder *enc ;
  int x ;
  int y ;
  int R ;
  int __cil_tmp8 ;
  int ctx ;
  int __cil_tmp10 ;

  {
  {
#line 345
  enc = it->enc_;
#line 347
  R = 0;
#line 349
  VP8IteratorNzToBytes(it);
#line 352
  InitResidual(0, 1, enc, & res);
#line 353
  SetResidualCoeffs((int16_t *)rd->y_dc_levels, & res);
#line 354
  __cil_tmp8 = GetResidualCost(it->top_nz_[8] + it->left_nz_[8], & res);
  }
  {
#line 354
  R += __cil_tmp8;
#line 357
  InitResidual(1, 0, enc, & res);
#line 358
  y = 0;
  }
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (y < 4)) {
#line 358
      goto while_break;
    }
#line 359
    x = 0;
    {
#line 359
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 359
      if (! (x < 4)) {
#line 359
        goto while_break___0;
      }
      {
#line 360
      ctx = it->top_nz_[x] + it->left_nz_[y];
#line 361
      SetResidualCoeffs((int16_t *)rd->y_ac_levels[x + y * 4], & res);
#line 362
      __cil_tmp10 = GetResidualCost(ctx, & res);
      }
#line 362
      R += __cil_tmp10;
#line 363
      it->left_nz_[y] = res.last >= 0;
#line 363
      it->top_nz_[x] = it->left_nz_[y];
#line 359
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 358
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  return (R);
}
}
#line 369 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
int VP8GetCostUV(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  VP8Residual res ;
  VP8Encoder *enc ;
  int ch ;
  int x ;
  int y ;
  int R ;
  int ctx ;
  int __cil_tmp10 ;

  {
  {
#line 371
  enc = it->enc_;
#line 373
  R = 0;
#line 375
  VP8IteratorNzToBytes(it);
#line 377
  InitResidual(0, 2, enc, & res);
#line 378
  ch = 0;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! (ch <= 2)) {
#line 378
      goto while_break;
    }
#line 379
    y = 0;
    {
#line 379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 379
      if (! (y < 2)) {
#line 379
        goto while_break___0;
      }
#line 380
      x = 0;
      {
#line 380
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 380
        if (! (x < 2)) {
#line 380
          goto while_break___1;
        }
        {
#line 381
        ctx = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 382
        SetResidualCoeffs((int16_t *)rd->uv_levels[(ch * 2 + x) + y * 2], & res);
#line 383
        __cil_tmp10 = GetResidualCost(ctx, & res);
        }
#line 383
        R += __cil_tmp10;
#line 384
        it->left_nz_[(4 + ch) + y] = res.last >= 0;
#line 384
        it->top_nz_[(4 + ch) + x] = it->left_nz_[(4 + ch) + y];
#line 380
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 379
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 378
    ch += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (R);
}
}
#line 394 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int PutCoeffs(VP8BitWriter *bw , int ctx , VP8Residual *res ) 
{ 
  int n ;
  uint8_t *p ;
  int __cil_tmp6 ;
  int c ;
  int __cil_tmp8 ;
  int sign ;
  int v ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int mask ;
  uint8_t *tab ;
  uint8_t *__cil_tmp20 ;
  int __cil_tmp21 ;

  {
  {
#line 395
  n = res->first;
#line 397
  p = (uint8_t *)(*(res->prob + n))[ctx];
#line 398
  __cil_tmp6 = VP8PutBit(bw, res->last >= 0, (int )*(p + 0));
  }
#line 398
  if (! __cil_tmp6) {
#line 399
    return (0);
  }
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! (n < 16)) {
#line 402
      goto while_break;
    }
#line 403
    __cil_tmp8 = n;
#line 403
    n ++;
#line 403
    c = (int )*(res->coeffs + __cil_tmp8);
#line 404
    sign = c < 0;
#line 405
    if (sign) {
#line 405
      tmp = - c;
    } else {
#line 405
      tmp = c;
    }
    {
#line 405
    v = tmp;
#line 406
    __cil_tmp12 = VP8PutBit(bw, v != 0, (int )*(p + 1));
    }
#line 406
    if (! __cil_tmp12) {
#line 407
      p = (uint8_t *)(*(res->prob + VP8EncBands[n]))[0];
#line 408
      goto while_continue;
    }
    {
#line 410
    __cil_tmp13 = VP8PutBit(bw, v > 1, (int )*(p + 2));
    }
#line 410
    if (! __cil_tmp13) {
#line 411
      p = (uint8_t *)(*(res->prob + VP8EncBands[n]))[1];
    } else {
      {
#line 413
      __cil_tmp14 = VP8PutBit(bw, v > 4, (int )*(p + 3));
      }
#line 413
      if (! __cil_tmp14) {
        {
#line 414
        __cil_tmp15 = VP8PutBit(bw, v != 2, (int )*(p + 4));
        }
#line 414
        if (__cil_tmp15) {
          {
#line 415
          VP8PutBit(bw, v == 4, (int )*(p + 5));
          }
        }
      } else {
        {
#line 416
        __cil_tmp16 = VP8PutBit(bw, v > 10, (int )*(p + 6));
        }
#line 416
        if (! __cil_tmp16) {
          {
#line 417
          __cil_tmp17 = VP8PutBit(bw, v > 6, (int )*(p + 7));
          }
#line 417
          if (! __cil_tmp17) {
            {
#line 418
            VP8PutBit(bw, v == 6, 159);
            }
          } else {
            {
#line 420
            VP8PutBit(bw, v >= 9, 165);
#line 421
            VP8PutBit(bw, ! (v & 1), 145);
            }
          }
        } else {
#line 426
          if (v < 3 + (8 << 1)) {
            {
#line 427
            VP8PutBit(bw, 0, (int )*(p + 8));
#line 428
            VP8PutBit(bw, 0, (int )*(p + 9));
#line 429
            v -= 11;
#line 430
            mask = 1 << 2;
#line 431
            tab = (uint8_t *)VP8Cat3;
            }
          } else
#line 432
          if (v < 3 + (8 << 2)) {
            {
#line 433
            VP8PutBit(bw, 0, (int )*(p + 8));
#line 434
            VP8PutBit(bw, 1, (int )*(p + 9));
#line 435
            v -= 3 + (8 << 1);
#line 436
            mask = 1 << 3;
#line 437
            tab = (uint8_t *)VP8Cat4;
            }
          } else
#line 438
          if (v < 3 + (8 << 3)) {
            {
#line 439
            VP8PutBit(bw, 1, (int )*(p + 8));
#line 440
            VP8PutBit(bw, 0, (int )*(p + 10));
#line 441
            v -= 3 + (8 << 2);
#line 442
            mask = 1 << 4;
#line 443
            tab = (uint8_t *)VP8Cat5;
            }
          } else {
            {
#line 445
            VP8PutBit(bw, 1, (int )*(p + 8));
#line 446
            VP8PutBit(bw, 1, (int )*(p + 10));
#line 447
            v -= 3 + (8 << 3);
#line 448
            mask = 1 << 10;
#line 449
            tab = (uint8_t *)VP8Cat6;
            }
          }
          {
#line 451
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 451
            if (! mask) {
#line 451
              goto while_break___0;
            }
            {
#line 452
            __cil_tmp20 = tab;
#line 452
            tab ++;
#line 452
            VP8PutBit(bw, ! (! (v & mask)), (int )*__cil_tmp20);
#line 453
            mask >>= 1;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 456
      p = (uint8_t *)(*(res->prob + VP8EncBands[n]))[2];
    }
    {
#line 458
    VP8PutBitUniform(bw, sign);
#line 459
    __cil_tmp21 = VP8PutBit(bw, n <= res->last, (int )*(p + 0));
    }
#line 459
    if (n == 16) {
#line 460
      return (1);
    } else
#line 459
    if (! __cil_tmp21) {
#line 460
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return (1);
}
}
#line 466 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void CodeResiduals(VP8BitWriter *bw , VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  int x ;
  int y ;
  int ch ;
  VP8Residual res ;
  uint64_t pos1 ;
  uint64_t pos2 ;
  uint64_t pos3 ;
  int i16 ;
  int segment ;
  VP8Encoder *enc ;
  uint64_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int ctx ;
  int __cil_tmp17 ;
  uint64_t __cil_tmp18 ;
  int ctx___0 ;
  int __cil_tmp20 ;
  uint64_t __cil_tmp21 ;

  {
  {
#line 471
  i16 = (int )(it->mb_)->type_ == 1;
#line 472
  segment = (int )(it->mb_)->segment_;
#line 473
  enc = it->enc_;
#line 475
  VP8IteratorNzToBytes(it);
#line 477
  pos1 = VP8BitWriterPos(bw);
  }
#line 478
  if (i16) {
    {
#line 479
    InitResidual(0, 1, enc, & res);
#line 480
    SetResidualCoeffs((int16_t *)rd->y_dc_levels, & res);
#line 481
    it->top_nz_[8] = PutCoeffs(bw, it->top_nz_[8] + it->left_nz_[8], & res);
#line 483
    InitResidual(1, 0, enc, & res);
    }
  } else {
    {
#line 485
    InitResidual(0, 3, enc, & res);
    }
  }
#line 489
  y = 0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (y < 4)) {
#line 489
      goto while_break;
    }
#line 490
    x = 0;
    {
#line 490
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 490
      if (! (x < 4)) {
#line 490
        goto while_break___0;
      }
      {
#line 491
      ctx = it->top_nz_[x] + it->left_nz_[y];
#line 492
      SetResidualCoeffs((int16_t *)rd->y_ac_levels[x + y * 4], & res);
#line 493
      it->top_nz_[x] = PutCoeffs(bw, ctx, & res);
      }
#line 490
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 489
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 496
  pos2 = VP8BitWriterPos(bw);
#line 499
  InitResidual(0, 2, enc, & res);
#line 500
  ch = 0;
  }
  {
#line 500
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 500
    if (! (ch <= 2)) {
#line 500
      goto while_break___1;
    }
#line 501
    y = 0;
    {
#line 501
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 501
      if (! (y < 2)) {
#line 501
        goto while_break___2;
      }
#line 502
      x = 0;
      {
#line 502
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 502
        if (! (x < 2)) {
#line 502
          goto while_break___3;
        }
        {
#line 503
        ctx___0 = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 504
        SetResidualCoeffs((int16_t *)rd->uv_levels[(ch * 2 + x) + y * 2], & res);
#line 505
        it->top_nz_[(4 + ch) + x] = PutCoeffs(bw, ctx___0, & res);
        }
#line 502
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 501
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 500
    ch += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 510
  pos3 = VP8BitWriterPos(bw);
#line 511
  it->luma_bits_ = pos2 - pos1;
#line 512
  it->uv_bits_ = pos3 - pos2;
#line 513
  it->bit_count_[segment][i16] += it->luma_bits_;
#line 514
  it->bit_count_[segment][2] += it->uv_bits_;
#line 515
  VP8IteratorBytesToNz(it);
  }
  return;
}
}
#line 520 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void RecordResiduals(VP8EncIterator *it , VP8ModeScore *rd ) 
{ 
  int x ;
  int y ;
  int ch ;
  VP8Residual res ;
  VP8Encoder *enc ;
  int __cil_tmp8 ;
  int ctx ;
  int __cil_tmp10 ;
  int ctx___0 ;
  int __cil_tmp12 ;

  {
  {
#line 524
  enc = it->enc_;
#line 526
  VP8IteratorNzToBytes(it);
  }
#line 528
  if ((int )(it->mb_)->type_ == 1) {
    {
#line 529
    InitResidual(0, 1, enc, & res);
#line 530
    SetResidualCoeffs((int16_t *)rd->y_dc_levels, & res);
#line 531
    it->top_nz_[8] = RecordCoeffs(it->top_nz_[8] + it->left_nz_[8], & res);
#line 533
    InitResidual(1, 0, enc, & res);
    }
  } else {
    {
#line 535
    InitResidual(0, 3, enc, & res);
    }
  }
#line 539
  y = 0;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! (y < 4)) {
#line 539
      goto while_break;
    }
#line 540
    x = 0;
    {
#line 540
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 540
      if (! (x < 4)) {
#line 540
        goto while_break___0;
      }
      {
#line 541
      ctx = it->top_nz_[x] + it->left_nz_[y];
#line 542
      SetResidualCoeffs((int16_t *)rd->y_ac_levels[x + y * 4], & res);
#line 543
      it->top_nz_[x] = RecordCoeffs(ctx, & res);
      }
#line 540
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 539
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 548
  InitResidual(0, 2, enc, & res);
#line 549
  ch = 0;
  }
  {
#line 549
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 549
    if (! (ch <= 2)) {
#line 549
      goto while_break___1;
    }
#line 550
    y = 0;
    {
#line 550
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 550
      if (! (y < 2)) {
#line 550
        goto while_break___2;
      }
#line 551
      x = 0;
      {
#line 551
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 551
        if (! (x < 2)) {
#line 551
          goto while_break___3;
        }
        {
#line 552
        ctx___0 = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 553
        SetResidualCoeffs((int16_t *)rd->uv_levels[(ch * 2 + x) + y * 2], & res);
#line 554
        it->top_nz_[(4 + ch) + x] = RecordCoeffs(ctx___0, & res);
        }
#line 551
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 550
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 549
    ch += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 560
  VP8IteratorBytesToNz(it);
  }
  return;
}
}
#line 568 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void RecordTokens(VP8EncIterator *it , VP8ModeScore *rd , VP8TBuffer *tokens ) 
{ 
  int x ;
  int y ;
  int ch ;
  VP8Residual res ;
  VP8Encoder *enc ;
  int ctx ;
  int __cil_tmp10 ;
  int ctx___0 ;
  int __cil_tmp12 ;
  int ctx___1 ;
  int __cil_tmp14 ;

  {
  {
#line 572
  enc = it->enc_;
#line 574
  VP8IteratorNzToBytes(it);
  }
#line 575
  if ((int )(it->mb_)->type_ == 1) {
    {
#line 576
    ctx = it->top_nz_[8] + it->left_nz_[8];
#line 577
    InitResidual(0, 1, enc, & res);
#line 578
    SetResidualCoeffs((int16_t *)rd->y_dc_levels, & res);
#line 579
    it->top_nz_[8] = VP8RecordCoeffTokens(ctx, 1, res.first, res.last, res.coeffs,
                                          tokens);
#line 582
    RecordCoeffs(ctx, & res);
#line 583
    InitResidual(1, 0, enc, & res);
    }
  } else {
    {
#line 585
    InitResidual(0, 3, enc, & res);
    }
  }
#line 589
  y = 0;
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (! (y < 4)) {
#line 589
      goto while_break;
    }
#line 590
    x = 0;
    {
#line 590
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 590
      if (! (x < 4)) {
#line 590
        goto while_break___0;
      }
      {
#line 591
      ctx___0 = it->top_nz_[x] + it->left_nz_[y];
#line 592
      SetResidualCoeffs((int16_t *)rd->y_ac_levels[x + y * 4], & res);
#line 593
      it->top_nz_[x] = VP8RecordCoeffTokens(ctx___0, res.coeff_type, res.first, res.last,
                                            res.coeffs, tokens);
#line 596
      RecordCoeffs(ctx___0, & res);
      }
#line 590
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 589
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 601
  InitResidual(0, 2, enc, & res);
#line 602
  ch = 0;
  }
  {
#line 602
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 602
    if (! (ch <= 2)) {
#line 602
      goto while_break___1;
    }
#line 603
    y = 0;
    {
#line 603
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 603
      if (! (y < 2)) {
#line 603
        goto while_break___2;
      }
#line 604
      x = 0;
      {
#line 604
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 604
        if (! (x < 2)) {
#line 604
          goto while_break___3;
        }
        {
#line 605
        ctx___1 = it->top_nz_[(4 + ch) + x] + it->left_nz_[(4 + ch) + y];
#line 606
        SetResidualCoeffs((int16_t *)rd->uv_levels[(ch * 2 + x) + y * 2], & res);
#line 607
        it->top_nz_[(4 + ch) + x] = VP8RecordCoeffTokens(ctx___1, 2, res.first, res.last,
                                                         res.coeffs, tokens);
#line 610
        RecordCoeffs(ctx___1, & res);
        }
#line 604
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 603
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 602
    ch += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 614
  VP8IteratorBytesToNz(it);
  }
  return;
}
}
#line 632 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void ResetSSE(VP8Encoder *enc ) 
{ 


  {
#line 633
  enc->sse_[0] = (uint64_t )0;
#line 634
  enc->sse_[1] = (uint64_t )0;
#line 635
  enc->sse_[2] = (uint64_t )0;
#line 637
  enc->sse_count_ = (uint64_t )0;
  return;
}
}
#line 640 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void StoreSSE(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  uint8_t *in ;
  uint8_t *out ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 641
  enc = it->enc_;
#line 642
  in = it->yuv_in_;
#line 643
  out = it->yuv_out_;
#line 645
  __cil_tmp5 = (*VP8SSE16x16)(in + 0, out + 0);
  }
  {
#line 645
  enc->sse_[0] += (unsigned long )__cil_tmp5;
#line 646
  __cil_tmp6 = (*VP8SSE8x8)(in + 256, out + 256);
  }
  {
#line 646
  enc->sse_[1] += (unsigned long )__cil_tmp6;
#line 647
  __cil_tmp7 = (*VP8SSE8x8)(in + 264, out + 264);
  }
#line 647
  enc->sse_[2] += (unsigned long )__cil_tmp7;
#line 648
  enc->sse_count_ += (unsigned long )256;
  return;
}
}
#line 651 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void StoreSideInfo(VP8EncIterator *it ) 
{ 
  VP8Encoder *enc ;
  VP8MBInfo *mb ;
  WebPPicture *pic ;
  uint8_t *info ;
  int tmp ;
  int b ;
  int tmp___0 ;

  {
#line 652
  enc = it->enc_;
#line 653
  mb = it->mb_;
#line 654
  pic = enc->pic_;
#line 656
  if (pic->stats != (void *)0) {
    {
#line 657
    StoreSSE(it);
#line 658
    enc->block_count_[0] += (int )mb->type_ == 0;
#line 659
    enc->block_count_[1] += (int )mb->type_ == 1;
#line 660
    enc->block_count_[2] += (int )mb->skip_ != 0;
    }
  }
#line 663
  if (pic->extra_info != (void *)0) {
#line 664
    info = pic->extra_info + (it->x_ + it->y_ * enc->mb_w_);
    {
#line 666
    if (pic->extra_info_type == 1) {
#line 666
      goto case_1;
    }
#line 667
    if (pic->extra_info_type == 2) {
#line 667
      goto case_2;
    }
#line 668
    if (pic->extra_info_type == 3) {
#line 668
      goto case_3;
    }
#line 669
    if (pic->extra_info_type == 4) {
#line 669
      goto case_4;
    }
#line 670
    if (pic->extra_info_type == 5) {
#line 670
      goto case_5;
    }
#line 671
    if (pic->extra_info_type == 6) {
#line 671
      goto case_6;
    }
#line 675
    if (pic->extra_info_type == 7) {
#line 675
      goto case_7;
    }
#line 676
    goto switch_default;
    case_1: /* CIL Label */ 
#line 666
    *info = (uint8_t )mb->type_;
#line 666
    goto switch_break;
    case_2: /* CIL Label */ 
#line 667
    *info = (uint8_t )mb->segment_;
#line 667
    goto switch_break;
    case_3: /* CIL Label */ 
#line 668
    *info = (uint8_t )enc->dqm_[mb->segment_].quant_;
#line 668
    goto switch_break;
    case_4: /* CIL Label */ 
#line 669
    if ((int )mb->type_ == 1) {
#line 669
      tmp = (int )*(it->preds_ + 0);
    } else {
#line 669
      tmp = 255;
    }
#line 669
    *info = (uint8_t )tmp;
#line 669
    goto switch_break;
    case_5: /* CIL Label */ 
#line 670
    *info = (uint8_t )mb->uv_mode_;
#line 670
    goto switch_break;
    case_6: /* CIL Label */ 
#line 672
    b = (int )(((it->luma_bits_ + it->uv_bits_) + 7UL) >> 3);
#line 673
    if (b > 255) {
#line 673
      tmp___0 = 255;
    } else {
#line 673
      tmp___0 = b;
    }
#line 673
    *info = (uint8_t )tmp___0;
#line 673
    goto switch_break;
    case_7: /* CIL Label */ 
#line 675
    *info = mb->alpha_;
#line 675
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 676
    *info = (uint8_t )0;
#line 676
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }

  }
  return;
}
}
#line 693 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void SetLoopParams(VP8Encoder *enc , float q ) 
{ 


  {
#line 695
  if ((double )q < 0.) {
#line 696
    q = (float )0;
  } else
#line 697
  if ((double )q > 100.) {
#line 698
    q = (float )100;
  }
  {
#line 701
  VP8SetSegmentParams(enc, q);
#line 702
  SetSegmentProbas(enc);
#line 704
  ResetStats(enc);
#line 705
  ResetTokenStats(enc);
#line 707
  ResetSSE(enc);
  }
  return;
}
}
#line 710 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int OneStatPass(VP8Encoder *enc , float q , VP8RDLevel rd_opt , int nb_mbs ,
                       float *PSNR , int percent_delta ) 
{ 
  VP8EncIterator it ;
  uint64_t size ;
  uint64_t distortion ;
  uint64_t pixel_count ;
  int __cil_tmp11 ;
  VP8ModeScore info ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  double __cil_tmp18 ;

  {
  {
#line 713
  size = (uint64_t )0;
#line 714
  distortion = (uint64_t )0;
#line 715
  pixel_count = (uint64_t )(nb_mbs * 384);
#line 717
  SetLoopParams(enc, q);
#line 719
  VP8IteratorInit(enc, & it);
  }
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 722
    VP8IteratorImport(& it);
#line 723
    __cil_tmp13 = VP8Decimate(& it, & info, rd_opt);
    }
#line 723
    if (__cil_tmp13) {
#line 725
      (enc->proba_.nb_skip_) ++;
    }
    {
#line 727
    RecordResiduals(& it, & info);
#line 728
    size += (unsigned long )info.R;
#line 729
    distortion += (unsigned long )info.D;
#line 730
    __cil_tmp15 = VP8IteratorProgress(& it, percent_delta);
    }
#line 730
    if (percent_delta) {
#line 730
      if (! __cil_tmp15) {
#line 731
        return (0);
      }
    }
#line 720
    if (! (__cil_tmp11 && nb_mbs > 0)) {
#line 720
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 733
  __cil_tmp16 = FinalizeSkipProba(enc);
  }
  {
#line 733
  size += (unsigned long )__cil_tmp16;
#line 734
  __cil_tmp17 = FinalizeTokenProbas(& enc->proba_);
  }
#line 734
  size += (unsigned long )__cil_tmp17;
#line 735
  size += (unsigned long )enc->segment_hdr_.size_;
#line 736
  size = ((size + 1024UL) >> 11) + 45UL;
#line 738
  if (PSNR) {
    {
#line 739
    __cil_tmp18 = log10(((255. * 255.) * (double )pixel_count) / (double )distortion);
#line 739
    *PSNR = (float )(10. * __cil_tmp18);
    }
  }
#line 741
  return ((int )size);
}
}
#line 745 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int const   dqs[9]  = 
#line 745
  {      20,      15,      10,      8, 
        6,      4,      2,      1, 
        0};
#line 747 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int StatLoop(VP8Encoder *enc ) 
{ 
  int method ;
  int do_search ;
  int fast_probe ;
  float q ;
  int max_passes ;
  int task_percent ;
  int percent_per_pass ;
  int final_percent ;
  int pass ;
  int nb_mbs ;
  int tmp ;
  int tmp___0 ;
  VP8RDLevel rd_opt ;
  int tmp___1 ;
  int __cil_tmp16 ;
  float PSNR ;
  int criterion ;
  int size ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 748
  method = enc->method_;
#line 749
  do_search = enc->do_search_;
#line 750
  fast_probe = (method == 0 || method == 3) && ! do_search;
#line 751
  q = (enc->config_)->quality;
#line 752
  max_passes = (enc->config_)->pass;
#line 753
  task_percent = 20;
#line 754
  percent_per_pass = (task_percent + max_passes / 2) / max_passes;
#line 755
  final_percent = enc->percent_ + task_percent;
#line 760
  nb_mbs = enc->mb_w_ * enc->mb_h_;
#line 761
  if (fast_probe) {
#line 762
    if (method == 3) {
#line 763
      if (nb_mbs > 200) {
#line 763
        tmp = nb_mbs >> 1;
      } else {
#line 763
        tmp = 100;
      }
#line 763
      nb_mbs = tmp;
    } else {
#line 765
      if (nb_mbs > 200) {
#line 765
        tmp___0 = nb_mbs >> 2;
      } else {
#line 765
        tmp___0 = 50;
      }
#line 765
      nb_mbs = tmp___0;
    }
  }
#line 770
  if (! do_search) {
#line 771
    pass = 0;
    {
#line 771
    while (1) {
      while_continue: /* CIL Label */ ;
#line 771
      if (! (pass < max_passes)) {
#line 771
        goto while_break;
      }
#line 772
      if (method >= 3) {
#line 772
        tmp___1 = 1;
      } else {
#line 772
        tmp___1 = 0;
      }
      {
#line 772
      rd_opt = (VP8RDLevel )tmp___1;
#line 773
      __cil_tmp16 = OneStatPass(enc, q, rd_opt, nb_mbs, (float *)((void *)0), percent_per_pass);
      }
#line 773
      if (! __cil_tmp16) {
#line 774
        return (0);
      }
#line 771
      pass ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 779
    pass = 0;
    {
#line 779
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 779
      if (! (pass < max_passes && dqs[pass] > 0)) {
#line 779
        goto while_break___0;
      }
      {
#line 782
      __cil_tmp20 = OneStatPass(enc, q, (VP8RDLevel )1, nb_mbs, & PSNR, percent_per_pass);
#line 782
      size = __cil_tmp20;
      }
#line 787
      if (size == 0) {
#line 787
        return (0);
      }
#line 788
      if ((enc->config_)->target_PSNR > (float )0) {
#line 789
        criterion = PSNR < (enc->config_)->target_PSNR;
      } else {
#line 791
        criterion = size < (enc->config_)->target_size;
      }
#line 794
      if (criterion) {
#line 795
        q += (float )dqs[pass];
      } else {
#line 797
        q -= (float )dqs[pass];
      }
#line 779
      pass ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 801
  VP8CalculateLevelCosts(& enc->proba_);
#line 802
  __cil_tmp21 = WebPReportProgress(enc->pic_, final_percent, & enc->percent_);
  }
#line 802
  return (__cil_tmp21);
}
}
#line 809 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int const   kAverageBytesPerMB[8]  = 
#line 809
  {      50,      24,      16,      9, 
        7,      5,      3,      2};
#line 811 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int PreLoopInitialize(VP8Encoder *enc ) 
{ 
  int p ;
  int ok ;
  int average_bytes_per_MB ;
  int bytes_per_parts ;
  int __cil_tmp6 ;

  {
#line 813
  ok = 1;
#line 814
  average_bytes_per_MB = kAverageBytesPerMB[enc->base_quant_ >> 4];
#line 815
  bytes_per_parts = ((enc->mb_w_ * enc->mb_h_) * average_bytes_per_MB) / enc->num_parts_;
#line 818
  p = 0;
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! (ok && p < enc->num_parts_)) {
#line 818
      goto while_break;
    }
    {
#line 819
    ok = VP8BitWriterInit((VP8BitWriter *)enc->parts_ + p, (size_t )bytes_per_parts);
    }
#line 818
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 821
  if (! ok) {
    {
#line 821
    VP8EncFreeBitWriters(enc);
    }
  }
#line 822
  return (ok);
}
}
#line 825 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static int PostLoopFinalize(VP8EncIterator *it , int ok ) 
{ 
  VP8Encoder *enc ;
  int p ;
  int i ;
  int s ;

  {
#line 826
  enc = it->enc_;
#line 827
  if (ok) {
#line 829
    p = 0;
    {
#line 829
    while (1) {
      while_continue: /* CIL Label */ ;
#line 829
      if (! (p < enc->num_parts_)) {
#line 829
        goto while_break;
      }
      {
#line 830
      VP8BitWriterFinish((VP8BitWriter *)enc->parts_ + p);
#line 831
      ok &= ! enc->parts_[p].error_;
      }
#line 829
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 835
  if (ok) {
#line 836
    if ((enc->pic_)->stats) {
#line 838
      i = 0;
      {
#line 838
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 838
        if (! (i <= 2)) {
#line 838
          goto while_break___0;
        }
#line 839
        s = 0;
        {
#line 839
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 839
          if (! (s < 4)) {
#line 839
            goto while_break___1;
          }
#line 840
          enc->residual_bytes_[i][s] = (int )((it->bit_count_[s][i] + 7UL) >> 3);
#line 839
          s ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 838
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 844
    VP8AdjustFilterStrength(it);
    }
  } else {
    {
#line 847
    VP8EncFreeBitWriters(enc);
    }
  }
#line 849
  return (ok);
}
}
#line 855 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
static void ResetAfterSkip(VP8EncIterator *it ) 
{ 


  {
#line 856
  if ((int )(it->mb_)->type_ == 1) {
#line 857
    *(it->nz_) = (uint32_t )0;
#line 858
    it->left_nz_[8] = 0;
  } else {
#line 860
    *(it->nz_) &= (unsigned int )(1 << 24);
  }
  return;
}
}
#line 864 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
int VP8EncLoop(VP8Encoder *enc ) 
{ 
  VP8EncIterator it ;
  int ok ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  VP8ModeScore info ;
  int dont_use_skip ;
  VP8RDLevel rd_opt ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 866
  __cil_tmp4 = PreLoopInitialize(enc);
#line 866
  ok = __cil_tmp4;
  }
#line 867
  if (! ok) {
#line 867
    return (0);
  }
  {
#line 869
  StatLoop(enc);
#line 871
  VP8IteratorInit(enc, & it);
#line 872
  VP8InitFilter(& it);
  }
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 875
    dont_use_skip = ! enc->proba_.use_skip_proba_;
#line 876
    rd_opt = enc->rd_opt_level_;
#line 878
    VP8IteratorImport(& it);
#line 881
    __cil_tmp9 = VP8Decimate(& it, & info, rd_opt);
    }
#line 881
    if (! __cil_tmp9) {
      {
      {
#line 882
      CodeResiduals(it.bw_, & it, & info);
      }
      }
    } else
#line 881
    if (dont_use_skip) {
      {
      {
#line 882
      CodeResiduals(it.bw_, & it, & info);
      }
      }
    } else {
      {
#line 884
      ResetAfterSkip(& it);
      }
    }
    {
#line 891
    StoreSideInfo(& it);
#line 892
    VP8StoreFilterStats(& it);
#line 893
    VP8IteratorExport(& it);
#line 894
    ok = VP8IteratorProgress(& it, 20);
    }
#line 873
    if (! (ok && __cil_tmp5)) {
#line 873
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 897
  __cil_tmp11 = PostLoopFinalize(& it, ok);
  }
#line 897
  return (__cil_tmp11);
}
}
#line 907 "/doner/libwebp/libwebp-v0.3.0/src/enc/frame.c"
int VP8EncTokenLoop(VP8Encoder *enc ) 
{ 
  int ok ;
  int max_count ;
  int cnt ;
  VP8EncIterator it ;
  VP8Proba *proba ;
  VP8RDLevel rd_opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  VP8ModeScore info ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 910
  max_count = enc->mb_w_ * enc->mb_h_ >> 3;
#line 913
  proba = & enc->proba_;
#line 914
  rd_opt = enc->rd_opt_level_;
#line 916
  if (max_count < 96) {
#line 916
    max_count = 96;
  }
  {
#line 917
  cnt = max_count;
#line 925
  SetLoopParams(enc, (enc->config_)->quality);
#line 927
  ok = PreLoopInitialize(enc);
  }
#line 928
  if (! ok) {
#line 928
    return (0);
  }
  {
#line 930
  VP8IteratorInit(enc, & it);
#line 931
  VP8InitFilter(& it);
  }
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 934
    VP8IteratorImport(& it);
#line 935
    cnt --;
    }
#line 935
    if (cnt < 0) {
      {
#line 936
      FinalizeTokenProbas(proba);
#line 937
      VP8CalculateLevelCosts(proba);
#line 938
      cnt = max_count;
      }
    }
    {
#line 940
    VP8Decimate(& it, & info, rd_opt);
#line 941
    RecordTokens(& it, & info, & enc->tokens_);
#line 947
    StoreSideInfo(& it);
#line 948
    VP8StoreFilterStats(& it);
#line 949
    VP8IteratorExport(& it);
#line 950
    ok = VP8IteratorProgress(& it, 20);
    }
#line 932
    if (! (ok && __cil_tmp14)) {
#line 932
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 953
  __cil_tmp17 = WebPReportProgress(enc->pic_, enc->percent_ + 20, & enc->percent_);
#line 953
  ok = ok && __cil_tmp17;
  }
#line 955
  if (ok) {
    {
#line 956
    FinalizeTokenProbas(proba);
#line 957
    ok = VP8EmitTokens(& enc->tokens_, (VP8BitWriter *)enc->parts_ + 0, (uint8_t *)((ProbaArray (*)[8])proba->coeffs_),
                       1);
    }
  }
  {
#line 961
  __cil_tmp19 = PostLoopFinalize(& it, ok);
  }
#line 961
  return (__cil_tmp19);
}
}
#line 19 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static uint8_t abs0[511] ;
#line 20
static uint8_t abs1[511] ;
#line 21
static int8_t sclip1[2041] ;
#line 22
static int8_t sclip2[225] ;
#line 23
static uint8_t clip1[766] ;
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static int tables_ok  =    0;
#line 27 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void InitTables(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 28
  if (! tables_ok) {
#line 30
    i = - 255;
    {
#line 30
    while (1) {
      while_continue: /* CIL Label */ ;
#line 30
      if (! (i <= 255)) {
#line 30
        goto while_break;
      }
#line 31
      if (i < 0) {
#line 31
        tmp = - i;
      } else {
#line 31
        tmp = i;
      }
#line 31
      abs0[255 + i] = (uint8_t )tmp;
#line 32
      abs1[255 + i] = (uint8_t )((int )abs0[255 + i] >> 1);
#line 30
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 34
    i = - 1020;
    {
#line 34
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 34
      if (! (i <= 1020)) {
#line 34
        goto while_break___0;
      }
#line 35
      if (i < -128) {
#line 35
        tmp___1 = - 128;
      } else {
#line 35
        if (i > 127) {
#line 35
          tmp___0 = 127;
        } else {
#line 35
          tmp___0 = i;
        }
#line 35
        tmp___1 = tmp___0;
      }
#line 35
      sclip1[1020 + i] = (int8_t )tmp___1;
#line 34
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 37
    i = - 112;
    {
#line 37
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 37
      if (! (i <= 112)) {
#line 37
        goto while_break___1;
      }
#line 38
      if (i < -16) {
#line 38
        tmp___3 = - 16;
      } else {
#line 38
        if (i > 15) {
#line 38
          tmp___2 = 15;
        } else {
#line 38
          tmp___2 = i;
        }
#line 38
        tmp___3 = tmp___2;
      }
#line 38
      sclip2[112 + i] = (int8_t )tmp___3;
#line 37
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 40
    i = - 255;
    {
#line 40
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 40
      if (! (i <= 510)) {
#line 40
        goto while_break___2;
      }
#line 41
      if (i < 0) {
#line 41
        tmp___5 = 0;
      } else {
#line 41
        if (i > 255) {
#line 41
          tmp___4 = 255;
        } else {
#line 41
          tmp___4 = i;
        }
#line 41
        tmp___5 = tmp___4;
      }
#line 41
      clip1[255 + i] = (uint8_t )tmp___5;
#line 40
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 43
    tables_ok = 1;
  }
  return;
}
}
#line 51 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
__inline static void do_filter2(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;

  {
#line 52
  p1 = (int )*(p + -2 * step);
#line 52
  p0 = (int )*(p + - step);
#line 52
  q0 = (int )*(p + 0);
#line 52
  q1 = (int )*(p + step);
#line 53
  a = 3 * (q0 - p0) + (int )sclip1[(1020 + p1) - q1];
#line 54
  a1 = (int )sclip2[112 + ((a + 4) >> 3)];
#line 55
  a2 = (int )sclip2[112 + ((a + 3) >> 3)];
#line 56
  *(p + - step) = clip1[(255 + p0) + a2];
#line 57
  *(p + 0) = clip1[(255 + q0) - a1];
  return;
}
}
#line 61 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
__inline static void do_filter4(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;
  int a3 ;

  {
#line 62
  p1 = (int )*(p + -2 * step);
#line 62
  p0 = (int )*(p + - step);
#line 62
  q0 = (int )*(p + 0);
#line 62
  q1 = (int )*(p + step);
#line 63
  a = 3 * (q0 - p0);
#line 64
  a1 = (int )sclip2[112 + ((a + 4) >> 3)];
#line 65
  a2 = (int )sclip2[112 + ((a + 3) >> 3)];
#line 66
  a3 = (a1 + 1) >> 1;
#line 67
  *(p + -2 * step) = clip1[(255 + p1) + a3];
#line 68
  *(p + - step) = clip1[(255 + p0) + a2];
#line 69
  *(p + 0) = clip1[(255 + q0) - a1];
#line 70
  *(p + step) = clip1[(255 + q1) - a3];
  return;
}
}
#line 74 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
__inline static int hev(uint8_t *p , int step , int thresh ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;

  {
#line 75
  p1 = (int )*(p + -2 * step);
#line 75
  p0 = (int )*(p + - step);
#line 75
  q0 = (int )*(p + 0);
#line 75
  q1 = (int )*(p + step);
#line 76
  return ((int )abs0[(255 + p1) - p0] > thresh || (int )abs0[(255 + q1) - q0] > thresh);
}
}
#line 79 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
__inline static int needs_filter(uint8_t *p , int step , int thresh ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;

  {
#line 80
  p1 = (int )*(p + -2 * step);
#line 80
  p0 = (int )*(p + - step);
#line 80
  q0 = (int )*(p + 0);
#line 80
  q1 = (int )*(p + step);
#line 81
  return (2 * (int )abs0[(255 + p0) - q0] + (int )abs1[(255 + p1) - q1] <= thresh);
}
}
#line 84 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
__inline static int needs_filter2(uint8_t *p , int step , int t , int it ) 
{ 
  int p3 ;
  int p2 ;
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int q2 ;
  int q3 ;

  {
#line 86
  p3 = (int )*(p + -4 * step);
#line 86
  p2 = (int )*(p + -3 * step);
#line 86
  p1 = (int )*(p + -2 * step);
#line 86
  p0 = (int )*(p + - step);
#line 87
  q0 = (int )*(p + 0);
#line 87
  q1 = (int )*(p + step);
#line 87
  q2 = (int )*(p + 2 * step);
#line 87
  q3 = (int )*(p + 3 * step);
#line 88
  if (2 * (int )abs0[(255 + p0) - q0] + (int )abs1[(255 + p1) - q1] > t) {
#line 89
    return (0);
  }
#line 90
  return ((((((int )abs0[(255 + p3) - p2] <= it && (int )abs0[(255 + p2) - p1] <= it) && (int )abs0[(255 + p1) - p0] <= it) && (int )abs0[(255 + q3) - q2] <= it) && (int )abs0[(255 + q2) - q1] <= it) && (int )abs0[(255 + q1) - q0] <= it);
}
}
#line 98 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void SimpleVFilter16(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < 16)) {
#line 100
      goto while_break;
    }
    {
#line 101
    __cil_tmp5 = needs_filter(p + i, stride, thresh);
    }
#line 101
    if (__cil_tmp5) {
      {
#line 102
      do_filter2(p + i, stride);
      }
    }
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 107 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void SimpleHFilter16(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 109
  i = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < 16)) {
#line 109
      goto while_break;
    }
    {
#line 110
    __cil_tmp5 = needs_filter(p + i * stride, 1, thresh);
    }
#line 110
    if (__cil_tmp5) {
      {
#line 111
      do_filter2(p + i * stride, 1);
      }
    }
#line 109
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 116 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void SimpleVFilter16i(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 118
  k = 3;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (k > 0)) {
#line 118
      goto while_break;
    }
    {
#line 119
    p += 4 * stride;
#line 120
    SimpleVFilter16(p, stride, thresh);
    }
#line 118
    k --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 124 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void SimpleHFilter16i(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 126
  k = 3;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (k > 0)) {
#line 126
      goto while_break;
    }
    {
#line 127
    p += 4;
#line 128
    SimpleHFilter16(p, stride, thresh);
    }
#line 126
    k --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 135 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
__inline static void FilterLoop24(uint8_t *p , int hstride , int vstride , int size ,
                                  int thresh , int ithresh , int hev_thresh ) 
{ 
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    __cil_tmp8 = size;
#line 138
    size --;
#line 138
    if (! (__cil_tmp8 > 0)) {
#line 138
      goto while_break;
    }
    {
#line 139
    __cil_tmp9 = needs_filter2(p, hstride, thresh, ithresh);
    }
#line 139
    if (__cil_tmp9) {
      {
#line 140
      __cil_tmp10 = hev(p, hstride, hev_thresh);
      }
#line 140
      if (__cil_tmp10) {
        {
#line 141
        do_filter2(p, hstride);
        }
      } else {
        {
#line 143
        do_filter4(p, hstride);
        }
      }
    }
#line 146
    p += vstride;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 151 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void VFilter16i(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 154
  k = 3;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (k > 0)) {
#line 154
      goto while_break;
    }
    {
#line 155
    p += 4 * stride;
#line 156
    FilterLoop24(p, stride, 1, 16, thresh, ithresh, hev_thresh);
    }
#line 154
    k --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 160 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void HFilter16i(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 163
  k = 3;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (k > 0)) {
#line 163
      goto while_break;
    }
    {
#line 164
    p += 4;
#line 165
    FilterLoop24(p, 1, stride, 16, thresh, ithresh, hev_thresh);
    }
#line 163
    k --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 169 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void VFilter8i(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                      int hev_thresh ) 
{ 


  {
  {
#line 171
  FilterLoop24(u + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
#line 172
  FilterLoop24(v + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
  }
  return;
}
}
#line 175 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void HFilter8i(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                      int hev_thresh ) 
{ 


  {
  {
#line 177
  FilterLoop24(u + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
#line 178
  FilterLoop24(v + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
  }
  return;
}
}
#line 183 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void (*VP8EncVFilter16i)(uint8_t * , int  , int  , int  , int  )  =    & VFilter16i;
#line 184 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void (*VP8EncHFilter16i)(uint8_t * , int  , int  , int  , int  )  =    & HFilter16i;
#line 185 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void (*VP8EncVFilter8i)(uint8_t * , uint8_t * , int  , int  , int  , int  )  =    & VFilter8i;
#line 186 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void (*VP8EncHFilter8i)(uint8_t * , uint8_t * , int  , int  , int  , int  )  =    & HFilter8i;
#line 188 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void (*VP8EncSimpleVFilter16i)(uint8_t * , int  , int  )  =    & SimpleVFilter16i;
#line 189 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void (*VP8EncSimpleHFilter16i)(uint8_t * , int  , int  )  =    & SimpleHFilter16i;
#line 194 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static int GetILevel(int sharpness , int level ) 
{ 


  {
#line 195
  if (sharpness > 0) {
#line 196
    if (sharpness > 4) {
#line 197
      level >>= 2;
    } else {
#line 199
      level >>= 1;
    }
#line 201
    if (level > 9 - sharpness) {
#line 202
      level = 9 - sharpness;
    }
  }
#line 205
  if (level < 1) {
#line 205
    level = 1;
  }
#line 206
  return (level);
}
}
#line 209 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void DoFilter(VP8EncIterator *it , int level ) 
{ 
  VP8Encoder *enc ;
  int ilevel ;
  int __cil_tmp5 ;
  int limit ;
  uint8_t *y_dst ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  int hev_thresh ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 210
  enc = it->enc_;
#line 211
  __cil_tmp5 = GetILevel((enc->config_)->filter_sharpness, level);
#line 211
  ilevel = __cil_tmp5;
#line 212
  limit = 2 * level + ilevel;
#line 214
  y_dst = it->yuv_out2_ + 0;
#line 215
  u_dst = it->yuv_out2_ + 256;
#line 216
  v_dst = it->yuv_out2_ + 264;
#line 219
  memcpy(y_dst, it->yuv_out_, 384UL * sizeof(uint8_t ));
  }
#line 221
  if (enc->filter_hdr_.simple_ == 1) {
    {
#line 222
    (*VP8EncSimpleHFilter16i)(y_dst, 16, limit);
#line 223
    (*VP8EncSimpleVFilter16i)(y_dst, 16, limit);
    }
  } else {
#line 225
    if (level >= 40) {
#line 225
      tmp___0 = 2;
    } else {
#line 225
      if (level >= 15) {
#line 225
        tmp = 1;
      } else {
#line 225
        tmp = 0;
      }
#line 225
      tmp___0 = tmp;
    }
    {
#line 225
    hev_thresh = tmp___0;
#line 226
    (*VP8EncHFilter16i)(y_dst, 16, limit, ilevel, hev_thresh);
#line 227
    (*VP8EncHFilter8i)(u_dst, v_dst, 16, limit, ilevel, hev_thresh);
#line 228
    (*VP8EncVFilter16i)(y_dst, 16, limit, ilevel, hev_thresh);
#line 229
    (*VP8EncVFilter8i)(u_dst, v_dst, 16, limit, ilevel, hev_thresh);
    }
  }
  return;
}
}
#line 237 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static double const   kMinValue  =    1.00000000001e-10;
#line 239 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void VP8SSIMAddStats(DistoStats *src , DistoStats *dst ) 
{ 


  {
#line 240
  dst->w += src->w;
#line 241
  dst->xm += src->xm;
#line 242
  dst->ym += src->ym;
#line 243
  dst->xxm += src->xxm;
#line 244
  dst->xym += src->xym;
#line 245
  dst->yym += src->yym;
  return;
}
}
#line 248 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static void VP8SSIMAccumulate(uint8_t *src1 , int stride1 , uint8_t *src2 , int stride2 ,
                              int xo , int yo , int W , int H , DistoStats *stats ) 
{ 
  int ymin ;
  int tmp ;
  int ymax ;
  int tmp___0 ;
  int xmin ;
  int tmp___1 ;
  int xmax ;
  int tmp___2 ;
  int x ;
  int y ;
  int s1 ;
  int s2 ;

  {
#line 252
  if (yo - 3 < 0) {
#line 252
    tmp = 0;
  } else {
#line 252
    tmp = yo - 3;
  }
#line 252
  ymin = tmp;
#line 253
  if (yo + 3 > H - 1) {
#line 253
    tmp___0 = H - 1;
  } else {
#line 253
    tmp___0 = yo + 3;
  }
#line 253
  ymax = tmp___0;
#line 254
  if (xo - 3 < 0) {
#line 254
    tmp___1 = 0;
  } else {
#line 254
    tmp___1 = xo - 3;
  }
#line 254
  xmin = tmp___1;
#line 255
  if (xo + 3 > W - 1) {
#line 255
    tmp___2 = W - 1;
  } else {
#line 255
    tmp___2 = xo + 3;
  }
#line 255
  xmax = tmp___2;
#line 257
  src1 += ymin * stride1;
#line 258
  src2 += ymin * stride2;
#line 259
  y = ymin;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (y <= ymax)) {
#line 259
      goto while_break;
    }
#line 260
    x = xmin;
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 260
      if (! (x <= xmax)) {
#line 260
        goto while_break___0;
      }
#line 261
      s1 = (int )*(src1 + x);
#line 262
      s2 = (int )*(src2 + x);
#line 263
      stats->w += (double )1;
#line 264
      stats->xm += (double )s1;
#line 265
      stats->ym += (double )s2;
#line 266
      stats->xxm += (double )(s1 * s1);
#line 267
      stats->xym += (double )(s1 * s2);
#line 268
      stats->yym += (double )(s2 * s2);
#line 260
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 259
    src2 += stride2;
#line 259
    src1 += stride1;
#line 259
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 273 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
double VP8SSIMGet(DistoStats *stats ) 
{ 
  double xmxm ;
  double ymym ;
  double xmym ;
  double w2 ;
  double sxx ;
  double syy ;
  double sxy ;
  double C1 ;
  double C2 ;
  double fnum ;
  double fden ;
  double tmp ;

  {
#line 274
  xmxm = stats->xm * stats->xm;
#line 275
  ymym = stats->ym * stats->ym;
#line 276
  xmym = stats->xm * stats->ym;
#line 277
  w2 = stats->w * stats->w;
#line 278
  sxx = stats->xxm * stats->w - xmxm;
#line 279
  syy = stats->yym * stats->w - ymym;
#line 280
  sxy = stats->xym * stats->w - xmym;
#line 285
  if (sxx < 0.) {
#line 285
    sxx = 0.;
  }
#line 286
  if (syy < 0.) {
#line 286
    syy = 0.;
  }
#line 287
  C1 = 6.50250000001 * w2;
#line 288
  C2 = 58.5225000001 * w2;
#line 289
  fnum = ((double )2 * xmym + C1) * ((double )2 * sxy + C2);
#line 290
  fden = ((xmxm + ymym) + C1) * ((sxx + syy) + C2);
#line 291
  if (fden != 0.) {
#line 291
    tmp = fnum / fden;
  } else {
#line 291
    tmp = (double )kMinValue;
  }
#line 291
  return ((int )tmp);
}
}
#line 294 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
double VP8SSIMGetSquaredError(DistoStats *s ) 
{ 
  double iw2 ;
  double sxx ;
  double syy ;
  double sxy ;
  double SSE ;

  {
#line 295
  if (s->w > 0.) {
#line 296
    iw2 = 1. / (s->w * s->w);
#line 297
    sxx = s->xxm * s->w - s->xm * s->xm;
#line 298
    syy = s->yym * s->w - s->ym * s->ym;
#line 299
    sxy = s->xym * s->w - s->xm * s->ym;
#line 300
    SSE = iw2 * ((sxx + syy) - 2. * sxy);
#line 301
    if (SSE > kMinValue) {
#line 301
      return (SSE);
    }
  }
#line 303
  return (kMinValue);
}
}
#line 306 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void VP8SSIMAccumulatePlane(uint8_t *src1 , int stride1 , uint8_t *src2 , int stride2 ,
                            int W , int H , DistoStats *stats ) 
{ 
  int x ;
  int y ;

  {
#line 310
  y = 0;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! (y < H)) {
#line 310
      goto while_break;
    }
#line 311
    x = 0;
    {
#line 311
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 311
      if (! (x < W)) {
#line 311
        goto while_break___0;
      }
      {
#line 312
      VP8SSIMAccumulate(src1, stride1, src2, stride2, x, y, W, H, stats);
      }
#line 311
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 310
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 317 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
static double GetMBSSIM(uint8_t *yuv1 , uint8_t *yuv2 ) 
{ 
  int x ;
  int y ;
  DistoStats s ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 319
  s.w = 0.;
#line 319
  s.xm = 0.;
#line 319
  s.ym = 0.;
#line 319
  s.xxm = 0.;
#line 319
  s.xym = 0.;
#line 319
  s.yym = 0.;
#line 322
  x = 3;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (x < 13)) {
#line 322
      goto while_break;
    }
#line 323
    y = 3;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 323
      if (! (y < 13)) {
#line 323
        goto while_break___0;
      }
      {
#line 324
      VP8SSIMAccumulate(yuv1 + 0, 16, yuv2 + 0, 16, x, y, 16, 16, & s);
      }
#line 323
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 322
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  x = 1;
  {
#line 327
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 327
    if (! (x < 7)) {
#line 327
      goto while_break___1;
    }
#line 328
    y = 1;
    {
#line 328
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 328
      if (! (y < 7)) {
#line 328
        goto while_break___2;
      }
      {
#line 329
      VP8SSIMAccumulate(yuv1 + 256, 16, yuv2 + 256, 16, x, y, 8, 8, & s);
#line 330
      VP8SSIMAccumulate(yuv1 + 264, 16, yuv2 + 264, 16, x, y, 8, 8, & s);
      }
#line 328
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 327
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 333
  __cil_tmp10 = VP8SSIMGet(& s);
  }
#line 333
  return (__cil_tmp10);
}
}
#line 340 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void VP8InitFilter(VP8EncIterator *it ) 
{ 
  int s ;
  int i ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 342
  if (! it->lf_stats_) {
#line 342
    return;
  }
  {
#line 344
  InitTables();
#line 345
  s = 0;
  }
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (s < 4)) {
#line 345
      goto while_break;
    }
#line 346
    i = 0;
    {
#line 346
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 346
      if (! (i < 64)) {
#line 346
        goto while_break___0;
      }
#line 347
      (*(it->lf_stats_))[s][i] = (double )0;
#line 346
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 345
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 352 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void VP8StoreFilterStats(VP8EncIterator *it ) 
{ 
  int d ;
  int s ;
  int level0 ;
  int delta_min ;
  int delta_max ;
  int step_size ;
  int tmp ;
  double __cil_tmp9 ;
  int level ;
  double __cil_tmp11 ;

  {
#line 354
  s = (int )(it->mb_)->segment_;
#line 355
  level0 = (it->enc_)->dqm_[s].fstrength_;
#line 358
  delta_min = - (it->enc_)->dqm_[s].quant_;
#line 359
  delta_max = (it->enc_)->dqm_[s].quant_;
#line 360
  if (delta_max - delta_min >= 4) {
#line 360
    tmp = 4;
  } else {
#line 360
    tmp = 1;
  }
#line 360
  step_size = tmp;
#line 362
  if (! it->lf_stats_) {
#line 362
    return;
  }
#line 370
  if ((int )(it->mb_)->type_ == 1) {
#line 370
    if ((int )(it->mb_)->skip_) {
#line 370
      return;
    }
  }
  {
#line 373
  __cil_tmp9 = GetMBSSIM(it->yuv_in_, it->yuv_out_);
  }
#line 373
  (*(it->lf_stats_))[s][0] += __cil_tmp9;
#line 375
  d = delta_min;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (d <= delta_max)) {
#line 375
      goto while_break;
    }
#line 376
    level = level0 + d;
#line 377
    if (level <= 0) {
#line 378
      goto while_continue;
    } else
#line 377
    if (level >= 64) {
#line 378
      goto while_continue;
    }
    {
#line 380
    DoFilter(it, level);
#line 381
    __cil_tmp11 = GetMBSSIM(it->yuv_in_, it->yuv_out2_);
    }
#line 381
    (*(it->lf_stats_))[s][level] += __cil_tmp11;
#line 375
    d += step_size;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 385 "/doner/libwebp/libwebp-v0.3.0/src/enc/filter.c"
void VP8AdjustFilterStrength(VP8EncIterator *it ) 
{ 
  int s ;
  VP8Encoder *enc ;
  int i ;
  int best_level ;
  double best_v ;
  double v ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 387
  enc = it->enc_;
#line 389
  if (! it->lf_stats_) {
#line 390
    return;
  }
#line 392
  s = 0;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (s < 4)) {
#line 392
      goto while_break;
    }
#line 393
    best_level = 0;
#line 395
    best_v = 1.00001000001 * (*(it->lf_stats_))[s][0];
#line 396
    i = 1;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 396
      if (! (i < 64)) {
#line 396
        goto while_break___0;
      }
#line 397
      v = (*(it->lf_stats_))[s][i];
#line 398
      if (v > best_v) {
#line 399
        best_v = v;
#line 400
        best_level = i;
      }
#line 396
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 403
    enc->dqm_[s].fstrength_ = best_level;
#line 392
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 21 "/doner/libwebp/libwebp-v0.3.0/src/enc/cost.c"
uint16_t VP8EntropyCost[256]  = 
#line 21 "/doner/libwebp/libwebp-v0.3.0/src/enc/cost.c"
  {      (uint16_t )1792,      (uint16_t )1792,      (uint16_t )1792,      (uint16_t )1536, 
        (uint16_t )1536,      (uint16_t )1408,      (uint16_t )1366,      (uint16_t )1280, 
        (uint16_t )1280,      (uint16_t )1216,      (uint16_t )1178,      (uint16_t )1152, 
        (uint16_t )1110,      (uint16_t )1076,      (uint16_t )1061,      (uint16_t )1024, 
        (uint16_t )1024,      (uint16_t )992,      (uint16_t )968,      (uint16_t )951, 
        (uint16_t )939,      (uint16_t )911,      (uint16_t )896,      (uint16_t )878, 
        (uint16_t )871,      (uint16_t )854,      (uint16_t )838,      (uint16_t )820, 
        (uint16_t )811,      (uint16_t )794,      (uint16_t )786,      (uint16_t )768, 
        (uint16_t )768,      (uint16_t )752,      (uint16_t )740,      (uint16_t )732, 
        (uint16_t )720,      (uint16_t )709,      (uint16_t )704,      (uint16_t )690, 
        (uint16_t )683,      (uint16_t )672,      (uint16_t )666,      (uint16_t )655, 
        (uint16_t )647,      (uint16_t )640,      (uint16_t )631,      (uint16_t )622, 
        (uint16_t )615,      (uint16_t )607,      (uint16_t )598,      (uint16_t )592, 
        (uint16_t )586,      (uint16_t )576,      (uint16_t )572,      (uint16_t )564, 
        (uint16_t )559,      (uint16_t )555,      (uint16_t )547,      (uint16_t )541, 
        (uint16_t )534,      (uint16_t )528,      (uint16_t )522,      (uint16_t )512, 
        (uint16_t )512,      (uint16_t )504,      (uint16_t )500,      (uint16_t )494, 
        (uint16_t )488,      (uint16_t )483,      (uint16_t )477,      (uint16_t )473, 
        (uint16_t )467,      (uint16_t )461,      (uint16_t )458,      (uint16_t )452, 
        (uint16_t )448,      (uint16_t )443,      (uint16_t )438,      (uint16_t )434, 
        (uint16_t )427,      (uint16_t )424,      (uint16_t )419,      (uint16_t )415, 
        (uint16_t )410,      (uint16_t )406,      (uint16_t )403,      (uint16_t )399, 
        (uint16_t )394,      (uint16_t )390,      (uint16_t )384,      (uint16_t )384, 
        (uint16_t )377,      (uint16_t )374,      (uint16_t )370,      (uint16_t )366, 
        (uint16_t )362,      (uint16_t )359,      (uint16_t )355,      (uint16_t )351, 
        (uint16_t )347,      (uint16_t )342,      (uint16_t )342,      (uint16_t )336, 
        (uint16_t )333,      (uint16_t )330,      (uint16_t )326,      (uint16_t )323, 
        (uint16_t )320,      (uint16_t )316,      (uint16_t )312,      (uint16_t )308, 
        (uint16_t )305,      (uint16_t )302,      (uint16_t )299,      (uint16_t )296, 
        (uint16_t )293,      (uint16_t )288,      (uint16_t )287,      (uint16_t )283, 
        (uint16_t )280,      (uint16_t )277,      (uint16_t )274,      (uint16_t )272, 
        (uint16_t )268,      (uint16_t )266,      (uint16_t )262,      (uint16_t )256, 
        (uint16_t )256,      (uint16_t )256,      (uint16_t )251,      (uint16_t )248, 
        (uint16_t )245,      (uint16_t )242,      (uint16_t )240,      (uint16_t )237, 
        (uint16_t )234,      (uint16_t )232,      (uint16_t )228,      (uint16_t )226, 
        (uint16_t )223,      (uint16_t )221,      (uint16_t )218,      (uint16_t )216, 
        (uint16_t )214,      (uint16_t )211,      (uint16_t )208,      (uint16_t )205, 
        (uint16_t )203,      (uint16_t )201,      (uint16_t )198,      (uint16_t )196, 
        (uint16_t )192,      (uint16_t )191,      (uint16_t )188,      (uint16_t )187, 
        (uint16_t )183,      (uint16_t )181,      (uint16_t )179,      (uint16_t )176, 
        (uint16_t )175,      (uint16_t )171,      (uint16_t )171,      (uint16_t )168, 
        (uint16_t )165,      (uint16_t )163,      (uint16_t )160,      (uint16_t )159, 
        (uint16_t )156,      (uint16_t )154,      (uint16_t )152,      (uint16_t )150, 
        (uint16_t )148,      (uint16_t )146,      (uint16_t )144,      (uint16_t )142, 
        (uint16_t )139,      (uint16_t )138,      (uint16_t )135,      (uint16_t )133, 
        (uint16_t )131,      (uint16_t )128,      (uint16_t )128,      (uint16_t )125, 
        (uint16_t )123,      (uint16_t )121,      (uint16_t )119,      (uint16_t )117, 
        (uint16_t )115,      (uint16_t )113,      (uint16_t )111,      (uint16_t )110, 
        (uint16_t )107,      (uint16_t )105,      (uint16_t )103,      (uint16_t )102, 
        (uint16_t )100,      (uint16_t )98,      (uint16_t )96,      (uint16_t )94, 
        (uint16_t )92,      (uint16_t )91,      (uint16_t )89,      (uint16_t )86, 
        (uint16_t )86,      (uint16_t )83,      (uint16_t )82,      (uint16_t )80, 
        (uint16_t )77,      (uint16_t )76,      (uint16_t )74,      (uint16_t )73, 
        (uint16_t )71,      (uint16_t )69,      (uint16_t )67,      (uint16_t )66, 
        (uint16_t )64,      (uint16_t )63,      (uint16_t )61,      (uint16_t )59, 
        (uint16_t )57,      (uint16_t )55,      (uint16_t )54,      (uint16_t )52, 
        (uint16_t )51,      (uint16_t )49,      (uint16_t )47,      (uint16_t )46, 
        (uint16_t )44,      (uint16_t )43,      (uint16_t )41,      (uint16_t )40, 
        (uint16_t )38,      (uint16_t )36,      (uint16_t )35,      (uint16_t )33, 
        (uint16_t )32,      (uint16_t )30,      (uint16_t )29,      (uint16_t )27, 
        (uint16_t )25,      (uint16_t )24,      (uint16_t )22,      (uint16_t )21, 
        (uint16_t )19,      (uint16_t )18,      (uint16_t )16,      (uint16_t )15, 
        (uint16_t )13,      (uint16_t )12,      (uint16_t )10,      (uint16_t )9, 
        (uint16_t )7,      (uint16_t )6,      (uint16_t )4,      (uint16_t )3};
#line 56 "/doner/libwebp/libwebp-v0.3.0/src/enc/cost.c"
uint16_t VP8LevelCodes[67][2]  = 
#line 56
  { {        (uint16_t )1,        (uint16_t )0}, 
   {        (uint16_t )7,        (uint16_t )1}, 
   {        (uint16_t )15,        (uint16_t )5}, 
   {        (uint16_t )15,        (uint16_t )13}, 
   {        (uint16_t )51,        (uint16_t )3}, 
   {        (uint16_t )51,        (uint16_t )3}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )51,        (uint16_t )35}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )19}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )211,        (uint16_t )147}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )83}, 
   {        (uint16_t )339,        (uint16_t )339}};
#line 78 "/doner/libwebp/libwebp-v0.3.0/src/enc/cost.c"
uint16_t VP8LevelFixedCosts[2048]  = 
#line 78
  {      (uint16_t )0,      (uint16_t )256,      (uint16_t )256,      (uint16_t )256, 
        (uint16_t )256,      (uint16_t )432,      (uint16_t )618,      (uint16_t )630, 
        (uint16_t )731,      (uint16_t )640,      (uint16_t )640,      (uint16_t )828, 
        (uint16_t )901,      (uint16_t )948,      (uint16_t )1021,      (uint16_t )1101, 
        (uint16_t )1174,      (uint16_t )1221,      (uint16_t )1294,      (uint16_t )1042, 
        (uint16_t )1085,      (uint16_t )1115,      (uint16_t )1158,      (uint16_t )1202, 
        (uint16_t )1245,      (uint16_t )1275,      (uint16_t )1318,      (uint16_t )1337, 
        (uint16_t )1380,      (uint16_t )1410,      (uint16_t )1453,      (uint16_t )1497, 
        (uint16_t )1540,      (uint16_t )1570,      (uint16_t )1613,      (uint16_t )1280, 
        (uint16_t )1295,      (uint16_t )1317,      (uint16_t )1332,      (uint16_t )1358, 
        (uint16_t )1373,      (uint16_t )1395,      (uint16_t )1410,      (uint16_t )1454, 
        (uint16_t )1469,      (uint16_t )1491,      (uint16_t )1506,      (uint16_t )1532, 
        (uint16_t )1547,      (uint16_t )1569,      (uint16_t )1584,      (uint16_t )1601, 
        (uint16_t )1616,      (uint16_t )1638,      (uint16_t )1653,      (uint16_t )1679, 
        (uint16_t )1694,      (uint16_t )1716,      (uint16_t )1731,      (uint16_t )1775, 
        (uint16_t )1790,      (uint16_t )1812,      (uint16_t )1827,      (uint16_t )1853, 
        (uint16_t )1868,      (uint16_t )1890,      (uint16_t )1905,      (uint16_t )1727, 
        (uint16_t )1733,      (uint16_t )1742,      (uint16_t )1748,      (uint16_t )1759, 
        (uint16_t )1765,      (uint16_t )1774,      (uint16_t )1780,      (uint16_t )1800, 
        (uint16_t )1806,      (uint16_t )1815,      (uint16_t )1821,      (uint16_t )1832, 
        (uint16_t )1838,      (uint16_t )1847,      (uint16_t )1853,      (uint16_t )1878, 
        (uint16_t )1884,      (uint16_t )1893,      (uint16_t )1899,      (uint16_t )1910, 
        (uint16_t )1916,      (uint16_t )1925,      (uint16_t )1931,      (uint16_t )1951, 
        (uint16_t )1957,      (uint16_t )1966,      (uint16_t )1972,      (uint16_t )1983, 
        (uint16_t )1989,      (uint16_t )1998,      (uint16_t )2004,      (uint16_t )2027, 
        (uint16_t )2033,      (uint16_t )2042,      (uint16_t )2048,      (uint16_t )2059, 
        (uint16_t )2065,      (uint16_t )2074,      (uint16_t )2080,      (uint16_t )2100, 
        (uint16_t )2106,      (uint16_t )2115,      (uint16_t )2121,      (uint16_t )2132, 
        (uint16_t )2138,      (uint16_t )2147,      (uint16_t )2153,      (uint16_t )2178, 
        (uint16_t )2184,      (uint16_t )2193,      (uint16_t )2199,      (uint16_t )2210, 
        (uint16_t )2216,      (uint16_t )2225,      (uint16_t )2231,      (uint16_t )2251, 
        (uint16_t )2257,      (uint16_t )2266,      (uint16_t )2272,      (uint16_t )2283, 
        (uint16_t )2289,      (uint16_t )2298,      (uint16_t )2304,      (uint16_t )2168, 
        (uint16_t )2174,      (uint16_t )2183,      (uint16_t )2189,      (uint16_t )2200, 
        (uint16_t )2206,      (uint16_t )2215,      (uint16_t )2221,      (uint16_t )2241, 
        (uint16_t )2247,      (uint16_t )2256,      (uint16_t )2262,      (uint16_t )2273, 
        (uint16_t )2279,      (uint16_t )2288,      (uint16_t )2294,      (uint16_t )2319, 
        (uint16_t )2325,      (uint16_t )2334,      (uint16_t )2340,      (uint16_t )2351, 
        (uint16_t )2357,      (uint16_t )2366,      (uint16_t )2372,      (uint16_t )2392, 
        (uint16_t )2398,      (uint16_t )2407,      (uint16_t )2413,      (uint16_t )2424, 
        (uint16_t )2430,      (uint16_t )2439,      (uint16_t )2445,      (uint16_t )2468, 
        (uint16_t )2474,      (uint16_t )2483,      (uint16_t )2489,      (uint16_t )2500, 
        (uint16_t )2506,      (uint16_t )2515,      (uint16_t )2521,      (uint16_t )2541, 
        (uint16_t )2547,      (uint16_t )2556,      (uint16_t )2562,      (uint16_t )2573, 
        (uint16_t )2579,      (uint16_t )2588,      (uint16_t )2594,      (uint16_t )2619, 
        (uint16_t )2625,      (uint16_t )2634,      (uint16_t )2640,      (uint16_t )2651, 
        (uint16_t )2657,      (uint16_t )2666,      (uint16_t )2672,      (uint16_t )2692, 
        (uint16_t )2698,      (uint16_t )2707,      (uint16_t )2713,      (uint16_t )2724, 
        (uint16_t )2730,      (uint16_t )2739,      (uint16_t )2745,      (uint16_t )2540, 
        (uint16_t )2546,      (uint16_t )2555,      (uint16_t )2561,      (uint16_t )2572, 
        (uint16_t )2578,      (uint16_t )2587,      (uint16_t )2593,      (uint16_t )2613, 
        (uint16_t )2619,      (uint16_t )2628,      (uint16_t )2634,      (uint16_t )2645, 
        (uint16_t )2651,      (uint16_t )2660,      (uint16_t )2666,      (uint16_t )2691, 
        (uint16_t )2697,      (uint16_t )2706,      (uint16_t )2712,      (uint16_t )2723, 
        (uint16_t )2729,      (uint16_t )2738,      (uint16_t )2744,      (uint16_t )2764, 
        (uint16_t )2770,      (uint16_t )2779,      (uint16_t )2785,      (uint16_t )2796, 
        (uint16_t )2802,      (uint16_t )2811,      (uint16_t )2817,      (uint16_t )2840, 
        (uint16_t )2846,      (uint16_t )2855,      (uint16_t )2861,      (uint16_t )2872, 
        (uint16_t )2878,      (uint16_t )2887,      (uint16_t )2893,      (uint16_t )2913, 
        (uint16_t )2919,      (uint16_t )2928,      (uint16_t )2934,      (uint16_t )2945, 
        (uint16_t )2951,      (uint16_t )2960,      (uint16_t )2966,      (uint16_t )2991, 
        (uint16_t )2997,      (uint16_t )3006,      (uint16_t )3012,      (uint16_t )3023, 
        (uint16_t )3029,      (uint16_t )3038,      (uint16_t )3044,      (uint16_t )3064, 
        (uint16_t )3070,      (uint16_t )3079,      (uint16_t )3085,      (uint16_t )3096, 
        (uint16_t )3102,      (uint16_t )3111,      (uint16_t )3117,      (uint16_t )2981, 
        (uint16_t )2987,      (uint16_t )2996,      (uint16_t )3002,      (uint16_t )3013, 
        (uint16_t )3019,      (uint16_t )3028,      (uint16_t )3034,      (uint16_t )3054, 
        (uint16_t )3060,      (uint16_t )3069,      (uint16_t )3075,      (uint16_t )3086, 
        (uint16_t )3092,      (uint16_t )3101,      (uint16_t )3107,      (uint16_t )3132, 
        (uint16_t )3138,      (uint16_t )3147,      (uint16_t )3153,      (uint16_t )3164, 
        (uint16_t )3170,      (uint16_t )3179,      (uint16_t )3185,      (uint16_t )3205, 
        (uint16_t )3211,      (uint16_t )3220,      (uint16_t )3226,      (uint16_t )3237, 
        (uint16_t )3243,      (uint16_t )3252,      (uint16_t )3258,      (uint16_t )3281, 
        (uint16_t )3287,      (uint16_t )3296,      (uint16_t )3302,      (uint16_t )3313, 
        (uint16_t )3319,      (uint16_t )3328,      (uint16_t )3334,      (uint16_t )3354, 
        (uint16_t )3360,      (uint16_t )3369,      (uint16_t )3375,      (uint16_t )3386, 
        (uint16_t )3392,      (uint16_t )3401,      (uint16_t )3407,      (uint16_t )3432, 
        (uint16_t )3438,      (uint16_t )3447,      (uint16_t )3453,      (uint16_t )3464, 
        (uint16_t )3470,      (uint16_t )3479,      (uint16_t )3485,      (uint16_t )3505, 
        (uint16_t )3511,      (uint16_t )3520,      (uint16_t )3526,      (uint16_t )3537, 
        (uint16_t )3543,      (uint16_t )3552,      (uint16_t )3558,      (uint16_t )2816, 
        (uint16_t )2822,      (uint16_t )2831,      (uint16_t )2837,      (uint16_t )2848, 
        (uint16_t )2854,      (uint16_t )2863,      (uint16_t )2869,      (uint16_t )2889, 
        (uint16_t )2895,      (uint16_t )2904,      (uint16_t )2910,      (uint16_t )2921, 
        (uint16_t )2927,      (uint16_t )2936,      (uint16_t )2942,      (uint16_t )2967, 
        (uint16_t )2973,      (uint16_t )2982,      (uint16_t )2988,      (uint16_t )2999, 
        (uint16_t )3005,      (uint16_t )3014,      (uint16_t )3020,      (uint16_t )3040, 
        (uint16_t )3046,      (uint16_t )3055,      (uint16_t )3061,      (uint16_t )3072, 
        (uint16_t )3078,      (uint16_t )3087,      (uint16_t )3093,      (uint16_t )3116, 
        (uint16_t )3122,      (uint16_t )3131,      (uint16_t )3137,      (uint16_t )3148, 
        (uint16_t )3154,      (uint16_t )3163,      (uint16_t )3169,      (uint16_t )3189, 
        (uint16_t )3195,      (uint16_t )3204,      (uint16_t )3210,      (uint16_t )3221, 
        (uint16_t )3227,      (uint16_t )3236,      (uint16_t )3242,      (uint16_t )3267, 
        (uint16_t )3273,      (uint16_t )3282,      (uint16_t )3288,      (uint16_t )3299, 
        (uint16_t )3305,      (uint16_t )3314,      (uint16_t )3320,      (uint16_t )3340, 
        (uint16_t )3346,      (uint16_t )3355,      (uint16_t )3361,      (uint16_t )3372, 
        (uint16_t )3378,      (uint16_t )3387,      (uint16_t )3393,      (uint16_t )3257, 
        (uint16_t )3263,      (uint16_t )3272,      (uint16_t )3278,      (uint16_t )3289, 
        (uint16_t )3295,      (uint16_t )3304,      (uint16_t )3310,      (uint16_t )3330, 
        (uint16_t )3336,      (uint16_t )3345,      (uint16_t )3351,      (uint16_t )3362, 
        (uint16_t )3368,      (uint16_t )3377,      (uint16_t )3383,      (uint16_t )3408, 
        (uint16_t )3414,      (uint16_t )3423,      (uint16_t )3429,      (uint16_t )3440, 
        (uint16_t )3446,      (uint16_t )3455,      (uint16_t )3461,      (uint16_t )3481, 
        (uint16_t )3487,      (uint16_t )3496,      (uint16_t )3502,      (uint16_t )3513, 
        (uint16_t )3519,      (uint16_t )3528,      (uint16_t )3534,      (uint16_t )3557, 
        (uint16_t )3563,      (uint16_t )3572,      (uint16_t )3578,      (uint16_t )3589, 
        (uint16_t )3595,      (uint16_t )3604,      (uint16_t )3610,      (uint16_t )3630, 
        (uint16_t )3636,      (uint16_t )3645,      (uint16_t )3651,      (uint16_t )3662, 
        (uint16_t )3668,      (uint16_t )3677,      (uint16_t )3683,      (uint16_t )3708, 
        (uint16_t )3714,      (uint16_t )3723,      (uint16_t )3729,      (uint16_t )3740, 
        (uint16_t )3746,      (uint16_t )3755,      (uint16_t )3761,      (uint16_t )3781, 
        (uint16_t )3787,      (uint16_t )3796,      (uint16_t )3802,      (uint16_t )3813, 
        (uint16_t )3819,      (uint16_t )3828,      (uint16_t )3834,      (uint16_t )3629, 
        (uint16_t )3635,      (uint16_t )3644,      (uint16_t )3650,      (uint16_t )3661, 
        (uint16_t )3667,      (uint16_t )3676,      (uint16_t )3682,      (uint16_t )3702, 
        (uint16_t )3708,      (uint16_t )3717,      (uint16_t )3723,      (uint16_t )3734, 
        (uint16_t )3740,      (uint16_t )3749,      (uint16_t )3755,      (uint16_t )3780, 
        (uint16_t )3786,      (uint16_t )3795,      (uint16_t )3801,      (uint16_t )3812, 
        (uint16_t )3818,      (uint16_t )3827,      (uint16_t )3833,      (uint16_t )3853, 
        (uint16_t )3859,      (uint16_t )3868,      (uint16_t )3874,      (uint16_t )3885, 
        (uint16_t )3891,      (uint16_t )3900,      (uint16_t )3906,      (uint16_t )3929, 
        (uint16_t )3935,      (uint16_t )3944,      (uint16_t )3950,      (uint16_t )3961, 
        (uint16_t )3967,      (uint16_t )3976,      (uint16_t )3982,      (uint16_t )4002, 
        (uint16_t )4008,      (uint16_t )4017,      (uint16_t )4023,      (uint16_t )4034, 
        (uint16_t )4040,      (uint16_t )4049,      (uint16_t )4055,      (uint16_t )4080, 
        (uint16_t )4086,      (uint16_t )4095,      (uint16_t )4101,      (uint16_t )4112, 
        (uint16_t )4118,      (uint16_t )4127,      (uint16_t )4133,      (uint16_t )4153, 
        (uint16_t )4159,      (uint16_t )4168,      (uint16_t )4174,      (uint16_t )4185, 
        (uint16_t )4191,      (uint16_t )4200,      (uint16_t )4206,      (uint16_t )4070, 
        (uint16_t )4076,      (uint16_t )4085,      (uint16_t )4091,      (uint16_t )4102, 
        (uint16_t )4108,      (uint16_t )4117,      (uint16_t )4123,      (uint16_t )4143, 
        (uint16_t )4149,      (uint16_t )4158,      (uint16_t )4164,      (uint16_t )4175, 
        (uint16_t )4181,      (uint16_t )4190,      (uint16_t )4196,      (uint16_t )4221, 
        (uint16_t )4227,      (uint16_t )4236,      (uint16_t )4242,      (uint16_t )4253, 
        (uint16_t )4259,      (uint16_t )4268,      (uint16_t )4274,      (uint16_t )4294, 
        (uint16_t )4300,      (uint16_t )4309,      (uint16_t )4315,      (uint16_t )4326, 
        (uint16_t )4332,      (uint16_t )4341,      (uint16_t )4347,      (uint16_t )4370, 
        (uint16_t )4376,      (uint16_t )4385,      (uint16_t )4391,      (uint16_t )4402, 
        (uint16_t )4408,      (uint16_t )4417,      (uint16_t )4423,      (uint16_t )4443, 
        (uint16_t )4449,      (uint16_t )4458,      (uint16_t )4464,      (uint16_t )4475, 
        (uint16_t )4481,      (uint16_t )4490,      (uint16_t )4496,      (uint16_t )4521, 
        (uint16_t )4527,      (uint16_t )4536,      (uint16_t )4542,      (uint16_t )4553, 
        (uint16_t )4559,      (uint16_t )4568,      (uint16_t )4574,      (uint16_t )4594, 
        (uint16_t )4600,      (uint16_t )4609,      (uint16_t )4615,      (uint16_t )4626, 
        (uint16_t )4632,      (uint16_t )4641,      (uint16_t )4647,      (uint16_t )3515, 
        (uint16_t )3521,      (uint16_t )3530,      (uint16_t )3536,      (uint16_t )3547, 
        (uint16_t )3553,      (uint16_t )3562,      (uint16_t )3568,      (uint16_t )3588, 
        (uint16_t )3594,      (uint16_t )3603,      (uint16_t )3609,      (uint16_t )3620, 
        (uint16_t )3626,      (uint16_t )3635,      (uint16_t )3641,      (uint16_t )3666, 
        (uint16_t )3672,      (uint16_t )3681,      (uint16_t )3687,      (uint16_t )3698, 
        (uint16_t )3704,      (uint16_t )3713,      (uint16_t )3719,      (uint16_t )3739, 
        (uint16_t )3745,      (uint16_t )3754,      (uint16_t )3760,      (uint16_t )3771, 
        (uint16_t )3777,      (uint16_t )3786,      (uint16_t )3792,      (uint16_t )3815, 
        (uint16_t )3821,      (uint16_t )3830,      (uint16_t )3836,      (uint16_t )3847, 
        (uint16_t )3853,      (uint16_t )3862,      (uint16_t )3868,      (uint16_t )3888, 
        (uint16_t )3894,      (uint16_t )3903,      (uint16_t )3909,      (uint16_t )3920, 
        (uint16_t )3926,      (uint16_t )3935,      (uint16_t )3941,      (uint16_t )3966, 
        (uint16_t )3972,      (uint16_t )3981,      (uint16_t )3987,      (uint16_t )3998, 
        (uint16_t )4004,      (uint16_t )4013,      (uint16_t )4019,      (uint16_t )4039, 
        (uint16_t )4045,      (uint16_t )4054,      (uint16_t )4060,      (uint16_t )4071, 
        (uint16_t )4077,      (uint16_t )4086,      (uint16_t )4092,      (uint16_t )3956, 
        (uint16_t )3962,      (uint16_t )3971,      (uint16_t )3977,      (uint16_t )3988, 
        (uint16_t )3994,      (uint16_t )4003,      (uint16_t )4009,      (uint16_t )4029, 
        (uint16_t )4035,      (uint16_t )4044,      (uint16_t )4050,      (uint16_t )4061, 
        (uint16_t )4067,      (uint16_t )4076,      (uint16_t )4082,      (uint16_t )4107, 
        (uint16_t )4113,      (uint16_t )4122,      (uint16_t )4128,      (uint16_t )4139, 
        (uint16_t )4145,      (uint16_t )4154,      (uint16_t )4160,      (uint16_t )4180, 
        (uint16_t )4186,      (uint16_t )4195,      (uint16_t )4201,      (uint16_t )4212, 
        (uint16_t )4218,      (uint16_t )4227,      (uint16_t )4233,      (uint16_t )4256, 
        (uint16_t )4262,      (uint16_t )4271,      (uint16_t )4277,      (uint16_t )4288, 
        (uint16_t )4294,      (uint16_t )4303,      (uint16_t )4309,      (uint16_t )4329, 
        (uint16_t )4335,      (uint16_t )4344,      (uint16_t )4350,      (uint16_t )4361, 
        (uint16_t )4367,      (uint16_t )4376,      (uint16_t )4382,      (uint16_t )4407, 
        (uint16_t )4413,      (uint16_t )4422,      (uint16_t )4428,      (uint16_t )4439, 
        (uint16_t )4445,      (uint16_t )4454,      (uint16_t )4460,      (uint16_t )4480, 
        (uint16_t )4486,      (uint16_t )4495,      (uint16_t )4501,      (uint16_t )4512, 
        (uint16_t )4518,      (uint16_t )4527,      (uint16_t )4533,      (uint16_t )4328, 
        (uint16_t )4334,      (uint16_t )4343,      (uint16_t )4349,      (uint16_t )4360, 
        (uint16_t )4366,      (uint16_t )4375,      (uint16_t )4381,      (uint16_t )4401, 
        (uint16_t )4407,      (uint16_t )4416,      (uint16_t )4422,      (uint16_t )4433, 
        (uint16_t )4439,      (uint16_t )4448,      (uint16_t )4454,      (uint16_t )4479, 
        (uint16_t )4485,      (uint16_t )4494,      (uint16_t )4500,      (uint16_t )4511, 
        (uint16_t )4517,      (uint16_t )4526,      (uint16_t )4532,      (uint16_t )4552, 
        (uint16_t )4558,      (uint16_t )4567,      (uint16_t )4573,      (uint16_t )4584, 
        (uint16_t )4590,      (uint16_t )4599,      (uint16_t )4605,      (uint16_t )4628, 
        (uint16_t )4634,      (uint16_t )4643,      (uint16_t )4649,      (uint16_t )4660, 
        (uint16_t )4666,      (uint16_t )4675,      (uint16_t )4681,      (uint16_t )4701, 
        (uint16_t )4707,      (uint16_t )4716,      (uint16_t )4722,      (uint16_t )4733, 
        (uint16_t )4739,      (uint16_t )4748,      (uint16_t )4754,      (uint16_t )4779, 
        (uint16_t )4785,      (uint16_t )4794,      (uint16_t )4800,      (uint16_t )4811, 
        (uint16_t )4817,      (uint16_t )4826,      (uint16_t )4832,      (uint16_t )4852, 
        (uint16_t )4858,      (uint16_t )4867,      (uint16_t )4873,      (uint16_t )4884, 
        (uint16_t )4890,      (uint16_t )4899,      (uint16_t )4905,      (uint16_t )4769, 
        (uint16_t )4775,      (uint16_t )4784,      (uint16_t )4790,      (uint16_t )4801, 
        (uint16_t )4807,      (uint16_t )4816,      (uint16_t )4822,      (uint16_t )4842, 
        (uint16_t )4848,      (uint16_t )4857,      (uint16_t )4863,      (uint16_t )4874, 
        (uint16_t )4880,      (uint16_t )4889,      (uint16_t )4895,      (uint16_t )4920, 
        (uint16_t )4926,      (uint16_t )4935,      (uint16_t )4941,      (uint16_t )4952, 
        (uint16_t )4958,      (uint16_t )4967,      (uint16_t )4973,      (uint16_t )4993, 
        (uint16_t )4999,      (uint16_t )5008,      (uint16_t )5014,      (uint16_t )5025, 
        (uint16_t )5031,      (uint16_t )5040,      (uint16_t )5046,      (uint16_t )5069, 
        (uint16_t )5075,      (uint16_t )5084,      (uint16_t )5090,      (uint16_t )5101, 
        (uint16_t )5107,      (uint16_t )5116,      (uint16_t )5122,      (uint16_t )5142, 
        (uint16_t )5148,      (uint16_t )5157,      (uint16_t )5163,      (uint16_t )5174, 
        (uint16_t )5180,      (uint16_t )5189,      (uint16_t )5195,      (uint16_t )5220, 
        (uint16_t )5226,      (uint16_t )5235,      (uint16_t )5241,      (uint16_t )5252, 
        (uint16_t )5258,      (uint16_t )5267,      (uint16_t )5273,      (uint16_t )5293, 
        (uint16_t )5299,      (uint16_t )5308,      (uint16_t )5314,      (uint16_t )5325, 
        (uint16_t )5331,      (uint16_t )5340,      (uint16_t )5346,      (uint16_t )4604, 
        (uint16_t )4610,      (uint16_t )4619,      (uint16_t )4625,      (uint16_t )4636, 
        (uint16_t )4642,      (uint16_t )4651,      (uint16_t )4657,      (uint16_t )4677, 
        (uint16_t )4683,      (uint16_t )4692,      (uint16_t )4698,      (uint16_t )4709, 
        (uint16_t )4715,      (uint16_t )4724,      (uint16_t )4730,      (uint16_t )4755, 
        (uint16_t )4761,      (uint16_t )4770,      (uint16_t )4776,      (uint16_t )4787, 
        (uint16_t )4793,      (uint16_t )4802,      (uint16_t )4808,      (uint16_t )4828, 
        (uint16_t )4834,      (uint16_t )4843,      (uint16_t )4849,      (uint16_t )4860, 
        (uint16_t )4866,      (uint16_t )4875,      (uint16_t )4881,      (uint16_t )4904, 
        (uint16_t )4910,      (uint16_t )4919,      (uint16_t )4925,      (uint16_t )4936, 
        (uint16_t )4942,      (uint16_t )4951,      (uint16_t )4957,      (uint16_t )4977, 
        (uint16_t )4983,      (uint16_t )4992,      (uint16_t )4998,      (uint16_t )5009, 
        (uint16_t )5015,      (uint16_t )5024,      (uint16_t )5030,      (uint16_t )5055, 
        (uint16_t )5061,      (uint16_t )5070,      (uint16_t )5076,      (uint16_t )5087, 
        (uint16_t )5093,      (uint16_t )5102,      (uint16_t )5108,      (uint16_t )5128, 
        (uint16_t )5134,      (uint16_t )5143,      (uint16_t )5149,      (uint16_t )5160, 
        (uint16_t )5166,      (uint16_t )5175,      (uint16_t )5181,      (uint16_t )5045, 
        (uint16_t )5051,      (uint16_t )5060,      (uint16_t )5066,      (uint16_t )5077, 
        (uint16_t )5083,      (uint16_t )5092,      (uint16_t )5098,      (uint16_t )5118, 
        (uint16_t )5124,      (uint16_t )5133,      (uint16_t )5139,      (uint16_t )5150, 
        (uint16_t )5156,      (uint16_t )5165,      (uint16_t )5171,      (uint16_t )5196, 
        (uint16_t )5202,      (uint16_t )5211,      (uint16_t )5217,      (uint16_t )5228, 
        (uint16_t )5234,      (uint16_t )5243,      (uint16_t )5249,      (uint16_t )5269, 
        (uint16_t )5275,      (uint16_t )5284,      (uint16_t )5290,      (uint16_t )5301, 
        (uint16_t )5307,      (uint16_t )5316,      (uint16_t )5322,      (uint16_t )5345, 
        (uint16_t )5351,      (uint16_t )5360,      (uint16_t )5366,      (uint16_t )5377, 
        (uint16_t )5383,      (uint16_t )5392,      (uint16_t )5398,      (uint16_t )5418, 
        (uint16_t )5424,      (uint16_t )5433,      (uint16_t )5439,      (uint16_t )5450, 
        (uint16_t )5456,      (uint16_t )5465,      (uint16_t )5471,      (uint16_t )5496, 
        (uint16_t )5502,      (uint16_t )5511,      (uint16_t )5517,      (uint16_t )5528, 
        (uint16_t )5534,      (uint16_t )5543,      (uint16_t )5549,      (uint16_t )5569, 
        (uint16_t )5575,      (uint16_t )5584,      (uint16_t )5590,      (uint16_t )5601, 
        (uint16_t )5607,      (uint16_t )5616,      (uint16_t )5622,      (uint16_t )5417, 
        (uint16_t )5423,      (uint16_t )5432,      (uint16_t )5438,      (uint16_t )5449, 
        (uint16_t )5455,      (uint16_t )5464,      (uint16_t )5470,      (uint16_t )5490, 
        (uint16_t )5496,      (uint16_t )5505,      (uint16_t )5511,      (uint16_t )5522, 
        (uint16_t )5528,      (uint16_t )5537,      (uint16_t )5543,      (uint16_t )5568, 
        (uint16_t )5574,      (uint16_t )5583,      (uint16_t )5589,      (uint16_t )5600, 
        (uint16_t )5606,      (uint16_t )5615,      (uint16_t )5621,      (uint16_t )5641, 
        (uint16_t )5647,      (uint16_t )5656,      (uint16_t )5662,      (uint16_t )5673, 
        (uint16_t )5679,      (uint16_t )5688,      (uint16_t )5694,      (uint16_t )5717, 
        (uint16_t )5723,      (uint16_t )5732,      (uint16_t )5738,      (uint16_t )5749, 
        (uint16_t )5755,      (uint16_t )5764,      (uint16_t )5770,      (uint16_t )5790, 
        (uint16_t )5796,      (uint16_t )5805,      (uint16_t )5811,      (uint16_t )5822, 
        (uint16_t )5828,      (uint16_t )5837,      (uint16_t )5843,      (uint16_t )5868, 
        (uint16_t )5874,      (uint16_t )5883,      (uint16_t )5889,      (uint16_t )5900, 
        (uint16_t )5906,      (uint16_t )5915,      (uint16_t )5921,      (uint16_t )5941, 
        (uint16_t )5947,      (uint16_t )5956,      (uint16_t )5962,      (uint16_t )5973, 
        (uint16_t )5979,      (uint16_t )5988,      (uint16_t )5994,      (uint16_t )5858, 
        (uint16_t )5864,      (uint16_t )5873,      (uint16_t )5879,      (uint16_t )5890, 
        (uint16_t )5896,      (uint16_t )5905,      (uint16_t )5911,      (uint16_t )5931, 
        (uint16_t )5937,      (uint16_t )5946,      (uint16_t )5952,      (uint16_t )5963, 
        (uint16_t )5969,      (uint16_t )5978,      (uint16_t )5984,      (uint16_t )6009, 
        (uint16_t )6015,      (uint16_t )6024,      (uint16_t )6030,      (uint16_t )6041, 
        (uint16_t )6047,      (uint16_t )6056,      (uint16_t )6062,      (uint16_t )6082, 
        (uint16_t )6088,      (uint16_t )6097,      (uint16_t )6103,      (uint16_t )6114, 
        (uint16_t )6120,      (uint16_t )6129,      (uint16_t )6135,      (uint16_t )6158, 
        (uint16_t )6164,      (uint16_t )6173,      (uint16_t )6179,      (uint16_t )6190, 
        (uint16_t )6196,      (uint16_t )6205,      (uint16_t )6211,      (uint16_t )6231, 
        (uint16_t )6237,      (uint16_t )6246,      (uint16_t )6252,      (uint16_t )6263, 
        (uint16_t )6269,      (uint16_t )6278,      (uint16_t )6284,      (uint16_t )6309, 
        (uint16_t )6315,      (uint16_t )6324,      (uint16_t )6330,      (uint16_t )6341, 
        (uint16_t )6347,      (uint16_t )6356,      (uint16_t )6362,      (uint16_t )6382, 
        (uint16_t )6388,      (uint16_t )6397,      (uint16_t )6403,      (uint16_t )6414, 
        (uint16_t )6420,      (uint16_t )6429,      (uint16_t )6435,      (uint16_t )3515, 
        (uint16_t )3521,      (uint16_t )3530,      (uint16_t )3536,      (uint16_t )3547, 
        (uint16_t )3553,      (uint16_t )3562,      (uint16_t )3568,      (uint16_t )3588, 
        (uint16_t )3594,      (uint16_t )3603,      (uint16_t )3609,      (uint16_t )3620, 
        (uint16_t )3626,      (uint16_t )3635,      (uint16_t )3641,      (uint16_t )3666, 
        (uint16_t )3672,      (uint16_t )3681,      (uint16_t )3687,      (uint16_t )3698, 
        (uint16_t )3704,      (uint16_t )3713,      (uint16_t )3719,      (uint16_t )3739, 
        (uint16_t )3745,      (uint16_t )3754,      (uint16_t )3760,      (uint16_t )3771, 
        (uint16_t )3777,      (uint16_t )3786,      (uint16_t )3792,      (uint16_t )3815, 
        (uint16_t )3821,      (uint16_t )3830,      (uint16_t )3836,      (uint16_t )3847, 
        (uint16_t )3853,      (uint16_t )3862,      (uint16_t )3868,      (uint16_t )3888, 
        (uint16_t )3894,      (uint16_t )3903,      (uint16_t )3909,      (uint16_t )3920, 
        (uint16_t )3926,      (uint16_t )3935,      (uint16_t )3941,      (uint16_t )3966, 
        (uint16_t )3972,      (uint16_t )3981,      (uint16_t )3987,      (uint16_t )3998, 
        (uint16_t )4004,      (uint16_t )4013,      (uint16_t )4019,      (uint16_t )4039, 
        (uint16_t )4045,      (uint16_t )4054,      (uint16_t )4060,      (uint16_t )4071, 
        (uint16_t )4077,      (uint16_t )4086,      (uint16_t )4092,      (uint16_t )3956, 
        (uint16_t )3962,      (uint16_t )3971,      (uint16_t )3977,      (uint16_t )3988, 
        (uint16_t )3994,      (uint16_t )4003,      (uint16_t )4009,      (uint16_t )4029, 
        (uint16_t )4035,      (uint16_t )4044,      (uint16_t )4050,      (uint16_t )4061, 
        (uint16_t )4067,      (uint16_t )4076,      (uint16_t )4082,      (uint16_t )4107, 
        (uint16_t )4113,      (uint16_t )4122,      (uint16_t )4128,      (uint16_t )4139, 
        (uint16_t )4145,      (uint16_t )4154,      (uint16_t )4160,      (uint16_t )4180, 
        (uint16_t )4186,      (uint16_t )4195,      (uint16_t )4201,      (uint16_t )4212, 
        (uint16_t )4218,      (uint16_t )4227,      (uint16_t )4233,      (uint16_t )4256, 
        (uint16_t )4262,      (uint16_t )4271,      (uint16_t )4277,      (uint16_t )4288, 
        (uint16_t )4294,      (uint16_t )4303,      (uint16_t )4309,      (uint16_t )4329, 
        (uint16_t )4335,      (uint16_t )4344,      (uint16_t )4350,      (uint16_t )4361, 
        (uint16_t )4367,      (uint16_t )4376,      (uint16_t )4382,      (uint16_t )4407, 
        (uint16_t )4413,      (uint16_t )4422,      (uint16_t )4428,      (uint16_t )4439, 
        (uint16_t )4445,      (uint16_t )4454,      (uint16_t )4460,      (uint16_t )4480, 
        (uint16_t )4486,      (uint16_t )4495,      (uint16_t )4501,      (uint16_t )4512, 
        (uint16_t )4518,      (uint16_t )4527,      (uint16_t )4533,      (uint16_t )4328, 
        (uint16_t )4334,      (uint16_t )4343,      (uint16_t )4349,      (uint16_t )4360, 
        (uint16_t )4366,      (uint16_t )4375,      (uint16_t )4381,      (uint16_t )4401, 
        (uint16_t )4407,      (uint16_t )4416,      (uint16_t )4422,      (uint16_t )4433, 
        (uint16_t )4439,      (uint16_t )4448,      (uint16_t )4454,      (uint16_t )4479, 
        (uint16_t )4485,      (uint16_t )4494,      (uint16_t )4500,      (uint16_t )4511, 
        (uint16_t )4517,      (uint16_t )4526,      (uint16_t )4532,      (uint16_t )4552, 
        (uint16_t )4558,      (uint16_t )4567,      (uint16_t )4573,      (uint16_t )4584, 
        (uint16_t )4590,      (uint16_t )4599,      (uint16_t )4605,      (uint16_t )4628, 
        (uint16_t )4634,      (uint16_t )4643,      (uint16_t )4649,      (uint16_t )4660, 
        (uint16_t )4666,      (uint16_t )4675,      (uint16_t )4681,      (uint16_t )4701, 
        (uint16_t )4707,      (uint16_t )4716,      (uint16_t )4722,      (uint16_t )4733, 
        (uint16_t )4739,      (uint16_t )4748,      (uint16_t )4754,      (uint16_t )4779, 
        (uint16_t )4785,      (uint16_t )4794,      (uint16_t )4800,      (uint16_t )4811, 
        (uint16_t )4817,      (uint16_t )4826,      (uint16_t )4832,      (uint16_t )4852, 
        (uint16_t )4858,      (uint16_t )4867,      (uint16_t )4873,      (uint16_t )4884, 
        (uint16_t )4890,      (uint16_t )4899,      (uint16_t )4905,      (uint16_t )4769, 
        (uint16_t )4775,      (uint16_t )4784,      (uint16_t )4790,      (uint16_t )4801, 
        (uint16_t )4807,      (uint16_t )4816,      (uint16_t )4822,      (uint16_t )4842, 
        (uint16_t )4848,      (uint16_t )4857,      (uint16_t )4863,      (uint16_t )4874, 
        (uint16_t )4880,      (uint16_t )4889,      (uint16_t )4895,      (uint16_t )4920, 
        (uint16_t )4926,      (uint16_t )4935,      (uint16_t )4941,      (uint16_t )4952, 
        (uint16_t )4958,      (uint16_t )4967,      (uint16_t )4973,      (uint16_t )4993, 
        (uint16_t )4999,      (uint16_t )5008,      (uint16_t )5014,      (uint16_t )5025, 
        (uint16_t )5031,      (uint16_t )5040,      (uint16_t )5046,      (uint16_t )5069, 
        (uint16_t )5075,      (uint16_t )5084,      (uint16_t )5090,      (uint16_t )5101, 
        (uint16_t )5107,      (uint16_t )5116,      (uint16_t )5122,      (uint16_t )5142, 
        (uint16_t )5148,      (uint16_t )5157,      (uint16_t )5163,      (uint16_t )5174, 
        (uint16_t )5180,      (uint16_t )5189,      (uint16_t )5195,      (uint16_t )5220, 
        (uint16_t )5226,      (uint16_t )5235,      (uint16_t )5241,      (uint16_t )5252, 
        (uint16_t )5258,      (uint16_t )5267,      (uint16_t )5273,      (uint16_t )5293, 
        (uint16_t )5299,      (uint16_t )5308,      (uint16_t )5314,      (uint16_t )5325, 
        (uint16_t )5331,      (uint16_t )5340,      (uint16_t )5346,      (uint16_t )4604, 
        (uint16_t )4610,      (uint16_t )4619,      (uint16_t )4625,      (uint16_t )4636, 
        (uint16_t )4642,      (uint16_t )4651,      (uint16_t )4657,      (uint16_t )4677, 
        (uint16_t )4683,      (uint16_t )4692,      (uint16_t )4698,      (uint16_t )4709, 
        (uint16_t )4715,      (uint16_t )4724,      (uint16_t )4730,      (uint16_t )4755, 
        (uint16_t )4761,      (uint16_t )4770,      (uint16_t )4776,      (uint16_t )4787, 
        (uint16_t )4793,      (uint16_t )4802,      (uint16_t )4808,      (uint16_t )4828, 
        (uint16_t )4834,      (uint16_t )4843,      (uint16_t )4849,      (uint16_t )4860, 
        (uint16_t )4866,      (uint16_t )4875,      (uint16_t )4881,      (uint16_t )4904, 
        (uint16_t )4910,      (uint16_t )4919,      (uint16_t )4925,      (uint16_t )4936, 
        (uint16_t )4942,      (uint16_t )4951,      (uint16_t )4957,      (uint16_t )4977, 
        (uint16_t )4983,      (uint16_t )4992,      (uint16_t )4998,      (uint16_t )5009, 
        (uint16_t )5015,      (uint16_t )5024,      (uint16_t )5030,      (uint16_t )5055, 
        (uint16_t )5061,      (uint16_t )5070,      (uint16_t )5076,      (uint16_t )5087, 
        (uint16_t )5093,      (uint16_t )5102,      (uint16_t )5108,      (uint16_t )5128, 
        (uint16_t )5134,      (uint16_t )5143,      (uint16_t )5149,      (uint16_t )5160, 
        (uint16_t )5166,      (uint16_t )5175,      (uint16_t )5181,      (uint16_t )5045, 
        (uint16_t )5051,      (uint16_t )5060,      (uint16_t )5066,      (uint16_t )5077, 
        (uint16_t )5083,      (uint16_t )5092,      (uint16_t )5098,      (uint16_t )5118, 
        (uint16_t )5124,      (uint16_t )5133,      (uint16_t )5139,      (uint16_t )5150, 
        (uint16_t )5156,      (uint16_t )5165,      (uint16_t )5171,      (uint16_t )5196, 
        (uint16_t )5202,      (uint16_t )5211,      (uint16_t )5217,      (uint16_t )5228, 
        (uint16_t )5234,      (uint16_t )5243,      (uint16_t )5249,      (uint16_t )5269, 
        (uint16_t )5275,      (uint16_t )5284,      (uint16_t )5290,      (uint16_t )5301, 
        (uint16_t )5307,      (uint16_t )5316,      (uint16_t )5322,      (uint16_t )5345, 
        (uint16_t )5351,      (uint16_t )5360,      (uint16_t )5366,      (uint16_t )5377, 
        (uint16_t )5383,      (uint16_t )5392,      (uint16_t )5398,      (uint16_t )5418, 
        (uint16_t )5424,      (uint16_t )5433,      (uint16_t )5439,      (uint16_t )5450, 
        (uint16_t )5456,      (uint16_t )5465,      (uint16_t )5471,      (uint16_t )5496, 
        (uint16_t )5502,      (uint16_t )5511,      (uint16_t )5517,      (uint16_t )5528, 
        (uint16_t )5534,      (uint16_t )5543,      (uint16_t )5549,      (uint16_t )5569, 
        (uint16_t )5575,      (uint16_t )5584,      (uint16_t )5590,      (uint16_t )5601, 
        (uint16_t )5607,      (uint16_t )5616,      (uint16_t )5622,      (uint16_t )5417, 
        (uint16_t )5423,      (uint16_t )5432,      (uint16_t )5438,      (uint16_t )5449, 
        (uint16_t )5455,      (uint16_t )5464,      (uint16_t )5470,      (uint16_t )5490, 
        (uint16_t )5496,      (uint16_t )5505,      (uint16_t )5511,      (uint16_t )5522, 
        (uint16_t )5528,      (uint16_t )5537,      (uint16_t )5543,      (uint16_t )5568, 
        (uint16_t )5574,      (uint16_t )5583,      (uint16_t )5589,      (uint16_t )5600, 
        (uint16_t )5606,      (uint16_t )5615,      (uint16_t )5621,      (uint16_t )5641, 
        (uint16_t )5647,      (uint16_t )5656,      (uint16_t )5662,      (uint16_t )5673, 
        (uint16_t )5679,      (uint16_t )5688,      (uint16_t )5694,      (uint16_t )5717, 
        (uint16_t )5723,      (uint16_t )5732,      (uint16_t )5738,      (uint16_t )5749, 
        (uint16_t )5755,      (uint16_t )5764,      (uint16_t )5770,      (uint16_t )5790, 
        (uint16_t )5796,      (uint16_t )5805,      (uint16_t )5811,      (uint16_t )5822, 
        (uint16_t )5828,      (uint16_t )5837,      (uint16_t )5843,      (uint16_t )5868, 
        (uint16_t )5874,      (uint16_t )5883,      (uint16_t )5889,      (uint16_t )5900, 
        (uint16_t )5906,      (uint16_t )5915,      (uint16_t )5921,      (uint16_t )5941, 
        (uint16_t )5947,      (uint16_t )5956,      (uint16_t )5962,      (uint16_t )5973, 
        (uint16_t )5979,      (uint16_t )5988,      (uint16_t )5994,      (uint16_t )5858, 
        (uint16_t )5864,      (uint16_t )5873,      (uint16_t )5879,      (uint16_t )5890, 
        (uint16_t )5896,      (uint16_t )5905,      (uint16_t )5911,      (uint16_t )5931, 
        (uint16_t )5937,      (uint16_t )5946,      (uint16_t )5952,      (uint16_t )5963, 
        (uint16_t )5969,      (uint16_t )5978,      (uint16_t )5984,      (uint16_t )6009, 
        (uint16_t )6015,      (uint16_t )6024,      (uint16_t )6030,      (uint16_t )6041, 
        (uint16_t )6047,      (uint16_t )6056,      (uint16_t )6062,      (uint16_t )6082, 
        (uint16_t )6088,      (uint16_t )6097,      (uint16_t )6103,      (uint16_t )6114, 
        (uint16_t )6120,      (uint16_t )6129,      (uint16_t )6135,      (uint16_t )6158, 
        (uint16_t )6164,      (uint16_t )6173,      (uint16_t )6179,      (uint16_t )6190, 
        (uint16_t )6196,      (uint16_t )6205,      (uint16_t )6211,      (uint16_t )6231, 
        (uint16_t )6237,      (uint16_t )6246,      (uint16_t )6252,      (uint16_t )6263, 
        (uint16_t )6269,      (uint16_t )6278,      (uint16_t )6284,      (uint16_t )6309, 
        (uint16_t )6315,      (uint16_t )6324,      (uint16_t )6330,      (uint16_t )6341, 
        (uint16_t )6347,      (uint16_t )6356,      (uint16_t )6362,      (uint16_t )6382, 
        (uint16_t )6388,      (uint16_t )6397,      (uint16_t )6403,      (uint16_t )6414, 
        (uint16_t )6420,      (uint16_t )6429,      (uint16_t )6435,      (uint16_t )5303, 
        (uint16_t )5309,      (uint16_t )5318,      (uint16_t )5324,      (uint16_t )5335, 
        (uint16_t )5341,      (uint16_t )5350,      (uint16_t )5356,      (uint16_t )5376, 
        (uint16_t )5382,      (uint16_t )5391,      (uint16_t )5397,      (uint16_t )5408, 
        (uint16_t )5414,      (uint16_t )5423,      (uint16_t )5429,      (uint16_t )5454, 
        (uint16_t )5460,      (uint16_t )5469,      (uint16_t )5475,      (uint16_t )5486, 
        (uint16_t )5492,      (uint16_t )5501,      (uint16_t )5507,      (uint16_t )5527, 
        (uint16_t )5533,      (uint16_t )5542,      (uint16_t )5548,      (uint16_t )5559, 
        (uint16_t )5565,      (uint16_t )5574,      (uint16_t )5580,      (uint16_t )5603, 
        (uint16_t )5609,      (uint16_t )5618,      (uint16_t )5624,      (uint16_t )5635, 
        (uint16_t )5641,      (uint16_t )5650,      (uint16_t )5656,      (uint16_t )5676, 
        (uint16_t )5682,      (uint16_t )5691,      (uint16_t )5697,      (uint16_t )5708, 
        (uint16_t )5714,      (uint16_t )5723,      (uint16_t )5729,      (uint16_t )5754, 
        (uint16_t )5760,      (uint16_t )5769,      (uint16_t )5775,      (uint16_t )5786, 
        (uint16_t )5792,      (uint16_t )5801,      (uint16_t )5807,      (uint16_t )5827, 
        (uint16_t )5833,      (uint16_t )5842,      (uint16_t )5848,      (uint16_t )5859, 
        (uint16_t )5865,      (uint16_t )5874,      (uint16_t )5880,      (uint16_t )5744, 
        (uint16_t )5750,      (uint16_t )5759,      (uint16_t )5765,      (uint16_t )5776, 
        (uint16_t )5782,      (uint16_t )5791,      (uint16_t )5797,      (uint16_t )5817, 
        (uint16_t )5823,      (uint16_t )5832,      (uint16_t )5838,      (uint16_t )5849, 
        (uint16_t )5855,      (uint16_t )5864,      (uint16_t )5870,      (uint16_t )5895, 
        (uint16_t )5901,      (uint16_t )5910,      (uint16_t )5916,      (uint16_t )5927, 
        (uint16_t )5933,      (uint16_t )5942,      (uint16_t )5948,      (uint16_t )5968, 
        (uint16_t )5974,      (uint16_t )5983,      (uint16_t )5989,      (uint16_t )6000, 
        (uint16_t )6006,      (uint16_t )6015,      (uint16_t )6021,      (uint16_t )6044, 
        (uint16_t )6050,      (uint16_t )6059,      (uint16_t )6065,      (uint16_t )6076, 
        (uint16_t )6082,      (uint16_t )6091,      (uint16_t )6097,      (uint16_t )6117, 
        (uint16_t )6123,      (uint16_t )6132,      (uint16_t )6138,      (uint16_t )6149, 
        (uint16_t )6155,      (uint16_t )6164,      (uint16_t )6170,      (uint16_t )6195, 
        (uint16_t )6201,      (uint16_t )6210,      (uint16_t )6216,      (uint16_t )6227, 
        (uint16_t )6233,      (uint16_t )6242,      (uint16_t )6248,      (uint16_t )6268, 
        (uint16_t )6274,      (uint16_t )6283,      (uint16_t )6289,      (uint16_t )6300, 
        (uint16_t )6306,      (uint16_t )6315,      (uint16_t )6321,      (uint16_t )6116, 
        (uint16_t )6122,      (uint16_t )6131,      (uint16_t )6137,      (uint16_t )6148, 
        (uint16_t )6154,      (uint16_t )6163,      (uint16_t )6169,      (uint16_t )6189, 
        (uint16_t )6195,      (uint16_t )6204,      (uint16_t )6210,      (uint16_t )6221, 
        (uint16_t )6227,      (uint16_t )6236,      (uint16_t )6242,      (uint16_t )6267, 
        (uint16_t )6273,      (uint16_t )6282,      (uint16_t )6288,      (uint16_t )6299, 
        (uint16_t )6305,      (uint16_t )6314,      (uint16_t )6320,      (uint16_t )6340, 
        (uint16_t )6346,      (uint16_t )6355,      (uint16_t )6361,      (uint16_t )6372, 
        (uint16_t )6378,      (uint16_t )6387,      (uint16_t )6393,      (uint16_t )6416, 
        (uint16_t )6422,      (uint16_t )6431,      (uint16_t )6437,      (uint16_t )6448, 
        (uint16_t )6454,      (uint16_t )6463,      (uint16_t )6469,      (uint16_t )6489, 
        (uint16_t )6495,      (uint16_t )6504,      (uint16_t )6510,      (uint16_t )6521, 
        (uint16_t )6527,      (uint16_t )6536,      (uint16_t )6542,      (uint16_t )6567, 
        (uint16_t )6573,      (uint16_t )6582,      (uint16_t )6588,      (uint16_t )6599, 
        (uint16_t )6605,      (uint16_t )6614,      (uint16_t )6620,      (uint16_t )6640, 
        (uint16_t )6646,      (uint16_t )6655,      (uint16_t )6661,      (uint16_t )6672, 
        (uint16_t )6678,      (uint16_t )6687,      (uint16_t )6693,      (uint16_t )6557, 
        (uint16_t )6563,      (uint16_t )6572,      (uint16_t )6578,      (uint16_t )6589, 
        (uint16_t )6595,      (uint16_t )6604,      (uint16_t )6610,      (uint16_t )6630, 
        (uint16_t )6636,      (uint16_t )6645,      (uint16_t )6651,      (uint16_t )6662, 
        (uint16_t )6668,      (uint16_t )6677,      (uint16_t )6683,      (uint16_t )6708, 
        (uint16_t )6714,      (uint16_t )6723,      (uint16_t )6729,      (uint16_t )6740, 
        (uint16_t )6746,      (uint16_t )6755,      (uint16_t )6761,      (uint16_t )6781, 
        (uint16_t )6787,      (uint16_t )6796,      (uint16_t )6802,      (uint16_t )6813, 
        (uint16_t )6819,      (uint16_t )6828,      (uint16_t )6834,      (uint16_t )6857, 
        (uint16_t )6863,      (uint16_t )6872,      (uint16_t )6878,      (uint16_t )6889, 
        (uint16_t )6895,      (uint16_t )6904,      (uint16_t )6910,      (uint16_t )6930, 
        (uint16_t )6936,      (uint16_t )6945,      (uint16_t )6951,      (uint16_t )6962, 
        (uint16_t )6968,      (uint16_t )6977,      (uint16_t )6983,      (uint16_t )7008, 
        (uint16_t )7014,      (uint16_t )7023,      (uint16_t )7029,      (uint16_t )7040, 
        (uint16_t )7046,      (uint16_t )7055,      (uint16_t )7061,      (uint16_t )7081, 
        (uint16_t )7087,      (uint16_t )7096,      (uint16_t )7102,      (uint16_t )7113, 
        (uint16_t )7119,      (uint16_t )7128,      (uint16_t )7134,      (uint16_t )6392, 
        (uint16_t )6398,      (uint16_t )6407,      (uint16_t )6413,      (uint16_t )6424, 
        (uint16_t )6430,      (uint16_t )6439,      (uint16_t )6445,      (uint16_t )6465, 
        (uint16_t )6471,      (uint16_t )6480,      (uint16_t )6486,      (uint16_t )6497, 
        (uint16_t )6503,      (uint16_t )6512,      (uint16_t )6518,      (uint16_t )6543, 
        (uint16_t )6549,      (uint16_t )6558,      (uint16_t )6564,      (uint16_t )6575, 
        (uint16_t )6581,      (uint16_t )6590,      (uint16_t )6596,      (uint16_t )6616, 
        (uint16_t )6622,      (uint16_t )6631,      (uint16_t )6637,      (uint16_t )6648, 
        (uint16_t )6654,      (uint16_t )6663,      (uint16_t )6669,      (uint16_t )6692, 
        (uint16_t )6698,      (uint16_t )6707,      (uint16_t )6713,      (uint16_t )6724, 
        (uint16_t )6730,      (uint16_t )6739,      (uint16_t )6745,      (uint16_t )6765, 
        (uint16_t )6771,      (uint16_t )6780,      (uint16_t )6786,      (uint16_t )6797, 
        (uint16_t )6803,      (uint16_t )6812,      (uint16_t )6818,      (uint16_t )6843, 
        (uint16_t )6849,      (uint16_t )6858,      (uint16_t )6864,      (uint16_t )6875, 
        (uint16_t )6881,      (uint16_t )6890,      (uint16_t )6896,      (uint16_t )6916, 
        (uint16_t )6922,      (uint16_t )6931,      (uint16_t )6937,      (uint16_t )6948, 
        (uint16_t )6954,      (uint16_t )6963,      (uint16_t )6969,      (uint16_t )6833, 
        (uint16_t )6839,      (uint16_t )6848,      (uint16_t )6854,      (uint16_t )6865, 
        (uint16_t )6871,      (uint16_t )6880,      (uint16_t )6886,      (uint16_t )6906, 
        (uint16_t )6912,      (uint16_t )6921,      (uint16_t )6927,      (uint16_t )6938, 
        (uint16_t )6944,      (uint16_t )6953,      (uint16_t )6959,      (uint16_t )6984, 
        (uint16_t )6990,      (uint16_t )6999,      (uint16_t )7005,      (uint16_t )7016, 
        (uint16_t )7022,      (uint16_t )7031,      (uint16_t )7037,      (uint16_t )7057, 
        (uint16_t )7063,      (uint16_t )7072,      (uint16_t )7078,      (uint16_t )7089, 
        (uint16_t )7095,      (uint16_t )7104,      (uint16_t )7110,      (uint16_t )7133, 
        (uint16_t )7139,      (uint16_t )7148,      (uint16_t )7154,      (uint16_t )7165, 
        (uint16_t )7171,      (uint16_t )7180,      (uint16_t )7186,      (uint16_t )7206, 
        (uint16_t )7212,      (uint16_t )7221,      (uint16_t )7227,      (uint16_t )7238, 
        (uint16_t )7244,      (uint16_t )7253,      (uint16_t )7259,      (uint16_t )7284, 
        (uint16_t )7290,      (uint16_t )7299,      (uint16_t )7305,      (uint16_t )7316, 
        (uint16_t )7322,      (uint16_t )7331,      (uint16_t )7337,      (uint16_t )7357, 
        (uint16_t )7363,      (uint16_t )7372,      (uint16_t )7378,      (uint16_t )7389, 
        (uint16_t )7395,      (uint16_t )7404,      (uint16_t )7410,      (uint16_t )7205, 
        (uint16_t )7211,      (uint16_t )7220,      (uint16_t )7226,      (uint16_t )7237, 
        (uint16_t )7243,      (uint16_t )7252,      (uint16_t )7258,      (uint16_t )7278, 
        (uint16_t )7284,      (uint16_t )7293,      (uint16_t )7299,      (uint16_t )7310, 
        (uint16_t )7316,      (uint16_t )7325,      (uint16_t )7331,      (uint16_t )7356, 
        (uint16_t )7362,      (uint16_t )7371,      (uint16_t )7377,      (uint16_t )7388, 
        (uint16_t )7394,      (uint16_t )7403,      (uint16_t )7409,      (uint16_t )7429, 
        (uint16_t )7435,      (uint16_t )7444,      (uint16_t )7450,      (uint16_t )7461, 
        (uint16_t )7467,      (uint16_t )7476,      (uint16_t )7482,      (uint16_t )7505, 
        (uint16_t )7511,      (uint16_t )7520,      (uint16_t )7526,      (uint16_t )7537, 
        (uint16_t )7543,      (uint16_t )7552,      (uint16_t )7558,      (uint16_t )7578, 
        (uint16_t )7584,      (uint16_t )7593,      (uint16_t )7599,      (uint16_t )7610, 
        (uint16_t )7616,      (uint16_t )7625,      (uint16_t )7631,      (uint16_t )7656, 
        (uint16_t )7662,      (uint16_t )7671,      (uint16_t )7677,      (uint16_t )7688, 
        (uint16_t )7694,      (uint16_t )7703,      (uint16_t )7709,      (uint16_t )7729, 
        (uint16_t )7735,      (uint16_t )7744,      (uint16_t )7750,      (uint16_t )7761};
#line 337 "/doner/libwebp/libwebp-v0.3.0/src/enc/cost.c"
static int VariableLevelCost(int level , uint8_t probas[11] ) 
{ 
  int pattern ;
  int bits ;
  int cost ;
  int i ;
  int __cil_tmp7 ;

  {
#line 338
  pattern = (int )VP8LevelCodes[level - 1][0];
#line 339
  bits = (int )VP8LevelCodes[level - 1][1];
#line 340
  cost = 0;
#line 342
  i = 2;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! pattern) {
#line 342
      goto while_break;
    }
#line 343
    if (pattern & 1) {
      {
#line 344
      __cil_tmp7 = VP8BitCost(bits & 1, probas[i]);
      }
#line 344
      cost += __cil_tmp7;
    }
#line 346
    bits >>= 1;
#line 347
    pattern >>= 1;
#line 342
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return (cost);
}
}
#line 355 "/doner/libwebp/libwebp-v0.3.0/src/enc/cost.c"
void VP8CalculateLevelCosts(VP8Proba *proba ) 
{ 
  int ctype ;
  int band ;
  int ctx ;
  uint8_t *p ;
  uint16_t *table ;
  int cost_base ;
  int __cil_tmp8 ;
  int v ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 358
  if (! proba->dirty_) {
#line 358
    return;
  }
#line 360
  ctype = 0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (ctype < 4)) {
#line 360
      goto while_break;
    }
#line 361
    band = 0;
    {
#line 361
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 361
      if (! (band < 8)) {
#line 361
        goto while_break___0;
      }
#line 362
      ctx = 0;
      {
#line 362
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 362
        if (! (ctx < 3)) {
#line 362
          goto while_break___1;
        }
        {
#line 363
        p = (uint8_t *)proba->coeffs_[ctype][band][ctx];
#line 364
        table = (uint16_t *)proba->level_cost_[ctype][band][ctx];
#line 365
        __cil_tmp8 = VP8BitCost(1, *(p + 1));
#line 365
        cost_base = __cil_tmp8;
#line 367
        __cil_tmp10 = VP8BitCost(0, *(p + 1));
#line 367
        *(table + 0) = (uint16_t )__cil_tmp10;
#line 368
        v = 1;
        }
        {
#line 368
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 368
          if (! (v <= 67)) {
#line 368
            goto while_break___2;
          }
          {
#line 369
          __cil_tmp11 = VariableLevelCost(v, p);
#line 369
          *(table + v) = (uint16_t )(cost_base + __cil_tmp11);
          }
#line 368
          v ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 362
        ctx ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 361
      band ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 360
    ctype ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  proba->dirty_ = 0;
  return;
}
}
#line 384 "/doner/libwebp/libwebp-v0.3.0/src/enc/cost.c"
uint16_t VP8FixedCostsUV[4]  = {      (uint16_t )302,      (uint16_t )984,      (uint16_t )439,      (uint16_t )642};
#line 386 "/doner/libwebp/libwebp-v0.3.0/src/enc/cost.c"
uint16_t VP8FixedCostsI16[4]  = {      (uint16_t )663,      (uint16_t )919,      (uint16_t )872,      (uint16_t )919};
#line 387 "/doner/libwebp/libwebp-v0.3.0/src/enc/cost.c"
uint16_t VP8FixedCostsI4[10][10][10]  = 
#line 387
  { { {          (uint16_t )251,          (uint16_t )1362,          (uint16_t )1934,          (uint16_t )2085, 
                (uint16_t )2314,          (uint16_t )2230,          (uint16_t )1839,          (uint16_t )1988, 
                (uint16_t )2437,          (uint16_t )2348}, 
     {          (uint16_t )403,          (uint16_t )680,          (uint16_t )1507,          (uint16_t )1519, 
                (uint16_t )2060,          (uint16_t )2005,          (uint16_t )1992,          (uint16_t )1914, 
                (uint16_t )1924,          (uint16_t )1733}, 
     {          (uint16_t )353,          (uint16_t )1121,          (uint16_t )973,          (uint16_t )1895, 
                (uint16_t )2060,          (uint16_t )1787,          (uint16_t )1671,          (uint16_t )1516, 
                (uint16_t )2012,          (uint16_t )1868}, 
     {          (uint16_t )770,          (uint16_t )852,          (uint16_t )1581,          (uint16_t )632, 
                (uint16_t )1393,          (uint16_t )1780,          (uint16_t )1823,          (uint16_t )1936, 
                (uint16_t )1074,          (uint16_t )1218}, 
     {          (uint16_t )510,          (uint16_t )1270,          (uint16_t )1467,          (uint16_t )1319, 
                (uint16_t )847,          (uint16_t )1279,          (uint16_t )1792,          (uint16_t )2094, 
                (uint16_t )1080,          (uint16_t )1353}, 
     {          (uint16_t )488,          (uint16_t )1322,          (uint16_t )918,          (uint16_t )1573, 
                (uint16_t )1300,          (uint16_t )883,          (uint16_t )1814,          (uint16_t )1752, 
                (uint16_t )1756,          (uint16_t )1502}, 
     {          (uint16_t )425,          (uint16_t )992,          (uint16_t )1820,          (uint16_t )1514, 
                (uint16_t )1843,          (uint16_t )2440,          (uint16_t )937,          (uint16_t )1771, 
                (uint16_t )1924,          (uint16_t )1129}, 
     {          (uint16_t )363,          (uint16_t )1248,          (uint16_t )1257,          (uint16_t )1970, 
                (uint16_t )2194,          (uint16_t )2385,          (uint16_t )1569,          (uint16_t )953, 
                (uint16_t )1951,          (uint16_t )1601}, 
     {          (uint16_t )723,          (uint16_t )1257,          (uint16_t )1631,          (uint16_t )964, 
                (uint16_t )963,          (uint16_t )1508,          (uint16_t )1697,          (uint16_t )1824, 
                (uint16_t )671,          (uint16_t )1418}, 
     {          (uint16_t )635,          (uint16_t )1038,          (uint16_t )1573,          (uint16_t )930, 
                (uint16_t )1673,          (uint16_t )1413,          (uint16_t )1410,          (uint16_t )1687, 
                (uint16_t )1410,          (uint16_t )749}}, 
   { {          (uint16_t )451,          (uint16_t )613,          (uint16_t )1345,          (uint16_t )1702, 
                (uint16_t )1870,          (uint16_t )1716,          (uint16_t )1728,          (uint16_t )1766, 
                (uint16_t )2190,          (uint16_t )2310}, 
     {          (uint16_t )678,          (uint16_t )453,          (uint16_t )1171,          (uint16_t )1443, 
                (uint16_t )1925,          (uint16_t )1831,          (uint16_t )2045,          (uint16_t )1781, 
                (uint16_t )1887,          (uint16_t )1602}, 
     {          (uint16_t )711,          (uint16_t )666,          (uint16_t )674,          (uint16_t )1718, 
                (uint16_t )1910,          (uint16_t )1493,          (uint16_t )1775,          (uint16_t )1193, 
                (uint16_t )2325,          (uint16_t )2325}, 
     {          (uint16_t )883,          (uint16_t )854,          (uint16_t )1583,          (uint16_t )542, 
                (uint16_t )1800,          (uint16_t )1878,          (uint16_t )1664,          (uint16_t )2149, 
                (uint16_t )1207,          (uint16_t )1087}, 
     {          (uint16_t )669,          (uint16_t )994,          (uint16_t )1248,          (uint16_t )1122, 
                (uint16_t )949,          (uint16_t )1179,          (uint16_t )1376,          (uint16_t )1729, 
                (uint16_t )1070,          (uint16_t )1244}, 
     {          (uint16_t )715,          (uint16_t )1026,          (uint16_t )715,          (uint16_t )1350, 
                (uint16_t )1430,          (uint16_t )930,          (uint16_t )1717,          (uint16_t )1296, 
                (uint16_t )1479,          (uint16_t )1479}, 
     {          (uint16_t )544,          (uint16_t )841,          (uint16_t )1656,          (uint16_t )1450, 
                (uint16_t )2094,          (uint16_t )3883,          (uint16_t )1010,          (uint16_t )1759, 
                (uint16_t )2076,          (uint16_t )809}, 
     {          (uint16_t )610,          (uint16_t )855,          (uint16_t )957,          (uint16_t )1553, 
                (uint16_t )2067,          (uint16_t )1561,          (uint16_t )1704,          (uint16_t )824, 
                (uint16_t )2066,          (uint16_t )1226}, 
     {          (uint16_t )833,          (uint16_t )960,          (uint16_t )1416,          (uint16_t )819, 
                (uint16_t )1277,          (uint16_t )1619,          (uint16_t )1501,          (uint16_t )1617, 
                (uint16_t )757,          (uint16_t )1182}, 
     {          (uint16_t )711,          (uint16_t )964,          (uint16_t )1252,          (uint16_t )879, 
                (uint16_t )1441,          (uint16_t )1828,          (uint16_t )1508,          (uint16_t )1636, 
                (uint16_t )1594,          (uint16_t )734}}, 
   { {          (uint16_t )605,          (uint16_t )764,          (uint16_t )734,          (uint16_t )1713, 
                (uint16_t )1747,          (uint16_t )1192,          (uint16_t )1819,          (uint16_t )1353, 
                (uint16_t )1877,          (uint16_t )2392}, 
     {          (uint16_t )866,          (uint16_t )641,          (uint16_t )586,          (uint16_t )1622, 
                (uint16_t )2072,          (uint16_t )1431,          (uint16_t )1888,          (uint16_t )1346, 
                (uint16_t )2189,          (uint16_t )1764}, 
     {          (uint16_t )901,          (uint16_t )851,          (uint16_t )456,          (uint16_t )2165, 
                (uint16_t )2281,          (uint16_t )1405,          (uint16_t )1739,          (uint16_t )1193, 
                (uint16_t )2183,          (uint16_t )2443}, 
     {          (uint16_t )770,          (uint16_t )1045,          (uint16_t )952,          (uint16_t )1078, 
                (uint16_t )1342,          (uint16_t )1191,          (uint16_t )1436,          (uint16_t )1063, 
                (uint16_t )1303,          (uint16_t )995}, 
     {          (uint16_t )901,          (uint16_t )1086,          (uint16_t )727,          (uint16_t )1170, 
                (uint16_t )884,          (uint16_t )1105,          (uint16_t )1267,          (uint16_t )1401, 
                (uint16_t )1739,          (uint16_t )1337}, 
     {          (uint16_t )951,          (uint16_t )1162,          (uint16_t )595,          (uint16_t )1488, 
                (uint16_t )1388,          (uint16_t )703,          (uint16_t )1790,          (uint16_t )1366, 
                (uint16_t )2057,          (uint16_t )1724}, 
     {          (uint16_t )534,          (uint16_t )986,          (uint16_t )1273,          (uint16_t )1987, 
                (uint16_t )3273,          (uint16_t )1485,          (uint16_t )1024,          (uint16_t )1399, 
                (uint16_t )1583,          (uint16_t )866}, 
     {          (uint16_t )699,          (uint16_t )1182,          (uint16_t )695,          (uint16_t )1978, 
                (uint16_t )1726,          (uint16_t )1986,          (uint16_t )1326,          (uint16_t )714, 
                (uint16_t )1750,          (uint16_t )1672}, 
     {          (uint16_t )951,          (uint16_t )1217,          (uint16_t )1209,          (uint16_t )920, 
                (uint16_t )1062,          (uint16_t )1441,          (uint16_t )1548,          (uint16_t )999, 
                (uint16_t )952,          (uint16_t )932}, 
     {          (uint16_t )733,          (uint16_t )1284,          (uint16_t )784,          (uint16_t )1256, 
                (uint16_t )1557,          (uint16_t )1098,          (uint16_t )1257,          (uint16_t )1357, 
                (uint16_t )1414,          (uint16_t )908}}, 
   { {          (uint16_t )316,          (uint16_t )1075,          (uint16_t )1653,          (uint16_t )1220, 
                (uint16_t )2145,          (uint16_t )2051,          (uint16_t )1730,          (uint16_t )2131, 
                (uint16_t )1884,          (uint16_t )1790}, 
     {          (uint16_t )745,          (uint16_t )516,          (uint16_t )1404,          (uint16_t )894, 
                (uint16_t )1599,          (uint16_t )2375,          (uint16_t )2013,          (uint16_t )2105, 
                (uint16_t )1475,          (uint16_t )1381}, 
     {          (uint16_t )516,          (uint16_t )729,          (uint16_t )1088,          (uint16_t )1319, 
                (uint16_t )1637,          (uint16_t )3426,          (uint16_t )1636,          (uint16_t )1275, 
                (uint16_t )1531,          (uint16_t )1453}, 
     {          (uint16_t )894,          (uint16_t )943,          (uint16_t )2138,          (uint16_t )468, 
                (uint16_t )1704,          (uint16_t )2259,          (uint16_t )2069,          (uint16_t )1763, 
                (uint16_t )1266,          (uint16_t )1158}, 
     {          (uint16_t )605,          (uint16_t )1025,          (uint16_t )1235,          (uint16_t )871, 
                (uint16_t )1170,          (uint16_t )1767,          (uint16_t )1493,          (uint16_t )1500, 
                (uint16_t )1104,          (uint16_t )1258}, 
     {          (uint16_t )739,          (uint16_t )826,          (uint16_t )1207,          (uint16_t )1151, 
                (uint16_t )1412,          (uint16_t )846,          (uint16_t )1305,          (uint16_t )2726, 
                (uint16_t )1014,          (uint16_t )1569}, 
     {          (uint16_t )558,          (uint16_t )825,          (uint16_t )1820,          (uint16_t )1398, 
                (uint16_t )3344,          (uint16_t )1556,          (uint16_t )1218,          (uint16_t )1550, 
                (uint16_t )1228,          (uint16_t )878}, 
     {          (uint16_t )429,          (uint16_t )951,          (uint16_t )1089,          (uint16_t )1816, 
                (uint16_t )3861,          (uint16_t )3861,          (uint16_t )1556,          (uint16_t )969, 
                (uint16_t )1568,          (uint16_t )1828}, 
     {          (uint16_t )883,          (uint16_t )961,          (uint16_t )1752,          (uint16_t )769, 
                (uint16_t )1468,          (uint16_t )1810,          (uint16_t )2081,          (uint16_t )2346, 
                (uint16_t )613,          (uint16_t )1298}, 
     {          (uint16_t )803,          (uint16_t )895,          (uint16_t )1372,          (uint16_t )641, 
                (uint16_t )1303,          (uint16_t )1708,          (uint16_t )1686,          (uint16_t )1700, 
                (uint16_t )1306,          (uint16_t )1033}}, 
   { {          (uint16_t )439,          (uint16_t )1267,          (uint16_t )1270,          (uint16_t )1579, 
                (uint16_t )963,          (uint16_t )1193,          (uint16_t )1723,          (uint16_t )1729, 
                (uint16_t )1198,          (uint16_t )1993}, 
     {          (uint16_t )705,          (uint16_t )725,          (uint16_t )1029,          (uint16_t )1153, 
                (uint16_t )1176,          (uint16_t )1103,          (uint16_t )1821,          (uint16_t )1567, 
                (uint16_t )1259,          (uint16_t )1574}, 
     {          (uint16_t )723,          (uint16_t )859,          (uint16_t )802,          (uint16_t )1253, 
                (uint16_t )972,          (uint16_t )1202,          (uint16_t )1407,          (uint16_t )1665, 
                (uint16_t )1520,          (uint16_t )1674}, 
     {          (uint16_t )894,          (uint16_t )960,          (uint16_t )1254,          (uint16_t )887, 
                (uint16_t )1052,          (uint16_t )1607,          (uint16_t )1344,          (uint16_t )1349, 
                (uint16_t )865,          (uint16_t )1150}, 
     {          (uint16_t )833,          (uint16_t )1312,          (uint16_t )1337,          (uint16_t )1205, 
                (uint16_t )572,          (uint16_t )1288,          (uint16_t )1414,          (uint16_t )1529, 
                (uint16_t )1088,          (uint16_t )1430}, 
     {          (uint16_t )842,          (uint16_t )1279,          (uint16_t )1068,          (uint16_t )1861, 
                (uint16_t )862,          (uint16_t )688,          (uint16_t )1861,          (uint16_t )1630, 
                (uint16_t )1039,          (uint16_t )1381}, 
     {          (uint16_t )766,          (uint16_t )938,          (uint16_t )1279,          (uint16_t )1546, 
                (uint16_t )3338,          (uint16_t )1550,          (uint16_t )1031,          (uint16_t )1542, 
                (uint16_t )1288,          (uint16_t )640}, 
     {          (uint16_t )715,          (uint16_t )1090,          (uint16_t )835,          (uint16_t )1609, 
                (uint16_t )1100,          (uint16_t )1100,          (uint16_t )1603,          (uint16_t )1019, 
                (uint16_t )1102,          (uint16_t )1617}, 
     {          (uint16_t )894,          (uint16_t )1813,          (uint16_t )1500,          (uint16_t )1188, 
                (uint16_t )789,          (uint16_t )1194,          (uint16_t )1491,          (uint16_t )1919, 
                (uint16_t )617,          (uint16_t )1333}, 
     {          (uint16_t )610,          (uint16_t )1076,          (uint16_t )1644,          (uint16_t )1281, 
                (uint16_t )1283,          (uint16_t )975,          (uint16_t )1179,          (uint16_t )1688, 
                (uint16_t )1434,          (uint16_t )889}}, 
   { {          (uint16_t )544,          (uint16_t )971,          (uint16_t )1146,          (uint16_t )1849, 
                (uint16_t )1221,          (uint16_t )740,          (uint16_t )1857,          (uint16_t )1621, 
                (uint16_t )1683,          (uint16_t )2430}, 
     {          (uint16_t )723,          (uint16_t )705,          (uint16_t )961,          (uint16_t )1371, 
                (uint16_t )1426,          (uint16_t )821,          (uint16_t )2081,          (uint16_t )2079, 
                (uint16_t )1839,          (uint16_t )1380}, 
     {          (uint16_t )783,          (uint16_t )857,          (uint16_t )703,          (uint16_t )2145, 
                (uint16_t )1419,          (uint16_t )814,          (uint16_t )1791,          (uint16_t )1310, 
                (uint16_t )1609,          (uint16_t )2206}, 
     {          (uint16_t )997,          (uint16_t )1000,          (uint16_t )1153,          (uint16_t )792, 
                (uint16_t )1229,          (uint16_t )1162,          (uint16_t )1810,          (uint16_t )1418, 
                (uint16_t )942,          (uint16_t )979}, 
     {          (uint16_t )901,          (uint16_t )1226,          (uint16_t )883,          (uint16_t )1289, 
                (uint16_t )793,          (uint16_t )715,          (uint16_t )1904,          (uint16_t )1649, 
                (uint16_t )1319,          (uint16_t )3108}, 
     {          (uint16_t )979,          (uint16_t )1478,          (uint16_t )782,          (uint16_t )2216, 
                (uint16_t )1454,          (uint16_t )455,          (uint16_t )3092,          (uint16_t )1591, 
                (uint16_t )1997,          (uint16_t )1664}, 
     {          (uint16_t )663,          (uint16_t )1110,          (uint16_t )1504,          (uint16_t )1114, 
                (uint16_t )1522,          (uint16_t )3311,          (uint16_t )676,          (uint16_t )1522, 
                (uint16_t )1530,          (uint16_t )1024}, 
     {          (uint16_t )605,          (uint16_t )1138,          (uint16_t )1153,          (uint16_t )1314, 
                (uint16_t )1569,          (uint16_t )1315,          (uint16_t )1157,          (uint16_t )804, 
                (uint16_t )1574,          (uint16_t )1320}, 
     {          (uint16_t )770,          (uint16_t )1216,          (uint16_t )1218,          (uint16_t )1227, 
                (uint16_t )869,          (uint16_t )1384,          (uint16_t )1232,          (uint16_t )1375, 
                (uint16_t )834,          (uint16_t )1239}, 
     {          (uint16_t )775,          (uint16_t )1007,          (uint16_t )843,          (uint16_t )1216, 
                (uint16_t )1225,          (uint16_t )1074,          (uint16_t )2527,          (uint16_t )1479, 
                (uint16_t )1149,          (uint16_t )975}}, 
   { {          (uint16_t )477,          (uint16_t )817,          (uint16_t )1309,          (uint16_t )1439, 
                (uint16_t )1708,          (uint16_t )1454,          (uint16_t )1159,          (uint16_t )1241, 
                (uint16_t )1945,          (uint16_t )1672}, 
     {          (uint16_t )577,          (uint16_t )796,          (uint16_t )1112,          (uint16_t )1271, 
                (uint16_t )1618,          (uint16_t )1458,          (uint16_t )1087,          (uint16_t )1345, 
                (uint16_t )1831,          (uint16_t )1265}, 
     {          (uint16_t )663,          (uint16_t )776,          (uint16_t )753,          (uint16_t )1940, 
                (uint16_t )1690,          (uint16_t )1690,          (uint16_t )1227,          (uint16_t )1097, 
                (uint16_t )3149,          (uint16_t )1361}, 
     {          (uint16_t )766,          (uint16_t )1299,          (uint16_t )1744,          (uint16_t )1161, 
                (uint16_t )1565,          (uint16_t )1106,          (uint16_t )1045,          (uint16_t )1230, 
                (uint16_t )1232,          (uint16_t )707}, 
     {          (uint16_t )915,          (uint16_t )1026,          (uint16_t )1404,          (uint16_t )1182, 
                (uint16_t )1184,          (uint16_t )851,          (uint16_t )1428,          (uint16_t )2425, 
                (uint16_t )1043,          (uint16_t )789}, 
     {          (uint16_t )883,          (uint16_t )1456,          (uint16_t )790,          (uint16_t )1082, 
                (uint16_t )1086,          (uint16_t )985,          (uint16_t )1083,          (uint16_t )1484, 
                (uint16_t )1238,          (uint16_t )1160}, 
     {          (uint16_t )507,          (uint16_t )1345,          (uint16_t )2261,          (uint16_t )1995, 
                (uint16_t )1847,          (uint16_t )3636,          (uint16_t )653,          (uint16_t )1761, 
                (uint16_t )2287,          (uint16_t )933}, 
     {          (uint16_t )553,          (uint16_t )1193,          (uint16_t )1470,          (uint16_t )2057, 
                (uint16_t )2059,          (uint16_t )2059,          (uint16_t )833,          (uint16_t )779, 
                (uint16_t )2058,          (uint16_t )1263}, 
     {          (uint16_t )766,          (uint16_t )1275,          (uint16_t )1515,          (uint16_t )1039, 
                (uint16_t )957,          (uint16_t )1554,          (uint16_t )1286,          (uint16_t )1540, 
                (uint16_t )1289,          (uint16_t )705}, 
     {          (uint16_t )499,          (uint16_t )1378,          (uint16_t )1496,          (uint16_t )1385, 
                (uint16_t )1850,          (uint16_t )1850,          (uint16_t )1044,          (uint16_t )2465, 
                (uint16_t )1515,          (uint16_t )720}}, 
   { {          (uint16_t )553,          (uint16_t )930,          (uint16_t )978,          (uint16_t )2077, 
                (uint16_t )1968,          (uint16_t )1481,          (uint16_t )1457,          (uint16_t )761, 
                (uint16_t )1957,          (uint16_t )2362}, 
     {          (uint16_t )694,          (uint16_t )864,          (uint16_t )905,          (uint16_t )1720, 
                (uint16_t )1670,          (uint16_t )1621,          (uint16_t )1429,          (uint16_t )718, 
                (uint16_t )2125,          (uint16_t )1477}, 
     {          (uint16_t )699,          (uint16_t )968,          (uint16_t )658,          (uint16_t )3190, 
                (uint16_t )2024,          (uint16_t )1479,          (uint16_t )1865,          (uint16_t )750, 
                (uint16_t )2060,          (uint16_t )2320}, 
     {          (uint16_t )733,          (uint16_t )1308,          (uint16_t )1296,          (uint16_t )1062, 
                (uint16_t )1576,          (uint16_t )1322,          (uint16_t )1062,          (uint16_t )1112, 
                (uint16_t )1172,          (uint16_t )816}, 
     {          (uint16_t )920,          (uint16_t )927,          (uint16_t )1052,          (uint16_t )939, 
                (uint16_t )947,          (uint16_t )1156,          (uint16_t )1152,          (uint16_t )1073, 
                (uint16_t )3056,          (uint16_t )1268}, 
     {          (uint16_t )723,          (uint16_t )1534,          (uint16_t )711,          (uint16_t )1547, 
                (uint16_t )1294,          (uint16_t )892,          (uint16_t )1553,          (uint16_t )928, 
                (uint16_t )1815,          (uint16_t )1561}, 
     {          (uint16_t )663,          (uint16_t )1366,          (uint16_t )1583,          (uint16_t )2111, 
                (uint16_t )1712,          (uint16_t )3501,          (uint16_t )522,          (uint16_t )1155, 
                (uint16_t )2130,          (uint16_t )1133}, 
     {          (uint16_t )614,          (uint16_t )1731,          (uint16_t )1188,          (uint16_t )2343, 
                (uint16_t )1944,          (uint16_t )3733,          (uint16_t )1287,          (uint16_t )487, 
                (uint16_t )3546,          (uint16_t )1758}, 
     {          (uint16_t )770,          (uint16_t )1585,          (uint16_t )1312,          (uint16_t )826, 
                (uint16_t )884,          (uint16_t )2673,          (uint16_t )1185,          (uint16_t )1006, 
                (uint16_t )1195,          (uint16_t )1195}, 
     {          (uint16_t )758,          (uint16_t )1333,          (uint16_t )1273,          (uint16_t )1023, 
                (uint16_t )1621,          (uint16_t )1162,          (uint16_t )1351,          (uint16_t )833, 
                (uint16_t )1479,          (uint16_t )862}}, 
   { {          (uint16_t )376,          (uint16_t )1193,          (uint16_t )1446,          (uint16_t )1149, 
                (uint16_t )1545,          (uint16_t )1577,          (uint16_t )1870,          (uint16_t )1789, 
                (uint16_t )1175,          (uint16_t )1823}, 
     {          (uint16_t )803,          (uint16_t )633,          (uint16_t )1136,          (uint16_t )1058, 
                (uint16_t )1350,          (uint16_t )1323,          (uint16_t )1598,          (uint16_t )2247, 
                (uint16_t )1072,          (uint16_t )1252}, 
     {          (uint16_t )614,          (uint16_t )1048,          (uint16_t )943,          (uint16_t )981, 
                (uint16_t )1152,          (uint16_t )1869,          (uint16_t )1461,          (uint16_t )1020, 
                (uint16_t )1618,          (uint16_t )1618}, 
     {          (uint16_t )1107,          (uint16_t )1085,          (uint16_t )1282,          (uint16_t )592, 
                (uint16_t )1779,          (uint16_t )1933,          (uint16_t )1648,          (uint16_t )2403, 
                (uint16_t )691,          (uint16_t )1246}, 
     {          (uint16_t )851,          (uint16_t )1309,          (uint16_t )1223,          (uint16_t )1243, 
                (uint16_t )895,          (uint16_t )1593,          (uint16_t )1792,          (uint16_t )2317, 
                (uint16_t )627,          (uint16_t )1076}, 
     {          (uint16_t )770,          (uint16_t )1216,          (uint16_t )1030,          (uint16_t )1125, 
                (uint16_t )921,          (uint16_t )981,          (uint16_t )1629,          (uint16_t )1131, 
                (uint16_t )1049,          (uint16_t )1646}, 
     {          (uint16_t )626,          (uint16_t )1469,          (uint16_t )1456,          (uint16_t )1081, 
                (uint16_t )1489,          (uint16_t )3278,          (uint16_t )981,          (uint16_t )1232, 
                (uint16_t )1498,          (uint16_t )733}, 
     {          (uint16_t )617,          (uint16_t )1201,          (uint16_t )812,          (uint16_t )1220, 
                (uint16_t )1476,          (uint16_t )1476,          (uint16_t )1478,          (uint16_t )970, 
                (uint16_t )1228,          (uint16_t )1488}, 
     {          (uint16_t )1179,          (uint16_t )1393,          (uint16_t )1540,          (uint16_t )999, 
                (uint16_t )1243,          (uint16_t )1503,          (uint16_t )1916,          (uint16_t )1925, 
                (uint16_t )414,          (uint16_t )1614}, 
     {          (uint16_t )943,          (uint16_t )1088,          (uint16_t )1490,          (uint16_t )682, 
                (uint16_t )1112,          (uint16_t )1372,          (uint16_t )1756,          (uint16_t )1505, 
                (uint16_t )966,          (uint16_t )966}}, 
   { {          (uint16_t )322,          (uint16_t )1142,          (uint16_t )1589,          (uint16_t )1396, 
                (uint16_t )2144,          (uint16_t )1859,          (uint16_t )1359,          (uint16_t )1925, 
                (uint16_t )2084,          (uint16_t )1518}, 
     {          (uint16_t )617,          (uint16_t )625,          (uint16_t )1241,          (uint16_t )1234, 
                (uint16_t )2121,          (uint16_t )1615,          (uint16_t )1524,          (uint16_t )1858, 
                (uint16_t )1720,          (uint16_t )1004}, 
     {          (uint16_t )553,          (uint16_t )851,          (uint16_t )786,          (uint16_t )1299, 
                (uint16_t )1452,          (uint16_t )1560,          (uint16_t )1372,          (uint16_t )1561, 
                (uint16_t )1967,          (uint16_t )1713}, 
     {          (uint16_t )770,          (uint16_t )977,          (uint16_t )1396,          (uint16_t )568, 
                (uint16_t )1893,          (uint16_t )1639,          (uint16_t )1540,          (uint16_t )2108, 
                (uint16_t )1430,          (uint16_t )1013}, 
     {          (uint16_t )684,          (uint16_t )1120,          (uint16_t )1375,          (uint16_t )982, 
                (uint16_t )930,          (uint16_t )2719,          (uint16_t )1638,          (uint16_t )1643, 
                (uint16_t )933,          (uint16_t )993}, 
     {          (uint16_t )553,          (uint16_t )1103,          (uint16_t )996,          (uint16_t )1356, 
                (uint16_t )1361,          (uint16_t )1005,          (uint16_t )1507,          (uint16_t )1761, 
                (uint16_t )1184,          (uint16_t )1268}, 
     {          (uint16_t )419,          (uint16_t )1247,          (uint16_t )1537,          (uint16_t )1554, 
                (uint16_t )1817,          (uint16_t )3606,          (uint16_t )1026,          (uint16_t )1666, 
                (uint16_t )1829,          (uint16_t )923}, 
     {          (uint16_t )439,          (uint16_t )1139,          (uint16_t )1101,          (uint16_t )1257, 
                (uint16_t )3710,          (uint16_t )1922,          (uint16_t )1205,          (uint16_t )1040, 
                (uint16_t )1931,          (uint16_t )1529}, 
     {          (uint16_t )979,          (uint16_t )935,          (uint16_t )1269,          (uint16_t )847, 
                (uint16_t )1202,          (uint16_t )1286,          (uint16_t )1530,          (uint16_t )1535, 
                (uint16_t )827,          (uint16_t )1036}, 
     {          (uint16_t )516,          (uint16_t )1378,          (uint16_t )1569,          (uint16_t )1110, 
                (uint16_t )1798,          (uint16_t )1798,          (uint16_t )1198,          (uint16_t )2199, 
                (uint16_t )1543,          (uint16_t )712}}};
#line 22 "/doner/libwebp/libwebp-v0.3.0/src/enc/config.c"
int WebPConfigInitInternal(WebPConfig *config , enum WebPPreset preset , float quality ,
                           int version ) 
{ 
  int __cil_tmp5 ;

  {
#line 24
  if (version >> 8 != 513 >> 8) {
#line 25
    return (0);
  }
#line 27
  if (config == (void *)0) {
#line 27
    return (0);
  }
#line 29
  config->quality = quality;
#line 30
  config->target_size = 0;
#line 31
  config->target_PSNR = (float )0.;
#line 32
  config->method = 4;
#line 33
  config->sns_strength = 50;
#line 34
  config->filter_strength = 60;
#line 35
  config->filter_sharpness = 0;
#line 36
  config->filter_type = 1;
#line 37
  config->partitions = 0;
#line 38
  config->segments = 4;
#line 39
  config->pass = 1;
#line 40
  config->show_compressed = 0;
#line 41
  config->preprocessing = 0;
#line 42
  config->autofilter = 0;
#line 43
  config->partition_limit = 0;
#line 44
  config->alpha_compression = 1;
#line 45
  config->alpha_filtering = 1;
#line 46
  config->alpha_quality = 100;
#line 47
  config->lossless = 0;
#line 48
  config->image_hint = (enum WebPImageHint )0;
#line 49
  config->emulate_jpeg_size = 0;
#line 50
  config->thread_level = 0;
#line 51
  config->low_memory = 0;
  {
#line 55
  if ((unsigned int )preset == (unsigned int )1) {
#line 55
    goto case_1;
  }
#line 60
  if ((unsigned int )preset == (unsigned int )2) {
#line 60
    goto case_2;
  }
#line 65
  if ((unsigned int )preset == (unsigned int )3) {
#line 65
    goto case_3;
  }
#line 70
  if ((unsigned int )preset == (unsigned int )4) {
#line 70
    goto case_4;
  }
#line 74
  if ((unsigned int )preset == (unsigned int )5) {
#line 74
    goto case_5;
  }
#line 80
  goto switch_default;
  case_1: /* CIL Label */ 
#line 56
  config->sns_strength = 80;
#line 57
  config->filter_sharpness = 4;
#line 58
  config->filter_strength = 35;
#line 59
  goto switch_break;
  case_2: /* CIL Label */ 
#line 61
  config->sns_strength = 80;
#line 62
  config->filter_sharpness = 3;
#line 63
  config->filter_strength = 30;
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
#line 66
  config->sns_strength = 25;
#line 67
  config->filter_sharpness = 6;
#line 68
  config->filter_strength = 10;
#line 69
  goto switch_break;
  case_4: /* CIL Label */ 
#line 71
  config->sns_strength = 0;
#line 72
  config->filter_strength = 0;
#line 73
  goto switch_break;
  case_5: /* CIL Label */ 
#line 75
  config->sns_strength = 0;
#line 76
  config->filter_strength = 0;
#line 77
  config->segments = 2;
#line 78
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 81
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 83
  __cil_tmp5 = WebPValidateConfig(config);
  }
#line 83
  return (__cil_tmp5);
}
}
#line 86 "/doner/libwebp/libwebp-v0.3.0/src/enc/config.c"
int WebPValidateConfig(WebPConfig *config ) 
{ 


  {
#line 87
  if (config == (void *)0) {
#line 87
    return (0);
  }
#line 88
  if (config->quality < (float )0) {
#line 89
    return (0);
  } else
#line 88
  if (config->quality > (float )100) {
#line 89
    return (0);
  }
#line 90
  if (config->target_size < 0) {
#line 91
    return (0);
  }
#line 92
  if (config->target_PSNR < (float )0) {
#line 93
    return (0);
  }
#line 94
  if (config->method < 0) {
#line 95
    return (0);
  } else
#line 94
  if (config->method > 6) {
#line 95
    return (0);
  }
#line 96
  if (config->segments < 1) {
#line 97
    return (0);
  } else
#line 96
  if (config->segments > 4) {
#line 97
    return (0);
  }
#line 98
  if (config->sns_strength < 0) {
#line 99
    return (0);
  } else
#line 98
  if (config->sns_strength > 100) {
#line 99
    return (0);
  }
#line 100
  if (config->filter_strength < 0) {
#line 101
    return (0);
  } else
#line 100
  if (config->filter_strength > 100) {
#line 101
    return (0);
  }
#line 102
  if (config->filter_sharpness < 0) {
#line 103
    return (0);
  } else
#line 102
  if (config->filter_sharpness > 7) {
#line 103
    return (0);
  }
#line 104
  if (config->filter_type < 0) {
#line 105
    return (0);
  } else
#line 104
  if (config->filter_type > 1) {
#line 105
    return (0);
  }
#line 106
  if (config->autofilter < 0) {
#line 107
    return (0);
  } else
#line 106
  if (config->autofilter > 1) {
#line 107
    return (0);
  }
#line 108
  if (config->pass < 1) {
#line 109
    return (0);
  } else
#line 108
  if (config->pass > 10) {
#line 109
    return (0);
  }
#line 110
  if (config->show_compressed < 0) {
#line 111
    return (0);
  } else
#line 110
  if (config->show_compressed > 1) {
#line 111
    return (0);
  }
#line 112
  if (config->preprocessing < 0) {
#line 113
    return (0);
  } else
#line 112
  if (config->preprocessing > 1) {
#line 113
    return (0);
  }
#line 114
  if (config->partitions < 0) {
#line 115
    return (0);
  } else
#line 114
  if (config->partitions > 3) {
#line 115
    return (0);
  }
#line 116
  if (config->partition_limit < 0) {
#line 117
    return (0);
  } else
#line 116
  if (config->partition_limit > 100) {
#line 117
    return (0);
  }
#line 118
  if (config->alpha_compression < 0) {
#line 119
    return (0);
  }
#line 120
  if (config->alpha_filtering < 0) {
#line 121
    return (0);
  }
#line 122
  if (config->alpha_quality < 0) {
#line 123
    return (0);
  } else
#line 122
  if (config->alpha_quality > 100) {
#line 123
    return (0);
  }
#line 124
  if (config->lossless < 0) {
#line 125
    return (0);
  } else
#line 124
  if (config->lossless > 1) {
#line 125
    return (0);
  }
#line 126
  if ((unsigned int )config->image_hint >= 4U) {
#line 127
    return (0);
  }
#line 128
  if (config->emulate_jpeg_size < 0) {
#line 129
    return (0);
  } else
#line 128
  if (config->emulate_jpeg_size > 1) {
#line 129
    return (0);
  }
#line 130
  if (config->thread_level < 0) {
#line 131
    return (0);
  } else
#line 130
  if (config->thread_level > 1) {
#line 131
    return (0);
  }
#line 132
  if (config->low_memory < 0) {
#line 133
    return (0);
  } else
#line 132
  if (config->low_memory > 1) {
#line 133
    return (0);
  }
#line 134
  return (1);
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/enc/../utils/color_cache.h"
static uint32_t kHashMul___0  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/enc/../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___0(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___0 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/enc/../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___0(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___0 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/enc/../utils/color_cache.h"
__inline static int VP8LColorCacheContains___0(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___0 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 44 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static uint8_t plane_to_code_lut[128]  = 
#line 44 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
  {      (uint8_t )96,      (uint8_t )73,      (uint8_t )55,      (uint8_t )39, 
        (uint8_t )23,      (uint8_t )13,      (uint8_t )5,      (uint8_t )1, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )101,      (uint8_t )78,      (uint8_t )58,      (uint8_t )42, 
        (uint8_t )26,      (uint8_t )16,      (uint8_t )8,      (uint8_t )2, 
        (uint8_t )0,      (uint8_t )3,      (uint8_t )9,      (uint8_t )17, 
        (uint8_t )27,      (uint8_t )43,      (uint8_t )59,      (uint8_t )79, 
        (uint8_t )102,      (uint8_t )86,      (uint8_t )62,      (uint8_t )46, 
        (uint8_t )32,      (uint8_t )20,      (uint8_t )10,      (uint8_t )6, 
        (uint8_t )4,      (uint8_t )7,      (uint8_t )11,      (uint8_t )21, 
        (uint8_t )33,      (uint8_t )47,      (uint8_t )63,      (uint8_t )87, 
        (uint8_t )105,      (uint8_t )90,      (uint8_t )70,      (uint8_t )52, 
        (uint8_t )37,      (uint8_t )28,      (uint8_t )18,      (uint8_t )14, 
        (uint8_t )12,      (uint8_t )15,      (uint8_t )19,      (uint8_t )29, 
        (uint8_t )38,      (uint8_t )53,      (uint8_t )71,      (uint8_t )91, 
        (uint8_t )110,      (uint8_t )99,      (uint8_t )82,      (uint8_t )66, 
        (uint8_t )48,      (uint8_t )35,      (uint8_t )30,      (uint8_t )24, 
        (uint8_t )22,      (uint8_t )25,      (uint8_t )31,      (uint8_t )36, 
        (uint8_t )49,      (uint8_t )67,      (uint8_t )83,      (uint8_t )100, 
        (uint8_t )115,      (uint8_t )108,      (uint8_t )94,      (uint8_t )76, 
        (uint8_t )64,      (uint8_t )50,      (uint8_t )44,      (uint8_t )40, 
        (uint8_t )34,      (uint8_t )41,      (uint8_t )45,      (uint8_t )51, 
        (uint8_t )65,      (uint8_t )77,      (uint8_t )95,      (uint8_t )109, 
        (uint8_t )118,      (uint8_t )113,      (uint8_t )103,      (uint8_t )92, 
        (uint8_t )80,      (uint8_t )68,      (uint8_t )60,      (uint8_t )56, 
        (uint8_t )54,      (uint8_t )57,      (uint8_t )61,      (uint8_t )69, 
        (uint8_t )81,      (uint8_t )93,      (uint8_t )104,      (uint8_t )114, 
        (uint8_t )119,      (uint8_t )116,      (uint8_t )111,      (uint8_t )106, 
        (uint8_t )97,      (uint8_t )88,      (uint8_t )84,      (uint8_t )74, 
        (uint8_t )72,      (uint8_t )75,      (uint8_t )85,      (uint8_t )89, 
        (uint8_t )98,      (uint8_t )107,      (uint8_t )112,      (uint8_t )117};
#line 55 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static int DistanceToPlaneCode(int xsize , int dist ) 
{ 
  int yoffset ;
  int xoffset ;

  {
#line 56
  yoffset = dist / xsize;
#line 57
  xoffset = dist - yoffset * xsize;
#line 58
  if (xoffset <= 8) {
#line 58
    if (yoffset < 8) {
#line 59
      return ((int )plane_to_code_lut[(yoffset * 16 + 8) - xoffset] + 1);
    } else {
#line 58
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 60
  if (xoffset > xsize - 8) {
#line 60
    if (yoffset < 7) {
#line 61
      return ((int )plane_to_code_lut[((yoffset + 1) * 16 + 8) + (xsize - xoffset)] + 1);
    }
  }
#line 63
  return (dist + 120);
}
}
#line 66 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
__inline static int FindMatchLength(uint32_t *array1 , uint32_t *array2 , int max_limit ) 
{ 
  int match_len ;

  {
#line 69
  match_len = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (match_len < max_limit && *(array1 + match_len) == *(array2 + match_len))) {
#line 70
      goto while_break;
    }
#line 71
    match_len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (match_len);
}
}
#line 79 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
void VP8LInitBackwardRefs(VP8LBackwardRefs *refs ) 
{ 


  {
#line 80
  if (refs != (void *)0) {
#line 81
    refs->refs = (PixOrCopy *)((void *)0);
#line 82
    refs->size = 0;
#line 83
    refs->max_size = 0;
  }
  return;
}
}
#line 87 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
void VP8LClearBackwardRefs(VP8LBackwardRefs *refs ) 
{ 


  {
#line 88
  if (refs != (void *)0) {
    {
#line 89
    free(refs->refs);
#line 90
    VP8LInitBackwardRefs(refs);
    }
  }
  return;
}
}
#line 94 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
int VP8LBackwardRefsAlloc(VP8LBackwardRefs *refs , int max_size ) 
{ 
  int tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 96
  refs->size = 0;
#line 97
  refs->max_size = 0;
#line 98
  __cil_tmp4 = WebPSafeMalloc((uint64_t )max_size, sizeof(*(refs->refs)));
#line 98
  refs->refs = (PixOrCopy *)__cil_tmp4;
  }
#line 100
  if (refs->refs == (void *)0) {
#line 100
    return (0);
  }
#line 101
  refs->max_size = max_size;
#line 102
  return (1);
}
}
#line 108 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
__inline static uint64_t GetPixPairHash64(uint32_t *argb ) 
{ 
  uint64_t key ;

  {
#line 109
  key = ((uint64_t )*(argb + 1) << 32) | (unsigned long )*(argb + 0);
#line 110
  key = (uint64_t )((unsigned long long )key * 0xc6a4a7935bd1e995ULL >> 46);
#line 111
  return (key);
}
}
#line 114 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static int HashChainInit(HashChain *p , int size ) 
{ 
  int i ;
  void *__cil_tmp4 ;

  {
  {
#line 116
  __cil_tmp4 = WebPSafeMalloc((uint64_t )size, sizeof(*(p->chain_)));
#line 116
  p->chain_ = (int *)__cil_tmp4;
  }
#line 117
  if (p->chain_ == (void *)0) {
#line 118
    return (0);
  }
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < size)) {
#line 120
      goto while_break;
    }
#line 121
    *(p->chain_ + i) = - 1;
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 123
    if (! (i < 1 << 18)) {
#line 123
      goto while_break___0;
    }
#line 124
    p->hash_to_first_index_[i] = - 1;
#line 123
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 126
  return (1);
}
}
#line 129 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static void HashChainDelete(HashChain *p ) 
{ 


  {
#line 130
  if (p != (void *)0) {
    {
#line 131
    free(p->chain_);
#line 132
    free(p);
    }
  }
  return;
}
}
#line 137 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static void HashChainInsert(HashChain *p , uint32_t *argb , int pos ) 
{ 
  uint64_t hash_code ;
  uint64_t __cil_tmp5 ;

  {
  {
#line 139
  __cil_tmp5 = GetPixPairHash64(argb);
#line 139
  hash_code = __cil_tmp5;
#line 140
  *(p->chain_ + pos) = p->hash_to_first_index_[hash_code];
#line 141
  p->hash_to_first_index_[hash_code] = pos;
  }
  return;
}
}
#line 144 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static void GetParamsForHashChainFindCopy(int quality , int xsize , int *window_size ,
                                          int *iter_pos , int *iter_limit ) 
{ 
  int iter_mult ;
  int tmp ;
  int max_window_size ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 147
  if (quality < 27) {
#line 147
    tmp = 1;
  } else {
#line 147
    tmp = 1 + ((quality - 27) >> 4);
  }
#line 147
  iter_mult = tmp;
#line 149
  if (quality > 50) {
#line 149
    tmp___1 = (1 << 20) - 120;
  } else {
#line 149
    if (quality > 25) {
#line 149
      tmp___0 = xsize << 8;
    } else {
#line 149
      tmp___0 = xsize << 4;
    }
#line 149
    tmp___1 = tmp___0;
  }
#line 149
  max_window_size = tmp___1;
#line 153
  if (max_window_size > (1 << 20) - 120) {
#line 153
    tmp___3 = (1 << 20) - 120;
  } else {
#line 153
    tmp___3 = max_window_size;
  }
#line 153
  *window_size = tmp___3;
#line 155
  *iter_pos = 5 + (quality >> 3);
#line 156
  *iter_limit = - quality * iter_mult;
  return;
}
}
#line 159 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static int HashChainFindCopy(HashChain *p , int base_position , int xsize , uint32_t *argb ,
                             int maxlen , int window_size , int iter_pos , int iter_limit ,
                             int *distance_ptr , int *length_ptr ) 
{ 
  uint64_t hash_code ;
  uint64_t __cil_tmp12 ;
  int prev_length ;
  int64_t best_val ;
  int best_length ;
  int best_distance ;
  uint32_t *argb_start ;
  int min_pos ;
  int tmp ;
  int pos ;
  int tmp___0 ;
  int64_t val ;
  int curr_length ;
  int __cil_tmp24 ;
  int y ;
  int x ;

  {
  {
#line 165
  __cil_tmp12 = GetPixPairHash64(argb + base_position);
#line 165
  hash_code = __cil_tmp12;
#line 166
  prev_length = 0;
#line 167
  best_val = (int64_t )0;
#line 168
  best_length = 0;
#line 169
  best_distance = 0;
#line 170
  argb_start = argb + base_position;
  }
#line 171
  if (base_position > window_size) {
#line 171
    tmp = base_position - window_size;
  } else {
#line 171
    tmp = 0;
  }
#line 171
  min_pos = tmp;
#line 176
  pos = p->hash_to_first_index_[hash_code];
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (pos >= min_pos)) {
#line 176
      goto while_break;
    }
#line 181
    if (iter_pos < 0) {
#line 182
      if (iter_pos < iter_limit) {
#line 183
        goto while_break;
      } else
#line 182
      if (best_val >= 16711680L) {
#line 183
        goto while_break;
      }
    }
#line 186
    iter_pos --;
#line 187
    if (best_length != 0) {
#line 187
      if (*(argb + ((pos + best_length) - 1)) != *(argb_start + (best_length - 1))) {
#line 189
        goto while_continue;
      }
    }
    {
#line 191
    curr_length = FindMatchLength(argb + pos, argb_start, maxlen);
    }
#line 192
    if (curr_length < prev_length) {
#line 193
      goto while_continue;
    }
#line 195
    val = (int64_t )(65536 * curr_length);
#line 197
    if (base_position - pos < 9 * xsize) {
#line 198
      y = (base_position - pos) / xsize;
#line 199
      x = (base_position - pos) % xsize;
#line 200
      if (x > xsize / 2) {
#line 201
        x = xsize - x;
      }
#line 203
      if (x <= 7) {
#line 203
        if (x >= -8) {
#line 204
          val -= (long )(y * y + x * x);
        } else {
#line 206
          val -= (long )162;
        }
      } else {
#line 206
        val -= (long )162;
      }
    } else {
#line 209
      val -= (long )162;
    }
#line 211
    if (best_val < val) {
#line 212
      prev_length = curr_length;
#line 213
      best_val = val;
#line 214
      best_length = curr_length;
#line 215
      best_distance = base_position - pos;
#line 216
      if (curr_length >= 4096) {
#line 217
        goto while_break;
      }
#line 219
      if (best_distance == 1) {
        _L: /* CIL Label */ 
#line 219
        if (best_length >= 128) {
#line 221
          goto while_break;
        }
      } else
#line 219
      if (best_distance == xsize) {
#line 219
        goto _L;
      }
    }
#line 178
    pos = *(p->chain_ + pos);
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  *distance_ptr = best_distance;
#line 226
  *length_ptr = best_length;
#line 227
  return (best_length >= 2);
}
}
#line 230 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
__inline static void PushBackCopy(VP8LBackwardRefs *refs , int length ) 
{ 
  int size ;
  int __cil_tmp4 ;
  PixOrCopy __cil_tmp5 ;
  int __cil_tmp6 ;
  PixOrCopy __cil_tmp7 ;

  {
#line 231
  size = refs->size;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! (length >= 4096)) {
#line 232
      goto while_break;
    }
    {
#line 233
    __cil_tmp4 = size;
#line 233
    size ++;
#line 233
    *(refs->refs + __cil_tmp4) = PixOrCopyCreateCopy((uint32_t )1, (uint16_t )4096);
#line 234
    length -= 4096;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  if (length > 0) {
    {
#line 237
    __cil_tmp6 = size;
#line 237
    size ++;
#line 237
    *(refs->refs + __cil_tmp6) = PixOrCopyCreateCopy((uint32_t )1, (uint16_t )length);
    }
  }
#line 239
  refs->size = size;
  return;
}
}
#line 242 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static void BackwardReferencesRle(int xsize , int ysize , uint32_t *argb , VP8LBackwardRefs *refs ) 
{ 
  int pix_count ;
  int match_len ;
  int i ;
  int __cil_tmp8 ;
  PixOrCopy __cil_tmp9 ;
  int __cil_tmp10 ;
  PixOrCopy __cil_tmp11 ;

  {
  {
#line 245
  pix_count = xsize * ysize;
#line 246
  match_len = 0;
#line 248
  refs->size = 0;
#line 249
  PushBackCopy(refs, match_len);
#line 250
  __cil_tmp8 = refs->size;
#line 250
  (refs->size) ++;
#line 250
  *(refs->refs + __cil_tmp8) = PixOrCopyCreateLiteral(*(argb + 0));
#line 251
  i = 1;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < pix_count)) {
#line 251
      goto while_break;
    }
#line 252
    if (*(argb + i) == *(argb + (i - 1))) {
#line 253
      match_len ++;
    } else {
      {
#line 255
      PushBackCopy(refs, match_len);
#line 256
      match_len = 0;
#line 257
      __cil_tmp10 = refs->size;
#line 257
      (refs->size) ++;
#line 257
      *(refs->refs + __cil_tmp10) = PixOrCopyCreateLiteral(*(argb + i));
      }
    }
#line 251
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 260
  PushBackCopy(refs, match_len);
  }
  return;
}
}
#line 263 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static int BackwardReferencesHashChain(int xsize , int ysize , uint32_t *argb , int cache_bits ,
                                       int quality , VP8LBackwardRefs *refs ) 
{ 
  int i ;
  int ok ;
  int cc_init ;
  int use_color_cache ;
  int pix_count ;
  HashChain *hash_chain ;
  void *__cil_tmp13 ;
  VP8LColorCache hashers ;
  int window_size ;
  int iter_pos ;
  int iter_limit ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int offset ;
  int len ;
  int maxlen ;
  int offset2 ;
  int len2 ;
  int k ;
  int maxlen___0 ;
  uint32_t pixel ;
  int __cil_tmp28 ;
  int ix ;
  int __cil_tmp30 ;
  PixOrCopy __cil_tmp31 ;
  PixOrCopy __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  PixOrCopy __cil_tmp35 ;
  int last ;
  int tmp ;
  uint32_t pixel___0 ;
  int __cil_tmp39 ;
  int ix___0 ;
  int __cil_tmp41 ;
  PixOrCopy __cil_tmp42 ;
  PixOrCopy __cil_tmp43 ;

  {
  {
#line 268
  ok = 0;
#line 269
  cc_init = 0;
#line 270
  use_color_cache = cache_bits > 0;
#line 271
  pix_count = xsize * ysize;
#line 272
  __cil_tmp13 = malloc(sizeof(*hash_chain));
#line 272
  hash_chain = (HashChain *)__cil_tmp13;
#line 274
  window_size = (1 << 20) - 120;
#line 275
  iter_pos = 1;
#line 276
  iter_limit = - 1;
  }
#line 278
  if (hash_chain == (void *)0) {
#line 278
    return (0);
  }
#line 279
  if (use_color_cache) {
    {
#line 280
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 281
    if (! cc_init) {
#line 281
      goto Error;
    }
  }
  {
#line 284
  __cil_tmp19 = HashChainInit(hash_chain, pix_count);
  }
#line 284
  if (! __cil_tmp19) {
#line 284
    goto Error;
  }
  {
#line 286
  refs->size = 0;
#line 287
  GetParamsForHashChainFindCopy(quality, xsize, & window_size, & iter_pos, & iter_limit);
#line 289
  i = 0;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < pix_count)) {
#line 289
      goto while_break;
    }
#line 291
    offset = 0;
#line 292
    len = 0;
#line 293
    if (i < pix_count - 1) {
#line 294
      maxlen = pix_count - i;
#line 295
      if (maxlen > 4096) {
#line 296
        maxlen = 4096;
      }
      {
#line 298
      HashChainFindCopy(hash_chain, i, xsize, argb, maxlen, window_size, iter_pos,
                        iter_limit, & offset, & len);
      }
    }
#line 302
    if (len >= 2) {
      {
#line 305
      offset2 = 0;
#line 306
      len2 = 0;
#line 308
      HashChainInsert(hash_chain, argb + i, i);
      }
#line 309
      if (i < pix_count - 2) {
#line 310
        maxlen___0 = pix_count - (i + 1);
#line 311
        if (maxlen___0 > 4096) {
#line 312
          maxlen___0 = 4096;
        }
        {
#line 314
        HashChainFindCopy(hash_chain, i + 1, xsize, argb, maxlen___0, window_size,
                          iter_pos, iter_limit, & offset2, & len2);
        }
#line 317
        if (len2 > len + 1) {
          {
#line 318
          pixel = *(argb + i);
#line 320
          __cil_tmp28 = VP8LColorCacheContains___0(& hashers, pixel);
          }
#line 320
          if (use_color_cache) {
#line 320
            if (__cil_tmp28) {
              {
#line 321
              __cil_tmp30 = VP8LColorCacheGetIndex___0(& hashers, pixel);
#line 321
              ix = __cil_tmp30;
#line 322
              *(refs->refs + refs->size) = PixOrCopyCreateCacheIdx(ix);
              }
            } else {
              {
              {
#line 324
              *(refs->refs + refs->size) = PixOrCopyCreateLiteral(pixel);
              }
              }
            }
          } else {
            {
            {
#line 324
            *(refs->refs + refs->size) = PixOrCopyCreateLiteral(pixel);
            }
            }
          }
#line 326
          (refs->size) ++;
#line 327
          if (use_color_cache) {
            {
#line 327
            VP8LColorCacheInsert___0(& hashers, pixel);
            }
          }
#line 328
          i ++;
#line 329
          len = len2;
#line 330
          offset = offset2;
        }
      }
#line 333
      if (len >= 4096) {
#line 334
        len = 4095;
      }
      {
#line 336
      __cil_tmp34 = refs->size;
#line 336
      (refs->size) ++;
#line 336
      *(refs->refs + __cil_tmp34) = PixOrCopyCreateCopy((uint32_t )offset, (uint16_t )len);
      }
#line 337
      if (use_color_cache) {
#line 338
        k = 0;
        {
#line 338
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 338
          if (! (k < len)) {
#line 338
            goto while_break___0;
          }
          {
#line 339
          VP8LColorCacheInsert___0(& hashers, *(argb + (i + k)));
          }
#line 338
          k ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 344
      if (len < (pix_count - 1) - i) {
#line 344
        tmp = len;
      } else {
#line 344
        tmp = (pix_count - 1) - i;
      }
#line 344
      last = tmp;
#line 345
      k = 1;
      {
#line 345
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 345
        if (! (k < last)) {
#line 345
          goto while_break___1;
        }
        {
#line 346
        HashChainInsert(hash_chain, argb + (i + k), i + k);
        }
#line 345
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 349
      i += len;
    } else {
      {
#line 351
      pixel___0 = *(argb + i);
#line 352
      __cil_tmp39 = VP8LColorCacheContains___0(& hashers, pixel___0);
      }
#line 352
      if (use_color_cache) {
#line 352
        if (__cil_tmp39) {
          {
#line 354
          __cil_tmp41 = VP8LColorCacheGetIndex___0(& hashers, pixel___0);
#line 354
          ix___0 = __cil_tmp41;
#line 355
          *(refs->refs + refs->size) = PixOrCopyCreateCacheIdx(ix___0);
          }
        } else {
          {
          {
#line 357
          *(refs->refs + refs->size) = PixOrCopyCreateLiteral(pixel___0);
          }
          }
        }
      } else {
        {
        {
#line 357
        *(refs->refs + refs->size) = PixOrCopyCreateLiteral(pixel___0);
        }
        }
      }
#line 359
      (refs->size) ++;
#line 360
      if (use_color_cache) {
        {
#line 360
        VP8LColorCacheInsert___0(& hashers, pixel___0);
        }
      }
#line 361
      if (i + 1 < pix_count) {
        {
#line 362
        HashChainInsert(hash_chain, argb + i, i);
        }
      }
#line 364
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  ok = 1;
  Error: 
#line 369
  if (cc_init) {
    {
#line 369
    VP8LColorCacheClear(& hashers);
    }
  }
  {
#line 370
  HashChainDelete(hash_chain);
  }
#line 371
  return (ok);
}
}
#line 384
static int BackwardReferencesTraceBackwards(int xsize , int ysize , int recursive_cost_model ,
                                            uint32_t *argb , int quality , int cache_bits ,
                                            VP8LBackwardRefs *refs ) ;
#line 389 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static void ConvertPopulationCountTableToBitEstimates(int num_symbols , int const   population_counts[] ,
                                                      double output[] ) 
{ 
  int sum ;
  int nonzeros ;
  int i ;
  double logsum ;
  float __cil_tmp8 ;
  float __cil_tmp9 ;

  {
#line 391
  sum = 0;
#line 392
  nonzeros = 0;
#line 394
  i = 0;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i < num_symbols)) {
#line 394
      goto while_break;
    }
#line 395
    sum += population_counts[i];
#line 396
    if (population_counts[i] > 0) {
#line 397
      nonzeros ++;
    }
#line 394
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  if (nonzeros <= 1) {
    {
#line 401
    memset(output, 0, (unsigned long )num_symbols * sizeof(output[0]));
    }
  } else {
    {
#line 403
    __cil_tmp8 = VP8LFastLog2(sum);
#line 403
    logsum = (double )__cil_tmp8;
#line 404
    i = 0;
    }
    {
#line 404
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 404
      if (! (i < num_symbols)) {
#line 404
        goto while_break___0;
      }
      {
#line 405
      __cil_tmp9 = VP8LFastLog2(population_counts[i]);
#line 405
      output[i] = logsum - (double )__cil_tmp9;
      }
#line 404
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 410 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static int CostModelBuild(CostModel *m , int xsize , int ysize , int recursion_level ,
                          uint32_t *argb , int quality , int cache_bits ) 
{ 
  int ok ;
  VP8LHistogram histo ;
  VP8LBackwardRefs refs ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 413
  ok = 0;
#line 417
  __cil_tmp11 = VP8LBackwardRefsAlloc(& refs, xsize * ysize);
  }
#line 417
  if (! __cil_tmp11) {
#line 417
    goto Error;
  }
#line 419
  if (recursion_level > 0) {
    {
#line 420
    __cil_tmp12 = BackwardReferencesTraceBackwards(xsize, ysize, recursion_level - 1,
                                                   argb, quality, cache_bits, & refs);
    }
#line 420
    if (! __cil_tmp12) {
#line 422
      goto Error;
    }
  } else {
    {
#line 425
    __cil_tmp13 = BackwardReferencesHashChain(xsize, ysize, argb, cache_bits, quality,
                                              & refs);
    }
#line 425
    if (! __cil_tmp13) {
#line 427
      goto Error;
    }
  }
  {
#line 430
  VP8LHistogramCreate(& histo, & refs, cache_bits);
#line 431
  __cil_tmp14 = VP8LHistogramNumCodes(& histo);
#line 431
  ConvertPopulationCountTableToBitEstimates(__cil_tmp14, (int const   [])((int *)histo.literal_),
                                            (double *)m->literal_);
#line 433
  ConvertPopulationCountTableToBitEstimates(256, (int const   [])((int *)histo.red_),
                                            (double *)m->red_);
#line 435
  ConvertPopulationCountTableToBitEstimates(256, (int const   [])((int *)histo.blue_),
                                            (double *)m->blue_);
#line 437
  ConvertPopulationCountTableToBitEstimates(256, (int const   [])((int *)histo.alpha_),
                                            (double *)m->alpha_);
#line 439
  ConvertPopulationCountTableToBitEstimates(40, (int const   [])((int *)histo.distance_),
                                            (double *)m->distance_);
#line 441
  ok = 1;
  }
  Error: 
  {
#line 444
  VP8LClearBackwardRefs(& refs);
  }
#line 445
  return (ok);
}
}
#line 448 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
__inline static double GetLiteralCost(CostModel *m , uint32_t v ) 
{ 


  {
#line 449
  return (((m->alpha_[v >> 24] + m->red_[(v >> 16) & 255U]) + m->literal_[(v >> 8) & 255U]) + m->blue_[v & 255U]);
}
}
#line 455 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
__inline static double GetCacheCost(CostModel *m , uint32_t idx ) 
{ 
  int literal_idx ;

  {
#line 456
  literal_idx = (int )(280U + idx);
#line 457
  return (m->literal_[literal_idx]);
}
}
#line 460 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
__inline static double GetLengthCost(CostModel *m , uint32_t length ) 
{ 
  int code ;
  int extra_bits_count ;
  int extra_bits_value ;

  {
  {
#line 463
  PrefixEncode((int )length, & code, & extra_bits_count, & extra_bits_value);
  }
#line 464
  return (m->literal_[256 + code] + (double )extra_bits_count);
}
}
#line 467 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
__inline static double GetDistanceCost(CostModel *m , uint32_t distance ) 
{ 
  int code ;
  int extra_bits_count ;
  int extra_bits_value ;

  {
  {
#line 470
  PrefixEncode((int )distance, & code, & extra_bits_count, & extra_bits_value);
  }
#line 471
  return (m->distance_[code] + (double )extra_bits_count);
}
}
#line 474 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static int BackwardReferencesHashChainDistanceOnly(int xsize , int ysize , int recursive_cost_model ,
                                                   uint32_t *argb , int quality ,
                                                   int cache_bits , uint32_t *dist_array ) 
{ 
  int i ;
  int ok ;
  int cc_init ;
  int pix_count ;
  int use_color_cache ;
  float *cost ;
  void *__cil_tmp14 ;
  CostModel *cost_model ;
  void *__cil_tmp16 ;
  HashChain *hash_chain ;
  void *__cil_tmp18 ;
  VP8LColorCache hashers ;
  double mul0 ;
  double tmp ;
  double mul1 ;
  double tmp___0 ;
  int min_distance_code ;
  int window_size ;
  int iter_pos ;
  int iter_limit ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  double prev_cost ;
  int shortmax ;
  int offset ;
  int len ;
  int maxlen ;
  int tmp___1 ;
  int code ;
  int __cil_tmp38 ;
  double distance_cost ;
  double __cil_tmp40 ;
  int k ;
  double cost_val ;
  double __cil_tmp43 ;
  int last ;
  int tmp___2 ;
  double cost_val___0 ;
  int __cil_tmp47 ;
  int ix ;
  int __cil_tmp49 ;
  double __cil_tmp50 ;
  double __cil_tmp51 ;

  {
  {
#line 478
  ok = 0;
#line 479
  cc_init = 0;
#line 480
  pix_count = xsize * ysize;
#line 481
  use_color_cache = cache_bits > 0;
#line 482
  __cil_tmp14 = WebPSafeMalloc((uint64_t )pix_count, sizeof(*cost));
#line 482
  cost = (float *)__cil_tmp14;
#line 484
  __cil_tmp16 = malloc(sizeof(*cost_model));
#line 484
  cost_model = (CostModel *)__cil_tmp16;
#line 485
  __cil_tmp18 = malloc(sizeof(*hash_chain));
#line 485
  hash_chain = (HashChain *)__cil_tmp18;
  }
#line 487
  if (recursive_cost_model != 0) {
#line 487
    tmp = 1.;
  } else {
#line 487
    tmp = 0.680000000001;
  }
#line 487
  mul0 = tmp;
#line 488
  if (recursive_cost_model != 0) {
#line 488
    tmp___0 = 1.;
  } else {
#line 488
    tmp___0 = 0.82;
  }
#line 488
  mul1 = tmp___0;
#line 489
  min_distance_code = 2;
#line 490
  window_size = (1 << 20) - 120;
#line 491
  iter_pos = 1;
#line 492
  iter_limit = - 1;
#line 494
  if (cost == (void *)0) {
#line 494
    goto Error;
  } else
#line 494
  if (cost_model == (void *)0) {
#line 494
    goto Error;
  } else
#line 494
  if (hash_chain == (void *)0) {
#line 494
    goto Error;
  }
  {
#line 496
  __cil_tmp28 = HashChainInit(hash_chain, pix_count);
  }
#line 496
  if (! __cil_tmp28) {
#line 496
    goto Error;
  }
#line 498
  if (use_color_cache) {
    {
#line 499
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 500
    if (! cc_init) {
#line 500
      goto Error;
    }
  }
  {
#line 503
  __cil_tmp30 = CostModelBuild(cost_model, xsize, ysize, recursive_cost_model, argb,
                               quality, cache_bits);
  }
#line 503
  if (! __cil_tmp30) {
#line 505
    goto Error;
  }
#line 508
  i = 0;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! (i < pix_count)) {
#line 508
      goto while_break;
    }
#line 508
    *(cost + i) = 9.99999968029e+37f;
#line 508
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 512
  *(dist_array + 0) = (uint32_t )0;
#line 513
  GetParamsForHashChainFindCopy(quality, xsize, & window_size, & iter_pos, & iter_limit);
#line 515
  i = 0;
  }
  {
#line 515
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 515
    if (! (i < pix_count)) {
#line 515
      goto while_break___0;
    }
#line 516
    prev_cost = 0.;
#line 518
    if (i > 0) {
#line 519
      prev_cost = (double )*(cost + (i - 1));
    }
#line 521
    shortmax = 0;
    {
#line 521
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 521
      if (! (shortmax < 2)) {
#line 521
        goto while_break___1;
      }
#line 522
      offset = 0;
#line 523
      len = 0;
#line 524
      if (i < pix_count - 1) {
#line 525
        if (shortmax) {
#line 525
          tmp___1 = 2;
        } else {
#line 525
          tmp___1 = 4096;
        }
#line 525
        maxlen = tmp___1;
#line 526
        if (maxlen > pix_count - i) {
#line 527
          maxlen = pix_count - i;
        }
        {
#line 529
        HashChainFindCopy(hash_chain, i, xsize, argb, maxlen, window_size, iter_pos,
                          iter_limit, & offset, & len);
        }
      }
#line 533
      if (len >= 2) {
        {
#line 534
        __cil_tmp38 = DistanceToPlaneCode(xsize, offset);
#line 534
        code = __cil_tmp38;
#line 535
        __cil_tmp40 = GetDistanceCost(cost_model, (uint32_t )code);
#line 535
        distance_cost = prev_cost + __cil_tmp40;
#line 538
        k = 1;
        }
        {
#line 538
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 538
          if (! (k < len)) {
#line 538
            goto while_break___2;
          }
          {
#line 539
          __cil_tmp43 = GetLengthCost(cost_model, (uint32_t )k);
#line 539
          cost_val = distance_cost + __cil_tmp43;
          }
#line 540
          if ((double )*(cost + (i + k)) > cost_val) {
#line 541
            *(cost + (i + k)) = (float )cost_val;
#line 542
            *(dist_array + (i + k)) = (uint32_t )(k + 1);
          }
#line 538
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 547
        if (len >= 128) {
#line 547
          if (code <= min_distance_code) {
#line 551
            if (use_color_cache) {
#line 552
              k = 0;
              {
#line 552
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 552
                if (! (k < len)) {
#line 552
                  goto while_break___3;
                }
                {
#line 553
                VP8LColorCacheInsert___0(& hashers, *(argb + (i + k)));
                }
#line 552
                k ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
#line 558
            if (len + i < pix_count - 1) {
#line 558
              tmp___2 = len + i;
            } else {
#line 558
              tmp___2 = pix_count - 1;
            }
#line 558
            last = tmp___2;
#line 560
            k = i;
            {
#line 560
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 560
              if (! (k < last)) {
#line 560
                goto while_break___4;
              }
              {
#line 561
              HashChainInsert(hash_chain, argb + k, k);
              }
#line 560
              k ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 565
            i += len - 1;
#line 566
            goto next_symbol;
          }
        }
      }
#line 521
      shortmax ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 570
    if (i < pix_count - 1) {
      {
#line 571
      HashChainInsert(hash_chain, argb + i, i);
      }
    }
    {
#line 575
    cost_val___0 = prev_cost;
#line 576
    __cil_tmp47 = VP8LColorCacheContains___0(& hashers, *(argb + i));
    }
#line 576
    if (use_color_cache) {
#line 576
      if (__cil_tmp47) {
        {
#line 577
        __cil_tmp49 = VP8LColorCacheGetIndex___0(& hashers, *(argb + i));
#line 577
        ix = __cil_tmp49;
#line 578
        __cil_tmp50 = GetCacheCost(cost_model, (uint32_t )ix);
        }
#line 578
        cost_val___0 += __cil_tmp50 * mul0;
      } else {
        {
        {
#line 580
        __cil_tmp51 = GetLiteralCost(cost_model, *(argb + i));
        }
        }
#line 580
        cost_val___0 += __cil_tmp51 * mul1;
      }
    } else {
      {
      {
#line 580
      __cil_tmp51 = GetLiteralCost(cost_model, *(argb + i));
      }
      }
#line 580
      cost_val___0 += __cil_tmp51 * mul1;
    }
#line 582
    if ((double )*(cost + i) > cost_val___0) {
#line 583
      *(cost + i) = (float )cost_val___0;
#line 584
      *(dist_array + i) = (uint32_t )1;
    }
#line 586
    if (use_color_cache) {
      {
#line 586
      VP8LColorCacheInsert___0(& hashers, *(argb + i));
      }
    }
    next_symbol: ;
#line 515
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 592
  ok = 1;
  Error: 
#line 594
  if (cc_init) {
    {
#line 594
    VP8LColorCacheClear(& hashers);
    }
  }
  {
#line 595
  HashChainDelete(hash_chain);
#line 596
  free(cost_model);
#line 597
  free(cost);
  }
#line 598
  return (ok);
}
}
#line 604 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static void TraceBackwards(uint32_t *dist_array , int dist_array_size , uint32_t **chosen_path ,
                           int *chosen_path_size ) 
{ 
  uint32_t *path ;
  uint32_t *cur ;
  int k ;

  {
#line 608
  path = dist_array + dist_array_size;
#line 609
  cur = (dist_array + dist_array_size) - 1;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (cur >= dist_array)) {
#line 610
      goto while_break;
    }
#line 611
    k = (int )*cur;
#line 612
    path --;
#line 613
    *path = (uint32_t )k;
#line 614
    cur -= k;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  *chosen_path = path;
#line 617
  *chosen_path_size = (int )((dist_array + dist_array_size) - path);
  return;
}
}
#line 620 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static int BackwardReferencesHashChainFollowChosenPath(int xsize , int ysize , uint32_t *argb ,
                                                       int quality , int cache_bits ,
                                                       uint32_t *chosen_path , int chosen_path_size ,
                                                       VP8LBackwardRefs *refs ) 
{ 
  int pix_count ;
  int use_color_cache ;
  int size ;
  int i ;
  int k ;
  int ix ;
  int ok ;
  int cc_init ;
  int window_size ;
  int iter_pos ;
  int iter_limit ;
  HashChain *hash_chain ;
  void *__cil_tmp21 ;
  VP8LColorCache hashers ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int offset ;
  int len ;
  int maxlen ;
  int tmp ;
  PixOrCopy __cil_tmp29 ;
  int last ;
  int tmp___0 ;
  int __cil_tmp32 ;
  int idx ;
  int __cil_tmp34 ;
  PixOrCopy __cil_tmp35 ;
  PixOrCopy __cil_tmp36 ;
  int tmp___1 ;

  {
  {
#line 625
  pix_count = xsize * ysize;
#line 626
  use_color_cache = cache_bits > 0;
#line 627
  size = 0;
#line 628
  i = 0;
#line 631
  ok = 0;
#line 632
  cc_init = 0;
#line 633
  window_size = (1 << 20) - 120;
#line 634
  iter_pos = 1;
#line 635
  iter_limit = - 1;
#line 636
  __cil_tmp21 = malloc(sizeof(*hash_chain));
#line 636
  hash_chain = (HashChain *)__cil_tmp21;
#line 639
  __cil_tmp23 = HashChainInit(hash_chain, pix_count);
  }
#line 639
  if (hash_chain == (void *)0) {
#line 640
    goto Error;
  } else
#line 639
  if (! __cil_tmp23) {
#line 640
    goto Error;
  }
#line 642
  if (use_color_cache) {
    {
#line 643
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 644
    if (! cc_init) {
#line 644
      goto Error;
    }
  }
  {
#line 647
  refs->size = 0;
#line 648
  GetParamsForHashChainFindCopy(quality, xsize, & window_size, & iter_pos, & iter_limit);
#line 650
  ix = 0;
  }
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (ix < chosen_path_size)) {
#line 650
      goto while_break;
    }
#line 651
    offset = 0;
#line 652
    len = 0;
#line 653
    maxlen = (int )*(chosen_path + ix);
#line 654
    if (maxlen != 1) {
      {
#line 655
      HashChainFindCopy(hash_chain, i, xsize, argb, maxlen, window_size, iter_pos,
                        iter_limit, & offset, & len);
#line 659
      *(refs->refs + size) = PixOrCopyCreateCopy((uint32_t )offset, (uint16_t )len);
      }
#line 660
      if (use_color_cache) {
#line 661
        k = 0;
        {
#line 661
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 661
          if (! (k < len)) {
#line 661
            goto while_break___0;
          }
          {
#line 662
          VP8LColorCacheInsert___0(& hashers, *(argb + (i + k)));
          }
#line 661
          k ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 666
      if (len < (pix_count - 1) - i) {
#line 666
        tmp___0 = len;
      } else {
#line 666
        tmp___0 = (pix_count - 1) - i;
      }
#line 666
      last = tmp___0;
#line 667
      k = 0;
      {
#line 667
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 667
        if (! (k < last)) {
#line 667
          goto while_break___1;
        }
        {
#line 668
        HashChainInsert(hash_chain, argb + (i + k), i + k);
        }
#line 667
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 671
      i += len;
    } else {
      {
#line 673
      __cil_tmp32 = VP8LColorCacheContains___0(& hashers, *(argb + i));
      }
#line 673
      if (use_color_cache) {
#line 673
        if (__cil_tmp32) {
          {
#line 675
          __cil_tmp34 = VP8LColorCacheGetIndex___0(& hashers, *(argb + i));
#line 675
          idx = __cil_tmp34;
#line 676
          *(refs->refs + size) = PixOrCopyCreateCacheIdx(idx);
          }
        } else {
          {
          {
#line 678
          *(refs->refs + size) = PixOrCopyCreateLiteral(*(argb + i));
          }
          }
        }
      } else {
        {
        {
#line 678
        *(refs->refs + size) = PixOrCopyCreateLiteral(*(argb + i));
        }
        }
      }
#line 680
      if (use_color_cache) {
        {
#line 680
        VP8LColorCacheInsert___0(& hashers, *(argb + i));
        }
      }
#line 681
      if (i + 1 < pix_count) {
        {
#line 682
        HashChainInsert(hash_chain, argb + i, i);
        }
      }
#line 684
      i ++;
    }
#line 650
    size ++;
#line 650
    ix ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 688
  refs->size = size;
#line 689
  ok = 1;
  Error: 
#line 691
  if (cc_init) {
    {
#line 691
    VP8LColorCacheClear(& hashers);
    }
  }
  {
#line 692
  HashChainDelete(hash_chain);
  }
#line 693
  return (ok);
}
}
#line 697 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static int BackwardReferencesTraceBackwards(int xsize , int ysize , int recursive_cost_model ,
                                            uint32_t *argb , int quality , int cache_bits ,
                                            VP8LBackwardRefs *refs ) 
{ 
  int ok ;
  int dist_array_size ;
  uint32_t *chosen_path ;
  int chosen_path_size ;
  uint32_t *dist_array ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 702
  ok = 0;
#line 703
  dist_array_size = xsize * ysize;
#line 704
  chosen_path = (uint32_t *)((void *)0);
#line 705
  chosen_path_size = 0;
#line 706
  __cil_tmp13 = WebPSafeMalloc((uint64_t )dist_array_size, sizeof(*dist_array));
#line 706
  dist_array = (uint32_t *)__cil_tmp13;
  }
#line 709
  if (dist_array == (void *)0) {
#line 709
    goto Error;
  }
  {
#line 711
  __cil_tmp14 = BackwardReferencesHashChainDistanceOnly(xsize, ysize, recursive_cost_model,
                                                        argb, quality, cache_bits,
                                                        dist_array);
  }
#line 711
  if (! __cil_tmp14) {
#line 714
    goto Error;
  }
  {
#line 716
  TraceBackwards(dist_array, dist_array_size, & chosen_path, & chosen_path_size);
#line 717
  __cil_tmp15 = BackwardReferencesHashChainFollowChosenPath(xsize, ysize, argb, quality,
                                                            cache_bits, chosen_path,
                                                            chosen_path_size, refs);
  }
#line 717
  if (! __cil_tmp15) {
#line 720
    goto Error;
  }
#line 722
  ok = 1;
  Error: 
  {
#line 724
  free(dist_array);
  }
#line 725
  return (ok);
}
}
#line 728 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static void BackwardReferences2DLocality(int xsize , VP8LBackwardRefs *refs ) 
{ 
  int i ;
  int __cil_tmp4 ;
  int dist ;
  int transformed_dist ;
  int __cil_tmp7 ;

  {
#line 731
  i = 0;
  {
#line 731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    if (! (i < refs->size)) {
#line 731
      goto while_break;
    }
    {
#line 732
    __cil_tmp4 = PixOrCopyIsCopy(refs->refs + i);
    }
#line 732
    if (__cil_tmp4) {
      {
#line 733
      dist = (int )(refs->refs + i)->argb_or_distance;
#line 734
      __cil_tmp7 = DistanceToPlaneCode(xsize, dist);
#line 734
      transformed_dist = __cil_tmp7;
#line 735
      (refs->refs + i)->argb_or_distance = (uint32_t )transformed_dist;
      }
    }
#line 731
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 740 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
int VP8LGetBackwardReferences(int width , int height , uint32_t *argb , int quality ,
                              int cache_bits , int use_2d_locality , VP8LBackwardRefs *best ) 
{ 
  int ok ;
  int lz77_is_useful ;
  VP8LBackwardRefs refs_rle ;
  VP8LBackwardRefs refs_lz77 ;
  int num_pix ;
  int __cil_tmp13 ;
  double bit_cost_lz77 ;
  double bit_cost_rle ;
  VP8LHistogram *histo ;
  void *__cil_tmp17 ;
  double __cil_tmp18 ;
  double __cil_tmp19 ;
  int try_lz77_trace_backwards ;
  int recursion_level ;
  int tmp ;
  VP8LBackwardRefs refs_trace ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;

  {
  {
#line 744
  ok = 0;
#line 747
  num_pix = width * height;
#line 749
  VP8LBackwardRefsAlloc(& refs_rle, num_pix);
#line 750
  VP8LBackwardRefsAlloc(& refs_lz77, num_pix);
#line 751
  VP8LInitBackwardRefs(best);
  }
#line 752
  if (refs_rle.refs == (void *)0) {
    Error1: 
    _L: /* CIL Label */ 
    {
#line 754
    VP8LClearBackwardRefs(& refs_rle);
    }
    {
#line 755
    VP8LClearBackwardRefs(& refs_lz77);
    }
#line 756
    goto End;
  } else
#line 752
  if (refs_lz77.refs == (void *)0) {
#line 752
    goto Error1;
  }
  {
#line 759
  __cil_tmp13 = BackwardReferencesHashChain(width, height, argb, cache_bits, quality,
                                            & refs_lz77);
  }
#line 759
  if (! __cil_tmp13) {
#line 761
    goto End;
  }
  {
#line 764
  BackwardReferencesRle(width, height, argb, & refs_rle);
#line 768
  __cil_tmp17 = malloc(sizeof(*histo));
#line 768
  histo = (VP8LHistogram *)__cil_tmp17;
  }
#line 769
  if (histo == (void *)0) {
#line 769
    goto Error1;
  }
  {
#line 771
  VP8LHistogramCreate(histo, & refs_lz77, cache_bits);
#line 772
  bit_cost_lz77 = VP8LHistogramEstimateBits(histo);
#line 774
  VP8LHistogramCreate(histo, & refs_rle, cache_bits);
#line 775
  bit_cost_rle = VP8LHistogramEstimateBits(histo);
#line 777
  lz77_is_useful = bit_cost_lz77 < bit_cost_rle;
#line 778
  free(histo);
  }
#line 782
  if (lz77_is_useful) {
    {
#line 784
    try_lz77_trace_backwards = quality > 10;
#line 785
    *best = refs_lz77;
#line 786
    VP8LClearBackwardRefs(& refs_rle);
    }
#line 787
    if (try_lz77_trace_backwards) {
#line 788
      if (num_pix < 64000) {
#line 788
        tmp = 1;
      } else {
#line 788
        tmp = 0;
      }
      {
#line 788
      recursion_level = tmp;
#line 790
      __cil_tmp24 = VP8LBackwardRefsAlloc(& refs_trace, num_pix);
      }
#line 790
      if (! __cil_tmp24) {
#line 791
        goto End;
      }
      {
#line 793
      __cil_tmp25 = BackwardReferencesTraceBackwards(width, height, recursion_level,
                                                     argb, quality, cache_bits, & refs_trace);
      }
#line 793
      if (__cil_tmp25) {
        {
#line 795
        VP8LClearBackwardRefs(& refs_lz77);
#line 796
        *best = refs_trace;
        }
      }
    }
  } else {
    {
#line 800
    VP8LClearBackwardRefs(& refs_lz77);
#line 801
    *best = refs_rle;
    }
  }
#line 804
  if (use_2d_locality) {
    {
#line 804
    BackwardReferences2DLocality(width, best);
    }
  }
#line 806
  ok = 1;
  End: 
#line 809
  if (! ok) {
    {
#line 810
    VP8LClearBackwardRefs(best);
    }
  }
#line 812
  return (ok);
}
}
#line 816 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
static int ComputeCacheHistogram(uint32_t *argb , int xsize , int ysize , VP8LBackwardRefs *refs ,
                                 int cache_bits , VP8LHistogram *histo ) 
{ 
  int pixel_index ;
  int i ;
  uint32_t k ;
  VP8LColorCache hashers ;
  int use_color_cache ;
  int cc_init ;
  int __cil_tmp13 ;
  PixOrCopy *v ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int ix ;
  int __cil_tmp18 ;
  PixOrCopy token ;
  PixOrCopy __cil_tmp20 ;
  uint32_t __cil_tmp21 ;
  uint32_t __cil_tmp22 ;
  int tmp ;

  {
#line 821
  pixel_index = 0;
#line 825
  use_color_cache = cache_bits > 0;
#line 826
  cc_init = 0;
#line 828
  if (use_color_cache) {
    {
#line 829
    cc_init = VP8LColorCacheInit(& hashers, cache_bits);
    }
#line 830
    if (! cc_init) {
#line 830
      return (0);
    }
  }
#line 833
  i = 0;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (! (i < refs->size)) {
#line 833
      goto while_break;
    }
    {
#line 834
    v = refs->refs + i;
#line 835
    __cil_tmp15 = PixOrCopyIsLiteral(v);
    }
#line 835
    if (__cil_tmp15) {
      {
#line 836
      __cil_tmp16 = VP8LColorCacheContains___0(& hashers, *(argb + pixel_index));
      }
#line 836
      if (use_color_cache) {
#line 836
        if (__cil_tmp16) {
          {
#line 839
          __cil_tmp18 = VP8LColorCacheGetIndex___0(& hashers, *(argb + pixel_index));
#line 839
          ix = __cil_tmp18;
#line 840
          __cil_tmp20 = PixOrCopyCreateCacheIdx(ix);
#line 840
          token = __cil_tmp20;
#line 841
          VP8LHistogramAddSinglePixOrCopy(histo, & token);
          }
        } else {
          {
          {
#line 843
          VP8LHistogramAddSinglePixOrCopy(histo, v);
          }
          }
        }
      } else {
        {
        {
#line 843
        VP8LHistogramAddSinglePixOrCopy(histo, v);
        }
        }
      }
    } else {
      {
#line 846
      VP8LHistogramAddSinglePixOrCopy(histo, v);
      }
    }
#line 848
    if (use_color_cache) {
#line 849
      k = (uint32_t )0;
      {
#line 849
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 849
        if (! (k < __cil_tmp21)) {
#line 849
          goto while_break___0;
        }
        {
#line 850
        VP8LColorCacheInsert___0(& hashers, *(argb + ((unsigned int )pixel_index + k)));
        }
#line 849
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 853
    __cil_tmp22 = PixOrCopyLength(v);
    }
#line 853
    pixel_index += __cil_tmp22;
#line 833
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 858
  if (cc_init) {
    {
#line 858
    VP8LColorCacheClear(& hashers);
    }
  }
#line 859
  return (1);
}
}
#line 863 "/doner/libwebp/libwebp-v0.3.0/src/enc/backward_references.c"
int VP8LCalculateEstimateForCacheSize(uint32_t *argb , int xsize , int ysize , int *best_cache_bits ) 
{ 
  int ok ;
  int cache_bits ;
  double lowest_entropy ;
  VP8LBackwardRefs refs ;
  static double kSmallPenaltyForLargeCache ;
  static int quality ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  double cur_entropy ;
  VP8LHistogram histo ;
  double __cil_tmp15 ;

  {
  {
#line 866
  ok = 0;
#line 868
  lowest_entropy = 1e+99;
#line 870
  kSmallPenaltyForLargeCache = 4.;
#line 871
  quality = 30;
#line 872
  __cil_tmp12 = BackwardReferencesHashChain(xsize, ysize, argb, 0, quality, & refs);
  }
  {
#line 872
  __cil_tmp11 = VP8LBackwardRefsAlloc(& refs, xsize * ysize);
  }
#line 872
  if (! __cil_tmp11) {
#line 874
    goto Error;
  } else
#line 872
  if (! __cil_tmp12) {
#line 874
    goto Error;
  }
#line 876
  cache_bits = 0;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (! (cache_bits <= 9)) {
#line 876
      goto while_break;
    }
    {
#line 879
    VP8LHistogramInit(& histo, cache_bits);
#line 880
    ComputeCacheHistogram(argb, xsize, ysize, & refs, cache_bits, & histo);
#line 881
    __cil_tmp15 = VP8LHistogramEstimateBits(& histo);
#line 881
    cur_entropy = __cil_tmp15 + kSmallPenaltyForLargeCache * (double )cache_bits;
    }
#line 883
    if (cache_bits == 0) {
#line 884
      *best_cache_bits = cache_bits;
#line 885
      lowest_entropy = cur_entropy;
    } else
#line 883
    if (cur_entropy < lowest_entropy) {
#line 884
      *best_cache_bits = cache_bits;
#line 885
      lowest_entropy = cur_entropy;
    }
#line 876
    cache_bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  ok = 1;
  Error: 
  {
#line 890
  VP8LClearBackwardRefs(& refs);
  }
#line 891
  return (ok);
}
}
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static void SmoothSegmentMap(VP8Encoder *enc ) 
{ 
  int n ;
  int x ;
  int y ;
  int w ;
  int h ;
  int majority_cnt_3_x_3_grid ;
  uint8_t *tmp ;
  void *__cil_tmp9 ;
  int tmp___12 ;
  int cnt[4] ;
  unsigned int tmp___13 ;
  VP8MBInfo *mb ;
  int majority_seg ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  VP8MBInfo *mb___0 ;

  {
  {
#line 32
  w = enc->mb_w_;
#line 33
  h = enc->mb_h_;
#line 34
  majority_cnt_3_x_3_grid = 5;
#line 35
  __cil_tmp9 = WebPSafeMalloc((uint64_t )w * (unsigned long )h, sizeof(*tmp));
#line 35
  tmp = (uint8_t *)__cil_tmp9;
  }
#line 38
  if (tmp == (void *)0) {
#line 38
    return;
  }
#line 39
  y = 1;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (y < h - 1)) {
#line 39
      goto while_break;
    }
#line 40
    x = 1;
    {
#line 40
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if (! (x < w - 1)) {
#line 40
        goto while_break___0;
      }
#line 41
      cnt[0] = 0;
#line 41
      tmp___13 = (unsigned int )1;
      {
#line 41
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 41
        if (tmp___13 >= 4) {
#line 41
          goto while_break___1;
        }
#line 41
        cnt[tmp___13] = 0;
#line 41
        tmp___13 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 42
      mb = enc->mb_info_ + (x + w * y);
#line 43
      majority_seg = (int )mb->segment_;
#line 45
      (cnt[(mb + (- w - 1))->segment_]) ++;
#line 46
      (cnt[(mb + - w)->segment_]) ++;
#line 47
      (cnt[(mb + (- w + 1))->segment_]) ++;
#line 48
      (cnt[(mb + - 1)->segment_]) ++;
#line 49
      (cnt[(mb + 1)->segment_]) ++;
#line 50
      (cnt[(mb + (w - 1))->segment_]) ++;
#line 51
      (cnt[(mb + w)->segment_]) ++;
#line 52
      (cnt[(mb + (w + 1))->segment_]) ++;
#line 53
      n = 0;
      {
#line 53
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 53
        if (! (n < 4)) {
#line 53
          goto while_break___2;
        }
#line 54
        if (cnt[n] >= majority_cnt_3_x_3_grid) {
#line 55
          majority_seg = n;
        }
#line 53
        n ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 58
      *(tmp + (x + y * w)) = (uint8_t )majority_seg;
#line 40
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 39
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  y = 1;
  {
#line 61
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 61
    if (! (y < h - 1)) {
#line 61
      goto while_break___3;
    }
#line 62
    x = 1;
    {
#line 62
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 62
      if (! (x < w - 1)) {
#line 62
        goto while_break___4;
      }
#line 63
      mb___0 = enc->mb_info_ + (x + w * y);
#line 64
      mb___0->segment_ = (unsigned int )*(tmp + (x + y * w));
#line 62
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 61
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 67
  free(tmp);
  }
  return;
}
}
#line 77 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static void SetSegmentAlphas(VP8Encoder *enc , int const   centers[4] , int mid ) 
{ 
  int nb ;
  int min ;
  int max ;
  int n ;
  int tmp ;
  int alpha ;
  int beta ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 80
  nb = enc->segment_hdr_.num_segments_;
#line 81
  min = centers[0];
#line 81
  max = centers[0];
#line 84
  if (nb > 1) {
#line 85
    n = 0;
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;
#line 85
      if (! (n < nb)) {
#line 85
        goto while_break;
      }
#line 86
      if (min > centers[n]) {
#line 86
        min = centers[n];
      }
#line 87
      if (max < centers[n]) {
#line 87
        max = centers[n];
      }
#line 85
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 90
  if (max == min) {
#line 90
    max = min + 1;
  }
#line 92
  n = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (n < nb)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    alpha = (255 * (centers[n] - mid)) / (max - min);
#line 94
    beta = (255 * (centers[n] - min)) / (max - min);
#line 95
    enc->dqm_[n].alpha_ = clip(alpha, - 127, 127);
#line 96
    enc->dqm_[n].beta_ = clip(beta, 0, 255);
    }
#line 92
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 109 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static int FinalAlphaValue(int alpha ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 110
  alpha = 255 - alpha;
#line 111
  __cil_tmp2 = clip(alpha, 0, 255);
  }
#line 111
  return (__cil_tmp2);
}
}
#line 114 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static int GetAlpha(VP8Histogram *histo ) 
{ 
  int max_value ;
  int last_non_zero ;
  int k ;
  int alpha ;
  int value ;
  int tmp ;

  {
#line 115
  max_value = 0;
#line 115
  last_non_zero = 1;
#line 118
  k = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (k <= 31)) {
#line 118
      goto while_break;
    }
#line 119
    value = histo->distribution[k];
#line 120
    if (value > 0) {
#line 121
      if (value > max_value) {
#line 121
        max_value = value;
      }
#line 122
      last_non_zero = k;
    }
#line 118
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if (max_value > 1) {
#line 128
    tmp = (510 * last_non_zero) / max_value;
  } else {
#line 128
    tmp = 0;
  }
#line 128
  alpha = tmp;
#line 129
  return (alpha);
}
}
#line 132 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static void MergeHistograms(VP8Histogram *in , VP8Histogram *out ) 
{ 
  int i ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i <= 31)) {
#line 135
      goto while_break;
    }
#line 136
    out->distribution[i] += in->distribution[i];
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 143 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static void AssignSegments(VP8Encoder *enc , int const   alphas[256] ) 
{ 
  int nb ;
  int centers[4] ;
  int weighted_average ;
  int map[256] ;
  int a ;
  int n ;
  int k ;
  int min_a ;
  int max_a ;
  int range_a ;
  int accum[4] ;
  int dist_accum[4] ;
  int __cil_tmp15 ;
  int total_weight ;
  int displaced ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int new_center ;
  int __cil_tmp22 ;
  VP8MBInfo *mb ;
  int alpha ;
  int smooth ;

  {
#line 145
  nb = enc->segment_hdr_.num_segments_;
#line 147
  weighted_average = 0;
#line 150
  min_a = 0;
#line 150
  max_a = 255;
#line 155
  n = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (n <= 255 && alphas[n] == 0)) {
#line 155
      goto while_break;
    }
#line 155
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  min_a = n;
#line 157
  n = 255;
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 157
    if (! (n > min_a && alphas[n] == 0)) {
#line 157
      goto while_break___0;
    }
#line 157
    n --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 158
  max_a = n;
#line 159
  range_a = max_a - min_a;
#line 162
  k = 0;
#line 162
  n = 1;
  {
#line 162
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 162
    if (! (n < 2 * nb)) {
#line 162
      goto while_break___1;
    }
#line 163
    __cil_tmp15 = k;
#line 163
    k ++;
#line 163
    centers[__cil_tmp15] = min_a + (n * range_a) / (2 * nb);
#line 162
    n += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 166
  k = 0;
  {
#line 166
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 166
    if (! (k < 6)) {
#line 166
      goto while_break___2;
    }
#line 170
    n = 0;
    {
#line 170
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 170
      if (! (n < nb)) {
#line 170
        goto while_break___3;
      }
#line 171
      accum[n] = 0;
#line 172
      dist_accum[n] = 0;
#line 170
      n ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 175
    n = 0;
#line 176
    a = min_a;
    {
#line 176
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 176
      if (! (a <= max_a)) {
#line 176
        goto while_break___4;
      }
#line 177
      if (alphas[a]) {
        {
#line 178
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 178
          __cil_tmp19 = abs(a - centers[n]);
          }
          {
#line 178
          __cil_tmp18 = abs(a - centers[n + 1]);
          }
#line 178
          if (! (n < nb - 1 && __cil_tmp18 < __cil_tmp19)) {
#line 178
            goto while_break___5;
          }
#line 179
          n ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 181
        map[a] = n;
#line 183
        dist_accum[n] += a * alphas[a];
#line 184
        accum[n] += alphas[a];
      }
#line 176
      a ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 189
    displaced = 0;
#line 190
    weighted_average = 0;
#line 191
    total_weight = 0;
#line 192
    n = 0;
    {
#line 192
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 192
      if (! (n < nb)) {
#line 192
        goto while_break___6;
      }
#line 193
      if (accum[n]) {
        {
#line 194
        new_center = (dist_accum[n] + accum[n] / 2) / accum[n];
#line 195
        __cil_tmp22 = abs(centers[n] - new_center);
        }
#line 195
        displaced += __cil_tmp22;
#line 196
        centers[n] = new_center;
#line 197
        weighted_average += new_center * accum[n];
#line 198
        total_weight += accum[n];
      }
#line 192
      n ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 201
    weighted_average = (weighted_average + total_weight / 2) / total_weight;
#line 202
    if (displaced < 5) {
#line 202
      goto while_break___2;
    }
#line 166
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 206
  n = 0;
  {
#line 206
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 206
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 206
      goto while_break___7;
    }
#line 207
    mb = enc->mb_info_ + n;
#line 208
    alpha = (int )mb->alpha_;
#line 209
    mb->segment_ = (unsigned int )map[alpha];
#line 210
    mb->alpha_ = (uint8_t )centers[map[alpha]];
#line 206
    n ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 213
  if (nb > 1) {
#line 214
    smooth = (enc->config_)->preprocessing & 1;
#line 215
    if (smooth) {
      {
#line 215
      SmoothSegmentMap(enc);
      }
    }
  }
  {
#line 218
  SetSegmentAlphas(enc, (int const   [4])((int *)centers), weighted_average);
  }
  return;
}
}
#line 234 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static int MBAnalyzeBestIntra16Mode(VP8EncIterator *it ) 
{ 
  int max_mode ;
  int tmp ;
  int mode ;
  int best_alpha ;
  int best_mode ;
  VP8Histogram histo ;
  unsigned int tmp___0 ;
  int alpha ;
  int __cil_tmp10 ;

  {
#line 235
  if ((it->enc_)->method_ >= 4) {
#line 235
    tmp = 2;
  } else {
#line 235
    tmp = 4;
  }
  {
#line 235
  max_mode = tmp;
#line 239
  best_alpha = - 1;
#line 240
  best_mode = 0;
#line 242
  VP8MakeLuma16Preds(it);
#line 243
  mode = 0;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (mode < max_mode)) {
#line 243
      goto while_break;
    }
#line 244
    histo.distribution[0] = 0;
#line 244
    tmp___0 = (unsigned int )1;
    {
#line 244
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 244
      if (tmp___0 >= 32) {
#line 244
        goto while_break___0;
      }
#line 244
      histo.distribution[tmp___0] = 0;
#line 244
      tmp___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 247
    (*VP8CollectHistogram)(it->yuv_in_ + 0, it->yuv_p_ + VP8I16ModeOffsets[mode],
                           0, 16, & histo);
#line 250
    alpha = GetAlpha(& histo);
    }
#line 251
    if (alpha > best_alpha) {
#line 252
      best_alpha = alpha;
#line 253
      best_mode = mode;
    }
#line 243
    mode ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  VP8SetIntra16Mode(it, best_mode);
  }
#line 257
  return (best_alpha);
}
}
#line 260 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static int MBAnalyzeBestIntra4Mode(VP8EncIterator *it , int best_alpha ) 
{ 
  uint8_t modes[16] ;
  int max_mode ;
  int tmp ;
  int i4_alpha ;
  VP8Histogram total_histo ;
  unsigned int tmp___0 ;
  int cur_histo ;
  int __cil_tmp10 ;
  int mode ;
  int best_mode_alpha ;
  VP8Histogram histos[2] ;
  uint8_t *src ;
  int alpha ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 263
  if ((it->enc_)->method_ >= 4) {
#line 263
    tmp = 2;
  } else {
#line 263
    tmp = 10;
  }
#line 263
  max_mode = tmp;
#line 267
  total_histo.distribution[0] = 0;
#line 267
  tmp___0 = (unsigned int )1;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (tmp___0 >= 32) {
#line 267
      goto while_break;
    }
#line 267
    total_histo.distribution[tmp___0] = 0;
#line 267
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  cur_histo = 0;
#line 270
  VP8IteratorStartI4(it);
  }
  {
#line 271
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 273
    best_mode_alpha = - 1;
#line 275
    src = (it->yuv_in_ + 0) + VP8Scan[it->i4_];
#line 277
    VP8MakeIntra4Preds(it);
#line 278
    mode = 0;
    }
    {
#line 278
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 278
      if (! (mode < max_mode)) {
#line 278
        goto while_break___1;
      }
      {
#line 281
      memset(& histos[cur_histo], 0, sizeof(histos[cur_histo]));
#line 282
      (*VP8CollectHistogram)(src, it->yuv_p_ + VP8I4ModeOffsets[mode], 0, 1, & histos[cur_histo]);
#line 284
      alpha = GetAlpha(& histos[cur_histo]);
      }
#line 285
      if (alpha > best_mode_alpha) {
#line 286
        best_mode_alpha = alpha;
#line 287
        modes[it->i4_] = (uint8_t )mode;
#line 288
        cur_histo ^= 1;
      }
#line 278
      mode ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 292
    MergeHistograms(& histos[cur_histo ^ 1], & total_histo);
    }
#line 271
    if (! __cil_tmp10) {
#line 271
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 296
  i4_alpha = GetAlpha(& total_histo);
  }
#line 297
  if (i4_alpha > best_alpha) {
    {
#line 298
    VP8SetIntra4Mode(it, (uint8_t *)modes);
#line 299
    best_alpha = i4_alpha;
    }
  }
#line 301
  return (best_alpha);
}
}
#line 304 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static int MBAnalyzeBestUVMode(VP8EncIterator *it ) 
{ 
  int best_alpha ;
  int best_mode ;
  int max_mode ;
  int tmp ;
  int mode ;
  VP8Histogram histo ;
  unsigned int tmp___0 ;
  int alpha ;
  int __cil_tmp10 ;

  {
#line 305
  best_alpha = - 1;
#line 306
  best_mode = 0;
#line 307
  if ((it->enc_)->method_ >= 4) {
#line 307
    tmp = 2;
  } else {
#line 307
    tmp = 4;
  }
  {
#line 307
  max_mode = tmp;
#line 311
  VP8MakeChroma8Preds(it);
#line 312
  mode = 0;
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! (mode < max_mode)) {
#line 312
      goto while_break;
    }
#line 313
    histo.distribution[0] = 0;
#line 313
    tmp___0 = (unsigned int )1;
    {
#line 313
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 313
      if (tmp___0 >= 32) {
#line 313
        goto while_break___0;
      }
#line 313
      histo.distribution[tmp___0] = 0;
#line 313
      tmp___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 315
    (*VP8CollectHistogram)(it->yuv_in_ + 256, it->yuv_p_ + VP8UVModeOffsets[mode],
                           16, 24, & histo);
#line 318
    alpha = GetAlpha(& histo);
    }
#line 319
    if (alpha > best_alpha) {
#line 320
      best_alpha = alpha;
#line 321
      best_mode = mode;
    }
#line 312
    mode ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  VP8SetIntraUVMode(it, best_mode);
  }
#line 325
  return (best_alpha);
}
}
#line 328 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static void MBAnalyze(VP8EncIterator *it , int alphas[256] , int *alpha , int *uv_alpha ) 
{ 
  VP8Encoder *enc ;
  int best_alpha ;
  int best_uv_alpha ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 331
  enc = it->enc_;
#line 334
  VP8SetIntra16Mode(it, 0);
#line 335
  VP8SetSkip(it, 0);
#line 336
  VP8SetSegment(it, 0);
#line 338
  best_alpha = MBAnalyzeBestIntra16Mode(it);
  }
#line 339
  if (enc->method_ >= 5) {
    {
#line 344
    best_alpha = MBAnalyzeBestIntra4Mode(it, best_alpha);
    }
  }
  {
#line 346
  best_uv_alpha = MBAnalyzeBestUVMode(it);
#line 349
  best_alpha = ((3 * best_alpha + best_uv_alpha) + 2) >> 2;
#line 350
  best_alpha = FinalAlphaValue(best_alpha);
#line 351
  (alphas[best_alpha]) ++;
#line 352
  (it->mb_)->alpha_ = (uint8_t )best_alpha;
#line 355
  *alpha += best_alpha;
#line 356
  *uv_alpha += best_uv_alpha;
  }
  return;
}
}
#line 359 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static void DefaultMBInfo(VP8MBInfo *mb ) 
{ 


  {
#line 360
  mb->type_ = (unsigned int )1;
#line 361
  mb->uv_mode_ = (unsigned int )0;
#line 362
  mb->skip_ = (unsigned int )0;
#line 363
  mb->segment_ = (unsigned int )0;
#line 364
  mb->alpha_ = (uint8_t )0;
  return;
}
}
#line 377 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
static void ResetAllMBInfo(VP8Encoder *enc ) 
{ 
  int n ;

  {
#line 379
  n = 0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (n < enc->mb_w_ * enc->mb_h_)) {
#line 379
      goto while_break;
    }
    {
#line 380
    DefaultMBInfo(enc->mb_info_ + n);
    }
#line 379
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  enc->dqm_[0].alpha_ = 0;
#line 384
  enc->dqm_[0].beta_ = 0;
#line 386
  WebPReportProgress(enc->pic_, enc->percent_ + 20, & enc->percent_);
  }
  return;
}
}
#line 389 "/doner/libwebp/libwebp-v0.3.0/src/enc/analysis.c"
int VP8EncAnalyze(VP8Encoder *enc ) 
{ 
  int ok ;
  int do_segments ;
  int alphas[256] ;
  unsigned int tmp ;
  VP8EncIterator it ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 390
  ok = 1;
#line 391
  do_segments = ((enc->config_)->emulate_jpeg_size || enc->segment_hdr_.num_segments_ > 1) || enc->method_ == 0;
#line 395
  enc->alpha_ = 0;
#line 396
  enc->uv_alpha_ = 0;
#line 397
  if (do_segments) {
#line 398
    alphas[0] = 0;
#line 398
    tmp = (unsigned int )1;
    {
#line 398
    while (1) {
      while_continue: /* CIL Label */ ;
#line 398
      if (tmp >= 256) {
#line 398
        goto while_break;
      }
#line 398
      alphas[tmp] = 0;
#line 398
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 401
    VP8IteratorInit(enc, & it);
    }
    {
#line 402
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 403
      VP8IteratorImport(& it);
#line 404
      MBAnalyze(& it, (int *)alphas, & enc->alpha_, & enc->uv_alpha_);
#line 405
      ok = VP8IteratorProgress(& it, 20);
      }
#line 402
      if (! (ok && __cil_tmp7)) {
#line 402
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 408
    enc->alpha_ /= enc->mb_w_ * enc->mb_h_;
#line 409
    enc->uv_alpha_ /= enc->mb_w_ * enc->mb_h_;
#line 410
    if (ok) {
      {
#line 410
      AssignSegments(enc, (int const   [256])((int *)alphas));
      }
    }
  } else {
    {
#line 412
    ResetAllMBInfo(enc);
    }
  }
#line 414
  return (ok);
}
}
#line 49 "/doner/libwebp/libwebp-v0.3.0/src/enc/alpha.c"
static int EncodeLossless(uint8_t *data , int width , int height , int effort_level ,
                          VP8BitWriter *bw , WebPAuxStats *stats ) 
{ 
  int ok ;
  WebPConfig config ;
  WebPPicture picture ;
  VP8LBitWriter tmp_bw ;
  int __cil_tmp11 ;
  int i ;
  int j ;
  uint32_t *dst ;
  uint8_t *src ;
  int tmp ;
  int __cil_tmp17 ;
  enum WebPEncodingError __cil_tmp18 ;
  uint8_t *buffer ;
  uint8_t *__cil_tmp20 ;
  size_t buffer_size ;
  size_t __cil_tmp22 ;

  {
  {
#line 53
  ok = 0;
#line 58
  WebPPictureInit(& picture);
#line 59
  picture.width = width;
#line 60
  picture.height = height;
#line 61
  picture.use_argb = 1;
#line 62
  picture.stats = stats;
#line 63
  __cil_tmp11 = WebPPictureAlloc(& picture);
  }
#line 63
  if (! __cil_tmp11) {
#line 63
    return (0);
  }
#line 68
  dst = picture.argb;
#line 69
  src = data;
#line 70
  j = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (j < picture.height)) {
#line 70
      goto while_break;
    }
#line 71
    i = 0;
    {
#line 71
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 71
      if (! (i < picture.width)) {
#line 71
        goto while_break___0;
      }
#line 72
      *(dst + i) = (unsigned int )((int )*(src + i) << 8) | 4278190080U;
#line 71
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 74
    src += width;
#line 75
    dst += picture.argb_stride;
#line 70
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  WebPConfigInit___0(& config);
#line 80
  config.lossless = 1;
#line 81
  config.method = effort_level;
#line 83
  config.quality = 5.f * (float )effort_level;
#line 86
  ok = VP8LBitWriterInit(& tmp_bw, (size_t )(width * height >> 3));
#line 87
  __cil_tmp18 = (enum WebPEncodingError )VP8LEncodeStream(& config, & picture, & tmp_bw);
#line 87
  ok = ok && (unsigned int )__cil_tmp18 == 0U;
#line 88
  WebPPictureFree(& picture);
  }
#line 89
  if (ok) {
    {
#line 90
    __cil_tmp20 = VP8LBitWriterFinish(& tmp_bw);
#line 90
    buffer = __cil_tmp20;
#line 91
    __cil_tmp22 = VP8LBitWriterNumBytes(& tmp_bw);
#line 91
    buffer_size = __cil_tmp22;
#line 92
    VP8BitWriterAppend(bw, buffer, buffer_size);
    }
  }
  {
#line 94
  VP8LBitWriterDestroy(& tmp_bw);
  }
#line 95
  return (ok && ! bw->error_);
}
}
#line 100 "/doner/libwebp/libwebp-v0.3.0/src/enc/alpha.c"
static int EncodeAlphaInternal(uint8_t *data , int width , int height , int method ,
                               int filter , int reduce_levels , int effort_level ,
                               uint8_t *tmp_alpha , VP8BitWriter *bw , WebPAuxStats *stats ) 
{ 
  int ok ;
  uint8_t *alpha_src ;
  WebPFilterFunc filter_func ;
  uint8_t header ;
  size_t expected_size ;
  size_t data_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 106
  ok = 0;
#line 111
  data_size = (size_t )(width * height);
#line 120
  if (method == 0) {
#line 120
    tmp___4 = 1UL + data_size;
  } else {
#line 120
    tmp___4 = data_size >> 5;
  }
#line 120
  expected_size = tmp___4;
#line 123
  header = (uint8_t )(method | (filter << 2));
#line 124
  if (reduce_levels) {
#line 124
    header |= 1 << 4;
  }
  {
#line 126
  VP8BitWriterInit(bw, expected_size);
#line 127
  VP8BitWriterAppend(bw, & header, (size_t )1);
#line 129
  filter_func = WebPFilters[filter];
  }
#line 130
  if (filter_func != (void *)0) {
    {
#line 131
    (*filter_func)(data, width, height, width, tmp_alpha);
#line 132
    alpha_src = tmp_alpha;
    }
  } else {
#line 134
    alpha_src = data;
  }
#line 137
  if (method == 0) {
    {
#line 138
    ok = VP8BitWriterAppend(bw, alpha_src, (size_t )(width * height));
#line 139
    ok = ok && ! bw->error_;
    }
  } else {
    {
#line 141
    ok = EncodeLossless(alpha_src, width, height, effort_level, bw, stats);
#line 142
    VP8BitWriterFinish(bw);
    }
  }
#line 144
  return (ok);
}
}
#line 150 "/doner/libwebp/libwebp-v0.3.0/src/enc/alpha.c"
static void CopyPlane___0(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                          int width , int height ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    __cil_tmp7 = height;
#line 152
    height --;
#line 152
    if (! (__cil_tmp7 > 0)) {
#line 152
      goto while_break;
    }
    {
#line 153
    memcpy(dst, src, (unsigned long )width);
#line 154
    src += src_stride;
#line 155
    dst += dst_stride;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 159 "/doner/libwebp/libwebp-v0.3.0/src/enc/alpha.c"
static int EncodeAlpha(VP8Encoder *enc , int quality , int method , int filter , int effort_level ,
                       uint8_t **output , size_t *output_size ) 
{ 
  WebPPicture *pic ;
  int width ;
  int height ;
  uint8_t *quant_alpha ;
  size_t data_size ;
  uint64_t sse ;
  int ok ;
  int reduce_levels ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp22 ;
  int alpha_levels ;
  int tmp___5 ;
  int __cil_tmp25 ;
  VP8BitWriter bw ;
  int test_filter ;
  uint8_t *filtered_alpha ;
  int __cil_tmp29 ;
  WEBP_FILTER_TYPE __cil_tmp30 ;
  void *__cil_tmp31 ;
  WebPAuxStats best_stats ;
  size_t best_score ;
  size_t __cil_tmp34 ;
  VP8BitWriter tmp_bw ;
  int __cil_tmp36 ;
  size_t score ;
  size_t __cil_tmp38 ;
  VP8BitWriter tmp___6 ;
  size_t __cil_tmp40 ;
  uint8_t *__cil_tmp41 ;

  {
#line 163
  pic = enc->pic_;
#line 164
  width = pic->width;
#line 165
  height = pic->height;
#line 167
  quant_alpha = (uint8_t *)((void *)0);
#line 168
  data_size = (size_t )(width * height);
#line 169
  sse = (uint64_t )0;
#line 170
  ok = 1;
#line 171
  reduce_levels = quality < 100;
#line 181
  if (quality < 0) {
#line 182
    return (0);
  } else
#line 181
  if (quality > 100) {
#line 182
    return (0);
  }
#line 185
  if (method < 0) {
#line 186
    return (0);
  } else
#line 185
  if (method > 1) {
#line 186
    return (0);
  }
  {
#line 189
  __cil_tmp22 = malloc(data_size);
#line 189
  quant_alpha = (uint8_t *)__cil_tmp22;
  }
#line 190
  if (quant_alpha == (void *)0) {
#line 191
    return (0);
  }
  {
#line 195
  CopyPlane___0(pic->a, pic->a_stride, quant_alpha, width, width, height);
  }
#line 197
  if (reduce_levels) {
#line 201
    if (quality <= 70) {
#line 201
      tmp___5 = 2 + quality / 5;
    } else {
#line 201
      tmp___5 = 16 + (quality - 70) * 8;
    }
    {
#line 201
    alpha_levels = tmp___5;
#line 203
    ok = QuantizeLevels(quant_alpha, width, height, alpha_levels, & sse);
    }
  }
#line 206
  if (ok) {
    {
#line 209
    filtered_alpha = (uint8_t *)((void *)0);
#line 212
    ok = EncodeAlphaInternal(quant_alpha, width, height, method, 0, reduce_levels,
                             effort_level, (uint8_t *)((void *)0), & bw, pic->stats);
    }
#line 215
    if (! ok) {
      {
#line 216
      VP8BitWriterWipeOut(& bw);
      }
#line 217
      goto End;
    }
#line 220
    if (filter == 6) {
      {
#line 221
      __cil_tmp30 = EstimateBestFilter(quant_alpha, width, height, width);
#line 221
      filter = (int )__cil_tmp30;
      }
    }
#line 224
    if (filter == 0) {
#line 225
      goto Ok;
    }
    {
#line 228
    __cil_tmp31 = malloc(data_size);
#line 228
    filtered_alpha = (uint8_t *)__cil_tmp31;
#line 229
    ok = filtered_alpha != (void *)0;
    }
#line 230
    if (! ok) {
#line 231
      goto End;
    }
    {
#line 237
    __cil_tmp34 = VP8BitWriterSize(& bw);
#line 237
    best_score = __cil_tmp34;
#line 239
    memset(& best_stats, 0, sizeof(best_stats));
    }
#line 240
    if (pic->stats != (void *)0) {
#line 240
      best_stats = *(pic->stats);
    }
#line 241
    test_filter = 1;
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 241
      if (! (ok && test_filter <= 3)) {
#line 241
        goto while_break;
      }
#line 245
      if (filter != 5) {
#line 245
        if (test_filter != filter) {
#line 246
          goto while_continue;
        }
      }
      {
#line 248
      ok = EncodeAlphaInternal(quant_alpha, width, height, method, test_filter, reduce_levels,
                               effort_level, filtered_alpha, & tmp_bw, pic->stats);
      }
#line 252
      if (ok) {
        {
#line 253
        __cil_tmp38 = VP8BitWriterSize(& tmp_bw);
#line 253
        score = __cil_tmp38;
        }
#line 254
        if (score < best_score) {
#line 256
          tmp___6 = tmp_bw;
#line 257
          tmp_bw = bw;
#line 258
          bw = tmp___6;
#line 259
          best_score = score;
#line 260
          if (pic->stats != (void *)0) {
#line 260
            best_stats = *(pic->stats);
          }
        }
      } else {
        {
#line 263
        VP8BitWriterWipeOut(& bw);
        }
      }
      {
#line 265
      VP8BitWriterWipeOut(& tmp_bw);
      }
#line 243
      test_filter ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 267
    if (pic->stats != (void *)0) {
#line 267
      *(pic->stats) = best_stats;
    }
    Ok: 
#line 270
    if (ok) {
      {
#line 271
      *output_size = VP8BitWriterSize(& bw);
#line 272
      *output = VP8BitWriterBuf(& bw);
      }
#line 273
      if (pic->stats != (void *)0) {
#line 274
        (pic->stats)->coded_size += (int )*output_size;
#line 275
        enc->sse_[3] = sse;
      }
    }
    {
#line 278
    free(filtered_alpha);
    }
  }
  End: 
  {
#line 281
  free(quant_alpha);
  }
#line 282
  return (ok);
}
}
#line 289 "/doner/libwebp/libwebp-v0.3.0/src/enc/alpha.c"
static int CompressAlphaJob(VP8Encoder *enc , void *dummy ) 
{ 
  WebPConfig *config ;
  uint8_t *alpha_data ;
  size_t alpha_size ;
  int effort_level ;
  WEBP_FILTER_TYPE filter ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp10 ;

  {
#line 290
  config = enc->config_;
#line 291
  alpha_data = (uint8_t *)((void *)0);
#line 292
  alpha_size = (size_t )0;
#line 293
  effort_level = config->method;
#line 294
  if (config->alpha_filtering == 0) {
#line 294
    tmp___0 = 0;
  } else {
#line 294
    if (config->alpha_filtering == 1) {
#line 294
      tmp = 6;
    } else {
#line 294
      tmp = 5;
    }
#line 294
    tmp___0 = tmp;
  }
  {
#line 294
  filter = (WEBP_FILTER_TYPE )tmp___0;
#line 298
  __cil_tmp10 = EncodeAlpha(enc, config->alpha_quality, config->alpha_compression,
                            (int )filter, effort_level, & alpha_data, & alpha_size);
  }
#line 298
  if (! __cil_tmp10) {
#line 300
    return (0);
  }
#line 302
  if (alpha_size != (unsigned long )((uint32_t )alpha_size)) {
    {
#line 303
    free(alpha_data);
    }
#line 304
    return (0);
  }
#line 306
  enc->alpha_data_size_ = (uint32_t )alpha_size;
#line 307
  enc->alpha_data_ = alpha_data;
#line 309
  return (1);
}
}
#line 312 "/doner/libwebp/libwebp-v0.3.0/src/enc/alpha.c"
void VP8EncInitAlpha(VP8Encoder *enc ) 
{ 
  int __cil_tmp2 ;
  WebPWorker *worker ;

  {
  {
#line 313
  enc->has_alpha_ = WebPPictureHasTransparency(enc->pic_);
#line 314
  enc->alpha_data_ = (uint8_t *)((void *)0);
#line 315
  enc->alpha_data_size_ = (uint32_t )0;
  }
#line 316
  if (enc->thread_level_ > 0) {
    {
#line 317
    worker = & enc->alpha_worker_;
#line 318
    WebPWorkerInit(worker);
#line 319
    worker->data1 = enc;
#line 320
    worker->data2 = (void *)0;
#line 321
    worker->hook = (WebPWorkerHook )(& CompressAlphaJob);
    }
  }
  return;
}
}
#line 325 "/doner/libwebp/libwebp-v0.3.0/src/enc/alpha.c"
int VP8EncStartAlpha(VP8Encoder *enc ) 
{ 
  WebPWorker *worker ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 326
  if (enc->has_alpha_) {
#line 327
    if (enc->thread_level_ > 0) {
      {
#line 328
      worker = & enc->alpha_worker_;
#line 329
      __cil_tmp3 = WebPWorkerReset(worker);
      }
#line 329
      if (! __cil_tmp3) {
#line 330
        return (0);
      }
      {
#line 332
      WebPWorkerLaunch(worker);
      }
#line 333
      return (1);
    } else {
      {
#line 335
      __cil_tmp4 = CompressAlphaJob(enc, (void *)0);
      }
#line 335
      return (__cil_tmp4);
    }
  }
#line 338
  return (1);
}
}
#line 341 "/doner/libwebp/libwebp-v0.3.0/src/enc/alpha.c"
int VP8EncFinishAlpha(VP8Encoder *enc ) 
{ 
  WebPWorker *worker ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 342
  if (enc->has_alpha_) {
#line 343
    if (enc->thread_level_ > 0) {
      {
#line 344
      worker = & enc->alpha_worker_;
#line 345
      __cil_tmp3 = WebPWorkerSync(worker);
      }
#line 345
      if (! __cil_tmp3) {
#line 345
        return (0);
      }
    }
  }
  {
#line 348
  __cil_tmp4 = WebPReportProgress(enc->pic_, enc->percent_ + 20, & enc->percent_);
  }
#line 348
  return (__cil_tmp4);
}
}
#line 351 "/doner/libwebp/libwebp-v0.3.0/src/enc/alpha.c"
int VP8EncDeleteAlpha(VP8Encoder *enc ) 
{ 
  int ok ;
  WebPWorker *worker ;
  int __cil_tmp4 ;

  {
#line 352
  ok = 1;
#line 353
  if (enc->thread_level_ > 0) {
    {
#line 354
    worker = & enc->alpha_worker_;
#line 355
    ok = WebPWorkerSync(worker);
#line 356
    WebPWorkerEnd(worker);
    }
  }
  {
#line 358
  free(enc->alpha_data_);
#line 359
  enc->alpha_data_ = (uint8_t *)((void *)0);
#line 360
  enc->alpha_data_size_ = (uint32_t )0;
#line 361
  enc->has_alpha_ = 0;
  }
#line 362
  return (ok);
}
}
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/dsp/yuv.c"
static int done  =    0;
#line 27 "/doner/libwebp/libwebp-v0.3.0/src/dsp/yuv.c"
__inline static uint8_t clip___1(int v , int max_value ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 28
  if (v < 0) {
#line 28
    tmp___0 = 0;
  } else {
#line 28
    if (v > max_value) {
#line 28
      tmp = max_value;
    } else {
#line 28
      tmp = v;
    }
#line 28
    tmp___0 = tmp;
  }
#line 28
  return ((uint8_t )tmp___0);
}
}
#line 31 "/doner/libwebp/libwebp-v0.3.0/src/dsp/yuv.c"
void VP8YUVInit(void) 
{ 
  int i ;
  int k ;
  uint8_t __cil_tmp3 ;
  uint8_t __cil_tmp4 ;

  {
#line 33
  if (done) {
#line 34
    return;
  }
#line 37
  i = 0;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < 256)) {
#line 37
      goto while_break;
    }
#line 38
    VP8kVToR[i] = (int16_t )((89858 * (i - 128) + 32768) >> 16);
#line 39
    VP8kUToG[i] = -22014 * (i - 128) + 32768;
#line 40
    VP8kVToG[i] = -45773 * (i - 128);
#line 41
    VP8kUToB[i] = (int16_t )((113618 * (i - 128) + 32768) >> 16);
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  i = -227;
  {
#line 43
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 43
    if (! (i < 482)) {
#line 43
      goto while_break___0;
    }
    {
#line 44
    k = ((i - 16) * 76283 + 32768) >> 16;
#line 45
    VP8kClip[i - -227] = clip___1(k, 255);
#line 46
    VP8kClip4Bits[i - -227] = clip___1((k + 8) >> 4, 15);
    }
#line 43
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 62
  done = 1;
  return;
}
}
#line 274 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling_neon.c"
void WebPInitUpsamplersNEON(void) 
{ 


  {
  return;
}
}
#line 283 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling_neon.c"
void WebPInitPremultiplyNEON(void) 
{ 


  {
  return;
}
}
#line 95 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void UpsampleRgbLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 95
  last_pixel_pair = (len - 1) >> 1;
#line 95
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 95
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 95
  if (top_y) {
    {
#line 95
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 95
    VP8YuvToRgb(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 95
  if (bottom_y) {
    {
#line 95
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 95
    VP8YuvToRgb(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                bottom_dst);
    }
  }
#line 95
  x = 1;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (x <= last_pixel_pair)) {
#line 95
      goto while_break;
    }
#line 95
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 95
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 95
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 95
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 95
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 95
    if (top_y) {
      {
#line 95
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 95
      uv1 = (diag_03 + t_uv) >> 1;
#line 95
      VP8YuvToRgb(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                  top_dst + (2 * x - 1) * 3);
#line 95
      VP8YuvToRgb(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                  top_dst + (2 * x) * 3);
      }
    }
#line 95
    if (bottom_y) {
      {
#line 95
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 95
      uv1___0 = (diag_12 + uv) >> 1;
#line 95
      VP8YuvToRgb(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                  bottom_dst + (2 * x - 1) * 3);
#line 95
      VP8YuvToRgb(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                  bottom_dst + (2 * x) * 3);
      }
    }
#line 95
    tl_uv = t_uv;
#line 95
    l_uv = uv;
#line 95
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if (! (len & 1)) {
#line 95
    if (top_y) {
      {
#line 95
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 95
      VP8YuvToRgb(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                  top_dst + (len - 1) * 3);
      }
    }
#line 95
    if (bottom_y) {
      {
#line 95
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 95
      VP8YuvToRgb(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                  bottom_dst + (len - 1) * 3);
      }
    }
  }
  return;
}
}
#line 96 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void UpsampleBgrLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 96
  last_pixel_pair = (len - 1) >> 1;
#line 96
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 96
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 96
  if (top_y) {
    {
#line 96
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 96
    VP8YuvToBgr(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 96
  if (bottom_y) {
    {
#line 96
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 96
    VP8YuvToBgr(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                bottom_dst);
    }
  }
#line 96
  x = 1;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! (x <= last_pixel_pair)) {
#line 96
      goto while_break;
    }
#line 96
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 96
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 96
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 96
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 96
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 96
    if (top_y) {
      {
#line 96
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 96
      uv1 = (diag_03 + t_uv) >> 1;
#line 96
      VP8YuvToBgr(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                  top_dst + (2 * x - 1) * 3);
#line 96
      VP8YuvToBgr(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                  top_dst + (2 * x) * 3);
      }
    }
#line 96
    if (bottom_y) {
      {
#line 96
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 96
      uv1___0 = (diag_12 + uv) >> 1;
#line 96
      VP8YuvToBgr(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                  bottom_dst + (2 * x - 1) * 3);
#line 96
      VP8YuvToBgr(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                  bottom_dst + (2 * x) * 3);
      }
    }
#line 96
    tl_uv = t_uv;
#line 96
    l_uv = uv;
#line 96
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if (! (len & 1)) {
#line 96
    if (top_y) {
      {
#line 96
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 96
      VP8YuvToBgr(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                  top_dst + (len - 1) * 3);
      }
    }
#line 96
    if (bottom_y) {
      {
#line 96
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 96
      VP8YuvToBgr(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                  bottom_dst + (len - 1) * 3);
      }
    }
  }
  return;
}
}
#line 97 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void UpsampleRgbaLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                 uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                 uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 97
  last_pixel_pair = (len - 1) >> 1;
#line 97
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 97
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 97
  if (top_y) {
    {
#line 97
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 97
    VP8YuvToRgba(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 97
  if (bottom_y) {
    {
#line 97
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 97
    VP8YuvToRgba(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                 bottom_dst);
    }
  }
#line 97
  x = 1;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (x <= last_pixel_pair)) {
#line 97
      goto while_break;
    }
#line 97
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 97
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 97
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 97
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 97
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 97
    if (top_y) {
      {
#line 97
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 97
      uv1 = (diag_03 + t_uv) >> 1;
#line 97
      VP8YuvToRgba(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                   top_dst + (2 * x - 1) * 4);
#line 97
      VP8YuvToRgba(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                   top_dst + (2 * x) * 4);
      }
    }
#line 97
    if (bottom_y) {
      {
#line 97
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 97
      uv1___0 = (diag_12 + uv) >> 1;
#line 97
      VP8YuvToRgba(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                   bottom_dst + (2 * x - 1) * 4);
#line 97
      VP8YuvToRgba(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                   bottom_dst + (2 * x) * 4);
      }
    }
#line 97
    tl_uv = t_uv;
#line 97
    l_uv = uv;
#line 97
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if (! (len & 1)) {
#line 97
    if (top_y) {
      {
#line 97
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 97
      VP8YuvToRgba(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                   top_dst + (len - 1) * 4);
      }
    }
#line 97
    if (bottom_y) {
      {
#line 97
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 97
      VP8YuvToRgba(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                   bottom_dst + (len - 1) * 4);
      }
    }
  }
  return;
}
}
#line 98 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void UpsampleBgraLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                 uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                 uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 98
  last_pixel_pair = (len - 1) >> 1;
#line 98
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 98
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 98
  if (top_y) {
    {
#line 98
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 98
    VP8YuvToBgra(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 98
  if (bottom_y) {
    {
#line 98
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 98
    VP8YuvToBgra(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                 bottom_dst);
    }
  }
#line 98
  x = 1;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (x <= last_pixel_pair)) {
#line 98
      goto while_break;
    }
#line 98
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 98
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 98
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 98
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 98
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 98
    if (top_y) {
      {
#line 98
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 98
      uv1 = (diag_03 + t_uv) >> 1;
#line 98
      VP8YuvToBgra(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                   top_dst + (2 * x - 1) * 4);
#line 98
      VP8YuvToBgra(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                   top_dst + (2 * x) * 4);
      }
    }
#line 98
    if (bottom_y) {
      {
#line 98
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 98
      uv1___0 = (diag_12 + uv) >> 1;
#line 98
      VP8YuvToBgra(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                   bottom_dst + (2 * x - 1) * 4);
#line 98
      VP8YuvToBgra(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                   bottom_dst + (2 * x) * 4);
      }
    }
#line 98
    tl_uv = t_uv;
#line 98
    l_uv = uv;
#line 98
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (! (len & 1)) {
#line 98
    if (top_y) {
      {
#line 98
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 98
      VP8YuvToBgra(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                   top_dst + (len - 1) * 4);
      }
    }
#line 98
    if (bottom_y) {
      {
#line 98
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 98
      VP8YuvToBgra(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                   bottom_dst + (len - 1) * 4);
      }
    }
  }
  return;
}
}
#line 99 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void UpsampleArgbLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                 uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                 uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 99
  last_pixel_pair = (len - 1) >> 1;
#line 99
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 99
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 99
  if (top_y) {
    {
#line 99
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 99
    VP8YuvToArgb(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 99
  if (bottom_y) {
    {
#line 99
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 99
    VP8YuvToArgb(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                 bottom_dst);
    }
  }
#line 99
  x = 1;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (x <= last_pixel_pair)) {
#line 99
      goto while_break;
    }
#line 99
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 99
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 99
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 99
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 99
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 99
    if (top_y) {
      {
#line 99
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 99
      uv1 = (diag_03 + t_uv) >> 1;
#line 99
      VP8YuvToArgb(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                   top_dst + (2 * x - 1) * 4);
#line 99
      VP8YuvToArgb(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                   top_dst + (2 * x) * 4);
      }
    }
#line 99
    if (bottom_y) {
      {
#line 99
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 99
      uv1___0 = (diag_12 + uv) >> 1;
#line 99
      VP8YuvToArgb(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                   bottom_dst + (2 * x - 1) * 4);
#line 99
      VP8YuvToArgb(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                   bottom_dst + (2 * x) * 4);
      }
    }
#line 99
    tl_uv = t_uv;
#line 99
    l_uv = uv;
#line 99
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  if (! (len & 1)) {
#line 99
    if (top_y) {
      {
#line 99
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 99
      VP8YuvToArgb(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                   top_dst + (len - 1) * 4);
      }
    }
#line 99
    if (bottom_y) {
      {
#line 99
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 99
      VP8YuvToArgb(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                   bottom_dst + (len - 1) * 4);
      }
    }
  }
  return;
}
}
#line 100 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void UpsampleRgba4444LinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                     uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                     uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 100
  last_pixel_pair = (len - 1) >> 1;
#line 100
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 100
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 100
  if (top_y) {
    {
#line 100
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 100
    VP8YuvToRgba4444(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16),
                     top_dst);
    }
  }
#line 100
  if (bottom_y) {
    {
#line 100
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 100
    VP8YuvToRgba4444(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                     bottom_dst);
    }
  }
#line 100
  x = 1;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (x <= last_pixel_pair)) {
#line 100
      goto while_break;
    }
#line 100
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 100
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 100
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 100
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 100
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 100
    if (top_y) {
      {
#line 100
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 100
      uv1 = (diag_03 + t_uv) >> 1;
#line 100
      VP8YuvToRgba4444(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                       top_dst + (2 * x - 1) * 2);
#line 100
      VP8YuvToRgba4444(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                       top_dst + (2 * x) * 2);
      }
    }
#line 100
    if (bottom_y) {
      {
#line 100
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 100
      uv1___0 = (diag_12 + uv) >> 1;
#line 100
      VP8YuvToRgba4444(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                       bottom_dst + (2 * x - 1) * 2);
#line 100
      VP8YuvToRgba4444(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                       bottom_dst + (2 * x) * 2);
      }
    }
#line 100
    tl_uv = t_uv;
#line 100
    l_uv = uv;
#line 100
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  if (! (len & 1)) {
#line 100
    if (top_y) {
      {
#line 100
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 100
      VP8YuvToRgba4444(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                       top_dst + (len - 1) * 2);
      }
    }
#line 100
    if (bottom_y) {
      {
#line 100
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 100
      VP8YuvToRgba4444(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                       bottom_dst + (len - 1) * 2);
      }
    }
  }
  return;
}
}
#line 101 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void UpsampleRgb565LinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *top_u ,
                                   uint8_t *top_v , uint8_t *cur_u , uint8_t *cur_v ,
                                   uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int x ;
  int last_pixel_pair ;
  uint32_t tl_uv ;
  uint32_t l_uv ;
  uint32_t uv0 ;
  uint32_t uv0___0 ;
  uint32_t t_uv ;
  uint32_t uv ;
  uint32_t avg ;
  uint32_t diag_12 ;
  uint32_t diag_03 ;
  uint32_t uv0___1 ;
  uint32_t uv1 ;
  uint32_t uv0___2 ;
  uint32_t uv1___0 ;
  uint32_t uv0___3 ;
  uint32_t uv0___4 ;

  {
#line 101
  last_pixel_pair = (len - 1) >> 1;
#line 101
  tl_uv = (uint32_t )((int )*(top_u + 0) | ((int )*(top_v + 0) << 16));
#line 101
  l_uv = (uint32_t )((int )*(cur_u + 0) | ((int )*(cur_v + 0) << 16));
#line 101
  if (top_y) {
    {
#line 101
    uv0 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 101
    VP8YuvToRgb565(*(top_y + 0), (uint8_t )(uv0 & 255U), (uint8_t )(uv0 >> 16), top_dst);
    }
  }
#line 101
  if (bottom_y) {
    {
#line 101
    uv0___0 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 101
    VP8YuvToRgb565(*(bottom_y + 0), (uint8_t )(uv0___0 & 255U), (uint8_t )(uv0___0 >> 16),
                   bottom_dst);
    }
  }
#line 101
  x = 1;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (x <= last_pixel_pair)) {
#line 101
      goto while_break;
    }
#line 101
    t_uv = (uint32_t )((int )*(top_u + x) | ((int )*(top_v + x) << 16));
#line 101
    uv = (uint32_t )((int )*(cur_u + x) | ((int )*(cur_v + x) << 16));
#line 101
    avg = (((tl_uv + t_uv) + l_uv) + uv) + 524296U;
#line 101
    diag_12 = (avg + 2U * (t_uv + l_uv)) >> 3;
#line 101
    diag_03 = (avg + 2U * (tl_uv + uv)) >> 3;
#line 101
    if (top_y) {
      {
#line 101
      uv0___1 = (diag_12 + tl_uv) >> 1;
#line 101
      uv1 = (diag_03 + t_uv) >> 1;
#line 101
      VP8YuvToRgb565(*(top_y + (2 * x - 1)), (uint8_t )(uv0___1 & 255U), (uint8_t )(uv0___1 >> 16),
                     top_dst + (2 * x - 1) * 2);
#line 101
      VP8YuvToRgb565(*(top_y + 2 * x), (uint8_t )(uv1 & 255U), (uint8_t )(uv1 >> 16),
                     top_dst + (2 * x) * 2);
      }
    }
#line 101
    if (bottom_y) {
      {
#line 101
      uv0___2 = (diag_03 + l_uv) >> 1;
#line 101
      uv1___0 = (diag_12 + uv) >> 1;
#line 101
      VP8YuvToRgb565(*(bottom_y + (2 * x - 1)), (uint8_t )(uv0___2 & 255U), (uint8_t )(uv0___2 >> 16),
                     bottom_dst + (2 * x - 1) * 2);
#line 101
      VP8YuvToRgb565(*(bottom_y + 2 * x), (uint8_t )(uv1___0 & 255U), (uint8_t )(uv1___0 >> 16),
                     bottom_dst + (2 * x) * 2);
      }
    }
#line 101
    tl_uv = t_uv;
#line 101
    l_uv = uv;
#line 101
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (! (len & 1)) {
#line 101
    if (top_y) {
      {
#line 101
      uv0___3 = ((3U * tl_uv + l_uv) + 131074U) >> 2;
#line 101
      VP8YuvToRgb565(*(top_y + (len - 1)), (uint8_t )(uv0___3 & 255U), (uint8_t )(uv0___3 >> 16),
                     top_dst + (len - 1) * 2);
      }
    }
#line 101
    if (bottom_y) {
      {
#line 101
      uv0___4 = ((3U * l_uv + tl_uv) + 131074U) >> 2;
#line 101
      VP8YuvToRgb565(*(bottom_y + (len - 1)), (uint8_t )(uv0___4 & 255U), (uint8_t )(uv0___4 >> 16),
                     bottom_dst + (len - 1) * 2);
      }
    }
  }
  return;
}
}
#line 135 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void SampleRgbLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                              uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < len - 1)) {
#line 135
      goto while_break;
    }
    {
#line 135
    VP8YuvToRgb(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 135
    VP8YuvToRgb(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 3);
#line 135
    VP8YuvToRgb(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 135
    VP8YuvToRgb(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 3);
#line 135
    top_y += 2;
#line 135
    bottom_y += 2;
#line 135
    u ++;
#line 135
    v ++;
#line 135
    top_dst += 6;
#line 135
    bottom_dst += 6;
    }
#line 135
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if (i == len - 1) {
    {
#line 135
    VP8YuvToRgb(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 135
    VP8YuvToRgb(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
  return;
}
}
#line 136 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void SampleBgrLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                              uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < len - 1)) {
#line 136
      goto while_break;
    }
    {
#line 136
    VP8YuvToBgr(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 136
    VP8YuvToBgr(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 3);
#line 136
    VP8YuvToBgr(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 136
    VP8YuvToBgr(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 3);
#line 136
    top_y += 2;
#line 136
    bottom_y += 2;
#line 136
    u ++;
#line 136
    v ++;
#line 136
    top_dst += 6;
#line 136
    bottom_dst += 6;
    }
#line 136
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (i == len - 1) {
    {
#line 136
    VP8YuvToBgr(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 136
    VP8YuvToBgr(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
  return;
}
}
#line 137 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void SampleRgbaLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                               uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < len - 1)) {
#line 137
      goto while_break;
    }
    {
#line 137
    VP8YuvToRgba(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 137
    VP8YuvToRgba(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 4);
#line 137
    VP8YuvToRgba(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 137
    VP8YuvToRgba(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 4);
#line 137
    top_y += 2;
#line 137
    bottom_y += 2;
#line 137
    u ++;
#line 137
    v ++;
#line 137
    top_dst += 8;
#line 137
    bottom_dst += 8;
    }
#line 137
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if (i == len - 1) {
    {
#line 137
    VP8YuvToRgba(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 137
    VP8YuvToRgba(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
  return;
}
}
#line 138 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void SampleBgraLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                               uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 138
  i = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (i < len - 1)) {
#line 138
      goto while_break;
    }
    {
#line 138
    VP8YuvToBgra(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 138
    VP8YuvToBgra(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 4);
#line 138
    VP8YuvToBgra(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 138
    VP8YuvToBgra(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 4);
#line 138
    top_y += 2;
#line 138
    bottom_y += 2;
#line 138
    u ++;
#line 138
    v ++;
#line 138
    top_dst += 8;
#line 138
    bottom_dst += 8;
    }
#line 138
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if (i == len - 1) {
    {
#line 138
    VP8YuvToBgra(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 138
    VP8YuvToBgra(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
  return;
}
}
#line 139 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void SampleArgbLinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u , uint8_t *v ,
                               uint8_t *top_dst , uint8_t *bottom_dst , int len ) 
{ 
  int i ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < len - 1)) {
#line 139
      goto while_break;
    }
    {
#line 139
    VP8YuvToArgb(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 139
    VP8YuvToArgb(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 4);
#line 139
    VP8YuvToArgb(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 139
    VP8YuvToArgb(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 4);
#line 139
    top_y += 2;
#line 139
    bottom_y += 2;
#line 139
    u ++;
#line 139
    v ++;
#line 139
    top_dst += 8;
#line 139
    bottom_dst += 8;
    }
#line 139
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (i == len - 1) {
    {
#line 139
    VP8YuvToArgb(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 139
    VP8YuvToArgb(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
  return;
}
}
#line 140 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void SampleRgba4444LinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u ,
                                   uint8_t *v , uint8_t *top_dst , uint8_t *bottom_dst ,
                                   int len ) 
{ 
  int i ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < len - 1)) {
#line 140
      goto while_break;
    }
    {
#line 140
    VP8YuvToRgba4444(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 140
    VP8YuvToRgba4444(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 2);
#line 140
    VP8YuvToRgba4444(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 140
    VP8YuvToRgba4444(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 2);
#line 140
    top_y += 2;
#line 140
    bottom_y += 2;
#line 140
    u ++;
#line 140
    v ++;
#line 140
    top_dst += 4;
#line 140
    bottom_dst += 4;
    }
#line 140
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (i == len - 1) {
    {
#line 140
    VP8YuvToRgba4444(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 140
    VP8YuvToRgba4444(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
  return;
}
}
#line 141 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void SampleRgb565LinePair(uint8_t *top_y , uint8_t *bottom_y , uint8_t *u ,
                                 uint8_t *v , uint8_t *top_dst , uint8_t *bottom_dst ,
                                 int len ) 
{ 
  int i ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < len - 1)) {
#line 141
      goto while_break;
    }
    {
#line 141
    VP8YuvToRgb565(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 141
    VP8YuvToRgb565(*(top_y + 1), *(u + 0), *(v + 0), top_dst + 2);
#line 141
    VP8YuvToRgb565(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
#line 141
    VP8YuvToRgb565(*(bottom_y + 1), *(u + 0), *(v + 0), bottom_dst + 2);
#line 141
    top_y += 2;
#line 141
    bottom_y += 2;
#line 141
    u ++;
#line 141
    v ++;
#line 141
    top_dst += 4;
#line 141
    bottom_dst += 4;
    }
#line 141
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  if (i == len - 1) {
    {
#line 141
    VP8YuvToRgb565(*(top_y + 0), *(u + 0), *(v + 0), top_dst);
#line 141
    VP8YuvToRgb565(*(bottom_y + 0), *(u + 0), *(v + 0), bottom_dst);
    }
  }
  return;
}
}
#line 145 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
WebPSampleLinePairFunc WebPSamplers[13]  = 
#line 145
  {      & SampleRgbLinePair,      & SampleRgbaLinePair,      & SampleBgrLinePair,      & SampleBgraLinePair, 
        & SampleArgbLinePair,      & SampleRgba4444LinePair,      & SampleRgb565LinePair,      & SampleRgbaLinePair, 
        & SampleBgraLinePair,      & SampleArgbLinePair,      & SampleRgba4444LinePair};
#line 191 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
WebPUpsampleLinePairFunc WebPGetLinePairConverter(int alpha_is_last ) 
{ 
  int tmp ;

  {
  {
#line 192
  WebPInitUpsamplers();
#line 193
  VP8YUVInit();
  }
#line 195
  if (alpha_is_last) {
#line 195
    tmp = 3;
  } else {
#line 195
    tmp = 4;
  }
#line 195
  return (WebPUpsamplers[tmp]);
}
}
#line 211 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void Yuv444ToRgb(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < len)) {
#line 211
      goto while_break;
    }
    {
#line 211
    VP8YuvToRgb(*(y + i), *(u + i), *(v + i), dst + i * 3);
    }
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 212 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void Yuv444ToBgr(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i < len)) {
#line 212
      goto while_break;
    }
    {
#line 212
    VP8YuvToBgr(*(y + i), *(u + i), *(v + i), dst + i * 3);
    }
#line 212
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 213 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void Yuv444ToRgba(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < len)) {
#line 213
      goto while_break;
    }
    {
#line 213
    VP8YuvToRgba(*(y + i), *(u + i), *(v + i), dst + i * 4);
    }
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 214 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void Yuv444ToBgra(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 214
  i = 0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (i < len)) {
#line 214
      goto while_break;
    }
    {
#line 214
    VP8YuvToBgra(*(y + i), *(u + i), *(v + i), dst + i * 4);
    }
#line 214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 215 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void Yuv444ToArgb(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < len)) {
#line 215
      goto while_break;
    }
    {
#line 215
    VP8YuvToArgb(*(y + i), *(u + i), *(v + i), dst + i * 4);
    }
#line 215
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 216 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void Yuv444ToRgba4444(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst ,
                             int len ) 
{ 
  int i ;

  {
#line 216
  i = 0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i < len)) {
#line 216
      goto while_break;
    }
    {
#line 216
    VP8YuvToRgba4444(*(y + i), *(u + i), *(v + i), dst + i * 2);
    }
#line 216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 217 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void Yuv444ToRgb565(uint8_t *y , uint8_t *u , uint8_t *v , uint8_t *dst , int len ) 
{ 
  int i ;

  {
#line 217
  i = 0;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < len)) {
#line 217
      goto while_break;
    }
    {
#line 217
    VP8YuvToRgb565(*(y + i), *(u + i), *(v + i), dst + i * 2);
    }
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 221 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
WebPYUV444Converter WebPYUV444Converters[13]  = 
#line 221
  {      & Yuv444ToRgb,      & Yuv444ToRgba,      & Yuv444ToBgr,      & Yuv444ToBgra, 
        & Yuv444ToArgb,      & Yuv444ToRgba4444,      & Yuv444ToRgb565,      & Yuv444ToRgba, 
        & Yuv444ToBgra,      & Yuv444ToArgb,      & Yuv444ToRgba4444};
#line 251 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void ApplyAlphaMultiply(uint8_t *rgba , int alpha_first , int w , int h , int stride ) 
{ 
  int __cil_tmp6 ;
  uint8_t *rgb ;
  int tmp ;
  uint8_t *alpha ;
  int tmp___0 ;
  int i ;
  uint32_t a ;
  uint32_t mult ;

  {
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    __cil_tmp6 = h;
#line 253
    h --;
#line 253
    if (! (__cil_tmp6 > 0)) {
#line 253
      goto while_break;
    }
#line 254
    if (alpha_first) {
#line 254
      tmp = 1;
    } else {
#line 254
      tmp = 0;
    }
#line 254
    rgb = rgba + tmp;
#line 255
    if (alpha_first) {
#line 255
      tmp___0 = 0;
    } else {
#line 255
      tmp___0 = 3;
    }
#line 255
    alpha = rgba + tmp___0;
#line 257
    i = 0;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (! (i < w)) {
#line 257
        goto while_break___0;
      }
#line 258
      a = (uint32_t )*(alpha + 4 * i);
#line 259
      if (a != 255U) {
#line 260
        mult = (uint32_t )((unsigned long )a * 32897UL);
#line 261
        *(rgb + 4 * i) = (uint8_t )((unsigned int )*(rgb + 4 * i) * mult >> 23);
#line 262
        *(rgb + (4 * i + 1)) = (uint8_t )((unsigned int )*(rgb + (4 * i + 1)) * mult >> 23);
#line 263
        *(rgb + (4 * i + 2)) = (uint8_t )((unsigned int )*(rgb + (4 * i + 2)) * mult >> 23);
      }
#line 257
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 266
    rgba += stride;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 276 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
__inline static uint8_t dither_hi(uint8_t x ) 
{ 


  {
#line 277
  return ((uint8_t )(((int )x & 240) | ((int )x >> 4)));
}
}
#line 280 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
__inline static uint8_t dither_lo(uint8_t x ) 
{ 


  {
#line 281
  return ((uint8_t )(((int )x & 15) | ((int )x << 4)));
}
}
#line 284 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
__inline static uint8_t multiply(uint8_t x , uint32_t m ) 
{ 


  {
#line 285
  return ((uint8_t )((unsigned int )x * m >> 16));
}
}
#line 288 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
static void ApplyAlphaMultiply4444(uint8_t *rgba4444 , int w , int h , int stride ) 
{ 
  int __cil_tmp5 ;
  int i ;
  uint8_t a ;
  uint32_t mult ;
  uint8_t r ;
  uint8_t __cil_tmp10 ;
  uint8_t __cil_tmp11 ;
  uint8_t g ;
  uint8_t __cil_tmp13 ;
  uint8_t __cil_tmp14 ;
  uint8_t b ;
  uint8_t __cil_tmp16 ;
  uint8_t __cil_tmp17 ;

  {
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    __cil_tmp5 = h;
#line 290
    h --;
#line 290
    if (! (__cil_tmp5 > 0)) {
#line 290
      goto while_break;
    }
#line 292
    i = 0;
    {
#line 292
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 292
      if (! (i < w)) {
#line 292
        goto while_break___0;
      }
      {
#line 293
      a = (uint8_t )((int )*(rgba4444 + (2 * i + 1)) & 15);
#line 294
      mult = (uint32_t )((int )a * 4369);
#line 295
      __cil_tmp10 = dither_hi(*(rgba4444 + 2 * i));
#line 295
      __cil_tmp11 = multiply(__cil_tmp10, mult);
#line 295
      r = __cil_tmp11;
#line 296
      __cil_tmp13 = dither_lo(*(rgba4444 + 2 * i));
#line 296
      __cil_tmp14 = multiply(__cil_tmp13, mult);
#line 296
      g = __cil_tmp14;
#line 297
      __cil_tmp16 = dither_hi(*(rgba4444 + (2 * i + 1)));
#line 297
      __cil_tmp17 = multiply(__cil_tmp16, mult);
#line 297
      b = __cil_tmp17;
#line 298
      *(rgba4444 + 2 * i) = (uint8_t )(((int )r & 240) | (((int )g >> 4) & 15));
#line 299
      *(rgba4444 + (2 * i + 1)) = (uint8_t )(((int )b & 240) | (int )a);
      }
#line 292
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 301
    rgba4444 += stride;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 306 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
void (*WebPApplyAlphaMultiply)(uint8_t * , int  , int  , int  , int  )  =    & ApplyAlphaMultiply;
#line 308 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
void (*WebPApplyAlphaMultiply4444)(uint8_t * , int  , int  , int  )  =    & ApplyAlphaMultiply4444;
#line 314 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
void WebPInitUpsamplers(void) 
{ 
  int __cil_tmp1 ;

  {
#line 316
  WebPUpsamplers[0] = & UpsampleRgbLinePair;
#line 317
  WebPUpsamplers[1] = & UpsampleRgbaLinePair;
#line 318
  WebPUpsamplers[2] = & UpsampleBgrLinePair;
#line 319
  WebPUpsamplers[3] = & UpsampleBgraLinePair;
#line 320
  WebPUpsamplers[4] = & UpsampleArgbLinePair;
#line 321
  WebPUpsamplers[5] = & UpsampleRgba4444LinePair;
#line 322
  WebPUpsamplers[6] = & UpsampleRgb565LinePair;
#line 325
  if (VP8GetCPUInfo != (void *)0) {
    {
#line 327
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 327
    if (__cil_tmp1) {
      {
#line 328
      WebPInitUpsamplersSSE2();
      }
    }
  }
  return;
}
}
#line 340 "/doner/libwebp/libwebp-v0.3.0/src/dsp/upsampling.c"
void WebPInitPremultiply(void) 
{ 
  int __cil_tmp1 ;

  {
#line 341
  WebPApplyAlphaMultiply = & ApplyAlphaMultiply;
#line 342
  WebPApplyAlphaMultiply4444 = & ApplyAlphaMultiply4444;
#line 345
  WebPUpsamplers[7] = & UpsampleRgbaLinePair;
#line 346
  WebPUpsamplers[8] = & UpsampleBgraLinePair;
#line 347
  WebPUpsamplers[9] = & UpsampleArgbLinePair;
#line 348
  WebPUpsamplers[10] = & UpsampleRgba4444LinePair;
#line 350
  if (VP8GetCPUInfo != (void *)0) {
    {
#line 352
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 352
    if (__cil_tmp1) {
      {
#line 353
      WebPInitPremultiplySSE2();
      }
    }
  }
  return;
}
}
#line 46 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./webpi.h"
void WebPResetDecParams(WebPDecParams *params ) ;
#line 69
enum VP8StatusCode WebPParseHeaders(WebPHeaderStructure *headers ) ;
#line 76
void WebPInitCustomIo(WebPDecParams *params , VP8Io *io ) ;
#line 80
int WebPIoInitFromOptions(WebPDecoderOptions *options , VP8Io *io , enum WEBP_CSP_MODE src_colorspace ) ;
#line 94
enum VP8StatusCode WebPAllocateDecBuffer(int w , int h , WebPDecoderOptions *options ,
                                         WebPDecBuffer *out ) ;
#line 100
void WebPCopyDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) ;
#line 104
void WebPGrabDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) ;
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/../utils/color_cache.h"
static uint32_t kHashMul___1  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___1(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___1 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___1(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___1 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/../utils/color_cache.h"
__inline static int VP8LColorCacheContains___1(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___1 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 95 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8li.h"
int VP8LDecodeAlphaImageStream(int width , int height , uint8_t *data , size_t data_size ,
                               uint8_t *output ) ;
#line 99
VP8LDecoder *VP8LNew(void) ;
#line 102
int VP8LDecodeHeader(VP8LDecoder *dec , VP8Io *io ) ;
#line 106
int VP8LDecodeImage(VP8LDecoder *dec ) ;
#line 110
void VP8LClear(VP8LDecoder *dec ) ;
#line 113
void VP8LDelete(VP8LDecoder *dec ) ;
#line 38 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
float const   kLog2Table[256]  = 
#line 38 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
  {      0.f,      0.f,      1.f,      1.58496248723f, 
        2.f,      2.3219280243f,      2.58496260644f,      2.80735492707f, 
        3.f,      3.16992497445f,      3.3219280243f,      3.45943164826f, 
        3.58496260644f,      3.70043969155f,      3.80735492707f,      3.90689063073f, 
        4.f,      4.08746290207f,      4.16992521287f,      4.24792766572f, 
        4.3219280243f,      4.39231729508f,      4.45943164826f,      4.5235619545f, 
        4.58496236802f,      4.64385604859f,      4.70043992997f,      4.75488758088f, 
        4.80735492707f,      4.85798120499f,      4.90689039231f,      4.9541964531f, 
        5.f,      5.04439401627f,      5.08746290207f,      5.12928295136f, 
        5.16992521287f,      5.20945358277f,      5.24792766572f,      5.28540229798f, 
        5.3219280243f,      5.35755205155f,      5.39231729508f,      5.42626476288f, 
        5.45943164826f,      5.49185323716f,      5.5235619545f,      5.55458879471f, 
        5.58496236802f,      5.61470985413f,      5.64385604859f,      5.67242527009f, 
        5.70043992997f,      5.72792053223f,      5.75488758088f,      5.78135967255f, 
        5.80735492707f,      5.83289003373f,      5.85798120499f,      5.88264322281f, 
        5.90689039231f,      5.93073749543f,      5.9541964531f,      5.97728013993f, 
        6.f,      6.02236795426f,      6.04439401627f,      6.06608915329f, 
        6.08746290207f,      6.10852432251f,      6.12928295136f,      6.14974689484f, 
        6.16992521287f,      6.18982458115f,      6.20945358277f,      6.22881889344f, 
        6.24792766572f,      6.26678657532f,      6.28540229798f,      6.30378055573f, 
        6.3219280243f,      6.33984994889f,      6.35755205155f,      6.37503957749f, 
        6.39231729508f,      6.40939092637f,      6.42626476288f,      6.442943573f, 
        6.45943164826f,      6.47573328019f,      6.49185323716f,      6.50779485703f, 
        6.5235619545f,      6.53915882111f,      6.55458879471f,      6.56985569001f, 
        6.58496236802f,      6.59991264344f,      6.61470985413f,      6.62935638428f, 
        6.64385604859f,      6.65821170807f,      6.67242527009f,      6.68650054932f, 
        6.70043992997f,      6.71424531937f,      6.72792053223f,      6.74146699906f, 
        6.75488758088f,      6.76818418503f,      6.78135967255f,      6.79441595078f, 
        6.80735492707f,      6.8201789856f,      6.83289003373f,      6.8454899788f, 
        6.85798120499f,      6.87036466599f,      6.88264322281f,      6.89481782914f, 
        6.90689039231f,      6.91886329651f,      6.93073749543f,      6.94251441956f, 
        6.9541964531f,      6.96578407288f,      6.97728013993f,      6.98868465424f, 
        7.f,      7.01122713089f,      7.02236795426f,      7.03342294693f, 
        7.04439401627f,      7.05528259278f,      7.06608915329f,      7.07681560517f, 
        7.08746290207f,      7.09803199769f,      7.10852432251f,      7.11894130707f, 
        7.12928295136f,      7.13955116272f,      7.14974689484f,      7.15987110138f, 
        7.16992521287f,      7.17990922928f,      7.18982458115f,      7.19967222214f, 
        7.20945358277f,      7.21916866303f,      7.22881889344f,      7.23840475083f, 
        7.24792766572f,      7.2573876381f,      7.26678657532f,      7.27612447739f, 
        7.28540229798f,      7.29462051392f,      7.30378055573f,      7.31288290024f, 
        7.3219280243f,      7.33091688157f,      7.33984994889f,      7.34872817994f, 
        7.35755205155f,      7.36632204056f,      7.37503957749f,      7.38370418549f, 
        7.39231729508f,      7.40087938309f,      7.40939092637f,      7.41785240174f, 
        7.42626476288f,      7.4346280098f,      7.442943573f,      7.45121097565f, 
        7.45943164826f,      7.46760559083f,      7.47573328019f,      7.48381567002f, 
        7.49185323716f,      7.4998459816f,      7.50779485703f,      7.51569986344f, 
        7.5235619545f,      7.53138160706f,      7.53915882111f,      7.54689455033f, 
        7.55458879471f,      7.56224250794f,      7.56985569001f,      7.57742881775f, 
        7.58496236802f,      7.59245681763f,      7.59991264344f,      7.60733032227f, 
        7.61470985413f,      7.62205171586f,      7.62935638428f,      7.63662481308f, 
        7.64385604859f,      7.65105152131f,      7.65821170807f,      7.66533613205f, 
        7.67242527009f,      7.67948007584f,      7.68650054932f,      7.69348716736f, 
        7.70043992997f,      7.70735931397f,      7.71424531937f,      7.72109937668f, 
        7.72792053223f,      7.73470973969f,      7.74146699906f,      7.74819278718f, 
        7.75488758088f,      7.76155138016f,      7.76818418503f,      7.77478694916f, 
        7.78135967255f,      7.7879023552f,      7.79441595078f,      7.80089998246f, 
        7.80735492707f,      7.81378126145f,      7.8201789856f,      7.82654857636f, 
        7.83289003373f,      7.83920383454f,      7.8454899788f,      7.85174894333f, 
        7.85798120499f,      7.86418628693f,      7.87036466599f,      7.87651681901f, 
        7.88264322281f,      7.88874340058f,      7.89481782914f,      7.90086698533f, 
        7.90689039231f,      7.9128894806f,      7.91886329651f,      7.9248123169f, 
        7.93073749543f,      7.93663787842f,      7.94251441956f,      7.94836711884f, 
        7.9541964531f,      7.9600019455f,      7.96578407288f,      7.97154378891f, 
        7.97728013993f,      7.98299360276f,      7.98868465424f,      7.99435329438f};
#line 169 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
float const   kSLog2Table[256]  = 
#line 169
  {      0.f,      0.f,      2.f,      4.75488758088f, 
        8.f,      11.6096401215f,      15.5097751618f,      19.6514835358f, 
        24.f,      28.5293254853f,      33.219280243f,      38.0537490845f, 
        43.0195503235f,      48.1057167054f,      53.3029670716f,      58.6033592225f, 
        64.f,      69.4868698121f,      75.0586471558f,      80.7106246949f, 
        86.4385604859f,      92.2386627198f,      98.107498169f,      104.041923523f, 
        110.039100647f,      116.09640503f,      122.211433411f,      128.381958008f, 
        134.605941773f,      140.881454468f,      147.206710816f,      153.580078125f, 
        160.f,      166.465011597f,      172.973739625f,      179.524902344f, 
        186.117294312f,      192.749771119f,      199.42124939f,      206.130691529f, 
        212.877120972f,      219.659637452f,      226.47732544f,      233.32939148f, 
        240.214996338f,      247.133392334f,      254.083847046f,      261.065673829f, 
        268.078186036f,      275.120788575f,      282.192810059f,      289.293701172f, 
        296.422851563f,      303.57977295f,      310.763916016f,      317.974792481f, 
        325.211883545f,      332.474731446f,      339.762908936f,      347.075927735f, 
        354.413421631f,      361.774963379f,      369.16015625f,      376.568634034f, 
        384.f,      391.453918458f,      398.930023194f,      406.427978516f, 
        413.947479249f,      421.488189698f,      429.049804688f,      436.632049561f, 
        444.234588624f,      451.857177735f,      459.499542237f,      467.161407471f, 
        474.84249878f,      482.542572022f,      490.261383057f,      497.998687745f, 
        505.754241944f,      513.527832032f,      521.319274903f,      529.128295899f, 
        536.954650879f,      544.798217774f,      552.658752442f,      560.536071778f, 
        568.429992676f,      576.340270997f,      584.266784668f,      592.209289551f, 
        600.16772461f,      608.141784668f,      616.131347657f,      624.136291504f, 
        632.156372071f,      640.191528321f,      648.241577149f,      656.30633545f, 
        664.385620118f,      672.479370118f,      680.587402344f,      688.709533692f, 
        696.845703125f,      704.995788575f,      713.159545899f,      721.336975098f, 
        729.527832032f,      737.7321167f,      745.949584961f,      754.180175782f, 
        762.42376709f,      770.680236817f,      778.949462891f,      787.231384278f, 
        795.525817872f,      803.832702637f,      812.151855469f,      820.483337403f, 
        828.826843262f,      837.182434083f,      845.549926758f,      853.929260254f, 
        862.3203125f,      870.723022461f,      879.137268067f,      887.562927247f, 
        896.f,      904.448303223f,      912.907836915f,      921.378417969f, 
        929.860046387f,      938.352539063f,      946.855957032f,      955.370117188f, 
        963.894958497f,      972.430419922f,      980.976379395f,      989.532836915f, 
        998.099609375f,      1006.67675782f,      1015.26409913f,      1023.86157227f, 
        1032.46923829f,      1041.086792f,      1049.71435547f,      1058.35180665f, 
        1066.99914551f,      1075.65612793f,      1084.32275391f,      1092.99914551f, 
        1101.68493653f,      1110.3803711f,      1119.08508301f,      1127.79931641f, 
        1136.52270508f,      1145.25549317f,      1153.99731446f,      1162.74841309f, 
        1171.50854493f,      1180.2775879f,      1189.05566407f,      1197.84265137f, 
        1206.63854981f,      1215.44311524f,      1224.2565918f,      1233.07861329f, 
        1241.90930176f,      1250.74865723f,      1259.59643555f,      1268.45275879f, 
        1277.31750489f,      1286.19067383f,      1295.07214356f,      1303.96191407f, 
        1312.85998536f,      1321.76623536f,      1330.680542f,      1339.60302735f, 
        1348.53356934f,      1357.4720459f,      1366.41857911f,      1375.37304688f, 
        1384.33544922f,      1393.305542f,      1402.28356934f,      1411.26928711f, 
        1420.26269532f,      1429.26379395f,      1438.27258301f,      1447.28894043f, 
        1456.31274415f,      1465.34423829f,      1474.38305665f,      1483.42944336f, 
        1492.4831543f,      1501.54418946f,      1510.6126709f,      1519.6883545f, 
        1528.77124024f,      1537.8614502f,      1546.95874024f,      1556.06323243f, 
        1565.17480469f,      1574.29345704f,      1583.41906739f,      1592.55175782f, 
        1601.69140625f,      1610.8380127f,      1619.99157715f,      1629.15197754f, 
        1638.3190918f,      1647.49316407f,      1656.6739502f,      1665.8614502f, 
        1675.05566407f,      1684.2565918f,      1693.4642334f,      1702.67834473f, 
        1711.89916993f,      1721.12646485f,      1730.36035157f,      1739.60070801f, 
        1748.84753418f,      1758.10070801f,      1767.36047364f,      1776.62646485f, 
        1785.89892579f,      1795.17761231f,      1804.46276856f,      1813.75402833f, 
        1823.05163575f,      1832.35534668f,      1841.66540528f,      1850.98144532f, 
        1860.30371094f,      1869.63220215f,      1878.96667481f,      1888.30712891f, 
        1897.65368653f,      1907.00634766f,      1916.36486817f,      1925.72949219f, 
        1935.09985352f,      1944.47631836f,      1953.85852051f,      1963.24670411f, 
        1972.640625f,      1982.04052735f,      1991.44604493f,      2000.85742188f, 
        2010.27453614f,      2019.6973877f,      2029.1258545f,      2038.56018067f};
#line 236 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
float VP8LFastSLog2Slow(int v ) 
{ 
  int tmp ;
  int log_cnt ;
  float v_f ;
  double __cil_tmp5 ;

  {
#line 238
  if (v < 4096) {
#line 239
    log_cnt = 0;
#line 240
    v_f = (float )v;
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 241
      if (! (v >= 256)) {
#line 241
        goto while_break;
      }
#line 242
      log_cnt ++;
#line 243
      v >>= 1;
    }
    while_break: /* CIL Label */ ;
    }
#line 245
    return (v_f * (kLog2Table[v] + (float )log_cnt));
  } else {
    {
#line 247
    __cil_tmp5 = log((double )v);
    }
#line 247
    return ((float )((1.44269504089 * (double )v) * __cil_tmp5));
  }
}
}
#line 251 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
float VP8LFastLog2Slow(int v ) 
{ 
  int tmp ;
  int log_cnt ;
  double __cil_tmp4 ;

  {
#line 253
  if (v < 4096) {
#line 254
    log_cnt = 0;
    {
#line 255
    while (1) {
      while_continue: /* CIL Label */ ;
#line 255
      if (! (v >= 256)) {
#line 255
        goto while_break;
      }
#line 256
      log_cnt ++;
#line 257
      v >>= 1;
    }
    while_break: /* CIL Label */ ;
    }
#line 259
    return (kLog2Table[v] + (float )log_cnt);
  } else {
    {
#line 261
    __cil_tmp4 = log((double )v);
    }
#line 261
    return ((float )(1.44269504089 * __cil_tmp4));
  }
}
}
#line 269 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static void AddPixelsEq(uint32_t *a , uint32_t b ) 
{ 
  uint32_t alpha_and_green ;
  uint32_t red_and_blue ;

  {
#line 270
  alpha_and_green = (*a & 4278255360U) + (b & 4278255360U);
#line 271
  red_and_blue = (*a & 16711935U) + (b & 16711935U);
#line 272
  *a = (alpha_and_green & 4278255360U) | (red_and_blue & 16711935U);
  return;
}
}
#line 275 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t Average2(uint32_t a0 , uint32_t a1 ) 
{ 


  {
#line 276
  return ((uint32_t )((((long )(a0 ^ a1) & 4278124286L) >> 1) + (long )(a0 & a1)));
}
}
#line 279 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t Average3(uint32_t a0 , uint32_t a1 , uint32_t a2 ) 
{ 
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;

  {
  {
#line 280
  __cil_tmp4 = Average2(a0, a2);
#line 280
  __cil_tmp5 = Average2(__cil_tmp4, a1);
  }
#line 280
  return (__cil_tmp5);
}
}
#line 283 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t Average4(uint32_t a0 , uint32_t a1 , uint32_t a2 , uint32_t a3 ) 
{ 
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;

  {
  {
#line 285
  __cil_tmp5 = Average2(a0, a1);
  }
  {
#line 285
  __cil_tmp6 = Average2(a2, a3);
#line 285
  __cil_tmp7 = Average2(__cil_tmp5, __cil_tmp6);
  }
#line 285
  return (__cil_tmp7);
}
}
#line 343 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t Clip255(uint32_t a ) 
{ 


  {
#line 344
  if (a < 256U) {
#line 345
    return (a);
  }
#line 349
  return (~ a >> 24);
}
}
#line 352 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static int AddSubtractComponentFull(int a , int b , int c ) 
{ 
  uint32_t __cil_tmp4 ;

  {
  {
#line 353
  __cil_tmp4 = Clip255((uint32_t )((a + b) - c));
  }
#line 353
  return ((int )__cil_tmp4);
}
}
#line 356 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t ClampedAddSubtractFull(uint32_t c0 , uint32_t c1 , uint32_t c2 ) 
{ 
  int a ;
  int __cil_tmp5 ;
  int r ;
  int __cil_tmp7 ;
  int g ;
  int __cil_tmp9 ;
  int b ;
  int __cil_tmp11 ;

  {
  {
#line 358
  __cil_tmp5 = AddSubtractComponentFull((int )(c0 >> 24), (int )(c1 >> 24), (int )(c2 >> 24));
#line 358
  a = __cil_tmp5;
#line 359
  __cil_tmp7 = AddSubtractComponentFull((int )((c0 >> 16) & 255U), (int )((c1 >> 16) & 255U),
                                        (int )((c2 >> 16) & 255U));
#line 359
  r = __cil_tmp7;
#line 362
  __cil_tmp9 = AddSubtractComponentFull((int )((c0 >> 8) & 255U), (int )((c1 >> 8) & 255U),
                                        (int )((c2 >> 8) & 255U));
#line 362
  g = __cil_tmp9;
#line 365
  __cil_tmp11 = AddSubtractComponentFull((int )(c0 & 255U), (int )(c1 & 255U), (int )(c2 & 255U));
#line 365
  b = __cil_tmp11;
  }
#line 366
  return ((uint32_t )((((a << 24) | (r << 16)) | (g << 8)) | b));
}
}
#line 369 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static int AddSubtractComponentHalf(int a , int b ) 
{ 
  uint32_t __cil_tmp3 ;

  {
  {
#line 370
  __cil_tmp3 = Clip255((uint32_t )(a + (a - b) / 2));
  }
#line 370
  return ((int )__cil_tmp3);
}
}
#line 373 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t ClampedAddSubtractHalf(uint32_t c0 , uint32_t c1 , uint32_t c2 ) 
{ 
  uint32_t ave ;
  uint32_t __cil_tmp5 ;
  int a ;
  int __cil_tmp7 ;
  int r ;
  int __cil_tmp9 ;
  int g ;
  int __cil_tmp11 ;
  int b ;
  int __cil_tmp13 ;

  {
  {
#line 375
  __cil_tmp5 = Average2(c0, c1);
#line 375
  ave = __cil_tmp5;
#line 376
  __cil_tmp7 = AddSubtractComponentHalf((int )(ave >> 24), (int )(c2 >> 24));
#line 376
  a = __cil_tmp7;
#line 377
  __cil_tmp9 = AddSubtractComponentHalf((int )((ave >> 16) & 255U), (int )((c2 >> 16) & 255U));
#line 377
  r = __cil_tmp9;
#line 378
  __cil_tmp11 = AddSubtractComponentHalf((int )((ave >> 8) & 255U), (int )((c2 >> 8) & 255U));
#line 378
  g = __cil_tmp11;
#line 379
  __cil_tmp13 = AddSubtractComponentHalf((int )(ave & 255U), (int )(c2 & 255U));
#line 379
  b = __cil_tmp13;
  }
#line 380
  return ((uint32_t )((((a << 24) | (r << 16)) | (g << 8)) | b));
}
}
#line 383 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static int Sub3(int a , int b , int c ) 
{ 
  int pb ;
  int pa ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 384
  pb = b - c;
#line 385
  pa = a - c;
#line 386
  __cil_tmp7 = abs(pa);
  }
  {
#line 386
  __cil_tmp6 = abs(pb);
  }
#line 386
  return (__cil_tmp6 - __cil_tmp7);
}
}
#line 389 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t Select(uint32_t a , uint32_t b , uint32_t c ) 
{ 
  int pa_minus_pb ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  uint32_t tmp ;

  {
  {
#line 390
  __cil_tmp8 = Sub3((int )(a & 255U), (int )(b & 255U), (int )(c & 255U));
  }
  {
#line 390
  __cil_tmp7 = Sub3((int )((a >> 8) & 255U), (int )((b >> 8) & 255U), (int )((c >> 8) & 255U));
  }
  {
#line 390
  __cil_tmp6 = Sub3((int )((a >> 16) & 255U), (int )((b >> 16) & 255U), (int )((c >> 16) & 255U));
  }
  {
#line 390
  __cil_tmp5 = Sub3((int )(a >> 24), (int )(b >> 24), (int )(c >> 24));
#line 390
  pa_minus_pb = ((__cil_tmp5 + __cil_tmp6) + __cil_tmp7) + __cil_tmp8;
  }
#line 395
  if (pa_minus_pb <= 0) {
#line 395
    tmp = a;
  } else {
#line 395
    tmp = b;
  }
#line 395
  return (tmp);
}
}
#line 402 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor0(uint32_t left , uint32_t *top ) 
{ 


  {
#line 405
  return (4278190080U);
}
}
#line 407 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor1(uint32_t left , uint32_t *top ) 
{ 


  {
#line 409
  return (left);
}
}
#line 411 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor2(uint32_t left , uint32_t *top ) 
{ 


  {
#line 413
  return (*(top + 0));
}
}
#line 415 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor3(uint32_t left , uint32_t *top ) 
{ 


  {
#line 417
  return (*(top + 1));
}
}
#line 419 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor4(uint32_t left , uint32_t *top ) 
{ 


  {
#line 421
  return (*(top + - 1));
}
}
#line 423 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor5(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 424
  __cil_tmp4 = Average3(left, *(top + 0), *(top + 1));
#line 424
  pred = __cil_tmp4;
  }
#line 425
  return (pred);
}
}
#line 427 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor6(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 428
  __cil_tmp4 = Average2(left, *(top + - 1));
#line 428
  pred = __cil_tmp4;
  }
#line 429
  return (pred);
}
}
#line 431 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor7(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 432
  __cil_tmp4 = Average2(left, *(top + 0));
#line 432
  pred = __cil_tmp4;
  }
#line 433
  return (pred);
}
}
#line 435 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor8(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 436
  __cil_tmp4 = Average2(*(top + - 1), *(top + 0));
#line 436
  pred = __cil_tmp4;
  }
#line 438
  return (pred);
}
}
#line 440 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor9(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 441
  __cil_tmp4 = Average2(*(top + 0), *(top + 1));
#line 441
  pred = __cil_tmp4;
  }
#line 443
  return (pred);
}
}
#line 445 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor10(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 446
  __cil_tmp4 = Average4(left, *(top + - 1), *(top + 0), *(top + 1));
#line 446
  pred = __cil_tmp4;
  }
#line 447
  return (pred);
}
}
#line 449 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor11(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 450
  __cil_tmp4 = Select(*(top + 0), left, *(top + - 1));
#line 450
  pred = __cil_tmp4;
  }
#line 451
  return (pred);
}
}
#line 453 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor12(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 454
  __cil_tmp4 = ClampedAddSubtractFull(left, *(top + 0), *(top + - 1));
#line 454
  pred = __cil_tmp4;
  }
#line 455
  return (pred);
}
}
#line 457 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static uint32_t Predictor13(uint32_t left , uint32_t *top ) 
{ 
  uint32_t pred ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 458
  __cil_tmp4 = ClampedAddSubtractHalf(left, *(top + 0), *(top + - 1));
#line 458
  pred = __cil_tmp4;
  }
#line 459
  return (pred);
}
}
#line 463 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static PredictorFunc kPredictors[16]  = 
#line 463
  {      & Predictor0,      & Predictor1,      & Predictor2,      & Predictor3, 
        & Predictor4,      & Predictor5,      & Predictor6,      & Predictor7, 
        & Predictor8,      & Predictor9,      & Predictor10,      & Predictor11, 
        & Predictor12,      & Predictor13,      & Predictor0,      & Predictor0};
#line 472 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static float PredictionCostSpatial(int const   *counts , int weight_0 , double exp_val ) 
{ 
  int significant_symbols ;
  double exp_decay_factor ;
  double bits ;
  int i ;

  {
#line 474
  significant_symbols = 16;
#line 475
  exp_decay_factor = 0.6;
#line 476
  bits = (double )(weight_0 * *(counts + 0));
#line 478
  i = 1;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (i < significant_symbols)) {
#line 478
      goto while_break;
    }
#line 479
    bits += exp_val * (double )(*(counts + i) + *(counts + (256 - i)));
#line 480
    exp_val *= exp_decay_factor;
#line 478
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return ((float )(- 0.100000000001 * bits));
}
}
#line 486 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static float CombinedShannonEntropy(int const   *X , int const   *Y , int n ) 
{ 
  int i ;
  double retval ;
  int sumX ;
  int sumXY ;
  int x ;
  int xy ;
  float __cil_tmp10 ;
  float __cil_tmp11 ;
  float __cil_tmp12 ;
  float __cil_tmp13 ;

  {
#line 489
  retval = 0.;
#line 490
  sumX = 0;
#line 490
  sumXY = 0;
#line 491
  i = 0;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (! (i < n)) {
#line 491
      goto while_break;
    }
#line 492
    x = *(X + i);
#line 493
    xy = *(X + i) + *(Y + i);
#line 494
    if (x != 0) {
      {
#line 495
      sumX += x;
#line 496
      __cil_tmp10 = VP8LFastSLog2(x);
      }
#line 496
      retval -= (double )__cil_tmp10;
    }
#line 498
    if (xy != 0) {
      {
#line 499
      sumXY += xy;
#line 500
      __cil_tmp11 = VP8LFastSLog2(xy);
      }
#line 500
      retval -= (double )__cil_tmp11;
    }
#line 491
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 503
  __cil_tmp13 = VP8LFastSLog2(sumXY);
  }
  {
#line 503
  __cil_tmp12 = VP8LFastSLog2(sumX);
  }
#line 503
  retval += (double )(__cil_tmp12 + __cil_tmp13);
#line 504
  return ((float )retval);
}
}
#line 507 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static float PredictionCostSpatialHistogram(int accumulated[4][256] , int tile[4][256] ) 
{ 
  int i ;
  double retval ;
  double kExpValue ;
  float __cil_tmp6 ;
  float __cil_tmp7 ;

  {
#line 510
  retval = (double )0;
#line 511
  i = 0;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 511
    if (! (i < 4)) {
#line 511
      goto while_break;
    }
    {
#line 512
    kExpValue = 0.94;
#line 513
    __cil_tmp6 = PredictionCostSpatial((int const   *)((int *)tile[i]), 1, kExpValue);
    }
    {
#line 513
    retval += (double )__cil_tmp6;
#line 514
    __cil_tmp7 = CombinedShannonEntropy((int const   *)((int *)tile[i]), (int const   *)((int *)accumulated[i]),
                                        256);
    }
#line 514
    retval += (double )__cil_tmp7;
#line 511
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 516
  return ((float )retval);
}
}
#line 519 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static int GetBestPredictorForTile(int width , int height , int tile_x , int tile_y ,
                                   int bits , int accumulated[4][256] , uint32_t *argb_scratch ) 
{ 
  int kNumPredModes ;
  int col_start ;
  int row_start ;
  int tile_size ;
  int ymax ;
  int tmp ;
  int xmax ;
  int tmp___0 ;
  int histo[4][256] ;
  float best_diff ;
  int best_mode ;
  int mode ;
  uint32_t *current_row ;
  PredictorFunc pred_func ;
  float cur_diff ;
  int y ;
  int x ;
  int row ;
  uint32_t *upper_row ;
  int col ;
  uint32_t predict ;
  uint32_t predict_diff ;
  unsigned int tmp___1 ;
  uint32_t __cil_tmp31 ;
  uint32_t __cil_tmp32 ;
  float __cil_tmp33 ;

  {
#line 523
  kNumPredModes = 14;
#line 524
  col_start = tile_x << bits;
#line 525
  row_start = tile_y << bits;
#line 526
  tile_size = 1 << bits;
#line 527
  if (tile_size <= height - row_start) {
#line 527
    tmp = tile_size;
  } else {
#line 527
    tmp = height - row_start;
  }
#line 527
  ymax = tmp;
#line 529
  if (tile_size <= width - col_start) {
#line 529
    tmp___0 = tile_size;
  } else {
#line 529
    tmp___0 = width - col_start;
  }
#line 529
  xmax = tmp___0;
#line 532
  best_diff = 1.00000001505e+30f;
#line 533
  best_mode = 0;
#line 536
  mode = 0;
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (! (mode < kNumPredModes)) {
#line 536
      goto while_break;
    }
    {
#line 537
    current_row = argb_scratch;
#line 538
    pred_func = kPredictors[mode];
#line 541
    memset(& histo[0][0], 0, sizeof(histo));
#line 542
    y = 0;
    }
    {
#line 542
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 542
      if (! (y < ymax)) {
#line 542
        goto while_break___0;
      }
#line 544
      row = row_start + y;
#line 545
      upper_row = current_row;
#line 546
      current_row = upper_row + width;
#line 547
      x = 0;
      {
#line 547
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 547
        if (! (x < xmax)) {
#line 547
          goto while_break___1;
        }
#line 548
        col = col_start + x;
#line 551
        if (row == 0) {
#line 552
          if (col == 0) {
#line 552
            tmp___1 = 4278190080U;
          } else {
#line 552
            tmp___1 = *(current_row + (col - 1));
          }
#line 552
          predict = tmp___1;
        } else
#line 553
        if (col == 0) {
#line 554
          predict = *(upper_row + col);
        } else {
          {
#line 556
          predict = (*pred_func)(*(current_row + (col - 1)), upper_row + col);
          }
        }
        {
#line 558
        predict_diff = VP8LSubPixels(*(current_row + col), predict);
#line 559
        (histo[0][predict_diff >> 24]) ++;
#line 560
        (histo[1][(predict_diff >> 16) & 255U]) ++;
#line 561
        (histo[2][(predict_diff >> 8) & 255U]) ++;
#line 562
        (histo[3][predict_diff & 255U]) ++;
        }
#line 547
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 542
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 565
    cur_diff = PredictionCostSpatialHistogram(accumulated, (int (*)[256])histo);
    }
#line 566
    if (cur_diff < best_diff) {
#line 567
      best_diff = cur_diff;
#line 568
      best_mode = mode;
    }
#line 536
    mode ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 572
  return (best_mode);
}
}
#line 575 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void CopyTileWithPrediction(int width , int height , int tile_x , int tile_y ,
                                   int bits , int mode , uint32_t *argb_scratch ,
                                   uint32_t *argb ) 
{ 
  int col_start ;
  int row_start ;
  int tile_size ;
  int ymax ;
  int tmp ;
  int xmax ;
  int tmp___0 ;
  PredictorFunc pred_func ;
  uint32_t *current_row ;
  int y ;
  int x ;
  int row ;
  uint32_t *upper_row ;
  int col ;
  int pix ;
  uint32_t predict ;
  unsigned int tmp___1 ;
  uint32_t __cil_tmp26 ;
  uint32_t __cil_tmp27 ;

  {
#line 579
  col_start = tile_x << bits;
#line 580
  row_start = tile_y << bits;
#line 581
  tile_size = 1 << bits;
#line 582
  if (tile_size <= height - row_start) {
#line 582
    tmp = tile_size;
  } else {
#line 582
    tmp = height - row_start;
  }
#line 582
  ymax = tmp;
#line 584
  if (tile_size <= width - col_start) {
#line 584
    tmp___0 = tile_size;
  } else {
#line 584
    tmp___0 = width - col_start;
  }
#line 584
  xmax = tmp___0;
#line 586
  pred_func = kPredictors[mode];
#line 587
  current_row = argb_scratch;
#line 590
  y = 0;
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (! (y < ymax)) {
#line 590
      goto while_break;
    }
#line 592
    row = row_start + y;
#line 593
    upper_row = current_row;
#line 594
    current_row = upper_row + width;
#line 595
    x = 0;
    {
#line 595
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 595
      if (! (x < xmax)) {
#line 595
        goto while_break___0;
      }
#line 596
      col = col_start + x;
#line 597
      pix = row * width + col;
#line 599
      if (row == 0) {
#line 600
        if (col == 0) {
#line 600
          tmp___1 = 4278190080U;
        } else {
#line 600
          tmp___1 = *(current_row + (col - 1));
        }
#line 600
        predict = tmp___1;
      } else
#line 601
      if (col == 0) {
#line 602
        predict = *(upper_row + col);
      } else {
        {
#line 604
        predict = (*pred_func)(*(current_row + (col - 1)), upper_row + col);
        }
      }
      {
#line 606
      *(argb + pix) = VP8LSubPixels(*(current_row + col), predict);
      }
#line 595
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 590
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 611 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
void VP8LResidualImage(int width , int height , int bits , uint32_t *argb , uint32_t *argb_scratch ,
                       uint32_t *image ) 
{ 
  int max_tile_size ;
  int tiles_per_row ;
  uint32_t __cil_tmp9 ;
  int tiles_per_col ;
  uint32_t __cil_tmp11 ;
  uint32_t *upper_row ;
  uint32_t *current_tile_rows ;
  int tile_y ;
  int histo[4][256] ;
  int tile_y_offset ;
  int this_tile_height ;
  int tmp ;
  int tile_x ;
  int pred ;
  int y ;
  int tile_x_offset ;
  int all_x_max ;
  int __cil_tmp24 ;
  int ix ;
  int all_x ;
  int all_y ;
  uint32_t a ;

  {
  {
#line 614
  max_tile_size = 1 << bits;
#line 615
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )bits);
#line 615
  tiles_per_row = (int )__cil_tmp9;
#line 616
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )height, (uint32_t )bits);
#line 616
  tiles_per_col = (int )__cil_tmp11;
#line 617
  upper_row = argb_scratch;
#line 618
  current_tile_rows = argb_scratch + width;
#line 621
  memset((int (*)[256])histo, 0, sizeof(histo));
#line 622
  tile_y = 0;
  }
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (tile_y < tiles_per_col)) {
#line 622
      goto while_break;
    }
#line 623
    tile_y_offset = tile_y * max_tile_size;
#line 624
    if (tile_y < tiles_per_col - 1) {
#line 624
      tmp = max_tile_size;
    } else {
#line 624
      tmp = height - tile_y_offset;
    }
#line 624
    this_tile_height = tmp;
#line 627
    if (tile_y > 0) {
      {
#line 628
      memcpy(upper_row, current_tile_rows + (max_tile_size - 1) * width, (unsigned long )width * sizeof(*upper_row));
      }
    }
    {
#line 631
    memcpy(current_tile_rows, argb + tile_y_offset * width, (unsigned long )(this_tile_height * width) * sizeof(*current_tile_rows));
#line 633
    tile_x = 0;
    }
    {
#line 633
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 633
      if (! (tile_x < tiles_per_row)) {
#line 633
        goto while_break___0;
      }
#line 636
      tile_x_offset = tile_x * max_tile_size;
#line 637
      all_x_max = tile_x_offset + max_tile_size;
#line 638
      if (all_x_max > width) {
#line 639
        all_x_max = width;
      }
      {
#line 641
      pred = GetBestPredictorForTile(width, height, tile_x, tile_y, bits, (int (*)[256])histo,
                                     argb_scratch);
#line 643
      *(image + (tile_y * tiles_per_row + tile_x)) = 4278190080U | (unsigned int )(pred << 8);
#line 644
      CopyTileWithPrediction(width, height, tile_x, tile_y, bits, pred, argb_scratch,
                             argb);
#line 646
      y = 0;
      }
      {
#line 646
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 646
        if (! (y < max_tile_size)) {
#line 646
          goto while_break___1;
        }
#line 649
        all_y = tile_y_offset + y;
#line 650
        if (all_y >= height) {
#line 651
          goto while_break___1;
        }
#line 653
        ix = all_y * width + tile_x_offset;
#line 654
        all_x = tile_x_offset;
        {
#line 654
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 654
          if (! (all_x < all_x_max)) {
#line 654
            goto while_break___2;
          }
#line 655
          a = *(argb + ix);
#line 656
          (histo[0][a >> 24]) ++;
#line 657
          (histo[1][(a >> 16) & 255U]) ++;
#line 658
          (histo[2][(a >> 8) & 255U]) ++;
#line 659
          (histo[3][a & 255U]) ++;
#line 654
          ix ++;
#line 654
          all_x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 646
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 633
      tile_x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 622
    tile_y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 667 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void PredictorInverseTransform(VP8LTransform *transform , int y_start , int y_end ,
                                      uint32_t *data ) 
{ 
  int width ;
  int x ;
  uint32_t pred0 ;
  uint32_t __cil_tmp8 ;
  uint32_t pred1 ;
  uint32_t __cil_tmp10 ;
  int y ;
  int mask ;
  int tiles_per_row ;
  uint32_t __cil_tmp14 ;
  uint32_t *pred_mode_base ;
  int x___0 ;
  uint32_t pred2 ;
  uint32_t __cil_tmp18 ;
  uint32_t *pred_mode_src ;
  PredictorFunc pred_func ;
  uint32_t *__cil_tmp21 ;
  uint32_t pred ;
  uint32_t *__cil_tmp23 ;
  uint32_t __cil_tmp24 ;

  {
#line 669
  width = transform->xsize_;
#line 670
  if (y_start == 0) {
    {
#line 672
    __cil_tmp8 = Predictor0(*(data + - 1), (uint32_t *)((void *)0));
#line 672
    pred0 = __cil_tmp8;
#line 673
    AddPixelsEq(data, pred0);
#line 674
    x = 1;
    }
    {
#line 674
    while (1) {
      while_continue: /* CIL Label */ ;
#line 674
      if (! (x < width)) {
#line 674
        goto while_break;
      }
      {
#line 675
      __cil_tmp10 = Predictor1(*(data + (x - 1)), (uint32_t *)((void *)0));
#line 675
      pred1 = __cil_tmp10;
#line 676
      AddPixelsEq(data + x, pred1);
      }
#line 674
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 678
    data += width;
#line 679
    y_start ++;
  }
  {
#line 683
  y = y_start;
#line 684
  mask = (1 << transform->bits_) - 1;
#line 685
  __cil_tmp14 = VP8LSubSampleSize((uint32_t )width, (uint32_t )transform->bits_);
#line 685
  tiles_per_row = (int )__cil_tmp14;
#line 686
  pred_mode_base = transform->data_ + (y >> transform->bits_) * tiles_per_row;
  }
  {
#line 689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 689
    if (! (y < y_end)) {
#line 689
      goto while_break___0;
    }
    {
#line 691
    __cil_tmp18 = Predictor2(*(data + - 1), data - width);
#line 691
    pred2 = __cil_tmp18;
#line 692
    pred_mode_src = pred_mode_base;
#line 696
    AddPixelsEq(data, pred2);
#line 699
    __cil_tmp21 = pred_mode_src;
#line 699
    pred_mode_src ++;
#line 699
    pred_func = kPredictors[(*__cil_tmp21 >> 8) & 15U];
#line 700
    x___0 = 1;
    }
    {
#line 700
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 700
      if (! (x___0 < width)) {
#line 700
        goto while_break___1;
      }
#line 702
      if ((x___0 & mask) == 0) {
#line 703
        __cil_tmp23 = pred_mode_src;
#line 703
        pred_mode_src ++;
#line 703
        pred_func = kPredictors[(*__cil_tmp23 >> 8) & 15U];
      }
      {
#line 705
      pred = (*pred_func)(*(data + (x___0 - 1)), (data + x___0) - width);
#line 706
      AddPixelsEq(data + x___0, pred);
      }
#line 700
      x___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 708
    data += width;
#line 709
    y ++;
#line 710
    if ((y & mask) == 0) {
#line 711
      pred_mode_base += tiles_per_row;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 717 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
void VP8LSubtractGreenFromBlueAndRed(uint32_t *argb_data , int num_pixs ) 
{ 
  int i ;
  uint32_t argb ;
  uint32_t green ;
  uint32_t new_r ;
  uint32_t new_b ;

  {
#line 718
  i = 0;
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 732
    if (! (i < num_pixs)) {
#line 732
      goto while_break;
    }
#line 733
    argb = *(argb_data + i);
#line 734
    green = (argb >> 8) & 255U;
#line 735
    new_r = (((argb >> 16) & 255U) - green) & 255U;
#line 736
    new_b = ((argb & 255U) - green) & 255U;
#line 737
    *(argb_data + i) = ((argb & 4278255360U) | (new_r << 16)) | new_b;
#line 732
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 743 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void AddGreenToBlueAndRed(VP8LTransform *transform , int y_start , int y_end ,
                                 uint32_t *data ) 
{ 
  int width ;
  uint32_t *data_end ;
  uint32_t argb ;
  uint32_t green ;
  uint32_t red_blue ;
  uint32_t *__cil_tmp10 ;

  {
#line 745
  width = transform->xsize_;
#line 746
  data_end = data + (y_end - y_start) * width;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (data < data_end)) {
#line 760
      goto while_break;
    }
#line 761
    argb = *data;
#line 762
    green = (argb >> 8) & 255U;
#line 763
    red_blue = argb & 16711935U;
#line 764
    red_blue += (green << 16) | green;
#line 765
    red_blue &= 16711935U;
#line 766
    __cil_tmp10 = data;
#line 766
    data ++;
#line 766
    *__cil_tmp10 = (argb & 4278255360U) | red_blue;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 778 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static void MultipliersClear(Multipliers *m ) 
{ 


  {
#line 779
  m->green_to_red_ = (uint8_t )0;
#line 780
  m->green_to_blue_ = (uint8_t )0;
#line 781
  m->red_to_blue_ = (uint8_t )0;
  return;
}
}
#line 784 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t ColorTransformDelta(int8_t color_pred , int8_t color ) 
{ 


  {
#line 786
  return ((uint32_t )((int )color_pred * (int )color) >> 5);
}
}
#line 789 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static void ColorCodeToMultipliers(uint32_t color_code , Multipliers *m ) 
{ 


  {
#line 791
  m->green_to_red_ = (uint8_t )(color_code & 255U);
#line 792
  m->green_to_blue_ = (uint8_t )((color_code >> 8) & 255U);
#line 793
  m->red_to_blue_ = (uint8_t )((color_code >> 16) & 255U);
  return;
}
}
#line 796 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t MultipliersToColorCode(Multipliers *m ) 
{ 


  {
#line 797
  return (((4278190080U | ((uint32_t )m->red_to_blue_ << 16)) | ((uint32_t )m->green_to_blue_ << 8)) | (unsigned int )m->green_to_red_);
}
}
#line 803 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint32_t TransformColor(Multipliers *m , uint32_t argb , int inverse ) 
{ 
  uint32_t green ;
  uint32_t red ;
  uint32_t new_red ;
  uint32_t new_blue ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint32_t __cil_tmp13 ;

  {
#line 805
  green = argb >> 8;
#line 806
  red = argb >> 16;
#line 807
  new_red = red;
#line 808
  new_blue = argb;
#line 810
  if (inverse) {
    {
#line 811
    __cil_tmp8 = ColorTransformDelta((int8_t )m->green_to_red_, (int8_t )green);
    }
    {
#line 811
    new_red += __cil_tmp8;
#line 812
    new_red &= (unsigned int )255;
#line 813
    __cil_tmp9 = ColorTransformDelta((int8_t )m->green_to_blue_, (int8_t )green);
    }
    {
#line 813
    new_blue += __cil_tmp9;
#line 814
    __cil_tmp10 = ColorTransformDelta((int8_t )m->red_to_blue_, (int8_t )new_red);
    }
#line 814
    new_blue += __cil_tmp10;
#line 815
    new_blue &= (unsigned int )255;
  } else {
    {
#line 817
    __cil_tmp11 = ColorTransformDelta((int8_t )m->green_to_red_, (int8_t )green);
    }
    {
#line 817
    new_red -= __cil_tmp11;
#line 818
    new_red &= (unsigned int )255;
#line 819
    __cil_tmp12 = ColorTransformDelta((int8_t )m->green_to_blue_, (int8_t )green);
    }
    {
#line 819
    new_blue -= __cil_tmp12;
#line 820
    __cil_tmp13 = ColorTransformDelta((int8_t )m->red_to_blue_, (int8_t )red);
    }
#line 820
    new_blue -= __cil_tmp13;
#line 821
    new_blue &= (unsigned int )255;
  }
#line 823
  return (((argb & 4278255360U) | (new_red << 16)) | new_blue);
}
}
#line 826 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint8_t TransformColorRed(uint8_t green_to_red , uint32_t argb ) 
{ 
  uint32_t green ;
  uint32_t new_red ;
  uint32_t __cil_tmp5 ;

  {
  {
#line 828
  green = argb >> 8;
#line 829
  new_red = argb >> 16;
#line 830
  __cil_tmp5 = ColorTransformDelta((int8_t )green_to_red, (int8_t )green);
  }
#line 830
  new_red -= __cil_tmp5;
#line 831
  return ((uint8_t )(new_red & 255U));
}
}
#line 834 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static uint8_t TransformColorBlue(uint8_t green_to_blue , uint8_t red_to_blue ,
                                           uint32_t argb ) 
{ 
  uint32_t green ;
  uint32_t red ;
  uint8_t new_blue ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;

  {
  {
#line 837
  green = argb >> 8;
#line 838
  red = argb >> 16;
#line 839
  new_blue = (uint8_t )argb;
#line 840
  __cil_tmp7 = ColorTransformDelta((int8_t )green_to_blue, (int8_t )green);
  }
  {
#line 840
  new_blue -= __cil_tmp7;
#line 841
  __cil_tmp8 = ColorTransformDelta((int8_t )red_to_blue, (int8_t )red);
  }
#line 841
  new_blue -= __cil_tmp8;
#line 842
  return ((uint8_t )((int )new_blue & 255));
}
}
#line 845 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
__inline static int SkipRepeatedPixels(uint32_t *argb , int ix , int xsize ) 
{ 
  uint32_t v ;

  {
#line 847
  v = *(argb + ix);
#line 848
  if (ix >= xsize + 3) {
#line 849
    if (v == *(argb + (ix - xsize))) {
#line 849
      if (*(argb + (ix - 1)) == *(argb + ((ix - xsize) - 1))) {
#line 849
        if (*(argb + (ix - 2)) == *(argb + ((ix - xsize) - 2))) {
#line 849
          if (*(argb + (ix - 3)) == *(argb + ((ix - xsize) - 3))) {
#line 853
            return (1);
          }
        }
      }
    }
#line 855
    return ((v == *(argb + (ix - 3)) && v == *(argb + (ix - 2))) && v == *(argb + (ix - 1)));
  } else
#line 856
  if (ix >= 3) {
#line 857
    return ((v == *(argb + (ix - 3)) && v == *(argb + (ix - 2))) && v == *(argb + (ix - 1)));
  }
#line 859
  return (0);
}
}
#line 862 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static float PredictionCostCrossColor(int const   accumulated[256] , int const   counts[256] ) 
{ 
  static double kExpValue ;
  float __cil_tmp4 ;
  float __cil_tmp5 ;

  {
  {
#line 866
  kExpValue = 2.4;
#line 867
  __cil_tmp5 = PredictionCostSpatial(counts, 3, kExpValue);
  }
  {
#line 867
  __cil_tmp4 = CombinedShannonEntropy(counts, accumulated, 256);
  }
#line 867
  return (__cil_tmp4 + __cil_tmp5);
}
}
#line 871 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static Multipliers GetBestColorTransformForTile(int tile_x , int tile_y , int bits ,
                                                Multipliers prevX , Multipliers prevY ,
                                                int step , int xsize , int ysize ,
                                                int *accumulated_red_histo , int *accumulated_blue_histo ,
                                                uint32_t *argb ) 
{ 
  float best_diff ;
  float cur_diff ;
  int halfstep ;
  int max_tile_size ;
  int tile_y_offset ;
  int tile_x_offset ;
  int green_to_red ;
  int green_to_blue ;
  int red_to_blue ;
  int all_x_max ;
  int all_y_max ;
  Multipliers best_tx ;
  int histo[256] ;
  unsigned int tmp ;
  int all_y ;
  int ix ;
  int all_x ;
  int __cil_tmp29 ;
  uint8_t __cil_tmp30 ;
  float __cil_tmp31 ;
  int all_y___0 ;
  int histo___0[256] ;
  unsigned int tmp___0 ;
  int all_x___0 ;
  int ix___0 ;
  int __cil_tmp37 ;
  uint8_t __cil_tmp38 ;
  float __cil_tmp39 ;

  {
  {
#line 879
  best_diff = 1.00000001505e+30f;
#line 881
  halfstep = step / 2;
#line 882
  max_tile_size = 1 << bits;
#line 883
  tile_y_offset = tile_y * max_tile_size;
#line 884
  tile_x_offset = tile_x * max_tile_size;
#line 888
  all_x_max = tile_x_offset + max_tile_size;
#line 889
  all_y_max = tile_y_offset + max_tile_size;
#line 891
  MultipliersClear(& best_tx);
  }
#line 892
  if (all_x_max > xsize) {
#line 893
    all_x_max = xsize;
  }
#line 895
  if (all_y_max > ysize) {
#line 896
    all_y_max = ysize;
  }
#line 899
  green_to_red = - 64;
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 899
    if (! (green_to_red <= 64)) {
#line 899
      goto while_break;
    }
#line 900
    histo[0] = 0;
#line 900
    tmp = (unsigned int )1;
    {
#line 900
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 900
      if (tmp >= 256) {
#line 900
        goto while_break___0;
      }
#line 900
      histo[tmp] = 0;
#line 900
      tmp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 903
    all_y = tile_y_offset;
    {
#line 903
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 903
      if (! (all_y < all_y_max)) {
#line 903
        goto while_break___1;
      }
#line 904
      ix = all_y * xsize + tile_x_offset;
#line 906
      all_x = tile_x_offset;
      {
#line 906
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 906
        if (! (all_x < all_x_max)) {
#line 906
          goto while_break___2;
        }
        {
#line 907
        __cil_tmp29 = SkipRepeatedPixels(argb, ix, xsize);
        }
#line 907
        if (__cil_tmp29) {
#line 908
          goto while_continue___2;
        }
        {
#line 910
        __cil_tmp30 = TransformColorRed((uint8_t )green_to_red, *(argb + ix));
        }
#line 910
        (histo[__cil_tmp30]) ++;
#line 906
        ix ++;
#line 906
        all_x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 903
      all_y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 913
    cur_diff = PredictionCostCrossColor((int const   [256])(accumulated_red_histo + 0),
                                        (int const   [256])(& histo[0]));
    }
#line 914
    if ((int )((uint8_t )green_to_red) == (int )prevX.green_to_red_) {
#line 915
      cur_diff -= (float )3;
    }
#line 917
    if ((int )((uint8_t )green_to_red) == (int )prevY.green_to_red_) {
#line 918
      cur_diff -= (float )3;
    }
#line 920
    if (green_to_red == 0) {
#line 921
      cur_diff -= (float )3;
    }
#line 923
    if (cur_diff < best_diff) {
#line 924
      best_diff = cur_diff;
#line 925
      best_tx.green_to_red_ = (uint8_t )green_to_red;
    }
#line 899
    green_to_red += halfstep;
  }
  while_break: /* CIL Label */ ;
  }
#line 928
  best_diff = 1.00000001505e+30f;
#line 929
  green_to_blue = - 32;
  {
#line 929
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 929
    if (! (green_to_blue <= 32)) {
#line 929
      goto while_break___3;
    }
#line 930
    red_to_blue = - 32;
    {
#line 930
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 930
      if (! (red_to_blue <= 32)) {
#line 930
        goto while_break___4;
      }
#line 932
      histo___0[0] = 0;
#line 932
      tmp___0 = (unsigned int )1;
      {
#line 932
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 932
        if (tmp___0 >= 256) {
#line 932
          goto while_break___5;
        }
#line 932
        histo___0[tmp___0] = 0;
#line 932
        tmp___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 933
      all_y___0 = tile_y_offset;
      {
#line 933
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 933
        if (! (all_y___0 < all_y_max)) {
#line 933
          goto while_break___6;
        }
#line 935
        ix___0 = all_y___0 * xsize + tile_x_offset;
#line 936
        all_x___0 = tile_x_offset;
        {
#line 936
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 936
          if (! (all_x___0 < all_x_max)) {
#line 936
            goto while_break___7;
          }
          {
#line 937
          __cil_tmp37 = SkipRepeatedPixels(argb, ix___0, xsize);
          }
#line 937
          if (__cil_tmp37) {
#line 938
            goto while_continue___7;
          }
          {
#line 940
          __cil_tmp38 = TransformColorBlue((uint8_t )green_to_blue, (uint8_t )red_to_blue,
                                           *(argb + ix___0));
          }
#line 940
          (histo___0[__cil_tmp38]) ++;
#line 936
          ix___0 ++;
#line 936
          all_x___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 933
        all_y___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 943
      cur_diff = PredictionCostCrossColor((int const   [256])(accumulated_blue_histo + 0),
                                          (int const   [256])(& histo___0[0]));
      }
#line 945
      if ((int )((uint8_t )green_to_blue) == (int )prevX.green_to_blue_) {
#line 946
        cur_diff -= (float )3;
      }
#line 948
      if ((int )((uint8_t )green_to_blue) == (int )prevY.green_to_blue_) {
#line 949
        cur_diff -= (float )3;
      }
#line 951
      if ((int )((uint8_t )red_to_blue) == (int )prevX.red_to_blue_) {
#line 952
        cur_diff -= (float )3;
      }
#line 954
      if ((int )((uint8_t )red_to_blue) == (int )prevY.red_to_blue_) {
#line 955
        cur_diff -= (float )3;
      }
#line 957
      if (green_to_blue == 0) {
#line 958
        cur_diff -= (float )3;
      }
#line 960
      if (red_to_blue == 0) {
#line 961
        cur_diff -= (float )3;
      }
#line 963
      if (cur_diff < best_diff) {
#line 964
        best_diff = cur_diff;
#line 965
        best_tx.green_to_blue_ = (uint8_t )green_to_blue;
#line 966
        best_tx.red_to_blue_ = (uint8_t )red_to_blue;
      }
#line 930
      red_to_blue += step;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 929
    green_to_blue += step;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 970
  return (best_tx);
}
}
#line 973 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void CopyTileWithColorTransform(int xsize , int ysize , int tile_x , int tile_y ,
                                       int bits , Multipliers color_transform , uint32_t *argb ) 
{ 
  int y ;
  int xscan ;
  int yscan ;
  int ix ;
  int end_ix ;
  uint32_t __cil_tmp13 ;

  {
#line 978
  xscan = 1 << bits;
#line 979
  yscan = 1 << bits;
#line 980
  tile_x <<= bits;
#line 981
  tile_y <<= bits;
#line 982
  if (xscan > xsize - tile_x) {
#line 983
    xscan = xsize - tile_x;
  }
#line 985
  if (yscan > ysize - tile_y) {
#line 986
    yscan = ysize - tile_y;
  }
#line 988
  yscan += tile_y;
#line 989
  y = tile_y;
  {
#line 989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 989
    if (! (y < yscan)) {
#line 989
      goto while_break;
    }
#line 990
    ix = y * xsize + tile_x;
#line 991
    end_ix = ix + xscan;
    {
#line 992
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 992
      if (! (ix < end_ix)) {
#line 992
        goto while_break___0;
      }
      {
#line 993
      *(argb + ix) = TransformColor(& color_transform, *(argb + ix), 0);
      }
#line 992
      ix ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 989
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 998 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
void VP8LColorSpaceTransform(int width , int height , int bits , int step , uint32_t *argb ,
                             uint32_t *image ) 
{ 
  int max_tile_size ;
  int tile_xsize ;
  uint32_t __cil_tmp9 ;
  int tile_ysize ;
  uint32_t __cil_tmp11 ;
  int accumulated_red_histo[256] ;
  unsigned int tmp ;
  int accumulated_blue_histo[256] ;
  unsigned int tmp___0 ;
  int tile_y ;
  int tile_x ;
  Multipliers prevX ;
  Multipliers prevY ;
  Multipliers color_transform ;
  int all_x_max ;
  int y ;
  int tile_y_offset ;
  int tile_x_offset ;
  Multipliers __cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  int ix ;
  int all_x ;
  int all_y ;

  {
  {
#line 1000
  max_tile_size = 1 << bits;
#line 1001
  __cil_tmp9 = VP8LSubSampleSize((uint32_t )width, (uint32_t )bits);
#line 1001
  tile_xsize = (int )__cil_tmp9;
#line 1002
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )height, (uint32_t )bits);
#line 1002
  tile_ysize = (int )__cil_tmp11;
#line 1003
  accumulated_red_histo[0] = 0;
  }
#line 1003
  tmp = (unsigned int )1;
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1003
    if (tmp >= 256) {
#line 1003
      goto while_break;
    }
#line 1003
    accumulated_red_histo[tmp] = 0;
#line 1003
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  accumulated_blue_histo[0] = 0;
#line 1004
  tmp___0 = (unsigned int )1;
  {
#line 1004
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1004
    if (tmp___0 >= 256) {
#line 1004
      goto while_break___0;
    }
#line 1004
    accumulated_blue_histo[tmp___0] = 0;
#line 1004
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1009
  MultipliersClear(& prevY);
#line 1010
  MultipliersClear(& prevX);
#line 1011
  tile_y = 0;
  }
  {
#line 1011
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1011
    if (! (tile_y < tile_ysize)) {
#line 1011
      goto while_break___1;
    }
#line 1012
    tile_x = 0;
    {
#line 1012
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1012
      if (! (tile_x < tile_xsize)) {
#line 1012
        goto while_break___2;
      }
#line 1016
      tile_y_offset = tile_y * max_tile_size;
#line 1017
      tile_x_offset = tile_x * max_tile_size;
#line 1018
      if (tile_y != 0) {
        {
#line 1019
        ColorCodeToMultipliers(*(image + ((tile_y * tile_xsize + tile_x) - 1)), & prevX);
#line 1020
        ColorCodeToMultipliers(*(image + ((tile_y - 1) * tile_xsize + tile_x)), & prevY);
        }
      } else
#line 1022
      if (tile_x != 0) {
        {
#line 1023
        ColorCodeToMultipliers(*(image + ((tile_y * tile_xsize + tile_x) - 1)), & prevX);
        }
      }
      {
#line 1025
      color_transform = GetBestColorTransformForTile(tile_x, tile_y, bits, prevX,
                                                     prevY, step, width, height, & accumulated_red_histo[0],
                                                     & accumulated_blue_histo[0],
                                                     argb);
#line 1032
      *(image + (tile_y * tile_xsize + tile_x)) = MultipliersToColorCode(& color_transform);
#line 1034
      CopyTileWithColorTransform(width, height, tile_x, tile_y, bits, color_transform,
                                 argb);
#line 1038
      all_x_max = tile_x_offset + max_tile_size;
      }
#line 1039
      if (all_x_max > width) {
#line 1040
        all_x_max = width;
      }
#line 1042
      y = 0;
      {
#line 1042
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1042
        if (! (y < max_tile_size)) {
#line 1042
          goto while_break___3;
        }
#line 1045
        all_y = tile_y_offset + y;
#line 1046
        if (all_y >= height) {
#line 1047
          goto while_break___3;
        }
#line 1049
        ix = all_y * width + tile_x_offset;
#line 1050
        all_x = tile_x_offset;
        {
#line 1050
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1050
          if (! (all_x < all_x_max)) {
#line 1050
            goto while_break___4;
          }
#line 1051
          if (ix >= 2) {
#line 1051
            if (*(argb + ix) == *(argb + (ix - 2))) {
#line 1051
              if (*(argb + ix) == *(argb + (ix - 1))) {
#line 1054
                goto while_continue___4;
              }
            }
          }
#line 1056
          if (ix >= width + 2) {
#line 1056
            if (*(argb + (ix - 2)) == *(argb + ((ix - width) - 2))) {
#line 1056
              if (*(argb + (ix - 1)) == *(argb + ((ix - width) - 1))) {
#line 1056
                if (*(argb + ix) == *(argb + (ix - width))) {
#line 1060
                  goto while_continue___4;
                }
              }
            }
          }
#line 1062
          (accumulated_red_histo[(*(argb + ix) >> 16) & 255U]) ++;
#line 1063
          (accumulated_blue_histo[*(argb + ix) & 255U]) ++;
#line 1050
          ix ++;
#line 1050
          all_x ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1042
        y ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1012
      tile_x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1011
    tile_y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 1071 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void ColorSpaceInverseTransform(VP8LTransform *transform , int y_start , int y_end ,
                                       uint32_t *data ) 
{ 
  int width ;
  int mask ;
  int tiles_per_row ;
  uint32_t __cil_tmp8 ;
  int y ;
  uint32_t *pred_row ;
  uint32_t *pred ;
  Multipliers m ;
  int x ;
  uint32_t *__cil_tmp14 ;
  uint32_t __cil_tmp15 ;

  {
  {
#line 1073
  width = transform->xsize_;
#line 1074
  mask = (1 << transform->bits_) - 1;
#line 1075
  __cil_tmp8 = VP8LSubSampleSize((uint32_t )width, (uint32_t )transform->bits_);
#line 1075
  tiles_per_row = (int )__cil_tmp8;
#line 1076
  y = y_start;
#line 1077
  pred_row = transform->data_ + (y >> transform->bits_) * tiles_per_row;
  }
  {
#line 1080
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1080
    if (! (y < y_end)) {
#line 1080
      goto while_break;
    }
#line 1081
    pred = pred_row;
#line 1082
    m.green_to_red_ = (uint8_t )0;
#line 1082
    m.green_to_blue_ = (uint8_t )0;
#line 1082
    m.red_to_blue_ = (uint8_t )0;
#line 1085
    x = 0;
    {
#line 1085
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1085
      if (! (x < width)) {
#line 1085
        goto while_break___0;
      }
#line 1086
      if ((x & mask) == 0) {
        {
#line 1086
        __cil_tmp14 = pred;
#line 1086
        pred ++;
#line 1086
        ColorCodeToMultipliers(*__cil_tmp14, & m);
        }
      }
      {
#line 1087
      *(data + x) = TransformColor(& m, *(data + x), 1);
      }
#line 1085
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1089
    data += width;
#line 1090
    y ++;
#line 1091
    if ((y & mask) == 0) {
#line 1091
      pred_row += tiles_per_row;
    }

  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1096 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void ColorIndexInverseTransform(VP8LTransform *transform , int y_start , int y_end ,
                                       uint32_t *src , uint32_t *dst ) 
{ 
  int y ;
  int bits_per_pixel ;
  int width ;
  uint32_t *color_map ;
  int pixels_per_byte ;
  int count_mask ;
  uint32_t bit_mask ;
  uint32_t packed_pixels ;
  int x ;
  uint32_t *__cil_tmp15 ;
  uint32_t *__cil_tmp16 ;
  int x___0 ;
  uint32_t *__cil_tmp18 ;
  uint32_t *__cil_tmp19 ;

  {
#line 1100
  bits_per_pixel = 8 >> transform->bits_;
#line 1101
  width = transform->xsize_;
#line 1102
  color_map = transform->data_;
#line 1103
  if (bits_per_pixel < 8) {
#line 1104
    pixels_per_byte = 1 << transform->bits_;
#line 1105
    count_mask = pixels_per_byte - 1;
#line 1106
    bit_mask = (uint32_t )((1 << bits_per_pixel) - 1);
#line 1107
    y = y_start;
    {
#line 1107
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1107
      if (! (y < y_end)) {
#line 1107
        goto while_break;
      }
#line 1108
      packed_pixels = (uint32_t )0;
#line 1110
      x = 0;
      {
#line 1110
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1110
        if (! (x < width)) {
#line 1110
          goto while_break___0;
        }
#line 1114
        if ((x & count_mask) == 0) {
#line 1114
          __cil_tmp15 = src;
#line 1114
          src ++;
#line 1114
          packed_pixels = (*__cil_tmp15 >> 8) & 255U;
        }
#line 1115
        __cil_tmp16 = dst;
#line 1115
        dst ++;
#line 1115
        *__cil_tmp16 = *(color_map + (packed_pixels & bit_mask));
#line 1116
        packed_pixels >>= bits_per_pixel;
#line 1110
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1107
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1120
    y = y_start;
    {
#line 1120
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1120
      if (! (y < y_end)) {
#line 1120
        goto while_break___1;
      }
#line 1122
      x___0 = 0;
      {
#line 1122
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1122
        if (! (x___0 < width)) {
#line 1122
          goto while_break___2;
        }
#line 1123
        __cil_tmp19 = src;
#line 1123
        src ++;
#line 1123
        __cil_tmp18 = dst;
#line 1123
        dst ++;
#line 1123
        *__cil_tmp18 = *(color_map + ((*__cil_tmp19 >> 8) & 255U));
#line 1122
        x___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1120
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 1129 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
void VP8LInverseTransform(VP8LTransform *transform , int row_start , int row_end ,
                          uint32_t *in , uint32_t *out ) 
{ 
  int tmp ;
  int tmp___0 ;
  int width ;
  int out_stride ;
  int in_stride ;
  uint32_t __cil_tmp11 ;
  uint32_t *src ;

  {
  {
#line 1135
  if ((unsigned int )transform->type_ == (unsigned int )2) {
#line 1135
    goto case_2;
  }
#line 1138
  if ((unsigned int )transform->type_ == (unsigned int )0) {
#line 1138
    goto case_0;
  }
#line 1148
  if ((unsigned int )transform->type_ == (unsigned int )1) {
#line 1148
    goto case_1;
  }
#line 1151
  if ((unsigned int )transform->type_ == (unsigned int )3) {
#line 1151
    goto case_3;
  }
#line 1134
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1136
  AddGreenToBlueAndRed(transform, row_start, row_end, out);
  }
#line 1137
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1139
  PredictorInverseTransform(transform, row_start, row_end, out);
  }
#line 1140
  if (row_end != transform->ysize_) {
    {
#line 1143
    width = transform->xsize_;
#line 1144
    memcpy(out - width, out + ((row_end - row_start) - 1) * width, (unsigned long )width * sizeof(*out));
    }
  }
#line 1147
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1149
  ColorSpaceInverseTransform(transform, row_start, row_end, out);
  }
#line 1150
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1152
  if (in == out) {
#line 1152
    if (transform->bits_ > 0) {
      {
#line 1158
      out_stride = (row_end - row_start) * transform->xsize_;
#line 1159
      __cil_tmp11 = VP8LSubSampleSize((uint32_t )transform->xsize_, (uint32_t )transform->bits_);
#line 1159
      in_stride = (int )((unsigned int )(row_end - row_start) * __cil_tmp11);
#line 1161
      src = (out + out_stride) - in_stride;
#line 1162
      memmove(src, out, (unsigned long )in_stride * sizeof(*src));
#line 1163
      ColorIndexInverseTransform(transform, row_start, row_end, src, out);
      }
    } else {
      {
      {
#line 1165
      ColorIndexInverseTransform(transform, row_start, row_end, in, out);
      }
      }
    }
  } else {
    {
    {
#line 1165
    ColorIndexInverseTransform(transform, row_start, row_end, in, out);
    }
    }
  }
#line 1167
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1174 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static int is_big_endian(void) 
{ 
  static union __anonunion_574 tmp ;

  {
#line 1175
  tmp.w = (uint16_t )1;
#line 1179
  return ((int )tmp.b[0] != 1);
}
}
#line 1182 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void ConvertBGRAToRGB(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  uint8_t *__cil_tmp8 ;
  uint8_t *__cil_tmp9 ;

  {
#line 1184
  src_end = src + num_pixels;
  {
#line 1185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1185
    if (! (src < src_end)) {
#line 1185
      goto while_break;
    }
#line 1186
    __cil_tmp6 = src;
#line 1186
    src ++;
#line 1186
    argb = *__cil_tmp6;
#line 1187
    __cil_tmp7 = dst;
#line 1187
    dst ++;
#line 1187
    *__cil_tmp7 = (uint8_t )((argb >> 16) & 255U);
#line 1188
    __cil_tmp8 = dst;
#line 1188
    dst ++;
#line 1188
    *__cil_tmp8 = (uint8_t )((argb >> 8) & 255U);
#line 1189
    __cil_tmp9 = dst;
#line 1189
    dst ++;
#line 1189
    *__cil_tmp9 = (uint8_t )(argb & 255U);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1193 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void ConvertBGRAToRGBA(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  uint8_t *__cil_tmp8 ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 1195
  src_end = src + num_pixels;
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1196
    if (! (src < src_end)) {
#line 1196
      goto while_break;
    }
#line 1197
    __cil_tmp6 = src;
#line 1197
    src ++;
#line 1197
    argb = *__cil_tmp6;
#line 1198
    __cil_tmp7 = dst;
#line 1198
    dst ++;
#line 1198
    *__cil_tmp7 = (uint8_t )((argb >> 16) & 255U);
#line 1199
    __cil_tmp8 = dst;
#line 1199
    dst ++;
#line 1199
    *__cil_tmp8 = (uint8_t )((argb >> 8) & 255U);
#line 1200
    __cil_tmp9 = dst;
#line 1200
    dst ++;
#line 1200
    *__cil_tmp9 = (uint8_t )(argb & 255U);
#line 1201
    __cil_tmp10 = dst;
#line 1201
    dst ++;
#line 1201
    *__cil_tmp10 = (uint8_t )((argb >> 24) & 255U);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1205 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void ConvertBGRAToRGBA4444(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t rg ;
  uint8_t ba ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 1207
  src_end = src + num_pixels;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1208
    if (! (src < src_end)) {
#line 1208
      goto while_break;
    }
#line 1209
    __cil_tmp6 = src;
#line 1209
    src ++;
#line 1209
    argb = *__cil_tmp6;
#line 1210
    rg = (uint8_t )(((argb >> 16) & 240U) | ((argb >> 12) & 15U));
#line 1211
    ba = (uint8_t )((argb & 240U) | ((argb >> 28) & 15U));
#line 1216
    __cil_tmp9 = dst;
#line 1216
    dst ++;
#line 1216
    *__cil_tmp9 = rg;
#line 1217
    __cil_tmp10 = dst;
#line 1217
    dst ++;
#line 1217
    *__cil_tmp10 = ba;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1222 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void ConvertBGRAToRGB565(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t rg ;
  uint8_t gb ;
  uint8_t *__cil_tmp9 ;
  uint8_t *__cil_tmp10 ;

  {
#line 1224
  src_end = src + num_pixels;
  {
#line 1225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1225
    if (! (src < src_end)) {
#line 1225
      goto while_break;
    }
#line 1226
    __cil_tmp6 = src;
#line 1226
    src ++;
#line 1226
    argb = *__cil_tmp6;
#line 1227
    rg = (uint8_t )(((argb >> 16) & 248U) | ((argb >> 13) & 7U));
#line 1228
    gb = (uint8_t )(((argb >> 5) & 224U) | ((argb >> 3) & 31U));
#line 1233
    __cil_tmp9 = dst;
#line 1233
    dst ++;
#line 1233
    *__cil_tmp9 = rg;
#line 1234
    __cil_tmp10 = dst;
#line 1234
    dst ++;
#line 1234
    *__cil_tmp10 = gb;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1239 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void ConvertBGRAToBGR(uint32_t *src , int num_pixels , uint8_t *dst ) 
{ 
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp6 ;
  uint8_t *__cil_tmp7 ;
  uint8_t *__cil_tmp8 ;
  uint8_t *__cil_tmp9 ;

  {
#line 1241
  src_end = src + num_pixels;
  {
#line 1242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1242
    if (! (src < src_end)) {
#line 1242
      goto while_break;
    }
#line 1243
    __cil_tmp6 = src;
#line 1243
    src ++;
#line 1243
    argb = *__cil_tmp6;
#line 1244
    __cil_tmp7 = dst;
#line 1244
    dst ++;
#line 1244
    *__cil_tmp7 = (uint8_t )(argb & 255U);
#line 1245
    __cil_tmp8 = dst;
#line 1245
    dst ++;
#line 1245
    *__cil_tmp8 = (uint8_t )((argb >> 8) & 255U);
#line 1246
    __cil_tmp9 = dst;
#line 1246
    dst ++;
#line 1246
    *__cil_tmp9 = (uint8_t )((argb >> 16) & 255U);
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1250 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
static void CopyOrSwap(uint32_t *src , int num_pixels , uint8_t *dst , int swap_on_big_endian ) 
{ 
  int __cil_tmp5 ;
  uint32_t *src_end ;
  uint32_t argb ;
  uint32_t *__cil_tmp8 ;

  {
  {
#line 1252
  __cil_tmp5 = is_big_endian();
  }
#line 1252
  if (__cil_tmp5 == swap_on_big_endian) {
#line 1253
    src_end = src + num_pixels;
    {
#line 1254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1254
      if (! (src < src_end)) {
#line 1254
        goto while_break;
      }
#line 1255
      __cil_tmp8 = src;
#line 1255
      src ++;
#line 1255
      argb = *__cil_tmp8;
      __asm__  ("asm":);
#line 1260
      *((uint32_t *)dst) = argb;
#line 1276
      dst += sizeof(argb);
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1279
    memcpy(dst, src, (unsigned long )num_pixels * sizeof(*src));
    }
  }
  return;
}
}
#line 1283 "/doner/libwebp/libwebp-v0.3.0/src/dsp/lossless.c"
void VP8LConvertFromBGRA(uint32_t *in_data , int num_pixels , enum WEBP_CSP_MODE out_colorspace ,
                         uint8_t *rgba ) 
{ 
  int tmp ;

  {
  {
#line 1286
  if ((unsigned int )out_colorspace == (unsigned int )0) {
#line 1286
    goto case_0;
  }
#line 1289
  if ((unsigned int )out_colorspace == (unsigned int )1) {
#line 1289
    goto case_1;
  }
#line 1292
  if ((unsigned int )out_colorspace == (unsigned int )7) {
#line 1292
    goto case_7;
  }
#line 1296
  if ((unsigned int )out_colorspace == (unsigned int )2) {
#line 1296
    goto case_2;
  }
#line 1299
  if ((unsigned int )out_colorspace == (unsigned int )3) {
#line 1299
    goto case_3;
  }
#line 1302
  if ((unsigned int )out_colorspace == (unsigned int )8) {
#line 1302
    goto case_8;
  }
#line 1306
  if ((unsigned int )out_colorspace == (unsigned int )4) {
#line 1306
    goto case_4;
  }
#line 1309
  if ((unsigned int )out_colorspace == (unsigned int )9) {
#line 1309
    goto case_9;
  }
#line 1313
  if ((unsigned int )out_colorspace == (unsigned int )5) {
#line 1313
    goto case_5;
  }
#line 1316
  if ((unsigned int )out_colorspace == (unsigned int )10) {
#line 1316
    goto case_10;
  }
#line 1320
  if ((unsigned int )out_colorspace == (unsigned int )6) {
#line 1320
    goto case_6;
  }
#line 1285
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1287
  ConvertBGRAToRGB(in_data, num_pixels, rgba);
  }
#line 1288
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1290
  ConvertBGRAToRGBA(in_data, num_pixels, rgba);
  }
#line 1291
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1293
  ConvertBGRAToRGBA(in_data, num_pixels, rgba);
  }
  {
#line 1294
  (*WebPApplyAlphaMultiply)(rgba, 0, num_pixels, 1, 0);
  }
#line 1295
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1297
  ConvertBGRAToBGR(in_data, num_pixels, rgba);
  }
#line 1298
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1300
  CopyOrSwap(in_data, num_pixels, rgba, 1);
  }
#line 1301
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1303
  CopyOrSwap(in_data, num_pixels, rgba, 1);
  }
  {
#line 1304
  (*WebPApplyAlphaMultiply)(rgba, 0, num_pixels, 1, 0);
  }
#line 1305
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1307
  CopyOrSwap(in_data, num_pixels, rgba, 0);
  }
#line 1308
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1310
  CopyOrSwap(in_data, num_pixels, rgba, 0);
  }
  {
#line 1311
  (*WebPApplyAlphaMultiply)(rgba, 1, num_pixels, 1, 0);
  }
#line 1312
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1314
  ConvertBGRAToRGBA4444(in_data, num_pixels, rgba);
  }
#line 1315
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1317
  ConvertBGRAToRGBA4444(in_data, num_pixels, rgba);
  }
  {
#line 1318
  (*WebPApplyAlphaMultiply4444)(rgba, num_pixels, 1, 0);
  }
#line 1319
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1321
  ConvertBGRAToRGB565(in_data, num_pixels, rgba);
  }
#line 1322
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 644 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc_neon.c"
void VP8EncDspInitNEON(void) ;
#line 646 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc_neon.c"
void VP8EncDspInitNEON(void) 
{ 


  {
  return;
}
}
#line 20 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static uint8_t clip_8b(int v ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 21
  if (! (v & -256)) {
#line 21
    tmp___0 = v;
  } else {
#line 21
    if (v < 0) {
#line 21
      tmp = 0;
    } else {
#line 21
      tmp = 255;
    }
#line 21
    tmp___0 = tmp;
  }
#line 21
  return ((uint8_t )tmp___0);
}
}
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static int clip_max(int v , int max ) 
{ 
  int tmp ;

  {
#line 25
  if (v > max) {
#line 25
    tmp = max;
  } else {
#line 25
    tmp = v;
  }
#line 25
  return (tmp);
}
}
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
int const   VP8DspScan[24]  = 
#line 32
  {      0,      4,      8,      12, 
        64,      68,      72,      76, 
        128,      132,      136,      140, 
        192,      196,      200,      204, 
        0,      4,      64,      68, 
        8,      12,      72,      76};
#line 43 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void CollectHistogram(uint8_t *ref , uint8_t *pred , int start_block , int end_block ,
                             VP8Histogram *histo ) 
{ 
  int j ;
  int k ;
  int16_t out[16] ;
  int v ;
  int __cil_tmp10 ;
  int clipped_value ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 47
  j = start_block;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (j < end_block)) {
#line 47
      goto while_break;
    }
    {
#line 51
    (*VP8FTransform)(ref + VP8DspScan[j], pred + VP8DspScan[j], (int16_t *)out);
#line 54
    k = 0;
    }
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 54
      if (! (k < 16)) {
#line 54
        goto while_break___0;
      }
      {
#line 55
      __cil_tmp10 = abs((int )out[k]);
#line 55
      v = __cil_tmp10 >> 3;
#line 56
      __cil_tmp12 = clip_max(v, 31);
#line 56
      clipped_value = __cil_tmp12;
#line 57
      (histo->distribution[clipped_value]) ++;
      }
#line 54
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 47
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 65
static uint8_t clip1___0[766] ;
#line 69 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int tables_ok___0  =    0;
#line 71 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void InitTables___0(void) 
{ 
  int i ;
  uint8_t __cil_tmp2 ;

  {
#line 72
  if (! tables_ok___0) {
#line 74
    i = - 255;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;
#line 74
      if (! (i <= 510)) {
#line 74
        goto while_break;
      }
      {
#line 75
      clip1___0[255 + i] = clip_8b(i);
      }
#line 74
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 77
    tables_ok___0 = 1;
  }
  return;
}
}
#line 88 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int const   kC1  =    20091 + (1 << 16);
#line 89 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int const   kC2  =    35468;
#line 92 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static void ITransformOne(uint8_t *ref , int16_t *in , uint8_t *dst ) 
{ 
  int C[16] ;
  int *tmp ;
  int i ;
  int a ;
  int b ;
  int c ;
  int d ;
  int16_t *__cil_tmp11 ;
  int dc ;
  int a___0 ;
  int b___0 ;
  int c___0 ;
  int d___0 ;
  uint8_t __cil_tmp17 ;
  uint8_t __cil_tmp18 ;
  uint8_t __cil_tmp19 ;
  uint8_t __cil_tmp20 ;
  int *__cil_tmp21 ;

  {
#line 96
  tmp = (int *)C;
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < 4)) {
#line 97
      goto while_break;
    }
#line 98
    a = (int )*(in + 0) + (int )*(in + 8);
#line 99
    b = (int )*(in + 0) - (int )*(in + 8);
#line 100
    c = ((int )*(in + 4) * kC2 >> 16) - ((int )*(in + 12) * kC1 >> 16);
#line 101
    d = ((int )*(in + 4) * kC1 >> 16) + ((int )*(in + 12) * kC2 >> 16);
#line 102
    *(tmp + 0) = a + d;
#line 103
    *(tmp + 1) = b + c;
#line 104
    *(tmp + 2) = b - c;
#line 105
    *(tmp + 3) = a - d;
#line 106
    tmp += 4;
#line 107
    in ++;
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  tmp = (int *)C;
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (i < 4)) {
#line 111
      goto while_break___0;
    }
    {
#line 112
    dc = *(tmp + 0) + 4;
#line 113
    a___0 = dc + *(tmp + 8);
#line 114
    b___0 = dc - *(tmp + 8);
#line 115
    c___0 = (*(tmp + 4) * kC2 >> 16) - (*(tmp + 12) * kC1 >> 16);
#line 116
    d___0 = (*(tmp + 4) * kC1 >> 16) + (*(tmp + 12) * kC2 >> 16);
#line 117
    *(dst + i * 16) = clip_8b((int )*(ref + i * 16) + ((a___0 + d___0) >> 3));
#line 118
    *(dst + (1 + i * 16)) = clip_8b((int )*(ref + (1 + i * 16)) + ((b___0 + c___0) >> 3));
#line 119
    *(dst + (2 + i * 16)) = clip_8b((int )*(ref + (2 + i * 16)) + ((b___0 - c___0) >> 3));
#line 120
    *(dst + (3 + i * 16)) = clip_8b((int )*(ref + (3 + i * 16)) + ((a___0 - d___0) >> 3));
#line 121
    tmp ++;
    }
#line 111
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 125 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void ITransform(uint8_t *ref , int16_t *in , uint8_t *dst , int do_two ) 
{ 


  {
  {
#line 127
  ITransformOne(ref, in, dst);
  }
#line 128
  if (do_two) {
    {
#line 129
    ITransformOne(ref + 4, in + 16, dst + 4);
    }
  }
  return;
}
}
#line 133 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void FTransform(uint8_t *src , uint8_t *ref , int16_t *out ) 
{ 
  int i ;
  int tmp[16] ;
  int d0 ;
  int d1 ;
  int d2 ;
  int d3 ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;

  {
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < 4)) {
#line 136
      goto while_break;
    }
#line 137
    d0 = (int )*(src + 0) - (int )*(ref + 0);
#line 138
    d1 = (int )*(src + 1) - (int )*(ref + 1);
#line 139
    d2 = (int )*(src + 2) - (int )*(ref + 2);
#line 140
    d3 = (int )*(src + 3) - (int )*(ref + 3);
#line 141
    a0 = d0 + d3;
#line 142
    a1 = d1 + d2;
#line 143
    a2 = d1 - d2;
#line 144
    a3 = d0 - d3;
#line 145
    tmp[i * 4] = (a0 + a1) << 3;
#line 146
    tmp[1 + i * 4] = ((a2 * 2217 + a3 * 5352) + 1812) >> 9;
#line 147
    tmp[2 + i * 4] = (a0 - a1) << 3;
#line 148
    tmp[3 + i * 4] = ((a3 * 2217 - a2 * 5352) + 937) >> 9;
#line 136
    ref += 16;
#line 136
    src += 16;
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 150
    if (! (i < 4)) {
#line 150
      goto while_break___0;
    }
#line 151
    a0___0 = tmp[i] + tmp[12 + i];
#line 152
    a1___0 = tmp[4 + i] + tmp[8 + i];
#line 153
    a2___0 = tmp[4 + i] - tmp[8 + i];
#line 154
    a3___0 = tmp[i] - tmp[12 + i];
#line 155
    *(out + i) = (int16_t )(((a0___0 + a1___0) + 7) >> 4);
#line 156
    *(out + (4 + i)) = (int16_t )((((a2___0 * 2217 + a3___0 * 5352) + 12000) >> 16) + (a3___0 != 0));
#line 157
    *(out + (8 + i)) = (int16_t )(((a0___0 - a1___0) + 7) >> 4);
#line 158
    *(out + (12 + i)) = (int16_t )(((a3___0 * 2217 - a2___0 * 5352) + 51000) >> 16);
#line 150
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 162 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void ITransformWHT(int16_t *in , int16_t *out ) 
{ 
  int tmp[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int dc ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;

  {
#line 165
  i = 0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < 4)) {
#line 165
      goto while_break;
    }
#line 166
    a0 = (int )*(in + i) + (int )*(in + (12 + i));
#line 167
    a1 = (int )*(in + (4 + i)) + (int )*(in + (8 + i));
#line 168
    a2 = (int )*(in + (4 + i)) - (int )*(in + (8 + i));
#line 169
    a3 = (int )*(in + i) - (int )*(in + (12 + i));
#line 170
    tmp[i] = a0 + a1;
#line 171
    tmp[8 + i] = a0 - a1;
#line 172
    tmp[4 + i] = a3 + a2;
#line 173
    tmp[12 + i] = a3 - a2;
#line 165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! (i < 4)) {
#line 175
      goto while_break___0;
    }
#line 176
    dc = tmp[i * 4] + 3;
#line 177
    a0___0 = dc + tmp[3 + i * 4];
#line 178
    a1___0 = tmp[1 + i * 4] + tmp[2 + i * 4];
#line 179
    a2___0 = tmp[1 + i * 4] - tmp[2 + i * 4];
#line 180
    a3___0 = dc - tmp[3 + i * 4];
#line 181
    *(out + 0) = (int16_t )((a0___0 + a1___0) >> 3);
#line 182
    *(out + 16) = (int16_t )((a3___0 + a2___0) >> 3);
#line 183
    *(out + 32) = (int16_t )((a0___0 - a1___0) >> 3);
#line 184
    *(out + 48) = (int16_t )((a3___0 - a2___0) >> 3);
#line 185
    out += 64;
#line 175
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 189 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void FTransformWHT(int16_t *in , int16_t *out ) 
{ 
  int tmp[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;
  int b0 ;
  int b1 ;
  int b2 ;
  int b3 ;

  {
#line 192
  i = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < 4)) {
#line 192
      goto while_break;
    }
#line 193
    a0 = ((int )*(in + 0) + (int )*(in + 32)) << 2;
#line 194
    a1 = ((int )*(in + 16) + (int )*(in + 48)) << 2;
#line 195
    a2 = ((int )*(in + 16) - (int )*(in + 48)) << 2;
#line 196
    a3 = ((int )*(in + 0) - (int )*(in + 32)) << 2;
#line 197
    tmp[i * 4] = (a0 + a1) + (a0 != 0);
#line 198
    tmp[1 + i * 4] = a3 + a2;
#line 199
    tmp[2 + i * 4] = a3 - a2;
#line 200
    tmp[3 + i * 4] = a0 - a1;
#line 192
    in += 64;
#line 192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  i = 0;
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if (! (i < 4)) {
#line 202
      goto while_break___0;
    }
#line 203
    a0___0 = tmp[i] + tmp[8 + i];
#line 204
    a1___0 = tmp[4 + i] + tmp[12 + i];
#line 205
    a2___0 = tmp[4 + i] - tmp[12 + i];
#line 206
    a3___0 = tmp[i] - tmp[8 + i];
#line 207
    b0 = a0___0 + a1___0;
#line 208
    b1 = a3___0 + a2___0;
#line 209
    b2 = a3___0 - a2___0;
#line 210
    b3 = a0___0 - a1___0;
#line 211
    *(out + i) = (int16_t )(((b0 + (b0 > 0)) + 3) >> 3);
#line 212
    *(out + (4 + i)) = (int16_t )(((b1 + (b1 > 0)) + 3) >> 3);
#line 213
    *(out + (8 + i)) = (int16_t )(((b2 + (b2 > 0)) + 3) >> 3);
#line 214
    *(out + (12 + i)) = (int16_t )(((b3 + (b3 > 0)) + 3) >> 3);
#line 202
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 226 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static void Fill(uint8_t *dst , int value , int size ) 
{ 
  int j ;

  {
#line 228
  j = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (j < size)) {
#line 228
      goto while_break;
    }
    {
#line 229
    memset(dst + j * 16, value, (unsigned long )size);
    }
#line 228
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 233 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static void VerticalPred(uint8_t *dst , uint8_t *top , int size ) 
{ 
  int j ;

  {
#line 236
  if (top) {
#line 237
    j = 0;
    {
#line 237
    while (1) {
      while_continue: /* CIL Label */ ;
#line 237
      if (! (j < size)) {
#line 237
        goto while_break;
      }
      {
#line 237
      memcpy(dst + j * 16, top, (unsigned long )size);
      }
#line 237
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 239
    Fill(dst, 127, size);
    }
  }
  return;
}
}
#line 243 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static void HorizontalPred(uint8_t *dst , uint8_t *left , int size ) 
{ 
  int j ;

  {
#line 245
  if (left) {
#line 247
    j = 0;
    {
#line 247
    while (1) {
      while_continue: /* CIL Label */ ;
#line 247
      if (! (j < size)) {
#line 247
        goto while_break;
      }
      {
#line 248
      memset(dst + j * 16, (int )*(left + j), (unsigned long )size);
      }
#line 247
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 251
    Fill(dst, 129, size);
    }
  }
  return;
}
}
#line 255 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static void TrueMotion(uint8_t *dst , uint8_t *left , uint8_t *top , int size ) 
{ 
  int y ;
  uint8_t *clip___3 ;
  uint8_t *clip_table ;
  int x ;

  {
#line 258
  if (left) {
#line 259
    if (top) {
#line 260
      clip___3 = ((uint8_t *)clip1___0 + 255) - (int )*(left + -1);
#line 261
      y = 0;
      {
#line 261
      while (1) {
        while_continue: /* CIL Label */ ;
#line 261
        if (! (y < size)) {
#line 261
          goto while_break;
        }
#line 262
        clip_table = clip___3 + (int )*(left + y);
#line 264
        x = 0;
        {
#line 264
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 264
          if (! (x < size)) {
#line 264
            goto while_break___0;
          }
#line 265
          *(dst + x) = *(clip_table + *(top + x));
#line 264
          x ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 267
        dst += 16;
#line 261
        y ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 270
      HorizontalPred(dst, left, size);
      }
    }
  } else
#line 277
  if (top) {
    {
#line 278
    VerticalPred(dst, top, size);
    }
  } else {
    {
#line 280
    Fill(dst, 129, size);
    }
  }
  return;
}
}
#line 285 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static void DCMode(uint8_t *dst , uint8_t *left , uint8_t *top , int size ,
                            int round___0 , int shift ) 
{ 
  int DC ;
  int j ;

  {
#line 288
  DC = 0;
#line 290
  if (top) {
#line 291
    j = 0;
    {
#line 291
    while (1) {
      while_continue: /* CIL Label */ ;
#line 291
      if (! (j < size)) {
#line 291
        goto while_break;
      }
#line 291
      DC += (int )*(top + j);
#line 291
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 292
    if (left) {
#line 293
      j = 0;
      {
#line 293
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 293
        if (! (j < size)) {
#line 293
          goto while_break___0;
        }
#line 293
        DC += (int )*(left + j);
#line 293
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 295
      DC += DC;
    }
#line 297
    DC = (DC + round___0) >> shift;
  } else
#line 298
  if (left) {
#line 299
    j = 0;
    {
#line 299
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 299
      if (! (j < size)) {
#line 299
        goto while_break___1;
      }
#line 299
      DC += (int )*(left + j);
#line 299
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 300
    DC += DC;
#line 301
    DC = (DC + round___0) >> shift;
  } else {
#line 303
    DC = 128;
  }
  {
#line 305
  Fill(dst, DC, size);
  }
  return;
}
}
#line 311 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void IntraChromaPreds(uint8_t *dst , uint8_t *left , uint8_t *top ) 
{ 


  {
  {
#line 314
  DCMode(dst + 1024, left, top, 8, 8, 4);
#line 315
  VerticalPred(dst + 1280, top, 8);
#line 316
  HorizontalPred(dst + 1408, left, 8);
#line 317
  TrueMotion(dst + 1152, left, top, 8);
#line 319
  dst += 8;
  }
#line 320
  if (top) {
#line 320
    top += 8;
  }
#line 321
  if (left) {
#line 321
    left += 16;
  }
  {
#line 322
  DCMode(dst + 1024, left, top, 8, 8, 4);
#line 323
  VerticalPred(dst + 1280, top, 8);
#line 324
  HorizontalPred(dst + 1408, left, 8);
#line 325
  TrueMotion(dst + 1152, left, top, 8);
  }
  return;
}
}
#line 331 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void Intra16Preds(uint8_t *dst , uint8_t *left , uint8_t *top ) 
{ 


  {
  {
#line 333
  DCMode(dst + 0, left, top, 16, 16, 5);
#line 334
  VerticalPred(dst + 512, top, 16);
#line 335
  HorizontalPred(dst + 768, left, 16);
#line 336
  TrueMotion(dst + 256, left, top, 16);
  }
  return;
}
}
#line 345 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void VE4(uint8_t *dst , uint8_t *top ) 
{ 
  uint8_t vals[4] ;
  int i ;

  {
#line 346
  vals[0] = (uint8_t )(((((int )*(top + -1) + 2 * (int )*(top + 0)) + (int )*(top + 1)) + 2) >> 2);
#line 346
  vals[1] = (uint8_t )(((((int )*(top + 0) + 2 * (int )*(top + 1)) + (int )*(top + 2)) + 2) >> 2);
#line 346
  vals[2] = (uint8_t )(((((int )*(top + 1) + 2 * (int )*(top + 2)) + (int )*(top + 3)) + 2) >> 2);
#line 346
  vals[3] = (uint8_t )(((((int )*(top + 2) + 2 * (int )*(top + 3)) + (int )*(top + 4)) + 2) >> 2);
#line 353
  i = 0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (i < 4)) {
#line 353
      goto while_break;
    }
    {
#line 354
    memcpy(dst + i * 16, (uint8_t *)vals, (unsigned long )4);
    }
#line 353
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 358 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void HE4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int L ;

  {
#line 359
  X = (int )*(top + - 1);
#line 360
  I = (int )*(top + - 2);
#line 361
  J = (int )*(top + - 3);
#line 362
  K = (int )*(top + - 4);
#line 363
  L = (int )*(top + - 5);
#line 364
  *((uint32_t *)(dst + 0)) = 16843009U * (unsigned int )((((X + 2 * I) + J) + 2) >> 2);
#line 365
  *((uint32_t *)(dst + 16)) = 16843009U * (unsigned int )((((I + 2 * J) + K) + 2) >> 2);
#line 366
  *((uint32_t *)(dst + 32)) = 16843009U * (unsigned int )((((J + 2 * K) + L) + 2) >> 2);
#line 367
  *((uint32_t *)(dst + 48)) = 16843009U * (unsigned int )((((K + 2 * L) + L) + 2) >> 2);
  return;
}
}
#line 370 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void DC4(uint8_t *dst , uint8_t *top ) 
{ 
  uint32_t dc ;
  int i ;

  {
#line 371
  dc = (uint32_t )4;
#line 373
  i = 0;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (i < 4)) {
#line 373
      goto while_break;
    }
#line 373
    dc += (unsigned int )((int )*(top + i) + (int )*(top + (-5 + i)));
#line 373
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  Fill(dst, (int )(dc >> 3), 4);
  }
  return;
}
}
#line 377 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void RD4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int L ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 378
  X = (int )*(top + - 1);
#line 379
  I = (int )*(top + - 2);
#line 380
  J = (int )*(top + - 3);
#line 381
  K = (int )*(top + - 4);
#line 382
  L = (int )*(top + - 5);
#line 383
  A = (int )*(top + 0);
#line 384
  B = (int )*(top + 1);
#line 385
  C = (int )*(top + 2);
#line 386
  D = (int )*(top + 3);
#line 387
  *(dst + 48) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 388
  *(dst + 49) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 388
  *(dst + 32) = *(dst + 49);
#line 389
  *(dst + 50) = (uint8_t )((((X + 2 * I) + J) + 2) >> 2);
#line 389
  *(dst + 33) = *(dst + 50);
#line 389
  *(dst + 16) = *(dst + 33);
#line 390
  *(dst + 51) = (uint8_t )((((A + 2 * X) + I) + 2) >> 2);
#line 390
  *(dst + 34) = *(dst + 51);
#line 390
  *(dst + 17) = *(dst + 34);
#line 390
  *(dst + 0) = *(dst + 17);
#line 391
  *(dst + 35) = (uint8_t )((((B + 2 * A) + X) + 2) >> 2);
#line 391
  *(dst + 18) = *(dst + 35);
#line 391
  *(dst + 1) = *(dst + 18);
#line 392
  *(dst + 19) = (uint8_t )((((C + 2 * B) + A) + 2) >> 2);
#line 392
  *(dst + 2) = *(dst + 19);
#line 393
  *(dst + 3) = (uint8_t )((((D + 2 * C) + B) + 2) >> 2);
  return;
}
}
#line 396 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void LD4(uint8_t *dst , uint8_t *top ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 397
  A = (int )*(top + 0);
#line 398
  B = (int )*(top + 1);
#line 399
  C = (int )*(top + 2);
#line 400
  D = (int )*(top + 3);
#line 401
  E = (int )*(top + 4);
#line 402
  F = (int )*(top + 5);
#line 403
  G = (int )*(top + 6);
#line 404
  H = (int )*(top + 7);
#line 405
  *(dst + 0) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 406
  *(dst + 16) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 406
  *(dst + 1) = *(dst + 16);
#line 407
  *(dst + 32) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 407
  *(dst + 17) = *(dst + 32);
#line 407
  *(dst + 2) = *(dst + 17);
#line 408
  *(dst + 48) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 408
  *(dst + 33) = *(dst + 48);
#line 408
  *(dst + 18) = *(dst + 33);
#line 408
  *(dst + 3) = *(dst + 18);
#line 409
  *(dst + 49) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 409
  *(dst + 34) = *(dst + 49);
#line 409
  *(dst + 19) = *(dst + 34);
#line 410
  *(dst + 50) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 410
  *(dst + 35) = *(dst + 50);
#line 411
  *(dst + 51) = (uint8_t )((((G + 2 * H) + H) + 2) >> 2);
  return;
}
}
#line 414 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void VR4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 415
  X = (int )*(top + - 1);
#line 416
  I = (int )*(top + - 2);
#line 417
  J = (int )*(top + - 3);
#line 418
  K = (int )*(top + - 4);
#line 419
  A = (int )*(top + 0);
#line 420
  B = (int )*(top + 1);
#line 421
  C = (int )*(top + 2);
#line 422
  D = (int )*(top + 3);
#line 423
  *(dst + 33) = (uint8_t )(((X + A) + 1) >> 1);
#line 423
  *(dst + 0) = *(dst + 33);
#line 424
  *(dst + 34) = (uint8_t )(((A + B) + 1) >> 1);
#line 424
  *(dst + 1) = *(dst + 34);
#line 425
  *(dst + 35) = (uint8_t )(((B + C) + 1) >> 1);
#line 425
  *(dst + 2) = *(dst + 35);
#line 426
  *(dst + 3) = (uint8_t )(((C + D) + 1) >> 1);
#line 428
  *(dst + 48) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 429
  *(dst + 32) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 430
  *(dst + 49) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 430
  *(dst + 16) = *(dst + 49);
#line 431
  *(dst + 50) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 431
  *(dst + 17) = *(dst + 50);
#line 432
  *(dst + 51) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 432
  *(dst + 18) = *(dst + 51);
#line 433
  *(dst + 19) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
  return;
}
}
#line 436 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void VL4(uint8_t *dst , uint8_t *top ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 437
  A = (int )*(top + 0);
#line 438
  B = (int )*(top + 1);
#line 439
  C = (int )*(top + 2);
#line 440
  D = (int )*(top + 3);
#line 441
  E = (int )*(top + 4);
#line 442
  F = (int )*(top + 5);
#line 443
  G = (int )*(top + 6);
#line 444
  H = (int )*(top + 7);
#line 445
  *(dst + 0) = (uint8_t )(((A + B) + 1) >> 1);
#line 446
  *(dst + 32) = (uint8_t )(((B + C) + 1) >> 1);
#line 446
  *(dst + 1) = *(dst + 32);
#line 447
  *(dst + 33) = (uint8_t )(((C + D) + 1) >> 1);
#line 447
  *(dst + 2) = *(dst + 33);
#line 448
  *(dst + 34) = (uint8_t )(((D + E) + 1) >> 1);
#line 448
  *(dst + 3) = *(dst + 34);
#line 450
  *(dst + 16) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 451
  *(dst + 48) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 451
  *(dst + 17) = *(dst + 48);
#line 452
  *(dst + 49) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 452
  *(dst + 18) = *(dst + 49);
#line 453
  *(dst + 50) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 453
  *(dst + 19) = *(dst + 50);
#line 454
  *(dst + 35) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 455
  *(dst + 51) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
  return;
}
}
#line 458 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void HU4(uint8_t *dst , uint8_t *top ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;

  {
#line 459
  I = (int )*(top + - 2);
#line 460
  J = (int )*(top + - 3);
#line 461
  K = (int )*(top + - 4);
#line 462
  L = (int )*(top + - 5);
#line 463
  *(dst + 0) = (uint8_t )(((I + J) + 1) >> 1);
#line 464
  *(dst + 16) = (uint8_t )(((J + K) + 1) >> 1);
#line 464
  *(dst + 2) = *(dst + 16);
#line 465
  *(dst + 32) = (uint8_t )(((K + L) + 1) >> 1);
#line 465
  *(dst + 18) = *(dst + 32);
#line 466
  *(dst + 1) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 467
  *(dst + 17) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 467
  *(dst + 3) = *(dst + 17);
#line 468
  *(dst + 33) = (uint8_t )((((K + 2 * L) + L) + 2) >> 2);
#line 468
  *(dst + 19) = *(dst + 33);
#line 469
  *(dst + 51) = (uint8_t )L;
#line 469
  *(dst + 50) = *(dst + 51);
#line 469
  *(dst + 49) = *(dst + 50);
#line 469
  *(dst + 48) = *(dst + 49);
#line 469
  *(dst + 34) = *(dst + 48);
#line 469
  *(dst + 35) = *(dst + 34);
  return;
}
}
#line 473 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void HD4(uint8_t *dst , uint8_t *top ) 
{ 
  int X ;
  int I ;
  int J ;
  int K ;
  int L ;
  int A ;
  int B ;
  int C ;

  {
#line 474
  X = (int )*(top + - 1);
#line 475
  I = (int )*(top + - 2);
#line 476
  J = (int )*(top + - 3);
#line 477
  K = (int )*(top + - 4);
#line 478
  L = (int )*(top + - 5);
#line 479
  A = (int )*(top + 0);
#line 480
  B = (int )*(top + 1);
#line 481
  C = (int )*(top + 2);
#line 483
  *(dst + 18) = (uint8_t )(((I + X) + 1) >> 1);
#line 483
  *(dst + 0) = *(dst + 18);
#line 484
  *(dst + 34) = (uint8_t )(((J + I) + 1) >> 1);
#line 484
  *(dst + 16) = *(dst + 34);
#line 485
  *(dst + 50) = (uint8_t )(((K + J) + 1) >> 1);
#line 485
  *(dst + 32) = *(dst + 50);
#line 486
  *(dst + 48) = (uint8_t )(((L + K) + 1) >> 1);
#line 488
  *(dst + 3) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 489
  *(dst + 2) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 490
  *(dst + 19) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 490
  *(dst + 1) = *(dst + 19);
#line 491
  *(dst + 35) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 491
  *(dst + 17) = *(dst + 35);
#line 492
  *(dst + 51) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 492
  *(dst + 33) = *(dst + 51);
#line 493
  *(dst + 49) = (uint8_t )((((L + 2 * K) + J) + 2) >> 2);
  return;
}
}
#line 496 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void TM4(uint8_t *dst , uint8_t *top ) 
{ 
  int x ;
  int y ;
  uint8_t *clip___3 ;
  uint8_t *clip_table ;

  {
#line 498
  clip___3 = ((uint8_t *)clip1___0 + 255) - (int )*(top + -1);
#line 499
  y = 0;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (y < 4)) {
#line 499
      goto while_break;
    }
#line 500
    clip_table = clip___3 + (int )*(top + (-2 - y));
#line 501
    x = 0;
    {
#line 501
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 501
      if (! (x < 4)) {
#line 501
        goto while_break___0;
      }
#line 502
      *(dst + x) = *(clip_table + *(top + x));
#line 501
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 504
    dst += 16;
#line 499
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 514 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void Intra4Preds(uint8_t *dst , uint8_t *top ) 
{ 


  {
  {
#line 515
  DC4(dst + 1536, top);
#line 516
  TM4(dst + 1540, top);
#line 517
  VE4(dst + 1544, top);
#line 518
  HE4(dst + 1548, top);
#line 519
  RD4(dst + 1600, top);
#line 520
  VR4(dst + 1604, top);
#line 521
  LD4(dst + 1608, top);
#line 522
  VL4(dst + 1612, top);
#line 523
  HD4(dst + 1664, top);
#line 524
  HU4(dst + 1668, top);
  }
  return;
}
}
#line 530 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static int GetSSE(uint8_t *a , uint8_t *b , int w , int h ) 
{ 
  int count ;
  int y ;
  int x ;
  int diff ;

  {
#line 532
  count = 0;
#line 534
  y = 0;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (y < h)) {
#line 534
      goto while_break;
    }
#line 535
    x = 0;
    {
#line 535
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 535
      if (! (x < w)) {
#line 535
        goto while_break___0;
      }
#line 536
      diff = (int )*(a + x) - (int )*(b + x);
#line 537
      count += diff * diff;
#line 535
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 539
    a += 16;
#line 540
    b += 16;
#line 534
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (count);
}
}
#line 545 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int SSE16x16(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 546
  __cil_tmp3 = GetSSE(a, b, 16, 16);
  }
#line 546
  return (__cil_tmp3);
}
}
#line 548 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int SSE16x8(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 549
  __cil_tmp3 = GetSSE(a, b, 16, 8);
  }
#line 549
  return (__cil_tmp3);
}
}
#line 551 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int SSE8x8(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 552
  __cil_tmp3 = GetSSE(a, b, 8, 8);
  }
#line 552
  return (__cil_tmp3);
}
}
#line 554 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int SSE4x4(uint8_t *a , uint8_t *b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 555
  __cil_tmp3 = GetSSE(a, b, 4, 4);
  }
#line 555
  return (__cil_tmp3);
}
}
#line 566 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int TTransform(uint8_t *in , uint16_t *w ) 
{ 
  int sum ;
  int tmp[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;
  int b0 ;
  int b1 ;
  int b2 ;
  int b3 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 567
  sum = 0;
#line 571
  i = 0;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i < 4)) {
#line 571
      goto while_break;
    }
#line 572
    a0 = (int )*(in + 0) + (int )*(in + 2);
#line 573
    a1 = (int )*(in + 1) + (int )*(in + 3);
#line 574
    a2 = (int )*(in + 1) - (int )*(in + 3);
#line 575
    a3 = (int )*(in + 0) - (int )*(in + 2);
#line 576
    tmp[i * 4] = a0 + a1;
#line 577
    tmp[1 + i * 4] = a3 + a2;
#line 578
    tmp[2 + i * 4] = a3 - a2;
#line 579
    tmp[3 + i * 4] = a0 - a1;
#line 571
    in += 16;
#line 571
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 582
  i = 0;
  {
#line 582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 582
    if (! (i < 4)) {
#line 582
      goto while_break___0;
    }
    {
#line 583
    a0___0 = tmp[i] + tmp[8 + i];
#line 584
    a1___0 = tmp[4 + i] + tmp[12 + i];
#line 585
    a2___0 = tmp[4 + i] - tmp[12 + i];
#line 586
    a3___0 = tmp[i] - tmp[8 + i];
#line 587
    b0 = a0___0 + a1___0;
#line 588
    b1 = a3___0 + a2___0;
#line 589
    b2 = a3___0 - a2___0;
#line 590
    b3 = a0___0 - a1___0;
#line 592
    __cil_tmp18 = abs(b0);
    }
    {
#line 592
    sum += (int )*(w + 0) * __cil_tmp18;
#line 593
    __cil_tmp19 = abs(b1);
    }
    {
#line 593
    sum += (int )*(w + 4) * __cil_tmp19;
#line 594
    __cil_tmp20 = abs(b2);
    }
    {
#line 594
    sum += (int )*(w + 8) * __cil_tmp20;
#line 595
    __cil_tmp21 = abs(b3);
    }
#line 595
    sum += (int )*(w + 12) * __cil_tmp21;
#line 582
    w ++;
#line 582
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 597
  return (sum);
}
}
#line 600 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int Disto4x4(uint8_t *a , uint8_t *b , uint16_t *w ) 
{ 
  int sum1 ;
  int __cil_tmp5 ;
  int sum2 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 602
  __cil_tmp5 = TTransform(a, w);
#line 602
  sum1 = __cil_tmp5;
#line 603
  __cil_tmp7 = TTransform(b, w);
#line 603
  sum2 = __cil_tmp7;
#line 604
  __cil_tmp8 = abs(sum2 - sum1);
  }
#line 604
  return (__cil_tmp8 >> 5);
}
}
#line 607 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int Disto16x16(uint8_t *a , uint8_t *b , uint16_t *w ) 
{ 
  int D ;
  int x ;
  int y ;
  int __cil_tmp7 ;

  {
#line 609
  D = 0;
#line 611
  y = 0;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! (y < 256)) {
#line 611
      goto while_break;
    }
#line 612
    x = 0;
    {
#line 612
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 612
      if (! (x < 16)) {
#line 612
        goto while_break___0;
      }
      {
#line 613
      __cil_tmp7 = Disto4x4((a + x) + y, (b + x) + y, w);
      }
#line 613
      D += __cil_tmp7;
#line 612
      x += 4;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 611
    y += 64;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  return (D);
}
}
#line 623 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static uint8_t kZigzag___0[16]  = 
#line 623
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )4,      (uint8_t )8, 
        (uint8_t )5,      (uint8_t )2,      (uint8_t )3,      (uint8_t )6, 
        (uint8_t )9,      (uint8_t )12,      (uint8_t )13,      (uint8_t )10, 
        (uint8_t )7,      (uint8_t )11,      (uint8_t )14,      (uint8_t )15};
#line 628 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static int QuantizeBlock(int16_t in[16] , int16_t out[16] , int n , VP8Matrix *mtx ) 
{ 
  int last ;
  int j ;
  int sign ;
  int coeff ;
  int tmp ;
  int Q ;
  int iQ ;
  int B ;
  int __cil_tmp13 ;

  {
#line 630
  last = - 1;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! (n < 16)) {
#line 631
      goto while_break;
    }
#line 632
    j = (int )kZigzag___0[n];
#line 633
    sign = (int )in[j] < 0;
#line 634
    if (sign) {
#line 634
      tmp = - ((int )in[j]);
    } else {
#line 634
      tmp = (int )in[j];
    }
#line 634
    coeff = tmp + (int )mtx->sharpen_[j];
#line 635
    if (coeff > (int )mtx->zthresh_[j]) {
      {
#line 636
      Q = (int )mtx->q_[j];
#line 637
      iQ = (int )mtx->iq_[j];
#line 638
      B = (int )mtx->bias_[j];
#line 639
      __cil_tmp13 = QUANTDIV(coeff, iQ, B);
#line 639
      out[n] = (int16_t )__cil_tmp13;
      }
#line 640
      if ((int )out[n] > 2047) {
#line 640
        out[n] = (int16_t )2047;
      }
#line 641
      if (sign) {
#line 641
        out[n] = (int16_t )(- ((int )out[n]));
      }
#line 642
      in[j] = (int16_t )((int )out[n] * Q);
#line 643
      if (out[n]) {
#line 643
        last = n;
      }
    } else {
#line 645
      out[n] = (int16_t )0;
#line 646
      in[j] = (int16_t )0;
    }
#line 631
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  return (last >= 0);
}
}
#line 655 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
__inline static void Copy(uint8_t *src , uint8_t *dst , int size ) 
{ 
  int y ;

  {
#line 657
  y = 0;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! (y < size)) {
#line 657
      goto while_break;
    }
    {
#line 658
    memcpy(dst, src, (unsigned long )size);
#line 659
    src += 16;
#line 660
    dst += 16;
    }
#line 657
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 664 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
static void Copy4x4(uint8_t *src , uint8_t *dst ) 
{ 


  {
  {
#line 664
  Copy(src, dst, 4);
  }
  return;
}
}
#line 688
extern void VP8EncDspInitSSE2(void) ;
#line 691 "/doner/libwebp/libwebp-v0.3.0/src/dsp/enc.c"
void VP8EncDspInit(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 692
  InitTables___0();
#line 695
  VP8CollectHistogram = & CollectHistogram;
#line 696
  VP8ITransform = & ITransform;
#line 697
  VP8FTransform = & FTransform;
#line 698
  VP8ITransformWHT = & ITransformWHT;
#line 699
  VP8FTransformWHT = & FTransformWHT;
#line 700
  VP8EncPredLuma4 = & Intra4Preds;
#line 701
  VP8EncPredLuma16 = & Intra16Preds;
#line 702
  VP8EncPredChroma8 = & IntraChromaPreds;
#line 703
  VP8SSE16x16 = & SSE16x16;
#line 704
  VP8SSE8x8 = & SSE8x8;
#line 705
  VP8SSE16x8 = & SSE16x8;
#line 706
  VP8SSE4x4 = & SSE4x4;
#line 707
  VP8TDisto4x4 = & Disto4x4;
#line 708
  VP8TDisto16x16 = & Disto16x16;
#line 709
  VP8EncQuantizeBlock = & QuantizeBlock;
#line 710
  VP8Copy4x4 = & Copy4x4;
  }
#line 713
  if (VP8GetCPUInfo) {
    {
#line 715
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 715
    if (__cil_tmp1) {
      {
#line 716
      VP8EncDspInitSSE2();
      }
    }
  }
  return;
}
}
#line 389 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec_neon.c"
void VP8DspInitNEON(void) ;
#line 391 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec_neon.c"
void VP8DspInitNEON(void) 
{ 


  {
  return;
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./../utils/color_cache.h"
static uint32_t kHashMul___2  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___2(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___2 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___2(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___2 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/./../utils/color_cache.h"
__inline static int VP8LColorCacheContains___2(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___2 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 290 "/doner/libwebp/libwebp-v0.3.0/src/dsp/../dec/vp8i.h"
int VP8SetError(VP8Decoder *dec , enum VP8StatusCode error , char const   *msg ) ;
#line 294
void VP8ResetProba(VP8Proba___0 *proba ) ;
#line 295
void VP8ParseProba(VP8BitReader *br , VP8Decoder *dec ) ;
#line 296
void VP8ParseIntraMode(VP8BitReader *br , VP8Decoder *dec ) ;
#line 299
void VP8ParseQuant(VP8Decoder *dec ) ;
#line 302
int VP8InitFrame(VP8Decoder *dec , VP8Io *io ) ;
#line 304
void VP8ReconstructBlock(VP8Decoder *dec ) ;
#line 309
enum VP8StatusCode VP8EnterCritical(VP8Decoder *dec , VP8Io *io ) ;
#line 312
int VP8ExitCritical(VP8Decoder *dec , VP8Io *io ) ;
#line 314
int VP8ProcessRow(VP8Decoder *dec , VP8Io *io ) ;
#line 316
void VP8InitScanline(VP8Decoder *dec ) ;
#line 318
int VP8DecodeMB(VP8Decoder *dec , VP8BitReader *token_br ) ;
#line 321
uint8_t *VP8DecompressAlphaRows(VP8Decoder *dec , int row , int num_rows ) ;
#line 325
int VP8DecodeLayer(VP8Decoder *dec ) ;
#line 22 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static uint8_t abs0___0[511] ;
#line 23
static uint8_t abs1___0[511] ;
#line 24
static int8_t sclip1___0[2041] ;
#line 25
static int8_t sclip2___0[225] ;
#line 26
static uint8_t clip1___1[766] ;
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static int tables_ok___1  =    0;
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DspInitTables(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 33
  if (! tables_ok___1) {
#line 35
    i = - 255;
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;
#line 35
      if (! (i <= 255)) {
#line 35
        goto while_break;
      }
#line 36
      if (i < 0) {
#line 36
        tmp = - i;
      } else {
#line 36
        tmp = i;
      }
#line 36
      abs0___0[255 + i] = (uint8_t )tmp;
#line 37
      abs1___0[255 + i] = (uint8_t )((int )abs0___0[255 + i] >> 1);
#line 35
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 39
    i = - 1020;
    {
#line 39
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 39
      if (! (i <= 1020)) {
#line 39
        goto while_break___0;
      }
#line 40
      if (i < -128) {
#line 40
        tmp___1 = - 128;
      } else {
#line 40
        if (i > 127) {
#line 40
          tmp___0 = 127;
        } else {
#line 40
          tmp___0 = i;
        }
#line 40
        tmp___1 = tmp___0;
      }
#line 40
      sclip1___0[1020 + i] = (int8_t )tmp___1;
#line 39
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 42
    i = - 112;
    {
#line 42
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 42
      if (! (i <= 112)) {
#line 42
        goto while_break___1;
      }
#line 43
      if (i < -16) {
#line 43
        tmp___3 = - 16;
      } else {
#line 43
        if (i > 15) {
#line 43
          tmp___2 = 15;
        } else {
#line 43
          tmp___2 = i;
        }
#line 43
        tmp___3 = tmp___2;
      }
#line 43
      sclip2___0[112 + i] = (int8_t )tmp___3;
#line 42
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 45
    i = - 255;
    {
#line 45
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 45
      if (! (i <= 510)) {
#line 45
        goto while_break___2;
      }
#line 46
      if (i < 0) {
#line 46
        tmp___5 = 0;
      } else {
#line 46
        if (i > 255) {
#line 46
          tmp___4 = 255;
        } else {
#line 46
          tmp___4 = i;
        }
#line 46
        tmp___5 = tmp___4;
      }
#line 46
      clip1___1[255 + i] = (uint8_t )tmp___5;
#line 45
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 48
    tables_ok___1 = 1;
  }
  return;
}
}
#line 62 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static int const   kC1___0  =    20091 + (1 << 16);
#line 63 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static int const   kC2___0  =    35468;
#line 66 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void TransformOne(int16_t *in , uint8_t *dst ) 
{ 
  int C[16] ;
  int *tmp ;
  int i ;
  int a ;
  int b ;
  int c ;
  int d ;
  int16_t *__cil_tmp10 ;
  int dc ;
  int a___0 ;
  int b___0 ;
  int c___0 ;
  int d___0 ;
  uint8_t __cil_tmp16 ;
  uint8_t __cil_tmp17 ;
  uint8_t __cil_tmp18 ;
  uint8_t __cil_tmp19 ;
  int *__cil_tmp20 ;

  {
#line 69
  tmp = (int *)C;
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < 4)) {
#line 70
      goto while_break;
    }
#line 71
    a = (int )*(in + 0) + (int )*(in + 8);
#line 72
    b = (int )*(in + 0) - (int )*(in + 8);
#line 73
    c = ((int )*(in + 4) * kC2___0 >> 16) - ((int )*(in + 12) * kC1___0 >> 16);
#line 74
    d = ((int )*(in + 4) * kC1___0 >> 16) + ((int )*(in + 12) * kC2___0 >> 16);
#line 75
    *(tmp + 0) = a + d;
#line 76
    *(tmp + 1) = b + c;
#line 77
    *(tmp + 2) = b - c;
#line 78
    *(tmp + 3) = a - d;
#line 79
    tmp += 4;
#line 80
    in ++;
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  tmp = (int *)C;
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (i < 4)) {
#line 90
      goto while_break___0;
    }
    {
#line 91
    dc = *(tmp + 0) + 4;
#line 92
    a___0 = dc + *(tmp + 8);
#line 93
    b___0 = dc - *(tmp + 8);
#line 94
    c___0 = (*(tmp + 4) * kC2___0 >> 16) - (*(tmp + 12) * kC1___0 >> 16);
#line 95
    d___0 = (*(tmp + 4) * kC1___0 >> 16) + (*(tmp + 12) * kC2___0 >> 16);
#line 96
    *(dst + 0) = clip_8b((int )*(dst + 0) + ((a___0 + d___0) >> 3));
#line 97
    *(dst + 1) = clip_8b((int )*(dst + 1) + ((b___0 + c___0) >> 3));
#line 98
    *(dst + 2) = clip_8b((int )*(dst + 2) + ((b___0 - c___0) >> 3));
#line 99
    *(dst + 3) = clip_8b((int )*(dst + 3) + ((a___0 - d___0) >> 3));
#line 100
    tmp ++;
#line 101
    dst += 32;
    }
#line 90
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 106 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void TransformTwo(int16_t *in , uint8_t *dst , int do_two ) 
{ 


  {
  {
#line 107
  TransformOne(in, dst);
  }
#line 108
  if (do_two) {
    {
#line 109
    TransformOne(in + 16, dst + 4);
    }
  }
  return;
}
}
#line 113 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void TransformUV(int16_t *in , uint8_t *dst ) 
{ 


  {
  {
#line 114
  (*VP8Transform)(in + 0, dst, 1);
#line 115
  (*VP8Transform)(in + 32, dst + 128, 1);
  }
  return;
}
}
#line 118 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void TransformDC(int16_t *in , uint8_t *dst ) 
{ 
  int DC ;
  int i ;
  int j ;
  uint8_t __cil_tmp6 ;

  {
#line 119
  DC = (int )*(in + 0) + 4;
#line 121
  j = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (j < 4)) {
#line 121
      goto while_break;
    }
#line 122
    i = 0;
    {
#line 122
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 122
      if (! (i < 4)) {
#line 122
        goto while_break___0;
      }
      {
#line 123
      *(dst + (i + j * 32)) = clip_8b((int )*(dst + (i + j * 32)) + (DC >> 3));
      }
#line 122
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 121
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 128 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void TransformDCUV(int16_t *in , uint8_t *dst ) 
{ 


  {
#line 129
  if (*(in + 0)) {
    {
#line 129
    TransformDC(in + 0, dst);
    }
  }
#line 130
  if (*(in + 16)) {
    {
#line 130
    TransformDC(in + 16, dst + 4);
    }
  }
#line 131
  if (*(in + 32)) {
    {
#line 131
    TransformDC(in + 32, dst + 128);
    }
  }
#line 132
  if (*(in + 48)) {
    {
#line 132
    TransformDC(in + 48, (dst + 128) + 4);
    }
  }
  return;
}
}
#line 140 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void TransformWHT(int16_t *in , int16_t *out ) 
{ 
  int tmp[16] ;
  int i ;
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int dc ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;

  {
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < 4)) {
#line 143
      goto while_break;
    }
#line 144
    a0 = (int )*(in + i) + (int )*(in + (12 + i));
#line 145
    a1 = (int )*(in + (4 + i)) + (int )*(in + (8 + i));
#line 146
    a2 = (int )*(in + (4 + i)) - (int )*(in + (8 + i));
#line 147
    a3 = (int )*(in + i) - (int )*(in + (12 + i));
#line 148
    tmp[i] = a0 + a1;
#line 149
    tmp[8 + i] = a0 - a1;
#line 150
    tmp[4 + i] = a3 + a2;
#line 151
    tmp[12 + i] = a3 - a2;
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    if (! (i < 4)) {
#line 153
      goto while_break___0;
    }
#line 154
    dc = tmp[i * 4] + 3;
#line 155
    a0___0 = dc + tmp[3 + i * 4];
#line 156
    a1___0 = tmp[1 + i * 4] + tmp[2 + i * 4];
#line 157
    a2___0 = tmp[1 + i * 4] - tmp[2 + i * 4];
#line 158
    a3___0 = dc - tmp[3 + i * 4];
#line 159
    *(out + 0) = (int16_t )((a0___0 + a1___0) >> 3);
#line 160
    *(out + 16) = (int16_t )((a3___0 + a2___0) >> 3);
#line 161
    *(out + 32) = (int16_t )((a0___0 - a1___0) >> 3);
#line 162
    *(out + 48) = (int16_t )((a3___0 - a2___0) >> 3);
#line 163
    out += 64;
#line 153
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 167 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
VP8WHT VP8TransformWHT  =    & TransformWHT;
#line 174 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static void TrueMotion___0(uint8_t *dst , int size ) 
{ 
  uint8_t *top ;
  uint8_t *clip0 ;
  int y ;
  uint8_t *clip___3 ;
  int x ;

  {
#line 175
  top = dst - 32;
#line 176
  clip0 = ((uint8_t *)clip1___1 + 255) - (int )*(top + -1);
#line 178
  y = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (y < size)) {
#line 178
      goto while_break;
    }
#line 179
    clip___3 = clip0 + (int )*(dst + -1);
#line 181
    x = 0;
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if (! (x < size)) {
#line 181
        goto while_break___0;
      }
#line 182
      *(dst + x) = *(clip___3 + *(top + x));
#line 181
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 184
    dst += 32;
#line 178
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 187 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void TM4___0(uint8_t *dst ) 
{ 


  {
  {
#line 187
  TrueMotion___0(dst, 4);
  }
  return;
}
}
#line 188 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void TM8uv(uint8_t *dst ) 
{ 


  {
  {
#line 188
  TrueMotion___0(dst, 8);
  }
  return;
}
}
#line 189 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void TM16(uint8_t *dst ) 
{ 


  {
  {
#line 189
  TrueMotion___0(dst, 16);
  }
  return;
}
}
#line 194 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void VE16(uint8_t *dst ) 
{ 
  int j ;

  {
#line 196
  j = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (j < 16)) {
#line 196
      goto while_break;
    }
    {
#line 197
    memcpy(dst + j * 32, dst - 32, (unsigned long )16);
    }
#line 196
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 201 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void HE16(uint8_t *dst ) 
{ 
  int j ;

  {
#line 203
  j = 16;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (j > 0)) {
#line 203
      goto while_break;
    }
    {
#line 204
    memset(dst, (int )*(dst + - 1), (unsigned long )16);
#line 205
    dst += 32;
    }
#line 203
    j --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 209 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static void Put16(int v , uint8_t *dst ) 
{ 
  int j ;

  {
#line 211
  j = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (j < 16)) {
#line 211
      goto while_break;
    }
    {
#line 212
    memset(dst + j * 32, v, (unsigned long )16);
    }
#line 211
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 216 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DC16(uint8_t *dst ) 
{ 
  int DC ;
  int j ;

  {
#line 217
  DC = 16;
#line 219
  j = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (j < 16)) {
#line 219
      goto while_break;
    }
#line 220
    DC += (int )*(dst + (-1 + j * 32)) + (int )*(dst + (j - 32));
#line 219
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  Put16(DC >> 5, dst);
  }
  return;
}
}
#line 225 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DC16NoTop(uint8_t *dst ) 
{ 
  int DC ;
  int j ;

  {
#line 226
  DC = 8;
#line 228
  j = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (j < 16)) {
#line 228
      goto while_break;
    }
#line 229
    DC += (int )*(dst + (-1 + j * 32));
#line 228
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  Put16(DC >> 4, dst);
  }
  return;
}
}
#line 234 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DC16NoLeft(uint8_t *dst ) 
{ 
  int DC ;
  int i ;

  {
#line 235
  DC = 8;
#line 237
  i = 0;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < 16)) {
#line 237
      goto while_break;
    }
#line 238
    DC += (int )*(dst + (i - 32));
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  Put16(DC >> 4, dst);
  }
  return;
}
}
#line 243 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DC16NoTopLeft(uint8_t *dst ) 
{ 


  {
  {
#line 244
  Put16(128, dst);
  }
  return;
}
}
#line 253 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void VE4___0(uint8_t *dst ) 
{ 
  uint8_t *top ;
  uint8_t vals[4] ;
  int i ;

  {
#line 254
  top = dst - 32;
#line 255
  vals[0] = (uint8_t )(((((int )*(top + -1) + 2 * (int )*(top + 0)) + (int )*(top + 1)) + 2) >> 2);
#line 255
  vals[1] = (uint8_t )(((((int )*(top + 0) + 2 * (int )*(top + 1)) + (int )*(top + 2)) + 2) >> 2);
#line 255
  vals[2] = (uint8_t )(((((int )*(top + 1) + 2 * (int )*(top + 2)) + (int )*(top + 3)) + 2) >> 2);
#line 255
  vals[3] = (uint8_t )(((((int )*(top + 2) + 2 * (int )*(top + 3)) + (int )*(top + 4)) + 2) >> 2);
#line 262
  i = 0;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! (i < 4)) {
#line 262
      goto while_break;
    }
    {
#line 263
    memcpy(dst + i * 32, (uint8_t *)vals, sizeof(vals));
    }
#line 262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 267 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void HE4___0(uint8_t *dst ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;

  {
#line 268
  A = (int )*(dst + -33);
#line 269
  B = (int )*(dst + - 1);
#line 270
  C = (int )*(dst + 31);
#line 271
  D = (int )*(dst + 63);
#line 272
  E = (int )*(dst + 95);
#line 273
  *((uint32_t *)(dst + 0)) = 16843009U * (unsigned int )((((A + 2 * B) + C) + 2) >> 2);
#line 274
  *((uint32_t *)(dst + 32)) = 16843009U * (unsigned int )((((B + 2 * C) + D) + 2) >> 2);
#line 275
  *((uint32_t *)(dst + 64)) = 16843009U * (unsigned int )((((C + 2 * D) + E) + 2) >> 2);
#line 276
  *((uint32_t *)(dst + 96)) = 16843009U * (unsigned int )((((D + 2 * E) + E) + 2) >> 2);
  return;
}
}
#line 279 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DC4___0(uint8_t *dst ) 
{ 
  uint32_t dc ;
  int i ;

  {
#line 280
  dc = (uint32_t )4;
#line 282
  i = 0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (i < 4)) {
#line 282
      goto while_break;
    }
#line 282
    dc += (unsigned int )((int )*(dst + (i - 32)) + (int )*(dst + (-1 + i * 32)));
#line 282
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  dc >>= 3;
#line 284
  i = 0;
  {
#line 284
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 284
    if (! (i < 4)) {
#line 284
      goto while_break___0;
    }
    {
#line 284
    memset(dst + i * 32, (int )dc, (unsigned long )4);
    }
#line 284
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 287 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void RD4___0(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;
  int X ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 288
  I = (int )*(dst + -1);
#line 289
  J = (int )*(dst + 31);
#line 290
  K = (int )*(dst + 63);
#line 291
  L = (int )*(dst + 95);
#line 292
  X = (int )*(dst + -33);
#line 293
  A = (int )*(dst + -32);
#line 294
  B = (int )*(dst + -31);
#line 295
  C = (int )*(dst + -30);
#line 296
  D = (int )*(dst + -29);
#line 297
  *(dst + 96) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 298
  *(dst + 97) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 298
  *(dst + 64) = *(dst + 97);
#line 299
  *(dst + 98) = (uint8_t )((((X + 2 * I) + J) + 2) >> 2);
#line 299
  *(dst + 65) = *(dst + 98);
#line 299
  *(dst + 32) = *(dst + 65);
#line 300
  *(dst + 99) = (uint8_t )((((A + 2 * X) + I) + 2) >> 2);
#line 300
  *(dst + 66) = *(dst + 99);
#line 300
  *(dst + 33) = *(dst + 66);
#line 300
  *(dst + 0) = *(dst + 33);
#line 301
  *(dst + 67) = (uint8_t )((((B + 2 * A) + X) + 2) >> 2);
#line 301
  *(dst + 34) = *(dst + 67);
#line 301
  *(dst + 1) = *(dst + 34);
#line 302
  *(dst + 35) = (uint8_t )((((C + 2 * B) + A) + 2) >> 2);
#line 302
  *(dst + 2) = *(dst + 35);
#line 303
  *(dst + 3) = (uint8_t )((((D + 2 * C) + B) + 2) >> 2);
  return;
}
}
#line 306 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void LD4___0(uint8_t *dst ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 307
  A = (int )*(dst + -32);
#line 308
  B = (int )*(dst + -31);
#line 309
  C = (int )*(dst + -30);
#line 310
  D = (int )*(dst + -29);
#line 311
  E = (int )*(dst + -28);
#line 312
  F = (int )*(dst + -27);
#line 313
  G = (int )*(dst + -26);
#line 314
  H = (int )*(dst + -25);
#line 315
  *(dst + 0) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 316
  *(dst + 32) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 316
  *(dst + 1) = *(dst + 32);
#line 317
  *(dst + 64) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 317
  *(dst + 33) = *(dst + 64);
#line 317
  *(dst + 2) = *(dst + 33);
#line 318
  *(dst + 96) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 318
  *(dst + 65) = *(dst + 96);
#line 318
  *(dst + 34) = *(dst + 65);
#line 318
  *(dst + 3) = *(dst + 34);
#line 319
  *(dst + 97) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 319
  *(dst + 66) = *(dst + 97);
#line 319
  *(dst + 35) = *(dst + 66);
#line 320
  *(dst + 98) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
#line 320
  *(dst + 67) = *(dst + 98);
#line 321
  *(dst + 99) = (uint8_t )((((G + 2 * H) + H) + 2) >> 2);
  return;
}
}
#line 324 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void VR4___0(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int X ;
  int A ;
  int B ;
  int C ;
  int D ;

  {
#line 325
  I = (int )*(dst + -1);
#line 326
  J = (int )*(dst + 31);
#line 327
  K = (int )*(dst + 63);
#line 328
  X = (int )*(dst + -33);
#line 329
  A = (int )*(dst + -32);
#line 330
  B = (int )*(dst + -31);
#line 331
  C = (int )*(dst + -30);
#line 332
  D = (int )*(dst + -29);
#line 333
  *(dst + 65) = (uint8_t )(((X + A) + 1) >> 1);
#line 333
  *(dst + 0) = *(dst + 65);
#line 334
  *(dst + 66) = (uint8_t )(((A + B) + 1) >> 1);
#line 334
  *(dst + 1) = *(dst + 66);
#line 335
  *(dst + 67) = (uint8_t )(((B + C) + 1) >> 1);
#line 335
  *(dst + 2) = *(dst + 67);
#line 336
  *(dst + 3) = (uint8_t )(((C + D) + 1) >> 1);
#line 338
  *(dst + 96) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 339
  *(dst + 64) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 340
  *(dst + 97) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 340
  *(dst + 32) = *(dst + 97);
#line 341
  *(dst + 98) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 341
  *(dst + 33) = *(dst + 98);
#line 342
  *(dst + 99) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 342
  *(dst + 34) = *(dst + 99);
#line 343
  *(dst + 35) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
  return;
}
}
#line 346 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void VL4___0(uint8_t *dst ) 
{ 
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int G ;
  int H ;

  {
#line 347
  A = (int )*(dst + -32);
#line 348
  B = (int )*(dst + -31);
#line 349
  C = (int )*(dst + -30);
#line 350
  D = (int )*(dst + -29);
#line 351
  E = (int )*(dst + -28);
#line 352
  F = (int )*(dst + -27);
#line 353
  G = (int )*(dst + -26);
#line 354
  H = (int )*(dst + -25);
#line 355
  *(dst + 0) = (uint8_t )(((A + B) + 1) >> 1);
#line 356
  *(dst + 64) = (uint8_t )(((B + C) + 1) >> 1);
#line 356
  *(dst + 1) = *(dst + 64);
#line 357
  *(dst + 65) = (uint8_t )(((C + D) + 1) >> 1);
#line 357
  *(dst + 2) = *(dst + 65);
#line 358
  *(dst + 66) = (uint8_t )(((D + E) + 1) >> 1);
#line 358
  *(dst + 3) = *(dst + 66);
#line 360
  *(dst + 32) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 361
  *(dst + 96) = (uint8_t )((((B + 2 * C) + D) + 2) >> 2);
#line 361
  *(dst + 33) = *(dst + 96);
#line 362
  *(dst + 97) = (uint8_t )((((C + 2 * D) + E) + 2) >> 2);
#line 362
  *(dst + 34) = *(dst + 97);
#line 363
  *(dst + 98) = (uint8_t )((((D + 2 * E) + F) + 2) >> 2);
#line 363
  *(dst + 35) = *(dst + 98);
#line 364
  *(dst + 67) = (uint8_t )((((E + 2 * F) + G) + 2) >> 2);
#line 365
  *(dst + 99) = (uint8_t )((((F + 2 * G) + H) + 2) >> 2);
  return;
}
}
#line 368 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void HU4___0(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;

  {
#line 369
  I = (int )*(dst + -1);
#line 370
  J = (int )*(dst + 31);
#line 371
  K = (int )*(dst + 63);
#line 372
  L = (int )*(dst + 95);
#line 373
  *(dst + 0) = (uint8_t )(((I + J) + 1) >> 1);
#line 374
  *(dst + 32) = (uint8_t )(((J + K) + 1) >> 1);
#line 374
  *(dst + 2) = *(dst + 32);
#line 375
  *(dst + 64) = (uint8_t )(((K + L) + 1) >> 1);
#line 375
  *(dst + 34) = *(dst + 64);
#line 376
  *(dst + 1) = (uint8_t )((((I + 2 * J) + K) + 2) >> 2);
#line 377
  *(dst + 33) = (uint8_t )((((J + 2 * K) + L) + 2) >> 2);
#line 377
  *(dst + 3) = *(dst + 33);
#line 378
  *(dst + 65) = (uint8_t )((((K + 2 * L) + L) + 2) >> 2);
#line 378
  *(dst + 35) = *(dst + 65);
#line 379
  *(dst + 99) = (uint8_t )L;
#line 379
  *(dst + 98) = *(dst + 99);
#line 379
  *(dst + 97) = *(dst + 98);
#line 379
  *(dst + 96) = *(dst + 97);
#line 379
  *(dst + 66) = *(dst + 96);
#line 379
  *(dst + 67) = *(dst + 66);
  return;
}
}
#line 383 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void HD4___0(uint8_t *dst ) 
{ 
  int I ;
  int J ;
  int K ;
  int L ;
  int X ;
  int A ;
  int B ;
  int C ;

  {
#line 384
  I = (int )*(dst + -1);
#line 385
  J = (int )*(dst + 31);
#line 386
  K = (int )*(dst + 63);
#line 387
  L = (int )*(dst + 95);
#line 388
  X = (int )*(dst + -33);
#line 389
  A = (int )*(dst + -32);
#line 390
  B = (int )*(dst + -31);
#line 391
  C = (int )*(dst + -30);
#line 393
  *(dst + 34) = (uint8_t )(((I + X) + 1) >> 1);
#line 393
  *(dst + 0) = *(dst + 34);
#line 394
  *(dst + 66) = (uint8_t )(((J + I) + 1) >> 1);
#line 394
  *(dst + 32) = *(dst + 66);
#line 395
  *(dst + 98) = (uint8_t )(((K + J) + 1) >> 1);
#line 395
  *(dst + 64) = *(dst + 98);
#line 396
  *(dst + 96) = (uint8_t )(((L + K) + 1) >> 1);
#line 398
  *(dst + 3) = (uint8_t )((((A + 2 * B) + C) + 2) >> 2);
#line 399
  *(dst + 2) = (uint8_t )((((X + 2 * A) + B) + 2) >> 2);
#line 400
  *(dst + 35) = (uint8_t )((((I + 2 * X) + A) + 2) >> 2);
#line 400
  *(dst + 1) = *(dst + 35);
#line 401
  *(dst + 67) = (uint8_t )((((J + 2 * I) + X) + 2) >> 2);
#line 401
  *(dst + 33) = *(dst + 67);
#line 402
  *(dst + 99) = (uint8_t )((((K + 2 * J) + I) + 2) >> 2);
#line 402
  *(dst + 65) = *(dst + 99);
#line 403
  *(dst + 97) = (uint8_t )((((L + 2 * K) + J) + 2) >> 2);
  return;
}
}
#line 413 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void VE8uv(uint8_t *dst ) 
{ 
  int j ;

  {
#line 415
  j = 0;
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (j < 8)) {
#line 415
      goto while_break;
    }
    {
#line 416
    memcpy(dst + j * 32, dst - 32, (unsigned long )8);
    }
#line 415
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 420 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void HE8uv(uint8_t *dst ) 
{ 
  int j ;

  {
#line 422
  j = 0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (j < 8)) {
#line 422
      goto while_break;
    }
    {
#line 423
    memset(dst, (int )*(dst + - 1), (unsigned long )8);
#line 424
    dst += 32;
    }
#line 422
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 429 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static void Put8x8uv(uint8_t value , uint8_t *dst ) 
{ 
  int j ;
  uint64_t v ;

  {
#line 432
  v = (uint64_t )((unsigned long long )((uint64_t )value) * 72340172838076673ULL);
#line 433
  j = 0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! (j < 8)) {
#line 433
      goto while_break;
    }
#line 434
    *((uint64_t *)(dst + j * 32)) = v;
#line 433
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 441 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DC8uv(uint8_t *dst ) 
{ 
  int dc0 ;
  int i ;

  {
#line 442
  dc0 = 8;
#line 444
  i = 0;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if (! (i < 8)) {
#line 444
      goto while_break;
    }
#line 445
    dc0 += (int )*(dst + (i - 32)) + (int )*(dst + (-1 + i * 32));
#line 444
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  Put8x8uv((uint8_t )(dc0 >> 4), dst);
  }
  return;
}
}
#line 450 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DC8uvNoLeft(uint8_t *dst ) 
{ 
  int dc0 ;
  int i ;

  {
#line 451
  dc0 = 4;
#line 453
  i = 0;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! (i < 8)) {
#line 453
      goto while_break;
    }
#line 454
    dc0 += (int )*(dst + (i - 32));
#line 453
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 456
  Put8x8uv((uint8_t )(dc0 >> 3), dst);
  }
  return;
}
}
#line 459 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DC8uvNoTop(uint8_t *dst ) 
{ 
  int dc0 ;
  int i ;

  {
#line 460
  dc0 = 4;
#line 462
  i = 0;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (i < 8)) {
#line 462
      goto while_break;
    }
#line 463
    dc0 += (int )*(dst + (-1 + i * 32));
#line 462
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 465
  Put8x8uv((uint8_t )(dc0 >> 3), dst);
  }
  return;
}
}
#line 468 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void DC8uvNoTopLeft(uint8_t *dst ) 
{ 


  {
  {
#line 469
  Put8x8uv((uint8_t )128, dst);
  }
  return;
}
}
#line 475 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
VP8PredFunc VP8PredLuma4[10]  = 
#line 475
  {      & DC4___0,      & TM4___0,      & VE4___0,      & HE4___0, 
        & RD4___0,      & VR4___0,      & LD4___0,      & VL4___0, 
        & HD4___0,      & HU4___0};
#line 479 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
VP8PredFunc VP8PredLuma16[7]  = {      & DC16,      & TM16,      & VE16,      & HE16, 
        & DC16NoTop,      & DC16NoLeft,      & DC16NoTopLeft};
#line 484 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
VP8PredFunc VP8PredChroma8[7]  = {      & DC8uv,      & TM8uv,      & VE8uv,      & HE8uv, 
        & DC8uvNoTop,      & DC8uvNoLeft,      & DC8uvNoTopLeft};
#line 493 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static void do_filter2___0(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;

  {
#line 494
  p1 = (int )*(p + -2 * step);
#line 494
  p0 = (int )*(p + - step);
#line 494
  q0 = (int )*(p + 0);
#line 494
  q1 = (int )*(p + step);
#line 495
  a = 3 * (q0 - p0) + (int )sclip1___0[(1020 + p1) - q1];
#line 496
  a1 = (int )sclip2___0[112 + ((a + 4) >> 3)];
#line 497
  a2 = (int )sclip2___0[112 + ((a + 3) >> 3)];
#line 498
  *(p + - step) = clip1___1[(255 + p0) + a2];
#line 499
  *(p + 0) = clip1___1[(255 + q0) - a1];
  return;
}
}
#line 503 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static void do_filter4___0(uint8_t *p , int step ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int a ;
  int a1 ;
  int a2 ;
  int a3 ;

  {
#line 504
  p1 = (int )*(p + -2 * step);
#line 504
  p0 = (int )*(p + - step);
#line 504
  q0 = (int )*(p + 0);
#line 504
  q1 = (int )*(p + step);
#line 505
  a = 3 * (q0 - p0);
#line 506
  a1 = (int )sclip2___0[112 + ((a + 4) >> 3)];
#line 507
  a2 = (int )sclip2___0[112 + ((a + 3) >> 3)];
#line 508
  a3 = (a1 + 1) >> 1;
#line 509
  *(p + -2 * step) = clip1___1[(255 + p1) + a3];
#line 510
  *(p + - step) = clip1___1[(255 + p0) + a2];
#line 511
  *(p + 0) = clip1___1[(255 + q0) - a1];
#line 512
  *(p + step) = clip1___1[(255 + q1) - a3];
  return;
}
}
#line 516 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static void do_filter6(uint8_t *p , int step ) 
{ 
  int p2 ;
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int q2 ;
  int a ;
  int a1 ;
  int a2 ;
  int a3 ;

  {
#line 517
  p2 = (int )*(p + -3 * step);
#line 517
  p1 = (int )*(p + -2 * step);
#line 517
  p0 = (int )*(p + - step);
#line 518
  q0 = (int )*(p + 0);
#line 518
  q1 = (int )*(p + step);
#line 518
  q2 = (int )*(p + 2 * step);
#line 519
  a = (int )sclip1___0[(1020 + 3 * (q0 - p0)) + (int )sclip1___0[(1020 + p1) - q1]];
#line 520
  a1 = (27 * a + 63) >> 7;
#line 521
  a2 = (18 * a + 63) >> 7;
#line 522
  a3 = (9 * a + 63) >> 7;
#line 523
  *(p + -3 * step) = clip1___1[(255 + p2) + a3];
#line 524
  *(p + -2 * step) = clip1___1[(255 + p1) + a2];
#line 525
  *(p + - step) = clip1___1[(255 + p0) + a1];
#line 526
  *(p + 0) = clip1___1[(255 + q0) - a1];
#line 527
  *(p + step) = clip1___1[(255 + q1) - a2];
#line 528
  *(p + 2 * step) = clip1___1[(255 + q2) - a3];
  return;
}
}
#line 531 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static int hev___0(uint8_t *p , int step , int thresh ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;

  {
#line 532
  p1 = (int )*(p + -2 * step);
#line 532
  p0 = (int )*(p + - step);
#line 532
  q0 = (int )*(p + 0);
#line 532
  q1 = (int )*(p + step);
#line 533
  return ((int )abs0___0[(255 + p1) - p0] > thresh || (int )abs0___0[(255 + q1) - q0] > thresh);
}
}
#line 536 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static int needs_filter___0(uint8_t *p , int step , int thresh ) 
{ 
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;

  {
#line 537
  p1 = (int )*(p + -2 * step);
#line 537
  p0 = (int )*(p + - step);
#line 537
  q0 = (int )*(p + 0);
#line 537
  q1 = (int )*(p + step);
#line 538
  return (2 * (int )abs0___0[(255 + p0) - q0] + (int )abs1___0[(255 + p1) - q1] <= thresh);
}
}
#line 541 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static int needs_filter2___0(uint8_t *p , int step , int t , int it ) 
{ 
  int p3 ;
  int p2 ;
  int p1 ;
  int p0 ;
  int q0 ;
  int q1 ;
  int q2 ;
  int q3 ;

  {
#line 543
  p3 = (int )*(p + -4 * step);
#line 543
  p2 = (int )*(p + -3 * step);
#line 543
  p1 = (int )*(p + -2 * step);
#line 543
  p0 = (int )*(p + - step);
#line 544
  q0 = (int )*(p + 0);
#line 544
  q1 = (int )*(p + step);
#line 544
  q2 = (int )*(p + 2 * step);
#line 544
  q3 = (int )*(p + 3 * step);
#line 545
  if (2 * (int )abs0___0[(255 + p0) - q0] + (int )abs1___0[(255 + p1) - q1] > t) {
#line 546
    return (0);
  }
#line 547
  return ((((((int )abs0___0[(255 + p3) - p2] <= it && (int )abs0___0[(255 + p2) - p1] <= it) && (int )abs0___0[(255 + p1) - p0] <= it) && (int )abs0___0[(255 + q3) - q2] <= it) && (int )abs0___0[(255 + q2) - q1] <= it) && (int )abs0___0[(255 + q1) - q0] <= it);
}
}
#line 555 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void SimpleVFilter16___0(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 557
  i = 0;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! (i < 16)) {
#line 557
      goto while_break;
    }
    {
#line 558
    __cil_tmp5 = needs_filter___0(p + i, stride, thresh);
    }
#line 558
    if (__cil_tmp5) {
      {
#line 559
      do_filter2___0(p + i, stride);
      }
    }
#line 557
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 564 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void SimpleHFilter16___0(uint8_t *p , int stride , int thresh ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 566
  i = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < 16)) {
#line 566
      goto while_break;
    }
    {
#line 567
    __cil_tmp5 = needs_filter___0(p + i * stride, 1, thresh);
    }
#line 567
    if (__cil_tmp5) {
      {
#line 568
      do_filter2___0(p + i * stride, 1);
      }
    }
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 573 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void SimpleVFilter16i___0(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 575
  k = 3;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if (! (k > 0)) {
#line 575
      goto while_break;
    }
    {
#line 576
    p += 4 * stride;
#line 577
    SimpleVFilter16___0(p, stride, thresh);
    }
#line 575
    k --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 581 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void SimpleHFilter16i___0(uint8_t *p , int stride , int thresh ) 
{ 
  int k ;

  {
#line 583
  k = 3;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (k > 0)) {
#line 583
      goto while_break;
    }
    {
#line 584
    p += 4;
#line 585
    SimpleHFilter16___0(p, stride, thresh);
    }
#line 583
    k --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 592 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static void FilterLoop26(uint8_t *p , int hstride , int vstride , int size ,
                                  int thresh , int ithresh , int hev_thresh ) 
{ 
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    __cil_tmp8 = size;
#line 595
    size --;
#line 595
    if (! (__cil_tmp8 > 0)) {
#line 595
      goto while_break;
    }
    {
#line 596
    __cil_tmp9 = needs_filter2___0(p, hstride, thresh, ithresh);
    }
#line 596
    if (__cil_tmp9) {
      {
#line 597
      __cil_tmp10 = hev___0(p, hstride, hev_thresh);
      }
#line 597
      if (__cil_tmp10) {
        {
#line 598
        do_filter2___0(p, hstride);
        }
      } else {
        {
#line 600
        do_filter6(p, hstride);
        }
      }
    }
#line 603
    p += vstride;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 607 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
__inline static void FilterLoop24___0(uint8_t *p , int hstride , int vstride , int size ,
                                      int thresh , int ithresh , int hev_thresh ) 
{ 
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    __cil_tmp8 = size;
#line 610
    size --;
#line 610
    if (! (__cil_tmp8 > 0)) {
#line 610
      goto while_break;
    }
    {
#line 611
    __cil_tmp9 = needs_filter2___0(p, hstride, thresh, ithresh);
    }
#line 611
    if (__cil_tmp9) {
      {
#line 612
      __cil_tmp10 = hev___0(p, hstride, hev_thresh);
      }
#line 612
      if (__cil_tmp10) {
        {
#line 613
        do_filter2___0(p, hstride);
        }
      } else {
        {
#line 615
        do_filter4___0(p, hstride);
        }
      }
    }
#line 618
    p += vstride;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 623 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void VFilter16(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 


  {
  {
#line 625
  FilterLoop26(p, stride, 1, 16, thresh, ithresh, hev_thresh);
  }
  return;
}
}
#line 628 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void HFilter16(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 


  {
  {
#line 630
  FilterLoop26(p, 1, stride, 16, thresh, ithresh, hev_thresh);
  }
  return;
}
}
#line 634 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void VFilter16i___0(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 637
  k = 3;
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! (k > 0)) {
#line 637
      goto while_break;
    }
    {
#line 638
    p += 4 * stride;
#line 639
    FilterLoop24___0(p, stride, 1, 16, thresh, ithresh, hev_thresh);
    }
#line 637
    k --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 643 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void HFilter16i___0(uint8_t *p , int stride , int thresh , int ithresh , int hev_thresh ) 
{ 
  int k ;

  {
#line 646
  k = 3;
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 646
    if (! (k > 0)) {
#line 646
      goto while_break;
    }
    {
#line 647
    p += 4;
#line 648
    FilterLoop24___0(p, 1, stride, 16, thresh, ithresh, hev_thresh);
    }
#line 646
    k --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 653 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void VFilter8(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                     int hev_thresh ) 
{ 


  {
  {
#line 655
  FilterLoop26(u, stride, 1, 8, thresh, ithresh, hev_thresh);
#line 656
  FilterLoop26(v, stride, 1, 8, thresh, ithresh, hev_thresh);
  }
  return;
}
}
#line 659 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void HFilter8(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                     int hev_thresh ) 
{ 


  {
  {
#line 661
  FilterLoop26(u, 1, stride, 8, thresh, ithresh, hev_thresh);
#line 662
  FilterLoop26(v, 1, stride, 8, thresh, ithresh, hev_thresh);
  }
  return;
}
}
#line 665 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void VFilter8i___0(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                          int hev_thresh ) 
{ 


  {
  {
#line 667
  FilterLoop24___0(u + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
#line 668
  FilterLoop24___0(v + 4 * stride, stride, 1, 8, thresh, ithresh, hev_thresh);
  }
  return;
}
}
#line 671 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
static void HFilter8i___0(uint8_t *u , uint8_t *v , int stride , int thresh , int ithresh ,
                          int hev_thresh ) 
{ 


  {
  {
#line 673
  FilterLoop24___0(u + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
#line 674
  FilterLoop24___0(v + 4, 1, stride, 8, thresh, ithresh, hev_thresh);
  }
  return;
}
}
#line 697
extern void VP8DspInitSSE2(void) ;
#line 700 "/doner/libwebp/libwebp-v0.3.0/src/dsp/dec.c"
void VP8DspInit(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 701
  DspInitTables();
#line 703
  VP8Transform = & TransformTwo;
#line 704
  VP8TransformUV = & TransformUV;
#line 705
  VP8TransformDC = & TransformDC;
#line 706
  VP8TransformDCUV = & TransformDCUV;
#line 708
  VP8VFilter16 = & VFilter16;
#line 709
  VP8HFilter16 = & HFilter16;
#line 710
  VP8VFilter8 = & VFilter8;
#line 711
  VP8HFilter8 = & HFilter8;
#line 712
  VP8VFilter16i = & VFilter16i___0;
#line 713
  VP8HFilter16i = & HFilter16i___0;
#line 714
  VP8VFilter8i = & VFilter8i___0;
#line 715
  VP8HFilter8i = & HFilter8i___0;
#line 716
  VP8SimpleVFilter16 = & SimpleVFilter16___0;
#line 717
  VP8SimpleHFilter16 = & SimpleHFilter16___0;
#line 718
  VP8SimpleVFilter16i = & SimpleVFilter16i___0;
#line 719
  VP8SimpleHFilter16i = & SimpleHFilter16i___0;
  }
#line 722
  if (VP8GetCPUInfo) {
    {
#line 724
    __cil_tmp1 = (*VP8GetCPUInfo)((CPUFeature )0);
    }
#line 724
    if (__cil_tmp1) {
      {
#line 725
      VP8DspInitSSE2();
      }
    }
  }
  return;
}
}
#line 37 "/doner/libwebp/libwebp-v0.3.0/src/dsp/cpu.c"
__inline static void GetCPUInfo(int cpu_info[4] , int info_type ) 
{ 


  {
  __asm__  ("asm":);
  return;
}
}
#line 48 "/doner/libwebp/libwebp-v0.3.0/src/dsp/cpu.c"
static int x86CPUInfo(CPUFeature feature ) 
{ 
  int cpu_info[4] ;

  {
  {
#line 50
  GetCPUInfo((int *)cpu_info, 1);
  }
#line 51
  if ((unsigned int )feature == 0U) {
#line 52
    return (0 != (cpu_info[3] & 67108864));
  }
#line 54
  if ((unsigned int )feature == 1U) {
#line 55
    return (0 != (cpu_info[2] & 1));
  }
#line 57
  return (0);
}
}
#line 59 "/doner/libwebp/libwebp-v0.3.0/src/dsp/cpu.c"
VP8CPUInfo VP8GetCPUInfo  =    & x86CPUInfo;
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
static uint32_t kHashMul___3  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___3(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___3 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___3(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___3 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheContains___3(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___3 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 48 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
__inline static uint32_t get_le24(uint8_t *data ) 
{ 


  {
#line 49
  return ((uint32_t )(((int )*(data + 0) | ((int )*(data + 1) << 8)) | ((int )*(data + 2) << 16)));
}
}
#line 52 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
__inline static uint32_t get_le32(uint8_t *data ) 
{ 
  uint32_t __cil_tmp2 ;

  {
  {
#line 53
  __cil_tmp2 = get_le24(data);
  }
#line 53
  return ((uint32_t )__cil_tmp2 | (unsigned int )((int )*(data + 3) << 24));
}
}
#line 62 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static enum VP8StatusCode ParseRIFF(uint8_t **data , size_t *data_size , size_t *riff_size ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  uint32_t size ;
  uint32_t __cil_tmp10 ;

  {
  {
#line 69
  *riff_size = (size_t )0;
#line 70
  __cil_tmp7 = memcmp(*data, "RIFFrU", (unsigned long )4);
  }
#line 70
  if (*data_size >= 12UL) {
#line 70
    if (! __cil_tmp7) {
      {
#line 71
      __cil_tmp8 = memcmp(*data + 8, "WEBP", (unsigned long )4);
      }
#line 71
      if (__cil_tmp8) {
#line 72
        return ((enum VP8StatusCode )3);
      } else {
        {
#line 74
        __cil_tmp10 = get_le32(*data + 4);
#line 74
        size = __cil_tmp10;
        }
#line 76
        if (size < 12U) {
#line 77
          return ((enum VP8StatusCode )3);
        }
#line 79
        if (size > 4294967286U) {
#line 80
          return ((enum VP8StatusCode )3);
        }
#line 83
        *riff_size = (size_t )size;
#line 84
        *data += 12;
#line 85
        *data_size -= (unsigned long )12;
      }
    }
  }
#line 88
  return ((enum VP8StatusCode )0);
}
}
#line 98 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static enum VP8StatusCode ParseVP8X(uint8_t **data , size_t *data_size , int *found_vp8x ,
                                    int *width_ptr , int *height_ptr , uint32_t *flags_ptr ) 
{ 
  uint32_t vp8x_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp11 ;
  int width ;
  int height ;
  uint32_t flags ;
  uint32_t chunk_size ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  uint32_t __cil_tmp19 ;

  {
#line 103
  vp8x_size = (uint32_t )18;
#line 108
  *found_vp8x = 0;
#line 110
  if (*data_size < 8UL) {
#line 111
    return ((enum VP8StatusCode )7);
  }
  {
#line 114
  __cil_tmp11 = memcmp(*data, "VP8XrU", (unsigned long )4);
  }
#line 114
  if (! __cil_tmp11) {
    {
#line 117
    __cil_tmp16 = get_le32(*data + 4);
#line 117
    chunk_size = __cil_tmp16;
    }
#line 118
    if (chunk_size != 10U) {
#line 119
      return ((enum VP8StatusCode )3);
    }
#line 123
    if (*data_size < (unsigned long )vp8x_size) {
#line 124
      return ((enum VP8StatusCode )7);
    }
    {
#line 126
    flags = get_le32(*data + 8);
#line 127
    __cil_tmp18 = get_le24(*data + 12);
#line 127
    width = (int )(1U + __cil_tmp18);
#line 128
    __cil_tmp19 = get_le24(*data + 15);
#line 128
    height = (int )(1U + __cil_tmp19);
    }
#line 129
    if ((unsigned long long )((unsigned long )width * (uint64_t )height) >= 1ULL << 32) {
#line 130
      return ((enum VP8StatusCode )3);
    }
#line 133
    if (flags_ptr != (void *)0) {
#line 133
      *flags_ptr = flags;
    }
#line 134
    if (width_ptr != (void *)0) {
#line 134
      *width_ptr = width;
    }
#line 135
    if (height_ptr != (void *)0) {
#line 135
      *height_ptr = height;
    }
#line 137
    *data += vp8x_size;
#line 138
    *data_size -= (unsigned long )vp8x_size;
#line 139
    *found_vp8x = 1;
  }
#line 141
  return ((enum VP8StatusCode )0);
}
}
#line 151 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static enum VP8StatusCode ParseOptionalChunks(uint8_t **data , size_t *data_size ,
                                              size_t riff_size , uint8_t **alpha_data ,
                                              size_t *alpha_size ) 
{ 
  uint8_t *buf ;
  size_t buf_size ;
  uint32_t total_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t chunk_size ;
  uint32_t disk_chunk_size ;
  uint32_t __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 158
  total_size = (uint32_t )22;
#line 163
  buf = *data;
#line 164
  buf_size = *data_size;
#line 168
  *alpha_data = (uint8_t *)((void *)0);
#line 169
  *alpha_size = (size_t )0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    *data = buf;
#line 176
    *data_size = buf_size;
#line 178
    if (buf_size < 8UL) {
#line 179
      return ((enum VP8StatusCode )7);
    }
    {
#line 182
    chunk_size = get_le32(buf + 4);
    }
#line 183
    if (chunk_size > 4294967286U) {
#line 184
      return ((enum VP8StatusCode )3);
    }
#line 187
    disk_chunk_size = ((8U + chunk_size) + 1U) & 4294967294U;
#line 188
    total_size += disk_chunk_size;
#line 191
    if (riff_size > 0UL) {
#line 191
      if ((unsigned long )total_size > riff_size) {
#line 192
        return ((enum VP8StatusCode )3);
      }
    }
#line 195
    if (buf_size < (unsigned long )disk_chunk_size) {
#line 196
      return ((enum VP8StatusCode )7);
    }
    {
#line 199
    __cil_tmp16 = memcmp(buf, "ALPH\256U\001", (unsigned long )4);
    }
#line 199
    if (! __cil_tmp16) {
#line 200
      *alpha_data = buf + 8;
#line 201
      *alpha_size = (size_t )chunk_size;
    } else {
      {
#line 202
      __cil_tmp18 = memcmp(buf, "VP8L\002", (unsigned long )4);
      }
      {
#line 202
      __cil_tmp17 = memcmp(buf, "VP8 \002", (unsigned long )4);
      }
#line 202
      if (! __cil_tmp17) {
#line 204
        return ((enum VP8StatusCode )0);
      } else
#line 202
      if (! __cil_tmp18) {
#line 204
        return ((enum VP8StatusCode )0);
      }
    }
#line 208
    buf += disk_chunk_size;
#line 209
    buf_size -= (unsigned long )disk_chunk_size;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 221 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static enum VP8StatusCode ParseVP8Header(uint8_t **data_ptr , size_t *data_size ,
                                         size_t riff_size , size_t *chunk_size , int *is_lossless ) 
{ 
  uint8_t *data ;
  int is_vp8 ;
  int __cil_tmp8 ;
  int is_vp8l ;
  int __cil_tmp10 ;
  uint32_t minimal_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t size ;
  uint32_t __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 226
  data = *data_ptr;
#line 227
  __cil_tmp8 = memcmp(data, "VP8 ", (unsigned long )4);
#line 227
  is_vp8 = ! __cil_tmp8;
#line 228
  __cil_tmp10 = memcmp(data, "VP8L", (unsigned long )4);
#line 228
  is_vp8l = ! __cil_tmp10;
#line 229
  minimal_size = (uint32_t )12;
  }
#line 237
  if (*data_size < 8UL) {
#line 238
    return ((enum VP8StatusCode )7);
  }
#line 241
  if (is_vp8) {
    _L: /* CIL Label */ 
    {
#line 243
    __cil_tmp17 = get_le32(data + 4);
#line 243
    size = __cil_tmp17;
    }
#line 244
    if (riff_size >= (unsigned long )minimal_size) {
#line 244
      if ((unsigned long )size > riff_size - (unsigned long )minimal_size) {
#line 245
        return ((enum VP8StatusCode )3);
      }
    }
#line 248
    *chunk_size = (size_t )size;
#line 249
    *data_ptr += 8;
#line 250
    *data_size -= (unsigned long )8;
#line 251
    *is_lossless = is_vp8l;
  } else
#line 241
  if (is_vp8l) {
#line 241
    goto _L;
  } else {
    {
#line 254
    *is_lossless = VP8LCheckSignature(data, *data_size);
#line 255
    *chunk_size = *data_size;
    }
  }
#line 258
  return ((enum VP8StatusCode )0);
}
}
#line 274 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static enum VP8StatusCode ParseHeadersInternal(uint8_t *data , size_t data_size ,
                                               int *width , int *height , int *has_alpha ,
                                               int *has_animation , WebPHeaderStructure *headers ) 
{ 
  int found_riff ;
  int found_vp8x ;
  enum VP8StatusCode status ;
  WebPHeaderStructure hdrs ;
  enum VP8StatusCode __cil_tmp12 ;
  uint32_t flags ;
  enum VP8StatusCode __cil_tmp14 ;
  int __cil_tmp15 ;
  enum VP8StatusCode __cil_tmp16 ;
  enum VP8StatusCode __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  int tmp___0 ;

  {
#line 281
  found_riff = 0;
#line 282
  found_vp8x = 0;
#line 286
  if (data == (void *)0) {
#line 287
    return ((enum VP8StatusCode )7);
  } else
#line 286
  if (data_size < 12UL) {
#line 287
    return ((enum VP8StatusCode )7);
  }
  {
#line 289
  memset(& hdrs, 0, sizeof(hdrs));
#line 290
  hdrs.data = data;
#line 291
  hdrs.data_size = data_size;
#line 294
  status = ParseRIFF(& data, & data_size, & hdrs.riff_size);
  }
#line 295
  if ((unsigned int )status != 0U) {
#line 296
    return (status);
  }
  {
#line 298
  found_riff = hdrs.riff_size > 0UL;
#line 302
  flags = (uint32_t )0;
#line 303
  status = ParseVP8X(& data, & data_size, & found_vp8x, width, height, & flags);
  }
#line 304
  if ((unsigned int )status != 0U) {
#line 305
    return (status);
  }
#line 307
  if (! found_riff) {
#line 307
    if (found_vp8x) {
#line 310
      return ((enum VP8StatusCode )3);
    }
  }
#line 312
  if (has_alpha != (void *)0) {
#line 312
    *has_alpha = ! (! (flags & 16U));
  }
#line 313
  if (has_animation != (void *)0) {
#line 313
    *has_animation = ! (! (flags & 2U));
  }
#line 314
  if (headers == (void *)0) {
#line 314
    if (found_vp8x) {
#line 315
      return ((enum VP8StatusCode )0);
    }
  }
#line 319
  if (data_size < 4UL) {
#line 319
    return ((enum VP8StatusCode )7);
  }
  {
#line 322
  __cil_tmp15 = memcmp(data, "ALPHrU", (unsigned long )4);
  }
#line 322
  if (found_riff) {
#line 322
    if (found_vp8x) {
      _L: /* CIL Label */ 
      {
#line 324
      status = ParseOptionalChunks(& data, & data_size, hdrs.riff_size, & hdrs.alpha_data,
                                   & hdrs.alpha_data_size);
      }
#line 326
      if ((unsigned int )status != 0U) {
#line 327
        return (status);
      }
    } else {
#line 322
      goto _L___14;
    }
  } else
  _L___14: /* CIL Label */ 
#line 322
  if (! found_riff) {
#line 322
    if (! found_vp8x) {
#line 322
      if (! __cil_tmp15) {
#line 322
        goto _L;
      }
    }
  }
  {
#line 332
  status = ParseVP8Header(& data, & data_size, hdrs.riff_size, & hdrs.compressed_size,
                          & hdrs.is_lossless);
  }
#line 334
  if ((unsigned int )status != 0U) {
#line 335
    return (status);
  }
#line 337
  if (hdrs.compressed_size > 4294967286UL) {
#line 338
    return ((enum VP8StatusCode )3);
  }
#line 341
  if (! hdrs.is_lossless) {
#line 342
    if (data_size < 10UL) {
#line 343
      return ((enum VP8StatusCode )7);
    }
    {
#line 346
    __cil_tmp18 = VP8GetInfo(data, data_size, (size_t )((uint32_t )hdrs.compressed_size),
                             width, height);
    }
#line 346
    if (! __cil_tmp18) {
#line 348
      return ((enum VP8StatusCode )3);
    }
  } else {
#line 351
    if (data_size < 5UL) {
#line 352
      return ((enum VP8StatusCode )7);
    }
    {
#line 355
    __cil_tmp19 = VP8LGetInfo(data, data_size, width, height, has_alpha);
    }
#line 355
    if (! __cil_tmp19) {
#line 356
      return ((enum VP8StatusCode )3);
    }
  }
#line 360
  if (has_alpha != (void *)0) {
#line 363
    *has_alpha |= hdrs.alpha_data != (void *)0;
  }
#line 365
  if (headers != (void *)0) {
#line 366
    *headers = hdrs;
#line 367
    headers->offset = (size_t )(data - headers->data);
  }
#line 371
  return ((enum VP8StatusCode )0);
}
}
#line 374 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
enum VP8StatusCode WebPParseHeaders(WebPHeaderStructure *headers ) 
{ 
  enum VP8StatusCode status ;
  int has_animation ;
  int tmp ;
  enum VP8StatusCode __cil_tmp5 ;

  {
  {
#line 376
  has_animation = 0;
#line 379
  status = ParseHeadersInternal(headers->data, headers->data_size, (int *)((void *)0),
                                (int *)((void *)0), (int *)((void *)0), & has_animation,
                                headers);
  }
#line 381
  if ((unsigned int )status == 0U) {
    _L: /* CIL Label */ 
#line 383
    if (has_animation) {
#line 384
      status = (enum VP8StatusCode )4;
    }
  } else
#line 381
  if ((unsigned int )status == 7U) {
#line 381
    goto _L;
  }
#line 387
  return (status);
}
}
#line 393 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
void WebPResetDecParams(WebPDecParams *params ) 
{ 


  {
#line 394
  if (params) {
    {
#line 395
    memset(params, 0, sizeof(*params));
    }
  }
  return;
}
}
#line 403 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static enum VP8StatusCode DecodeInto(uint8_t *data , size_t data_size , WebPDecParams *params ) 
{ 
  enum VP8StatusCode status ;
  VP8Io io ;
  WebPHeaderStructure headers ;
  enum VP8StatusCode __cil_tmp7 ;
  int tmp ;
  VP8Decoder *dec ;
  VP8Decoder *__cil_tmp10 ;
  int __cil_tmp11 ;
  enum VP8StatusCode __cil_tmp12 ;
  int __cil_tmp13 ;
  VP8LDecoder *dec___0 ;
  VP8LDecoder *__cil_tmp15 ;
  int __cil_tmp16 ;
  enum VP8StatusCode __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 409
  headers.data = data;
#line 410
  headers.data_size = data_size;
#line 411
  status = WebPParseHeaders(& headers);
  }
#line 412
  if ((unsigned int )status != 0U) {
#line 413
    return (status);
  }
  {
#line 417
  VP8InitIo(& io);
#line 418
  io.data = headers.data + headers.offset;
#line 419
  io.data_size = headers.data_size - headers.offset;
#line 420
  WebPInitCustomIo(params, & io);
  }
#line 422
  if (! headers.is_lossless) {
    {
#line 423
    __cil_tmp10 = VP8New();
#line 423
    dec = __cil_tmp10;
    }
#line 424
    if (dec == (void *)0) {
#line 425
      return ((enum VP8StatusCode )1);
    }
    {
#line 428
    dec->use_threads_ = params->options && (params->options)->use_threads > 0;
#line 432
    dec->alpha_data_ = headers.alpha_data;
#line 433
    dec->alpha_data_size_ = headers.alpha_data_size;
#line 436
    __cil_tmp11 = VP8GetHeaders(dec, & io);
    }
#line 436
    if (! __cil_tmp11) {
#line 437
      status = dec->status_;
    } else {
      {
#line 440
      status = WebPAllocateDecBuffer(io.width, io.height, params->options, params->output);
      }
#line 442
      if ((unsigned int )status == 0U) {
        {
#line 443
        __cil_tmp13 = VP8Decode(dec, & io);
        }
#line 443
        if (! __cil_tmp13) {
#line 444
          status = dec->status_;
        }
      }
    }
    {
#line 448
    VP8Delete(dec);
    }
  } else {
    {
#line 450
    __cil_tmp15 = VP8LNew();
#line 450
    dec___0 = __cil_tmp15;
    }
#line 451
    if (dec___0 == (void *)0) {
#line 452
      return ((enum VP8StatusCode )1);
    }
    {
#line 454
    __cil_tmp16 = VP8LDecodeHeader(dec___0, & io);
    }
#line 454
    if (! __cil_tmp16) {
#line 455
      status = dec___0->status_;
    } else {
      {
#line 458
      status = WebPAllocateDecBuffer(io.width, io.height, params->options, params->output);
      }
#line 460
      if ((unsigned int )status == 0U) {
        {
#line 461
        __cil_tmp18 = VP8LDecodeImage(dec___0);
        }
#line 461
        if (! __cil_tmp18) {
#line 462
          status = dec___0->status_;
        }
      }
    }
    {
#line 466
    VP8LDelete(dec___0);
    }
  }
#line 469
  if ((unsigned int )status != 0U) {
    {
#line 470
    WebPFreeDecBuffer(params->output);
    }
  }
#line 472
  return (status);
}
}
#line 476 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static uint8_t *DecodeIntoRGBABuffer(enum WEBP_CSP_MODE colorspace , uint8_t *data ,
                                     size_t data_size , uint8_t *rgba , int stride ,
                                     size_t size ) 
{ 
  WebPDecParams params ;
  WebPDecBuffer buf ;
  enum VP8StatusCode __cil_tmp9 ;

  {
#line 483
  if (rgba == (void *)0) {
#line 484
    return ((uint8_t *)((void *)0));
  }
  {
#line 486
  WebPInitDecBuffer(& buf);
#line 487
  WebPResetDecParams(& params);
#line 488
  params.output = & buf;
#line 489
  buf.colorspace = colorspace;
#line 490
  buf.u.RGBA.rgba = rgba;
#line 491
  buf.u.RGBA.stride = stride;
#line 492
  buf.u.RGBA.size = size;
#line 493
  buf.is_external_memory = 1;
#line 494
  __cil_tmp9 = DecodeInto(data, data_size, & params);
  }
#line 494
  if ((unsigned int )__cil_tmp9 != 0U) {
#line 495
    return ((uint8_t *)((void *)0));
  }
#line 497
  return (rgba);
}
}
#line 500 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeRGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 502
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )0, data, data_size, output,
                                    stride, size);
  }
#line 502
  return (__cil_tmp6);
}
}
#line 505 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeRGBAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 507
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )1, data, data_size, output,
                                    stride, size);
  }
#line 507
  return (__cil_tmp6);
}
}
#line 510 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeARGBInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 512
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )4, data, data_size, output,
                                    stride, size);
  }
#line 512
  return (__cil_tmp6);
}
}
#line 515 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeBGRInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                           int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 517
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )2, data, data_size, output,
                                    stride, size);
  }
#line 517
  return (__cil_tmp6);
}
}
#line 520 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeBGRAInto(uint8_t *data , size_t data_size , uint8_t *output , size_t size ,
                            int stride ) 
{ 
  uint8_t *__cil_tmp6 ;

  {
  {
#line 522
  __cil_tmp6 = DecodeIntoRGBABuffer((enum WEBP_CSP_MODE )3, data, data_size, output,
                                    stride, size);
  }
#line 522
  return (__cil_tmp6);
}
}
#line 525 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeYUVInto(uint8_t *data , size_t data_size , uint8_t *luma , size_t luma_size ,
                           int luma_stride , uint8_t *u , size_t u_size , int u_stride ,
                           uint8_t *v , size_t v_size , int v_stride ) 
{ 
  WebPDecParams params ;
  WebPDecBuffer output ;
  enum VP8StatusCode __cil_tmp14 ;

  {
#line 531
  if (luma == (void *)0) {
#line 531
    return ((uint8_t *)((void *)0));
  }
  {
#line 532
  WebPInitDecBuffer(& output);
#line 533
  WebPResetDecParams(& params);
#line 534
  params.output = & output;
#line 535
  output.colorspace = (enum WEBP_CSP_MODE )11;
#line 536
  output.u.YUVA.y = luma;
#line 537
  output.u.YUVA.y_stride = luma_stride;
#line 538
  output.u.YUVA.y_size = luma_size;
#line 539
  output.u.YUVA.u = u;
#line 540
  output.u.YUVA.u_stride = u_stride;
#line 541
  output.u.YUVA.u_size = u_size;
#line 542
  output.u.YUVA.v = v;
#line 543
  output.u.YUVA.v_stride = v_stride;
#line 544
  output.u.YUVA.v_size = v_size;
#line 545
  output.is_external_memory = 1;
#line 546
  __cil_tmp14 = DecodeInto(data, data_size, & params);
  }
#line 546
  if ((unsigned int )__cil_tmp14 != 0U) {
#line 547
    return ((uint8_t *)((void *)0));
  }
#line 549
  return (luma);
}
}
#line 554 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static uint8_t *Decode(enum WEBP_CSP_MODE mode , uint8_t *data , size_t data_size ,
                       int *width , int *height , WebPDecBuffer *keep_info ) 
{ 
  WebPDecParams params ;
  WebPDecBuffer output ;
  int __cil_tmp9 ;
  enum VP8StatusCode __cil_tmp10 ;
  int __cil_tmp11 ;
  uint8_t *tmp ;

  {
  {
#line 560
  WebPInitDecBuffer(& output);
#line 561
  WebPResetDecParams(& params);
#line 562
  params.output = & output;
#line 563
  output.colorspace = mode;
#line 566
  __cil_tmp9 = WebPGetInfo(data, data_size, & output.width, & output.height);
  }
#line 566
  if (! __cil_tmp9) {
#line 567
    return ((uint8_t *)((void *)0));
  }
#line 569
  if (width != (void *)0) {
#line 569
    *width = output.width;
  }
#line 570
  if (height != (void *)0) {
#line 570
    *height = output.height;
  }
  {
#line 573
  __cil_tmp10 = DecodeInto(data, data_size, & params);
  }
#line 573
  if ((unsigned int )__cil_tmp10 != 0U) {
#line 574
    return ((uint8_t *)((void *)0));
  }
#line 576
  if (keep_info != (void *)0) {
    {
#line 577
    WebPCopyDecBuffer(& output, keep_info);
    }
  }
  {
#line 580
  __cil_tmp11 = WebPIsRGBMode___0(mode);
  }
#line 580
  if (__cil_tmp11) {
#line 580
    tmp = output.u.RGBA.rgba;
  } else {
#line 580
    tmp = output.u.YUVA.y;
  }
#line 580
  return (tmp);
}
}
#line 583 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeRGB(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 585
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )0, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 585
  return (__cil_tmp5);
}
}
#line 588 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeRGBA(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 590
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )1, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 590
  return (__cil_tmp5);
}
}
#line 593 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeARGB(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 595
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )4, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 595
  return (__cil_tmp5);
}
}
#line 598 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeBGR(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 600
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )2, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 600
  return (__cil_tmp5);
}
}
#line 603 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeBGRA(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  uint8_t *__cil_tmp5 ;

  {
  {
#line 605
  __cil_tmp5 = Decode((enum WEBP_CSP_MODE )3, data, data_size, width, height, (WebPDecBuffer *)((void *)0));
  }
#line 605
  return (__cil_tmp5);
}
}
#line 608 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
uint8_t *WebPDecodeYUV(uint8_t *data , size_t data_size , int *width , int *height ,
                       uint8_t **u , uint8_t **v , int *stride , int *uv_stride ) 
{ 
  WebPDecBuffer output ;
  uint8_t *out ;
  uint8_t *__cil_tmp11 ;
  WebPYUVABuffer *buf ;
  int tmp ;

  {
  {
#line 612
  __cil_tmp11 = Decode((enum WEBP_CSP_MODE )11, data, data_size, width, height, & output);
#line 612
  out = __cil_tmp11;
  }
#line 615
  if (out != (void *)0) {
#line 616
    buf = & output.u.YUVA;
#line 617
    *u = buf->u;
#line 618
    *v = buf->v;
#line 619
    *stride = buf->y_stride;
#line 620
    *uv_stride = buf->u_stride;
  }
#line 623
  return (out);
}
}
#line 626 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static void DefaultFeatures(WebPBitstreamFeatures *features ) 
{ 
  int tmp ;

  {
  {
#line 628
  memset(features, 0, sizeof(*features));
#line 629
  features->bitstream_version = 0;
  }
  return;
}
}
#line 632 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
static enum VP8StatusCode GetFeatures(uint8_t *data , size_t data_size , WebPBitstreamFeatures *features ) 
{ 
  enum VP8StatusCode __cil_tmp4 ;

  {
#line 634
  if (features == (void *)0) {
#line 635
    return ((enum VP8StatusCode )2);
  } else
#line 634
  if (data == (void *)0) {
#line 635
    return ((enum VP8StatusCode )2);
  }
  {
#line 637
  DefaultFeatures(features);
#line 640
  __cil_tmp4 = ParseHeadersInternal(data, data_size, & features->width, & features->height,
                                    & features->has_alpha, & features->has_animation,
                                    (WebPHeaderStructure *)((void *)0));
  }
#line 640
  return (__cil_tmp4);
}
}
#line 649 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
int WebPGetInfo(uint8_t *data , size_t data_size , int *width , int *height ) 
{ 
  WebPBitstreamFeatures features ;
  enum VP8StatusCode __cil_tmp6 ;

  {
  {
#line 653
  __cil_tmp6 = GetFeatures(data, data_size, & features);
  }
#line 653
  if ((unsigned int )__cil_tmp6 != 0U) {
#line 654
    return (0);
  }
#line 657
  if (width != (void *)0) {
#line 658
    *width = features.width;
  }
#line 660
  if (height != (void *)0) {
#line 661
    *height = features.height;
  }
#line 664
  return (1);
}
}
#line 670 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
int WebPInitDecoderConfigInternal(WebPDecoderConfig *config , int version ) 
{ 


  {
#line 672
  if (version >> 8 != 513 >> 8) {
#line 673
    return (0);
  }
#line 675
  if (config == (void *)0) {
#line 676
    return (0);
  }
  {
#line 678
  memset(config, 0, sizeof(*config));
#line 679
  DefaultFeatures(& config->input);
#line 680
  WebPInitDecBuffer(& config->output);
  }
#line 681
  return (1);
}
}
#line 684 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
enum VP8StatusCode___0 WebPGetFeaturesInternal(uint8_t *data , size_t data_size ,
                                               WebPBitstreamFeatures *features , int version ) 
{ 
  enum VP8StatusCode __cil_tmp5 ;

  {
#line 687
  if (version >> 8 != 513 >> 8) {
#line 688
    return ((enum VP8StatusCode )2);
  }
#line 690
  if (features == (void *)0) {
#line 691
    return ((enum VP8StatusCode )2);
  }
  {
#line 693
  __cil_tmp5 = GetFeatures(data, data_size, features);
  }
#line 693
  return (__cil_tmp5);
}
}
#line 696 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
enum VP8StatusCode___0 WebPDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) 
{ 
  WebPDecParams params ;
  enum VP8StatusCode status ;
  enum VP8StatusCode __cil_tmp6 ;
  enum VP8StatusCode __cil_tmp7 ;

  {
#line 701
  if (config == (void *)0) {
#line 702
    return ((enum VP8StatusCode )2);
  }
  {
#line 705
  status = GetFeatures(data, data_size, & config->input);
  }
#line 706
  if ((unsigned int )status != 0U) {
#line 707
    if ((unsigned int )status == 7U) {
#line 708
      return ((enum VP8StatusCode )3);
    }
#line 710
    return (status);
  }
  {
#line 713
  WebPResetDecParams(& params);
#line 714
  params.output = & config->output;
#line 715
  params.options = & config->options;
#line 716
  status = DecodeInto(data, data_size, & params);
  }
#line 718
  return (status);
}
}
#line 724 "/doner/libwebp/libwebp-v0.3.0/src/dec/webp.c"
int WebPIoInitFromOptions(WebPDecoderOptions *options , VP8Io *io , enum WEBP_CSP_MODE src_colorspace ) 
{ 
  int W ;
  int H ;
  int x ;
  int y ;
  int w ;
  int h ;
  int __cil_tmp10 ;

  {
#line 726
  W = io->width;
#line 727
  H = io->height;
#line 728
  x = 0;
#line 728
  y = 0;
#line 728
  w = W;
#line 728
  h = H;
#line 731
  io->use_cropping = options != (void *)0 && options->use_cropping > 0;
#line 732
  if (io->use_cropping) {
    {
#line 733
    w = options->crop_width;
#line 734
    h = options->crop_height;
#line 735
    x = options->crop_left;
#line 736
    y = options->crop_top;
#line 737
    __cil_tmp10 = WebPIsRGBMode___0(src_colorspace);
    }
#line 737
    if (! __cil_tmp10) {
#line 738
      x &= ~ 1;
#line 739
      y &= ~ 1;
    }
#line 741
    if (x < 0) {
#line 742
      return (0);
    } else
#line 741
    if (y < 0) {
#line 742
      return (0);
    } else
#line 741
    if (w <= 0) {
#line 742
      return (0);
    } else
#line 741
    if (h <= 0) {
#line 742
      return (0);
    } else
#line 741
    if (x + w > W) {
#line 742
      return (0);
    } else
#line 741
    if (y + h > H) {
#line 742
      return (0);
    }
  }
#line 745
  io->crop_left = x;
#line 746
  io->crop_top = y;
#line 747
  io->crop_right = x + w;
#line 748
  io->crop_bottom = y + h;
#line 749
  io->mb_w = w;
#line 750
  io->mb_h = h;
#line 753
  io->use_scaling = options != (void *)0 && options->use_scaling > 0;
#line 754
  if (io->use_scaling) {
#line 755
    if (options->scaled_width <= 0) {
#line 756
      return (0);
    } else
#line 755
    if (options->scaled_height <= 0) {
#line 756
      return (0);
    }
#line 758
    io->scaled_width = options->scaled_width;
#line 759
    io->scaled_height = options->scaled_height;
  }
#line 763
  io->bypass_filtering = options && options->bypass_filtering;
#line 767
  io->fancy_upsampling = options == (void *)0 || ! options->no_fancy_upsampling;
#line 770
  if (io->use_scaling) {
#line 772
    io->bypass_filtering = io->scaled_width < (W * 3) / 4 && io->scaled_height < (H * 3) / 4;
#line 774
    io->fancy_upsampling = 0;
  }
#line 776
  return (1);
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/./../utils/color_cache.h"
static uint32_t kHashMul___4  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___4(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___4 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/./../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___4(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___4 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/./../utils/color_cache.h"
__inline static int VP8LColorCacheContains___4(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___4 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 27 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int const   kCodeLengthLiterals  =    16;
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int const   kCodeLengthRepeatCode  =    16;
#line 29 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int const   kCodeLengthExtraBits[3]  = {      2,      3,      7};
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int const   kCodeLengthRepeatOffsets[3]  = {      3,      3,      11};
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static uint16_t kAlphabetSize[5]  = {      (uint16_t )280,      (uint16_t )256,      (uint16_t )256,      (uint16_t )256, 
        (uint16_t )40};
#line 55 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static uint8_t kCodeLengthCodeOrder[19]  = 
#line 55
  {      (uint8_t )17,      (uint8_t )18,      (uint8_t )0,      (uint8_t )1, 
        (uint8_t )2,      (uint8_t )3,      (uint8_t )4,      (uint8_t )5, 
        (uint8_t )16,      (uint8_t )6,      (uint8_t )7,      (uint8_t )8, 
        (uint8_t )9,      (uint8_t )10,      (uint8_t )11,      (uint8_t )12, 
        (uint8_t )13,      (uint8_t )14,      (uint8_t )15};
#line 60 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static uint8_t code_to_plane_lut[120]  = 
#line 60
  {      (uint8_t )24,      (uint8_t )7,      (uint8_t )23,      (uint8_t )25, 
        (uint8_t )40,      (uint8_t )6,      (uint8_t )39,      (uint8_t )41, 
        (uint8_t )22,      (uint8_t )26,      (uint8_t )38,      (uint8_t )42, 
        (uint8_t )56,      (uint8_t )5,      (uint8_t )55,      (uint8_t )57, 
        (uint8_t )21,      (uint8_t )27,      (uint8_t )54,      (uint8_t )58, 
        (uint8_t )37,      (uint8_t )43,      (uint8_t )72,      (uint8_t )4, 
        (uint8_t )71,      (uint8_t )73,      (uint8_t )20,      (uint8_t )28, 
        (uint8_t )53,      (uint8_t )59,      (uint8_t )70,      (uint8_t )74, 
        (uint8_t )36,      (uint8_t )44,      (uint8_t )88,      (uint8_t )69, 
        (uint8_t )75,      (uint8_t )52,      (uint8_t )60,      (uint8_t )3, 
        (uint8_t )87,      (uint8_t )89,      (uint8_t )19,      (uint8_t )29, 
        (uint8_t )86,      (uint8_t )90,      (uint8_t )35,      (uint8_t )45, 
        (uint8_t )68,      (uint8_t )76,      (uint8_t )85,      (uint8_t )91, 
        (uint8_t )51,      (uint8_t )61,      (uint8_t )104,      (uint8_t )2, 
        (uint8_t )103,      (uint8_t )105,      (uint8_t )18,      (uint8_t )30, 
        (uint8_t )102,      (uint8_t )106,      (uint8_t )34,      (uint8_t )46, 
        (uint8_t )84,      (uint8_t )92,      (uint8_t )67,      (uint8_t )77, 
        (uint8_t )101,      (uint8_t )107,      (uint8_t )50,      (uint8_t )62, 
        (uint8_t )120,      (uint8_t )1,      (uint8_t )119,      (uint8_t )121, 
        (uint8_t )83,      (uint8_t )93,      (uint8_t )17,      (uint8_t )31, 
        (uint8_t )100,      (uint8_t )108,      (uint8_t )66,      (uint8_t )78, 
        (uint8_t )118,      (uint8_t )122,      (uint8_t )33,      (uint8_t )47, 
        (uint8_t )117,      (uint8_t )123,      (uint8_t )49,      (uint8_t )63, 
        (uint8_t )99,      (uint8_t )109,      (uint8_t )82,      (uint8_t )94, 
        (uint8_t )0,      (uint8_t )116,      (uint8_t )124,      (uint8_t )65, 
        (uint8_t )79,      (uint8_t )16,      (uint8_t )32,      (uint8_t )98, 
        (uint8_t )110,      (uint8_t )48,      (uint8_t )115,      (uint8_t )125, 
        (uint8_t )81,      (uint8_t )95,      (uint8_t )64,      (uint8_t )114, 
        (uint8_t )126,      (uint8_t )97,      (uint8_t )111,      (uint8_t )80, 
        (uint8_t )113,      (uint8_t )127,      (uint8_t )96,      (uint8_t )112};
#line 75
static int DecodeImageStream(int xsize , int ysize , int is_level0 , VP8LDecoder *dec ,
                             uint32_t **decoded_data ) ;
#line 82 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
int VP8LCheckSignature(uint8_t *data , size_t size ) 
{ 


  {
#line 83
  return (size >= 1UL && (int )*(data + 0) == 47);
}
}
#line 86 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int ReadImageInfo(VP8LBitReader *br , int *width , int *height , int *has_alpha ) 
{ 
  uint8_t signature ;
  uint32_t __cil_tmp6 ;
  int __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;

  {
  {
#line 89
  __cil_tmp6 = VP8LReadBits(br, 8);
#line 89
  signature = (uint8_t )__cil_tmp6;
#line 90
  __cil_tmp7 = VP8LCheckSignature(& signature, (size_t )1);
  }
#line 90
  if (! __cil_tmp7) {
#line 91
    return (0);
  }
  {
#line 93
  __cil_tmp8 = VP8LReadBits(br, 14);
#line 93
  *width = (int )(__cil_tmp8 + 1U);
#line 94
  __cil_tmp9 = VP8LReadBits(br, 14);
#line 94
  *height = (int )(__cil_tmp9 + 1U);
#line 95
  __cil_tmp10 = VP8LReadBits(br, 1);
#line 95
  *has_alpha = (int )__cil_tmp10;
#line 96
  VP8LReadBits(br, 3);
  }
#line 97
  return (1);
}
}
#line 100 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
int VP8LGetInfo(uint8_t *data , size_t data_size , int *width , int *height , int *has_alpha ) 
{ 
  int w ;
  int h ;
  int a ;
  VP8LBitReader br ;
  int __cil_tmp10 ;

  {
#line 102
  if (data == (void *)0) {
#line 103
    return (0);
  } else
#line 102
  if (data_size < 5UL) {
#line 103
    return (0);
  } else {
    {
#line 107
    VP8LInitBitReader(& br, data, data_size);
#line 108
    __cil_tmp10 = ReadImageInfo(& br, & w, & h, & a);
    }
#line 108
    if (! __cil_tmp10) {
#line 109
      return (0);
    }
#line 111
    if (width != (void *)0) {
#line 111
      *width = w;
    }
#line 112
    if (height != (void *)0) {
#line 112
      *height = h;
    }
#line 113
    if (has_alpha != (void *)0) {
#line 113
      *has_alpha = a;
    }
#line 114
    return (1);
  }
}
}
#line 120 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
__inline static int GetCopyDistance(int distance_symbol , VP8LBitReader *br ) 
{ 
  int extra_bits ;
  int offset ;
  uint32_t __cil_tmp5 ;

  {
#line 123
  if (distance_symbol < 4) {
#line 124
    return (distance_symbol + 1);
  }
  {
#line 126
  extra_bits = (distance_symbol - 2) >> 1;
#line 127
  offset = (2 + (distance_symbol & 1)) << extra_bits;
#line 128
  __cil_tmp5 = VP8LReadBits(br, extra_bits);
  }
#line 128
  return ((int )(((unsigned int )offset + __cil_tmp5) + 1U));
}
}
#line 131 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
__inline static int GetCopyLength(int length_symbol , VP8LBitReader *br ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 134
  __cil_tmp3 = GetCopyDistance(length_symbol, br);
  }
#line 134
  return (__cil_tmp3);
}
}
#line 137 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
__inline static int PlaneCodeToDistance(int xsize , int plane_code ) 
{ 
  int dist_code ;
  int yoffset ;
  int xoffset ;
  int dist ;
  int tmp ;

  {
#line 138
  if (plane_code > 120) {
#line 139
    return (plane_code - 120);
  } else {
#line 141
    dist_code = (int )code_to_plane_lut[plane_code - 1];
#line 142
    yoffset = dist_code >> 4;
#line 143
    xoffset = 8 - (dist_code & 15);
#line 144
    dist = yoffset * xsize + xoffset;
#line 145
    if (dist >= 1) {
#line 145
      tmp = dist;
    } else {
#line 145
      tmp = 1;
    }
#line 145
    return (tmp);
  }
}
}
#line 153 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
__inline static int ReadSymbol(HuffmanTree___0 *tree , VP8LBitReader *br ) 
{ 
  HuffmanTreeNode *node ;
  int num_bits ;
  uint32_t bits ;
  uint32_t __cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;
  HuffmanTreeNode *__cil_tmp9 ;

  {
  {
#line 155
  node = tree->root_;
#line 156
  num_bits = 0;
#line 157
  __cil_tmp6 = VP8LPrefetchBits(br);
#line 157
  bits = __cil_tmp6;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    __cil_tmp8 = HuffmanTreeNodeIsLeaf(node);
    }
#line 159
    if (! (! __cil_tmp8)) {
#line 159
      goto while_break;
    }
    {
#line 160
    node = HuffmanTreeNextNode(node, (int )(bits & 1U));
#line 161
    bits >>= 1;
#line 162
    num_bits ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  VP8LDiscardBits(br, num_bits);
  }
#line 165
  return (node->symbol_);
}
}
#line 168 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int ReadHuffmanCodeLengths(VP8LDecoder *dec , int const   *code_length_code_lengths ,
                                  int num_symbols , int *code_lengths ) 
{ 
  int ok ;
  VP8LBitReader *br ;
  int symbol ;
  int max_symbol ;
  int prev_code_len ;
  HuffmanTree___0 tree ;
  int __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  int length_nbits ;
  uint32_t __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  int code_len ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int use_prev ;
  int slot ;
  int extra_bits ;
  int repeat_offset ;
  int repeat ;
  uint32_t __cil_tmp25 ;
  int length ;
  int tmp ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;

  {
  {
#line 171
  ok = 0;
#line 172
  br = & dec->br_;
#line 175
  prev_code_len = 8;
#line 178
  __cil_tmp11 = HuffmanTreeBuildImplicit(& tree, code_length_code_lengths, 19);
  }
#line 178
  if (! __cil_tmp11) {
#line 180
    dec->status_ = (enum VP8StatusCode )3;
#line 181
    return (0);
  }
  {
#line 184
  __cil_tmp12 = VP8LReadBits(br, 1);
  }
#line 184
  if (__cil_tmp12) {
    {
#line 185
    __cil_tmp14 = VP8LReadBits(br, 3);
#line 185
    length_nbits = (int )(2U + 2U * __cil_tmp14);
#line 186
    __cil_tmp15 = VP8LReadBits(br, length_nbits);
#line 186
    max_symbol = (int )(2U + __cil_tmp15);
    }
#line 187
    if (max_symbol > num_symbols) {
#line 188
      dec->status_ = (enum VP8StatusCode )3;
#line 189
      goto End;
    }
  } else {
#line 192
    max_symbol = num_symbols;
  }
#line 195
  symbol = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (symbol < num_symbols)) {
#line 196
      goto while_break;
    }
#line 198
    __cil_tmp17 = max_symbol;
#line 198
    max_symbol --;
#line 198
    if (__cil_tmp17 == 0) {
#line 198
      goto while_break;
    }
    {
#line 199
    VP8LFillBitWindow(br);
#line 200
    code_len = ReadSymbol(& tree, br);
    }
#line 201
    if (code_len < kCodeLengthLiterals) {
#line 202
      __cil_tmp19 = symbol;
#line 202
      symbol ++;
#line 202
      *(code_lengths + __cil_tmp19) = code_len;
#line 203
      if (code_len != 0) {
#line 203
        prev_code_len = code_len;
      }
    } else {
      {
#line 205
      use_prev = code_len == kCodeLengthRepeatCode;
#line 206
      slot = code_len - kCodeLengthLiterals;
#line 207
      extra_bits = kCodeLengthExtraBits[slot];
#line 208
      repeat_offset = kCodeLengthRepeatOffsets[slot];
#line 209
      __cil_tmp25 = VP8LReadBits(br, extra_bits);
#line 209
      repeat = (int )(__cil_tmp25 + (unsigned int )repeat_offset);
      }
#line 210
      if (symbol + repeat > num_symbols) {
#line 211
        dec->status_ = (enum VP8StatusCode )3;
#line 212
        goto End;
      } else {
#line 214
        if (use_prev) {
#line 214
          tmp = prev_code_len;
        } else {
#line 214
          tmp = 0;
        }
#line 214
        length = tmp;
        {
#line 215
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 215
          __cil_tmp28 = repeat;
#line 215
          repeat --;
#line 215
          if (! (__cil_tmp28 > 0)) {
#line 215
            goto while_break___0;
          }
#line 215
          __cil_tmp29 = symbol;
#line 215
          symbol ++;
#line 215
          *(code_lengths + __cil_tmp29) = length;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  ok = 1;
  End: 
  {
#line 222
  HuffmanTreeRelease(& tree);
  }
#line 223
  return (ok);
}
}
#line 226 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int ReadHuffmanCode(int alphabet_size , VP8LDecoder *dec , HuffmanTree___0 *tree ) 
{ 
  int ok ;
  VP8LBitReader *br ;
  int simple_code ;
  uint32_t __cil_tmp7 ;
  int symbols[2] ;
  int codes[2] ;
  int code_lengths[2] ;
  int num_symbols ;
  uint32_t __cil_tmp12 ;
  int first_symbol_len_code ;
  uint32_t __cil_tmp14 ;
  int tmp ;
  uint32_t __cil_tmp16 ;
  uint32_t __cil_tmp17 ;
  int __cil_tmp18 ;
  int *code_lengths___0 ;
  int i ;
  int code_length_code_lengths[19] ;
  unsigned int tmp___0 ;
  int num_codes ;
  uint32_t __cil_tmp24 ;
  void *__cil_tmp25 ;
  uint32_t __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
  {
#line 228
  ok = 0;
#line 229
  br = & dec->br_;
#line 230
  __cil_tmp7 = VP8LReadBits(br, 1);
#line 230
  simple_code = (int )__cil_tmp7;
  }
#line 232
  if (simple_code) {
    {
#line 236
    __cil_tmp12 = VP8LReadBits(br, 1);
#line 236
    num_symbols = (int )(__cil_tmp12 + 1U);
#line 237
    __cil_tmp14 = VP8LReadBits(br, 1);
#line 237
    first_symbol_len_code = (int )__cil_tmp14;
    }
#line 239
    if (first_symbol_len_code == 0) {
#line 239
      tmp = 1;
    } else {
#line 239
      tmp = 8;
    }
    {
#line 239
    __cil_tmp16 = VP8LReadBits(br, tmp);
#line 239
    symbols[0] = (int )__cil_tmp16;
#line 240
    codes[0] = 0;
#line 241
    code_lengths[0] = num_symbols - 1;
    }
#line 243
    if (num_symbols == 2) {
      {
#line 244
      __cil_tmp17 = VP8LReadBits(br, 8);
#line 244
      symbols[1] = (int )__cil_tmp17;
#line 245
      codes[1] = 1;
#line 246
      code_lengths[1] = num_symbols - 1;
      }
    }
    {
#line 248
    ok = HuffmanTreeBuildExplicit(tree, (int const   *)((int *)code_lengths), (int const   *)((int *)codes),
                                  (int const   *)((int *)symbols), alphabet_size,
                                  num_symbols);
    }
  } else {
#line 251
    code_lengths___0 = (int *)((void *)0);
#line 253
    code_length_code_lengths[0] = 0;
#line 253
    tmp___0 = (unsigned int )1;
    {
#line 253
    while (1) {
      while_continue: /* CIL Label */ ;
#line 253
      if (tmp___0 >= 19) {
#line 253
        goto while_break;
      }
#line 253
      code_length_code_lengths[tmp___0] = 0;
#line 253
      tmp___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 254
    __cil_tmp24 = VP8LReadBits(br, 4);
#line 254
    num_codes = (int )(__cil_tmp24 + 4U);
    }
#line 255
    if (num_codes > 19) {
#line 256
      dec->status_ = (enum VP8StatusCode )3;
#line 257
      return (0);
    }
    {
#line 260
    __cil_tmp25 = WebPSafeCalloc((uint64_t )alphabet_size, sizeof(*code_lengths___0));
#line 260
    code_lengths___0 = (int *)__cil_tmp25;
    }
#line 262
    if (code_lengths___0 == (void *)0) {
#line 263
      dec->status_ = (enum VP8StatusCode )1;
#line 264
      return (0);
    }
#line 267
    i = 0;
    {
#line 267
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 267
      if (! (i < num_codes)) {
#line 267
        goto while_break___0;
      }
      {
#line 268
      __cil_tmp26 = VP8LReadBits(br, 3);
#line 268
      code_length_code_lengths[kCodeLengthCodeOrder[i]] = (int )__cil_tmp26;
      }
#line 267
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 270
    ok = ReadHuffmanCodeLengths(dec, (int const   *)((int *)code_length_code_lengths),
                                alphabet_size, code_lengths___0);
    }
#line 272
    if (ok) {
      {
#line 273
      ok = HuffmanTreeBuildImplicit(tree, (int const   *)code_lengths___0, alphabet_size);
      }
    }
    {
#line 275
    free(code_lengths___0);
    }
  }
#line 277
  ok = ok && ! br->error_;
#line 278
  if (! ok) {
#line 279
    dec->status_ = (enum VP8StatusCode )3;
#line 280
    return (0);
  }
#line 282
  return (1);
}
}
#line 285 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static void DeleteHtreeGroups(HTreeGroup *htree_groups , int num_htree_groups ) 
{ 
  int i ;
  int j ;
  HuffmanTree___0 *htrees ;

  {
#line 286
  if (htree_groups != (void *)0) {
#line 288
    i = 0;
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 288
      if (! (i < num_htree_groups)) {
#line 288
        goto while_break;
      }
#line 289
      htrees = (HuffmanTree___0 *)(htree_groups + i)->htrees_;
#line 290
      j = 0;
      {
#line 290
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 290
        if (! (j < 5)) {
#line 290
          goto while_break___0;
        }
        {
#line 291
        HuffmanTreeRelease(htrees + j);
        }
#line 290
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 288
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 294
    free(htree_groups);
    }
  }
  return;
}
}
#line 298 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int ReadHuffmanCodes(VP8LDecoder *dec , int xsize , int ysize , int color_cache_bits ,
                            int allow_recursion ) 
{ 
  int i ;
  int j ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  uint32_t *huffman_image ;
  HTreeGroup *htree_groups ;
  int num_htree_groups ;
  uint32_t __cil_tmp13 ;
  int huffman_precision ;
  uint32_t __cil_tmp15 ;
  int huffman_xsize ;
  uint32_t __cil_tmp17 ;
  int huffman_ysize ;
  uint32_t __cil_tmp19 ;
  int huffman_pixs ;
  int __cil_tmp21 ;
  int group ;
  int tmp ;
  void *__cil_tmp24 ;
  HuffmanTree___0 *htrees ;
  int alphabet_size ;
  int __cil_tmp27 ;

  {
  {
#line 301
  br = & dec->br_;
#line 302
  hdr = & dec->hdr_;
#line 303
  huffman_image = (uint32_t *)((void *)0);
#line 304
  htree_groups = (HTreeGroup *)((void *)0);
#line 305
  num_htree_groups = 1;
#line 307
  __cil_tmp13 = VP8LReadBits(br, 1);
  }
#line 307
  if (allow_recursion) {
#line 307
    if (__cil_tmp13) {
      {
#line 309
      __cil_tmp15 = VP8LReadBits(br, 3);
#line 309
      huffman_precision = (int )(__cil_tmp15 + 2U);
#line 310
      __cil_tmp17 = VP8LSubSampleSize((uint32_t )xsize, (uint32_t )huffman_precision);
#line 310
      huffman_xsize = (int )__cil_tmp17;
#line 311
      __cil_tmp19 = VP8LSubSampleSize((uint32_t )ysize, (uint32_t )huffman_precision);
#line 311
      huffman_ysize = (int )__cil_tmp19;
#line 312
      huffman_pixs = huffman_xsize * huffman_ysize;
#line 313
      __cil_tmp21 = DecodeImageStream(huffman_xsize, huffman_ysize, 0, dec, & huffman_image);
      }
#line 313
      if (! __cil_tmp21) {
#line 315
        dec->status_ = (enum VP8StatusCode )3;
#line 316
        goto Error;
      }
#line 318
      hdr->huffman_subsample_bits_ = huffman_precision;
#line 319
      i = 0;
      {
#line 319
      while (1) {
        while_continue: /* CIL Label */ ;
#line 319
        if (! (i < huffman_pixs)) {
#line 319
          goto while_break;
        }
#line 321
        group = (int )((*(huffman_image + i) >> 8) & 65535U);
#line 322
        *(huffman_image + i) = (uint32_t )group;
#line 323
        if (group >= num_htree_groups) {
#line 324
          num_htree_groups = group + 1;
        }
#line 319
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 329
  if (br->error_) {
#line 329
    goto Error;
  }
  {
#line 332
  __cil_tmp24 = WebPSafeCalloc((uint64_t )num_htree_groups, sizeof(*htree_groups));
#line 332
  htree_groups = (HTreeGroup *)__cil_tmp24;
  }
#line 335
  if (htree_groups == (void *)0) {
#line 336
    dec->status_ = (enum VP8StatusCode )1;
#line 337
    goto Error;
  }
#line 340
  i = 0;
  {
#line 340
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 340
    if (! (i < num_htree_groups)) {
#line 340
      goto while_break___0;
    }
#line 341
    htrees = (HuffmanTree___0 *)(htree_groups + i)->htrees_;
#line 342
    j = 0;
    {
#line 342
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 342
      if (! (j < 5)) {
#line 342
        goto while_break___1;
      }
#line 343
      alphabet_size = (int )kAlphabetSize[j];
#line 344
      if (j == 0) {
#line 344
        if (color_cache_bits > 0) {
#line 345
          alphabet_size += 1 << color_cache_bits;
        }
      }
      {
#line 347
      __cil_tmp27 = ReadHuffmanCode(alphabet_size, dec, htrees + j);
      }
#line 347
      if (! __cil_tmp27) {
#line 347
        goto Error;
      }
#line 342
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 340
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 352
  hdr->huffman_image_ = huffman_image;
#line 353
  hdr->num_htree_groups_ = num_htree_groups;
#line 354
  hdr->htree_groups_ = htree_groups;
#line 355
  return (1);
  Error: 
  {
#line 358
  free(huffman_image);
  }
  {
#line 359
  DeleteHtreeGroups(htree_groups, num_htree_groups);
  }
#line 360
  return (0);
}
}
#line 366 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int AllocateAndInitRescaler(VP8LDecoder *dec , VP8Io *io ) 
{ 
  int num_channels ;
  int in_width ;
  int out_width ;
  int in_height ;
  int out_height ;
  uint64_t work_size ;
  int32_t *work ;
  uint64_t scaled_data_size ;
  uint32_t *scaled_data ;
  uint64_t memory_size ;
  uint8_t *memory ;
  void *__cil_tmp14 ;
  int tmp ;

  {
  {
#line 367
  num_channels = 4;
#line 368
  in_width = io->mb_w;
#line 369
  out_width = io->scaled_width;
#line 370
  in_height = io->mb_h;
#line 371
  out_height = io->scaled_height;
#line 372
  work_size = (unsigned long )(2 * num_channels) * (uint64_t )out_width;
#line 374
  scaled_data_size = (unsigned long )num_channels * (uint64_t )out_width;
#line 376
  memory_size = (sizeof(*(dec->rescaler)) + work_size * sizeof(*work)) + scaled_data_size * sizeof(*scaled_data);
#line 379
  __cil_tmp14 = WebPSafeCalloc(memory_size, sizeof(*memory));
#line 379
  memory = (uint8_t *)__cil_tmp14;
  }
#line 380
  if (memory == (void *)0) {
#line 381
    dec->status_ = (enum VP8StatusCode )1;
#line 382
    return (0);
  }
  {
#line 385
  dec->rescaler_memory = memory;
#line 387
  dec->rescaler = (WebPRescaler *)memory;
#line 388
  memory += sizeof(*(dec->rescaler));
#line 389
  work = (int32_t *)memory;
#line 390
  memory += work_size * sizeof(*work);
#line 391
  scaled_data = (uint32_t *)memory;
#line 393
  WebPRescalerInit(dec->rescaler, in_width, in_height, (uint8_t *)scaled_data, out_width,
                   out_height, 0, num_channels, in_width, out_width, in_height, out_height,
                   work);
  }
#line 396
  return (1);
}
}
#line 403 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int Export(WebPRescaler *rescaler , enum WEBP_CSP_MODE colorspace , int rgba_stride ,
                  uint8_t *rgba ) 
{ 
  uint32_t *src ;
  int dst_width ;
  int num_lines_out ;
  int __cil_tmp8 ;
  uint8_t *dst ;

  {
#line 405
  src = (uint32_t *)rescaler->dst;
#line 406
  dst_width = rescaler->dst_width;
#line 407
  num_lines_out = 0;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 408
    __cil_tmp8 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 408
    if (! __cil_tmp8) {
#line 408
      goto while_break;
    }
    {
#line 409
    dst = rgba + num_lines_out * rgba_stride;
#line 410
    WebPRescalerExportRow(rescaler);
#line 411
    VP8LConvertFromBGRA(src, dst_width, colorspace, dst);
#line 412
    num_lines_out ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 414
  return (num_lines_out);
}
}
#line 418 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int EmitRescaledRows(VP8LDecoder *dec , uint32_t *data , int in_stride , int mb_h ,
                            uint8_t *out , int out_stride ) 
{ 
  enum WEBP_CSP_MODE colorspace ;
  uint8_t *in ;
  int num_lines_in ;
  int num_lines_out ;
  uint8_t *row_in ;
  uint8_t *row_out ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 421
  colorspace = (dec->output_)->colorspace;
#line 422
  in = (uint8_t *)data;
#line 423
  num_lines_in = 0;
#line 424
  num_lines_out = 0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (num_lines_in < mb_h)) {
#line 425
      goto while_break;
    }
    {
#line 426
    row_in = in + num_lines_in * in_stride;
#line 427
    row_out = out + num_lines_out * out_stride;
#line 428
    __cil_tmp13 = WebPRescalerImport(dec->rescaler, mb_h - num_lines_in, row_in, in_stride);
    }
    {
#line 428
    num_lines_in += __cil_tmp13;
#line 430
    __cil_tmp14 = Export(dec->rescaler, colorspace, out_stride, row_out);
    }
#line 430
    num_lines_out += __cil_tmp14;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  return (num_lines_out);
}
}
#line 436 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int EmitRows(enum WEBP_CSP_MODE colorspace , uint32_t *data , int in_stride ,
                    int mb_w , int mb_h , uint8_t *out , int out_stride ) 
{ 
  int lines ;
  uint8_t *row_in ;
  uint8_t *row_out ;
  int __cil_tmp11 ;

  {
#line 440
  lines = mb_h;
#line 441
  row_in = (uint8_t *)data;
#line 442
  row_out = out;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    __cil_tmp11 = lines;
#line 443
    lines --;
#line 443
    if (! (__cil_tmp11 > 0)) {
#line 443
      goto while_break;
    }
    {
#line 444
    VP8LConvertFromBGRA((uint32_t *)row_in, mb_w, colorspace, row_out);
#line 445
    row_in += in_stride;
#line 446
    row_out += out_stride;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  return (mb_h);
}
}
#line 454 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static void ConvertToYUVA(uint32_t *src , int width , int y_pos , WebPDecBuffer *output ) 
{ 
  WebPYUVABuffer *buf ;
  int i ;
  uint8_t *y ;
  uint32_t p ;
  int __cil_tmp9 ;
  uint8_t *u ;
  uint8_t *v ;
  int uv_width ;
  int i___0 ;
  uint32_t v0 ;
  uint32_t v1 ;
  int r ;
  int g ;
  int b ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp_u ;
  int __cil_tmp22 ;
  int tmp_v ;
  int __cil_tmp24 ;
  uint32_t v0___0 ;
  int r___0 ;
  int g___0 ;
  int b___0 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int tmp_u___0 ;
  int __cil_tmp32 ;
  int tmp_v___0 ;
  int __cil_tmp34 ;
  int i___1 ;
  uint8_t *a ;

  {
#line 456
  buf = & output->u.YUVA;
#line 460
  y = buf->y + y_pos * buf->y_stride;
#line 461
  i = 0;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! (i < width)) {
#line 461
      goto while_break;
    }
    {
#line 462
    p = *(src + i);
#line 463
    __cil_tmp9 = VP8RGBToY((int )((p >> 16) & 255U), (int )((p >> 8) & 255U), (int )(p & 255U));
#line 463
    *(y + i) = (uint8_t )__cil_tmp9;
    }
#line 461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 469
  u = buf->u + (y_pos >> 1) * buf->u_stride;
#line 470
  v = buf->v + (y_pos >> 1) * buf->v_stride;
#line 471
  uv_width = width >> 1;
#line 473
  i___0 = 0;
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 473
    if (! (i___0 < uv_width)) {
#line 473
      goto while_break___0;
    }
#line 474
    v0 = *(src + 2 * i___0);
#line 475
    v1 = *(src + (2 * i___0 + 1));
#line 478
    r = (int )(((v0 >> 15) & 510U) + ((v1 >> 15) & 510U));
#line 479
    g = (int )(((v0 >> 7) & 510U) + ((v1 >> 7) & 510U));
#line 480
    b = (int )(((v0 << 1) & 510U) + ((v1 << 1) & 510U));
#line 481
    if (! (y_pos & 1)) {
      {
#line 482
      __cil_tmp19 = VP8RGBToU(r, g, b);
#line 482
      *(u + i___0) = (uint8_t )__cil_tmp19;
#line 483
      __cil_tmp20 = VP8RGBToV(r, g, b);
#line 483
      *(v + i___0) = (uint8_t )__cil_tmp20;
      }
    } else {
      {
#line 485
      __cil_tmp22 = VP8RGBToU(r, g, b);
#line 485
      tmp_u = __cil_tmp22;
#line 486
      __cil_tmp24 = VP8RGBToV(r, g, b);
#line 486
      tmp_v = __cil_tmp24;
#line 488
      *(u + i___0) = (uint8_t )((((int )*(u + i___0) + tmp_u) + 1) >> 1);
#line 489
      *(v + i___0) = (uint8_t )((((int )*(v + i___0) + tmp_v) + 1) >> 1);
      }
    }
#line 473
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 492
  if (width & 1) {
#line 493
    v0___0 = *(src + 2 * i___0);
#line 494
    r___0 = (int )((v0___0 >> 14) & 1020U);
#line 495
    g___0 = (int )((v0___0 >> 6) & 1020U);
#line 496
    b___0 = (int )((v0___0 << 2) & 1020U);
#line 497
    if (! (y_pos & 1)) {
      {
#line 498
      __cil_tmp29 = VP8RGBToU(r___0, g___0, b___0);
#line 498
      *(u + i___0) = (uint8_t )__cil_tmp29;
#line 499
      __cil_tmp30 = VP8RGBToV(r___0, g___0, b___0);
#line 499
      *(v + i___0) = (uint8_t )__cil_tmp30;
      }
    } else {
      {
#line 501
      __cil_tmp32 = VP8RGBToU(r___0, g___0, b___0);
#line 501
      tmp_u___0 = __cil_tmp32;
#line 502
      __cil_tmp34 = VP8RGBToV(r___0, g___0, b___0);
#line 502
      tmp_v___0 = __cil_tmp34;
#line 503
      *(u + i___0) = (uint8_t )((((int )*(u + i___0) + tmp_u___0) + 1) >> 1);
#line 504
      *(v + i___0) = (uint8_t )((((int )*(v + i___0) + tmp_v___0) + 1) >> 1);
      }
    }
  }
#line 509
  if (buf->a != (void *)0) {
#line 511
    a = buf->a + y_pos * buf->a_stride;
#line 512
    i___1 = 0;
    {
#line 512
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 512
      if (! (i___1 < width)) {
#line 512
        goto while_break___1;
      }
#line 512
      *(a + i___1) = (uint8_t )(*(src + i___1) >> 24);
#line 512
      i___1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 516 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int ExportYUVA(VP8LDecoder *dec , int y_pos ) 
{ 
  WebPRescaler *rescaler ;
  uint32_t *src ;
  int dst_width ;
  int num_lines_out ;
  int __cil_tmp7 ;

  {
#line 517
  rescaler = dec->rescaler;
#line 518
  src = (uint32_t *)rescaler->dst;
#line 519
  dst_width = rescaler->dst_width;
#line 520
  num_lines_out = 0;
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 521
    __cil_tmp7 = WebPRescalerHasPendingOutput(rescaler);
    }
#line 521
    if (! __cil_tmp7) {
#line 521
      goto while_break;
    }
    {
#line 522
    WebPRescalerExportRow(rescaler);
#line 523
    ConvertToYUVA(src, dst_width, y_pos, dec->output_);
#line 524
    y_pos ++;
#line 525
    num_lines_out ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  return (num_lines_out);
}
}
#line 530 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int EmitRescaledRowsYUVA(VP8LDecoder *dec , uint32_t *data , int in_stride ,
                                int mb_h ) 
{ 
  uint8_t *in ;
  int num_lines_in ;
  int y_pos ;
  uint8_t *row_in ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 533
  in = (uint8_t *)data;
#line 534
  num_lines_in = 0;
#line 535
  y_pos = dec->last_out_row_;
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (! (num_lines_in < mb_h)) {
#line 536
      goto while_break;
    }
    {
#line 537
    row_in = in + num_lines_in * in_stride;
#line 538
    __cil_tmp9 = WebPRescalerImport(dec->rescaler, mb_h - num_lines_in, row_in, in_stride);
    }
    {
#line 538
    num_lines_in += __cil_tmp9;
#line 540
    __cil_tmp10 = ExportYUVA(dec, y_pos);
    }
#line 540
    y_pos += __cil_tmp10;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return (y_pos);
}
}
#line 545 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int EmitRowsYUVA(VP8LDecoder *dec , uint32_t *data , int in_stride , int mb_w ,
                        int num_rows ) 
{ 
  int y_pos ;
  uint8_t *row_in ;
  int __cil_tmp8 ;

  {
#line 548
  y_pos = dec->last_out_row_;
#line 549
  row_in = (uint8_t *)data;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    __cil_tmp8 = num_rows;
#line 550
    num_rows --;
#line 550
    if (! (__cil_tmp8 > 0)) {
#line 550
      goto while_break;
    }
    {
#line 551
    ConvertToYUVA((uint32_t *)row_in, mb_w, y_pos, dec->output_);
#line 552
    row_in += in_stride;
#line 553
    y_pos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return (y_pos);
}
}
#line 566 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int SetCropWindow(VP8Io *io , int y_start , int y_end , uint32_t **in_data ,
                         int pixel_stride ) 
{ 
  int tmp ;
  int tmp___0 ;
  int delta ;

  {
#line 570
  if (y_end > io->crop_bottom) {
#line 571
    y_end = io->crop_bottom;
  }
#line 573
  if (y_start < io->crop_top) {
#line 574
    delta = io->crop_top - y_start;
#line 575
    y_start = io->crop_top;
#line 576
    *in_data += pixel_stride * delta;
  }
#line 578
  if (y_start >= y_end) {
#line 578
    return (0);
  }
#line 580
  *in_data += io->crop_left;
#line 582
  io->mb_y = y_start - io->crop_top;
#line 583
  io->mb_w = io->crop_right - io->crop_left;
#line 584
  io->mb_h = y_end - y_start;
#line 585
  return (1);
}
}
#line 590 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
__inline static int GetMetaIndex(uint32_t *image , int xsize , int bits , int x ,
                                 int y ) 
{ 


  {
#line 592
  if (bits == 0) {
#line 592
    return (0);
  }
#line 593
  return ((int )*(image + (xsize * (y >> bits) + (x >> bits))));
}
}
#line 596 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
__inline static HTreeGroup *GetHtreeGroupForPos(VP8LMetadata *hdr , int x , int y ) 
{ 
  int meta_index ;
  int __cil_tmp5 ;
  int tmp ;

  {
  {
#line 598
  __cil_tmp5 = GetMetaIndex(hdr->huffman_image_, hdr->huffman_xsize_, hdr->huffman_subsample_bits_,
                            x, y);
#line 598
  meta_index = __cil_tmp5;
  }
#line 601
  return (hdr->htree_groups_ + meta_index);
}
}
#line 609 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static void ApplyInverseTransforms(VP8LDecoder *dec , int num_rows , uint32_t *rows ) 
{ 
  int n ;
  int cache_pixs ;
  int start_row ;
  int end_row ;
  uint32_t *rows_in ;
  uint32_t *rows_out ;
  int __cil_tmp10 ;
  VP8LTransform *transform ;

  {
  {
#line 611
  n = dec->next_transform_;
#line 612
  cache_pixs = dec->width_ * num_rows;
#line 613
  start_row = dec->last_row_;
#line 614
  end_row = start_row + num_rows;
#line 615
  rows_in = rows;
#line 616
  rows_out = dec->argb_cache_;
#line 620
  memcpy(rows_out, rows_in, (unsigned long )cache_pixs * sizeof(*rows_out));
  }
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    __cil_tmp10 = n;
#line 621
    n --;
#line 621
    if (! (__cil_tmp10 > 0)) {
#line 621
      goto while_break;
    }
    {
#line 622
    transform = & dec->transforms_[n];
#line 623
    VP8LInverseTransform(transform, start_row, end_row, rows_in, rows_out);
#line 624
    rows_in = rows_out;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 630 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static void ProcessRows(VP8LDecoder *dec , int row ) 
{ 
  uint32_t *rows ;
  int num_rows ;
  VP8Io *io ;
  uint32_t *rows_data ;
  int __cil_tmp7 ;
  WebPDecBuffer *output ;
  int in_stride ;
  WebPRGBABuffer *buf ;
  uint8_t *rgba ;
  int num_rows_out ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 631
  rows = dec->argb_ + dec->width_ * dec->last_row_;
#line 632
  num_rows = row - dec->last_row_;
#line 634
  if (num_rows <= 0) {
#line 634
    return;
  }
  {
#line 635
  ApplyInverseTransforms(dec, num_rows, rows);
#line 639
  io = dec->io_;
#line 640
  rows_data = dec->argb_cache_;
#line 641
  __cil_tmp7 = SetCropWindow(io, dec->last_row_, row, & rows_data, io->width);
  }
#line 641
  if (! (! __cil_tmp7)) {
#line 644
    output = dec->output_;
#line 645
    in_stride = (int )((unsigned long )io->width * sizeof(*rows_data));
#line 646
    if ((unsigned int )output->colorspace < 11U) {
#line 647
      buf = & output->u.RGBA;
#line 648
      rgba = buf->rgba + dec->last_out_row_ * buf->stride;
#line 649
      if (io->use_scaling) {
        {
#line 649
        __cil_tmp13 = EmitRescaledRows(dec, rows_data, in_stride, io->mb_h, rgba,
                                       buf->stride);
#line 649
        tmp = __cil_tmp13;
        }
      } else {
        {
#line 649
        __cil_tmp14 = EmitRows(output->colorspace, rows_data, in_stride, io->mb_w,
                               io->mb_h, rgba, buf->stride);
#line 649
        tmp = __cil_tmp14;
        }
      }
#line 649
      num_rows_out = tmp;
#line 655
      dec->last_out_row_ += num_rows_out;
    } else {
#line 657
      if (io->use_scaling) {
        {
#line 657
        __cil_tmp16 = EmitRescaledRowsYUVA(dec, rows_data, in_stride, io->mb_h);
#line 657
        tmp___0 = __cil_tmp16;
        }
      } else {
        {
#line 657
        __cil_tmp17 = EmitRowsYUVA(dec, rows_data, in_stride, io->mb_w, io->mb_h);
#line 657
        tmp___0 = __cil_tmp17;
        }
      }
#line 657
      dec->last_out_row_ = tmp___0;
    }
  }
#line 666
  dec->last_row_ = row;
  return;
}
}
#line 670 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int DecodeImageData(VP8LDecoder *dec , uint32_t *data , int width , int height ,
                           ProcessRowsFunc process_func ) 
{ 
  int ok ;
  int col ;
  int row ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  HTreeGroup *htree_group ;
  uint32_t *src ;
  uint32_t *last_cached ;
  uint32_t *src_end ;
  int len_code_limit ;
  int color_cache_limit ;
  VP8LColorCache *color_cache ;
  VP8LColorCache *tmp ;
  int mask ;
  int tmp___0 ;
  int code ;
  HTreeGroup *__cil_tmp22 ;
  int __cil_tmp23 ;
  int red ;
  int green ;
  int blue ;
  int alpha ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  uint32_t *__cil_tmp31 ;
  int dist_code ;
  int dist ;
  int length_sym ;
  int length ;
  int __cil_tmp36 ;
  int dist_symbol ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int i ;
  HTreeGroup *__cil_tmp42 ;
  uint32_t *__cil_tmp43 ;
  int key ;
  int tmp___1 ;
  uint32_t *__cil_tmp46 ;
  uint32_t __cil_tmp47 ;
  int tmp___2 ;

  {
#line 673
  ok = 1;
#line 674
  col = 0;
#line 674
  row = 0;
#line 675
  br = & dec->br_;
#line 676
  hdr = & dec->hdr_;
#line 677
  htree_group = hdr->htree_groups_;
#line 678
  src = data;
#line 679
  last_cached = data;
#line 680
  src_end = data + width * height;
#line 681
  len_code_limit = 280;
#line 682
  color_cache_limit = len_code_limit + hdr->color_cache_size_;
#line 683
  if (hdr->color_cache_size_ > 0) {
#line 683
    tmp = & hdr->color_cache_;
  } else {
#line 683
    tmp = (VP8LColorCache *)((void *)0);
  }
#line 683
  color_cache = tmp;
#line 685
  mask = hdr->huffman_mask_;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 689
    if (! (src < src_end && ! br->eos_)) {
#line 689
      goto while_break;
    }
#line 694
    if ((col & mask) == 0) {
      {
#line 695
      htree_group = GetHtreeGroupForPos(hdr, col, row);
      }
    }
    {
#line 697
    VP8LFillBitWindow(br);
#line 698
    code = ReadSymbol(& htree_group->htrees_[0], br);
    }
#line 699
    if (code < 256) {
      {
#line 701
      red = ReadSymbol(& htree_group->htrees_[1], br);
#line 702
      green = code;
#line 703
      VP8LFillBitWindow(br);
#line 704
      blue = ReadSymbol(& htree_group->htrees_[2], br);
#line 705
      alpha = ReadSymbol(& htree_group->htrees_[3], br);
#line 706
      *src = (uint32_t )((((alpha << 24) + (red << 16)) + (green << 8)) + blue);
      }
      AdvanceByOne: 
#line 708
      src ++;
#line 709
      col ++;
#line 710
      if (col >= width) {
#line 711
        col = 0;
#line 712
        row ++;
#line 713
        if (process_func != (void *)0) {
#line 713
          if (row % 16 == 0) {
            {
#line 714
            (*process_func)(dec, row);
            }
          }
        }
#line 716
        if (color_cache != (void *)0) {
          {
#line 717
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 717
            if (! (last_cached < src)) {
#line 717
              goto while_break___0;
            }
            {
#line 718
            __cil_tmp31 = last_cached;
#line 718
            last_cached ++;
#line 718
            VP8LColorCacheInsert___4(color_cache, *__cil_tmp31);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    } else
#line 722
    if (code < len_code_limit) {
      {
#line 724
      length_sym = code - 256;
#line 725
      __cil_tmp36 = GetCopyLength(length_sym, br);
#line 725
      length = __cil_tmp36;
#line 726
      __cil_tmp38 = ReadSymbol(& htree_group->htrees_[4], br);
#line 726
      dist_symbol = __cil_tmp38;
#line 727
      VP8LFillBitWindow(br);
#line 728
      dist_code = GetCopyDistance(dist_symbol, br);
#line 729
      dist = PlaneCodeToDistance(width, dist_code);
      }
#line 730
      if (src - data < (long )dist) {
#line 731
        ok = 0;
#line 732
        goto End;
      } else
#line 730
      if (src_end - src < (long )length) {
#line 731
        ok = 0;
#line 732
        goto End;
      }
#line 736
      i = 0;
      {
#line 736
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 736
        if (! (i < length)) {
#line 736
          goto while_break___1;
        }
#line 736
        *(src + i) = *(src + (i - dist));
#line 736
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 737
      src += length;
#line 739
      col += length;
      {
#line 740
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 740
        if (! (col >= width)) {
#line 740
          goto while_break___2;
        }
#line 741
        col -= width;
#line 742
        row ++;
#line 743
        if (process_func != (void *)0) {
#line 743
          if (row % 16 == 0) {
            {
#line 744
            (*process_func)(dec, row);
            }
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 747
      if (src < src_end) {
        {
#line 748
        htree_group = GetHtreeGroupForPos(hdr, col, row);
        }
#line 749
        if (color_cache != (void *)0) {
          {
#line 750
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 750
            if (! (last_cached < src)) {
#line 750
              goto while_break___3;
            }
            {
#line 751
            __cil_tmp43 = last_cached;
#line 751
            last_cached ++;
#line 751
            VP8LColorCacheInsert___4(color_cache, *__cil_tmp43);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
    } else
#line 755
    if (code < color_cache_limit) {
#line 756
      key = code - len_code_limit;
      {
#line 758
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 758
        if (! (last_cached < src)) {
#line 758
          goto while_break___4;
        }
        {
#line 759
        __cil_tmp46 = last_cached;
#line 759
        last_cached ++;
#line 759
        VP8LColorCacheInsert___4(color_cache, *__cil_tmp46);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 761
      *src = VP8LColorCacheLookup(color_cache, (uint32_t )key);
      }
#line 762
      goto AdvanceByOne;
    } else {
#line 764
      ok = 0;
#line 765
      goto End;
    }
#line 767
    ok = ! br->error_;
#line 768
    if (! ok) {
#line 768
      goto End;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 771
  if (process_func != (void *)0) {
    {
#line 771
    (*process_func)(dec, row);
    }
  }
  End: 
#line 774
  if (src < src_end) {
#line 774
    if (br->eos_) {
      _L: /* CIL Label */ 
#line 775
      ok = 0;
#line 776
      if (! br->eos_) {
#line 776
        tmp___2 = 3;
      } else {
#line 776
        tmp___2 = 5;
      }
#line 776
      dec->status_ = (enum VP8StatusCode )tmp___2;
    } else {
#line 774
      goto _L___15;
    }
  } else
  _L___15: /* CIL Label */ 
#line 774
  if (br->error_) {
#line 774
    goto _L;
  } else
#line 774
  if (! ok) {
#line 774
    goto _L;
  } else
#line 778
  if (src == src_end) {
#line 779
    dec->state_ = (VP8LDecodeState )0;
  }
#line 782
  return (ok);
}
}
#line 788 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static void ClearTransform(VP8LTransform *transform ) 
{ 


  {
  {
#line 789
  free(transform->data_);
#line 790
  transform->data_ = (uint32_t *)((void *)0);
  }
  return;
}
}
#line 795 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int ExpandColorMap(int num_colors , VP8LTransform *transform ) 
{ 
  int i ;
  int final_num_colors ;
  uint32_t *new_color_map ;
  void *__cil_tmp6 ;
  uint8_t *data ;
  uint8_t *new_data ;

  {
  {
#line 797
  final_num_colors = 1 << (8 >> transform->bits_);
#line 798
  __cil_tmp6 = WebPSafeMalloc((uint64_t )final_num_colors, sizeof(*new_color_map));
#line 798
  new_color_map = (uint32_t *)__cil_tmp6;
  }
#line 801
  if (new_color_map == (void *)0) {
#line 802
    return (0);
  } else {
#line 804
    data = (uint8_t *)transform->data_;
#line 805
    new_data = (uint8_t *)new_color_map;
#line 806
    *(new_color_map + 0) = *(transform->data_ + 0);
#line 807
    i = 4;
    {
#line 807
    while (1) {
      while_continue: /* CIL Label */ ;
#line 807
      if (! (i < 4 * num_colors)) {
#line 807
        goto while_break;
      }
#line 809
      *(new_data + i) = (uint8_t )(((int )*(data + i) + (int )*(new_data + (i - 4))) & 255);
#line 807
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 811
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 811
      if (! (i < 4 * final_num_colors)) {
#line 811
        goto while_break___0;
      }
#line 812
      *(new_data + i) = (uint8_t )0;
#line 811
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 813
    free(transform->data_);
#line 814
    transform->data_ = new_color_map;
    }
  }
#line 816
  return (1);
}
}
#line 819 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int ReadTransform(int *xsize , int const   *ysize , VP8LDecoder *dec ) 
{ 
  int ok ;
  VP8LBitReader *br ;
  VP8LTransform *transform ;
  VP8LImageTransformType type ;
  uint32_t __cil_tmp8 ;
  int tmp ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int num_colors ;
  uint32_t __cil_tmp15 ;
  int bits ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int tmp___3 ;

  {
  {
#line 821
  ok = 1;
#line 822
  br = & dec->br_;
#line 823
  transform = & dec->transforms_[dec->next_transform_];
#line 824
  __cil_tmp8 = VP8LReadBits(br, 2);
#line 824
  type = (VP8LImageTransformType )__cil_tmp8;
  }
#line 828
  if (dec->transforms_seen_ & (1U << (unsigned int )type)) {
#line 829
    return (0);
  }
#line 831
  dec->transforms_seen_ |= 1U << (unsigned int )type;
#line 833
  transform->type_ = type;
#line 834
  transform->xsize_ = *xsize;
#line 835
  transform->ysize_ = *ysize;
#line 836
  transform->data_ = (uint32_t *)((void *)0);
#line 837
  (dec->next_transform_) ++;
  {
#line 842
  if ((unsigned int )type == (unsigned int )1) {
#line 842
    goto case_1;
  }
#line 842
  if ((unsigned int )type == (unsigned int )0) {
#line 842
    goto case_1;
  }
#line 850
  if ((unsigned int )type == (unsigned int )3) {
#line 850
    goto case_3;
  }
#line 862
  if ((unsigned int )type == (unsigned int )2) {
#line 862
    goto case_2;
  }
#line 840
  goto switch_break;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 843
  __cil_tmp10 = VP8LReadBits(br, 3);
#line 843
  transform->bits_ = (int )(__cil_tmp10 + 2U);
  }
  {
#line 844
  __cil_tmp11 = VP8LSubSampleSize((uint32_t )transform->xsize_, (uint32_t )transform->bits_);
  }
  {
#line 844
  __cil_tmp12 = VP8LSubSampleSize((uint32_t )transform->ysize_, (uint32_t )transform->bits_);
#line 844
  __cil_tmp13 = DecodeImageStream((int )__cil_tmp11, (int )__cil_tmp12, 0, dec, & transform->data_);
#line 844
  ok = __cil_tmp13;
  }
#line 849
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 851
  __cil_tmp15 = VP8LReadBits(br, 8);
#line 851
  num_colors = (int )(__cil_tmp15 + 1U);
  }
#line 852
  if (num_colors > 16) {
#line 852
    tmp___2 = 0;
  } else {
#line 852
    if (num_colors > 4) {
#line 852
      tmp___1 = 1;
    } else {
#line 852
      if (num_colors > 2) {
#line 852
        tmp___0 = 2;
      } else {
#line 852
        tmp___0 = 3;
      }
#line 852
      tmp___1 = tmp___0;
    }
#line 852
    tmp___2 = tmp___1;
  }
  {
#line 852
  bits = tmp___2;
#line 856
  __cil_tmp20 = VP8LSubSampleSize((uint32_t )transform->xsize_, (uint32_t )bits);
#line 856
  *xsize = (int )__cil_tmp20;
#line 857
  transform->bits_ = bits;
#line 858
  ok = DecodeImageStream(num_colors, 1, 0, dec, & transform->data_);
#line 859
  __cil_tmp22 = ExpandColorMap(num_colors, transform);
#line 859
  ok = ok && __cil_tmp22;
  }
#line 860
  goto switch_break;
  case_2: /* CIL Label */ 
#line 863
  goto switch_break;
#line 866
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 869
  return (ok);
}
}
#line 875 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static void InitMetadata(VP8LMetadata *hdr ) 
{ 
  int tmp ;

  {
  {
#line 877
  memset(hdr, 0, sizeof(*hdr));
  }
  return;
}
}
#line 880 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static void ClearMetadata(VP8LMetadata *hdr ) 
{ 
  int tmp ;

  {
  {
#line 883
  free(hdr->huffman_image_);
#line 884
  DeleteHtreeGroups(hdr->htree_groups_, hdr->num_htree_groups_);
#line 885
  VP8LColorCacheClear(& hdr->color_cache_);
#line 886
  InitMetadata(hdr);
  }
  return;
}
}
#line 892 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
VP8LDecoder *VP8LNew(void) 
{ 
  VP8LDecoder *dec ;
  void *__cil_tmp2 ;

  {
  {
#line 893
  __cil_tmp2 = calloc((unsigned long )1, sizeof(*dec));
#line 893
  dec = (VP8LDecoder *)__cil_tmp2;
  }
#line 894
  if (dec == (void *)0) {
#line 894
    return ((VP8LDecoder *)((void *)0));
  }
#line 895
  dec->status_ = (enum VP8StatusCode )0;
#line 896
  dec->action_ = (VP8LDecodeState )2;
#line 897
  dec->state_ = (VP8LDecodeState )2;
#line 898
  return (dec);
}
}
#line 901 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
void VP8LClear(VP8LDecoder *dec ) 
{ 
  int i ;

  {
#line 903
  if (dec == (void *)0) {
#line 903
    return;
  }
  {
#line 904
  ClearMetadata(& dec->hdr_);
#line 906
  free(dec->argb_);
#line 907
  dec->argb_ = (uint32_t *)((void *)0);
#line 908
  i = 0;
  }
  {
#line 908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 908
    if (! (i < dec->next_transform_)) {
#line 908
      goto while_break;
    }
    {
#line 909
    ClearTransform(& dec->transforms_[i]);
    }
#line 908
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 911
  dec->next_transform_ = 0;
#line 912
  dec->transforms_seen_ = (uint32_t )0;
#line 914
  free(dec->rescaler_memory);
#line 915
  dec->rescaler_memory = (uint8_t *)((void *)0);
#line 917
  dec->output_ = (WebPDecBuffer *)((void *)0);
  }
  return;
}
}
#line 920 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
void VP8LDelete(VP8LDecoder *dec ) 
{ 


  {
#line 921
  if (dec != (void *)0) {
    {
#line 922
    VP8LClear(dec);
#line 923
    free(dec);
    }
  }
  return;
}
}
#line 927 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static void UpdateDecoder(VP8LDecoder *dec , int width , int height ) 
{ 
  VP8LMetadata *hdr ;
  int num_bits ;
  uint32_t __cil_tmp6 ;
  int tmp ;

  {
  {
#line 928
  hdr = & dec->hdr_;
#line 929
  num_bits = hdr->huffman_subsample_bits_;
#line 930
  dec->width_ = width;
#line 931
  dec->height_ = height;
#line 933
  __cil_tmp6 = VP8LSubSampleSize((uint32_t )width, (uint32_t )num_bits);
#line 933
  hdr->huffman_xsize_ = (int )__cil_tmp6;
  }
#line 934
  if (num_bits == 0) {
#line 934
    tmp = ~ 0;
  } else {
#line 934
    tmp = (1 << num_bits) - 1;
  }
#line 934
  hdr->huffman_mask_ = tmp;
  return;
}
}
#line 937 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int DecodeImageStream(int xsize , int ysize , int is_level0 , VP8LDecoder *dec ,
                             uint32_t **decoded_data ) 
{ 
  int ok ;
  int transform_xsize ;
  int transform_ysize ;
  VP8LBitReader *br ;
  VP8LMetadata *hdr ;
  uint32_t *data ;
  int color_cache_bits ;
  uint32_t __cil_tmp13 ;
  int __cil_tmp14 ;
  uint32_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  uint64_t total_size ;
  void *__cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp ;
  int tmp___0 ;

  {
#line 941
  ok = 1;
#line 942
  transform_xsize = xsize;
#line 943
  transform_ysize = ysize;
#line 944
  br = & dec->br_;
#line 945
  hdr = & dec->hdr_;
#line 946
  data = (uint32_t *)((void *)0);
#line 947
  color_cache_bits = 0;
#line 950
  if (is_level0) {
    {
#line 951
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 951
      __cil_tmp13 = VP8LReadBits(br, 1);
      }
#line 951
      if (! (ok && __cil_tmp13)) {
#line 951
        goto while_break;
      }
      {
#line 952
      ok = ReadTransform(& transform_xsize, (int const   *)(& transform_ysize), dec);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 957
  __cil_tmp15 = VP8LReadBits(br, 1);
  }
#line 957
  if (ok) {
#line 957
    if (__cil_tmp15) {
      {
#line 958
      __cil_tmp16 = VP8LReadBits(br, 4);
#line 958
      color_cache_bits = (int )__cil_tmp16;
#line 959
      ok = color_cache_bits >= 1 && color_cache_bits <= 11;
      }
#line 960
      if (! ok) {
#line 961
        dec->status_ = (enum VP8StatusCode )3;
#line 962
        goto End;
      }
    }
  }
  {
#line 967
  __cil_tmp17 = ReadHuffmanCodes(dec, transform_xsize, transform_ysize, color_cache_bits,
                                 is_level0);
#line 967
  ok = ok && __cil_tmp17;
  }
#line 969
  if (! ok) {
#line 970
    dec->status_ = (enum VP8StatusCode )3;
#line 971
    goto End;
  }
#line 975
  if (color_cache_bits > 0) {
    {
#line 976
    hdr->color_cache_size_ = 1 << color_cache_bits;
#line 977
    __cil_tmp18 = VP8LColorCacheInit(& hdr->color_cache_, color_cache_bits);
    }
#line 977
    if (! __cil_tmp18) {
#line 978
      dec->status_ = (enum VP8StatusCode )1;
#line 979
      ok = 0;
#line 980
      goto End;
    }
  } else {
#line 983
    hdr->color_cache_size_ = 0;
  }
  {
#line 985
  UpdateDecoder(dec, transform_xsize, transform_ysize);
  }
#line 987
  if (is_level0) {
#line 988
    dec->state_ = (VP8LDecodeState )1;
#line 989
    goto End;
  }
  {
#line 993
  total_size = (uint64_t )transform_xsize * (unsigned long )transform_ysize;
#line 994
  __cil_tmp20 = WebPSafeMalloc(total_size, sizeof(*data));
#line 994
  data = (uint32_t *)__cil_tmp20;
  }
#line 995
  if (data == (void *)0) {
#line 996
    dec->status_ = (enum VP8StatusCode )1;
#line 997
    ok = 0;
#line 998
    goto End;
  }
  {
#line 1003
  ok = DecodeImageData(dec, data, transform_xsize, transform_ysize, (ProcessRowsFunc )((void *)0));
#line 1004
  ok = ok && ! br->error_;
  }
  End: 
#line 1008
  if (! ok) {
    {
#line 1009
    free(data);
#line 1010
    ClearMetadata(hdr);
    }
#line 1013
    if ((unsigned int )dec->status_ == 3U) {
#line 1013
      if (dec->br_.eos_) {
#line 1014
        dec->status_ = (enum VP8StatusCode )5;
      }
    }
  } else {
#line 1017
    if (decoded_data != (void *)0) {
#line 1018
      *decoded_data = data;
    }
#line 1025
    if (! is_level0) {
      {
#line 1025
      ClearMetadata(hdr);
      }
    }
  }
#line 1027
  return (ok);
}
}
#line 1033 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static int AllocateARGBBuffers(VP8LDecoder *dec , int final_width ) 
{ 
  uint64_t num_pixels ;
  uint64_t cache_top_pixels ;
  uint64_t cache_pixels ;
  uint64_t total_num_pixels ;
  int tmp ;
  void *__cil_tmp8 ;

  {
  {
#line 1034
  num_pixels = (uint64_t )dec->width_ * (unsigned long )dec->height_;
#line 1037
  cache_top_pixels = (uint64_t )final_width;
#line 1039
  cache_pixels = (uint64_t )final_width * 16UL;
#line 1040
  total_num_pixels = (num_pixels + cache_top_pixels) + cache_pixels;
#line 1044
  __cil_tmp8 = WebPSafeMalloc(total_num_pixels, sizeof(*(dec->argb_)));
#line 1044
  dec->argb_ = (uint32_t *)__cil_tmp8;
  }
#line 1045
  if (dec->argb_ == (void *)0) {
#line 1046
    dec->argb_cache_ = (uint32_t *)((void *)0);
#line 1047
    dec->status_ = (enum VP8StatusCode )1;
#line 1048
    return (0);
  }
#line 1050
  dec->argb_cache_ = (dec->argb_ + num_pixels) + cache_top_pixels;
#line 1051
  return (1);
}
}
#line 1057 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
static void ExtractAlphaRows(VP8LDecoder *dec , int row ) 
{ 
  int num_rows ;
  uint32_t *in ;
  int width ;
  int cache_pixs ;
  uint8_t *dst ;
  uint32_t *src ;
  int i ;

  {
#line 1058
  num_rows = row - dec->last_row_;
#line 1059
  in = dec->argb_ + dec->width_ * dec->last_row_;
#line 1061
  if (num_rows <= 0) {
#line 1061
    return;
  }
  {
#line 1062
  ApplyInverseTransforms(dec, num_rows, in);
#line 1066
  width = (dec->io_)->width;
#line 1067
  cache_pixs = width * num_rows;
#line 1068
  dst = (uint8_t *)(dec->io_)->opaque + width * dec->last_row_;
#line 1069
  src = dec->argb_cache_;
#line 1071
  i = 0;
  }
  {
#line 1071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1071
    if (! (i < cache_pixs)) {
#line 1071
      goto while_break;
    }
#line 1071
    *(dst + i) = (uint8_t )((*(src + i) >> 8) & 255U);
#line 1071
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1074
  dec->last_out_row_ = row;
#line 1074
  dec->last_row_ = dec->last_out_row_;
  return;
}
}
#line 1077 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
int VP8LDecodeAlphaImageStream(int width , int height , uint8_t *data , size_t data_size ,
                               uint8_t *output ) 
{ 
  VP8Io io ;
  int ok ;
  VP8LDecoder *dec ;
  VP8LDecoder *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 1080
  ok = 0;
#line 1081
  __cil_tmp9 = VP8LNew();
#line 1081
  dec = __cil_tmp9;
  }
#line 1082
  if (dec == (void *)0) {
#line 1082
    return (0);
  }
  {
#line 1084
  dec->width_ = width;
#line 1085
  dec->height_ = height;
#line 1086
  dec->io_ = & io;
#line 1088
  VP8InitIo(& io);
#line 1089
  WebPInitCustomIo((WebPDecParams *)((void *)0), & io);
#line 1090
  io.opaque = output;
#line 1091
  io.width = width;
#line 1092
  io.height = height;
#line 1094
  dec->status_ = (enum VP8StatusCode )0;
#line 1095
  VP8LInitBitReader(& dec->br_, data, data_size);
#line 1097
  dec->action_ = (VP8LDecodeState )1;
#line 1098
  __cil_tmp10 = DecodeImageStream(width, height, 1, dec, (uint32_t **)((void *)0));
  }
#line 1098
  if (! __cil_tmp10) {
#line 1098
    goto Err;
  }
  {
#line 1101
  __cil_tmp11 = AllocateARGBBuffers(dec, width);
  }
#line 1101
  if (! __cil_tmp11) {
#line 1101
    goto Err;
  }
  {
#line 1104
  dec->action_ = (VP8LDecodeState )0;
#line 1105
  ok = DecodeImageData(dec, dec->argb_, dec->width_, dec->height_, & ExtractAlphaRows);
  }
  Err: 
  {
#line 1109
  VP8LDelete(dec);
  }
#line 1110
  return (ok);
}
}
#line 1115 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
int VP8LDecodeHeader(VP8LDecoder *dec , VP8Io *io ) 
{ 
  int width ;
  int height ;
  int has_alpha ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
#line 1118
  if (dec == (void *)0) {
#line 1118
    return (0);
  }
#line 1119
  if (io == (void *)0) {
#line 1120
    dec->status_ = (enum VP8StatusCode )2;
#line 1121
    return (0);
  }
  {
#line 1124
  dec->io_ = io;
#line 1125
  dec->status_ = (enum VP8StatusCode )0;
#line 1126
  VP8LInitBitReader(& dec->br_, io->data, io->data_size);
#line 1127
  __cil_tmp6 = ReadImageInfo(& dec->br_, & width, & height, & has_alpha);
  }
#line 1127
  if (! __cil_tmp6) {
#line 1128
    dec->status_ = (enum VP8StatusCode )3;
#line 1129
    goto Error;
  }
  {
#line 1131
  dec->state_ = (VP8LDecodeState )2;
#line 1132
  io->width = width;
#line 1133
  io->height = height;
#line 1135
  dec->action_ = (VP8LDecodeState )1;
#line 1136
  __cil_tmp7 = DecodeImageStream(width, height, 1, dec, (uint32_t **)((void *)0));
  }
#line 1136
  if (! __cil_tmp7) {
#line 1136
    goto Error;
  }
#line 1137
  return (1);
  Error: 
  {
#line 1140
  VP8LClear(dec);
  }
#line 1142
  return (0);
}
}
#line 1145 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8l.c"
int VP8LDecodeImage(VP8LDecoder *dec ) 
{ 
  VP8Io *io ;
  WebPDecParams *params ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp___2 ;

  {
#line 1146
  io = (VP8Io *)((void *)0);
#line 1147
  params = (WebPDecParams *)((void *)0);
#line 1150
  if (dec == (void *)0) {
#line 1150
    return (0);
  }
  {
#line 1152
  io = dec->io_;
#line 1154
  params = (WebPDecParams *)io->opaque;
#line 1156
  dec->output_ = params->output;
#line 1160
  __cil_tmp7 = WebPIoInitFromOptions(params->options, io, (enum WEBP_CSP_MODE )3);
  }
#line 1160
  if (! __cil_tmp7) {
#line 1161
    dec->status_ = (enum VP8StatusCode )2;
#line 1162
    goto Err;
  }
  {
#line 1165
  __cil_tmp8 = AllocateARGBBuffers(dec, io->width);
  }
#line 1165
  if (! __cil_tmp8) {
#line 1165
    goto Err;
  }
  {
#line 1167
  __cil_tmp9 = AllocateAndInitRescaler(dec, io);
  }
#line 1167
  if (io->use_scaling) {
#line 1167
    if (! __cil_tmp9) {
#line 1167
      goto Err;
    }
  }
  {
#line 1170
  dec->action_ = (VP8LDecodeState )0;
#line 1171
  __cil_tmp10 = DecodeImageData(dec, dec->argb_, dec->width_, dec->height_, & ProcessRows);
  }
#line 1171
  if (! __cil_tmp10) {
#line 1173
    goto Err;
  }
  {
#line 1177
  params->last_y = dec->last_out_row_;
#line 1178
  VP8LClear(dec);
  }
#line 1179
  return (1);
  Err: 
  {
#line 1182
  VP8LClear(dec);
  }
#line 1184
  return (0);
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
static uint32_t kHashMul___5  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___5(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___5 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___5(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___5 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheContains___5(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___5 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 25 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
int WebPGetDecoderVersion(void) 
{ 


  {
#line 26
  return (3 << 8);
}
}
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static void SetOk(VP8Decoder *dec ) 
{ 


  {
#line 33
  dec->status_ = (enum VP8StatusCode )0;
#line 34
  dec->error_msg_ = "OK";
  return;
}
}
#line 37 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
int VP8InitIoInternal(VP8Io *io , int version ) 
{ 


  {
#line 38
  if (version >> 8 != 513 >> 8) {
#line 39
    return (0);
  }
#line 41
  if (io != (void *)0) {
    {
#line 42
    memset(io, 0, sizeof(*io));
    }
  }
#line 44
  return (1);
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
VP8Decoder *VP8New(void) 
{ 
  VP8Decoder *dec ;
  void *__cil_tmp2 ;

  {
  {
#line 48
  __cil_tmp2 = calloc((unsigned long )1, sizeof(*dec));
#line 48
  dec = (VP8Decoder *)__cil_tmp2;
  }
#line 49
  if (dec != (void *)0) {
    {
#line 50
    SetOk(dec);
#line 51
    WebPWorkerInit(& dec->worker_);
#line 52
    dec->ready_ = 0;
#line 53
    dec->num_parts_ = 1;
    }
  }
#line 55
  return (dec);
}
}
#line 58 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
enum VP8StatusCode VP8Status(VP8Decoder *dec ) 
{ 


  {
#line 59
  if (! dec) {
#line 59
    return ((enum VP8StatusCode )2);
  }
#line 60
  return (dec->status_);
}
}
#line 63 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
char const   *VP8StatusMessage(VP8Decoder *dec ) 
{ 


  {
#line 64
  if (dec == (void *)0) {
#line 64
    return ("no object");
  }
#line 65
  if (! dec->error_msg_) {
#line 65
    return ("OK");
  }
#line 66
  return (dec->error_msg_);
}
}
#line 69 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
void VP8Delete(VP8Decoder *dec ) 
{ 


  {
#line 70
  if (dec != (void *)0) {
    {
#line 71
    VP8Clear(dec);
#line 72
    free(dec);
    }
  }
  return;
}
}
#line 76 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
int VP8SetError(VP8Decoder *dec , enum VP8StatusCode error , char const   *msg ) 
{ 


  {
#line 82
  if ((unsigned int )dec->status_ == 0U) {
#line 83
    dec->status_ = error;
#line 84
    dec->error_msg_ = msg;
#line 85
    dec->ready_ = 0;
  }
#line 87
  return (0);
}
}
#line 92 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
int VP8CheckSignature(uint8_t *data , size_t data_size ) 
{ 


  {
#line 93
  return (((data_size >= 3UL && (int )*(data + 0) == 157) && (int )*(data + 1) == 1) && (int )*(data + 2) == 42);
}
}
#line 97 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
int VP8GetInfo(uint8_t *data , size_t data_size , size_t chunk_size , int *width ,
               int *height ) 
{ 
  int __cil_tmp6 ;
  uint32_t bits ;
  int key_frame ;
  int w ;
  int h ;

  {
#line 99
  if (data == (void *)0) {
#line 100
    return (0);
  } else
#line 99
  if (data_size < 10UL) {
#line 100
    return (0);
  }
  {
#line 103
  __cil_tmp6 = VP8CheckSignature(data + 3, data_size - 3UL);
  }
#line 103
  if (! __cil_tmp6) {
#line 104
    return (0);
  } else {
#line 106
    bits = (uint32_t )(((int )*(data + 0) | ((int )*(data + 1) << 8)) | ((int )*(data + 2) << 16));
#line 107
    key_frame = ! (bits & 1U);
#line 108
    w = (((int )*(data + 7) << 8) | (int )*(data + 6)) & 16383;
#line 109
    h = (((int )*(data + 9) << 8) | (int )*(data + 8)) & 16383;
#line 111
    if (! key_frame) {
#line 112
      return (0);
    }
#line 115
    if (((bits >> 1) & 7U) > 3U) {
#line 116
      return (0);
    }
#line 118
    if (! ((bits >> 4) & 1U)) {
#line 119
      return (0);
    }
#line 121
    if ((unsigned long )(bits >> 5) >= chunk_size) {
#line 122
      return (0);
    }
#line 125
    if (width) {
#line 126
      *width = w;
    }
#line 128
    if (height) {
#line 129
      *height = h;
    }
#line 132
    return (1);
  }
}
}
#line 139 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static void ResetSegmentHeader___0(VP8SegmentHeader___0 *hdr ) 
{ 
  int tmp ;

  {
  {
#line 141
  hdr->use_segment_ = 0;
#line 142
  hdr->update_map_ = 0;
#line 143
  hdr->absolute_delta_ = 1;
#line 144
  memset((int8_t *)hdr->quantizer_, 0, sizeof(hdr->quantizer_));
#line 145
  memset((int8_t *)hdr->filter_strength_, 0, sizeof(hdr->filter_strength_));
  }
  return;
}
}
#line 149 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static int ParseSegmentHeader(VP8BitReader *br , VP8SegmentHeader___0 *hdr , VP8Proba___0 *proba ) 
{ 
  int tmp ;
  int tmp___0 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  int s ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;
  int32_t __cil_tmp12 ;
  int32_t tmp___1 ;
  uint32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int32_t tmp___2 ;
  int s___0 ;
  uint32_t __cil_tmp18 ;
  uint32_t __cil_tmp19 ;
  uint32_t tmp___3 ;

  {
  {
#line 153
  __cil_tmp6 = VP8Get(br);
#line 153
  hdr->use_segment_ = (int )__cil_tmp6;
  }
#line 154
  if (hdr->use_segment_) {
    {
#line 155
    __cil_tmp7 = VP8Get(br);
#line 155
    hdr->update_map_ = (int )__cil_tmp7;
#line 156
    __cil_tmp8 = VP8Get(br);
    }
#line 156
    if (__cil_tmp8) {
      {
#line 158
      __cil_tmp10 = VP8Get(br);
#line 158
      hdr->absolute_delta_ = (int )__cil_tmp10;
#line 159
      s = 0;
      }
      {
#line 159
      while (1) {
        while_continue: /* CIL Label */ ;
#line 159
        if (! (s < 4)) {
#line 159
          goto while_break;
        }
        {
#line 160
        __cil_tmp11 = VP8Get(br);
        }
#line 160
        if (__cil_tmp11) {
          {
#line 160
          __cil_tmp12 = VP8GetSignedValue(br, 7);
#line 160
          tmp___1 = __cil_tmp12;
          }
        } else {
#line 160
          tmp___1 = 0;
        }
#line 160
        hdr->quantizer_[s] = (int8_t )tmp___1;
#line 159
        s ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 162
      s = 0;
      {
#line 162
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 162
        if (! (s < 4)) {
#line 162
          goto while_break___0;
        }
        {
#line 163
        __cil_tmp14 = VP8Get(br);
        }
#line 163
        if (__cil_tmp14) {
          {
#line 163
          __cil_tmp15 = VP8GetSignedValue(br, 6);
#line 163
          tmp___2 = __cil_tmp15;
          }
        } else {
#line 163
          tmp___2 = 0;
        }
#line 163
        hdr->filter_strength_[s] = (int8_t )tmp___2;
#line 162
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 166
    if (hdr->update_map_) {
#line 168
      s___0 = 0;
      {
#line 168
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 168
        if (! (s___0 < 3)) {
#line 168
          goto while_break___1;
        }
        {
#line 169
        __cil_tmp18 = VP8Get(br);
        }
#line 169
        if (__cil_tmp18) {
          {
#line 169
          __cil_tmp19 = VP8GetValue(br, 8);
#line 169
          tmp___3 = __cil_tmp19;
          }
        } else {
#line 169
          tmp___3 = 255U;
        }
#line 169
        proba->segments_[s___0] = (uint8_t )tmp___3;
#line 168
        s___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else {
#line 173
    hdr->update_map_ = 0;
  }
#line 175
  return (! br->eof_);
}
}
#line 187 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static enum VP8StatusCode ParsePartitions(VP8Decoder *dec , uint8_t *buf , size_t size ) 
{ 
  VP8BitReader *br ;
  uint8_t *sz ;
  uint8_t *buf_end ;
  uint8_t *part_start ;
  int last_part ;
  int p ;
  uint32_t __cil_tmp10 ;
  uint32_t psize ;
  uint8_t *part_end ;
  int tmp ;

  {
  {
#line 189
  br = & dec->br_;
#line 190
  sz = buf;
#line 191
  buf_end = buf + size;
#line 196
  __cil_tmp10 = VP8GetValue(br, 2);
#line 196
  dec->num_parts_ = 1 << __cil_tmp10;
#line 197
  last_part = dec->num_parts_ - 1;
#line 198
  part_start = buf + last_part * 3;
  }
#line 199
  if (buf_end < part_start) {
#line 201
    return ((enum VP8StatusCode )7);
  }
#line 203
  p = 0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (p < last_part)) {
#line 203
      goto while_break;
    }
#line 204
    psize = (uint32_t )(((int )*(sz + 0) | ((int )*(sz + 1) << 8)) | ((int )*(sz + 2) << 16));
#line 205
    part_end = part_start + psize;
#line 206
    if (part_end > buf_end) {
#line 206
      part_end = buf_end;
    }
    {
#line 207
    VP8InitBitReader((VP8BitReader *)dec->parts_ + p, part_start, part_end);
#line 208
    part_start = part_end;
#line 209
    sz += 3;
    }
#line 203
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  VP8InitBitReader((VP8BitReader *)dec->parts_ + last_part, part_start, buf_end);
  }
#line 212
  if (part_start < buf_end) {
#line 212
    tmp = 0;
  } else {
#line 212
    tmp = 5;
  }
#line 212
  return ((enum VP8StatusCode )tmp);
}
}
#line 217 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static int ParseFilterHeader(VP8BitReader *br , VP8Decoder *dec ) 
{ 
  VP8FilterHeader___0 *hdr ;
  uint32_t __cil_tmp4 ;
  uint32_t __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  uint32_t __cil_tmp7 ;
  uint32_t __cil_tmp8 ;
  int i ;
  uint32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  int32_t __cil_tmp13 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 218
  hdr = & dec->filter_hdr_;
#line 219
  __cil_tmp4 = VP8Get(br);
#line 219
  hdr->simple_ = (int )__cil_tmp4;
#line 220
  __cil_tmp5 = VP8GetValue(br, 6);
#line 220
  hdr->level_ = (int )__cil_tmp5;
#line 221
  __cil_tmp6 = VP8GetValue(br, 3);
#line 221
  hdr->sharpness_ = (int )__cil_tmp6;
#line 222
  __cil_tmp7 = VP8Get(br);
#line 222
  hdr->use_lf_delta_ = (int )__cil_tmp7;
  }
#line 223
  if (hdr->use_lf_delta_) {
    {
#line 224
    __cil_tmp8 = VP8Get(br);
    }
#line 224
    if (__cil_tmp8) {
#line 226
      i = 0;
      {
#line 226
      while (1) {
        while_continue: /* CIL Label */ ;
#line 226
        if (! (i < 4)) {
#line 226
          goto while_break;
        }
        {
#line 227
        __cil_tmp10 = VP8Get(br);
        }
#line 227
        if (__cil_tmp10) {
          {
#line 228
          hdr->ref_lf_delta_[i] = VP8GetSignedValue(br, 6);
          }
        }
#line 226
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 231
      i = 0;
      {
#line 231
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 231
        if (! (i < 4)) {
#line 231
          goto while_break___0;
        }
        {
#line 232
        __cil_tmp12 = VP8Get(br);
        }
#line 232
        if (__cil_tmp12) {
          {
#line 233
          hdr->mode_lf_delta_[i] = VP8GetSignedValue(br, 6);
          }
        }
#line 231
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 238
  if (hdr->level_ == 0) {
#line 238
    tmp___0 = 0;
  } else {
#line 238
    if (hdr->simple_) {
#line 238
      tmp = 1;
    } else {
#line 238
      tmp = 2;
    }
#line 238
    tmp___0 = tmp;
  }
#line 238
  dec->filter_type_ = tmp___0;
#line 239
  return (! br->eof_);
}
}
#line 243 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
int VP8GetHeaders(VP8Decoder *dec , VP8Io *io ) 
{ 
  uint8_t *buf ;
  size_t buf_size ;
  VP8FrameHeader *frm_hdr ;
  VP8PictureHeader *pic_hdr ;
  VP8BitReader *br ;
  enum VP8StatusCode status ;
  WebPHeaderStructure headers ;
  int __cil_tmp10 ;
  enum VP8StatusCode __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp16 ;
  uint32_t bits ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  uint32_t __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  enum VP8StatusCode __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 252
  if (dec == (void *)0) {
#line 253
    return (0);
  }
  {
#line 255
  SetOk(dec);
  }
#line 256
  if (io == (void *)0) {
    {
#line 257
    __cil_tmp10 = VP8SetError(dec, (enum VP8StatusCode )2, "null VP8Io passed to VP8GetHeaders()");
    }
#line 257
    return (__cil_tmp10);
  }
  {
#line 262
  headers.data = io->data;
#line 263
  headers.data_size = io->data_size;
#line 264
  status = WebPParseHeaders(& headers);
  }
#line 265
  if ((unsigned int )status != 0U) {
    {
#line 266
    __cil_tmp12 = VP8SetError(dec, status, "Incorrect/incomplete header.");
    }
#line 266
    return (__cil_tmp12);
  }
#line 268
  if (headers.is_lossless) {
    {
#line 269
    __cil_tmp13 = VP8SetError(dec, (enum VP8StatusCode )3, "Unexpected lossless format encountered.");
    }
#line 269
    return (__cil_tmp13);
  }
#line 273
  if (dec->alpha_data_ == (void *)0) {
#line 279
    dec->alpha_data_ = headers.alpha_data;
#line 280
    dec->alpha_data_size_ = headers.alpha_data_size;
  }
#line 284
  buf = headers.data + headers.offset;
#line 285
  buf_size = headers.data_size - headers.offset;
#line 287
  if (buf_size < 4UL) {
    {
#line 288
    __cil_tmp16 = VP8SetError(dec, (enum VP8StatusCode )7, "Truncated header.\224E\214rU");
    }
#line 288
    return (__cil_tmp16);
  }
#line 294
  bits = (uint32_t )(((int )*(buf + 0) | ((int )*(buf + 1) << 8)) | ((int )*(buf + 2) << 16));
#line 295
  frm_hdr = & dec->frm_hdr_;
#line 296
  frm_hdr->key_frame_ = (uint8_t )(! (bits & 1U));
#line 297
  frm_hdr->profile_ = (uint8_t )((bits >> 1) & 7U);
#line 298
  frm_hdr->show_ = (uint8_t )((bits >> 4) & 1U);
#line 299
  frm_hdr->partition_length_ = bits >> 5;
#line 300
  if ((int )frm_hdr->profile_ > 3) {
    {
#line 301
    __cil_tmp18 = VP8SetError(dec, (enum VP8StatusCode )3, "Incorrect keyframe parameters.");
    }
#line 301
    return (__cil_tmp18);
  }
#line 303
  if (! frm_hdr->show_) {
    {
#line 304
    __cil_tmp19 = VP8SetError(dec, (enum VP8StatusCode )4, "Frame not displayable.");
    }
#line 304
    return (__cil_tmp19);
  }
#line 306
  buf += 3;
#line 307
  buf_size -= (unsigned long )3;
#line 310
  pic_hdr = & dec->pic_hdr_;
#line 311
  if (frm_hdr->key_frame_) {
#line 313
    if (buf_size < 7UL) {
      {
#line 314
      __cil_tmp20 = VP8SetError(dec, (enum VP8StatusCode )7, "cannot parse picture header");
      }
#line 314
      return (__cil_tmp20);
    }
    {
#line 317
    __cil_tmp21 = VP8CheckSignature(buf, buf_size);
    }
#line 317
    if (! __cil_tmp21) {
      {
#line 318
      __cil_tmp22 = VP8SetError(dec, (enum VP8StatusCode )3, "Bad code word");
      }
#line 318
      return (__cil_tmp22);
    }
    {
#line 321
    pic_hdr->width_ = (uint16_t )((((int )*(buf + 4) << 8) | (int )*(buf + 3)) & 16383);
#line 322
    pic_hdr->xscale_ = (uint8_t )((int )*(buf + 4) >> 6);
#line 323
    pic_hdr->height_ = (uint16_t )((((int )*(buf + 6) << 8) | (int )*(buf + 5)) & 16383);
#line 324
    pic_hdr->yscale_ = (uint8_t )((int )*(buf + 6) >> 6);
#line 325
    buf += 7;
#line 326
    buf_size -= (unsigned long )7;
#line 328
    dec->mb_w_ = ((int )pic_hdr->width_ + 15) >> 4;
#line 329
    dec->mb_h_ = ((int )pic_hdr->height_ + 15) >> 4;
#line 331
    io->width = (int )pic_hdr->width_;
#line 332
    io->height = (int )pic_hdr->height_;
#line 333
    io->use_scaling = 0;
#line 334
    io->use_cropping = 0;
#line 335
    io->crop_top = 0;
#line 336
    io->crop_left = 0;
#line 337
    io->crop_right = io->width;
#line 338
    io->crop_bottom = io->height;
#line 339
    io->mb_w = io->width;
#line 340
    io->mb_h = io->height;
#line 342
    VP8ResetProba(& dec->proba_);
#line 343
    ResetSegmentHeader___0(& dec->segment_hdr_);
#line 344
    dec->segment_ = (uint8_t )0;
    }
  }
#line 349
  if ((unsigned long )frm_hdr->partition_length_ > buf_size) {
    {
#line 350
    __cil_tmp23 = VP8SetError(dec, (enum VP8StatusCode )7, "bad partition length");
    }
#line 350
    return (__cil_tmp23);
  }
  {
#line 354
  br = & dec->br_;
#line 355
  VP8InitBitReader(br, buf, buf + frm_hdr->partition_length_);
#line 356
  buf += frm_hdr->partition_length_;
#line 357
  buf_size -= (unsigned long )frm_hdr->partition_length_;
  }
#line 359
  if (frm_hdr->key_frame_) {
    {
#line 360
    __cil_tmp24 = VP8Get(br);
#line 360
    pic_hdr->colorspace_ = (uint8_t )__cil_tmp24;
#line 361
    __cil_tmp25 = VP8Get(br);
#line 361
    pic_hdr->clamp_type_ = (uint8_t )__cil_tmp25;
    }
  }
  {
#line 363
  __cil_tmp26 = ParseSegmentHeader(br, & dec->segment_hdr_, & dec->proba_);
  }
#line 363
  if (! __cil_tmp26) {
    {
#line 364
    __cil_tmp27 = VP8SetError(dec, (enum VP8StatusCode )3, "cannot parse segment header");
    }
#line 364
    return (__cil_tmp27);
  }
  {
#line 368
  __cil_tmp28 = ParseFilterHeader(br, dec);
  }
#line 368
  if (! __cil_tmp28) {
    {
#line 369
    __cil_tmp29 = VP8SetError(dec, (enum VP8StatusCode )3, "cannot parse filter header");
    }
#line 369
    return (__cil_tmp29);
  }
  {
#line 372
  status = ParsePartitions(dec, buf, buf_size);
  }
#line 373
  if ((unsigned int )status != 0U) {
    {
#line 374
    __cil_tmp31 = VP8SetError(dec, status, "cannot parse partitions");
    }
#line 374
    return (__cil_tmp31);
  }
  {
#line 378
  VP8ParseQuant(dec);
  }
#line 381
  if (! frm_hdr->key_frame_) {
    {
#line 395
    __cil_tmp32 = VP8SetError(dec, (enum VP8StatusCode )4, "Not a key frame.\220");
    }
#line 395
    return (__cil_tmp32);
  } else {
#line 399
    dec->buffer_flags_ = (uint32_t )259;
  }
  {
#line 412
  VP8Get(br);
#line 415
  VP8ParseProba(br, dec);
#line 440
  dec->ready_ = 1;
  }
#line 441
  return (1);
}
}
#line 447 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static int const   kBands[17]  = 
#line 447
  {      0,      1,      2,      3, 
        6,      4,      5,      6, 
        6,      6,      6,      6, 
        6,      6,      6,      7, 
        0};
#line 452 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static uint8_t kCat3[4]  = {      (uint8_t )173,      (uint8_t )148,      (uint8_t )140,      (uint8_t )0};
#line 453 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static uint8_t kCat4[5]  = {      (uint8_t )176,      (uint8_t )155,      (uint8_t )140,      (uint8_t )135, 
        (uint8_t )0};
#line 454 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static uint8_t kCat5[6]  = {      (uint8_t )180,      (uint8_t )157,      (uint8_t )141,      (uint8_t )134, 
        (uint8_t )130,      (uint8_t )0};
#line 455 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static uint8_t kCat6[12]  = 
#line 455
  {      (uint8_t )254,      (uint8_t )254,      (uint8_t )243,      (uint8_t )230, 
        (uint8_t )196,      (uint8_t )177,      (uint8_t )153,      (uint8_t )140, 
        (uint8_t )133,      (uint8_t )130,      (uint8_t )129,      (uint8_t )0};
#line 457 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static uint8_t * const  kCat3456[4]  = {      (uint8_t *)kCat3,      (uint8_t *)kCat4,      (uint8_t *)kCat5,      (uint8_t *)kCat6};
#line 458 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static uint8_t kZigzag___1[16]  = 
#line 458
  {      (uint8_t )0,      (uint8_t )1,      (uint8_t )4,      (uint8_t )8, 
        (uint8_t )5,      (uint8_t )2,      (uint8_t )3,      (uint8_t )6, 
        (uint8_t )9,      (uint8_t )12,      (uint8_t )13,      (uint8_t )10, 
        (uint8_t )7,      (uint8_t )11,      (uint8_t )14,      (uint8_t )15};
#line 466 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static int GetLargeValue(VP8BitReader *br , uint8_t *p ) 
{ 
  int v ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  uint8_t *tab ;
  int bit1 ;
  int __cil_tmp14 ;
  int bit0 ;
  int __cil_tmp16 ;
  int cat ;
  int __cil_tmp18 ;

  {
  {
#line 468
  __cil_tmp4 = VP8GetBit(br, (int )*(p + 3));
  }
#line 468
  if (! __cil_tmp4) {
    {
#line 469
    __cil_tmp5 = VP8GetBit(br, (int )*(p + 4));
    }
#line 469
    if (! __cil_tmp5) {
#line 470
      v = 2;
    } else {
      {
#line 472
      __cil_tmp6 = VP8GetBit(br, (int )*(p + 5));
#line 472
      v = 3 + __cil_tmp6;
      }
    }
  } else {
    {
#line 475
    __cil_tmp7 = VP8GetBit(br, (int )*(p + 6));
    }
#line 475
    if (! __cil_tmp7) {
      {
#line 476
      __cil_tmp8 = VP8GetBit(br, (int )*(p + 7));
      }
#line 476
      if (! __cil_tmp8) {
        {
#line 477
        __cil_tmp9 = VP8GetBit(br, 159);
#line 477
        v = 5 + __cil_tmp9;
        }
      } else {
        {
#line 479
        __cil_tmp10 = VP8GetBit(br, 165);
#line 479
        v = 7 + 2 * __cil_tmp10;
#line 480
        __cil_tmp11 = VP8GetBit(br, 145);
        }
#line 480
        v += __cil_tmp11;
      }
    } else {
      {
#line 484
      __cil_tmp14 = VP8GetBit(br, (int )*(p + 8));
#line 484
      bit1 = __cil_tmp14;
#line 485
      __cil_tmp16 = VP8GetBit(br, (int )*(p + (9 + bit1)));
#line 485
      bit0 = __cil_tmp16;
#line 486
      cat = 2 * bit1 + bit0;
#line 487
      v = 0;
#line 488
      tab = kCat3456[cat];
      }
      {
#line 488
      while (1) {
        while_continue: /* CIL Label */ ;
#line 488
        if (! *tab) {
#line 488
          goto while_break;
        }
        {
#line 489
        __cil_tmp18 = VP8GetBit(br, (int )*tab);
        }
#line 489
        v += v + __cil_tmp18;
#line 488
        tab ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 491
      v += 3 + (8 << cat);
    }
  }
#line 494
  return (v);
}
}
#line 499 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static int GetCoeffs(VP8BitReader *br , ProbaArray___0 prob , int ctx , quant_t dq ,
                     int n , int16_t *out ) 
{ 
  uint8_t *p ;
  int __cil_tmp8 ;
  ProbaCtxArray p_ctx ;
  int __cil_tmp10 ;
  int v ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 502
  p = (uint8_t *)(*(prob + n))[ctx];
#line 503
  __cil_tmp8 = VP8GetBit(br, (int )*(p + 0));
  }
#line 503
  if (! __cil_tmp8) {
#line 504
    return (0);
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (n < 16)) {
#line 506
      goto while_break;
    }
    {
#line 507
    p_ctx = (uint8_t (*)[11])*(prob + kBands[n + 1]);
#line 508
    __cil_tmp10 = VP8GetBit(br, (int )*(p + 1));
    }
#line 508
    if (! __cil_tmp10) {
#line 509
      p = (uint8_t *)*(p_ctx + 0);
    } else {
      {
#line 512
      __cil_tmp12 = VP8GetBit(br, (int )*(p + 2));
      }
#line 512
      if (! __cil_tmp12) {
#line 513
        v = 1;
#line 514
        p = (uint8_t *)*(p_ctx + 1);
      } else {
        {
#line 516
        v = GetLargeValue(br, p);
#line 517
        p = (uint8_t *)*(p_ctx + 2);
        }
      }
      {
#line 519
      __cil_tmp14 = VP8GetSigned(br, v);
#line 519
      *(out + kZigzag___1[n]) = (int16_t )(__cil_tmp14 * dq[n > 0]);
#line 520
      __cil_tmp15 = VP8GetBit(br, (int )*(p + 0));
      }
#line 520
      if (n < 15) {
#line 520
        if (! __cil_tmp15) {
#line 521
          return (n + 1);
        }
      }
    }
#line 506
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return (16);
}
}
#line 535 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static PackedNz kUnpackTab[16]  = 
#line 535
  {      {{(uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )0}}, 
        {{(uint8_t )1, (uint8_t )0, (uint8_t )0, (uint8_t )0}}, 
        {{(uint8_t )0, (uint8_t )1, (uint8_t )0, (uint8_t )0}}, 
        {{(uint8_t )1, (uint8_t )1, (uint8_t )0, (uint8_t )0}}, 
        {{(uint8_t )0, (uint8_t )0, (uint8_t )1, (uint8_t )0}}, 
        {{(uint8_t )1, (uint8_t )0, (uint8_t )1, (uint8_t )0}}, 
        {{(uint8_t )0, (uint8_t )1, (uint8_t )1, (uint8_t )0}}, 
        {{(uint8_t )1, (uint8_t )1, (uint8_t )1, (uint8_t )0}}, 
        {{(uint8_t )0, (uint8_t )0, (uint8_t )0, (uint8_t )1}}, 
        {{(uint8_t )1, (uint8_t )0, (uint8_t )0, (uint8_t )1}}, 
        {{(uint8_t )0, (uint8_t )1, (uint8_t )0, (uint8_t )1}}, 
        {{(uint8_t )1, (uint8_t )1, (uint8_t )0, (uint8_t )1}}, 
        {{(uint8_t )0, (uint8_t )0, (uint8_t )1, (uint8_t )1}}, 
        {{(uint8_t )1, (uint8_t )0, (uint8_t )1, (uint8_t )1}}, 
        {{(uint8_t )0, (uint8_t )1, (uint8_t )1, (uint8_t )1}}, 
        {{(uint8_t )1, (uint8_t )1, (uint8_t )1, (uint8_t )1}}};
#line 550 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static void ParseResiduals(VP8Decoder *dec , VP8MB *mb , VP8BitReader *token_br ) 
{ 
  int out_t_nz ;
  int out_l_nz ;
  int first ;
  ProbaArray___0 ac_prob ;
  VP8QuantMatrix *q ;
  int16_t *dst ;
  VP8MB *left_mb ;
  PackedNz nz_ac ;
  PackedNz nz_dc ;
  PackedNz tnz ;
  PackedNz lnz ;
  uint32_t non_zero_ac ;
  uint32_t non_zero_dc ;
  int x ;
  int y ;
  int ch ;
  int16_t dc[16] ;
  unsigned int tmp ;
  int ctx ;
  int __cil_tmp23 ;
  int l ;
  int ctx___0 ;
  int nz ;
  int __cil_tmp27 ;
  int l___0 ;
  int ctx___1 ;
  int nz___0 ;
  int __cil_tmp31 ;

  {
  {
#line 554
  q = & dec->dqm_[dec->segment_];
#line 555
  dst = dec->coeffs_;
#line 556
  left_mb = dec->mb_info_ - 1;
#line 559
  non_zero_ac = (uint32_t )0;
#line 560
  non_zero_dc = (uint32_t )0;
#line 563
  nz_ac.i32 = (uint32_t )0;
#line 563
  nz_dc.i32 = nz_ac.i32;
#line 564
  memset(dst, 0, 384UL * sizeof(*dst));
  }
#line 565
  if (! dec->is_i4x4_) {
#line 566
    dc[0] = (int16_t )0;
#line 566
    tmp = (unsigned int )1;
    {
#line 566
    while (1) {
      while_continue: /* CIL Label */ ;
#line 566
      if (tmp >= 16) {
#line 566
        goto while_break;
      }
#line 566
      dc[tmp] = 0;
#line 566
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 567
    ctx = (int )mb->dc_nz_ + (int )left_mb->dc_nz_;
#line 568
    __cil_tmp23 = GetCoeffs(token_br, (ProbaArray___0 )((uint8_t (*)[3][11])dec->proba_.coeffs_[1]),
                            ctx, (int const   *)q->y2_mat_, 0, (int16_t *)dc);
#line 568
    left_mb->dc_nz_ = (unsigned int )(__cil_tmp23 > 0);
#line 568
    mb->dc_nz_ = left_mb->dc_nz_;
#line 571
    first = 1;
#line 572
    ac_prob = (ProbaArray___0 )((uint8_t (*)[3][11])dec->proba_.coeffs_[0]);
#line 573
    (*VP8TransformWHT)((int16_t *)dc, dst);
    }
  } else {
#line 575
    first = 0;
#line 576
    ac_prob = (ProbaArray___0 )((uint8_t (*)[3][11])dec->proba_.coeffs_[3]);
  }
#line 579
  tnz = kUnpackTab[(int )mb->nz_ & 15];
#line 580
  lnz = kUnpackTab[(int )left_mb->nz_ & 15];
#line 581
  y = 0;
  {
#line 581
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 581
    if (! (y < 4)) {
#line 581
      goto while_break___0;
    }
#line 582
    l = (int )lnz.i8[y];
#line 583
    x = 0;
    {
#line 583
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 583
      if (! (x < 4)) {
#line 583
        goto while_break___1;
      }
      {
#line 584
      ctx___0 = l + (int )tnz.i8[x];
#line 585
      __cil_tmp27 = GetCoeffs(token_br, ac_prob, ctx___0, (int const   *)q->y1_mat_,
                              first, dst);
#line 585
      nz = __cil_tmp27;
#line 587
      l = nz > 0;
#line 587
      tnz.i8[x] = (uint8_t )l;
#line 588
      nz_dc.i8[x] = (uint8_t )((int )*(dst + 0) != 0);
#line 589
      nz_ac.i8[x] = (uint8_t )(nz > 1);
#line 590
      dst += 16;
      }
#line 583
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 592
    lnz.i8[y] = (uint8_t )l;
#line 593
    non_zero_dc |= (nz_dc.i32 * 16909320U & 4278190080U) >> (24 - y * 4);
#line 594
    non_zero_ac |= (nz_ac.i32 * 16909320U & 4278190080U) >> (24 - y * 4);
#line 581
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 596
  out_t_nz = (int )((tnz.i32 * 16909320U & 4278190080U) >> 24);
#line 597
  out_l_nz = (int )((lnz.i32 * 16909320U & 4278190080U) >> 24);
#line 599
  tnz = kUnpackTab[(int )mb->nz_ >> 4];
#line 600
  lnz = kUnpackTab[(int )left_mb->nz_ >> 4];
#line 601
  ch = 0;
  {
#line 601
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 601
    if (! (ch < 4)) {
#line 601
      goto while_break___2;
    }
#line 602
    y = 0;
    {
#line 602
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 602
      if (! (y < 2)) {
#line 602
        goto while_break___3;
      }
#line 603
      l___0 = (int )lnz.i8[ch + y];
#line 604
      x = 0;
      {
#line 604
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 604
        if (! (x < 2)) {
#line 604
          goto while_break___4;
        }
        {
#line 605
        ctx___1 = l___0 + (int )tnz.i8[ch + x];
#line 606
        __cil_tmp31 = GetCoeffs(token_br, (ProbaArray___0 )((uint8_t (*)[3][11])dec->proba_.coeffs_[2]),
                                ctx___1, (int const   *)q->uv_mat_, 0, dst);
#line 606
        nz___0 = __cil_tmp31;
#line 609
        l___0 = nz___0 > 0;
#line 609
        tnz.i8[ch + x] = (uint8_t )l___0;
#line 610
        nz_dc.i8[y * 2 + x] = (uint8_t )((int )*(dst + 0) != 0);
#line 611
        nz_ac.i8[y * 2 + x] = (uint8_t )(nz___0 > 1);
#line 612
        dst += 16;
        }
#line 604
        x ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 614
      lnz.i8[ch + y] = (uint8_t )l___0;
#line 602
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 616
    non_zero_dc |= (nz_dc.i32 * 16909320U & 4278190080U) >> (8 - ch * 2);
#line 617
    non_zero_ac |= (nz_ac.i32 * 16909320U & 4278190080U) >> (8 - ch * 2);
#line 601
    ch += 2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 619
  out_t_nz |= (tnz.i32 * 16909320U & 4278190080U) >> 20;
#line 620
  out_l_nz |= (lnz.i32 * 16909320U & 4278190080U) >> 20;
#line 621
  mb->nz_ = (unsigned int )out_t_nz;
#line 622
  left_mb->nz_ = (unsigned int )out_l_nz;
#line 624
  dec->non_zero_ac_ = non_zero_ac;
#line 625
  dec->non_zero_ = non_zero_ac | non_zero_dc;
#line 626
  mb->skip_ = ! dec->non_zero_;
  return;
}
}
#line 633 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
int VP8DecodeMB(VP8Decoder *dec , VP8BitReader *token_br ) 
{ 
  VP8BitReader *br ;
  VP8MB *left ;
  VP8MB *info ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;
  int __cil_tmp10 ;
  int tmp___0 ;
  VP8FInfo *finfo ;

  {
#line 634
  br = & dec->br_;
#line 635
  left = dec->mb_info_ - 1;
#line 636
  info = dec->mb_info_ + dec->mb_x_;
#line 640
  if (dec->segment_hdr_.update_map_) {
    {
#line 642
    __cil_tmp6 = VP8GetBit(br, (int )dec->proba_.segments_[0]);
    }
#line 642
    if (! __cil_tmp6) {
      {
#line 642
      __cil_tmp7 = VP8GetBit(br, (int )dec->proba_.segments_[1]);
#line 642
      tmp = __cil_tmp7;
      }
    } else {
      {
#line 642
      __cil_tmp8 = VP8GetBit(br, (int )dec->proba_.segments_[2]);
#line 642
      tmp = 2 + __cil_tmp8;
      }
    }
#line 642
    dec->segment_ = (uint8_t )tmp;
  }
#line 646
  if (dec->use_skip_proba_) {
    {
#line 646
    __cil_tmp10 = VP8GetBit(br, (int )dec->skip_p_);
#line 646
    tmp___0 = __cil_tmp10;
    }
  } else {
#line 646
    tmp___0 = 0;
  }
  {
#line 646
  info->skip_ = (unsigned int )tmp___0;
#line 648
  VP8ParseIntraMode(br, dec);
  }
#line 649
  if (br->eof_) {
#line 650
    return (0);
  }
#line 653
  if (! info->skip_) {
    {
#line 654
    ParseResiduals(dec, info, token_br);
    }
  } else {
#line 656
    info->nz_ = (unsigned int )0;
#line 656
    left->nz_ = info->nz_;
#line 657
    if (! dec->is_i4x4_) {
#line 658
      info->dc_nz_ = (unsigned int )0;
#line 658
      left->dc_nz_ = info->dc_nz_;
    }
#line 660
    dec->non_zero_ = (uint32_t )0;
#line 661
    dec->non_zero_ac_ = (uint32_t )0;
  }
#line 664
  if (dec->filter_type_ > 0) {
#line 665
    finfo = dec->f_info_ + dec->mb_x_;
#line 666
    *finfo = dec->fstrengths_[dec->segment_][dec->is_i4x4_];
#line 667
    finfo->f_inner_ = ! info->skip_ || (int )dec->is_i4x4_;
  }
#line 670
  return (! token_br->eof_);
}
}
#line 673 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
void VP8InitScanline(VP8Decoder *dec ) 
{ 
  VP8MB *left ;

  {
  {
#line 674
  left = dec->mb_info_ - 1;
#line 675
  left->nz_ = (unsigned int )0;
#line 676
  left->dc_nz_ = (unsigned int )0;
#line 677
  memset((uint8_t *)dec->intra_l_, 0, sizeof(dec->intra_l_));
#line 678
  dec->filter_row_ = (dec->filter_type_ > 0 && dec->mb_y_ >= dec->tl_mb_y_) && dec->mb_y_ <= dec->br_mb_y_;
  }
  return;
}
}
#line 683 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
static int ParseFrame(VP8Decoder *dec , VP8Io *io ) 
{ 
  VP8BitReader *token_br ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 684
  dec->mb_y_ = 0;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! (dec->mb_y_ < dec->br_mb_y_)) {
#line 684
      goto while_break;
    }
    {
#line 685
    token_br = & dec->parts_[dec->mb_y_ & (dec->num_parts_ - 1)];
#line 687
    VP8InitScanline(dec);
#line 688
    dec->mb_x_ = 0;
    }
    {
#line 688
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 688
      if (! (dec->mb_x_ < dec->mb_w_)) {
#line 688
        goto while_break___0;
      }
      {
#line 689
      __cil_tmp4 = VP8DecodeMB(dec, token_br);
      }
#line 689
      if (! __cil_tmp4) {
        {
#line 690
        __cil_tmp5 = VP8SetError(dec, (enum VP8StatusCode )7, "Premature end-of-file encountered.");
        }
#line 690
        return (__cil_tmp5);
      }
      {
#line 694
      VP8ReconstructBlock(dec);
      }
#line 688
      (dec->mb_x_) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 696
    __cil_tmp7 = VP8ProcessRow(dec, io);
    }
#line 696
    if (! __cil_tmp7) {
      {
#line 697
      __cil_tmp8 = VP8SetError(dec, (enum VP8StatusCode )6, "Output aborted.");
      }
#line 697
      return (__cil_tmp8);
    }
#line 684
    (dec->mb_y_) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 700
  __cil_tmp9 = WebPWorkerSync(& dec->worker_);
  }
#line 700
  if (dec->use_threads_) {
#line 700
    if (! __cil_tmp9) {
#line 701
      return (0);
    }
  }
#line 719
  return (1);
}
}
#line 723 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
int VP8Decode(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int tmp ;
  enum VP8StatusCode __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 724
  ok = 0;
#line 725
  if (dec == (void *)0) {
#line 726
    return (0);
  }
#line 728
  if (io == (void *)0) {
    {
#line 729
    __cil_tmp4 = VP8SetError(dec, (enum VP8StatusCode )2, "NULL VP8Io parameter in VP8Decode().");
    }
#line 729
    return (__cil_tmp4);
  }
#line 733
  if (! dec->ready_) {
    {
#line 734
    __cil_tmp5 = VP8GetHeaders(dec, io);
    }
#line 734
    if (! __cil_tmp5) {
#line 735
      return (0);
    }
  }
  {
#line 741
  __cil_tmp7 = VP8EnterCritical(dec, io);
#line 741
  ok = (unsigned int )__cil_tmp7 == 0U;
  }
#line 742
  if (ok) {
#line 744
    if (ok) {
      {
#line 744
      ok = VP8InitFrame(dec, io);
      }
    }
#line 747
    if (ok) {
      {
#line 747
      ok = ParseFrame(dec, io);
      }
    }
    {
#line 750
    __cil_tmp10 = VP8ExitCritical(dec, io);
    }
#line 750
    ok &= __cil_tmp10;
  }
#line 753
  if (! ok) {
    {
#line 754
    VP8Clear(dec);
    }
#line 755
    return (0);
  }
#line 758
  dec->ready_ = 0;
#line 759
  return (ok);
}
}
#line 762 "/doner/libwebp/libwebp-v0.3.0/src/dec/vp8.c"
void VP8Clear(VP8Decoder *dec ) 
{ 


  {
#line 763
  if (dec == (void *)0) {
#line 764
    return;
  }
#line 766
  if (dec->use_threads_) {
    {
#line 767
    WebPWorkerEnd(& dec->worker_);
    }
  }
#line 769
  if (dec->mem_) {
    {
#line 770
    free(dec->mem_);
    }
  }
  {
#line 772
  dec->mem_ = (void *)0;
#line 773
  dec->mem_size_ = (size_t )0;
#line 774
  memset(& dec->br_, 0, sizeof(dec->br_));
#line 775
  dec->ready_ = 0;
  }
  return;
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/./../utils/color_cache.h"
static uint32_t kHashMul___6  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/./../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___6(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___6 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/./../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___6(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___6 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/./../utils/color_cache.h"
__inline static int VP8LColorCacheContains___6(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___6 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 21 "/doner/libwebp/libwebp-v0.3.0/src/dec/tree.c"
static int8_t kYModesIntra4[18]  = 
#line 21 "/doner/libwebp/libwebp-v0.3.0/src/dec/tree.c"
  {      (int8_t )(- 0),      (int8_t )1,      (int8_t )(- 1),      (int8_t )2, 
        (int8_t )(- 2),      (int8_t )3,      (int8_t )4,      (int8_t )6, 
        (int8_t )(- 3),      (int8_t )5,      (int8_t )(- 4),      (int8_t )(- 5), 
        (int8_t )(- 6),      (int8_t )7,      (int8_t )(- 7),      (int8_t )8, 
        (int8_t )(- 8),      (int8_t )(- 9)};
#line 87 "/doner/libwebp/libwebp-v0.3.0/src/dec/tree.c"
static uint8_t CoeffsProba0[4][8][3][11]  = { { { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )253,            (uint8_t )136,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )228,            (uint8_t )219,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )189,            (uint8_t )129,            (uint8_t )242,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )213,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )106,            (uint8_t )126,            (uint8_t )227,            (uint8_t )252, 
                    (uint8_t )214,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )98,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )226,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )181,            (uint8_t )133,            (uint8_t )238,            (uint8_t )254, 
                    (uint8_t )221,            (uint8_t )234,            (uint8_t )255,            (uint8_t )154, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )78,            (uint8_t )134,            (uint8_t )202,            (uint8_t )247, 
                    (uint8_t )198,            (uint8_t )180,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )185,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )243,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )150,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )77,            (uint8_t )110,            (uint8_t )216,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )230,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )101,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )241,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )170,            (uint8_t )139,            (uint8_t )241,            (uint8_t )252, 
                    (uint8_t )236,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )37,            (uint8_t )116,            (uint8_t )196,            (uint8_t )243, 
                    (uint8_t )228,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )204,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )245,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )207,            (uint8_t )160,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )238,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )102,            (uint8_t )103,            (uint8_t )231,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )171,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )152,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )240,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )177,            (uint8_t )135,            (uint8_t )243,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )225,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )80,            (uint8_t )129,            (uint8_t )211,            (uint8_t )255, 
                    (uint8_t )194,            (uint8_t )224,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )246,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )198,            (uint8_t )35,            (uint8_t )237,            (uint8_t )223, 
                    (uint8_t )193,            (uint8_t )187,            (uint8_t )162,            (uint8_t )160, 
                    (uint8_t )145,            (uint8_t )155,            (uint8_t )62}, 
       {            (uint8_t )131,            (uint8_t )45,            (uint8_t )198,            (uint8_t )221, 
                    (uint8_t )172,            (uint8_t )176,            (uint8_t )220,            (uint8_t )157, 
                    (uint8_t )252,            (uint8_t )221,            (uint8_t )1}, 
       {            (uint8_t )68,            (uint8_t )47,            (uint8_t )146,            (uint8_t )208, 
                    (uint8_t )149,            (uint8_t )167,            (uint8_t )221,            (uint8_t )162, 
                    (uint8_t )255,            (uint8_t )223,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )149,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )221,            (uint8_t )224,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )184,            (uint8_t )141,            (uint8_t )234,            (uint8_t )253, 
                    (uint8_t )222,            (uint8_t )220,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )81,            (uint8_t )99,            (uint8_t )181,            (uint8_t )242, 
                    (uint8_t )176,            (uint8_t )190,            (uint8_t )249,            (uint8_t )202, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )129,            (uint8_t )232,            (uint8_t )253, 
                    (uint8_t )214,            (uint8_t )197,            (uint8_t )242,            (uint8_t )196, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )99,            (uint8_t )121,            (uint8_t )210,            (uint8_t )250, 
                    (uint8_t )201,            (uint8_t )198,            (uint8_t )255,            (uint8_t )202, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )23,            (uint8_t )91,            (uint8_t )163,            (uint8_t )242, 
                    (uint8_t )170,            (uint8_t )187,            (uint8_t )247,            (uint8_t )210, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )200,            (uint8_t )246,            (uint8_t )255, 
                    (uint8_t )234,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )109,            (uint8_t )178,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )231,            (uint8_t )245,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )44,            (uint8_t )130,            (uint8_t )201,            (uint8_t )253, 
                    (uint8_t )205,            (uint8_t )192,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )132,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )219,            (uint8_t )209,            (uint8_t )255,            (uint8_t )165, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )94,            (uint8_t )136,            (uint8_t )225,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )190,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )22,            (uint8_t )100,            (uint8_t )174,            (uint8_t )245, 
                    (uint8_t )186,            (uint8_t )161,            (uint8_t )255,            (uint8_t )199, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )232,            (uint8_t )235,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )143,            (uint8_t )241,            (uint8_t )255, 
                    (uint8_t )227,            (uint8_t )234,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )35,            (uint8_t )77,            (uint8_t )181,            (uint8_t )251, 
                    (uint8_t )193,            (uint8_t )211,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )157,            (uint8_t )247,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )231,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )121,            (uint8_t )141,            (uint8_t )235,            (uint8_t )255, 
                    (uint8_t )225,            (uint8_t )227,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )45,            (uint8_t )99,            (uint8_t )188,            (uint8_t )251, 
                    (uint8_t )195,            (uint8_t )217,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )203,            (uint8_t )1,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )137,            (uint8_t )1,            (uint8_t )177,            (uint8_t )255, 
                    (uint8_t )224,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )253,            (uint8_t )9,            (uint8_t )248,            (uint8_t )251, 
                    (uint8_t )207,            (uint8_t )208,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )175,            (uint8_t )13,            (uint8_t )224,            (uint8_t )243, 
                    (uint8_t )193,            (uint8_t )185,            (uint8_t )249,            (uint8_t )198, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )73,            (uint8_t )17,            (uint8_t )171,            (uint8_t )221, 
                    (uint8_t )161,            (uint8_t )179,            (uint8_t )236,            (uint8_t )167, 
                    (uint8_t )255,            (uint8_t )234,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )95,            (uint8_t )247,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )183,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )239,            (uint8_t )90,            (uint8_t )244,            (uint8_t )250, 
                    (uint8_t )211,            (uint8_t )209,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )155,            (uint8_t )77,            (uint8_t )195,            (uint8_t )248, 
                    (uint8_t )188,            (uint8_t )195,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )24,            (uint8_t )239,            (uint8_t )251, 
                    (uint8_t )218,            (uint8_t )219,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )201,            (uint8_t )51,            (uint8_t )219,            (uint8_t )255, 
                    (uint8_t )196,            (uint8_t )186,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )69,            (uint8_t )46,            (uint8_t )190,            (uint8_t )239, 
                    (uint8_t )201,            (uint8_t )218,            (uint8_t )255,            (uint8_t )228, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )191,            (uint8_t )251,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )223,            (uint8_t )165,            (uint8_t )249,            (uint8_t )255, 
                    (uint8_t )213,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )124,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )16,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )190,            (uint8_t )36,            (uint8_t )230,            (uint8_t )255, 
                    (uint8_t )236,            (uint8_t )255,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )226,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )247,            (uint8_t )192,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )240,            (uint8_t )128,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )134,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )213,            (uint8_t )62,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )55,            (uint8_t )93,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}, 
   { { {            (uint8_t )202,            (uint8_t )24,            (uint8_t )213,            (uint8_t )235, 
                    (uint8_t )186,            (uint8_t )191,            (uint8_t )220,            (uint8_t )160, 
                    (uint8_t )240,            (uint8_t )175,            (uint8_t )255}, 
       {            (uint8_t )126,            (uint8_t )38,            (uint8_t )182,            (uint8_t )232, 
                    (uint8_t )169,            (uint8_t )184,            (uint8_t )228,            (uint8_t )174, 
                    (uint8_t )255,            (uint8_t )187,            (uint8_t )128}, 
       {            (uint8_t )61,            (uint8_t )46,            (uint8_t )138,            (uint8_t )219, 
                    (uint8_t )151,            (uint8_t )178,            (uint8_t )240,            (uint8_t )170, 
                    (uint8_t )255,            (uint8_t )216,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )112,            (uint8_t )230,            (uint8_t )250, 
                    (uint8_t )199,            (uint8_t )191,            (uint8_t )247,            (uint8_t )159, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )166,            (uint8_t )109,            (uint8_t )228,            (uint8_t )252, 
                    (uint8_t )211,            (uint8_t )215,            (uint8_t )255,            (uint8_t )174, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )39,            (uint8_t )77,            (uint8_t )162,            (uint8_t )232, 
                    (uint8_t )172,            (uint8_t )180,            (uint8_t )245,            (uint8_t )178, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )52,            (uint8_t )220,            (uint8_t )246, 
                    (uint8_t )198,            (uint8_t )199,            (uint8_t )249,            (uint8_t )220, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )124,            (uint8_t )74,            (uint8_t )191,            (uint8_t )243, 
                    (uint8_t )183,            (uint8_t )193,            (uint8_t )250,            (uint8_t )221, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}, 
       {            (uint8_t )24,            (uint8_t )71,            (uint8_t )130,            (uint8_t )219, 
                    (uint8_t )154,            (uint8_t )170,            (uint8_t )243,            (uint8_t )182, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )182,            (uint8_t )225,            (uint8_t )249, 
                    (uint8_t )219,            (uint8_t )240,            (uint8_t )255,            (uint8_t )224, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )149,            (uint8_t )150,            (uint8_t )226,            (uint8_t )252, 
                    (uint8_t )216,            (uint8_t )205,            (uint8_t )255,            (uint8_t )171, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )28,            (uint8_t )108,            (uint8_t )170,            (uint8_t )242, 
                    (uint8_t )183,            (uint8_t )194,            (uint8_t )254,            (uint8_t )223, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )81,            (uint8_t )230,            (uint8_t )252, 
                    (uint8_t )204,            (uint8_t )203,            (uint8_t )255,            (uint8_t )192, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )123,            (uint8_t )102,            (uint8_t )209,            (uint8_t )247, 
                    (uint8_t )188,            (uint8_t )196,            (uint8_t )255,            (uint8_t )233, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )20,            (uint8_t )95,            (uint8_t )153,            (uint8_t )243, 
                    (uint8_t )164,            (uint8_t )173,            (uint8_t )255,            (uint8_t )203, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )222,            (uint8_t )248,            (uint8_t )255, 
                    (uint8_t )216,            (uint8_t )213,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )168,            (uint8_t )175,            (uint8_t )246,            (uint8_t )252, 
                    (uint8_t )235,            (uint8_t )205,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )47,            (uint8_t )116,            (uint8_t )215,            (uint8_t )255, 
                    (uint8_t )211,            (uint8_t )212,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )121,            (uint8_t )236,            (uint8_t )253, 
                    (uint8_t )212,            (uint8_t )214,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )141,            (uint8_t )84,            (uint8_t )213,            (uint8_t )252, 
                    (uint8_t )201,            (uint8_t )202,            (uint8_t )255,            (uint8_t )219, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )42,            (uint8_t )80,            (uint8_t )160,            (uint8_t )240, 
                    (uint8_t )162,            (uint8_t )185,            (uint8_t )255,            (uint8_t )205, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}, 
     { {            (uint8_t )1,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )244,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}, 
       {            (uint8_t )238,            (uint8_t )1,            (uint8_t )255,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128,            (uint8_t )128, 
                    (uint8_t )128,            (uint8_t )128,            (uint8_t )128}}}};
#line 224 "/doner/libwebp/libwebp-v0.3.0/src/dec/tree.c"
static uint8_t kBModesProba___0[10][10][9]  = 
#line 224
  { { {          (uint8_t )231,          (uint8_t )120,          (uint8_t )48,          (uint8_t )89, 
                (uint8_t )115,          (uint8_t )113,          (uint8_t )120,          (uint8_t )152, 
                (uint8_t )112}, 
     {          (uint8_t )152,          (uint8_t )179,          (uint8_t )64,          (uint8_t )126, 
                (uint8_t )170,          (uint8_t )118,          (uint8_t )46,          (uint8_t )70, 
                (uint8_t )95}, 
     {          (uint8_t )175,          (uint8_t )69,          (uint8_t )143,          (uint8_t )80, 
                (uint8_t )85,          (uint8_t )82,          (uint8_t )72,          (uint8_t )155, 
                (uint8_t )103}, 
     {          (uint8_t )56,          (uint8_t )58,          (uint8_t )10,          (uint8_t )171, 
                (uint8_t )218,          (uint8_t )189,          (uint8_t )17,          (uint8_t )13, 
                (uint8_t )152}, 
     {          (uint8_t )114,          (uint8_t )26,          (uint8_t )17,          (uint8_t )163, 
                (uint8_t )44,          (uint8_t )195,          (uint8_t )21,          (uint8_t )10, 
                (uint8_t )173}, 
     {          (uint8_t )121,          (uint8_t )24,          (uint8_t )80,          (uint8_t )195, 
                (uint8_t )26,          (uint8_t )62,          (uint8_t )44,          (uint8_t )64, 
                (uint8_t )85}, 
     {          (uint8_t )144,          (uint8_t )71,          (uint8_t )10,          (uint8_t )38, 
                (uint8_t )171,          (uint8_t )213,          (uint8_t )144,          (uint8_t )34, 
                (uint8_t )26}, 
     {          (uint8_t )170,          (uint8_t )46,          (uint8_t )55,          (uint8_t )19, 
                (uint8_t )136,          (uint8_t )160,          (uint8_t )33,          (uint8_t )206, 
                (uint8_t )71}, 
     {          (uint8_t )63,          (uint8_t )20,          (uint8_t )8,          (uint8_t )114, 
                (uint8_t )114,          (uint8_t )208,          (uint8_t )12,          (uint8_t )9, 
                (uint8_t )226}, 
     {          (uint8_t )81,          (uint8_t )40,          (uint8_t )11,          (uint8_t )96, 
                (uint8_t )182,          (uint8_t )84,          (uint8_t )29,          (uint8_t )16, 
                (uint8_t )36}}, 
   { {          (uint8_t )134,          (uint8_t )183,          (uint8_t )89,          (uint8_t )137, 
                (uint8_t )98,          (uint8_t )101,          (uint8_t )106,          (uint8_t )165, 
                (uint8_t )148}, 
     {          (uint8_t )72,          (uint8_t )187,          (uint8_t )100,          (uint8_t )130, 
                (uint8_t )157,          (uint8_t )111,          (uint8_t )32,          (uint8_t )75, 
                (uint8_t )80}, 
     {          (uint8_t )66,          (uint8_t )102,          (uint8_t )167,          (uint8_t )99, 
                (uint8_t )74,          (uint8_t )62,          (uint8_t )40,          (uint8_t )234, 
                (uint8_t )128}, 
     {          (uint8_t )41,          (uint8_t )53,          (uint8_t )9,          (uint8_t )178, 
                (uint8_t )241,          (uint8_t )141,          (uint8_t )26,          (uint8_t )8, 
                (uint8_t )107}, 
     {          (uint8_t )74,          (uint8_t )43,          (uint8_t )26,          (uint8_t )146, 
                (uint8_t )73,          (uint8_t )166,          (uint8_t )49,          (uint8_t )23, 
                (uint8_t )157}, 
     {          (uint8_t )65,          (uint8_t )38,          (uint8_t )105,          (uint8_t )160, 
                (uint8_t )51,          (uint8_t )52,          (uint8_t )31,          (uint8_t )115, 
                (uint8_t )128}, 
     {          (uint8_t )104,          (uint8_t )79,          (uint8_t )12,          (uint8_t )27, 
                (uint8_t )217,          (uint8_t )255,          (uint8_t )87,          (uint8_t )17, 
                (uint8_t )7}, 
     {          (uint8_t )87,          (uint8_t )68,          (uint8_t )71,          (uint8_t )44, 
                (uint8_t )114,          (uint8_t )51,          (uint8_t )15,          (uint8_t )186, 
                (uint8_t )23}, 
     {          (uint8_t )47,          (uint8_t )41,          (uint8_t )14,          (uint8_t )110, 
                (uint8_t )182,          (uint8_t )183,          (uint8_t )21,          (uint8_t )17, 
                (uint8_t )194}, 
     {          (uint8_t )66,          (uint8_t )45,          (uint8_t )25,          (uint8_t )102, 
                (uint8_t )197,          (uint8_t )189,          (uint8_t )23,          (uint8_t )18, 
                (uint8_t )22}}, 
   { {          (uint8_t )88,          (uint8_t )88,          (uint8_t )147,          (uint8_t )150, 
                (uint8_t )42,          (uint8_t )46,          (uint8_t )45,          (uint8_t )196, 
                (uint8_t )205}, 
     {          (uint8_t )43,          (uint8_t )97,          (uint8_t )183,          (uint8_t )117, 
                (uint8_t )85,          (uint8_t )38,          (uint8_t )35,          (uint8_t )179, 
                (uint8_t )61}, 
     {          (uint8_t )39,          (uint8_t )53,          (uint8_t )200,          (uint8_t )87, 
                (uint8_t )26,          (uint8_t )21,          (uint8_t )43,          (uint8_t )232, 
                (uint8_t )171}, 
     {          (uint8_t )56,          (uint8_t )34,          (uint8_t )51,          (uint8_t )104, 
                (uint8_t )114,          (uint8_t )102,          (uint8_t )29,          (uint8_t )93, 
                (uint8_t )77}, 
     {          (uint8_t )39,          (uint8_t )28,          (uint8_t )85,          (uint8_t )171, 
                (uint8_t )58,          (uint8_t )165,          (uint8_t )90,          (uint8_t )98, 
                (uint8_t )64}, 
     {          (uint8_t )34,          (uint8_t )22,          (uint8_t )116,          (uint8_t )206, 
                (uint8_t )23,          (uint8_t )34,          (uint8_t )43,          (uint8_t )166, 
                (uint8_t )73}, 
     {          (uint8_t )107,          (uint8_t )54,          (uint8_t )32,          (uint8_t )26, 
                (uint8_t )51,          (uint8_t )1,          (uint8_t )81,          (uint8_t )43, 
                (uint8_t )31}, 
     {          (uint8_t )68,          (uint8_t )25,          (uint8_t )106,          (uint8_t )22, 
                (uint8_t )64,          (uint8_t )171,          (uint8_t )36,          (uint8_t )225, 
                (uint8_t )114}, 
     {          (uint8_t )34,          (uint8_t )19,          (uint8_t )21,          (uint8_t )102, 
                (uint8_t )132,          (uint8_t )188,          (uint8_t )16,          (uint8_t )76, 
                (uint8_t )124}, 
     {          (uint8_t )62,          (uint8_t )18,          (uint8_t )78,          (uint8_t )95, 
                (uint8_t )85,          (uint8_t )57,          (uint8_t )50,          (uint8_t )48, 
                (uint8_t )51}}, 
   { {          (uint8_t )193,          (uint8_t )101,          (uint8_t )35,          (uint8_t )159, 
                (uint8_t )215,          (uint8_t )111,          (uint8_t )89,          (uint8_t )46, 
                (uint8_t )111}, 
     {          (uint8_t )60,          (uint8_t )148,          (uint8_t )31,          (uint8_t )172, 
                (uint8_t )219,          (uint8_t )228,          (uint8_t )21,          (uint8_t )18, 
                (uint8_t )111}, 
     {          (uint8_t )112,          (uint8_t )113,          (uint8_t )77,          (uint8_t )85, 
                (uint8_t )179,          (uint8_t )255,          (uint8_t )38,          (uint8_t )120, 
                (uint8_t )114}, 
     {          (uint8_t )40,          (uint8_t )42,          (uint8_t )1,          (uint8_t )196, 
                (uint8_t )245,          (uint8_t )209,          (uint8_t )10,          (uint8_t )25, 
                (uint8_t )109}, 
     {          (uint8_t )88,          (uint8_t )43,          (uint8_t )29,          (uint8_t )140, 
                (uint8_t )166,          (uint8_t )213,          (uint8_t )37,          (uint8_t )43, 
                (uint8_t )154}, 
     {          (uint8_t )61,          (uint8_t )63,          (uint8_t )30,          (uint8_t )155, 
                (uint8_t )67,          (uint8_t )45,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )100,          (uint8_t )80,          (uint8_t )8,          (uint8_t )43, 
                (uint8_t )154,          (uint8_t )1,          (uint8_t )51,          (uint8_t )26, 
                (uint8_t )71}, 
     {          (uint8_t )142,          (uint8_t )78,          (uint8_t )78,          (uint8_t )16, 
                (uint8_t )255,          (uint8_t )128,          (uint8_t )34,          (uint8_t )197, 
                (uint8_t )171}, 
     {          (uint8_t )41,          (uint8_t )40,          (uint8_t )5,          (uint8_t )102, 
                (uint8_t )211,          (uint8_t )183,          (uint8_t )4,          (uint8_t )1, 
                (uint8_t )221}, 
     {          (uint8_t )51,          (uint8_t )50,          (uint8_t )17,          (uint8_t )168, 
                (uint8_t )209,          (uint8_t )192,          (uint8_t )23,          (uint8_t )25, 
                (uint8_t )82}}, 
   { {          (uint8_t )138,          (uint8_t )31,          (uint8_t )36,          (uint8_t )171, 
                (uint8_t )27,          (uint8_t )166,          (uint8_t )38,          (uint8_t )44, 
                (uint8_t )229}, 
     {          (uint8_t )67,          (uint8_t )87,          (uint8_t )58,          (uint8_t )169, 
                (uint8_t )82,          (uint8_t )115,          (uint8_t )26,          (uint8_t )59, 
                (uint8_t )179}, 
     {          (uint8_t )63,          (uint8_t )59,          (uint8_t )90,          (uint8_t )180, 
                (uint8_t )59,          (uint8_t )166,          (uint8_t )93,          (uint8_t )73, 
                (uint8_t )154}, 
     {          (uint8_t )40,          (uint8_t )40,          (uint8_t )21,          (uint8_t )116, 
                (uint8_t )143,          (uint8_t )209,          (uint8_t )34,          (uint8_t )39, 
                (uint8_t )175}, 
     {          (uint8_t )47,          (uint8_t )15,          (uint8_t )16,          (uint8_t )183, 
                (uint8_t )34,          (uint8_t )223,          (uint8_t )49,          (uint8_t )45, 
                (uint8_t )183}, 
     {          (uint8_t )46,          (uint8_t )17,          (uint8_t )33,          (uint8_t )183, 
                (uint8_t )6,          (uint8_t )98,          (uint8_t )15,          (uint8_t )32, 
                (uint8_t )183}, 
     {          (uint8_t )57,          (uint8_t )46,          (uint8_t )22,          (uint8_t )24, 
                (uint8_t )128,          (uint8_t )1,          (uint8_t )54,          (uint8_t )17, 
                (uint8_t )37}, 
     {          (uint8_t )65,          (uint8_t )32,          (uint8_t )73,          (uint8_t )115, 
                (uint8_t )28,          (uint8_t )128,          (uint8_t )23,          (uint8_t )128, 
                (uint8_t )205}, 
     {          (uint8_t )40,          (uint8_t )3,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )51,          (uint8_t )192,          (uint8_t )18,          (uint8_t )6, 
                (uint8_t )223}, 
     {          (uint8_t )87,          (uint8_t )37,          (uint8_t )9,          (uint8_t )115, 
                (uint8_t )59,          (uint8_t )77,          (uint8_t )64,          (uint8_t )21, 
                (uint8_t )47}}, 
   { {          (uint8_t )104,          (uint8_t )55,          (uint8_t )44,          (uint8_t )218, 
                (uint8_t )9,          (uint8_t )54,          (uint8_t )53,          (uint8_t )130, 
                (uint8_t )226}, 
     {          (uint8_t )64,          (uint8_t )90,          (uint8_t )70,          (uint8_t )205, 
                (uint8_t )40,          (uint8_t )41,          (uint8_t )23,          (uint8_t )26, 
                (uint8_t )57}, 
     {          (uint8_t )54,          (uint8_t )57,          (uint8_t )112,          (uint8_t )184, 
                (uint8_t )5,          (uint8_t )41,          (uint8_t )38,          (uint8_t )166, 
                (uint8_t )213}, 
     {          (uint8_t )30,          (uint8_t )34,          (uint8_t )26,          (uint8_t )133, 
                (uint8_t )152,          (uint8_t )116,          (uint8_t )10,          (uint8_t )32, 
                (uint8_t )134}, 
     {          (uint8_t )39,          (uint8_t )19,          (uint8_t )53,          (uint8_t )221, 
                (uint8_t )26,          (uint8_t )114,          (uint8_t )32,          (uint8_t )73, 
                (uint8_t )255}, 
     {          (uint8_t )31,          (uint8_t )9,          (uint8_t )65,          (uint8_t )234, 
                (uint8_t )2,          (uint8_t )15,          (uint8_t )1,          (uint8_t )118, 
                (uint8_t )73}, 
     {          (uint8_t )75,          (uint8_t )32,          (uint8_t )12,          (uint8_t )51, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )160,          (uint8_t )43, 
                (uint8_t )51}, 
     {          (uint8_t )88,          (uint8_t )31,          (uint8_t )35,          (uint8_t )67, 
                (uint8_t )102,          (uint8_t )85,          (uint8_t )55,          (uint8_t )186, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )23,          (uint8_t )111, 
                (uint8_t )59,          (uint8_t )205,          (uint8_t )45,          (uint8_t )37, 
                (uint8_t )192}, 
     {          (uint8_t )55,          (uint8_t )38,          (uint8_t )70,          (uint8_t )124, 
                (uint8_t )73,          (uint8_t )102,          (uint8_t )1,          (uint8_t )34, 
                (uint8_t )98}}, 
   { {          (uint8_t )125,          (uint8_t )98,          (uint8_t )42,          (uint8_t )88, 
                (uint8_t )104,          (uint8_t )85,          (uint8_t )117,          (uint8_t )175, 
                (uint8_t )82}, 
     {          (uint8_t )95,          (uint8_t )84,          (uint8_t )53,          (uint8_t )89, 
                (uint8_t )128,          (uint8_t )100,          (uint8_t )113,          (uint8_t )101, 
                (uint8_t )45}, 
     {          (uint8_t )75,          (uint8_t )79,          (uint8_t )123,          (uint8_t )47, 
                (uint8_t )51,          (uint8_t )128,          (uint8_t )81,          (uint8_t )171, 
                (uint8_t )1}, 
     {          (uint8_t )57,          (uint8_t )17,          (uint8_t )5,          (uint8_t )71, 
                (uint8_t )102,          (uint8_t )57,          (uint8_t )53,          (uint8_t )41, 
                (uint8_t )49}, 
     {          (uint8_t )38,          (uint8_t )33,          (uint8_t )13,          (uint8_t )121, 
                (uint8_t )57,          (uint8_t )73,          (uint8_t )26,          (uint8_t )1, 
                (uint8_t )85}, 
     {          (uint8_t )41,          (uint8_t )10,          (uint8_t )67,          (uint8_t )138, 
                (uint8_t )77,          (uint8_t )110,          (uint8_t )90,          (uint8_t )47, 
                (uint8_t )114}, 
     {          (uint8_t )115,          (uint8_t )21,          (uint8_t )2,          (uint8_t )10, 
                (uint8_t )102,          (uint8_t )255,          (uint8_t )166,          (uint8_t )23, 
                (uint8_t )6}, 
     {          (uint8_t )101,          (uint8_t )29,          (uint8_t )16,          (uint8_t )10, 
                (uint8_t )85,          (uint8_t )128,          (uint8_t )101,          (uint8_t )196, 
                (uint8_t )26}, 
     {          (uint8_t )57,          (uint8_t )18,          (uint8_t )10,          (uint8_t )102, 
                (uint8_t )102,          (uint8_t )213,          (uint8_t )34,          (uint8_t )20, 
                (uint8_t )43}, 
     {          (uint8_t )117,          (uint8_t )20,          (uint8_t )15,          (uint8_t )36, 
                (uint8_t )163,          (uint8_t )128,          (uint8_t )68,          (uint8_t )1, 
                (uint8_t )26}}, 
   { {          (uint8_t )102,          (uint8_t )61,          (uint8_t )71,          (uint8_t )37, 
                (uint8_t )34,          (uint8_t )53,          (uint8_t )31,          (uint8_t )243, 
                (uint8_t )192}, 
     {          (uint8_t )69,          (uint8_t )60,          (uint8_t )71,          (uint8_t )38, 
                (uint8_t )73,          (uint8_t )119,          (uint8_t )28,          (uint8_t )222, 
                (uint8_t )37}, 
     {          (uint8_t )68,          (uint8_t )45,          (uint8_t )128,          (uint8_t )34, 
                (uint8_t )1,          (uint8_t )47,          (uint8_t )11,          (uint8_t )245, 
                (uint8_t )171}, 
     {          (uint8_t )62,          (uint8_t )17,          (uint8_t )19,          (uint8_t )70, 
                (uint8_t )146,          (uint8_t )85,          (uint8_t )55,          (uint8_t )62, 
                (uint8_t )70}, 
     {          (uint8_t )37,          (uint8_t )43,          (uint8_t )37,          (uint8_t )154, 
                (uint8_t )100,          (uint8_t )163,          (uint8_t )85,          (uint8_t )160, 
                (uint8_t )1}, 
     {          (uint8_t )63,          (uint8_t )9,          (uint8_t )92,          (uint8_t )136, 
                (uint8_t )28,          (uint8_t )64,          (uint8_t )32,          (uint8_t )201, 
                (uint8_t )85}, 
     {          (uint8_t )75,          (uint8_t )15,          (uint8_t )9,          (uint8_t )9, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )184,          (uint8_t )119, 
                (uint8_t )16}, 
     {          (uint8_t )86,          (uint8_t )6,          (uint8_t )28,          (uint8_t )5, 
                (uint8_t )64,          (uint8_t )255,          (uint8_t )25,          (uint8_t )248, 
                (uint8_t )1}, 
     {          (uint8_t )56,          (uint8_t )8,          (uint8_t )17,          (uint8_t )132, 
                (uint8_t )137,          (uint8_t )255,          (uint8_t )55,          (uint8_t )116, 
                (uint8_t )128}, 
     {          (uint8_t )58,          (uint8_t )15,          (uint8_t )20,          (uint8_t )82, 
                (uint8_t )135,          (uint8_t )57,          (uint8_t )26,          (uint8_t )121, 
                (uint8_t )40}}, 
   { {          (uint8_t )164,          (uint8_t )50,          (uint8_t )31,          (uint8_t )137, 
                (uint8_t )154,          (uint8_t )133,          (uint8_t )25,          (uint8_t )35, 
                (uint8_t )218}, 
     {          (uint8_t )51,          (uint8_t )103,          (uint8_t )44,          (uint8_t )131, 
                (uint8_t )131,          (uint8_t )123,          (uint8_t )31,          (uint8_t )6, 
                (uint8_t )158}, 
     {          (uint8_t )86,          (uint8_t )40,          (uint8_t )64,          (uint8_t )135, 
                (uint8_t )148,          (uint8_t )224,          (uint8_t )45,          (uint8_t )183, 
                (uint8_t )128}, 
     {          (uint8_t )22,          (uint8_t )26,          (uint8_t )17,          (uint8_t )131, 
                (uint8_t )240,          (uint8_t )154,          (uint8_t )14,          (uint8_t )1, 
                (uint8_t )209}, 
     {          (uint8_t )45,          (uint8_t )16,          (uint8_t )21,          (uint8_t )91, 
                (uint8_t )64,          (uint8_t )222,          (uint8_t )7,          (uint8_t )1, 
                (uint8_t )197}, 
     {          (uint8_t )56,          (uint8_t )21,          (uint8_t )39,          (uint8_t )155, 
                (uint8_t )60,          (uint8_t )138,          (uint8_t )23,          (uint8_t )102, 
                (uint8_t )213}, 
     {          (uint8_t )83,          (uint8_t )12,          (uint8_t )13,          (uint8_t )54, 
                (uint8_t )192,          (uint8_t )255,          (uint8_t )68,          (uint8_t )47, 
                (uint8_t )28}, 
     {          (uint8_t )85,          (uint8_t )26,          (uint8_t )85,          (uint8_t )85, 
                (uint8_t )128,          (uint8_t )128,          (uint8_t )32,          (uint8_t )146, 
                (uint8_t )171}, 
     {          (uint8_t )18,          (uint8_t )11,          (uint8_t )7,          (uint8_t )63, 
                (uint8_t )144,          (uint8_t )171,          (uint8_t )4,          (uint8_t )4, 
                (uint8_t )246}, 
     {          (uint8_t )35,          (uint8_t )27,          (uint8_t )10,          (uint8_t )146, 
                (uint8_t )174,          (uint8_t )171,          (uint8_t )12,          (uint8_t )26, 
                (uint8_t )128}}, 
   { {          (uint8_t )190,          (uint8_t )80,          (uint8_t )35,          (uint8_t )99, 
                (uint8_t )180,          (uint8_t )80,          (uint8_t )126,          (uint8_t )54, 
                (uint8_t )45}, 
     {          (uint8_t )85,          (uint8_t )126,          (uint8_t )47,          (uint8_t )87, 
                (uint8_t )176,          (uint8_t )51,          (uint8_t )41,          (uint8_t )20, 
                (uint8_t )32}, 
     {          (uint8_t )101,          (uint8_t )75,          (uint8_t )128,          (uint8_t )139, 
                (uint8_t )118,          (uint8_t )146,          (uint8_t )116,          (uint8_t )128, 
                (uint8_t )85}, 
     {          (uint8_t )56,          (uint8_t )41,          (uint8_t )15,          (uint8_t )176, 
                (uint8_t )236,          (uint8_t )85,          (uint8_t )37,          (uint8_t )9, 
                (uint8_t )62}, 
     {          (uint8_t )71,          (uint8_t )30,          (uint8_t )17,          (uint8_t )119, 
                (uint8_t )118,          (uint8_t )255,          (uint8_t )17,          (uint8_t )18, 
                (uint8_t )138}, 
     {          (uint8_t )101,          (uint8_t )38,          (uint8_t )60,          (uint8_t )138, 
                (uint8_t )55,          (uint8_t )70,          (uint8_t )43,          (uint8_t )26, 
                (uint8_t )142}, 
     {          (uint8_t )146,          (uint8_t )36,          (uint8_t )19,          (uint8_t )30, 
                (uint8_t )171,          (uint8_t )255,          (uint8_t )97,          (uint8_t )27, 
                (uint8_t )20}, 
     {          (uint8_t )138,          (uint8_t )45,          (uint8_t )61,          (uint8_t )62, 
                (uint8_t )219,          (uint8_t )1,          (uint8_t )81,          (uint8_t )188, 
                (uint8_t )64}, 
     {          (uint8_t )32,          (uint8_t )41,          (uint8_t )20,          (uint8_t )117, 
                (uint8_t )151,          (uint8_t )142,          (uint8_t )20,          (uint8_t )21, 
                (uint8_t )163}, 
     {          (uint8_t )112,          (uint8_t )19,          (uint8_t )12,          (uint8_t )61, 
                (uint8_t )195,          (uint8_t )128,          (uint8_t )48,          (uint8_t )4, 
                (uint8_t )24}}};
#line 327 "/doner/libwebp/libwebp-v0.3.0/src/dec/tree.c"
void VP8ResetProba(VP8Proba___0 *proba ) 
{ 


  {
  {
#line 328
  memset((uint8_t *)proba->segments_, (int )255U, sizeof(proba->segments_));
#line 329
  memcpy((uint8_t (*)[8][3][11])proba->coeffs_, (uint8_t (*)[8][3][11])CoeffsProba0,
         sizeof(CoeffsProba0));
  }
  return;
}
}
#line 337 "/doner/libwebp/libwebp-v0.3.0/src/dec/tree.c"
void VP8ParseIntraMode(VP8BitReader *br , VP8Decoder *dec ) 
{ 
  uint8_t *top ;
  uint8_t *left ;
  int __cil_tmp5 ;
  int ymode ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;
  int __cil_tmp10 ;
  int tmp___0 ;
  int tmp___1 ;
  uint8_t *modes ;
  int y ;
  int ymode___0 ;
  int x ;
  uint8_t *prob ;
  int i ;
  int __cil_tmp19 ;
  uint8_t *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 338
  top = dec->intra_t_ + 4 * dec->mb_x_;
#line 339
  left = (uint8_t *)dec->intra_l_;
#line 341
  __cil_tmp5 = VP8GetBit(br, 145);
#line 341
  dec->is_i4x4_ = (uint8_t )(! __cil_tmp5);
  }
#line 342
  if (! dec->is_i4x4_) {
    {
#line 343
    __cil_tmp7 = VP8GetBit(br, 156);
    }
#line 343
    if (__cil_tmp7) {
      {
#line 343
      __cil_tmp8 = VP8GetBit(br, 128);
      }
#line 343
      if (__cil_tmp8) {
#line 343
        tmp = 1;
      } else {
#line 343
        tmp = 3;
      }
#line 343
      tmp___1 = tmp;
    } else {
      {
#line 343
      __cil_tmp10 = VP8GetBit(br, 163);
      }
#line 343
      if (__cil_tmp10) {
#line 343
        tmp___0 = 2;
      } else {
#line 343
        tmp___0 = 0;
      }
#line 343
      tmp___1 = tmp___0;
    }
    {
#line 343
    ymode = tmp___1;
#line 346
    dec->imodes_[0] = (uint8_t )ymode;
#line 347
    memset(top, ymode, 4UL * sizeof(*(top + 0)));
#line 348
    memset(left, ymode, 4UL * sizeof(*(left + 0)));
    }
  } else {
#line 350
    modes = (uint8_t *)dec->imodes_;
#line 352
    y = 0;
    {
#line 352
    while (1) {
      while_continue: /* CIL Label */ ;
#line 352
      if (! (y < 4)) {
#line 352
        goto while_break;
      }
#line 353
      ymode___0 = (int )*(left + y);
#line 355
      x = 0;
      {
#line 355
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 355
        if (! (x < 4)) {
#line 355
          goto while_break___0;
        }
#line 356
        prob = (uint8_t *)kBModesProba___0[*(top + x)][ymode___0];
#line 359
        i = 0;
        {
#line 360
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 361
          __cil_tmp19 = VP8GetBit(br, (int )*(prob + i));
#line 361
          i = (int )kYModesIntra4[2 * i + __cil_tmp19];
          }
#line 360
          if (! (i > 0)) {
#line 360
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 363
        ymode___0 = - i;
#line 376
        *(top + x) = (uint8_t )ymode___0;
#line 377
        __cil_tmp20 = modes;
#line 377
        modes ++;
#line 377
        *__cil_tmp20 = (uint8_t )ymode___0;
#line 355
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 379
      *(left + y) = (uint8_t )ymode___0;
#line 352
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 383
  __cil_tmp21 = VP8GetBit(br, 142);
  }
#line 383
  if (! __cil_tmp21) {
#line 383
    tmp___4 = 0;
  } else {
    {
#line 383
    __cil_tmp22 = VP8GetBit(br, 114);
    }
#line 383
    if (! __cil_tmp22) {
#line 383
      tmp___3 = 2;
    } else {
      {
#line 383
      __cil_tmp23 = VP8GetBit(br, 183);
      }
#line 383
      if (__cil_tmp23) {
#line 383
        tmp___2 = 1;
      } else {
#line 383
        tmp___2 = 3;
      }
#line 383
      tmp___3 = tmp___2;
    }
#line 383
    tmp___4 = tmp___3;
  }
#line 383
  dec->uvmode_ = (uint8_t )tmp___4;
  return;
}
}
#line 392 "/doner/libwebp/libwebp-v0.3.0/src/dec/tree.c"
static uint8_t CoeffsUpdateProba[4][8][3][11]  = { { { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )176,            (uint8_t )246,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )241,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )244,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )246,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )239,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )217,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )225,            (uint8_t )252,            (uint8_t )241,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )250,            (uint8_t )241,            (uint8_t )250, 
                    (uint8_t )253,            (uint8_t )255,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )223,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )238,            (uint8_t )253,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )248,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )247,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )186,            (uint8_t )251,            (uint8_t )250,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )234,            (uint8_t )251,            (uint8_t )244,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )251,            (uint8_t )243,            (uint8_t )253, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )236,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )251,            (uint8_t )253,            (uint8_t )253,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}, 
   { { {            (uint8_t )248,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )254,            (uint8_t )252,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )249,            (uint8_t )253, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )246,            (uint8_t )253,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )254,            (uint8_t )251,            (uint8_t )254, 
                    (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )254,            (uint8_t )252,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )248,            (uint8_t )254,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )255,            (uint8_t )254,            (uint8_t )254, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )245,            (uint8_t )251,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )253,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )251,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )252,            (uint8_t )253,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )254,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )252,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )249,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )254,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )253,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )250,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}, 
     { {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )254,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}, 
       {            (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255,            (uint8_t )255, 
                    (uint8_t )255,            (uint8_t )255,            (uint8_t )255}}}};
#line 539 "/doner/libwebp/libwebp-v0.3.0/src/dec/tree.c"
void VP8ParseProba(VP8BitReader *br , VP8Decoder *dec ) 
{ 
  VP8Proba___0 *proba ;
  int t ;
  int b ;
  int c ;
  int p ;
  int __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  uint32_t __cil_tmp11 ;

  {
#line 540
  proba = & dec->proba_;
#line 542
  t = 0;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 542
    if (! (t < 4)) {
#line 542
      goto while_break;
    }
#line 543
    b = 0;
    {
#line 543
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 543
      if (! (b < 8)) {
#line 543
        goto while_break___0;
      }
#line 544
      c = 0;
      {
#line 544
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 544
        if (! (c < 3)) {
#line 544
          goto while_break___1;
        }
#line 545
        p = 0;
        {
#line 545
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 545
          if (! (p < 11)) {
#line 545
            goto while_break___2;
          }
          {
#line 546
          __cil_tmp8 = VP8GetBit(br, (int )CoeffsUpdateProba[t][b][c][p]);
          }
#line 546
          if (__cil_tmp8) {
            {
#line 547
            __cil_tmp9 = VP8GetValue(br, 8);
#line 547
            proba->coeffs_[t][b][c][p] = (uint8_t )__cil_tmp9;
            }
          }
#line 545
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 544
        c ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 543
      b ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 542
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  __cil_tmp10 = VP8Get(br);
#line 553
  dec->use_skip_proba_ = (int )__cil_tmp10;
  }
#line 554
  if (dec->use_skip_proba_) {
    {
#line 555
    __cil_tmp11 = VP8GetValue(br, 8);
#line 555
    dec->skip_p_ = (uint8_t )__cil_tmp11;
    }
  }
  return;
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
static uint32_t kHashMul___7  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___7(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___7 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___7(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___7 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheContains___7(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___7 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 18 "/doner/libwebp/libwebp-v0.3.0/src/dec/quant.c"
__inline static int clip___2(int v , int M ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 19
  if (v < 0) {
#line 19
    tmp___0 = 0;
  } else {
#line 19
    if (v > M) {
#line 19
      tmp = M;
    } else {
#line 19
      tmp = v;
    }
#line 19
    tmp___0 = tmp;
  }
#line 19
  return (tmp___0);
}
}
#line 23 "/doner/libwebp/libwebp-v0.3.0/src/dec/quant.c"
static uint8_t kDcTable___0[128]  = 
#line 23
  {      (uint8_t )4,      (uint8_t )5,      (uint8_t )6,      (uint8_t )7, 
        (uint8_t )8,      (uint8_t )9,      (uint8_t )10,      (uint8_t )10, 
        (uint8_t )11,      (uint8_t )12,      (uint8_t )13,      (uint8_t )14, 
        (uint8_t )15,      (uint8_t )16,      (uint8_t )17,      (uint8_t )17, 
        (uint8_t )18,      (uint8_t )19,      (uint8_t )20,      (uint8_t )20, 
        (uint8_t )21,      (uint8_t )21,      (uint8_t )22,      (uint8_t )22, 
        (uint8_t )23,      (uint8_t )23,      (uint8_t )24,      (uint8_t )25, 
        (uint8_t )25,      (uint8_t )26,      (uint8_t )27,      (uint8_t )28, 
        (uint8_t )29,      (uint8_t )30,      (uint8_t )31,      (uint8_t )32, 
        (uint8_t )33,      (uint8_t )34,      (uint8_t )35,      (uint8_t )36, 
        (uint8_t )37,      (uint8_t )37,      (uint8_t )38,      (uint8_t )39, 
        (uint8_t )40,      (uint8_t )41,      (uint8_t )42,      (uint8_t )43, 
        (uint8_t )44,      (uint8_t )45,      (uint8_t )46,      (uint8_t )46, 
        (uint8_t )47,      (uint8_t )48,      (uint8_t )49,      (uint8_t )50, 
        (uint8_t )51,      (uint8_t )52,      (uint8_t )53,      (uint8_t )54, 
        (uint8_t )55,      (uint8_t )56,      (uint8_t )57,      (uint8_t )58, 
        (uint8_t )59,      (uint8_t )60,      (uint8_t )61,      (uint8_t )62, 
        (uint8_t )63,      (uint8_t )64,      (uint8_t )65,      (uint8_t )66, 
        (uint8_t )67,      (uint8_t )68,      (uint8_t )69,      (uint8_t )70, 
        (uint8_t )71,      (uint8_t )72,      (uint8_t )73,      (uint8_t )74, 
        (uint8_t )75,      (uint8_t )76,      (uint8_t )76,      (uint8_t )77, 
        (uint8_t )78,      (uint8_t )79,      (uint8_t )80,      (uint8_t )81, 
        (uint8_t )82,      (uint8_t )83,      (uint8_t )84,      (uint8_t )85, 
        (uint8_t )86,      (uint8_t )87,      (uint8_t )88,      (uint8_t )89, 
        (uint8_t )91,      (uint8_t )93,      (uint8_t )95,      (uint8_t )96, 
        (uint8_t )98,      (uint8_t )100,      (uint8_t )101,      (uint8_t )102, 
        (uint8_t )104,      (uint8_t )106,      (uint8_t )108,      (uint8_t )110, 
        (uint8_t )112,      (uint8_t )114,      (uint8_t )116,      (uint8_t )118, 
        (uint8_t )122,      (uint8_t )124,      (uint8_t )126,      (uint8_t )128, 
        (uint8_t )130,      (uint8_t )132,      (uint8_t )134,      (uint8_t )136, 
        (uint8_t )138,      (uint8_t )140,      (uint8_t )143,      (uint8_t )145, 
        (uint8_t )148,      (uint8_t )151,      (uint8_t )154,      (uint8_t )157};
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/quant.c"
static uint16_t kAcTable___0[128]  = 
#line 42
  {      (uint16_t )4,      (uint16_t )5,      (uint16_t )6,      (uint16_t )7, 
        (uint16_t )8,      (uint16_t )9,      (uint16_t )10,      (uint16_t )11, 
        (uint16_t )12,      (uint16_t )13,      (uint16_t )14,      (uint16_t )15, 
        (uint16_t )16,      (uint16_t )17,      (uint16_t )18,      (uint16_t )19, 
        (uint16_t )20,      (uint16_t )21,      (uint16_t )22,      (uint16_t )23, 
        (uint16_t )24,      (uint16_t )25,      (uint16_t )26,      (uint16_t )27, 
        (uint16_t )28,      (uint16_t )29,      (uint16_t )30,      (uint16_t )31, 
        (uint16_t )32,      (uint16_t )33,      (uint16_t )34,      (uint16_t )35, 
        (uint16_t )36,      (uint16_t )37,      (uint16_t )38,      (uint16_t )39, 
        (uint16_t )40,      (uint16_t )41,      (uint16_t )42,      (uint16_t )43, 
        (uint16_t )44,      (uint16_t )45,      (uint16_t )46,      (uint16_t )47, 
        (uint16_t )48,      (uint16_t )49,      (uint16_t )50,      (uint16_t )51, 
        (uint16_t )52,      (uint16_t )53,      (uint16_t )54,      (uint16_t )55, 
        (uint16_t )56,      (uint16_t )57,      (uint16_t )58,      (uint16_t )60, 
        (uint16_t )62,      (uint16_t )64,      (uint16_t )66,      (uint16_t )68, 
        (uint16_t )70,      (uint16_t )72,      (uint16_t )74,      (uint16_t )76, 
        (uint16_t )78,      (uint16_t )80,      (uint16_t )82,      (uint16_t )84, 
        (uint16_t )86,      (uint16_t )88,      (uint16_t )90,      (uint16_t )92, 
        (uint16_t )94,      (uint16_t )96,      (uint16_t )98,      (uint16_t )100, 
        (uint16_t )102,      (uint16_t )104,      (uint16_t )106,      (uint16_t )108, 
        (uint16_t )110,      (uint16_t )112,      (uint16_t )114,      (uint16_t )116, 
        (uint16_t )119,      (uint16_t )122,      (uint16_t )125,      (uint16_t )128, 
        (uint16_t )131,      (uint16_t )134,      (uint16_t )137,      (uint16_t )140, 
        (uint16_t )143,      (uint16_t )146,      (uint16_t )149,      (uint16_t )152, 
        (uint16_t )155,      (uint16_t )158,      (uint16_t )161,      (uint16_t )164, 
        (uint16_t )167,      (uint16_t )170,      (uint16_t )173,      (uint16_t )177, 
        (uint16_t )181,      (uint16_t )185,      (uint16_t )189,      (uint16_t )193, 
        (uint16_t )197,      (uint16_t )201,      (uint16_t )205,      (uint16_t )209, 
        (uint16_t )213,      (uint16_t )217,      (uint16_t )221,      (uint16_t )225, 
        (uint16_t )229,      (uint16_t )234,      (uint16_t )239,      (uint16_t )245, 
        (uint16_t )249,      (uint16_t )254,      (uint16_t )259,      (uint16_t )264, 
        (uint16_t )269,      (uint16_t )274,      (uint16_t )279,      (uint16_t )284};
#line 64 "/doner/libwebp/libwebp-v0.3.0/src/dec/quant.c"
void VP8ParseQuant(VP8Decoder *dec ) 
{ 
  VP8BitReader *br ;
  int base_q0 ;
  uint32_t __cil_tmp4 ;
  int dqy1_dc ;
  uint32_t __cil_tmp6 ;
  int32_t __cil_tmp7 ;
  int32_t tmp ;
  int dqy2_dc ;
  uint32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;
  int32_t tmp___0 ;
  int dqy2_ac ;
  uint32_t __cil_tmp14 ;
  int32_t __cil_tmp15 ;
  int32_t tmp___1 ;
  int dquv_dc ;
  uint32_t __cil_tmp18 ;
  int32_t __cil_tmp19 ;
  int32_t tmp___2 ;
  int dquv_ac ;
  uint32_t __cil_tmp22 ;
  int32_t __cil_tmp23 ;
  int32_t tmp___3 ;
  VP8SegmentHeader___0 *hdr ;
  int i ;
  int q ;
  VP8QuantMatrix *m ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;

  {
  {
#line 65
  br = & dec->br_;
#line 66
  __cil_tmp4 = VP8GetValue(br, 7);
#line 66
  base_q0 = (int )__cil_tmp4;
#line 67
  __cil_tmp6 = VP8Get(br);
  }
#line 67
  if (__cil_tmp6) {
    {
#line 67
    __cil_tmp7 = VP8GetSignedValue(br, 4);
#line 67
    tmp = __cil_tmp7;
    }
  } else {
#line 67
    tmp = 0;
  }
  {
#line 67
  dqy1_dc = tmp;
#line 68
  __cil_tmp10 = VP8Get(br);
  }
#line 68
  if (__cil_tmp10) {
    {
#line 68
    __cil_tmp11 = VP8GetSignedValue(br, 4);
#line 68
    tmp___0 = __cil_tmp11;
    }
  } else {
#line 68
    tmp___0 = 0;
  }
  {
#line 68
  dqy2_dc = tmp___0;
#line 69
  __cil_tmp14 = VP8Get(br);
  }
#line 69
  if (__cil_tmp14) {
    {
#line 69
    __cil_tmp15 = VP8GetSignedValue(br, 4);
#line 69
    tmp___1 = __cil_tmp15;
    }
  } else {
#line 69
    tmp___1 = 0;
  }
  {
#line 69
  dqy2_ac = tmp___1;
#line 70
  __cil_tmp18 = VP8Get(br);
  }
#line 70
  if (__cil_tmp18) {
    {
#line 70
    __cil_tmp19 = VP8GetSignedValue(br, 4);
#line 70
    tmp___2 = __cil_tmp19;
    }
  } else {
#line 70
    tmp___2 = 0;
  }
  {
#line 70
  dquv_dc = tmp___2;
#line 71
  __cil_tmp22 = VP8Get(br);
  }
#line 71
  if (__cil_tmp22) {
    {
#line 71
    __cil_tmp23 = VP8GetSignedValue(br, 4);
#line 71
    tmp___3 = __cil_tmp23;
    }
  } else {
#line 71
    tmp___3 = 0;
  }
#line 71
  dquv_ac = tmp___3;
#line 73
  hdr = & dec->segment_hdr_;
#line 76
  i = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < 4)) {
#line 76
      goto while_break;
    }
#line 78
    if (hdr->use_segment_) {
#line 79
      q = (int )hdr->quantizer_[i];
#line 80
      if (! hdr->absolute_delta_) {
#line 81
        q += base_q0;
      }
    } else
#line 84
    if (i > 0) {
#line 85
      dec->dqm_[i] = dec->dqm_[0];
#line 86
      goto while_continue;
    } else {
#line 88
      q = base_q0;
    }
    {
#line 92
    m = & dec->dqm_[i];
#line 93
    __cil_tmp29 = clip___2(q + dqy1_dc, 127);
#line 93
    m->y1_mat_[0] = (int )kDcTable___0[__cil_tmp29];
#line 94
    __cil_tmp30 = clip___2(q, 127);
#line 94
    m->y1_mat_[1] = (int )kAcTable___0[__cil_tmp30];
#line 96
    __cil_tmp31 = clip___2(q + dqy2_dc, 127);
#line 96
    m->y2_mat_[0] = (int )kDcTable___0[__cil_tmp31] * 2;
#line 100
    __cil_tmp32 = clip___2(q + dqy2_ac, 127);
#line 100
    m->y2_mat_[1] = (int )kAcTable___0[__cil_tmp32] * 101581 >> 16;
    }
#line 101
    if (m->y2_mat_[1] < 8) {
#line 101
      m->y2_mat_[1] = 8;
    }
    {
#line 103
    __cil_tmp33 = clip___2(q + dquv_dc, 117);
#line 103
    m->uv_mat_[0] = (int )kDcTable___0[__cil_tmp33];
#line 104
    __cil_tmp34 = clip___2(q + dquv_ac, 127);
#line 104
    m->uv_mat_[1] = (int )kAcTable___0[__cil_tmp34];
    }
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
static uint32_t kHashMul___8  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___8(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___8 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___8(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___8 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheContains___8(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___8 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 23 "/doner/libwebp/libwebp-v0.3.0/src/dec/layer.c"
int VP8DecodeLayer(VP8Decoder *dec ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 30
  return (1);
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/../dec/./../utils/color_cache.h"
static uint32_t kHashMul___9  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/../dec/./../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___9(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___9 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/../dec/./../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___9(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___9 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/../dec/./../utils/color_cache.h"
__inline static int VP8LColorCacheContains___9(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___9 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitYUV(VP8Io *io , WebPDecParams *p ) 
{ 
  WebPDecBuffer *output ;
  WebPYUVABuffer *buf ;
  uint8_t *y_dst ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  int mb_w ;
  int mb_h ;
  int uv_w ;
  int uv_h ;
  int j ;

  {
#line 27
  output = p->output;
#line 28
  buf = & output->u.YUVA;
#line 29
  y_dst = buf->y + io->mb_y * buf->y_stride;
#line 30
  u_dst = buf->u + (io->mb_y >> 1) * buf->u_stride;
#line 31
  v_dst = buf->v + (io->mb_y >> 1) * buf->v_stride;
#line 32
  mb_w = io->mb_w;
#line 33
  mb_h = io->mb_h;
#line 34
  uv_w = (mb_w + 1) / 2;
#line 35
  uv_h = (mb_h + 1) / 2;
#line 37
  j = 0;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (j < mb_h)) {
#line 37
      goto while_break;
    }
    {
#line 38
    memcpy(y_dst + j * buf->y_stride, io->y + j * io->y_stride, (unsigned long )mb_w);
    }
#line 37
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  j = 0;
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! (j < uv_h)) {
#line 40
      goto while_break___0;
    }
    {
#line 41
    memcpy(u_dst + j * buf->u_stride, io->u + j * io->uv_stride, (unsigned long )uv_w);
#line 42
    memcpy(v_dst + j * buf->v_stride, io->v + j * io->uv_stride, (unsigned long )uv_w);
    }
#line 40
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 44
  return (io->mb_h);
}
}
#line 48 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitSampledRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  WebPDecBuffer *output ;
  WebPRGBABuffer *buf ;
  uint8_t *dst ;
  uint8_t *y_src ;
  uint8_t *u_src ;
  uint8_t *v_src ;
  WebPSampleLinePairFunc sample ;
  int mb_w ;
  int last ;
  int j ;

  {
#line 49
  output = p->output;
#line 50
  buf = & output->u.RGBA;
#line 51
  dst = buf->rgba + io->mb_y * buf->stride;
#line 52
  y_src = io->y;
#line 53
  u_src = io->u;
#line 54
  v_src = io->v;
#line 55
  sample = WebPSamplers[output->colorspace];
#line 56
  mb_w = io->mb_w;
#line 57
  last = io->mb_h - 1;
#line 59
  j = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (j < last)) {
#line 59
      goto while_break;
    }
    {
#line 60
    (*sample)(y_src, y_src + io->y_stride, u_src, v_src, dst, dst + buf->stride, mb_w);
#line 62
    y_src += 2 * io->y_stride;
#line 63
    u_src += io->uv_stride;
#line 64
    v_src += io->uv_stride;
#line 65
    dst += 2 * buf->stride;
    }
#line 59
    j += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  if (j == last) {
    {
#line 68
    (*sample)(y_src, y_src, u_src, v_src, dst, dst, mb_w);
    }
  }
#line 70
  return (io->mb_h);
}
}
#line 103 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitFancyRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  int num_lines_out ;
  WebPRGBABuffer *buf ;
  uint8_t *dst ;
  WebPUpsampleLinePairFunc upsample ;
  uint8_t *cur_y ;
  uint8_t *cur_u ;
  uint8_t *cur_v ;
  uint8_t *top_u ;
  uint8_t *top_v ;
  int y ;
  int y_end ;
  int mb_w ;
  int uv_w ;
  int __cil_tmp16 ;

  {
#line 104
  num_lines_out = io->mb_h;
#line 105
  buf = & (p->output)->u.RGBA;
#line 106
  dst = buf->rgba + io->mb_y * buf->stride;
#line 107
  upsample = WebPUpsamplers[(p->output)->colorspace];
#line 108
  cur_y = io->y;
#line 109
  cur_u = io->u;
#line 110
  cur_v = io->v;
#line 111
  top_u = p->tmp_u;
#line 112
  top_v = p->tmp_v;
#line 113
  y = io->mb_y;
#line 114
  y_end = io->mb_y + io->mb_h;
#line 115
  mb_w = io->mb_w;
#line 116
  uv_w = (mb_w + 1) / 2;
#line 118
  if (y == 0) {
    {
#line 120
    (*upsample)((uint8_t *)((void *)0), cur_y, cur_u, cur_v, cur_u, cur_v, (uint8_t *)((void *)0),
                dst, mb_w);
    }
  } else {
    {
#line 123
    (*upsample)(p->tmp_y, cur_y, top_u, top_v, cur_u, cur_v, dst - buf->stride, dst,
                mb_w);
#line 125
    num_lines_out ++;
    }
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (y + 2 < y_end)) {
#line 128
      goto while_break;
    }
    {
#line 129
    top_u = cur_u;
#line 130
    top_v = cur_v;
#line 131
    cur_u += io->uv_stride;
#line 132
    cur_v += io->uv_stride;
#line 133
    dst += 2 * buf->stride;
#line 134
    cur_y += 2 * io->y_stride;
#line 135
    (*upsample)(cur_y - io->y_stride, cur_y, top_u, top_v, cur_u, cur_v, dst - buf->stride,
                dst, mb_w);
    }
#line 128
    y += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  cur_y += io->y_stride;
#line 141
  if (io->crop_top + y_end < io->crop_bottom) {
    {
#line 143
    memcpy(p->tmp_y, cur_y, (unsigned long )mb_w * sizeof(*(p->tmp_y)));
#line 144
    memcpy(p->tmp_u, cur_u, (unsigned long )uv_w * sizeof(*(p->tmp_u)));
#line 145
    memcpy(p->tmp_v, cur_v, (unsigned long )uv_w * sizeof(*(p->tmp_v)));
#line 148
    __cil_tmp16 = num_lines_out;
#line 148
    num_lines_out --;
    }
  } else
#line 151
  if (! (y_end & 1)) {
    {
#line 152
    (*upsample)(cur_y, (uint8_t *)((void *)0), cur_u, cur_v, cur_u, cur_v, dst + buf->stride,
                (uint8_t *)((void *)0), mb_w);
    }
  }
#line 156
  return (num_lines_out);
}
}
#line 163 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitAlphaYUV(VP8Io *io , WebPDecParams *p ) 
{ 
  uint8_t *alpha ;
  WebPYUVABuffer *buf ;
  int mb_w ;
  int mb_h ;
  uint8_t *dst ;
  int j ;

  {
#line 164
  alpha = io->a;
#line 165
  buf = & (p->output)->u.YUVA;
#line 166
  mb_w = io->mb_w;
#line 167
  mb_h = io->mb_h;
#line 168
  dst = buf->a + io->mb_y * buf->a_stride;
#line 171
  if (alpha != (void *)0) {
#line 172
    j = 0;
    {
#line 172
    while (1) {
      while_continue: /* CIL Label */ ;
#line 172
      if (! (j < mb_h)) {
#line 172
        goto while_break;
      }
      {
#line 173
      memcpy(dst, alpha, (unsigned long )mb_w * sizeof(*dst));
#line 174
      alpha += io->width;
#line 175
      dst += buf->a_stride;
      }
#line 172
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 177
  if (buf->a != (void *)0) {
#line 179
    j = 0;
    {
#line 179
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 179
      if (! (j < mb_h)) {
#line 179
        goto while_break___0;
      }
      {
#line 180
      memset(dst, 255, (unsigned long )mb_w * sizeof(*dst));
#line 181
      dst += buf->a_stride;
      }
#line 179
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 184
  return (0);
}
}
#line 187 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int GetAlphaSourceRow(VP8Io *io , uint8_t **alpha , int *num_rows ) 
{ 
  int start_y ;

  {
#line 189
  start_y = io->mb_y;
#line 190
  *num_rows = io->mb_h;
#line 194
  if (io->fancy_upsampling) {
#line 195
    if (start_y == 0) {
#line 197
      (*num_rows) --;
    } else {
#line 199
      start_y --;
#line 203
      *alpha -= io->width;
    }
#line 205
    if ((io->crop_top + io->mb_y) + io->mb_h == io->crop_bottom) {
#line 207
      *num_rows = (io->crop_bottom - io->crop_top) - start_y;
    }
  }
#line 210
  return (start_y);
}
}
#line 213 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitAlphaRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  uint8_t *alpha ;
  int mb_w ;
  enum WEBP_CSP_MODE colorspace ;
  int alpha_first ;
  WebPRGBABuffer *buf ;
  int num_rows ;
  int start_y ;
  int __cil_tmp10 ;
  uint8_t *base_rgba ;
  uint8_t *dst ;
  int tmp ;
  uint32_t alpha_mask ;
  int i ;
  int j ;
  uint32_t alpha_value ;
  int __cil_tmp18 ;

  {
#line 214
  alpha = io->a;
#line 215
  if (alpha != (void *)0) {
    {
#line 216
    mb_w = io->mb_w;
#line 217
    colorspace = (p->output)->colorspace;
#line 218
    alpha_first = (unsigned int )colorspace == 4U || (unsigned int )colorspace == 9U;
#line 220
    buf = & (p->output)->u.RGBA;
#line 222
    __cil_tmp10 = GetAlphaSourceRow(io, & alpha, & num_rows);
#line 222
    start_y = __cil_tmp10;
#line 223
    base_rgba = buf->rgba + start_y * buf->stride;
    }
#line 224
    if (alpha_first) {
#line 224
      tmp = 0;
    } else {
#line 224
      tmp = 3;
    }
#line 224
    dst = base_rgba + tmp;
#line 225
    alpha_mask = (uint32_t )255;
#line 228
    j = 0;
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 228
      if (! (j < num_rows)) {
#line 228
        goto while_break;
      }
#line 229
      i = 0;
      {
#line 229
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 229
        if (! (i < mb_w)) {
#line 229
          goto while_break___0;
        }
#line 230
        alpha_value = (uint32_t )*(alpha + i);
#line 231
        *(dst + 4 * i) = (uint8_t )alpha_value;
#line 232
        alpha_mask &= alpha_value;
#line 229
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 234
      alpha += io->width;
#line 235
      dst += buf->stride;
#line 228
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 238
    __cil_tmp18 = WebPIsPremultipliedMode___0(colorspace);
    }
#line 238
    if (alpha_mask != 255U) {
#line 238
      if (__cil_tmp18) {
        {
#line 239
        (*WebPApplyAlphaMultiply)(base_rgba, alpha_first, mb_w, num_rows, buf->stride);
        }
      }
    }
  }
#line 243
  return (0);
}
}
#line 246 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitAlphaRGBA4444(VP8Io *io , WebPDecParams *p ) 
{ 
  uint8_t *alpha ;
  int mb_w ;
  enum WEBP_CSP_MODE colorspace ;
  WebPRGBABuffer *buf ;
  int num_rows ;
  int start_y ;
  int __cil_tmp9 ;
  uint8_t *base_rgba ;
  uint8_t *alpha_dst ;
  uint32_t alpha_mask ;
  int i ;
  int j ;
  uint32_t alpha_value ;
  int __cil_tmp16 ;

  {
#line 247
  alpha = io->a;
#line 248
  if (alpha != (void *)0) {
    {
#line 249
    mb_w = io->mb_w;
#line 250
    colorspace = (p->output)->colorspace;
#line 251
    buf = & (p->output)->u.RGBA;
#line 253
    __cil_tmp9 = GetAlphaSourceRow(io, & alpha, & num_rows);
#line 253
    start_y = __cil_tmp9;
#line 254
    base_rgba = buf->rgba + start_y * buf->stride;
#line 255
    alpha_dst = base_rgba + 1;
#line 256
    alpha_mask = (uint32_t )15;
#line 259
    j = 0;
    }
    {
#line 259
    while (1) {
      while_continue: /* CIL Label */ ;
#line 259
      if (! (j < num_rows)) {
#line 259
        goto while_break;
      }
#line 260
      i = 0;
      {
#line 260
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 260
        if (! (i < mb_w)) {
#line 260
          goto while_break___0;
        }
#line 262
        alpha_value = (uint32_t )((int )*(alpha + i) >> 4);
#line 263
        *(alpha_dst + 2 * i) = (uint8_t )((unsigned int )((int )*(alpha_dst + 2 * i) & 240) | alpha_value);
#line 264
        alpha_mask &= alpha_value;
#line 260
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 266
      alpha += io->width;
#line 267
      alpha_dst += buf->stride;
#line 259
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 269
    __cil_tmp16 = WebPIsPremultipliedMode___0(colorspace);
    }
#line 269
    if (alpha_mask != 15U) {
#line 269
      if (__cil_tmp16) {
        {
#line 270
        (*WebPApplyAlphaMultiply4444)(base_rgba, mb_w, num_rows, buf->stride);
        }
      }
    }
  }
#line 273
  return (0);
}
}
#line 279 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int Rescale(uint8_t *src , int src_stride , int new_lines , WebPRescaler *wrk ) 
{ 
  int num_lines_out ;
  int lines_in ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 281
  num_lines_out = 0;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (new_lines > 0)) {
#line 282
      goto while_break;
    }
    {
#line 283
    __cil_tmp7 = WebPRescalerImport(wrk, new_lines, src, src_stride);
#line 283
    lines_in = __cil_tmp7;
#line 284
    src += lines_in * src_stride;
#line 285
    new_lines -= lines_in;
#line 286
    __cil_tmp8 = WebPRescalerExport(wrk);
    }
#line 286
    num_lines_out += __cil_tmp8;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return (num_lines_out);
}
}
#line 291 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitRescaledYUV(VP8Io *io , WebPDecParams *p ) 
{ 
  int mb_h ;
  int uv_mb_h ;
  int num_lines_out ;
  int __cil_tmp6 ;

  {
  {
#line 292
  mb_h = io->mb_h;
#line 293
  uv_mb_h = (mb_h + 1) >> 1;
#line 294
  __cil_tmp6 = Rescale(io->y, io->y_stride, mb_h, & p->scaler_y);
#line 294
  num_lines_out = __cil_tmp6;
#line 295
  Rescale(io->u, io->uv_stride, uv_mb_h, & p->scaler_u);
#line 296
  Rescale(io->v, io->uv_stride, uv_mb_h, & p->scaler_v);
  }
#line 297
  return (num_lines_out);
}
}
#line 300 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitRescaledAlphaYUV(VP8Io *io , WebPDecParams *p ) 
{ 


  {
#line 301
  if (io->a != (void *)0) {
    {
#line 302
    Rescale(io->a, io->width, io->mb_h, & p->scaler_a);
    }
  }
#line 304
  return (0);
}
}
#line 307 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int InitYUVRescaler(VP8Io *io , WebPDecParams *p ) 
{ 
  int has_alpha ;
  int __cil_tmp4 ;
  WebPYUVABuffer *buf ;
  int out_width ;
  int out_height ;
  int uv_out_width ;
  int uv_out_height ;
  int uv_in_width ;
  int uv_in_height ;
  size_t work_size ;
  size_t uv_work_size ;
  size_t tmp_size ;
  int32_t *work ;
  void *__cil_tmp16 ;

  {
  {
#line 308
  __cil_tmp4 = WebPIsAlphaMode___0((p->output)->colorspace);
#line 308
  has_alpha = __cil_tmp4;
#line 309
  buf = & (p->output)->u.YUVA;
#line 310
  out_width = io->scaled_width;
#line 311
  out_height = io->scaled_height;
#line 312
  uv_out_width = (out_width + 1) >> 1;
#line 313
  uv_out_height = (out_height + 1) >> 1;
#line 314
  uv_in_width = (io->mb_w + 1) >> 1;
#line 315
  uv_in_height = (io->mb_h + 1) >> 1;
#line 316
  work_size = (size_t )(2 * out_width);
#line 317
  uv_work_size = (size_t )(2 * uv_out_width);
#line 321
  tmp_size = work_size + 2UL * uv_work_size;
  }
#line 322
  if (has_alpha) {
#line 323
    tmp_size += work_size;
  }
  {
#line 325
  p->memory = calloc((unsigned long )1, tmp_size * sizeof(*work));
  }
#line 326
  if (p->memory == (void *)0) {
#line 327
    return (0);
  }
  {
#line 329
  work = (int32_t *)p->memory;
#line 330
  WebPRescalerInit(& p->scaler_y, io->mb_w, io->mb_h, buf->y, out_width, out_height,
                   buf->y_stride, 1, io->mb_w, out_width, io->mb_h, out_height, work);
#line 334
  WebPRescalerInit(& p->scaler_u, uv_in_width, uv_in_height, buf->u, uv_out_width,
                   uv_out_height, buf->u_stride, 1, uv_in_width, uv_out_width, uv_in_height,
                   uv_out_height, work + work_size);
#line 339
  WebPRescalerInit(& p->scaler_v, uv_in_width, uv_in_height, buf->v, uv_out_width,
                   uv_out_height, buf->v_stride, 1, uv_in_width, uv_out_width, uv_in_height,
                   uv_out_height, (work + work_size) + uv_work_size);
#line 344
  p->emit = & EmitRescaledYUV;
  }
#line 346
  if (has_alpha) {
    {
#line 347
    WebPRescalerInit(& p->scaler_a, io->mb_w, io->mb_h, buf->a, out_width, out_height,
                     buf->a_stride, 1, io->mb_w, out_width, io->mb_h, out_height,
                     (work + work_size) + 2UL * uv_work_size);
#line 351
    p->emit_alpha = & EmitRescaledAlphaYUV;
    }
  }
#line 353
  return (1);
}
}
#line 359 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int ExportRGB(WebPDecParams *p , int y_pos ) 
{ 
  WebPYUV444Converter convert ;
  WebPRGBABuffer *buf ;
  uint8_t *dst ;
  int num_lines_out ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;
  int tmp___0 ;

  {
#line 360
  convert = WebPYUV444Converters[(p->output)->colorspace];
#line 362
  buf = & (p->output)->u.RGBA;
#line 363
  dst = buf->rgba + (p->last_y + y_pos) * buf->stride;
#line 364
  num_lines_out = 0;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 367
    __cil_tmp8 = WebPRescalerHasPendingOutput(& p->scaler_u);
    }
    {
#line 367
    __cil_tmp7 = WebPRescalerHasPendingOutput(& p->scaler_y);
    }
#line 367
    if (! (__cil_tmp7 && __cil_tmp8)) {
#line 367
      goto while_break;
    }
    {
#line 371
    WebPRescalerExportRow(& p->scaler_y);
#line 372
    WebPRescalerExportRow(& p->scaler_u);
#line 373
    WebPRescalerExportRow(& p->scaler_v);
#line 374
    (*convert)(p->scaler_y.dst, p->scaler_u.dst, p->scaler_v.dst, dst, p->scaler_y.dst_width);
#line 376
    dst += buf->stride;
#line 377
    num_lines_out ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  return (num_lines_out);
}
}
#line 382 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitRescaledRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  int mb_h ;
  int uv_mb_h ;
  int j ;
  int uv_j ;
  int num_lines_out ;
  int y_lines_in ;
  int __cil_tmp9 ;
  int u_lines_in ;
  int __cil_tmp11 ;
  int v_lines_in ;
  int __cil_tmp13 ;
  int tmp ;
  int __cil_tmp15 ;

  {
#line 383
  mb_h = io->mb_h;
#line 384
  uv_mb_h = (mb_h + 1) >> 1;
#line 385
  j = 0;
#line 385
  uv_j = 0;
#line 386
  num_lines_out = 0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! (j < mb_h)) {
#line 387
      goto while_break;
    }
    {
#line 388
    __cil_tmp9 = WebPRescalerImport(& p->scaler_y, mb_h - j, io->y + j * io->y_stride,
                                    io->y_stride);
#line 388
    y_lines_in = __cil_tmp9;
#line 391
    __cil_tmp11 = WebPRescalerImport(& p->scaler_u, uv_mb_h - uv_j, io->u + uv_j * io->uv_stride,
                                     io->uv_stride);
#line 391
    u_lines_in = __cil_tmp11;
#line 394
    __cil_tmp13 = WebPRescalerImport(& p->scaler_v, uv_mb_h - uv_j, io->v + uv_j * io->uv_stride,
                                     io->uv_stride);
#line 394
    v_lines_in = __cil_tmp13;
#line 399
    j += y_lines_in;
#line 400
    uv_j += u_lines_in;
#line 401
    __cil_tmp15 = ExportRGB(p, num_lines_out);
    }
#line 401
    num_lines_out += __cil_tmp15;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (num_lines_out);
}
}
#line 406 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int ExportAlpha(WebPDecParams *p , int y_pos ) 
{ 
  WebPRGBABuffer *buf ;
  uint8_t *base_rgba ;
  enum WEBP_CSP_MODE colorspace ;
  int alpha_first ;
  uint8_t *dst ;
  int tmp ;
  int num_lines_out ;
  int is_premult_alpha ;
  int __cil_tmp11 ;
  uint32_t alpha_mask ;
  int width ;
  int __cil_tmp14 ;
  int i ;
  int tmp___0 ;
  uint32_t alpha_value ;

  {
#line 407
  buf = & (p->output)->u.RGBA;
#line 408
  base_rgba = buf->rgba + (p->last_y + y_pos) * buf->stride;
#line 409
  colorspace = (p->output)->colorspace;
#line 410
  alpha_first = (unsigned int )colorspace == 4U || (unsigned int )colorspace == 9U;
#line 412
  if (alpha_first) {
#line 412
    tmp = 0;
  } else {
#line 412
    tmp = 3;
  }
  {
#line 412
  dst = base_rgba + tmp;
#line 413
  num_lines_out = 0;
#line 414
  __cil_tmp11 = WebPIsPremultipliedMode___0(colorspace);
#line 414
  is_premult_alpha = __cil_tmp11;
#line 415
  alpha_mask = (uint32_t )255;
#line 416
  width = p->scaler_a.dst_width;
  }
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 418
    __cil_tmp14 = WebPRescalerHasPendingOutput(& p->scaler_a);
    }
#line 418
    if (! __cil_tmp14) {
#line 418
      goto while_break;
    }
    {
#line 421
    WebPRescalerExportRow(& p->scaler_a);
#line 422
    i = 0;
    }
    {
#line 422
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 422
      if (! (i < width)) {
#line 422
        goto while_break___0;
      }
#line 423
      alpha_value = (uint32_t )*(p->scaler_a.dst + i);
#line 424
      *(dst + 4 * i) = (uint8_t )alpha_value;
#line 425
      alpha_mask &= alpha_value;
#line 422
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 427
    dst += buf->stride;
#line 428
    num_lines_out ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (is_premult_alpha) {
#line 430
    if (alpha_mask != 255U) {
      {
#line 431
      (*WebPApplyAlphaMultiply)(base_rgba, alpha_first, width, num_lines_out, buf->stride);
      }
    }
  }
#line 434
  return (num_lines_out);
}
}
#line 437 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int ExportAlphaRGBA4444(WebPDecParams *p , int y_pos ) 
{ 
  WebPRGBABuffer *buf ;
  uint8_t *base_rgba ;
  uint8_t *alpha_dst ;
  int num_lines_out ;
  enum WEBP_CSP_MODE colorspace ;
  int width ;
  int is_premult_alpha ;
  int __cil_tmp10 ;
  uint32_t alpha_mask ;
  int __cil_tmp12 ;
  int i ;
  int tmp ;
  uint32_t alpha_value ;

  {
  {
#line 438
  buf = & (p->output)->u.RGBA;
#line 439
  base_rgba = buf->rgba + (p->last_y + y_pos) * buf->stride;
#line 440
  alpha_dst = base_rgba + 1;
#line 441
  num_lines_out = 0;
#line 442
  colorspace = (p->output)->colorspace;
#line 443
  width = p->scaler_a.dst_width;
#line 444
  __cil_tmp10 = WebPIsPremultipliedMode___0(colorspace);
#line 444
  is_premult_alpha = __cil_tmp10;
#line 445
  alpha_mask = (uint32_t )15;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 447
    __cil_tmp12 = WebPRescalerHasPendingOutput(& p->scaler_a);
    }
#line 447
    if (! __cil_tmp12) {
#line 447
      goto while_break;
    }
    {
#line 450
    WebPRescalerExportRow(& p->scaler_a);
#line 451
    i = 0;
    }
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 451
      if (! (i < width)) {
#line 451
        goto while_break___0;
      }
#line 453
      alpha_value = (uint32_t )((int )*(p->scaler_a.dst + i) >> 4);
#line 454
      *(alpha_dst + 2 * i) = (uint8_t )((unsigned int )((int )*(alpha_dst + 2 * i) & 240) | alpha_value);
#line 455
      alpha_mask &= alpha_value;
#line 451
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 457
    alpha_dst += buf->stride;
#line 458
    num_lines_out ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  if (is_premult_alpha) {
#line 460
    if (alpha_mask != 15U) {
      {
#line 461
      (*WebPApplyAlphaMultiply4444)(base_rgba, width, num_lines_out, buf->stride);
      }
    }
  }
#line 463
  return (num_lines_out);
}
}
#line 466 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int EmitRescaledAlphaRGB(VP8Io *io , WebPDecParams *p ) 
{ 
  WebPRescaler *scaler ;
  int j ;
  int pos ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 467
  if (io->a != (void *)0) {
#line 468
    scaler = & p->scaler_a;
#line 469
    j = 0;
#line 470
    pos = 0;
    {
#line 471
    while (1) {
      while_continue: /* CIL Label */ ;
#line 471
      if (! (j < io->mb_h)) {
#line 471
        goto while_break;
      }
      {
#line 472
      __cil_tmp6 = WebPRescalerImport(scaler, io->mb_h - j, io->a + j * io->width,
                                      io->width);
      }
      {
#line 472
      j += __cil_tmp6;
#line 474
      __cil_tmp7 = (*(p->emit_alpha_row))(p, pos);
      }
#line 474
      pos += __cil_tmp7;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 477
  return (0);
}
}
#line 480 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int InitRGBRescaler(VP8Io *io , WebPDecParams *p ) 
{ 
  int has_alpha ;
  int __cil_tmp4 ;
  int out_width ;
  int out_height ;
  int uv_in_width ;
  int uv_in_height ;
  size_t work_size ;
  int32_t *work ;
  uint8_t *tmp ;
  size_t tmp_size1 ;
  size_t tmp_size2 ;
  void *__cil_tmp14 ;

  {
  {
#line 481
  __cil_tmp4 = WebPIsAlphaMode___0((p->output)->colorspace);
#line 481
  has_alpha = __cil_tmp4;
#line 482
  out_width = io->scaled_width;
#line 483
  out_height = io->scaled_height;
#line 484
  uv_in_width = (io->mb_w + 1) >> 1;
#line 485
  uv_in_height = (io->mb_h + 1) >> 1;
#line 486
  work_size = (size_t )(2 * out_width);
#line 491
  tmp_size1 = 3UL * work_size;
#line 492
  tmp_size2 = (size_t )(3 * out_width);
  }
#line 493
  if (has_alpha) {
#line 494
    tmp_size1 += work_size;
#line 495
    tmp_size2 += (unsigned long )out_width;
  }
  {
#line 497
  p->memory = calloc((unsigned long )1, tmp_size1 * sizeof(*work) + tmp_size2 * sizeof(*tmp));
  }
#line 498
  if (p->memory == (void *)0) {
#line 499
    return (0);
  }
  {
#line 501
  work = (int32_t *)p->memory;
#line 502
  tmp = (uint8_t *)(work + tmp_size1);
#line 503
  WebPRescalerInit(& p->scaler_y, io->mb_w, io->mb_h, tmp + 0, out_width, out_height,
                   0, 1, io->mb_w, out_width, io->mb_h, out_height, work + 0UL);
#line 507
  WebPRescalerInit(& p->scaler_u, uv_in_width, uv_in_height, tmp + out_width, out_width,
                   out_height, 0, 1, io->mb_w, 2 * out_width, io->mb_h, 2 * out_height,
                   work + work_size);
#line 511
  WebPRescalerInit(& p->scaler_v, uv_in_width, uv_in_height, tmp + 2 * out_width,
                   out_width, out_height, 0, 1, io->mb_w, 2 * out_width, io->mb_h,
                   2 * out_height, work + 2UL * work_size);
#line 515
  p->emit = & EmitRescaledRGB;
  }
#line 517
  if (has_alpha) {
    {
#line 518
    WebPRescalerInit(& p->scaler_a, io->mb_w, io->mb_h, tmp + 3 * out_width, out_width,
                     out_height, 0, 1, io->mb_w, out_width, io->mb_h, out_height,
                     work + 3UL * work_size);
#line 522
    p->emit_alpha = & EmitRescaledAlphaRGB;
    }
#line 523
    if ((unsigned int )(p->output)->colorspace == 5U) {
#line 525
      p->emit_alpha_row = & ExportAlphaRGBA4444;
    } else
#line 523
    if ((unsigned int )(p->output)->colorspace == 10U) {
#line 525
      p->emit_alpha_row = & ExportAlphaRGBA4444;
    } else {
#line 527
      p->emit_alpha_row = & ExportAlpha;
    }
  }
#line 530
  return (1);
}
}
#line 536 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int CustomSetup(VP8Io *io ) 
{ 
  WebPDecParams *p ;
  enum WEBP_CSP_MODE colorspace ;
  int is_rgb ;
  int __cil_tmp5 ;
  int is_alpha ;
  int __cil_tmp7 ;
  int tmp ;
  int __cil_tmp9 ;
  int ok ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int tmp___0 ;
  int uv_width ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  int (*tmp___1)(VP8Io * const  io , WebPDecParams * const  p ) ;
  int (*tmp___2)(VP8Io * const  io , WebPDecParams * const  p ) ;

  {
  {
#line 537
  p = (WebPDecParams *)io->opaque;
#line 538
  colorspace = (p->output)->colorspace;
#line 539
  __cil_tmp5 = WebPIsRGBMode___0(colorspace);
#line 539
  is_rgb = __cil_tmp5;
#line 540
  __cil_tmp7 = WebPIsAlphaMode___0(colorspace);
#line 540
  is_alpha = __cil_tmp7;
#line 542
  p->memory = (void *)0;
#line 543
  p->emit = (OutputFunc )((void *)0);
#line 544
  p->emit_alpha = (OutputFunc )((void *)0);
#line 545
  p->emit_alpha_row = (OutputRowFunc )((void *)0);
  }
#line 546
  if (is_alpha) {
#line 546
    tmp = 11;
  } else {
#line 546
    tmp = 12;
  }
  {
#line 546
  __cil_tmp9 = WebPIoInitFromOptions(p->options, io, (enum WEBP_CSP_MODE )tmp);
  }
#line 546
  if (! __cil_tmp9) {
#line 547
    return (0);
  }
#line 550
  if (io->use_scaling) {
#line 551
    if (is_rgb) {
      {
#line 551
      __cil_tmp11 = InitRGBRescaler(io, p);
#line 551
      tmp___0 = __cil_tmp11;
      }
    } else {
      {
#line 551
      __cil_tmp12 = InitYUVRescaler(io, p);
#line 551
      tmp___0 = __cil_tmp12;
      }
    }
#line 551
    ok = tmp___0;
#line 552
    if (! ok) {
#line 553
      return (0);
    }
  } else {
#line 556
    if (is_rgb) {
#line 557
      p->emit = & EmitSampledRGB;
#line 559
      if (io->fancy_upsampling) {
        {
#line 560
        uv_width = (io->mb_w + 1) >> 1;
#line 561
        p->memory = malloc((unsigned long )(io->mb_w + 2 * uv_width));
        }
#line 562
        if (p->memory == (void *)0) {
#line 563
          return (0);
        }
        {
#line 565
        p->tmp_y = (uint8_t *)p->memory;
#line 566
        p->tmp_u = p->tmp_y + io->mb_w;
#line 567
        p->tmp_v = p->tmp_u + uv_width;
#line 568
        p->emit = & EmitFancyRGB;
#line 569
        WebPInitUpsamplers();
        }
      }
    } else {
#line 573
      p->emit = & EmitYUV;
    }
#line 575
    if (is_alpha) {
      {
#line 576
      __cil_tmp16 = WebPIsPremultipliedMode___0(colorspace);
      }
#line 576
      if (__cil_tmp16) {
        {
#line 576
        WebPInitPremultiply();
        }
      }
#line 577
      if ((unsigned int )colorspace == 5U || (unsigned int )colorspace == 10U) {
#line 577
        tmp___2 = & EmitAlphaRGBA4444;
      } else {
#line 577
        if (is_rgb) {
#line 577
          tmp___1 = & EmitAlphaRGB;
        } else {
#line 577
          tmp___1 = & EmitAlphaYUV;
        }
#line 577
        tmp___2 = tmp___1;
      }
#line 577
      p->emit_alpha = tmp___2;
    }
  }
#line 585
  if (is_rgb) {
    {
#line 586
    VP8YUVInit();
    }
  }
#line 588
  return (1);
}
}
#line 593 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static int CustomPut(VP8Io *io ) 
{ 
  WebPDecParams *p ;
  int mb_w ;
  int mb_h ;
  int num_lines_out ;
  int tmp ;
  int __cil_tmp7 ;

  {
#line 594
  p = (WebPDecParams *)io->opaque;
#line 595
  mb_w = io->mb_w;
#line 596
  mb_h = io->mb_h;
#line 600
  if (mb_w <= 0) {
#line 601
    return (0);
  } else
#line 600
  if (mb_h <= 0) {
#line 601
    return (0);
  }
  {
#line 603
  num_lines_out = (*(p->emit))(io, p);
  }
#line 604
  if (p->emit_alpha) {
    {
#line 605
    (*(p->emit_alpha))(io, p);
    }
  }
#line 607
  p->last_y += num_lines_out;
#line 608
  return (1);
}
}
#line 613 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
static void CustomTeardown(VP8Io *io ) 
{ 
  WebPDecParams *p ;

  {
  {
#line 614
  p = (WebPDecParams *)io->opaque;
#line 615
  free(p->memory);
#line 616
  p->memory = (void *)0;
  }
  return;
}
}
#line 622 "/doner/libwebp/libwebp-v0.3.0/src/dec/io.c"
void WebPInitCustomIo(WebPDecParams *params , VP8Io *io ) 
{ 


  {
#line 623
  io->put = & CustomPut;
#line 624
  io->setup = & CustomSetup;
#line 625
  io->teardown = & CustomTeardown;
#line 626
  io->opaque = params;
  return;
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
static uint32_t kHashMul___10  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___10(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___10 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___10(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___10 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheContains___10(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___10 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 89 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static void RemapBitReader(VP8BitReader *br , ptrdiff_t offset ) 
{ 


  {
#line 90
  if (br->buf_ != (void *)0) {
#line 91
    br->buf_ += offset;
#line 92
    br->buf_end_ += offset;
  }
  return;
}
}
#line 96 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
__inline static size_t MemDataSize(MemBuffer *mem ) 
{ 


  {
#line 97
  return (mem->end_ - mem->start_);
}
}
#line 100 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static void DoRemap(WebPIDecoder *idec , ptrdiff_t offset ) 
{ 
  MemBuffer *mem ;
  uint8_t *new_base ;
  size_t __cil_tmp5 ;
  VP8Decoder *dec ;
  int last_part ;
  int p ;
  int tmp ;
  VP8LDecoder *dec___0 ;
  size_t __cil_tmp11 ;

  {
  {
#line 101
  mem = & idec->mem_;
#line 102
  new_base = mem->buf_ + mem->start_;
#line 105
  idec->io_.data = new_base;
#line 106
  idec->io_.data_size = MemDataSize(mem);
  }
#line 108
  if (idec->dec_ != (void *)0) {
#line 109
    if (! idec->is_lossless_) {
#line 110
      dec = (VP8Decoder *)idec->dec_;
#line 111
      last_part = dec->num_parts_ - 1;
#line 112
      if (offset != 0L) {
#line 114
        p = 0;
        {
#line 114
        while (1) {
          while_continue: /* CIL Label */ ;
#line 114
          if (! (p <= last_part)) {
#line 114
            goto while_break;
          }
          {
#line 115
          RemapBitReader((VP8BitReader *)dec->parts_ + p, offset);
          }
#line 114
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 119
        if ((unsigned int )mem->mode_ == 2U) {
          {
#line 120
          RemapBitReader(& dec->br_, offset);
          }
        }
      }
#line 124
      dec->parts_[last_part].buf_end_ = mem->buf_ + mem->end_;
    } else {
      {
#line 126
      dec___0 = (VP8LDecoder *)idec->dec_;
#line 127
      __cil_tmp11 = MemDataSize(mem);
#line 127
      VP8LBitReaderSetBuffer(& dec___0->br_, new_base, __cil_tmp11);
      }
    }
  }
  return;
}
}
#line 134 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static int AppendToMemBuffer(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  MemBuffer *mem ;
  uint8_t *old_base ;
  int tmp ;
  size_t current_size ;
  size_t __cil_tmp8 ;
  uint64_t new_size ;
  uint64_t extra_size ;
  uint8_t *new_buf ;
  void *__cil_tmp12 ;
  int tmp___0 ;

  {
#line 136
  mem = & idec->mem_;
#line 137
  old_base = mem->buf_ + mem->start_;
#line 139
  if (data_size > 4294967286UL) {
#line 142
    return (0);
  }
#line 145
  if (mem->end_ + data_size > mem->buf_size_) {
    {
#line 146
    __cil_tmp8 = MemDataSize(mem);
#line 146
    current_size = __cil_tmp8;
#line 147
    new_size = (uint64_t )current_size + data_size;
#line 148
    extra_size = ((new_size + 4096UL) - 1UL) & 0xfffffffffffff000UL;
#line 149
    __cil_tmp12 = WebPSafeMalloc(extra_size, sizeof(*new_buf));
#line 149
    new_buf = (uint8_t *)__cil_tmp12;
    }
#line 151
    if (new_buf == (void *)0) {
#line 151
      return (0);
    }
    {
#line 152
    memcpy(new_buf, old_base, current_size);
#line 153
    free(mem->buf_);
#line 154
    mem->buf_ = new_buf;
#line 155
    mem->buf_size_ = (size_t )extra_size;
#line 156
    mem->start_ = (size_t )0;
#line 157
    mem->end_ = current_size;
    }
  }
  {
#line 160
  memcpy(mem->buf_ + mem->end_, data, data_size);
#line 161
  mem->end_ += data_size;
#line 164
  DoRemap(idec, (mem->buf_ + mem->start_) - old_base);
  }
#line 165
  return (1);
}
}
#line 168 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static int RemapMemBuffer(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  MemBuffer *mem ;
  uint8_t *old_base ;
  int tmp ;

  {
#line 170
  mem = & idec->mem_;
#line 171
  old_base = mem->buf_ + mem->start_;
#line 174
  if (data_size < mem->buf_size_) {
#line 174
    return (0);
  }
  {
#line 176
  mem->buf_ = (uint8_t *)data;
#line 177
  mem->buf_size_ = data_size;
#line 177
  mem->end_ = mem->buf_size_;
#line 179
  DoRemap(idec, (mem->buf_ + mem->start_) - old_base);
  }
#line 180
  return (1);
}
}
#line 183 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static void InitMemBuffer(MemBuffer *mem ) 
{ 


  {
#line 184
  mem->mode_ = (MemBufferMode )0;
#line 185
  mem->buf_ = (uint8_t *)((void *)0);
#line 186
  mem->buf_size_ = (size_t )0;
#line 187
  mem->part0_buf_ = (uint8_t *)((void *)0);
#line 188
  mem->part0_size_ = (size_t )0;
  return;
}
}
#line 191 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static void ClearMemBuffer(MemBuffer *mem ) 
{ 
  int tmp ;

  {
#line 193
  if ((unsigned int )mem->mode_ == 1U) {
    {
#line 194
    free(mem->buf_);
#line 195
    free((void *)mem->part0_buf_);
    }
  }
  return;
}
}
#line 199 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static int CheckMemBufferMode(MemBuffer *mem , MemBufferMode expected ) 
{ 
  int tmp ;

  {
#line 200
  if ((unsigned int )mem->mode_ == 0U) {
#line 201
    mem->mode_ = expected;
  } else
#line 202
  if ((unsigned int )mem->mode_ != (unsigned int )expected) {
#line 203
    return (0);
  }
#line 206
  return (1);
}
}
#line 212 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static void SaveContext(VP8Decoder *dec , VP8BitReader *token_br , MBContext *context ) 
{ 
  VP8BitReader *br ;
  VP8MB *left ;
  VP8MB *info ;

  {
  {
#line 214
  br = & dec->br_;
#line 215
  left = dec->mb_info_ - 1;
#line 216
  info = dec->mb_info_ + dec->mb_x_;
#line 218
  context->left_ = *left;
#line 219
  context->info_ = *info;
#line 220
  context->br_ = *br;
#line 221
  context->token_br_ = *token_br;
#line 222
  memcpy((uint8_t *)context->intra_t_, dec->intra_t_ + 4 * dec->mb_x_, (unsigned long )4);
#line 223
  memcpy((uint8_t *)context->intra_l_, (uint8_t *)dec->intra_l_, (unsigned long )4);
  }
  return;
}
}
#line 226 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static void RestoreContext(MBContext *context , VP8Decoder *dec , VP8BitReader *token_br ) 
{ 
  VP8BitReader *br ;
  VP8MB *left ;
  VP8MB *info ;

  {
  {
#line 228
  br = & dec->br_;
#line 229
  left = dec->mb_info_ - 1;
#line 230
  info = dec->mb_info_ + dec->mb_x_;
#line 232
  *left = context->left_;
#line 233
  *info = context->info_;
#line 234
  *br = context->br_;
#line 235
  *token_br = context->token_br_;
#line 236
  memcpy(dec->intra_t_ + 4 * dec->mb_x_, (uint8_t *)context->intra_t_, (unsigned long )4);
#line 237
  memcpy((uint8_t *)dec->intra_l_, (uint8_t *)context->intra_l_, (unsigned long )4);
  }
  return;
}
}
#line 242 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static enum VP8StatusCode IDecError(WebPIDecoder *idec , enum VP8StatusCode error ) 
{ 
  VP8Io *io ;

  {
#line 243
  if ((unsigned int )idec->state_ == 3U) {
#line 244
    io = & idec->io_;
#line 245
    if (io->teardown) {
      {
#line 246
      (*(io->teardown))(io);
      }
    }
  }
#line 249
  idec->state_ = (DecState )7;
#line 250
  return (error);
}
}
#line 253 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static void ChangeState(WebPIDecoder *idec , DecState new_state , size_t consumed_bytes ) 
{ 
  MemBuffer *mem ;
  int tmp ;
  size_t __cil_tmp6 ;

  {
  {
#line 255
  mem = & idec->mem_;
#line 256
  idec->state_ = new_state;
#line 257
  mem->start_ += consumed_bytes;
#line 259
  idec->io_.data = mem->buf_ + mem->start_;
#line 260
  idec->io_.data_size = MemDataSize(mem);
  }
  return;
}
}
#line 264 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static enum VP8StatusCode DecodeWebPHeaders(WebPIDecoder *idec ) 
{ 
  MemBuffer *mem ;
  uint8_t *data ;
  size_t curr_size ;
  size_t __cil_tmp5 ;
  enum VP8StatusCode status ;
  WebPHeaderStructure headers ;
  enum VP8StatusCode __cil_tmp8 ;
  enum VP8StatusCode __cil_tmp9 ;
  VP8Decoder *dec ;
  VP8Decoder *__cil_tmp11 ;
  VP8LDecoder *dec___0 ;
  VP8LDecoder *__cil_tmp13 ;

  {
  {
#line 265
  mem = & idec->mem_;
#line 266
  data = mem->buf_ + mem->start_;
#line 267
  __cil_tmp5 = MemDataSize(mem);
#line 267
  curr_size = __cil_tmp5;
#line 271
  headers.data = data;
#line 272
  headers.data_size = curr_size;
#line 273
  status = WebPParseHeaders(& headers);
  }
#line 274
  if ((unsigned int )status == 7U) {
#line 275
    return ((enum VP8StatusCode )5);
  } else
#line 276
  if ((unsigned int )status != 0U) {
    {
#line 277
    __cil_tmp9 = IDecError(idec, status);
    }
#line 277
    return (__cil_tmp9);
  }
#line 280
  idec->chunk_size_ = headers.compressed_size;
#line 281
  idec->is_lossless_ = headers.is_lossless;
#line 282
  if (! idec->is_lossless_) {
    {
#line 283
    __cil_tmp11 = VP8New();
#line 283
    dec = __cil_tmp11;
    }
#line 284
    if (dec == (void *)0) {
#line 285
      return ((enum VP8StatusCode )1);
    }
    {
#line 287
    idec->dec_ = dec;
#line 289
    dec->use_threads_ = idec->params_.options != (void *)0 && (idec->params_.options)->use_threads > 0;
#line 294
    dec->alpha_data_ = headers.alpha_data;
#line 295
    dec->alpha_data_size_ = headers.alpha_data_size;
#line 296
    ChangeState(idec, (DecState )1, headers.offset);
    }
  } else {
    {
#line 298
    __cil_tmp13 = VP8LNew();
#line 298
    dec___0 = __cil_tmp13;
    }
#line 299
    if (dec___0 == (void *)0) {
#line 300
      return ((enum VP8StatusCode )1);
    }
    {
#line 302
    idec->dec_ = dec___0;
#line 303
    ChangeState(idec, (DecState )4, headers.offset);
    }
  }
#line 305
  return ((enum VP8StatusCode )0);
}
}
#line 308 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static enum VP8StatusCode DecodeVP8FrameHeader(WebPIDecoder *idec ) 
{ 
  uint8_t *data ;
  size_t curr_size ;
  size_t __cil_tmp4 ;
  uint32_t bits ;
  int __cil_tmp6 ;
  enum VP8StatusCode __cil_tmp7 ;

  {
  {
#line 309
  data = idec->mem_.buf_ + idec->mem_.start_;
#line 310
  __cil_tmp4 = MemDataSize(& idec->mem_);
#line 310
  curr_size = __cil_tmp4;
  }
#line 313
  if (curr_size < 10UL) {
#line 315
    return ((enum VP8StatusCode )5);
  }
  {
#line 317
  __cil_tmp6 = VP8GetInfo(data, curr_size, idec->chunk_size_, (int *)((void *)0),
                          (int *)((void *)0));
  }
#line 317
  if (! __cil_tmp6) {
    {
#line 318
    __cil_tmp7 = IDecError(idec, (enum VP8StatusCode )3);
    }
#line 318
    return (__cil_tmp7);
  }
#line 321
  bits = (uint32_t )(((int )*(data + 0) | ((int )*(data + 1) << 8)) | ((int )*(data + 2) << 16));
#line 322
  idec->mem_.part0_size_ = (size_t )((bits >> 5) + 10U);
#line 324
  idec->io_.data = data;
#line 325
  idec->io_.data_size = curr_size;
#line 326
  idec->state_ = (DecState )2;
#line 327
  return ((enum VP8StatusCode )0);
}
}
#line 331 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static int CopyParts0Data(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  VP8BitReader *br ;
  size_t psize ;
  MemBuffer *mem ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint8_t *part0_buf ;
  void *__cil_tmp11 ;

  {
#line 332
  dec = (VP8Decoder *)idec->dec_;
#line 333
  br = & dec->br_;
#line 334
  psize = (size_t )(br->buf_end_ - br->buf_);
#line 335
  mem = & idec->mem_;
#line 340
  if ((unsigned int )mem->mode_ == 1U) {
    {
#line 342
    __cil_tmp11 = malloc(psize);
#line 342
    part0_buf = (uint8_t *)__cil_tmp11;
    }
#line 343
    if (part0_buf == (void *)0) {
#line 344
      return (0);
    }
    {
#line 346
    memcpy(part0_buf, br->buf_, psize);
#line 347
    mem->part0_buf_ = part0_buf;
#line 348
    br->buf_ = part0_buf;
#line 349
    br->buf_end_ = part0_buf + psize;
    }
  }
#line 353
  mem->start_ += psize;
#line 354
  return (1);
}
}
#line 357 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static enum VP8StatusCode DecodePartition0(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  VP8Io *io ;
  WebPDecParams *params ;
  WebPDecBuffer *output ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  enum VP8StatusCode status ;
  enum VP8StatusCode __cil_tmp9 ;
  enum VP8StatusCode __cil_tmp10 ;
  enum VP8StatusCode __cil_tmp11 ;
  int __cil_tmp12 ;
  enum VP8StatusCode __cil_tmp13 ;
  enum VP8StatusCode __cil_tmp14 ;
  enum VP8StatusCode __cil_tmp15 ;
  int __cil_tmp16 ;
  enum VP8StatusCode __cil_tmp17 ;

  {
  {
#line 358
  dec = (VP8Decoder *)idec->dec_;
#line 359
  io = & idec->io_;
#line 360
  params = & idec->params_;
#line 361
  output = params->output;
#line 364
  __cil_tmp6 = MemDataSize(& idec->mem_);
  }
#line 364
  if (__cil_tmp6 < idec->mem_.part0_size_) {
#line 365
    return ((enum VP8StatusCode )5);
  }
  {
#line 368
  __cil_tmp7 = VP8GetHeaders(dec, io);
  }
#line 368
  if (! __cil_tmp7) {
#line 369
    status = dec->status_;
#line 370
    if ((unsigned int )status == 5U) {
#line 373
      return ((enum VP8StatusCode )5);
    } else
#line 370
    if ((unsigned int )status == 7U) {
#line 373
      return ((enum VP8StatusCode )5);
    }
    {
#line 375
    __cil_tmp9 = IDecError(idec, status);
    }
#line 375
    return (__cil_tmp9);
  }
  {
#line 379
  dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options, output);
  }
#line 381
  if ((unsigned int )dec->status_ != 0U) {
    {
#line 382
    __cil_tmp11 = IDecError(idec, dec->status_);
    }
#line 382
    return (__cil_tmp11);
  }
  {
#line 385
  __cil_tmp12 = CopyParts0Data(idec);
  }
#line 385
  if (! __cil_tmp12) {
    {
#line 386
    __cil_tmp13 = IDecError(idec, (enum VP8StatusCode )1);
    }
#line 386
    return (__cil_tmp13);
  }
  {
#line 390
  __cil_tmp14 = VP8EnterCritical(dec, io);
  }
#line 390
  if ((unsigned int )__cil_tmp14 != 0U) {
    {
#line 391
    __cil_tmp15 = IDecError(idec, dec->status_);
    }
#line 391
    return (__cil_tmp15);
  }
  {
#line 396
  idec->state_ = (DecState )3;
#line 398
  __cil_tmp16 = VP8InitFrame(dec, io);
  }
#line 398
  if (! __cil_tmp16) {
    {
#line 399
    __cil_tmp17 = IDecError(idec, dec->status_);
    }
#line 399
    return (__cil_tmp17);
  }
#line 401
  return ((enum VP8StatusCode )0);
}
}
#line 405 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static enum VP8StatusCode DecodeRemaining(WebPIDecoder *idec ) 
{ 
  VP8Decoder *dec ;
  VP8Io *io ;
  int tmp ;
  VP8BitReader *token_br ;
  MBContext context ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  enum VP8StatusCode __cil_tmp9 ;
  int tmp___0 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  enum VP8StatusCode __cil_tmp13 ;
  int __cil_tmp14 ;
  enum VP8StatusCode __cil_tmp15 ;

  {
#line 406
  dec = (VP8Decoder *)idec->dec_;
#line 407
  io = & idec->io_;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (dec->mb_y_ < dec->mb_h_)) {
#line 411
      goto while_break;
    }
#line 412
    token_br = & dec->parts_[dec->mb_y_ & (dec->num_parts_ - 1)];
#line 413
    if (dec->mb_x_ == 0) {
      {
#line 414
      VP8InitScanline(dec);
      }
    }
    {
#line 416
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 416
      if (! (dec->mb_x_ < dec->mb_w_)) {
#line 416
        goto while_break___0;
      }
      {
#line 418
      SaveContext(dec, token_br, & context);
#line 420
      __cil_tmp7 = VP8DecodeMB(dec, token_br);
      }
#line 420
      if (! __cil_tmp7) {
        {
#line 421
        RestoreContext(& context, dec, token_br);
#line 423
        __cil_tmp8 = MemDataSize(& idec->mem_);
        }
#line 423
        if (dec->num_parts_ == 1) {
#line 423
          if (__cil_tmp8 > 4096UL) {
            {
#line 424
            __cil_tmp9 = IDecError(idec, (enum VP8StatusCode )3);
            }
#line 424
            return (__cil_tmp9);
          }
        }
#line 426
        return ((enum VP8StatusCode )5);
      }
      {
#line 429
      VP8ReconstructBlock(dec);
      }
#line 432
      if (dec->num_parts_ == 1) {
#line 433
        idec->mem_.start_ = (size_t )(token_br->buf_ - idec->mem_.buf_);
      }
#line 416
      (dec->mb_x_) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 437
    __cil_tmp12 = VP8ProcessRow(dec, io);
    }
#line 437
    if (! __cil_tmp12) {
      {
#line 438
      __cil_tmp13 = IDecError(idec, (enum VP8StatusCode )6);
      }
#line 438
      return (__cil_tmp13);
    }
#line 440
    dec->mb_x_ = 0;
#line 411
    (dec->mb_y_) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 443
  __cil_tmp14 = VP8ExitCritical(dec, io);
  }
#line 443
  if (! __cil_tmp14) {
    {
#line 444
    __cil_tmp15 = IDecError(idec, (enum VP8StatusCode )6);
    }
#line 444
    return (__cil_tmp15);
  }
#line 446
  dec->ready_ = 0;
#line 447
  idec->state_ = (DecState )6;
#line 449
  return ((enum VP8StatusCode )0);
}
}
#line 452 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static int ErrorStatusLossless(WebPIDecoder *idec , enum VP8StatusCode status ) 
{ 
  enum VP8StatusCode __cil_tmp3 ;

  {
#line 453
  if ((unsigned int )status == 5U) {
#line 454
    return (5);
  } else
#line 453
  if ((unsigned int )status == 7U) {
#line 454
    return (5);
  }
  {
#line 456
  __cil_tmp3 = IDecError(idec, status);
  }
#line 456
  return ((int )__cil_tmp3);
}
}
#line 459 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static enum VP8StatusCode DecodeVP8LHeader(WebPIDecoder *idec ) 
{ 
  VP8Io *io ;
  VP8LDecoder *dec ;
  WebPDecParams *params ;
  WebPDecBuffer *output ;
  size_t curr_size ;
  size_t __cil_tmp7 ;
  int tmp ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  enum VP8StatusCode __cil_tmp11 ;
  enum VP8StatusCode __cil_tmp12 ;

  {
  {
#line 460
  io = & idec->io_;
#line 461
  dec = (VP8LDecoder *)idec->dec_;
#line 462
  params = & idec->params_;
#line 463
  output = params->output;
#line 464
  __cil_tmp7 = MemDataSize(& idec->mem_);
#line 464
  curr_size = __cil_tmp7;
  }
#line 468
  if (curr_size < idec->chunk_size_ >> 3) {
#line 469
    return ((enum VP8StatusCode )5);
  }
  {
#line 471
  __cil_tmp9 = VP8LDecodeHeader(dec, io);
  }
#line 471
  if (! __cil_tmp9) {
    {
#line 472
    __cil_tmp10 = ErrorStatusLossless(idec, dec->status_);
    }
#line 472
    return ((enum VP8StatusCode )__cil_tmp10);
  }
  {
#line 475
  dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options, output);
  }
#line 477
  if ((unsigned int )dec->status_ != 0U) {
    {
#line 478
    __cil_tmp12 = IDecError(idec, dec->status_);
    }
#line 478
    return (__cil_tmp12);
  }
#line 481
  idec->state_ = (DecState )5;
#line 482
  return ((enum VP8StatusCode )0);
}
}
#line 485 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static enum VP8StatusCode DecodeVP8LData(WebPIDecoder *idec ) 
{ 
  VP8LDecoder *dec ;
  size_t curr_size ;
  size_t __cil_tmp4 ;
  int tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 486
  dec = (VP8LDecoder *)idec->dec_;
#line 487
  __cil_tmp4 = MemDataSize(& idec->mem_);
#line 487
  curr_size = __cil_tmp4;
  }
#line 492
  if (curr_size < idec->chunk_size_) {
#line 493
    return ((enum VP8StatusCode )5);
  }
  {
#line 496
  __cil_tmp6 = VP8LDecodeImage(dec);
  }
#line 496
  if (! __cil_tmp6) {
    {
#line 497
    __cil_tmp7 = ErrorStatusLossless(idec, dec->status_);
    }
#line 497
    return ((enum VP8StatusCode )__cil_tmp7);
  }
#line 500
  idec->state_ = (DecState )6;
#line 502
  return ((enum VP8StatusCode )0);
}
}
#line 506 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static enum VP8StatusCode IDecode(WebPIDecoder *idec ) 
{ 
  enum VP8StatusCode status ;
  enum VP8StatusCode __cil_tmp3 ;
  enum VP8StatusCode __cil_tmp4 ;
  enum VP8StatusCode __cil_tmp5 ;
  enum VP8StatusCode __cil_tmp6 ;
  enum VP8StatusCode __cil_tmp7 ;
  enum VP8StatusCode __cil_tmp8 ;

  {
#line 507
  status = (enum VP8StatusCode )5;
#line 509
  if ((unsigned int )idec->state_ == 0U) {
    {
#line 510
    status = DecodeWebPHeaders(idec);
    }
  } else
#line 512
  if (idec->dec_ == (void *)0) {
#line 513
    return ((enum VP8StatusCode )5);
  }
#line 516
  if ((unsigned int )idec->state_ == 1U) {
    {
#line 517
    status = DecodeVP8FrameHeader(idec);
    }
  }
#line 519
  if ((unsigned int )idec->state_ == 2U) {
    {
#line 520
    status = DecodePartition0(idec);
    }
  }
#line 522
  if ((unsigned int )idec->state_ == 3U) {
    {
#line 523
    status = DecodeRemaining(idec);
    }
  }
#line 525
  if ((unsigned int )idec->state_ == 4U) {
    {
#line 526
    status = DecodeVP8LHeader(idec);
    }
  }
#line 528
  if ((unsigned int )idec->state_ == 5U) {
    {
#line 529
    status = DecodeVP8LData(idec);
    }
  }
#line 531
  return (status);
}
}
#line 537 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
WebPIDecoder *WebPINewDecoder(WebPDecBuffer *output_buffer ) 
{ 
  WebPIDecoder *idec ;
  void *__cil_tmp3 ;
  WebPDecBuffer *tmp ;

  {
  {
#line 538
  __cil_tmp3 = calloc((unsigned long )1, sizeof(*idec));
#line 538
  idec = (WebPIDecoder *)__cil_tmp3;
  }
#line 539
  if (idec == (void *)0) {
#line 540
    return ((WebPIDecoder *)((void *)0));
  }
  {
#line 543
  idec->state_ = (DecState )0;
#line 544
  idec->chunk_size_ = (size_t )0;
#line 546
  InitMemBuffer(& idec->mem_);
#line 547
  WebPInitDecBuffer(& idec->output_);
#line 548
  VP8InitIo(& idec->io_);
#line 550
  WebPResetDecParams(& idec->params_);
  }
#line 551
  if (output_buffer) {
#line 551
    tmp = output_buffer;
  } else {
#line 551
    tmp = & idec->output_;
  }
  {
#line 551
  idec->params_.output = tmp;
#line 552
  WebPInitCustomIo(& idec->params_, & idec->io_);
  }
#line 554
  return (idec);
}
}
#line 557 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
WebPIDecoder *WebPIDecode(uint8_t *data , size_t data_size , WebPDecoderConfig *config ) 
{ 
  WebPIDecoder *idec ;
  enum VP8StatusCode __cil_tmp5 ;
  WebPDecBuffer *tmp ;
  WebPIDecoder *__cil_tmp7 ;

  {
#line 562
  if (data != (void *)0) {
#line 562
    if (data_size > 0UL) {
#line 562
      if (config != (void *)0) {
        {
#line 563
        __cil_tmp5 = WebPGetFeatures___0(data, data_size, & config->input);
        }
#line 563
        if ((unsigned int )__cil_tmp5 != 0U) {
#line 564
          return ((WebPIDecoder *)((void *)0));
        }
      }
    }
  }
#line 568
  if (config) {
#line 568
    tmp = & config->output;
  } else {
#line 568
    tmp = (WebPDecBuffer *)((void *)0);
  }
  {
#line 568
  __cil_tmp7 = WebPINewDecoder(tmp);
#line 568
  idec = __cil_tmp7;
  }
#line 569
  if (idec == (void *)0) {
#line 570
    return ((WebPIDecoder *)((void *)0));
  }
#line 573
  if (config != (void *)0) {
#line 574
    idec->params_.options = & config->options;
  }
#line 576
  return (idec);
}
}
#line 579 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
void WebPIDelete(WebPIDecoder *idec ) 
{ 


  {
#line 580
  if (idec == (void *)0) {
#line 580
    return;
  }
#line 581
  if (idec->dec_ != (void *)0) {
#line 582
    if (! idec->is_lossless_) {
      {
#line 583
      VP8Delete(idec->dec_);
      }
    } else {
      {
#line 585
      VP8LDelete(idec->dec_);
      }
    }
  }
  {
#line 588
  ClearMemBuffer(& idec->mem_);
#line 589
  WebPFreeDecBuffer(& idec->output_);
#line 590
  free(idec);
  }
  return;
}
}
#line 596 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
WebPIDecoder *WebPINewRGB(enum WEBP_CSP_MODE mode , uint8_t *output_buffer , size_t output_buffer_size ,
                          int output_stride ) 
{ 
  int is_external_memory ;
  WebPIDecoder *idec ;
  WebPIDecoder *__cil_tmp7 ;

  {
#line 598
  is_external_memory = output_buffer != (void *)0;
#line 601
  if ((unsigned int )mode >= 11U) {
#line 601
    return ((WebPIDecoder *)((void *)0));
  }
#line 602
  if (! is_external_memory) {
#line 603
    output_buffer_size = (size_t )0;
#line 604
    output_stride = 0;
  } else
#line 606
  if (output_stride == 0) {
#line 607
    return ((WebPIDecoder *)((void *)0));
  } else
#line 606
  if (output_buffer_size == 0UL) {
#line 607
    return ((WebPIDecoder *)((void *)0));
  }
  {
#line 610
  idec = WebPINewDecoder((WebPDecBuffer *)((void *)0));
  }
#line 611
  if (idec == (void *)0) {
#line 611
    return ((WebPIDecoder *)((void *)0));
  }
#line 612
  idec->output_.colorspace = mode;
#line 613
  idec->output_.is_external_memory = is_external_memory;
#line 614
  idec->output_.u.RGBA.rgba = output_buffer;
#line 615
  idec->output_.u.RGBA.stride = output_stride;
#line 616
  idec->output_.u.RGBA.size = output_buffer_size;
#line 617
  return (idec);
}
}
#line 620 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
WebPIDecoder *WebPINewYUVA(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                           size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                           int v_stride , uint8_t *a , size_t a_size , int a_stride ) 
{ 
  int is_external_memory ;
  WebPIDecoder *idec ;
  enum WEBP_CSP_MODE colorspace ;
  int tmp ;
  WebPIDecoder *__cil_tmp17 ;

  {
#line 624
  is_external_memory = luma != (void *)0;
#line 628
  if (! is_external_memory) {
#line 629
    a_size = (size_t )0;
#line 629
    v_size = a_size;
#line 629
    u_size = v_size;
#line 629
    luma_size = u_size;
#line 630
    a_stride = 0;
#line 630
    v_stride = a_stride;
#line 630
    u_stride = v_stride;
#line 630
    luma_stride = u_stride;
#line 631
    a = (uint8_t *)((void *)0);
#line 631
    v = a;
#line 631
    u = v;
#line 632
    colorspace = (enum WEBP_CSP_MODE )12;
  } else {
#line 634
    if (u == (void *)0) {
#line 634
      return ((WebPIDecoder *)((void *)0));
    } else
#line 634
    if (v == (void *)0) {
#line 634
      return ((WebPIDecoder *)((void *)0));
    }
#line 635
    if (luma_size == 0UL) {
#line 635
      return ((WebPIDecoder *)((void *)0));
    } else
#line 635
    if (u_size == 0UL) {
#line 635
      return ((WebPIDecoder *)((void *)0));
    } else
#line 635
    if (v_size == 0UL) {
#line 635
      return ((WebPIDecoder *)((void *)0));
    }
#line 636
    if (luma_stride == 0) {
#line 636
      return ((WebPIDecoder *)((void *)0));
    } else
#line 636
    if (u_stride == 0) {
#line 636
      return ((WebPIDecoder *)((void *)0));
    } else
#line 636
    if (v_stride == 0) {
#line 636
      return ((WebPIDecoder *)((void *)0));
    }
#line 637
    if (a != (void *)0) {
#line 638
      if (a_size == 0UL) {
#line 638
        return ((WebPIDecoder *)((void *)0));
      } else
#line 638
      if (a_stride == 0) {
#line 638
        return ((WebPIDecoder *)((void *)0));
      }
    }
#line 640
    if (a == (void *)0) {
#line 640
      tmp = 11;
    } else {
#line 640
      tmp = 12;
    }
#line 640
    colorspace = (enum WEBP_CSP_MODE )tmp;
  }
  {
#line 643
  idec = WebPINewDecoder((WebPDecBuffer *)((void *)0));
  }
#line 644
  if (idec == (void *)0) {
#line 644
    return ((WebPIDecoder *)((void *)0));
  }
#line 646
  idec->output_.colorspace = colorspace;
#line 647
  idec->output_.is_external_memory = is_external_memory;
#line 648
  idec->output_.u.YUVA.y = luma;
#line 649
  idec->output_.u.YUVA.y_stride = luma_stride;
#line 650
  idec->output_.u.YUVA.y_size = luma_size;
#line 651
  idec->output_.u.YUVA.u = u;
#line 652
  idec->output_.u.YUVA.u_stride = u_stride;
#line 653
  idec->output_.u.YUVA.u_size = u_size;
#line 654
  idec->output_.u.YUVA.v = v;
#line 655
  idec->output_.u.YUVA.v_stride = v_stride;
#line 656
  idec->output_.u.YUVA.v_size = v_size;
#line 657
  idec->output_.u.YUVA.a = a;
#line 658
  idec->output_.u.YUVA.a_stride = a_stride;
#line 659
  idec->output_.u.YUVA.a_size = a_size;
#line 660
  return (idec);
}
}
#line 663 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
WebPIDecoder *WebPINewYUV(uint8_t *luma , size_t luma_size , int luma_stride , uint8_t *u ,
                          size_t u_size , int u_stride , uint8_t *v , size_t v_size ,
                          int v_stride ) 
{ 
  WebPIDecoder *__cil_tmp10 ;

  {
  {
#line 666
  __cil_tmp10 = WebPINewYUVA(luma, luma_size, luma_stride, u, u_size, u_stride, v,
                             v_size, v_stride, (uint8_t *)((void *)0), (size_t )0,
                             0);
  }
#line 666
  return (__cil_tmp10);
}
}
#line 674 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static enum VP8StatusCode IDecCheckStatus(WebPIDecoder *idec ) 
{ 
  int tmp ;

  {
#line 676
  if ((unsigned int )idec->state_ == 7U) {
#line 677
    return ((enum VP8StatusCode )3);
  }
#line 679
  if ((unsigned int )idec->state_ == 6U) {
#line 680
    return ((enum VP8StatusCode )0);
  }
#line 682
  return ((enum VP8StatusCode )5);
}
}
#line 685 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
enum VP8StatusCode___0 WebPIAppend(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  enum VP8StatusCode status ;
  enum VP8StatusCode __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  enum VP8StatusCode __cil_tmp8 ;

  {
#line 688
  if (idec == (void *)0) {
#line 689
    return ((enum VP8StatusCode )2);
  } else
#line 688
  if (data == (void *)0) {
#line 689
    return ((enum VP8StatusCode )2);
  }
  {
#line 691
  status = IDecCheckStatus(idec);
  }
#line 692
  if ((unsigned int )status != 5U) {
#line 693
    return (status);
  }
  {
#line 696
  __cil_tmp6 = CheckMemBufferMode(& idec->mem_, (MemBufferMode )1);
  }
#line 696
  if (! __cil_tmp6) {
#line 697
    return ((enum VP8StatusCode )2);
  }
  {
#line 700
  __cil_tmp7 = AppendToMemBuffer(idec, data, data_size);
  }
#line 700
  if (! __cil_tmp7) {
#line 701
    return ((enum VP8StatusCode )1);
  }
  {
#line 703
  __cil_tmp8 = IDecode(idec);
  }
#line 703
  return (__cil_tmp8);
}
}
#line 706 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
enum VP8StatusCode___0 WebPIUpdate(WebPIDecoder *idec , uint8_t *data , size_t data_size ) 
{ 
  enum VP8StatusCode status ;
  enum VP8StatusCode __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  enum VP8StatusCode __cil_tmp8 ;

  {
#line 709
  if (idec == (void *)0) {
#line 710
    return ((enum VP8StatusCode )2);
  } else
#line 709
  if (data == (void *)0) {
#line 710
    return ((enum VP8StatusCode )2);
  }
  {
#line 712
  status = IDecCheckStatus(idec);
  }
#line 713
  if ((unsigned int )status != 5U) {
#line 714
    return (status);
  }
  {
#line 717
  __cil_tmp6 = CheckMemBufferMode(& idec->mem_, (MemBufferMode )2);
  }
#line 717
  if (! __cil_tmp6) {
#line 718
    return ((enum VP8StatusCode )2);
  }
  {
#line 721
  __cil_tmp7 = RemapMemBuffer(idec, data, data_size);
  }
#line 721
  if (! __cil_tmp7) {
#line 722
    return ((enum VP8StatusCode )2);
  }
  {
#line 724
  __cil_tmp8 = IDecode(idec);
  }
#line 724
  return (__cil_tmp8);
}
}
#line 729 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
static WebPDecBuffer *GetOutputBuffer(WebPIDecoder *idec ) 
{ 


  {
#line 730
  if (idec == (void *)0) {
#line 731
    return ((WebPDecBuffer *)((void *)0));
  } else
#line 730
  if (idec->dec_ == (void *)0) {
#line 731
    return ((WebPDecBuffer *)((void *)0));
  }
#line 733
  if ((unsigned int )idec->state_ <= 2U) {
#line 734
    return ((WebPDecBuffer *)((void *)0));
  }
#line 736
  return (idec->params_.output);
}
}
#line 739 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
WebPDecBuffer *WebPIDecodedArea(WebPIDecoder *idec , int *left , int *top , int *width ,
                                int *height ) 
{ 
  WebPDecBuffer *src ;
  WebPDecBuffer *__cil_tmp7 ;

  {
  {
#line 742
  __cil_tmp7 = GetOutputBuffer(idec);
#line 742
  src = __cil_tmp7;
  }
#line 743
  if (left != (void *)0) {
#line 743
    *left = 0;
  }
#line 744
  if (top != (void *)0) {
#line 744
    *top = 0;
  }
#line 746
  if (src) {
#line 747
    if (width != (void *)0) {
#line 747
      *width = src->width;
    }
#line 748
    if (height != (void *)0) {
#line 748
      *height = idec->params_.last_y;
    }
  } else {
#line 750
    if (width != (void *)0) {
#line 750
      *width = 0;
    }
#line 751
    if (height != (void *)0) {
#line 751
      *height = 0;
    }
  }
#line 753
  return (src);
}
}
#line 756 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
uint8_t *WebPIDecGetRGB(WebPIDecoder *idec , int *last_y , int *width , int *height ,
                        int *stride ) 
{ 
  WebPDecBuffer *src ;
  WebPDecBuffer *__cil_tmp7 ;

  {
  {
#line 758
  __cil_tmp7 = GetOutputBuffer(idec);
#line 758
  src = __cil_tmp7;
  }
#line 759
  if (src == (void *)0) {
#line 759
    return ((uint8_t *)((void *)0));
  }
#line 760
  if ((unsigned int )src->colorspace >= 11U) {
#line 761
    return ((uint8_t *)((void *)0));
  }
#line 764
  if (last_y != (void *)0) {
#line 764
    *last_y = idec->params_.last_y;
  }
#line 765
  if (width != (void *)0) {
#line 765
    *width = src->width;
  }
#line 766
  if (height != (void *)0) {
#line 766
    *height = src->height;
  }
#line 767
  if (stride != (void *)0) {
#line 767
    *stride = src->u.RGBA.stride;
  }
#line 769
  return (src->u.RGBA.rgba);
}
}
#line 772 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
uint8_t *WebPIDecGetYUVA(WebPIDecoder *idec , int *last_y , uint8_t **u , uint8_t **v ,
                         uint8_t **a , int *width , int *height , int *stride , int *uv_stride ,
                         int *a_stride ) 
{ 
  WebPDecBuffer *src ;
  WebPDecBuffer *__cil_tmp12 ;

  {
  {
#line 776
  __cil_tmp12 = GetOutputBuffer(idec);
#line 776
  src = __cil_tmp12;
  }
#line 777
  if (src == (void *)0) {
#line 777
    return ((uint8_t *)((void *)0));
  }
#line 778
  if ((unsigned int )src->colorspace < 11U) {
#line 779
    return ((uint8_t *)((void *)0));
  }
#line 782
  if (last_y != (void *)0) {
#line 782
    *last_y = idec->params_.last_y;
  }
#line 783
  if (u != (void *)0) {
#line 783
    *u = src->u.YUVA.u;
  }
#line 784
  if (v != (void *)0) {
#line 784
    *v = src->u.YUVA.v;
  }
#line 785
  if (a != (void *)0) {
#line 785
    *a = src->u.YUVA.a;
  }
#line 786
  if (width != (void *)0) {
#line 786
    *width = src->width;
  }
#line 787
  if (height != (void *)0) {
#line 787
    *height = src->height;
  }
#line 788
  if (stride != (void *)0) {
#line 788
    *stride = src->u.YUVA.y_stride;
  }
#line 789
  if (uv_stride != (void *)0) {
#line 789
    *uv_stride = src->u.YUVA.u_stride;
  }
#line 790
  if (a_stride != (void *)0) {
#line 790
    *a_stride = src->u.YUVA.a_stride;
  }
#line 792
  return (src->u.YUVA.y);
}
}
#line 795 "/doner/libwebp/libwebp-v0.3.0/src/dec/idec.c"
int WebPISetIOHooks(WebPIDecoder *idec , VP8IoPutHook put , VP8IoSetupHook setup ,
                    VP8IoTeardownHook teardown , void *user_data ) 
{ 


  {
#line 800
  if (idec == (void *)0) {
#line 801
    return (0);
  } else
#line 800
  if ((unsigned int )idec->state_ > 0U) {
#line 801
    return (0);
  }
#line 804
  idec->io_.put = put;
#line 805
  idec->io_.setup = setup;
#line 806
  idec->io_.teardown = teardown;
#line 807
  idec->io_.opaque = user_data;
#line 809
  return (1);
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
static uint32_t kHashMul___11  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___11(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___11 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___11(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___11 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheContains___11(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___11 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 30 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
static uint8_t kFilterExtraRows[3]  = {      (uint8_t )0,      (uint8_t )2,      (uint8_t )8};
#line 32 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
__inline static int hev_thresh_from_level(int level , int keyframe ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 33
  if (keyframe) {
#line 34
    if (level >= 40) {
#line 34
      tmp___0 = 2;
    } else {
#line 34
      if (level >= 15) {
#line 34
        tmp = 1;
      } else {
#line 34
        tmp = 0;
      }
#line 34
      tmp___0 = tmp;
    }
#line 34
    return (tmp___0);
  } else {
#line 36
    if (level >= 40) {
#line 36
      tmp___3 = 3;
    } else {
#line 36
      if (level >= 20) {
#line 36
        tmp___2 = 2;
      } else {
#line 36
        if (level >= 15) {
#line 36
          tmp___1 = 1;
        } else {
#line 36
          tmp___1 = 0;
        }
#line 36
        tmp___2 = tmp___1;
      }
#line 36
      tmp___3 = tmp___2;
    }
#line 36
    return (tmp___3);
  }
}
}
#line 40 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
static void DoFilter___0(VP8Decoder *dec , int mb_x , int mb_y ) 
{ 
  VP8ThreadContext *ctx ;
  int y_bps ;
  VP8FInfo *f_info ;
  uint8_t *y_dst ;
  int level ;
  int ilevel ;
  int limit ;
  int uv_bps ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  int hev_thresh ;
  int __cil_tmp15 ;

  {
#line 41
  ctx = & dec->thread_ctx_;
#line 42
  y_bps = dec->cache_y_stride_;
#line 43
  f_info = ctx->f_info_ + mb_x;
#line 44
  y_dst = (dec->cache_y_ + (ctx->id_ * 16) * y_bps) + mb_x * 16;
#line 45
  level = (int )f_info->f_level_;
#line 46
  ilevel = (int )f_info->f_ilevel_;
#line 47
  limit = 2 * level + ilevel;
#line 48
  if (level == 0) {
#line 49
    return;
  }
#line 51
  if (dec->filter_type_ == 1) {
#line 52
    if (mb_x > 0) {
      {
#line 53
      (*VP8SimpleHFilter16)(y_dst, y_bps, limit + 4);
      }
    }
#line 55
    if (f_info->f_inner_) {
      {
#line 56
      (*VP8SimpleHFilter16i)(y_dst, y_bps, limit);
      }
    }
#line 58
    if (mb_y > 0) {
      {
#line 59
      (*VP8SimpleVFilter16)(y_dst, y_bps, limit + 4);
      }
    }
#line 61
    if (f_info->f_inner_) {
      {
#line 62
      (*VP8SimpleVFilter16i)(y_dst, y_bps, limit);
      }
    }
  } else {
    {
#line 65
    uv_bps = dec->cache_uv_stride_;
#line 66
    u_dst = (dec->cache_u_ + (ctx->id_ * 8) * uv_bps) + mb_x * 8;
#line 67
    v_dst = (dec->cache_v_ + (ctx->id_ * 8) * uv_bps) + mb_x * 8;
#line 68
    __cil_tmp15 = hev_thresh_from_level(level, (int )dec->frm_hdr_.key_frame_);
#line 68
    hev_thresh = __cil_tmp15;
    }
#line 70
    if (mb_x > 0) {
      {
#line 71
      (*VP8HFilter16)(y_dst, y_bps, limit + 4, ilevel, hev_thresh);
#line 72
      (*VP8HFilter8)(u_dst, v_dst, uv_bps, limit + 4, ilevel, hev_thresh);
      }
    }
#line 74
    if (f_info->f_inner_) {
      {
#line 75
      (*VP8HFilter16i)(y_dst, y_bps, limit, ilevel, hev_thresh);
#line 76
      (*VP8HFilter8i)(u_dst, v_dst, uv_bps, limit, ilevel, hev_thresh);
      }
    }
#line 78
    if (mb_y > 0) {
      {
#line 79
      (*VP8VFilter16)(y_dst, y_bps, limit + 4, ilevel, hev_thresh);
#line 80
      (*VP8VFilter8)(u_dst, v_dst, uv_bps, limit + 4, ilevel, hev_thresh);
      }
    }
#line 82
    if (f_info->f_inner_) {
      {
#line 83
      (*VP8VFilter16i)(y_dst, y_bps, limit, ilevel, hev_thresh);
#line 84
      (*VP8VFilter8i)(u_dst, v_dst, uv_bps, limit, ilevel, hev_thresh);
      }
    }
  }
  return;
}
}
#line 90 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
static void FilterRow(VP8Decoder *dec ) 
{ 
  int mb_x ;
  int mb_y ;
  int tmp ;

  {
#line 92
  mb_y = dec->thread_ctx_.mb_y_;
#line 94
  mb_x = dec->tl_mb_x_;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (mb_x < dec->br_mb_x_)) {
#line 94
      goto while_break;
    }
    {
#line 95
    DoFilter___0(dec, mb_x, mb_y);
    }
#line 94
    mb_x ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 102 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
static void PrecomputeFilterStrengths(VP8Decoder *dec ) 
{ 
  int s ;
  VP8FilterHeader___0 *hdr ;
  int i4x4 ;
  int base_level ;
  VP8FInfo *info ;
  int level ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 103
  if (dec->filter_type_ > 0) {
#line 105
    hdr = & dec->filter_hdr_;
#line 106
    s = 0;
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
#line 106
      if (! (s < 4)) {
#line 106
        goto while_break;
      }
#line 110
      if (dec->segment_hdr_.use_segment_) {
#line 111
        base_level = (int )dec->segment_hdr_.filter_strength_[s];
#line 112
        if (! dec->segment_hdr_.absolute_delta_) {
#line 113
          base_level += hdr->level_;
        }
      } else {
#line 116
        base_level = hdr->level_;
      }
#line 118
      i4x4 = 0;
      {
#line 118
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 118
        if (! (i4x4 <= 1)) {
#line 118
          goto while_break___0;
        }
#line 119
        info = & dec->fstrengths_[s][i4x4];
#line 120
        level = base_level;
#line 121
        if (hdr->use_lf_delta_) {
#line 123
          level += hdr->ref_lf_delta_[0];
#line 124
          if (i4x4) {
#line 125
            level += hdr->mode_lf_delta_[0];
          }
        }
#line 128
        if (level < 0) {
#line 128
          tmp___0 = 0;
        } else {
#line 128
          if (level > 63) {
#line 128
            tmp = 63;
          } else {
#line 128
            tmp = level;
          }
#line 128
          tmp___0 = tmp;
        }
#line 128
        level = tmp___0;
#line 129
        info->f_level_ = (unsigned int )level;
#line 131
        if (hdr->sharpness_ > 0) {
#line 132
          if (hdr->sharpness_ > 4) {
#line 133
            level >>= 2;
          } else {
#line 135
            level >>= 1;
          }
#line 137
          if (level > 9 - hdr->sharpness_) {
#line 138
            level = 9 - hdr->sharpness_;
          }
        }
#line 141
        if (level < 1) {
#line 141
          tmp___1 = 1;
        } else {
#line 141
          tmp___1 = level;
        }
#line 141
        info->f_ilevel_ = (unsigned int )tmp___1;
#line 142
        info->f_inner_ = (unsigned int )0;
#line 118
        i4x4 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 106
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 162 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
static int FinishRow(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  VP8ThreadContext *ctx ;
  int extra_y_rows ;
  int ysize ;
  int uvsize ;
  int y_offset ;
  int uv_offset ;
  uint8_t *ydst ;
  uint8_t *udst ;
  uint8_t *vdst ;
  int first_row ;
  int last_row ;
  int y_start ;
  int y_end ;
  uint8_t *__cil_tmp17 ;
  int __cil_tmp18 ;
  int delta_y ;
  int tmp ;
  int __cil_tmp21 ;

  {
#line 163
  ok = 1;
#line 164
  ctx = & dec->thread_ctx_;
#line 165
  extra_y_rows = (int )kFilterExtraRows[dec->filter_type_];
#line 166
  ysize = extra_y_rows * dec->cache_y_stride_;
#line 167
  uvsize = (extra_y_rows / 2) * dec->cache_uv_stride_;
#line 168
  y_offset = (ctx->id_ * 16) * dec->cache_y_stride_;
#line 169
  uv_offset = (ctx->id_ * 8) * dec->cache_uv_stride_;
#line 170
  ydst = (dec->cache_y_ - ysize) + y_offset;
#line 171
  udst = (dec->cache_u_ - uvsize) + uv_offset;
#line 172
  vdst = (dec->cache_v_ - uvsize) + uv_offset;
#line 173
  first_row = ctx->mb_y_ == 0;
#line 174
  last_row = ctx->mb_y_ >= dec->br_mb_y_ - 1;
#line 175
  y_start = ctx->mb_y_ * 16;
#line 176
  y_end = (ctx->mb_y_ + 1) * 16;
#line 178
  if (ctx->filter_row_) {
    {
#line 179
    FilterRow(dec);
    }
  }
#line 182
  if (io->put) {
#line 183
    if (! first_row) {
#line 184
      y_start -= extra_y_rows;
#line 185
      io->y = ydst;
#line 186
      io->u = udst;
#line 187
      io->v = vdst;
    } else {
#line 189
      io->y = dec->cache_y_ + y_offset;
#line 190
      io->u = dec->cache_u_ + uv_offset;
#line 191
      io->v = dec->cache_v_ + uv_offset;
    }
#line 194
    if (! last_row) {
#line 195
      y_end -= extra_y_rows;
    }
#line 197
    if (y_end > io->crop_bottom) {
#line 198
      y_end = io->crop_bottom;
    }
#line 200
    io->a = (uint8_t *)((void *)0);
#line 201
    if (dec->alpha_data_ != (void *)0) {
#line 201
      if (y_start < y_end) {
        {
#line 207
        io->a = VP8DecompressAlphaRows(dec, y_start, y_end - y_start);
        }
#line 208
        if (io->a == (void *)0) {
          {
#line 209
          __cil_tmp18 = VP8SetError(dec, (enum VP8StatusCode )3, "Could not decode alpha data.");
          }
#line 209
          return (__cil_tmp18);
        }
      }
    }
#line 213
    if (y_start < io->crop_top) {
#line 214
      delta_y = io->crop_top - y_start;
#line 215
      y_start = io->crop_top;
#line 217
      io->y += dec->cache_y_stride_ * delta_y;
#line 218
      io->u += dec->cache_uv_stride_ * (delta_y >> 1);
#line 219
      io->v += dec->cache_uv_stride_ * (delta_y >> 1);
#line 220
      if (io->a != (void *)0) {
#line 221
        io->a += io->width * delta_y;
      }
    }
#line 224
    if (y_start < y_end) {
#line 225
      io->y += io->crop_left;
#line 226
      io->u += io->crop_left >> 1;
#line 227
      io->v += io->crop_left >> 1;
#line 228
      if (io->a != (void *)0) {
#line 229
        io->a += io->crop_left;
      }
      {
#line 231
      io->mb_y = y_start - io->crop_top;
#line 232
      io->mb_w = io->crop_right - io->crop_left;
#line 233
      io->mb_h = y_end - y_start;
#line 234
      ok = (*(io->put))(io);
      }
    }
  }
#line 238
  if (ctx->id_ + 1 == dec->num_caches_) {
#line 239
    if (! last_row) {
      {
#line 240
      memcpy(dec->cache_y_ - ysize, ydst + 16 * dec->cache_y_stride_, (unsigned long )ysize);
#line 241
      memcpy(dec->cache_u_ - uvsize, udst + 8 * dec->cache_uv_stride_, (unsigned long )uvsize);
#line 242
      memcpy(dec->cache_v_ - uvsize, vdst + 8 * dec->cache_uv_stride_, (unsigned long )uvsize);
      }
    }
  }
#line 246
  return (ok);
}
}
#line 253 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
int VP8ProcessRow(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  VP8ThreadContext *ctx ;
  int __cil_tmp5 ;
  WebPWorker *worker ;
  int __cil_tmp7 ;
  int tmp ;
  VP8FInfo *tmp___0 ;

  {
#line 254
  ok = 1;
#line 255
  ctx = & dec->thread_ctx_;
#line 256
  if (! dec->use_threads_) {
    {
#line 258
    ctx->mb_y_ = dec->mb_y_;
#line 259
    ctx->filter_row_ = dec->filter_row_;
#line 260
    ok = FinishRow(dec, io);
    }
  } else {
    {
#line 262
    worker = & dec->worker_;
#line 264
    __cil_tmp7 = WebPWorkerSync(worker);
    }
#line 264
    ok &= __cil_tmp7;
#line 266
    if (ok) {
#line 267
      ctx->io_ = *io;
#line 268
      ctx->id_ = dec->cache_id_;
#line 269
      ctx->mb_y_ = dec->mb_y_;
#line 270
      ctx->filter_row_ = dec->filter_row_;
#line 271
      if (ctx->filter_row_) {
#line 272
        tmp___0 = ctx->f_info_;
#line 273
        ctx->f_info_ = dec->f_info_;
#line 274
        dec->f_info_ = tmp___0;
      }
      {
#line 276
      WebPWorkerLaunch(worker);
#line 277
      (dec->cache_id_) ++;
      }
#line 277
      if (dec->cache_id_ == dec->num_caches_) {
#line 278
        dec->cache_id_ = 0;
      }
    }
  }
#line 282
  return (ok);
}
}
#line 288 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
enum VP8StatusCode VP8EnterCritical(VP8Decoder *dec , VP8Io *io ) 
{ 
  int __cil_tmp3 ;
  int extra_pixels ;

  {
  {
#line 291
  __cil_tmp3 = (*(io->setup))(io);
  }
#line 291
  if (io->setup) {
#line 291
    if (! __cil_tmp3) {
      {
#line 292
      VP8SetError(dec, (enum VP8StatusCode )6, "Frame setup failed\315\214rU");
      }
#line 293
      return (dec->status_);
    }
  }
#line 297
  if (io->bypass_filtering) {
#line 298
    dec->filter_type_ = 0;
  }
#line 314
  extra_pixels = (int )kFilterExtraRows[dec->filter_type_];
#line 315
  if (dec->filter_type_ == 2) {
#line 317
    dec->tl_mb_x_ = 0;
#line 318
    dec->tl_mb_y_ = 0;
  } else {
#line 324
    dec->tl_mb_x_ = (io->crop_left - extra_pixels) >> 4;
#line 325
    dec->tl_mb_y_ = (io->crop_top - extra_pixels) >> 4;
#line 326
    if (dec->tl_mb_x_ < 0) {
#line 326
      dec->tl_mb_x_ = 0;
    }
#line 327
    if (dec->tl_mb_y_ < 0) {
#line 327
      dec->tl_mb_y_ = 0;
    }
  }
#line 330
  dec->br_mb_y_ = ((io->crop_bottom + 15) + extra_pixels) >> 4;
#line 331
  dec->br_mb_x_ = ((io->crop_right + 15) + extra_pixels) >> 4;
#line 332
  if (dec->br_mb_x_ > dec->mb_w_) {
#line 333
    dec->br_mb_x_ = dec->mb_w_;
  }
#line 335
  if (dec->br_mb_y_ > dec->mb_h_) {
#line 336
    dec->br_mb_y_ = dec->mb_h_;
  }
  {
#line 339
  PrecomputeFilterStrengths(dec);
  }
#line 340
  return ((enum VP8StatusCode )0);
}
}
#line 343 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
int VP8ExitCritical(VP8Decoder *dec , VP8Io *io ) 
{ 
  int ok ;
  int __cil_tmp4 ;

  {
#line 344
  ok = 1;
#line 345
  if (dec->use_threads_) {
    {
#line 346
    ok = WebPWorkerSync(& dec->worker_);
    }
  }
#line 349
  if (io->teardown) {
    {
#line 350
    (*(io->teardown))(io);
    }
  }
#line 352
  return (ok);
}
}
#line 383 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
static int InitThreadContext(VP8Decoder *dec ) 
{ 
  WebPWorker *worker ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp ;

  {
#line 384
  dec->cache_id_ = 0;
#line 385
  if (dec->use_threads_) {
    {
#line 386
    worker = & dec->worker_;
#line 387
    __cil_tmp3 = WebPWorkerReset(worker);
    }
#line 387
    if (! __cil_tmp3) {
      {
#line 388
      __cil_tmp4 = VP8SetError(dec, (enum VP8StatusCode )1, "thread initialization failed.U");
      }
#line 388
      return (__cil_tmp4);
    }
#line 391
    worker->data1 = dec;
#line 392
    worker->data2 = (void *)(& dec->thread_ctx_.io_);
#line 393
    worker->hook = (WebPWorkerHook )(& FinishRow);
#line 394
    if (dec->filter_type_ > 0) {
#line 394
      tmp = 3;
    } else {
#line 394
      tmp = 2;
    }
#line 394
    dec->num_caches_ = tmp;
  } else {
#line 397
    dec->num_caches_ = 1;
  }
#line 399
  return (1);
}
}
#line 408 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
static int AllocateMemory(VP8Decoder *dec ) 
{ 
  int num_caches ;
  int mb_w ;
  size_t intra_pred_mode_size ;
  size_t top_size ;
  size_t mb_info_size ;
  size_t f_info_size ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t yuv_size ;
  size_t coeffs_size ;
  size_t cache_height ;
  size_t cache_size ;
  uint64_t alpha_size ;
  unsigned long long tmp___1 ;
  uint64_t needed ;
  uint8_t *mem ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  VP8FInfo *tmp___2 ;
  int tmp___3 ;
  int extra_rows ;
  int extra_y ;
  int extra_uv ;
  uint8_t *tmp___4 ;
  int tmp___5 ;

  {
#line 409
  num_caches = dec->num_caches_;
#line 410
  mb_w = dec->mb_w_;
#line 412
  intra_pred_mode_size = (unsigned long )(4 * mb_w) * sizeof(uint8_t );
#line 413
  top_size = (size_t )(32 * mb_w);
#line 414
  mb_info_size = (unsigned long )(mb_w + 1) * sizeof(VP8MB );
#line 415
  if (dec->filter_type_ > 0) {
#line 415
    if (dec->use_threads_) {
#line 415
      tmp = 2;
    } else {
#line 415
      tmp = 1;
    }
#line 415
    tmp___0 = (unsigned long )(mb_w * tmp) * sizeof(VP8FInfo );
  } else {
#line 415
    tmp___0 = (unsigned long )0;
  }
#line 415
  f_info_size = tmp___0;
#line 419
  yuv_size = 832UL * sizeof(*(dec->yuv_b_));
#line 420
  coeffs_size = 384UL * sizeof(*(dec->coeffs_));
#line 421
  cache_height = (size_t )(((16 * num_caches + (int )kFilterExtraRows[dec->filter_type_]) * 3) / 2);
#line 423
  cache_size = top_size * cache_height;
#line 425
  if (dec->alpha_data_ != (void *)0) {
#line 425
    tmp___1 = (unsigned long long )((uint64_t )dec->pic_hdr_.width_ * (unsigned long )dec->pic_hdr_.height_);
  } else {
#line 425
    tmp___1 = 0ULL;
  }
#line 425
  alpha_size = (uint64_t )tmp___1;
#line 427
  needed = ((((((((uint64_t )intra_pred_mode_size + top_size) + mb_info_size) + f_info_size) + yuv_size) + coeffs_size) + cache_size) + alpha_size) + 31UL;
#line 433
  if (needed != (size_t )needed) {
#line 433
    return (0);
  }
#line 434
  if (needed > dec->mem_size_) {
    {
#line 435
    free(dec->mem_);
#line 436
    dec->mem_size_ = (size_t )0;
#line 437
    dec->mem_ = WebPSafeMalloc(needed, sizeof(uint8_t ));
    }
#line 438
    if (dec->mem_ == (void *)0) {
      {
#line 439
      __cil_tmp19 = VP8SetError(dec, (enum VP8StatusCode )1, "no memory during frame initialization.");
      }
#line 439
      return (__cil_tmp19);
    }
#line 443
    dec->mem_size_ = (size_t )needed;
  }
#line 446
  mem = (uint8_t *)dec->mem_;
#line 447
  dec->intra_t_ = (uint8_t *)mem;
#line 448
  mem += intra_pred_mode_size;
#line 450
  dec->y_t_ = (uint8_t *)mem;
#line 451
  mem += 16 * mb_w;
#line 452
  dec->u_t_ = (uint8_t *)mem;
#line 453
  mem += 8 * mb_w;
#line 454
  dec->v_t_ = (uint8_t *)mem;
#line 455
  mem += 8 * mb_w;
#line 457
  dec->mb_info_ = (VP8MB *)mem + 1;
#line 458
  mem += mb_info_size;
#line 460
  if (f_info_size) {
#line 460
    tmp___2 = (VP8FInfo *)mem;
  } else {
#line 460
    tmp___2 = (VP8FInfo *)((void *)0);
  }
#line 460
  dec->f_info_ = tmp___2;
#line 461
  mem += f_info_size;
#line 462
  dec->thread_ctx_.id_ = 0;
#line 463
  dec->thread_ctx_.f_info_ = dec->f_info_;
#line 464
  if (dec->use_threads_) {
#line 468
    dec->thread_ctx_.f_info_ += mb_w;
  }
#line 471
  mem = (uint8_t *)((uintptr_t )(mem + 31) & 0xffffffffffffffe0UL);
#line 473
  dec->yuv_b_ = (uint8_t *)mem;
#line 474
  mem += yuv_size;
#line 476
  dec->coeffs_ = (int16_t *)mem;
#line 477
  mem += coeffs_size;
#line 479
  dec->cache_y_stride_ = 16 * mb_w;
#line 480
  dec->cache_uv_stride_ = 8 * mb_w;
#line 482
  extra_rows = (int )kFilterExtraRows[dec->filter_type_];
#line 483
  extra_y = extra_rows * dec->cache_y_stride_;
#line 484
  extra_uv = (extra_rows / 2) * dec->cache_uv_stride_;
#line 485
  dec->cache_y_ = (uint8_t *)mem + extra_y;
#line 486
  dec->cache_u_ = (dec->cache_y_ + (16 * num_caches) * dec->cache_y_stride_) + extra_uv;
#line 488
  dec->cache_v_ = (dec->cache_u_ + (8 * num_caches) * dec->cache_uv_stride_) + extra_uv;
#line 490
  dec->cache_id_ = 0;
#line 492
  mem += cache_size;
#line 495
  if (alpha_size) {
#line 495
    tmp___4 = (uint8_t *)mem;
  } else {
#line 495
    tmp___4 = (uint8_t *)((void *)0);
  }
  {
#line 495
  dec->alpha_plane_ = tmp___4;
#line 496
  mem += alpha_size;
#line 500
  memset(dec->mb_info_ - 1, 0, mb_info_size);
#line 503
  memset(dec->intra_t_, 0, intra_pred_mode_size);
  }
#line 505
  return (1);
}
}
#line 508 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
static void InitIo(VP8Decoder *dec , VP8Io *io ) 
{ 


  {
#line 510
  io->mb_y = 0;
#line 511
  io->y = dec->cache_y_;
#line 512
  io->u = dec->cache_u_;
#line 513
  io->v = dec->cache_v_;
#line 514
  io->y_stride = dec->cache_y_stride_;
#line 515
  io->uv_stride = dec->cache_uv_stride_;
#line 516
  io->a = (uint8_t *)((void *)0);
  return;
}
}
#line 519 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
int VP8InitFrame(VP8Decoder *dec , VP8Io *io ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 520
  __cil_tmp3 = InitThreadContext(dec);
  }
#line 520
  if (! __cil_tmp3) {
#line 520
    return (0);
  }
  {
#line 521
  __cil_tmp4 = AllocateMemory(dec);
  }
#line 521
  if (! __cil_tmp4) {
#line 521
    return (0);
  }
  {
#line 522
  InitIo(dec, io);
#line 523
  VP8DspInit();
  }
#line 524
  return (1);
}
}
#line 530 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
static int const   kScan[16]  = 
#line 530
  {      0,      4,      8,      12, 
        128,      132,      136,      140, 
        256,      260,      264,      268, 
        384,      388,      392,      396};
#line 537 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
__inline static int CheckMode(VP8Decoder *dec , int mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 538
  if (mode == 0) {
#line 539
    if (dec->mb_x_ == 0) {
#line 540
      if (dec->mb_y_ == 0) {
#line 540
        tmp = 6;
      } else {
#line 540
        tmp = 5;
      }
#line 540
      return (tmp);
    } else {
#line 542
      if (dec->mb_y_ == 0) {
#line 542
        tmp___0 = 4;
      } else {
#line 542
        tmp___0 = 0;
      }
#line 542
      return (tmp___0);
    }
  }
#line 545
  return (mode);
}
}
#line 548 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
__inline static void Copy32b(uint8_t *dst , uint8_t *src ) 
{ 


  {
#line 549
  *((uint32_t *)dst) = *((uint32_t *)src);
  return;
}
}
#line 552 "/doner/libwebp/libwebp-v0.3.0/src/dec/frame.c"
void VP8ReconstructBlock(VP8Decoder *dec ) 
{ 
  int j ;
  uint8_t *y_dst ;
  uint8_t *u_dst ;
  uint8_t *v_dst ;
  uint8_t *top_y ;
  uint8_t *top_u ;
  uint8_t *top_v ;
  int16_t *coeffs ;
  int n ;
  uint32_t *top_right ;
  uint8_t *dst ;
  int __cil_tmp13 ;
  int pred_func ;
  int __cil_tmp15 ;
  uint8_t *dst___0 ;
  int __cil_tmp17 ;
  int pred_func___0 ;
  int __cil_tmp19 ;
  int16_t *u_coeffs ;
  int16_t *v_coeffs ;
  int y_offset ;
  int uv_offset ;
  uint8_t *y_out ;
  uint8_t *u_out ;
  uint8_t *v_out ;

  {
#line 554
  y_dst = dec->yuv_b_ + 40;
#line 555
  u_dst = dec->yuv_b_ + 584;
#line 556
  v_dst = dec->yuv_b_ + 600;
#line 560
  if (dec->mb_x_ > 0) {
#line 561
    j = - 1;
    {
#line 561
    while (1) {
      while_continue: /* CIL Label */ ;
#line 561
      if (! (j < 16)) {
#line 561
        goto while_break;
      }
      {
#line 562
      Copy32b(y_dst + (j * 32 - 4), y_dst + (j * 32 + 12));
      }
#line 561
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 564
    j = - 1;
    {
#line 564
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 564
      if (! (j < 8)) {
#line 564
        goto while_break___0;
      }
      {
#line 565
      Copy32b(u_dst + (j * 32 - 4), u_dst + (j * 32 + 4));
#line 566
      Copy32b(v_dst + (j * 32 - 4), v_dst + (j * 32 + 4));
      }
#line 564
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 569
    j = 0;
    {
#line 569
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 569
      if (! (j < 16)) {
#line 569
        goto while_break___1;
      }
#line 570
      *(y_dst + (j * 32 - 1)) = (uint8_t )129;
#line 569
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 572
    j = 0;
    {
#line 572
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 572
      if (! (j < 8)) {
#line 572
        goto while_break___2;
      }
#line 573
      *(u_dst + (j * 32 - 1)) = (uint8_t )129;
#line 574
      *(v_dst + (j * 32 - 1)) = (uint8_t )129;
#line 572
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 577
    if (dec->mb_y_ > 0) {
#line 578
      *(v_dst + -33) = (uint8_t )129;
#line 578
      *(u_dst + -33) = *(v_dst + -33);
#line 578
      *(y_dst + -33) = *(u_dst + -33);
    }
  }
#line 583
  top_y = dec->y_t_ + dec->mb_x_ * 16;
#line 584
  top_u = dec->u_t_ + dec->mb_x_ * 8;
#line 585
  top_v = dec->v_t_ + dec->mb_x_ * 8;
#line 586
  coeffs = dec->coeffs_;
#line 589
  if (dec->mb_y_ > 0) {
    {
#line 590
    memcpy(y_dst - 32, top_y, (unsigned long )16);
#line 591
    memcpy(u_dst - 32, top_u, (unsigned long )8);
#line 592
    memcpy(v_dst - 32, top_v, (unsigned long )8);
    }
  } else
#line 593
  if (dec->mb_x_ == 0) {
    {
#line 596
    memset((y_dst - 32) - 1, 127, (unsigned long )21);
#line 597
    memset((u_dst - 32) - 1, 127, (unsigned long )9);
#line 598
    memset((v_dst - 32) - 1, 127, (unsigned long )9);
    }
  }
#line 603
  if (dec->is_i4x4_) {
#line 604
    top_right = (uint32_t *)((y_dst - 32) + 16);
#line 606
    if (dec->mb_y_ > 0) {
#line 607
      if (dec->mb_x_ >= dec->mb_w_ - 1) {
#line 608
        *(top_right + 0) = (unsigned int )*(top_y + 15) * 16843009U;
      } else {
        {
#line 610
        memcpy(top_right, top_y + 16, sizeof(*top_right));
        }
      }
    }
#line 614
    *(top_right + 96) = *(top_right + 0);
#line 614
    *(top_right + 64) = *(top_right + 96);
#line 614
    *(top_right + 32) = *(top_right + 64);
#line 617
    n = 0;
    {
#line 617
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 617
      if (! (n < 16)) {
#line 617
        goto while_break___3;
      }
      {
#line 618
      dst = y_dst + kScan[n];
#line 619
      (*(VP8PredLuma4[dec->imodes_[n]]))(dst);
      }
#line 620
      if (dec->non_zero_ac_ & (unsigned int )(1 << n)) {
        {
#line 621
        (*VP8Transform)(coeffs + n * 16, dst, 0);
        }
      } else
#line 622
      if (dec->non_zero_ & (unsigned int )(1 << n)) {
        {
#line 623
        (*VP8TransformDC)(coeffs + n * 16, dst);
        }
      }
#line 617
      n ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
    {
#line 627
    __cil_tmp15 = CheckMode(dec, (int )dec->imodes_[0]);
#line 627
    pred_func = __cil_tmp15;
#line 628
    (*(VP8PredLuma16[pred_func]))(y_dst);
    }
#line 629
    if (dec->non_zero_) {
#line 630
      n = 0;
      {
#line 630
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 630
        if (! (n < 16)) {
#line 630
          goto while_break___4;
        }
#line 631
        dst___0 = y_dst + kScan[n];
#line 632
        if (dec->non_zero_ac_ & (unsigned int )(1 << n)) {
          {
#line 633
          (*VP8Transform)(coeffs + n * 16, dst___0, 0);
          }
        } else
#line 634
        if (dec->non_zero_ & (unsigned int )(1 << n)) {
          {
#line 635
          (*VP8TransformDC)(coeffs + n * 16, dst___0);
          }
        }
#line 630
        n ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
  {
#line 642
  __cil_tmp19 = CheckMode(dec, (int )dec->uvmode_);
#line 642
  pred_func___0 = __cil_tmp19;
#line 643
  (*(VP8PredChroma8[pred_func___0]))(u_dst);
#line 644
  (*(VP8PredChroma8[pred_func___0]))(v_dst);
  }
#line 646
  if (dec->non_zero_ & 983040U) {
#line 647
    u_coeffs = dec->coeffs_ + 256;
#line 648
    if (dec->non_zero_ac_ & 983040U) {
      {
#line 649
      (*VP8TransformUV)(u_coeffs, u_dst);
      }
    } else {
      {
#line 651
      (*VP8TransformDCUV)(u_coeffs, u_dst);
      }
    }
  }
#line 654
  if (dec->non_zero_ & 15728640U) {
#line 655
    v_coeffs = dec->coeffs_ + 320;
#line 656
    if (dec->non_zero_ac_ & 15728640U) {
      {
#line 657
      (*VP8TransformUV)(v_coeffs, v_dst);
      }
    } else {
      {
#line 659
      (*VP8TransformDCUV)(v_coeffs, v_dst);
      }
    }
  }
#line 664
  if (dec->mb_y_ < dec->mb_h_ - 1) {
    {
#line 665
    memcpy(top_y, y_dst + 480, (unsigned long )16);
#line 666
    memcpy(top_u, u_dst + 224, (unsigned long )8);
#line 667
    memcpy(top_v, v_dst + 224, (unsigned long )8);
    }
  }
#line 673
  y_offset = (dec->cache_id_ * 16) * dec->cache_y_stride_;
#line 674
  uv_offset = (dec->cache_id_ * 8) * dec->cache_uv_stride_;
#line 675
  y_out = (dec->cache_y_ + dec->mb_x_ * 16) + y_offset;
#line 676
  u_out = (dec->cache_u_ + dec->mb_x_ * 8) + uv_offset;
#line 677
  v_out = (dec->cache_v_ + dec->mb_x_ * 8) + uv_offset;
#line 678
  j = 0;
  {
#line 678
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 678
    if (! (j < 16)) {
#line 678
      goto while_break___5;
    }
    {
#line 679
    memcpy(y_out + j * dec->cache_y_stride_, y_dst + j * 32, (unsigned long )16);
    }
#line 678
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 681
  j = 0;
  {
#line 681
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 681
    if (! (j < 8)) {
#line 681
      goto while_break___6;
    }
    {
#line 682
    memcpy(u_out + j * dec->cache_uv_stride_, u_dst + j * 32, (unsigned long )8);
#line 683
    memcpy(v_out + j * dec->cache_uv_stride_, v_dst + j * 32, (unsigned long )8);
    }
#line 681
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  return;
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
static uint32_t kHashMul___12  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___12(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___12 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___12(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___12 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheContains___12(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___12 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
static int const   kModeBpp[13]  = 
#line 26 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
  {      3,      4,      3,      4, 
        4,      2,      2,      4, 
        4,      4,      2,      1, 
        1};
#line 34 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
static int IsValidColorspace(int webp_csp_mode ) 
{ 


  {
#line 35
  return (webp_csp_mode >= 0 && webp_csp_mode < 13);
}
}
#line 38 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
static enum VP8StatusCode CheckDecBuffer(WebPDecBuffer *buffer ) 
{ 
  int ok ;
  enum WEBP_CSP_MODE mode ;
  int width ;
  int height ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  WebPYUVABuffer *buf ;
  uint64_t y_size ;
  uint64_t u_size ;
  uint64_t v_size ;
  uint64_t a_size ;
  WebPRGBABuffer *buf___0 ;
  uint64_t size ;
  int tmp ;

  {
  {
#line 39
  ok = 1;
#line 40
  mode = buffer->colorspace;
#line 41
  width = buffer->width;
#line 42
  height = buffer->height;
#line 43
  __cil_tmp6 = IsValidColorspace((int )mode);
  }
#line 43
  if (! __cil_tmp6) {
#line 44
    ok = 0;
  } else {
    {
#line 45
    __cil_tmp7 = WebPIsRGBMode___0(mode);
    }
#line 45
    if (! __cil_tmp7) {
#line 46
      buf = & buffer->u.YUVA;
#line 47
      y_size = (uint64_t )buf->y_stride * (unsigned long )height;
#line 48
      u_size = (uint64_t )buf->u_stride * (unsigned long )((height + 1) / 2);
#line 49
      v_size = (uint64_t )buf->v_stride * (unsigned long )((height + 1) / 2);
#line 50
      a_size = (uint64_t )buf->a_stride * (unsigned long )height;
#line 51
      ok &= y_size <= buf->y_size;
#line 52
      ok &= u_size <= buf->u_size;
#line 53
      ok &= v_size <= buf->v_size;
#line 54
      ok &= buf->y_stride >= width;
#line 55
      ok &= buf->u_stride >= (width + 1) / 2;
#line 56
      ok &= buf->v_stride >= (width + 1) / 2;
#line 57
      ok &= buf->y != (void *)0;
#line 58
      ok &= buf->u != (void *)0;
#line 59
      ok &= buf->v != (void *)0;
#line 60
      if ((unsigned int )mode == 12U) {
#line 61
        ok &= buf->a_stride >= width;
#line 62
        ok &= a_size <= buf->a_size;
#line 63
        ok &= buf->a != (void *)0;
      }
    } else {
#line 66
      buf___0 = & buffer->u.RGBA;
#line 67
      size = (uint64_t )buf___0->stride * (unsigned long )height;
#line 68
      ok &= size <= buf___0->size;
#line 69
      ok &= buf___0->stride >= width * kModeBpp[mode];
#line 70
      ok &= buf___0->rgba != (void *)0;
    }
  }
#line 72
  if (ok) {
#line 72
    tmp = 0;
  } else {
#line 72
    tmp = 2;
  }
#line 72
  return ((enum VP8StatusCode )tmp);
}
}
#line 75 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
static enum VP8StatusCode AllocateBuffer(WebPDecBuffer *buffer ) 
{ 
  int w ;
  int h ;
  enum WEBP_CSP_MODE mode ;
  int __cil_tmp5 ;
  uint8_t *output ;
  int uv_stride ;
  int a_stride ;
  uint64_t uv_size ;
  uint64_t a_size ;
  uint64_t total_size ;
  int stride ;
  uint64_t size ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  WebPYUVABuffer *buf ;
  WebPRGBABuffer *buf___0 ;
  enum VP8StatusCode __cil_tmp19 ;

  {
  {
#line 76
  w = buffer->width;
#line 77
  h = buffer->height;
#line 78
  mode = buffer->colorspace;
#line 80
  __cil_tmp5 = IsValidColorspace((int )mode);
  }
#line 80
  if (w <= 0) {
#line 81
    return ((enum VP8StatusCode )2);
  } else
#line 80
  if (h <= 0) {
#line 81
    return ((enum VP8StatusCode )2);
  } else
#line 80
  if (! __cil_tmp5) {
#line 81
    return ((enum VP8StatusCode )2);
  }
#line 84
  if (buffer->private_memory == (void *)0) {
#line 84
    if (! buffer->is_external_memory) {
#line 86
      uv_stride = 0;
#line 86
      a_stride = 0;
#line 87
      uv_size = (uint64_t )0;
      {
#line 87
      a_size = (uint64_t )0;
#line 90
      stride = w * kModeBpp[mode];
#line 91
      size = (uint64_t )stride * (unsigned long )h;
#line 93
      __cil_tmp14 = WebPIsRGBMode___0(mode);
      }
#line 93
      if (! __cil_tmp14) {
#line 94
        uv_stride = (w + 1) / 2;
#line 95
        uv_size = (uint64_t )uv_stride * (unsigned long )((h + 1) / 2);
#line 96
        if ((unsigned int )mode == 12U) {
#line 97
          a_stride = w;
#line 98
          a_size = (uint64_t )a_stride * (unsigned long )h;
        }
      }
      {
#line 101
      total_size = (size + 2UL * uv_size) + a_size;
#line 104
      __cil_tmp15 = WebPSafeMalloc(total_size, sizeof(*output));
#line 104
      output = (uint8_t *)__cil_tmp15;
      }
#line 105
      if (output == (void *)0) {
#line 106
        return ((enum VP8StatusCode )1);
      }
      {
#line 108
      buffer->private_memory = output;
#line 110
      __cil_tmp16 = WebPIsRGBMode___0(mode);
      }
#line 110
      if (! __cil_tmp16) {
#line 111
        buf = & buffer->u.YUVA;
#line 112
        buf->y = output;
#line 113
        buf->y_stride = stride;
#line 114
        buf->y_size = (size_t )size;
#line 115
        buf->u = output + size;
#line 116
        buf->u_stride = uv_stride;
#line 117
        buf->u_size = (size_t )uv_size;
#line 118
        buf->v = (output + size) + uv_size;
#line 119
        buf->v_stride = uv_stride;
#line 120
        buf->v_size = (size_t )uv_size;
#line 121
        if ((unsigned int )mode == 12U) {
#line 122
          buf->a = (output + size) + 2UL * uv_size;
        }
#line 124
        buf->a_size = (size_t )a_size;
#line 125
        buf->a_stride = a_stride;
      } else {
#line 127
        buf___0 = & buffer->u.RGBA;
#line 128
        buf___0->rgba = output;
#line 129
        buf___0->stride = stride;
#line 130
        buf___0->size = (size_t )size;
      }
    }
  }
  {
#line 133
  __cil_tmp19 = CheckDecBuffer(buffer);
  }
#line 133
  return (__cil_tmp19);
}
}
#line 136 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
enum VP8StatusCode WebPAllocateDecBuffer(int w , int h , WebPDecoderOptions *options ,
                                         WebPDecBuffer *out ) 
{ 
  int cw ;
  int ch ;
  int x ;
  int y ;
  enum VP8StatusCode __cil_tmp9 ;

  {
#line 139
  if (out == (void *)0) {
#line 140
    return ((enum VP8StatusCode )2);
  } else
#line 139
  if (w <= 0) {
#line 140
    return ((enum VP8StatusCode )2);
  } else
#line 139
  if (h <= 0) {
#line 140
    return ((enum VP8StatusCode )2);
  }
#line 142
  if (options != (void *)0) {
#line 143
    if (options->use_cropping) {
#line 144
      cw = options->crop_width;
#line 145
      ch = options->crop_height;
#line 146
      x = options->crop_left & -2;
#line 147
      y = options->crop_top & -2;
#line 148
      if (x < 0) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (y < 0) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (cw <= 0) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (ch <= 0) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (x + cw > w) {
#line 149
        return ((enum VP8StatusCode )2);
      } else
#line 148
      if (y + ch > h) {
#line 149
        return ((enum VP8StatusCode )2);
      }
#line 151
      w = cw;
#line 152
      h = ch;
    }
#line 154
    if (options->use_scaling) {
#line 155
      if (options->scaled_width <= 0) {
#line 156
        return ((enum VP8StatusCode )2);
      } else
#line 155
      if (options->scaled_height <= 0) {
#line 156
        return ((enum VP8StatusCode )2);
      }
#line 158
      w = options->scaled_width;
#line 159
      h = options->scaled_height;
    }
  }
  {
#line 162
  out->width = w;
#line 163
  out->height = h;
#line 166
  __cil_tmp9 = AllocateBuffer(out);
  }
#line 166
  return (__cil_tmp9);
}
}
#line 172 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
int WebPInitDecBufferInternal(WebPDecBuffer *buffer , int version ) 
{ 


  {
#line 173
  if (version >> 8 != 513 >> 8) {
#line 174
    return (0);
  }
#line 176
  if (buffer == (void *)0) {
#line 176
    return (0);
  }
  {
#line 177
  memset(buffer, 0, sizeof(*buffer));
  }
#line 178
  return (1);
}
}
#line 181 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
void WebPFreeDecBuffer(WebPDecBuffer *buffer ) 
{ 


  {
#line 182
  if (buffer != (void *)0) {
#line 183
    if (! buffer->is_external_memory) {
      {
#line 184
      free(buffer->private_memory);
      }
    }
#line 185
    buffer->private_memory = (uint8_t *)((void *)0);
  }
  return;
}
}
#line 189 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
void WebPCopyDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) 
{ 


  {
#line 191
  if (src != (void *)0) {
#line 191
    if (dst != (void *)0) {
#line 192
      *dst = *src;
#line 193
      if (src->private_memory != (void *)0) {
#line 194
        dst->is_external_memory = 1;
#line 195
        dst->private_memory = (uint8_t *)((void *)0);
      }
    }
  }
  return;
}
}
#line 201 "/doner/libwebp/libwebp-v0.3.0/src/dec/buffer.c"
void WebPGrabDecBuffer(WebPDecBuffer *src , WebPDecBuffer *dst ) 
{ 


  {
#line 202
  if (src != (void *)0) {
#line 202
    if (dst != (void *)0) {
#line 203
      *dst = *src;
#line 204
      if (src->private_memory != (void *)0) {
#line 205
        src->is_external_memory = 1;
#line 206
        src->private_memory = (uint8_t *)((void *)0);
      }
    }
  }
  return;
}
}
#line 28 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
static uint32_t kHashMul___13  =    (uint32_t )506832829;
#line 36 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static void VP8LColorCacheInsert___13(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 38
  key = kHashMul___13 * argb >> cc->hash_shift_;
#line 39
  *(cc->colors_ + key) = argb;
  return;
}
}
#line 42 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheGetIndex___13(VP8LColorCache *cc , uint32_t argb ) 
{ 


  {
#line 44
  return ((int )(kHashMul___13 * argb >> cc->hash_shift_));
}
}
#line 47 "/doner/libwebp/libwebp-v0.3.0/src/dec/././../utils/color_cache.h"
__inline static int VP8LColorCacheContains___13(VP8LColorCache *cc , uint32_t argb ) 
{ 
  uint32_t key ;

  {
#line 49
  key = kHashMul___13 * argb >> cc->hash_shift_;
#line 50
  return (*(cc->colors_ + key) == argb);
}
}
#line 24 "/doner/libwebp/libwebp-v0.3.0/src/dec/alpha.c"
static void CopyPlane___1(uint8_t *src , int src_stride , uint8_t *dst , int dst_stride ,
                          int width , int height ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    __cil_tmp7 = height;
#line 26
    height --;
#line 26
    if (! (__cil_tmp7 > 0)) {
#line 26
      goto while_break;
    }
    {
#line 27
    memcpy(dst, src, (unsigned long )width);
#line 28
    src += src_stride;
#line 29
    dst += dst_stride;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 43 "/doner/libwebp/libwebp-v0.3.0/src/dec/alpha.c"
static int DecodeAlpha(uint8_t *data , size_t data_size , int width , int height ,
                       int stride , uint8_t *output ) 
{ 
  uint8_t *decoded_data ;
  size_t decoded_size ;
  WEBP_FILTER_TYPE filter ;
  int pre_processing ;
  int rsrv ;
  int ok ;
  int method ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;
  WebPUnfilterFunc unfilter_func ;
  int __cil_tmp19 ;

  {
#line 45
  decoded_data = (uint8_t *)((void *)0);
#line 46
  decoded_size = (size_t )(height * width);
#line 50
  ok = 0;
#line 56
  if (data_size <= 1UL) {
#line 57
    return (0);
  }
#line 60
  method = (int )*(data + 0) & 3;
#line 61
  filter = (WEBP_FILTER_TYPE )(((int )*(data + 0) >> 2) & 3);
#line 62
  pre_processing = ((int )*(data + 0) >> 4) & 3;
#line 63
  rsrv = ((int )*(data + 0) >> 6) & 3;
#line 64
  if (method < 0) {
#line 69
    return (0);
  } else
#line 64
  if (method > 1) {
#line 69
    return (0);
  } else
#line 64
  if ((unsigned int )filter >= 4U) {
#line 69
    return (0);
  } else
#line 64
  if (pre_processing > 1) {
#line 69
    return (0);
  } else
#line 64
  if (rsrv != 0) {
#line 69
    return (0);
  }
#line 72
  if (method == 0) {
#line 73
    ok = data_size >= decoded_size;
#line 74
    decoded_data = (uint8_t *)data + 1;
  } else {
    {
#line 76
    __cil_tmp16 = malloc(decoded_size);
#line 76
    decoded_data = (uint8_t *)__cil_tmp16;
    }
#line 77
    if (decoded_data == (void *)0) {
#line 77
      return (0);
    }
    {
#line 78
    ok = VP8LDecodeAlphaImageStream(width, height, data + 1, data_size - 1UL, decoded_data);
    }
  }
#line 84
  if (ok) {
#line 85
    unfilter_func = WebPUnfilters[filter];
#line 86
    if (unfilter_func != (void *)0) {
      {
#line 89
      (*unfilter_func)(width, height, width, decoded_data);
      }
    }
    {
#line 92
    CopyPlane___1(decoded_data, width, output, stride, width, height);
    }
#line 93
    if (pre_processing == 1) {
      {
#line 94
      ok = DequantizeLevels(decoded_data, width, height);
      }
    }
  }
#line 98
  if (method != 0) {
    {
#line 99
    free(decoded_data);
    }
  }
#line 101
  return (ok);
}
}
#line 106 "/doner/libwebp/libwebp-v0.3.0/src/dec/alpha.c"
uint8_t *VP8DecompressAlphaRows(VP8Decoder *dec , int row , int num_rows ) 
{ 
  int stride ;
  int __cil_tmp5 ;

  {
#line 108
  stride = (int )dec->pic_hdr_.width_;
#line 110
  if (row < 0) {
#line 111
    return ((uint8_t *)((void *)0));
  } else
#line 110
  if (num_rows < 0) {
#line 111
    return ((uint8_t *)((void *)0));
  } else
#line 110
  if (row + num_rows > (int )dec->pic_hdr_.height_) {
#line 111
    return ((uint8_t *)((void *)0));
  }
#line 114
  if (row == 0) {
    {
#line 116
    __cil_tmp5 = DecodeAlpha(dec->alpha_data_, (size_t )dec->alpha_data_size_, (int )dec->pic_hdr_.width_,
                             (int )dec->pic_hdr_.height_, stride, dec->alpha_plane_);
    }
#line 116
    if (! __cil_tmp5) {
#line 119
      return ((uint8_t *)((void *)0));
    }
  }
#line 124
  return (dec->alpha_plane_ + row * stride);
}
}
#line 24 "/doner/libwebp/libwebp-v0.3.0/examples/./wicdec.h"
int ReadPictureWithWIC(char const   *filename , struct WebPPicture *pic , int keep_alpha ,
                       struct Metadata *metadata ) ;
#line 331 "/doner/libwebp/libwebp-v0.3.0/examples/wicdec.c"
int ReadPictureWithWIC(char const   *filename , struct WebPPicture *pic , int keep_alpha ,
                       struct Metadata *metadata ) 
{ 


  {
  {
#line 338
  fprintf(stderr, "Windows Imaging Component (WIC) support not compiled. Visual Studio and mingw-w64 builds support WIC. Make sure wincodec.h detection is working correctly if using autoconf and HAVE_WINCODEC_H is defined before building.\n\220");
  }
#line 342
  return (0);
}
}
#line 24 "/doner/libwebp/libwebp-v0.3.0/examples/./tiffdec.h"
int ReadTIFF(char const   *filename , WebPPicture *pic , int keep_alpha , Metadata *metadata ) ;
#line 281 "/usr/include/x86_64-linux-gnu/tiffio.h"
extern char const   *TIFFGetVersion(void) ;
#line 283
extern TIFFCodec *TIFFFindCODEC(uint16  ) ;
#line 284
extern TIFFCodec *TIFFRegisterCODEC(uint16  , char const   * , TIFFInitMethod  ) ;
#line 285
extern void TIFFUnRegisterCODEC(TIFFCodec * ) ;
#line 286
extern int TIFFIsCODECConfigured(uint16  ) ;
#line 287
extern TIFFCodec *TIFFGetConfiguredCODECs(void) ;
#line 293
extern void *_TIFFmalloc(tmsize_t s ) ;
#line 294
extern void *_TIFFcalloc(tmsize_t nmemb , tmsize_t siz ) ;
#line 295
extern void *_TIFFrealloc(void *p , tmsize_t s ) ;
#line 296
extern void _TIFFmemset(void *p , int v , tmsize_t c ) ;
#line 297
extern void _TIFFmemcpy(void *d , void const   *s , tmsize_t c ) ;
#line 298
extern int _TIFFmemcmp(void const   *p1 , void const   *p2 , tmsize_t c ) ;
#line 299
extern void _TIFFfree(void *p ) ;
#line 304
extern int TIFFGetTagListCount(TIFF * ) ;
#line 305
extern uint32 TIFFGetTagListEntry(TIFF * , int tag_index ) ;
#line 317
extern TIFFField *TIFFFindField(TIFF * , uint32  , TIFFDataType  ) ;
#line 318
extern TIFFField *TIFFFieldWithTag(TIFF * , uint32  ) ;
#line 319
extern TIFFField *TIFFFieldWithName(TIFF * , char const   * ) ;
#line 321
extern uint32 TIFFFieldTag(TIFFField * ) ;
#line 322
extern char const   *TIFFFieldName(TIFFField * ) ;
#line 323
extern TIFFDataType TIFFFieldDataType(TIFFField * ) ;
#line 324
extern int TIFFFieldPassCount(TIFFField * ) ;
#line 325
extern int TIFFFieldReadCount(TIFFField * ) ;
#line 326
extern int TIFFFieldWriteCount(TIFFField * ) ;
#line 338
extern TIFFTagMethods *TIFFAccessTagMethods(TIFF * ) ;
#line 339
extern void *TIFFGetClientInfo(TIFF * , char const   * ) ;
#line 340
extern void TIFFSetClientInfo(TIFF * , void * , char const   * ) ;
#line 342
extern void TIFFCleanup(TIFF *tif ) ;
#line 343
extern void TIFFClose(TIFF *tif ) ;
#line 344
extern int TIFFFlush(TIFF *tif ) ;
#line 345
extern int TIFFFlushData(TIFF *tif ) ;
#line 346
extern int TIFFGetField(TIFF *tif , uint32 tag  , ...) ;
#line 347
extern int TIFFVGetField(TIFF *tif , uint32 tag , va_list ap ) ;
#line 348
extern int TIFFGetFieldDefaulted(TIFF *tif , uint32 tag  , ...) ;
#line 349
extern int TIFFVGetFieldDefaulted(TIFF *tif , uint32 tag , va_list ap ) ;
#line 350
extern int TIFFReadDirectory(TIFF *tif ) ;
#line 351
extern int TIFFReadCustomDirectory(TIFF *tif , toff_t diroff , TIFFFieldArray *infoarray ) ;
#line 352
extern int TIFFReadEXIFDirectory(TIFF *tif , toff_t diroff ) ;
#line 353
extern uint64 TIFFScanlineSize64(TIFF *tif ) ;
#line 354
extern tmsize_t TIFFScanlineSize(TIFF *tif ) ;
#line 355
extern uint64 TIFFRasterScanlineSize64(TIFF *tif ) ;
#line 356
extern tmsize_t TIFFRasterScanlineSize(TIFF *tif ) ;
#line 357
extern uint64 TIFFStripSize64(TIFF *tif ) ;
#line 358
extern tmsize_t TIFFStripSize(TIFF *tif ) ;
#line 359
extern uint64 TIFFRawStripSize64(TIFF *tif , uint32 strip ) ;
#line 360
extern tmsize_t TIFFRawStripSize(TIFF *tif , uint32 strip ) ;
#line 361
extern uint64 TIFFVStripSize64(TIFF *tif , uint32 nrows ) ;
#line 362
extern tmsize_t TIFFVStripSize(TIFF *tif , uint32 nrows ) ;
#line 363
extern uint64 TIFFTileRowSize64(TIFF *tif ) ;
#line 364
extern tmsize_t TIFFTileRowSize(TIFF *tif ) ;
#line 365
extern uint64 TIFFTileSize64(TIFF *tif ) ;
#line 366
extern tmsize_t TIFFTileSize(TIFF *tif ) ;
#line 367
extern uint64 TIFFVTileSize64(TIFF *tif , uint32 nrows ) ;
#line 368
extern tmsize_t TIFFVTileSize(TIFF *tif , uint32 nrows ) ;
#line 369
extern uint32 TIFFDefaultStripSize(TIFF *tif , uint32 request ) ;
#line 370
extern void TIFFDefaultTileSize(TIFF * , uint32 * , uint32 * ) ;
#line 371
extern int TIFFFileno(TIFF * ) ;
#line 372
extern int TIFFSetFileno(TIFF * , int  ) ;
#line 373
extern thandle_t TIFFClientdata(TIFF * ) ;
#line 374
extern thandle_t TIFFSetClientdata(TIFF * , thandle_t  ) ;
#line 375
extern int TIFFGetMode(TIFF * ) ;
#line 376
extern int TIFFSetMode(TIFF * , int  ) ;
#line 377
extern int TIFFIsTiled(TIFF * ) ;
#line 378
extern int TIFFIsByteSwapped(TIFF * ) ;
#line 379
extern int TIFFIsUpSampled(TIFF * ) ;
#line 380
extern int TIFFIsMSB2LSB(TIFF * ) ;
#line 381
extern int TIFFIsBigEndian(TIFF * ) ;
#line 382
extern TIFFReadWriteProc TIFFGetReadProc(TIFF * ) ;
#line 383
extern TIFFReadWriteProc TIFFGetWriteProc(TIFF * ) ;
#line 384
extern TIFFSeekProc TIFFGetSeekProc(TIFF * ) ;
#line 385
extern TIFFCloseProc TIFFGetCloseProc(TIFF * ) ;
#line 386
extern TIFFSizeProc TIFFGetSizeProc(TIFF * ) ;
#line 387
extern TIFFMapFileProc TIFFGetMapFileProc(TIFF * ) ;
#line 388
extern TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF * ) ;
#line 389
extern uint32 TIFFCurrentRow(TIFF * ) ;
#line 390
extern uint16 TIFFCurrentDirectory(TIFF * ) ;
#line 391
extern uint16 TIFFNumberOfDirectories(TIFF * ) ;
#line 392
extern uint64 TIFFCurrentDirOffset(TIFF * ) ;
#line 393
extern uint32 TIFFCurrentStrip(TIFF * ) ;
#line 394
extern uint32 TIFFCurrentTile(TIFF *tif ) ;
#line 395
extern int TIFFReadBufferSetup(TIFF *tif , void *bp , tmsize_t size ) ;
#line 396
extern int TIFFWriteBufferSetup(TIFF *tif , void *bp , tmsize_t size ) ;
#line 397
extern int TIFFSetupStrips(TIFF * ) ;
#line 398
extern int TIFFWriteCheck(TIFF * , int  , char const   * ) ;
#line 399
extern void TIFFFreeDirectory(TIFF * ) ;
#line 400
extern int TIFFCreateDirectory(TIFF * ) ;
#line 401
extern int TIFFCreateCustomDirectory(TIFF * , TIFFFieldArray * ) ;
#line 402
extern int TIFFCreateEXIFDirectory(TIFF * ) ;
#line 403
extern int TIFFLastDirectory(TIFF * ) ;
#line 404
extern int TIFFSetDirectory(TIFF * , uint16  ) ;
#line 405
extern int TIFFSetSubDirectory(TIFF * , uint64  ) ;
#line 406
extern int TIFFUnlinkDirectory(TIFF * , uint16  ) ;
#line 407
extern int TIFFSetField(TIFF * , uint32   , ...) ;
#line 408
extern int TIFFVSetField(TIFF * , uint32  , va_list  ) ;
#line 409
extern int TIFFUnsetField(TIFF * , uint32  ) ;
#line 410
extern int TIFFWriteDirectory(TIFF * ) ;
#line 411
extern int TIFFWriteCustomDirectory(TIFF * , uint64 * ) ;
#line 412
extern int TIFFCheckpointDirectory(TIFF * ) ;
#line 413
extern int TIFFRewriteDirectory(TIFF * ) ;
#line 414
extern int TIFFDeferStrileArrayWriting(TIFF * ) ;
#line 415
extern int TIFFForceStrileArrayWriting(TIFF * ) ;
#line 425
extern void TIFFPrintDirectory(TIFF * , FILE * , long  ) ;
#line 426
extern int TIFFReadScanline(TIFF *tif , void *buf , uint32 row , uint16 sample ) ;
#line 427
extern int TIFFWriteScanline(TIFF *tif , void *buf , uint32 row , uint16 sample ) ;
#line 428
extern int TIFFReadRGBAImage(TIFF * , uint32  , uint32  , uint32 * , int  ) ;
#line 429
extern int TIFFReadRGBAImageOriented(TIFF * , uint32  , uint32  , uint32 * , int  ,
                                     int  ) ;
#line 432
extern int TIFFReadRGBAStrip(TIFF * , uint32  , uint32 * ) ;
#line 433
extern int TIFFReadRGBATile(TIFF * , uint32  , uint32  , uint32 * ) ;
#line 434
extern int TIFFReadRGBAStripExt(TIFF * , uint32  , uint32 * , int stop_on_error ) ;
#line 435
extern int TIFFReadRGBATileExt(TIFF * , uint32  , uint32  , uint32 * , int stop_on_error ) ;
#line 436
extern int TIFFRGBAImageOK(TIFF * , char [1024] ) ;
#line 437
extern int TIFFRGBAImageBegin(TIFFRGBAImage * , TIFF * , int  , char [1024] ) ;
#line 438
extern int TIFFRGBAImageGet(TIFFRGBAImage * , uint32 * , uint32  , uint32  ) ;
#line 439
extern void TIFFRGBAImageEnd(TIFFRGBAImage * ) ;
#line 440
extern TIFF *TIFFOpen(char const   * , char const   * ) ;
#line 444
extern TIFF *TIFFFdOpen(int  , char const   * , char const   * ) ;
#line 445
extern TIFF *TIFFClientOpen(char const   * , char const   * , thandle_t  , TIFFReadWriteProc  ,
                            TIFFReadWriteProc  , TIFFSeekProc  , TIFFCloseProc  ,
                            TIFFSizeProc  , TIFFMapFileProc  , TIFFUnmapFileProc  ) ;
#line 451
extern char const   *TIFFFileName(TIFF * ) ;
#line 452
extern char const   *TIFFSetFileName(TIFF * , char const   * ) ;
#line 453
extern void TIFFError(char const   * , char const   *  , ...) ;
#line 454
extern void TIFFErrorExt(thandle_t  , char const   * , char const   *  , ...) ;
#line 455
extern void TIFFWarning(char const   * , char const   *  , ...) ;
#line 456
extern void TIFFWarningExt(thandle_t  , char const   * , char const   *  , ...) ;
#line 457
extern TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler  ) ;
#line 458
extern TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt  ) ;
#line 459
extern TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler  ) ;
#line 460
extern TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt  ) ;
#line 461
extern TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc  ) ;
#line 462
extern uint32 TIFFComputeTile(TIFF *tif , uint32 x , uint32 y , uint32 z , uint16 s ) ;
#line 463
extern int TIFFCheckTile(TIFF *tif , uint32 x , uint32 y , uint32 z , uint16 s ) ;
#line 464
extern uint32 TIFFNumberOfTiles(TIFF * ) ;
#line 465
extern tmsize_t TIFFReadTile(TIFF *tif , void *buf , uint32 x , uint32 y , uint32 z ,
                             uint16 s ) ;
#line 466
extern tmsize_t TIFFWriteTile(TIFF *tif , void *buf , uint32 x , uint32 y , uint32 z ,
                              uint16 s ) ;
#line 467
extern uint32 TIFFComputeStrip(TIFF * , uint32  , uint16  ) ;
#line 468
extern uint32 TIFFNumberOfStrips(TIFF * ) ;
#line 469
extern tmsize_t TIFFReadEncodedStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 470
extern tmsize_t TIFFReadRawStrip(TIFF *tif , uint32 strip , void *buf , tmsize_t size ) ;
#line 471
extern tmsize_t TIFFReadEncodedTile(TIFF *tif , uint32 tile , void *buf , tmsize_t size ) ;
#line 472
extern tmsize_t TIFFReadRawTile(TIFF *tif , uint32 tile , void *buf , tmsize_t size ) ;
#line 473
extern int TIFFReadFromUserBuffer(TIFF *tif , uint32 strile , void *inbuf , tmsize_t insize ,
                                  void *outbuf , tmsize_t outsize ) ;
#line 476
extern tmsize_t TIFFWriteEncodedStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 477
extern tmsize_t TIFFWriteRawStrip(TIFF *tif , uint32 strip , void *data , tmsize_t cc ) ;
#line 478
extern tmsize_t TIFFWriteEncodedTile(TIFF *tif , uint32 tile , void *data , tmsize_t cc ) ;
#line 479
extern tmsize_t TIFFWriteRawTile(TIFF *tif , uint32 tile , void *data , tmsize_t cc ) ;
#line 480
extern int TIFFDataWidth(TIFFDataType  ) ;
#line 481
extern void TIFFSetWriteOffset(TIFF *tif , toff_t off ) ;
#line 482
extern void TIFFSwabShort(uint16 * ) ;
#line 483
extern void TIFFSwabLong(uint32 * ) ;
#line 484
extern void TIFFSwabLong8(uint64 * ) ;
#line 485
extern void TIFFSwabFloat(float * ) ;
#line 486
extern void TIFFSwabDouble(double * ) ;
#line 487
extern void TIFFSwabArrayOfShort(uint16 *wp , tmsize_t n ) ;
#line 488
extern void TIFFSwabArrayOfTriples(uint8 *tp , tmsize_t n ) ;
#line 489
extern void TIFFSwabArrayOfLong(uint32 *lp , tmsize_t n ) ;
#line 490
extern void TIFFSwabArrayOfLong8(uint64 *lp , tmsize_t n ) ;
#line 491
extern void TIFFSwabArrayOfFloat(float *fp , tmsize_t n ) ;
#line 492
extern void TIFFSwabArrayOfDouble(double *dp , tmsize_t n ) ;
#line 493
extern void TIFFReverseBits(uint8 *cp , tmsize_t n ) ;
#line 494
extern unsigned char const   *TIFFGetBitRevTable(int  ) ;
#line 496
extern uint64 TIFFGetStrileOffset(TIFF *tif , uint32 strile ) ;
#line 497
extern uint64 TIFFGetStrileByteCount(TIFF *tif , uint32 strile ) ;
#line 498
extern uint64 TIFFGetStrileOffsetWithErr(TIFF *tif , uint32 strile , int *pbErr ) ;
#line 499
extern uint64 TIFFGetStrileByteCountWithErr(TIFF *tif , uint32 strile , int *pbErr ) ;
#line 505
extern double LogL16toY(int  ) ;
#line 506
extern double LogL10toY(int  ) ;
#line 507
extern void XYZtoRGB24(float * , uint8 * ) ;
#line 508
extern int uv_decode(double * , double * , int  ) ;
#line 509
extern void LogLuv24toXYZ(uint32  , float * ) ;
#line 510
extern void LogLuv32toXYZ(uint32  , float * ) ;
#line 518
extern int LogL16fromY(double  , int  ) ;
#line 519
extern int LogL10fromY(double  , int  ) ;
#line 520
extern int uv_encode(double  , double  , int  ) ;
#line 521
extern uint32 LogLuv24fromXYZ(float * , int  ) ;
#line 522
extern uint32 LogLuv32fromXYZ(float * , int  ) ;
#line 526
extern int TIFFCIELabToRGBInit(TIFFCIELabToRGB * , TIFFDisplay * , float * ) ;
#line 527
extern void TIFFCIELabToXYZ(TIFFCIELabToRGB * , uint32  , int32  , int32  , float * ,
                            float * , float * ) ;
#line 529
extern void TIFFXYZToRGB(TIFFCIELabToRGB * , float  , float  , float  , uint32 * ,
                         uint32 * , uint32 * ) ;
#line 532
extern int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB * , float * , float * ) ;
#line 533
extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB * , uint32  , int32  , int32  , uint32 * ,
                           uint32 * , uint32 * ) ;
#line 553
extern int TIFFMergeFieldInfo(TIFF * , TIFFFieldInfo [] , uint32  ) ;
#line 33 "/doner/libwebp/libwebp-v0.3.0/examples/./metadata.h"
void MetadataInit(Metadata *metadata ) ;
#line 34
void MetadataPayloadDelete(MetadataPayload *payload ) ;
#line 35
void MetadataFree(Metadata *metadata ) ;
#line 38
int MetadataCopy(char const   *metadata , size_t metadata_len , MetadataPayload *payload ) ;
#line 27 "/doner/libwebp/libwebp-v0.3.0/examples/tiffdec.c"
static struct __anonstruct_879 kTIFFMetadataMap[3]  = {      {(ttag_t )34675, 0}, 
        {(ttag_t )700, 0}, 
        {(ttag_t )0, (size_t )0}};
#line 35 "/doner/libwebp/libwebp-v0.3.0/examples/tiffdec.c"
static int ExtractMetadataFromTIFF(TIFF *tif , Metadata *metadata ) 
{ 
  int i ;
  toff_t exif_ifd_offset ;
  MetadataPayload *payload ;
  void *tag_data ;
  uint32 tag_data_len ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 39
  i = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (kTIFFMetadataMap[i].tag != 0U)) {
#line 39
      goto while_break;
    }
    {
#line 40
    payload = (MetadataPayload *)((uint8_t *)metadata + kTIFFMetadataMap[i].storage_offset);
#line 46
    __cil_tmp9 = MetadataCopy((char const   *)tag_data, (size_t )tag_data_len, payload);
    }
    {
#line 46
    __cil_tmp8 = TIFFGetField(tif, kTIFFMetadataMap[i].tag, & tag_data_len, & tag_data);
    }
#line 46
    if (__cil_tmp8) {
#line 46
      if (! __cil_tmp9) {
#line 48
        return (0);
      }
    }
#line 39
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  __cil_tmp10 = TIFFGetField(tif, (uint32 )34665, & exif_ifd_offset);
  }
#line 58
  if (__cil_tmp10) {
    {
#line 59
    fprintf(stderr, "Warning: EXIF extraction from TIFF is unsupported.\n");
    }
  }
#line 61
  return (1);
}
}
#line 64 "/doner/libwebp/libwebp-v0.3.0/examples/tiffdec.c"
int ReadTIFF(char const   *filename , WebPPicture *pic , int keep_alpha , Metadata *metadata ) 
{ 
  TIFF *tif ;
  TIFF *__cil_tmp6 ;
  uint32 width ;
  uint32 height ;
  uint32 *raster ;
  int ok ;
  tdir_t dircount ;
  uint16 __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  int stride ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  int __cil_tmp21 ;

  {
  {
#line 67
  __cil_tmp6 = TIFFOpen(filename, "r");
#line 67
  tif = __cil_tmp6;
#line 70
  ok = 0;
  }
#line 73
  if (tif == (void *)0) {
    {
#line 74
    fprintf(stderr, "Error! Cannot open TIFF file \'%s\'\n\026\215rU", filename);
    }
#line 75
    return (0);
  }
  {
#line 78
  dircount = TIFFNumberOfDirectories(tif);
  }
#line 79
  if ((int )dircount > 1) {
    {
#line 80
    fprintf(stderr, "Warning: multi-directory TIFF files are not supported.\nOnly the first will be used, %d will be ignored.\nrU",
            (int )dircount - 1);
    }
  }
  {
#line 85
  __cil_tmp14 = TIFFGetField(tif, (uint32 )257, & height);
  }
  {
#line 85
  __cil_tmp13 = TIFFGetField(tif, (uint32 )256, & width);
  }
#line 85
  if (! (__cil_tmp13 && __cil_tmp14)) {
    {
#line 87
    fprintf(stderr, "Error! Cannot retrieve TIFF image dimensions.\n");
    }
#line 88
    return (0);
  }
  {
#line 90
  __cil_tmp15 = _TIFFmalloc((tmsize_t )((unsigned long )(width * height) * sizeof(*raster)));
#line 90
  raster = (uint32 *)__cil_tmp15;
  }
#line 91
  if (raster != (void *)0) {
    {
#line 92
    __cil_tmp16 = TIFFReadRGBAImageOriented(tif, width, height, raster, 1, 1);
    }
#line 92
    if (__cil_tmp16) {
#line 94
      stride = (int )((unsigned long )width * sizeof(*raster));
#line 95
      pic->width = (int )width;
#line 96
      pic->height = (int )height;
#line 101
      if (keep_alpha) {
        {
#line 101
        __cil_tmp18 = WebPPictureImportRGBA(pic, (uint8_t *)raster, stride);
#line 101
        tmp = __cil_tmp18;
        }
      } else {
        {
#line 101
        __cil_tmp19 = WebPPictureImportRGBX(pic, (uint8_t *)raster, stride);
#line 101
        tmp = __cil_tmp19;
        }
      }
#line 101
      ok = tmp;
    }
    {
#line 105
    _TIFFfree(raster);
    }
  } else {
    {
#line 107
    fprintf(stderr, "Error allocating TIFF RGBA memory!\n");
    }
  }
#line 110
  if (ok) {
#line 111
    if (metadata != (void *)0) {
      {
#line 112
      ok = ExtractMetadataFromTIFF(tif, metadata);
      }
#line 113
      if (! ok) {
        {
#line 114
        fprintf(stderr, "Error extracting TIFF metadata!\n\220");
#line 115
        MetadataFree(metadata);
#line 116
        WebPPictureFree(pic);
        }
      }
    }
  }
  {
#line 121
  TIFFClose(tif);
  }
#line 122
  return (ok);
}
}
#line 26 "/doner/libwebp/libwebp-v0.3.0/examples/./pngdec.h"
int ReadPNG(FILE *in_file , struct WebPPicture *pic , int keep_alpha , struct Metadata *metadata ) ;
#line 282 "/doner/libwebp/libwebp-v0.3.0/examples/pngdec.c"
int ReadPNG(FILE *in_file , struct WebPPicture *pic , int keep_alpha , struct Metadata *metadata ) 
{ 


  {
  {
#line 288
  fprintf(stderr, "PNG support not compiled. Please install the libpng development package before building.\n");
  }
#line 290
  return (0);
}
}
#line 26 "/doner/libwebp/libwebp-v0.3.0/examples/./jpegdec.h"
int ReadJPEG(FILE *in_file , WebPPicture *pic , Metadata *metadata ) ;
#line 891 "/usr/include/jpeglib.h"
extern struct jpeg_error_mgr *jpeg_std_error(struct jpeg_error_mgr *err ) ;
#line 906
extern void jpeg_CreateCompress(j_compress_ptr cinfo , int version , size_t structsize ) ;
#line 908
extern void jpeg_CreateDecompress(j_decompress_ptr cinfo , int version , size_t structsize ) ;
#line 911
extern void jpeg_destroy_compress(j_compress_ptr cinfo ) ;
#line 912
extern void jpeg_destroy_decompress(j_decompress_ptr cinfo ) ;
#line 916
extern void jpeg_stdio_dest(j_compress_ptr cinfo , FILE *outfile ) ;
#line 917
extern void jpeg_stdio_src(j_decompress_ptr cinfo , FILE *infile ) ;
#line 921
extern void jpeg_mem_dest(j_compress_ptr cinfo , unsigned char **outbuffer , unsigned long *outsize ) ;
#line 923
extern void jpeg_mem_src(j_decompress_ptr cinfo , unsigned char const   *inbuffer ,
                         unsigned long insize ) ;
#line 928
extern void jpeg_set_defaults(j_compress_ptr cinfo ) ;
#line 930
extern void jpeg_set_colorspace(j_compress_ptr cinfo , J_COLOR_SPACE colorspace ) ;
#line 932
extern void jpeg_default_colorspace(j_compress_ptr cinfo ) ;
#line 933
extern void jpeg_set_quality(j_compress_ptr cinfo , int quality , boolean force_baseline ) ;
#line 935
extern void jpeg_set_linear_quality(j_compress_ptr cinfo , int scale_factor , boolean force_baseline ) ;
#line 938
extern void jpeg_default_qtables(j_compress_ptr cinfo , boolean force_baseline ) ;
#line 941
extern void jpeg_add_quant_table(j_compress_ptr cinfo , int which_tbl , unsigned int const   *basic_table ,
                                 int scale_factor , boolean force_baseline ) ;
#line 944
extern int jpeg_quality_scaling(int quality ) ;
#line 945
extern void jpeg_simple_progression(j_compress_ptr cinfo ) ;
#line 946
extern void jpeg_suppress_tables(j_compress_ptr cinfo , boolean suppress ) ;
#line 947
extern JQUANT_TBL *jpeg_alloc_quant_table(j_common_ptr cinfo ) ;
#line 948
extern JHUFF_TBL *jpeg_alloc_huff_table(j_common_ptr cinfo ) ;
#line 951
extern void jpeg_start_compress(j_compress_ptr cinfo , boolean write_all_tables ) ;
#line 953
extern JDIMENSION jpeg_write_scanlines(j_compress_ptr cinfo , JSAMPARRAY scanlines ,
                                       JDIMENSION num_lines ) ;
#line 956
extern void jpeg_finish_compress(j_compress_ptr cinfo ) ;
#line 960
extern void jpeg_calc_jpeg_dimensions(j_compress_ptr cinfo ) ;
#line 964
extern JDIMENSION jpeg_write_raw_data(j_compress_ptr cinfo , JSAMPIMAGE data , JDIMENSION num_lines ) ;
#line 968
extern void jpeg_write_marker(j_compress_ptr cinfo , int marker , JOCTET *dataptr ,
                              unsigned int datalen ) ;
#line 971
extern void jpeg_write_m_header(j_compress_ptr cinfo , int marker , unsigned int datalen ) ;
#line 973
extern void jpeg_write_m_byte(j_compress_ptr cinfo , int val ) ;
#line 976
extern void jpeg_write_tables(j_compress_ptr cinfo ) ;
#line 979
extern void jpeg_write_icc_profile(j_compress_ptr cinfo , JOCTET *icc_data_ptr , unsigned int icc_data_len ) ;
#line 985
extern int jpeg_read_header(j_decompress_ptr cinfo , boolean require_image ) ;
#line 997
extern boolean jpeg_start_decompress(j_decompress_ptr cinfo ) ;
#line 998
extern JDIMENSION jpeg_read_scanlines(j_decompress_ptr cinfo , JSAMPARRAY scanlines ,
                                      JDIMENSION max_lines ) ;
#line 1001
extern JDIMENSION jpeg_skip_scanlines(j_decompress_ptr cinfo , JDIMENSION num_lines ) ;
#line 1003
extern void jpeg_crop_scanline(j_decompress_ptr cinfo , JDIMENSION *xoffset , JDIMENSION *width ) ;
#line 1005
extern boolean jpeg_finish_decompress(j_decompress_ptr cinfo ) ;
#line 1008
extern JDIMENSION jpeg_read_raw_data(j_decompress_ptr cinfo , JSAMPIMAGE data , JDIMENSION max_lines ) ;
#line 1012
extern boolean jpeg_has_multiple_scans(j_decompress_ptr cinfo ) ;
#line 1013
extern boolean jpeg_start_output(j_decompress_ptr cinfo , int scan_number ) ;
#line 1014
extern boolean jpeg_finish_output(j_decompress_ptr cinfo ) ;
#line 1015
extern boolean jpeg_input_complete(j_decompress_ptr cinfo ) ;
#line 1016
extern void jpeg_new_colormap(j_decompress_ptr cinfo ) ;
#line 1017
extern int jpeg_consume_input(j_decompress_ptr cinfo ) ;
#line 1027
extern void jpeg_core_output_dimensions(j_decompress_ptr cinfo ) ;
#line 1029
extern void jpeg_calc_output_dimensions(j_decompress_ptr cinfo ) ;
#line 1032
extern void jpeg_save_markers(j_decompress_ptr cinfo , int marker_code , unsigned int length_limit ) ;
#line 1036
extern void jpeg_set_marker_processor(j_decompress_ptr cinfo , int marker_code , jpeg_marker_parser_method routine ) ;
#line 1041
extern jvirt_barray_ptr *jpeg_read_coefficients(j_decompress_ptr cinfo ) ;
#line 1042
extern void jpeg_write_coefficients(j_compress_ptr cinfo , jvirt_barray_ptr *coef_arrays ) ;
#line 1044
extern void jpeg_copy_critical_parameters(j_decompress_ptr srcinfo , j_compress_ptr dstinfo ) ;
#line 1053
extern void jpeg_abort_compress(j_compress_ptr cinfo ) ;
#line 1054
extern void jpeg_abort_decompress(j_decompress_ptr cinfo ) ;
#line 1059
extern void jpeg_abort(j_common_ptr cinfo ) ;
#line 1060
extern void jpeg_destroy(j_common_ptr cinfo ) ;
#line 1063
extern boolean jpeg_resync_to_restart(j_decompress_ptr cinfo , int desired ) ;
#line 1066
extern boolean jpeg_read_icc_profile(j_decompress_ptr cinfo , JOCTET **icc_data_ptr ,
                                     unsigned int *icc_data_len ) ;
#line 49 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int setjmp(jmp_buf __env ) ;
#line 58
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag __env[1] ) ;
#line 67
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag __env[1] ,
                                                  int __val ) ;
#line 74
extern  __attribute__((__nothrow__)) void _longjmp(struct __jmp_buf_tag __env[1] ,
                                                   int __val ) ;
#line 93
extern  __attribute__((__nothrow__)) void siglongjmp(struct __jmp_buf_tag __env[1] ,
                                                     int __val ) ;
#line 43 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
static void SaveMetadataMarkers(j_decompress_ptr dinfo ) 
{ 
  unsigned int max_marker_length ;

  {
  {
#line 44
  max_marker_length = (unsigned int )65535;
#line 45
  jpeg_save_markers(dinfo, 225, max_marker_length);
#line 46
  jpeg_save_markers(dinfo, 226, max_marker_length);
  }
  return;
}
}
#line 49 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
static int CompareICCPSegments(void const   *a , void const   *b ) 
{ 
  ICCPSegment *s1 ;
  ICCPSegment *s2 ;

  {
#line 50
  s1 = (ICCPSegment *)a;
#line 51
  s2 = (ICCPSegment *)b;
#line 52
  return (s1->seq - s2->seq);
}
}
#line 58 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
static int StoreICCP(j_decompress_ptr dinfo , MetadataPayload *iccp ) 
{ 
  static char const   kICCPSignature[12] ;
  static size_t kICCPSignatureLength ;
  static size_t kICCPSkipLength ;
  int expected_count ;
  int actual_count ;
  int seq_max ;
  size_t total_size ;
  ICCPSegment iccp_segments[255] ;
  jpeg_saved_marker_ptr marker ;
  int __cil_tmp12 ;
  int seq ;
  int count ;
  size_t segment_size ;
  ICCPSegment *segment ;
  void *__cil_tmp17 ;
  int i ;
  size_t offset ;

  {
  {
#line 60
  kICCPSignature = "ICC_PROFILE";
#line 61
  kICCPSignatureLength = (size_t )12;
#line 62
  kICCPSkipLength = (size_t )14;
#line 63
  expected_count = 0;
#line 64
  actual_count = 0;
#line 65
  seq_max = 0;
#line 66
  total_size = (size_t )0;
#line 70
  memset((ICCPSegment *)iccp_segments, 0, sizeof(iccp_segments));
#line 71
  marker = dinfo->marker_list;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (marker != (void *)0)) {
#line 71
      goto while_break;
    }
    {
#line 72
    __cil_tmp12 = memcmp(marker->data, (char const   *)kICCPSignature, kICCPSignatureLength);
    }
#line 72
    if ((int )marker->marker == 226) {
#line 72
      if ((unsigned long )marker->data_length > kICCPSkipLength) {
#line 72
        if (! __cil_tmp12) {
#line 76
          seq = (int )*(marker->data + kICCPSignatureLength);
#line 77
          count = (int )*(marker->data + (kICCPSignatureLength + 1UL));
#line 78
          segment_size = (unsigned long )marker->data_length - kICCPSkipLength;
#line 81
          if (segment_size == 0UL) {
            {
            {
            {
#line 82
            fprintf(stderr, "[ICCP] size (%d) / count (%d) / sequence number (%d) cannot be 0!\n",
                    (int )segment_size, seq, count);
            }
            }
            }
#line 85
            return (0);
          } else
#line 81
          if (count == 0) {
            {
            {
            {
#line 82
            fprintf(stderr, "[ICCP] size (%d) / count (%d) / sequence number (%d) cannot be 0!\n",
                    (int )segment_size, seq, count);
            }
            }
            }
#line 85
            return (0);
          } else
#line 81
          if (seq == 0) {
            {
            {
            {
#line 82
            fprintf(stderr, "[ICCP] size (%d) / count (%d) / sequence number (%d) cannot be 0!\n",
                    (int )segment_size, seq, count);
            }
            }
            }
#line 85
            return (0);
          }
#line 88
          if (expected_count == 0) {
#line 89
            expected_count = count;
          } else
#line 90
          if (expected_count != count) {
            {
#line 91
            fprintf(stderr, "[ICCP] Inconsistent segment count (%d / %d)!\n", expected_count,
                    count);
            }
#line 93
            return (0);
          }
#line 96
          segment = ((ICCPSegment *)iccp_segments + seq) - 1;
#line 97
          if (segment->data_length != 0UL) {
            {
#line 98
            fprintf(stderr, "[ICCP] Duplicate segment number (%d)!\n", seq);
            }
#line 99
            return (0);
          }
#line 102
          segment->data = marker->data + kICCPSkipLength;
#line 103
          segment->data_length = segment_size;
#line 104
          segment->seq = seq;
#line 105
          total_size += segment_size;
#line 106
          if (seq > seq_max) {
#line 106
            seq_max = seq;
          }
#line 107
          actual_count ++;
        }
      }
    }
#line 71
    marker = marker->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  if (actual_count == 0) {
#line 111
    return (1);
  }
#line 112
  if (seq_max != actual_count) {
    {
#line 113
    fprintf(stderr, "[ICCP] Discontinuous segments, expected: %d actual: %d!\n\230\001",
            actual_count, seq_max);
    }
#line 115
    return (0);
  }
#line 117
  if (expected_count != actual_count) {
    {
#line 118
    fprintf(stderr, "[ICCP] Segment count: %d does not match expected: %d!\n", actual_count,
            expected_count);
    }
#line 120
    return (0);
  }
  {
#line 125
  qsort((ICCPSegment *)iccp_segments, (size_t )actual_count, sizeof(*((ICCPSegment *)iccp_segments)),
        & CompareICCPSegments);
#line 128
  __cil_tmp17 = malloc(total_size);
#line 128
  iccp->bytes = (uint8_t *)__cil_tmp17;
  }
#line 129
  if (iccp->bytes == (void *)0) {
#line 129
    return (0);
  }
#line 130
  iccp->size = total_size;
#line 134
  offset = (size_t )0;
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! (i < seq_max)) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    memcpy(iccp->bytes + offset, iccp_segments[i].data, iccp_segments[i].data_length);
#line 138
    offset += iccp_segments[i].data_length;
    }
#line 135
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 141
  return (1);
}
}
#line 146 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
static int ExtractMetadataFromJPEG(j_decompress_ptr dinfo , Metadata *metadata ) 
{ 
  static struct __anonstruct_907 kJPEGMetadataMap[3] ;
  jpeg_saved_marker_ptr marker ;
  int __cil_tmp5 ;
  int i ;
  int __cil_tmp7 ;
  MetadataPayload *payload ;
  char const   *marker_data ;
  size_t marker_data_length ;
  int __cil_tmp11 ;

  {
#line 148
  kJPEGMetadataMap[0].marker = 225;
#line 148
  kJPEGMetadataMap[0].signature = "Exif";
#line 148
  kJPEGMetadataMap[0].signature_length = (size_t )6;
#line 148
  kJPEGMetadataMap[0].storage_offset = 0;
#line 148
  kJPEGMetadataMap[1].marker = 225;
#line 148
  kJPEGMetadataMap[1].signature = "http://ns.adobe.com/xap/1.0/";
#line 148
  kJPEGMetadataMap[1].signature_length = (size_t )29;
#line 148
  kJPEGMetadataMap[1].storage_offset = 0;
#line 148
  kJPEGMetadataMap[2].marker = 0;
#line 148
  kJPEGMetadataMap[2].signature = (char const   *)((void *)0);
#line 148
  kJPEGMetadataMap[2].signature_length = (size_t )0;
  {
#line 148
  kJPEGMetadataMap[2].storage_offset = (size_t )0;
#line 163
  __cil_tmp5 = StoreICCP(dinfo, & metadata->iccp);
  }
#line 163
  if (! __cil_tmp5) {
#line 163
    return (0);
  }
#line 165
  marker = dinfo->marker_list;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (marker != (void *)0)) {
#line 165
      goto while_break;
    }
#line 167
    i = 0;
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 167
      if (! (kJPEGMetadataMap[i].marker != 0)) {
#line 167
        goto while_break___0;
      }
      {
#line 168
      __cil_tmp7 = memcmp(marker->data, kJPEGMetadataMap[i].signature, kJPEGMetadataMap[i].signature_length);
      }
#line 168
      if ((int )marker->marker == kJPEGMetadataMap[i].marker) {
#line 168
        if ((unsigned long )marker->data_length > kJPEGMetadataMap[i].signature_length) {
#line 168
          if (! __cil_tmp7) {
#line 172
            payload = (MetadataPayload *)((uint8_t *)metadata + kJPEGMetadataMap[i].storage_offset);
#line 176
            if (payload->bytes == (void *)0) {
              {
#line 177
              marker_data = (char const   *)marker->data + kJPEGMetadataMap[i].signature_length;
#line 179
              marker_data_length = (unsigned long )marker->data_length - kJPEGMetadataMap[i].signature_length;
#line 181
              __cil_tmp11 = MetadataCopy(marker_data, marker_data_length, payload);
              }
#line 181
              if (! __cil_tmp11) {
#line 181
                return (0);
              }
            } else {
              {
#line 183
              fprintf(stderr, "Ignoring additional \'%s\' marker\n\230\001", kJPEGMetadataMap[i].signature);
              }
            }
          }
        }
      }
#line 167
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 165
    marker = marker->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (1);
}
}
#line 203 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
static void my_error_exit(j_common_ptr dinfo ) 
{ 
  struct my_error_mgr *myerr ;

  {
  {
#line 204
  myerr = (struct my_error_mgr *)dinfo->err;
#line 205
  (*((dinfo->err)->output_message))(dinfo);
#line 206
  longjmp((struct __jmp_buf_tag *)myerr->setjmp_buffer, 1);
  }
  return;
}
}
#line 209 "/doner/libwebp/libwebp-v0.3.0/examples/jpegdec.c"
int ReadJPEG(FILE *in_file , WebPPicture *pic , Metadata *metadata ) 
{ 
  int ok ;
  int stride ;
  int width ;
  int height ;
  struct jpeg_decompress_struct dinfo ;
  struct my_error_mgr jerr ;
  uint8_t *rgb ;
  JSAMPROW buffer[1] ;
  struct jpeg_error_mgr *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  JDIMENSION __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 210
  ok = 0;
#line 214
  rgb = (uint8_t *)((void *)0);
#line 217
  dinfo.err = jpeg_std_error(& jerr.pub);
#line 218
  jerr.pub.error_exit = & my_error_exit;
#line 220
  __cil_tmp13 = _setjmp((struct __jmp_buf_tag *)jerr.setjmp_buffer);
  }
#line 220
  if (__cil_tmp13) {
    Error: 
    {
#line 222
    MetadataFree(metadata);
    }
    {
#line 223
    jpeg_destroy_decompress(& dinfo);
    }
#line 224
    goto End;
  }
  {
#line 227
  jpeg_CreateDecompress(& dinfo, 80, (size_t )sizeof(struct jpeg_decompress_struct ));
#line 228
  jpeg_stdio_src(& dinfo, in_file);
  }
#line 229
  if (metadata != (void *)0) {
    {
#line 229
    SaveMetadataMarkers(& dinfo);
    }
  }
  {
#line 230
  jpeg_read_header(& dinfo, 1);
#line 232
  dinfo.out_color_space = (J_COLOR_SPACE )2;
#line 233
  dinfo.dct_method = (J_DCT_METHOD )1;
#line 234
  dinfo.do_fancy_upsampling = 1;
#line 236
  jpeg_start_decompress(& dinfo);
  }
#line 238
  if (dinfo.output_components != 3) {
#line 239
    goto Error;
  }
  {
#line 242
  width = (int )dinfo.output_width;
#line 243
  height = (int )dinfo.output_height;
#line 244
  stride = (int )((unsigned long )(dinfo.output_width * (unsigned int )dinfo.output_components) * sizeof(*rgb));
#line 246
  __cil_tmp14 = malloc((unsigned long )(stride * height));
#line 246
  rgb = (uint8_t *)__cil_tmp14;
  }
#line 247
  if (rgb == (void *)0) {
#line 248
    goto End;
  }
#line 250
  buffer[0] = (JSAMPLE *)rgb;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (dinfo.output_scanline < dinfo.output_height)) {
#line 252
      goto while_break;
    }
    {
#line 253
    __cil_tmp15 = jpeg_read_scanlines(& dinfo, (JSAMPROW *)buffer, (JDIMENSION )1);
    }
#line 253
    if (__cil_tmp15 != 1U) {
#line 254
      goto End;
    }
#line 256
    buffer[0] += stride;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  if (metadata != (void *)0) {
    {
#line 260
    ok = ExtractMetadataFromJPEG(& dinfo, metadata);
    }
#line 261
    if (! ok) {
      {
#line 262
      fprintf(stderr, "Error extracting JPEG metadata!\n\220");
      }
#line 263
      goto Error;
    }
  }
  {
#line 267
  jpeg_finish_decompress(& dinfo);
#line 268
  jpeg_destroy_decompress(& dinfo);
#line 271
  pic->width = width;
#line 272
  pic->height = height;
#line 273
  ok = WebPPictureImportRGB(pic, rgb, stride);
  }
#line 274
  if (! ok) {
#line 274
    goto Error;
  }
  End: 
  {
#line 277
  free(rgb);
  }
#line 278
  return (ok);
}
}
#line 18 "/doner/libwebp/libwebp-v0.3.0/examples/metadata.c"
void MetadataInit(Metadata *metadata ) 
{ 


  {
#line 19
  if (metadata == (void *)0) {
#line 19
    return;
  }
  {
#line 20
  memset(metadata, 0, sizeof(*metadata));
  }
  return;
}
}
#line 23 "/doner/libwebp/libwebp-v0.3.0/examples/metadata.c"
void MetadataPayloadDelete(MetadataPayload *payload ) 
{ 


  {
#line 24
  if (payload == (void *)0) {
#line 24
    return;
  }
  {
#line 25
  free(payload->bytes);
#line 26
  payload->bytes = (uint8_t *)((void *)0);
#line 27
  payload->size = (size_t )0;
  }
  return;
}
}
#line 30 "/doner/libwebp/libwebp-v0.3.0/examples/metadata.c"
void MetadataFree(Metadata *metadata ) 
{ 


  {
#line 31
  if (metadata == (void *)0) {
#line 31
    return;
  }
  {
#line 32
  MetadataPayloadDelete(& metadata->exif);
#line 33
  MetadataPayloadDelete(& metadata->iccp);
#line 34
  MetadataPayloadDelete(& metadata->xmp);
  }
  return;
}
}
#line 37 "/doner/libwebp/libwebp-v0.3.0/examples/metadata.c"
int MetadataCopy(char const   *metadata , size_t metadata_len , MetadataPayload *payload ) 
{ 
  void *__cil_tmp4 ;

  {
#line 39
  if (metadata == (void *)0) {
#line 39
    return (0);
  } else
#line 39
  if (metadata_len == 0UL) {
#line 39
    return (0);
  } else
#line 39
  if (payload == (void *)0) {
#line 39
    return (0);
  }
  {
#line 40
  __cil_tmp4 = malloc(metadata_len);
#line 40
  payload->bytes = (uint8_t *)__cil_tmp4;
  }
#line 41
  if (payload->bytes == (void *)0) {
#line 41
    return (0);
  }
  {
#line 42
  payload->size = metadata_len;
#line 43
  memcpy(payload->bytes, metadata, metadata_len);
  }
#line 44
  return (1);
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 75
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 83
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 141
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 145
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 38 "/doner/libwebp/libwebp-v0.3.0/examples/./stopwatch.h"
__inline static double StopwatchReadAndReset(Stopwatch *watch ) 
{ 
  struct timeval old_value ;

  {
  {
#line 39
  old_value = *watch;
#line 40
  gettimeofday(watch, (void *)0);
  }
#line 41
  return ((double )(watch->tv_sec - old_value.tv_sec) + (double )(watch->tv_usec - old_value.tv_usec) / 1000000.);
}
}
#line 45 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int verbose  =    0;
#line 47 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int ReadYUV(FILE *in_file , WebPPicture *pic ) 
{ 
  int use_argb ;
  int uv_width ;
  int uv_height ;
  int y ;
  int ok ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 48
  use_argb = pic->use_argb;
#line 49
  uv_width = (pic->width + 1) / 2;
#line 50
  uv_height = (pic->height + 1) / 2;
#line 52
  ok = 0;
#line 54
  pic->use_argb = 0;
#line 55
  __cil_tmp8 = WebPPictureAlloc(pic);
  }
#line 55
  if (! __cil_tmp8) {
#line 55
    return (ok);
  }
#line 57
  y = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (y < pic->height)) {
#line 57
      goto while_break;
    }
    {
#line 58
    __cil_tmp9 = fread(pic->y + y * pic->y_stride, (unsigned long )pic->width, (unsigned long )1,
                       in_file);
    }
#line 58
    if (__cil_tmp9 != 1UL) {
#line 59
      goto End;
    }
#line 57
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  y = 0;
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (! (y < uv_height)) {
#line 62
      goto while_break___0;
    }
    {
#line 63
    __cil_tmp10 = fread(pic->u + y * pic->uv_stride, (unsigned long )uv_width, (unsigned long )1,
                        in_file);
    }
#line 63
    if (__cil_tmp10 != 1UL) {
#line 64
      goto End;
    }
#line 62
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 66
  y = 0;
  {
#line 66
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 66
    if (! (y < uv_height)) {
#line 66
      goto while_break___1;
    }
    {
#line 67
    __cil_tmp11 = fread(pic->v + y * pic->uv_stride, (unsigned long )uv_width, (unsigned long )1,
                        in_file);
    }
#line 67
    if (__cil_tmp11 != 1UL) {
#line 68
      goto End;
    }
#line 66
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 70
  ok = 1;
#line 71
  if (use_argb) {
    {
#line 71
    ok = WebPPictureYUVAToARGB(pic);
    }
  }
  End: 
#line 74
  return (ok);
}
}
#line 110 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static InputFileFormat GetImageType(FILE *in_file ) 
{ 
  InputFileFormat format ;
  unsigned int magic ;
  unsigned char buf[4] ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 111
  format = (InputFileFormat )3;
#line 115
  __cil_tmp6 = fseek(in_file, (long )0, 0);
  }
  {
#line 115
  __cil_tmp5 = fread(& buf[0], (unsigned long )4, (unsigned long )1, in_file);
  }
#line 115
  if (__cil_tmp5 != 1UL) {
#line 117
    return (format);
  } else
#line 115
  if (__cil_tmp6 != 0) {
#line 117
    return (format);
  }
#line 120
  magic = (unsigned int )(((((int )buf[0] << 24) | ((int )buf[1] << 16)) | ((int )buf[2] << 8)) | (int )buf[3]);
#line 121
  if (magic == 2303741511U) {
#line 122
    format = (InputFileFormat )0;
  } else
#line 123
  if (magic >= 4292411136U) {
#line 123
    if (magic <= 4292411391U) {
#line 124
      format = (InputFileFormat )1;
    } else {
#line 123
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 125
  if (magic == 1229531648U) {
#line 126
    format = (InputFileFormat )2;
  } else
#line 125
  if (magic == 1296891946U) {
#line 126
    format = (InputFileFormat )2;
  }
#line 128
  return (format);
}
}
#line 131 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int ReadPicture(char const   *filename , WebPPicture *pic , int keep_alpha ,
                       Metadata *metadata ) 
{ 
  int ok ;
  FILE *in_file ;
  FILE *__cil_tmp7 ;
  InputFileFormat format ;
  InputFileFormat __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 133
  ok = 0;
#line 134
  __cil_tmp7 = fopen(filename, "rbX\215rU");
#line 134
  in_file = __cil_tmp7;
  }
#line 135
  if (in_file == (void *)0) {
    {
#line 136
    fprintf(stderr, "Error! Cannot open input file \'%s\'\n\215rU", filename);
    }
#line 137
    return (ok);
  }
#line 140
  if (pic->width == 0) {
    _L: /* CIL Label */ 
    {
#line 142
    __cil_tmp9 = GetImageType(in_file);
#line 142
    format = __cil_tmp9;
    }
#line 143
    if ((unsigned int )format == 0U) {
      {
#line 144
      ok = ReadPNG(in_file, pic, keep_alpha, metadata);
      }
    } else
#line 145
    if ((unsigned int )format == 1U) {
      {
#line 146
      ok = ReadJPEG(in_file, pic, metadata);
      }
    } else
#line 147
    if ((unsigned int )format == 2U) {
      {
#line 148
      ok = ReadTIFF(filename, pic, keep_alpha, metadata);
      }
    }
  } else
#line 140
  if (pic->height == 0) {
#line 140
    goto _L;
  } else {
    {
#line 152
    ok = ReadYUV(in_file, pic);
    }
  }
#line 154
  if (! ok) {
    {
#line 155
    fprintf(stderr, "Error! Could not process file %s\n", filename);
    }
  }
  {
#line 158
  fclose(in_file);
  }
#line 159
  return (ok);
}
}
#line 164 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void AllocExtraInfo(WebPPicture *pic ) 
{ 
  int mb_w ;
  int mb_h ;
  void *__cil_tmp4 ;

  {
  {
#line 165
  mb_w = (pic->width + 15) / 16;
#line 166
  mb_h = (pic->height + 15) / 16;
#line 167
  __cil_tmp4 = malloc((unsigned long )(mb_w * mb_h) * sizeof(*(pic->extra_info)));
#line 167
  pic->extra_info = (uint8_t *)__cil_tmp4;
  }
  return;
}
}
#line 170 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void PrintByteCount(int const   bytes[4] , int total_size , int *totals ) 
{ 
  int s ;
  int total ;

  {
#line 173
  total = 0;
#line 174
  s = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (s < 4)) {
#line 174
      goto while_break;
    }
    {
#line 175
    fprintf(stderr, "| %7d ", bytes[s]);
#line 176
    total += bytes[s];
    }
#line 177
    if (totals) {
#line 177
      *(totals + s) += bytes[s];
    }
#line 174
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  fprintf(stderr, "| %7d  (%.1f%%)\n\230\001", total, (double )((100.f * (float )total) / (float )total_size));
  }
  return;
}
}
#line 182 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void PrintPercents(int const   counts[4] , int total ) 
{ 
  int s ;

  {
#line 184
  s = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (s < 4)) {
#line 184
      goto while_break;
    }
    {
#line 185
    fprintf(stderr, "|      %2d%%rU", (100 * counts[s]) / total);
    }
#line 184
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  fprintf(stderr, "| %7d\n", total);
  }
  return;
}
}
#line 190 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void PrintValues(int const   values[4] ) 
{ 
  int s ;

  {
#line 192
  s = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (s < 4)) {
#line 192
      goto while_break;
    }
    {
#line 193
    fprintf(stderr, "| %7d ", values[s]);
    }
#line 192
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  fprintf(stderr, "|\nX\215rU");
  }
  return;
}
}
#line 198 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void PrintFullLosslessInfo(WebPAuxStats *stats , char const   *description ) 
{ 


  {
  {
#line 200
  fprintf(stderr, "Lossless-%s compressed size: %d bytes\n", description, stats->lossless_size);
  }
#line 202
  if (stats->lossless_features) {
    {
#line 203
    fprintf(stderr, "  * Lossless features used:\215rU");
    }
#line 204
    if (stats->lossless_features & 1U) {
      {
#line 204
      fprintf(stderr, " PREDICTION\215rU");
      }
    }
#line 205
    if (stats->lossless_features & 2U) {
      {
#line 205
      fprintf(stderr, " CROSS-COLOR-TRANSFORM");
      }
    }
#line 206
    if (stats->lossless_features & 4U) {
      {
#line 206
      fprintf(stderr, " SUBTRACT-GREEN");
      }
    }
#line 207
    if (stats->lossless_features & 8U) {
      {
#line 207
      fprintf(stderr, " PALETTE\220");
      }
    }
    {
#line 208
    fprintf(stderr, "\n");
    }
  }
  {
#line 210
  fprintf(stderr, "  * Precision Bits: histogram=%d transform=%d cache=%d\n", stats->histogram_bits,
          stats->transform_bits, stats->cache_bits);
  }
#line 212
  if (stats->palette_size > 0) {
    {
#line 213
    fprintf(stderr, "  * Palette size:   %d\n", stats->palette_size);
    }
  }
  return;
}
}
#line 217 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void PrintExtraInfoLossless(WebPPicture *pic , int short_output , char const   *file_name ) 
{ 
  WebPAuxStats *stats ;

  {
#line 220
  stats = pic->stats;
#line 221
  if (short_output) {
    {
#line 222
    fprintf(stderr, "%7d %2.2f\n", stats->coded_size, (double )stats->PSNR[3]);
    }
  } else {
    {
#line 224
    fprintf(stderr, "File:      %s\n", file_name);
#line 225
    fprintf(stderr, "Dimension: %d x %d\n", pic->width, pic->height);
#line 226
    fprintf(stderr, "Output:    %d bytes\n", stats->coded_size);
#line 227
    PrintFullLosslessInfo(stats, "ARGB");
    }
  }
  return;
}
}
#line 231 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void PrintExtraInfoLossy(WebPPicture *pic , int short_output , int full_details ,
                                char const   *file_name ) 
{ 
  WebPAuxStats *stats ;
  int num_i4 ;
  int num_i16 ;
  int num_skip ;
  int total ;
  char const   *tmp ;
  int totals[4] ;
  int mb_w ;
  int mb_h ;
  int type ;
  int x ;
  int y ;
  int c ;

  {
#line 234
  stats = pic->stats;
#line 235
  if (short_output) {
    {
#line 236
    fprintf(stderr, "%7d %2.2f\n", stats->coded_size, (double )stats->PSNR[3]);
    }
  } else {
    {
#line 238
    num_i4 = stats->block_count[0];
#line 239
    num_i16 = stats->block_count[1];
#line 240
    num_skip = stats->block_count[2];
#line 241
    total = num_i4 + num_i16;
#line 242
    fprintf(stderr, "File:      %s\n", file_name);
    }
#line 243
    if (stats->alpha_data_size) {
#line 243
      tmp = " (with alpha)";
    } else {
#line 243
      tmp = "\220";
    }
    {
#line 243
    fprintf(stderr, "Dimension: %d x %d%s\n", pic->width, pic->height, tmp);
#line 246
    fprintf(stderr, "Output:    %d bytes Y-U-V-All-PSNR %2.2f %2.2f %2.2f   %2.2f dB\n",
            stats->coded_size, (double )stats->PSNR[0], (double )stats->PSNR[1], (double )stats->PSNR[2],
            (double )stats->PSNR[3]);
    }
#line 250
    if (total > 0) {
      {
#line 251
      totals[0] = 0;
#line 251
      totals[1] = 0;
#line 251
      totals[2] = 0;
#line 251
      totals[3] = 0;
#line 252
      fprintf(stderr, "block count:  intra4: %d\n              intra16: %d  (-> %.2f%%)\n",
              num_i4, num_i16, (double )((100.f * (float )num_i16) / (float )total));
#line 255
      fprintf(stderr, "              skipped block: %d (%.2f%%)\n", num_skip, (double )((100.f * (float )num_skip) / (float )total));
#line 257
      fprintf(stderr, "bytes used:  header:         %6d  (%.1f%%)\n             mode-partition: %6d  (%.1f%%)\n",
              stats->header_bytes[0], (double )((100.f * (float )stats->header_bytes[0]) / (float )stats->coded_size),
              stats->header_bytes[1], (double )((100.f * (float )stats->header_bytes[1]) / (float )stats->coded_size));
      }
#line 263
      if (stats->alpha_data_size > 0) {
        {
#line 264
        fprintf(stderr, "             transparency:   %6d (%.1f dB)\n", stats->alpha_data_size,
                (double )stats->PSNR[4]);
        }
      }
#line 267
      if (stats->layer_data_size) {
        {
#line 268
        fprintf(stderr, "             enhancement:    %6d\n", stats->layer_data_size);
        }
      }
      {
#line 271
      fprintf(stderr, " Residuals bytes  |segment 1|segment 2|segment 3|segment 4|  total\n");
      }
#line 274
      if (full_details) {
        {
#line 275
        fprintf(stderr, "  intra4-coeffs:  ");
#line 276
        PrintByteCount((int const   *)stats->residual_bytes[0], stats->coded_size,
                       (int *)totals);
#line 277
        fprintf(stderr, " intra16-coeffs:  ");
#line 278
        PrintByteCount((int const   *)stats->residual_bytes[1], stats->coded_size,
                       (int *)totals);
#line 279
        fprintf(stderr, "  chroma coeffs:  ");
#line 280
        PrintByteCount((int const   *)stats->residual_bytes[2], stats->coded_size,
                       (int *)totals);
        }
      }
      {
#line 282
      fprintf(stderr, "    macroblocks:  ");
#line 283
      PrintPercents((int const   *)stats->segment_size, total);
#line 284
      fprintf(stderr, "      quantizer:  ");
#line 285
      PrintValues((int const   *)stats->segment_quant);
#line 286
      fprintf(stderr, "   filter level:  ");
#line 287
      PrintValues((int const   *)stats->segment_level);
      }
#line 288
      if (full_details) {
        {
#line 289
        fprintf(stderr, "------------------+---------");
#line 290
        fprintf(stderr, "+---------+---------+---------+-----------------\n");
#line 291
        fprintf(stderr, " segments total:  ");
#line 292
        PrintByteCount((int const   [4])((int *)totals), stats->coded_size, (int *)((void *)0));
        }
      }
    }
#line 295
    if (stats->lossless_size > 0) {
      {
#line 296
      PrintFullLosslessInfo(stats, "alpha");
      }
    }
  }
#line 299
  if (pic->extra_info != (void *)0) {
#line 300
    mb_w = (pic->width + 15) / 16;
#line 301
    mb_h = (pic->height + 15) / 16;
#line 302
    type = pic->extra_info_type;
#line 304
    y = 0;
    {
#line 304
    while (1) {
      while_continue: /* CIL Label */ ;
#line 304
      if (! (y < mb_h)) {
#line 304
        goto while_break;
      }
#line 305
      x = 0;
      {
#line 305
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 305
        if (! (x < mb_w)) {
#line 305
          goto while_break___0;
        }
#line 306
        c = (int )*(pic->extra_info + (x + y * mb_w));
#line 307
        if (type == 1) {
          {
#line 308
          printf("%c", (int )*("+." + c));
          }
        } else
#line 309
        if (type == 2) {
          {
#line 310
          printf("%c", (int )*(".-*X" + c));
          }
        } else
#line 311
        if (type == 3) {
          {
#line 312
          printf("%.2d ", c);
          }
        } else
#line 313
        if (type == 6) {
          {
          {
#line 314
          printf("%3d ", c);
          }
          }
        } else
#line 313
        if (type == 7) {
          {
          {
#line 314
          printf("%3d ", c);
          }
          }
        } else {
          {
#line 316
          printf("0x%.2x ", c);
          }
        }
#line 305
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 319
      printf("\n");
      }
#line 304
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 326 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int MyWriter(uint8_t *data , size_t data_size , WebPPicture *pic ) 
{ 
  FILE *out ;
  unsigned long __cil_tmp5 ;
  unsigned long tmp ;

  {
#line 328
  out = (FILE *)pic->custom_ptr;
#line 329
  if (data_size) {
    {
#line 329
    __cil_tmp5 = fwrite(data, data_size, (unsigned long )1, out);
#line 329
    tmp = __cil_tmp5 == 1UL;
    }
  } else {
#line 329
    tmp = (unsigned long )1;
  }
#line 329
  return ((int )tmp);
}
}
#line 333 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int DumpPicture(WebPPicture *picture , char const   *PGM_name ) 
{ 
  int y ;
  int uv_width ;
  int uv_height ;
  int stride ;
  int alpha_height ;
  int __cil_tmp8 ;
  int tmp ;
  int height ;
  FILE *f ;
  FILE *__cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;

  {
  {
#line 335
  uv_width = (picture->width + 1) / 2;
#line 336
  uv_height = (picture->height + 1) / 2;
#line 337
  stride = (picture->width + 1) & -2;
#line 338
  __cil_tmp8 = WebPPictureHasTransparency(picture);
  }
#line 338
  if (__cil_tmp8) {
#line 338
    tmp = picture->height;
  } else {
#line 338
    tmp = 0;
  }
  {
#line 338
  alpha_height = tmp;
#line 340
  height = (picture->height + uv_height) + alpha_height;
#line 341
  __cil_tmp12 = fopen(PGM_name, "wb");
#line 341
  f = __cil_tmp12;
  }
#line 342
  if (f == (void *)0) {
#line 342
    return (0);
  }
  {
#line 343
  fprintf(f, "P5\n%d %d\n255\n", stride, height);
#line 344
  y = 0;
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! (y < picture->height)) {
#line 344
      goto while_break;
    }
    {
#line 345
    __cil_tmp13 = fwrite(picture->y + y * picture->y_stride, (unsigned long )picture->width,
                         (unsigned long )1, f);
    }
#line 345
    if (__cil_tmp13 != 1UL) {
#line 346
      return (0);
    }
#line 347
    if (picture->width & 1) {
      {
#line 347
      fputc(0, f);
      }
    }
#line 344
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  y = 0;
  {
#line 349
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 349
    if (! (y < uv_height)) {
#line 349
      goto while_break___0;
    }
    {
#line 350
    __cil_tmp14 = fwrite(picture->u + y * picture->uv_stride, (unsigned long )uv_width,
                         (unsigned long )1, f);
    }
#line 350
    if (__cil_tmp14 != 1UL) {
#line 351
      return (0);
    }
    {
#line 352
    __cil_tmp15 = fwrite(picture->v + y * picture->uv_stride, (unsigned long )uv_width,
                         (unsigned long )1, f);
    }
#line 352
    if (__cil_tmp15 != 1UL) {
#line 353
      return (0);
    }
#line 349
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 355
  y = 0;
  {
#line 355
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 355
    if (! (y < alpha_height)) {
#line 355
      goto while_break___1;
    }
    {
#line 356
    __cil_tmp16 = fwrite(picture->a + y * picture->a_stride, (unsigned long )picture->width,
                         (unsigned long )1, f);
    }
#line 356
    if (__cil_tmp16 != 1UL) {
#line 357
      return (0);
    }
#line 358
    if (picture->width & 1) {
      {
#line 358
      fputc(0, f);
      }
    }
#line 355
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 360
  fclose(f);
  }
#line 361
  return (1);
}
}
#line 374 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int const   kChunkHeaderSize  =    8;
#line 375 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int const   kTagSize  =    4;
#line 377 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void PrintMetadataInfo(Metadata *metadata , int metadata_written ) 
{ 


  {
#line 379
  if (metadata == (void *)0) {
#line 379
    return;
  } else
#line 379
  if (metadata_written == 0) {
#line 379
    return;
  }
  {
#line 381
  fprintf(stderr, "Metadata:\nY\215rU");
  }
#line 382
  if (metadata_written & 2) {
    {
#line 383
    fprintf(stderr, "  * ICC profile:  %6d bytes\nrU", (int )metadata->iccp.size);
    }
  }
#line 385
  if (metadata_written & 1) {
    {
#line 386
    fprintf(stderr, "  * EXIF data:    %6d bytes\nrU", (int )metadata->exif.size);
    }
  }
#line 388
  if (metadata_written & 4) {
    {
#line 389
    fprintf(stderr, "  * XMP data:     %6d bytes\n", (int )metadata->xmp.size);
    }
  }
  return;
}
}
#line 394 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int WriteLE(FILE *out , uint32_t val , int num ) 
{ 
  uint8_t buf[4] ;
  int i ;
  unsigned long __cil_tmp6 ;

  {
#line 397
  i = 0;
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! (i < num)) {
#line 397
      goto while_break;
    }
#line 398
    buf[i] = (uint8_t )(val & 255U);
#line 399
    val >>= 8;
#line 397
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 401
  __cil_tmp6 = fwrite((uint8_t *)buf, (unsigned long )num, (unsigned long )1, out);
  }
#line 401
  return (__cil_tmp6 == 1UL);
}
}
#line 404 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int WriteLE24(FILE *out , uint32_t val ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 405
  __cil_tmp3 = WriteLE(out, val, 3);
  }
#line 405
  return (__cil_tmp3);
}
}
#line 408 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int WriteLE32(FILE *out , uint32_t val ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 409
  __cil_tmp3 = WriteLE(out, val, 4);
  }
#line 409
  return (__cil_tmp3);
}
}
#line 412 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int WriteMetadataChunk(FILE *out , char const   fourcc[4] , MetadataPayload *payload ) 
{ 
  uint8_t zero ;
  size_t need_padding ;
  int ok ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 414
  zero = (uint8_t )0;
#line 415
  need_padding = payload->size & 1UL;
#line 416
  __cil_tmp7 = fwrite(fourcc, (unsigned long )kTagSize, (unsigned long )1, out);
#line 416
  ok = __cil_tmp7 == 1UL;
#line 417
  __cil_tmp8 = WriteLE32(out, (uint32_t )payload->size);
#line 417
  ok = ok && __cil_tmp8;
#line 418
  __cil_tmp9 = fwrite(payload->bytes, payload->size, (unsigned long )1, out);
#line 418
  ok = ok && __cil_tmp9 == 1UL;
#line 419
  __cil_tmp10 = fwrite(& zero, need_padding, need_padding, out);
  }
#line 419
  return (ok && __cil_tmp10 == need_padding);
}
}
#line 424 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int UpdateFlagsAndSize(MetadataPayload *payload , int keep , int flag , uint32_t *vp8x_flags ,
                              uint64_t *metadata_size ) 
{ 


  {
#line 427
  if (payload->bytes != (void *)0) {
#line 427
    if (keep) {
#line 427
      if (payload->size > 0UL) {
#line 428
        *vp8x_flags |= (unsigned int )flag;
#line 429
        *metadata_size += ((unsigned long )kChunkHeaderSize + payload->size) + (payload->size & 1UL);
#line 430
        return (1);
      }
    }
  }
#line 432
  return (0);
}
}
#line 439 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int WriteWebPWithMetadata(FILE *out , WebPPicture *picture , WebPMemoryWriter *memory_writer ,
                                 Metadata *metadata , int keep_metadata , int *metadata_written ) 
{ 
  char const   kVP8XHeader[9] ;
  int kAlphaFlag ;
  int kEXIFFlag ;
  int kICCPFlag ;
  int kXMPFlag ;
  size_t kRiffHeaderSize ;
  size_t kMaxChunkPayload ;
  size_t kMinSize ;
  uint32_t flags ;
  uint64_t metadata_size ;
  int write_exif ;
  int __cil_tmp18 ;
  int write_iccp ;
  int __cil_tmp20 ;
  int write_xmp ;
  int __cil_tmp22 ;
  uint8_t *webp ;
  size_t webp_size ;
  int kVP8XChunkSize ;
  int has_vp8x ;
  int __cil_tmp27 ;
  uint32_t riff_size ;
  int tmp ;
  int ok ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int is_lossless ;
  int __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;

  {
  {
#line 445
  kVP8XHeader = "VP8X\n";
#line 446
  kAlphaFlag = 16;
#line 447
  kEXIFFlag = 8;
#line 448
  kICCPFlag = 32;
#line 449
  kXMPFlag = 4;
#line 450
  kRiffHeaderSize = (size_t )12;
#line 451
  kMaxChunkPayload = (size_t )((-1 - kChunkHeaderSize) - 1);
#line 452
  kMinSize = kRiffHeaderSize + (unsigned long )kChunkHeaderSize;
#line 453
  flags = (uint32_t )0;
#line 454
  metadata_size = (uint64_t )0;
#line 455
  __cil_tmp18 = UpdateFlagsAndSize(& metadata->exif, ! (! (keep_metadata & 1)), kEXIFFlag,
                                   & flags, & metadata_size);
#line 455
  write_exif = __cil_tmp18;
#line 458
  __cil_tmp20 = UpdateFlagsAndSize(& metadata->iccp, ! (! (keep_metadata & 2)), kICCPFlag,
                                   & flags, & metadata_size);
#line 458
  write_iccp = __cil_tmp20;
#line 461
  __cil_tmp22 = UpdateFlagsAndSize(& metadata->xmp, ! (! (keep_metadata & 4)), kXMPFlag,
                                   & flags, & metadata_size);
#line 461
  write_xmp = __cil_tmp22;
#line 464
  webp = memory_writer->mem;
#line 465
  webp_size = memory_writer->size;
#line 467
  *metadata_written = 0;
  }
#line 469
  if (webp_size < kMinSize) {
#line 469
    return (0);
  }
#line 470
  if ((webp_size - (unsigned long )kChunkHeaderSize) + metadata_size > kMaxChunkPayload) {
    {
#line 471
    fprintf(stderr, "Error! Addition of metadata would exceed container size limit.\n");
    }
#line 473
    return (0);
  }
#line 476
  if (metadata_size > 0UL) {
    {
#line 477
    kVP8XChunkSize = 18;
#line 478
    __cil_tmp27 = memcmp(webp + kRiffHeaderSize, "VP8X", (unsigned long )kTagSize);
#line 478
    has_vp8x = ! __cil_tmp27;
    }
#line 479
    if (has_vp8x) {
#line 479
      tmp = 0;
    } else {
#line 479
      tmp = kVP8XChunkSize;
    }
    {
#line 479
    riff_size = (uint32_t )(((webp_size - (unsigned long )kChunkHeaderSize) + (unsigned long )tmp) + metadata_size);
#line 483
    __cil_tmp31 = fwrite(webp, (unsigned long )kTagSize, (unsigned long )1, out);
#line 483
    ok = __cil_tmp31 == 1UL;
#line 485
    __cil_tmp32 = WriteLE32(out, riff_size);
#line 485
    ok = ok && __cil_tmp32;
#line 486
    webp += kChunkHeaderSize;
#line 487
    webp_size -= (unsigned long )kChunkHeaderSize;
#line 489
    __cil_tmp33 = fwrite(webp, (unsigned long )kTagSize, (unsigned long )1, out);
#line 489
    ok = ok && __cil_tmp33 == 1UL;
#line 490
    webp += kTagSize;
#line 491
    webp_size -= (unsigned long )kTagSize;
    }
#line 492
    if (has_vp8x) {
      {
#line 493
      *(webp + kChunkHeaderSize) |= (int )((uint8_t )(flags & 255U));
#line 494
      __cil_tmp34 = fwrite(webp, (unsigned long )kVP8XChunkSize, (unsigned long )1,
                           out);
#line 494
      ok = ok && __cil_tmp34 == 1UL;
#line 495
      webp_size -= (unsigned long )kVP8XChunkSize;
      }
    } else {
      {
#line 497
      __cil_tmp36 = memcmp(webp, "VP8L", (unsigned long )kTagSize);
#line 497
      is_lossless = ! __cil_tmp36;
      }
#line 499
      if (is_lossless) {
#line 499
        flags |= (unsigned int )kAlphaFlag;
      }
      {
#line 500
      __cil_tmp37 = fwrite((char const   *)kVP8XHeader, (unsigned long )kChunkHeaderSize,
                           (unsigned long )1, out);
#line 500
      ok = ok && __cil_tmp37 == 1UL;
#line 501
      __cil_tmp38 = WriteLE32(out, flags);
#line 501
      ok = ok && __cil_tmp38;
#line 502
      __cil_tmp39 = WriteLE24(out, (uint32_t )(picture->width - 1));
#line 502
      ok = ok && __cil_tmp39;
#line 503
      __cil_tmp40 = WriteLE24(out, (uint32_t )(picture->height - 1));
#line 503
      ok = ok && __cil_tmp40;
      }
    }
#line 505
    if (write_iccp) {
      {
#line 506
      __cil_tmp41 = WriteMetadataChunk(out, (char const   [4])"ICCP", & metadata->iccp);
#line 506
      ok = ok && __cil_tmp41;
#line 507
      *metadata_written |= 2;
      }
    }
    {
#line 510
    __cil_tmp42 = fwrite(webp, webp_size, (unsigned long )1, out);
#line 510
    ok = ok && __cil_tmp42 == 1UL;
    }
#line 511
    if (write_exif) {
      {
#line 512
      __cil_tmp43 = WriteMetadataChunk(out, (char const   [4])"EXIF", & metadata->exif);
#line 512
      ok = ok && __cil_tmp43;
#line 513
      *metadata_written |= 1;
      }
    }
#line 515
    if (write_xmp) {
      {
#line 516
      __cil_tmp44 = WriteMetadataChunk(out, (char const   [4])"XMP ", & metadata->xmp);
#line 516
      ok = ok && __cil_tmp44;
#line 517
      *metadata_written |= 4;
      }
    }
#line 519
    return (ok);
  } else {
    {
#line 522
    __cil_tmp45 = fwrite(webp, webp_size, (unsigned long )1, out);
    }
#line 522
    return (__cil_tmp45 == 1UL);
  }
}
}
#line 528 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static int ProgressReport(int percent , WebPPicture *picture ) 
{ 


  {
  {
#line 529
  printf("[%s]: %3d %%      \r", (char *)picture->user_data, percent);
#line 531
  fflush(stdout);
  }
#line 532
  return (1);
}
}
#line 537 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void HelpShort(void) 
{ 


  {
  {
#line 538
  printf("Usage:\n\n\220");
#line 539
  printf("   cwebp [options] -q quality input.png -o output.webp\n\n\220");
#line 540
  printf("where quality is between 0 (poor) to 100 (very good).\n");
#line 541
  printf("Typical value is around 80.\n\n");
#line 542
  printf("Try -longhelp for an exhaustive list of advanced options.\n");
  }
  return;
}
}
#line 545 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static void HelpLong(void) 
{ 


  {
  {
#line 546
  printf("Usage:\n");
#line 547
  printf(" cwebp [-preset <...>] [options] in_file [-o out_file]\n\n\220");
#line 548
  printf("If input size (-s) for an image is not specified, it is assumed to be a PNG, JPEG or TIFF file.\nrU");
#line 553
  printf("options:\n");
#line 554
  printf("  -h / -help  ............ short help\n");
#line 555
  printf("  -H / -longhelp  ........ long help\n");
#line 556
  printf("  -q <float> ............. quality factor (0:small..100:big)\nU");
#line 557
  printf("  -alpha_q <int> ......... Transparency-compression quality (0..100).\nZ\215rU");
#line 559
  printf("  -preset <string> ....... Preset setting, one of:\n\215rU");
#line 560
  printf("                            default, photo, picture,\nU");
#line 561
  printf("                            drawing, icon, text\n\220");
#line 562
  printf("     -preset must come first, as it overwrites other parameters.\220");
#line 563
  printf("\n");
#line 564
  printf("  -m <int> ............... compression method (0=fast, 6=slowest)\nZ\215rU");
#line 565
  printf("  -segments <int> ........ number of segments to use (1..4)\n");
#line 566
  printf("  -size <int> ............ Target size (in bytes)\n=\214rU");
#line 567
  printf("  -psnr <float> .......... Target PSNR (in dB. typically: 42)\n");
#line 568
  printf("\n");
#line 569
  printf("  -s <int> <int> ......... Input size (width x height) for YUV\n");
#line 570
  printf("  -sns <int> ............. Spatial Noise Shaping (0:off, 100:max)\nZ\215rU");
#line 571
  printf("  -f <int> ............... filter strength (0=off..100)\n\220");
#line 572
  printf("  -sharpness <int> ....... filter sharpness (0:most .. 7:least sharp)\nZ\215rU");
#line 574
  printf("  -strong ................ use strong filter instead of simple (default).\n");
#line 576
  printf("  -nostrong .............. use simple filter instead of strong.\n\220");
#line 577
  printf("  -partition_limit <int> . limit quality to fit the 512k limit on\n");
#line 578
  printf("                           the first partition (0=no degradation ... 100=full)\n");
#line 580
  printf("  -pass <int> ............ analysis pass number (1..10)\n\220");
#line 581
  printf("  -crop <x> <y> <w> <h> .. crop picture with the given rectangle\n\306Z\215rU");
#line 582
  printf("  -resize <w> <h> ........ resize picture (after any cropping)\n");
#line 583
  printf("  -mt .................... use multi-threading if available\nrU");
#line 584
  printf("  -low_memory ............ reduce memory usage (slower encoding)\n}Z\215rU");
#line 588
  printf("  -map <int> ............. print map of extra info.\n");
#line 589
  printf("  -print_psnr ............ prints averaged PSNR distortion.\n");
#line 590
  printf("  -print_ssim ............ prints averaged SSIM distortion.\n");
#line 591
  printf("  -print_lsim ............ prints local-similarity distortion.\n");
#line 592
  printf("  -d <file.pgm> .......... dump the compressed output (PGM file).\n");
#line 593
  printf("  -alpha_method <int> .... Transparency-compression method (0..1)\n");
#line 594
  printf("  -alpha_filter <string> . predictive filtering for alpha plane.\nwZ\215rU");
#line 595
  printf("                           One of: none, fast (default) or best.\n\325Z\215rU");
#line 596
  printf("  -alpha_cleanup ......... Clean RGB values in transparent area.\n");
#line 597
  printf("  -noalpha ............... discard any transparency information.\n");
#line 598
  printf("  -lossless .............. Encode image losslessly.\nrU");
#line 599
  printf("  -hint <string> ......... Specify image characteristics hint.\n");
#line 600
  printf("                           One of: photo, picture or graph\n");
#line 602
  printf("\npZ\215rU");
#line 603
  printf("  -metadata <string> ..... comma separated list of metadata to\n");
#line 604
  printf("                           ");
#line 605
  printf("copy from the input to the output if present.\n");
#line 606
  printf("                           Valid values: all, none (default), exif, icc, xmp\n");
#line 609
  printf("\noZ\215rU");
#line 610
  printf("  -short ................. condense printed message\n");
#line 611
  printf("  -quiet ................. don\'t print anything.\n");
#line 612
  printf("  -version ............... print version number and exit.\nZ\215rU");
#line 614
  printf("  -noasm ................. disable all assembly optimizations.\n");
#line 616
  printf("  -v ..................... verbose, e.g. print encoding/decoding times\n\215rU");
#line 618
  printf("  -progress .............. report encoding progress\n");
#line 619
  printf("\n");
#line 620
  printf("Experimental Options:\n");
#line 621
  printf("  -jpeg_like ............. Roughly match expected JPEG size.\nU");
#line 622
  printf("  -af .................... auto-adjust filter strength.\n\220");
#line 623
  printf("  -pre <int> ............. pre-processing filter\n{S\215rU");
#line 624
  printf("\n\315Z\215rU");
  }
  return;
}
}
#line 630 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
static char const   * const  kErrorMessages[11]  = 
#line 630
  {      "OKZ\215rU",      "OUT_OF_MEMORY: Out of memory allocating objects",      "BITSTREAM_OUT_OF_MEMORY: Out of memory re-allocating byte buffer\323\001 \214\001",      "NULL_PARAMETER: NULL parameter passed to function\353Z\215rU", 
        "INVALID_CONFIGURATION: configuration is invalid",      "BAD_DIMENSION: Bad picture dimension. Maximum width and height allowed is 16383 pixels.\215rU",      "PARTITION0_OVERFLOW: Partition #0 is too big to fit 512k.\nTo reduce the size of this partition, try using less segments with the -segments option, and eventually reduce the number of header bits using -partition_limit. More details are available in the manual (`man cwebp`)\356Z\215rU",      "PARTITION_OVERFLOW: Partition is too big to fit 16M", 
        "BAD_WRITE: Picture writer returned an I/O error",      "FILE_TOO_BIG: File would be too big to fit in 4G\020\357Z\215rU",      "USER_ABORT: encoding abort requested by user"};
#line 651 "/doner/libwebp/libwebp-v0.3.0/examples/cwebp.c"
int main(int argc , char const   *argv[] ) 
{ 
  int return_value ;
  char const   *in_file ;
  char const   *out_file ;
  char const   *dump_file ;
  FILE *out ;
  int c ;
  int short_output ;
  int quiet ;
  int keep_alpha ;
  int crop ;
  int crop_x ;
  int crop_y ;
  int crop_w ;
  int crop_h ;
  int resize_w ;
  int resize_h ;
  int show_progress ;
  int keep_metadata ;
  int metadata_written ;
  WebPPicture picture ;
  int print_distortion ;
  WebPPicture original_picture ;
  WebPConfig config ;
  WebPAuxStats stats ;
  WebPMemoryWriter memory_writer ;
  Metadata metadata ;
  Stopwatch stop_watch ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  long __cil_tmp45 ;
  long __cil_tmp46 ;
  int __cil_tmp47 ;
  long __cil_tmp48 ;
  int __cil_tmp49 ;
  double __cil_tmp50 ;
  int __cil_tmp51 ;
  long __cil_tmp52 ;
  int __cil_tmp53 ;
  long __cil_tmp54 ;
  int __cil_tmp55 ;
  int tmp ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  long __cil_tmp68 ;
  int __cil_tmp69 ;
  double __cil_tmp70 ;
  int __cil_tmp71 ;
  long __cil_tmp72 ;
  int __cil_tmp73 ;
  long __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  long __cil_tmp82 ;
  int __cil_tmp83 ;
  long __cil_tmp84 ;
  int __cil_tmp85 ;
  long __cil_tmp86 ;
  int __cil_tmp87 ;
  long __cil_tmp88 ;
  int __cil_tmp89 ;
  long __cil_tmp90 ;
  int __cil_tmp91 ;
  long __cil_tmp92 ;
  int __cil_tmp93 ;
  long __cil_tmp94 ;
  long __cil_tmp95 ;
  long __cil_tmp96 ;
  long __cil_tmp97 ;
  int __cil_tmp98 ;
  long __cil_tmp99 ;
  long __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int version ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  enum WebPPreset preset ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  static struct __anonstruct_928 kTokens[5] ;
  size_t kNumTokens ;
  char const   *start ;
  char const   *end ;
  unsigned long __cil_tmp121 ;
  size_t i ;
  char const   *token ;
  char *__cil_tmp124 ;
  unsigned long __cil_tmp125 ;
  unsigned long __cil_tmp126 ;
  int __cil_tmp127 ;
  int __cil_tmp128 ;
  int __cil_tmp129 ;
  Metadata *tmp___0 ;
  int __cil_tmp131 ;
  int (*tmp___1)(int percent , WebPPicture * const  picture ) ;
  double read_time ;
  double __cil_tmp134 ;
  FILE *__cil_tmp135 ;
  int __cil_tmp136 ;
  int __cil_tmp137 ;
  int __cil_tmp138 ;
  double encode_time ;
  double __cil_tmp140 ;
  int __cil_tmp141 ;
  int __cil_tmp142 ;
  static char const   *distortion_names[3] ;
  float values[5] ;

  {
#line 652
  return_value = - 1;
#line 653
  in_file = (char const   *)((void *)0);
#line 653
  out_file = (char const   *)((void *)0);
#line 653
  dump_file = (char const   *)((void *)0);
#line 654
  out = (FILE *)((void *)0);
#line 656
  short_output = 0;
#line 657
  quiet = 0;
#line 658
  keep_alpha = 1;
#line 659
  crop = 0;
#line 659
  crop_x = 0;
#line 659
  crop_y = 0;
#line 659
  crop_w = 0;
#line 659
  crop_h = 0;
#line 660
  resize_w = 0;
  {
#line 660
  resize_h = 0;
#line 661
  show_progress = 0;
#line 662
  keep_metadata = 0;
#line 663
  metadata_written = 0;
#line 665
  print_distortion = - 1;
#line 673
  MetadataInit(& metadata);
#line 674
  WebPMemoryWriterInit(& memory_writer);
#line 675
  __cil_tmp32 = WebPConfigInit___0(& config);
  }
  {
#line 675
  __cil_tmp31 = WebPPictureInit(& original_picture);
  }
  {
#line 675
  __cil_tmp30 = WebPPictureInit(& picture);
  }
#line 675
  if (! __cil_tmp30) {
    {
    {
    {
#line 678
    fprintf(stderr, "Error! Version mismatch!\n");
    }
    }
    }
#line 679
    return (- 1);
  } else
#line 675
  if (! __cil_tmp31) {
    {
    {
    {
#line 678
    fprintf(stderr, "Error! Version mismatch!\n");
    }
    }
    }
#line 679
    return (- 1);
  } else
#line 675
  if (! __cil_tmp32) {
    {
    {
    {
#line 678
    fprintf(stderr, "Error! Version mismatch!\n");
    }
    }
    }
#line 679
    return (- 1);
  }
#line 682
  if (argc == 1) {
    {
#line 683
    HelpShort();
    }
#line 684
    return (0);
  }
#line 687
  c = 1;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! (c < argc)) {
#line 687
      goto while_break;
    }
    {
#line 688
    __cil_tmp34 = strcmp(argv[c], "-help");
    }
    {
#line 688
    __cil_tmp33 = strcmp(argv[c], "-h");
    }
#line 688
    if (! __cil_tmp33) {
      {
      {
#line 689
      HelpShort();
      }
      }
#line 690
      return (0);
    } else
#line 688
    if (! __cil_tmp34) {
      {
      {
#line 689
      HelpShort();
      }
      }
#line 690
      return (0);
    } else {
      {
#line 691
      __cil_tmp36 = strcmp(argv[c], "-longhelp");
      }
      {
#line 691
      __cil_tmp35 = strcmp(argv[c], "-H");
      }
#line 691
      if (! __cil_tmp35) {
        {
        {
#line 692
        HelpLong();
        }
        }
#line 693
        return (0);
      } else
#line 691
      if (! __cil_tmp36) {
        {
        {
#line 692
        HelpLong();
        }
        }
#line 693
        return (0);
      } else {
        {
#line 694
        __cil_tmp37 = strcmp(argv[c], "-o");
        }
#line 694
        if (! __cil_tmp37) {
#line 694
          if (c < argc - 1) {
#line 695
            c ++;
#line 695
            out_file = argv[c];
          } else {
#line 694
            goto _L___37;
          }
        } else {
          _L___37: /* CIL Label */ 
          {
#line 696
          __cil_tmp38 = strcmp(argv[c], "-d");
          }
#line 696
          if (! __cil_tmp38) {
#line 696
            if (c < argc - 1) {
#line 697
              c ++;
#line 697
              dump_file = argv[c];
#line 698
              config.show_compressed = 1;
            } else {
#line 696
              goto _L___36;
            }
          } else {
            _L___36: /* CIL Label */ 
            {
#line 699
            __cil_tmp39 = strcmp(argv[c], "-print_psnr");
            }
#line 699
            if (! __cil_tmp39) {
#line 700
              config.show_compressed = 1;
#line 701
              print_distortion = 0;
            } else {
              {
#line 702
              __cil_tmp40 = strcmp(argv[c], "-print_ssim");
              }
#line 702
              if (! __cil_tmp40) {
#line 703
                config.show_compressed = 1;
#line 704
                print_distortion = 1;
              } else {
                {
#line 705
                __cil_tmp41 = strcmp(argv[c], "-print_lsim");
                }
#line 705
                if (! __cil_tmp41) {
#line 706
                  config.show_compressed = 1;
#line 707
                  print_distortion = 2;
                } else {
                  {
#line 708
                  __cil_tmp42 = strcmp(argv[c], "-short");
                  }
#line 708
                  if (! __cil_tmp42) {
#line 709
                    short_output ++;
                  } else {
                    {
#line 710
                    __cil_tmp44 = strcmp(argv[c], "-s");
                    }
#line 710
                    if (! __cil_tmp44) {
#line 710
                      if (c < argc - 2) {
                        {
#line 711
                        c ++;
#line 711
                        __cil_tmp45 = strtol(argv[c], (char **)((void *)0), 0);
#line 711
                        picture.width = (int )__cil_tmp45;
#line 712
                        c ++;
#line 712
                        __cil_tmp46 = strtol(argv[c], (char **)((void *)0), 0);
#line 712
                        picture.height = (int )__cil_tmp46;
                        }
                      } else {
#line 710
                        goto _L___35;
                      }
                    } else {
                      _L___35: /* CIL Label */ 
                      {
#line 713
                      __cil_tmp47 = strcmp(argv[c], "-m");
                      }
#line 713
                      if (! __cil_tmp47) {
#line 713
                        if (c < argc - 1) {
                          {
#line 714
                          c ++;
#line 714
                          __cil_tmp48 = strtol(argv[c], (char **)((void *)0), 0);
#line 714
                          config.method = (int )__cil_tmp48;
                          }
                        } else {
#line 713
                          goto _L___34;
                        }
                      } else {
                        _L___34: /* CIL Label */ 
                        {
#line 715
                        __cil_tmp49 = strcmp(argv[c], "-q");
                        }
#line 715
                        if (! __cil_tmp49) {
#line 715
                          if (c < argc - 1) {
                            {
#line 716
                            c ++;
#line 716
                            __cil_tmp50 = strtod(argv[c], (char **)((void *)0));
#line 716
                            config.quality = (float )__cil_tmp50;
                            }
                          } else {
#line 715
                            goto _L___33;
                          }
                        } else {
                          _L___33: /* CIL Label */ 
                          {
#line 717
                          __cil_tmp51 = strcmp(argv[c], "-alpha_q\220");
                          }
#line 717
                          if (! __cil_tmp51) {
#line 717
                            if (c < argc - 1) {
                              {
#line 718
                              c ++;
#line 718
                              __cil_tmp52 = strtol(argv[c], (char **)((void *)0),
                                                   0);
#line 718
                              config.alpha_quality = (int )__cil_tmp52;
                              }
                            } else {
#line 717
                              goto _L___32;
                            }
                          } else {
                            _L___32: /* CIL Label */ 
                            {
#line 719
                            __cil_tmp53 = strcmp(argv[c], "-alpha_method");
                            }
#line 719
                            if (! __cil_tmp53) {
#line 719
                              if (c < argc - 1) {
                                {
#line 720
                                c ++;
#line 720
                                __cil_tmp54 = strtol(argv[c], (char **)((void *)0),
                                                     0);
#line 720
                                config.alpha_compression = (int )__cil_tmp54;
                                }
                              } else {
#line 719
                                goto _L___31;
                              }
                            } else {
                              _L___31: /* CIL Label */ 
                              {
#line 721
                              __cil_tmp55 = strcmp(argv[c], "-alpha_cleanup");
                              }
#line 721
                              if (! __cil_tmp55) {
#line 722
                                if (keep_alpha) {
#line 722
                                  tmp = 2;
                                } else {
#line 722
                                  tmp = 0;
                                }
#line 722
                                keep_alpha = tmp;
                              } else {
                                {
#line 723
                                __cil_tmp57 = strcmp(argv[c], "-alpha_filter");
                                }
#line 723
                                if (! __cil_tmp57) {
#line 723
                                  if (c < argc - 1) {
                                    {
#line 724
                                    c ++;
#line 725
                                    __cil_tmp58 = strcmp(argv[c], "none");
                                    }
#line 725
                                    if (! __cil_tmp58) {
#line 726
                                      config.alpha_filtering = 0;
                                    } else {
                                      {
#line 727
                                      __cil_tmp59 = strcmp(argv[c], "fast");
                                      }
#line 727
                                      if (! __cil_tmp59) {
#line 728
                                        config.alpha_filtering = 1;
                                      } else {
                                        {
#line 729
                                        __cil_tmp60 = strcmp(argv[c], "best");
                                        }
#line 729
                                        if (! __cil_tmp60) {
#line 730
                                          config.alpha_filtering = 2;
                                        } else {
                                          {
#line 732
                                          fprintf(stderr, "Error! Unrecognized alpha filter: %s\n",
                                                  argv[c]);
                                          }
#line 733
                                          goto Error;
                                        }
                                      }
                                    }
                                  } else {
#line 723
                                    goto _L___30;
                                  }
                                } else {
                                  _L___30: /* CIL Label */ 
                                  {
#line 735
                                  __cil_tmp61 = strcmp(argv[c], "-noalpha\220");
                                  }
#line 735
                                  if (! __cil_tmp61) {
#line 736
                                    keep_alpha = 0;
                                  } else {
                                    {
#line 737
                                    __cil_tmp62 = strcmp(argv[c], "-lossless");
                                    }
#line 737
                                    if (! __cil_tmp62) {
#line 738
                                      config.lossless = 1;
#line 739
                                      picture.use_argb = 1;
                                    } else {
                                      {
#line 740
                                      __cil_tmp63 = strcmp(argv[c], "-hint");
                                      }
#line 740
                                      if (! __cil_tmp63) {
#line 740
                                        if (c < argc - 1) {
                                          {
#line 741
                                          c ++;
#line 742
                                          __cil_tmp64 = strcmp(argv[c], "photo");
                                          }
#line 742
                                          if (! __cil_tmp64) {
#line 743
                                            config.image_hint = (enum WebPImageHint )2;
                                          } else {
                                            {
#line 744
                                            __cil_tmp65 = strcmp(argv[c], "picture");
                                            }
#line 744
                                            if (! __cil_tmp65) {
#line 745
                                              config.image_hint = (enum WebPImageHint )1;
                                            } else {
                                              {
#line 746
                                              __cil_tmp66 = strcmp(argv[c], "graph");
                                              }
#line 746
                                              if (! __cil_tmp66) {
#line 747
                                                config.image_hint = (enum WebPImageHint )3;
                                              } else {
                                                {
#line 749
                                                fprintf(stderr, "Error! Unrecognized image hint: %s\n",
                                                        argv[c]);
                                                }
#line 750
                                                goto Error;
                                              }
                                            }
                                          }
                                        } else {
#line 740
                                          goto _L___29;
                                        }
                                      } else {
                                        _L___29: /* CIL Label */ 
                                        {
#line 752
                                        __cil_tmp67 = strcmp(argv[c], "-size");
                                        }
#line 752
                                        if (! __cil_tmp67) {
#line 752
                                          if (c < argc - 1) {
                                            {
#line 753
                                            c ++;
#line 753
                                            __cil_tmp68 = strtol(argv[c], (char **)((void *)0),
                                                                 0);
#line 753
                                            config.target_size = (int )__cil_tmp68;
                                            }
                                          } else {
#line 752
                                            goto _L___28;
                                          }
                                        } else {
                                          _L___28: /* CIL Label */ 
                                          {
#line 754
                                          __cil_tmp69 = strcmp(argv[c], "-psnr");
                                          }
#line 754
                                          if (! __cil_tmp69) {
#line 754
                                            if (c < argc - 1) {
                                              {
#line 755
                                              c ++;
#line 755
                                              __cil_tmp70 = strtod(argv[c], (char **)((void *)0));
#line 755
                                              config.target_PSNR = (float )__cil_tmp70;
                                              }
                                            } else {
#line 754
                                              goto _L___27;
                                            }
                                          } else {
                                            _L___27: /* CIL Label */ 
                                            {
#line 756
                                            __cil_tmp71 = strcmp(argv[c], "-sns");
                                            }
#line 756
                                            if (! __cil_tmp71) {
#line 756
                                              if (c < argc - 1) {
                                                {
#line 757
                                                c ++;
#line 757
                                                __cil_tmp72 = strtol(argv[c], (char **)((void *)0),
                                                                     0);
#line 757
                                                config.sns_strength = (int )__cil_tmp72;
                                                }
                                              } else {
#line 756
                                                goto _L___26;
                                              }
                                            } else {
                                              _L___26: /* CIL Label */ 
                                              {
#line 758
                                              __cil_tmp73 = strcmp(argv[c], "-f");
                                              }
#line 758
                                              if (! __cil_tmp73) {
#line 758
                                                if (c < argc - 1) {
                                                  {
#line 759
                                                  c ++;
#line 759
                                                  __cil_tmp74 = strtol(argv[c], (char **)((void *)0),
                                                                       0);
#line 759
                                                  config.filter_strength = (int )__cil_tmp74;
                                                  }
                                                } else {
#line 758
                                                  goto _L___25;
                                                }
                                              } else {
                                                _L___25: /* CIL Label */ 
                                                {
#line 760
                                                __cil_tmp75 = strcmp(argv[c], "-af");
                                                }
#line 760
                                                if (! __cil_tmp75) {
#line 761
                                                  config.autofilter = 1;
                                                } else {
                                                  {
#line 762
                                                  __cil_tmp76 = strcmp(argv[c], "-jpeg_like");
                                                  }
#line 762
                                                  if (! __cil_tmp76) {
#line 763
                                                    config.emulate_jpeg_size = 1;
                                                  } else {
                                                    {
#line 764
                                                    __cil_tmp77 = strcmp(argv[c],
                                                                         "-mt");
                                                    }
#line 764
                                                    if (! __cil_tmp77) {
#line 765
                                                      (config.thread_level) ++;
                                                    } else {
                                                      {
#line 766
                                                      __cil_tmp78 = strcmp(argv[c],
                                                                           "-low_memory");
                                                      }
#line 766
                                                      if (! __cil_tmp78) {
#line 767
                                                        config.low_memory = 1;
                                                      } else {
                                                        {
#line 768
                                                        __cil_tmp79 = strcmp(argv[c],
                                                                             "-strong");
                                                        }
#line 768
                                                        if (! __cil_tmp79) {
#line 769
                                                          config.filter_type = 1;
                                                        } else {
                                                          {
#line 770
                                                          __cil_tmp80 = strcmp(argv[c],
                                                                               "-nostrong");
                                                          }
#line 770
                                                          if (! __cil_tmp80) {
#line 771
                                                            config.filter_type = 0;
                                                          } else {
                                                            {
#line 772
                                                            __cil_tmp81 = strcmp(argv[c],
                                                                                 "-sharpness");
                                                            }
#line 772
                                                            if (! __cil_tmp81) {
#line 772
                                                              if (c < argc - 1) {
                                                                {
#line 773
                                                                c ++;
#line 773
                                                                __cil_tmp82 = strtol(argv[c],
                                                                                     (char **)((void *)0),
                                                                                     0);
#line 773
                                                                config.filter_sharpness = (int )__cil_tmp82;
                                                                }
                                                              } else {
#line 772
                                                                goto _L___24;
                                                              }
                                                            } else {
                                                              _L___24: /* CIL Label */ 
                                                              {
#line 774
                                                              __cil_tmp83 = strcmp(argv[c],
                                                                                   "-pass");
                                                              }
#line 774
                                                              if (! __cil_tmp83) {
#line 774
                                                                if (c < argc - 1) {
                                                                  {
#line 775
                                                                  c ++;
#line 775
                                                                  __cil_tmp84 = strtol(argv[c],
                                                                                       (char **)((void *)0),
                                                                                       0);
#line 775
                                                                  config.pass = (int )__cil_tmp84;
                                                                  }
                                                                } else {
#line 774
                                                                  goto _L___23;
                                                                }
                                                              } else {
                                                                _L___23: /* CIL Label */ 
                                                                {
#line 776
                                                                __cil_tmp85 = strcmp(argv[c],
                                                                                     "-pre");
                                                                }
#line 776
                                                                if (! __cil_tmp85) {
#line 776
                                                                  if (c < argc - 1) {
                                                                    {
#line 777
                                                                    c ++;
#line 777
                                                                    __cil_tmp86 = strtol(argv[c],
                                                                                         (char **)((void *)0),
                                                                                         0);
#line 777
                                                                    config.preprocessing = (int )__cil_tmp86;
                                                                    }
                                                                  } else {
#line 776
                                                                    goto _L___22;
                                                                  }
                                                                } else {
                                                                  _L___22: /* CIL Label */ 
                                                                  {
#line 778
                                                                  __cil_tmp87 = strcmp(argv[c],
                                                                                       "-segments");
                                                                  }
#line 778
                                                                  if (! __cil_tmp87) {
#line 778
                                                                    if (c < argc - 1) {
                                                                      {
#line 779
                                                                      c ++;
#line 779
                                                                      __cil_tmp88 = strtol(argv[c],
                                                                                           (char **)((void *)0),
                                                                                           0);
#line 779
                                                                      config.segments = (int )__cil_tmp88;
                                                                      }
                                                                    } else {
#line 778
                                                                      goto _L___21;
                                                                    }
                                                                  } else {
                                                                    _L___21: /* CIL Label */ 
                                                                    {
#line 780
                                                                    __cil_tmp89 = strcmp(argv[c],
                                                                                         "-partition_limit\220");
                                                                    }
#line 780
                                                                    if (! __cil_tmp89) {
#line 780
                                                                      if (c < argc - 1) {
                                                                        {
#line 781
                                                                        c ++;
#line 781
                                                                        __cil_tmp90 = strtol(argv[c],
                                                                                             (char **)((void *)0),
                                                                                             0);
#line 781
                                                                        config.partition_limit = (int )__cil_tmp90;
                                                                        }
                                                                      } else {
#line 780
                                                                        goto _L___20;
                                                                      }
                                                                    } else {
                                                                      _L___20: /* CIL Label */ 
                                                                      {
#line 782
                                                                      __cil_tmp91 = strcmp(argv[c],
                                                                                           "-map");
                                                                      }
#line 782
                                                                      if (! __cil_tmp91) {
#line 782
                                                                        if (c < argc - 1) {
                                                                          {
#line 783
                                                                          c ++;
#line 783
                                                                          __cil_tmp92 = strtol(argv[c],
                                                                                               (char **)((void *)0),
                                                                                               0);
#line 783
                                                                          picture.extra_info_type = (int )__cil_tmp92;
                                                                          }
                                                                        } else {
#line 782
                                                                          goto _L___19;
                                                                        }
                                                                      } else {
                                                                        _L___19: /* CIL Label */ 
                                                                        {
#line 792
                                                                        __cil_tmp93 = strcmp(argv[c],
                                                                                             "-crop");
                                                                        }
#line 792
                                                                        if (! __cil_tmp93) {
#line 792
                                                                          if (c < argc - 4) {
                                                                            {
#line 793
                                                                            crop = 1;
#line 794
                                                                            c ++;
#line 794
                                                                            __cil_tmp94 = strtol(argv[c],
                                                                                                 (char **)((void *)0),
                                                                                                 0);
#line 794
                                                                            crop_x = (int )__cil_tmp94;
#line 795
                                                                            c ++;
#line 795
                                                                            __cil_tmp95 = strtol(argv[c],
                                                                                                 (char **)((void *)0),
                                                                                                 0);
#line 795
                                                                            crop_y = (int )__cil_tmp95;
#line 796
                                                                            c ++;
#line 796
                                                                            __cil_tmp96 = strtol(argv[c],
                                                                                                 (char **)((void *)0),
                                                                                                 0);
#line 796
                                                                            crop_w = (int )__cil_tmp96;
#line 797
                                                                            c ++;
#line 797
                                                                            __cil_tmp97 = strtol(argv[c],
                                                                                                 (char **)((void *)0),
                                                                                                 0);
#line 797
                                                                            crop_h = (int )__cil_tmp97;
                                                                            }
                                                                          } else {
#line 792
                                                                            goto _L___18;
                                                                          }
                                                                        } else {
                                                                          _L___18: /* CIL Label */ 
                                                                          {
#line 798
                                                                          __cil_tmp98 = strcmp(argv[c],
                                                                                               "-resize");
                                                                          }
#line 798
                                                                          if (! __cil_tmp98) {
#line 798
                                                                            if (c < argc - 2) {
                                                                              {
#line 799
                                                                              c ++;
#line 799
                                                                              __cil_tmp99 = strtol(argv[c],
                                                                                                   (char **)((void *)0),
                                                                                                   0);
#line 799
                                                                              resize_w = (int )__cil_tmp99;
#line 800
                                                                              c ++;
#line 800
                                                                              __cil_tmp100 = strtol(argv[c],
                                                                                                    (char **)((void *)0),
                                                                                                    0);
#line 800
                                                                              resize_h = (int )__cil_tmp100;
                                                                              }
                                                                            } else {
#line 798
                                                                              goto _L___17;
                                                                            }
                                                                          } else {
                                                                            _L___17: /* CIL Label */ 
                                                                            {
#line 802
                                                                            __cil_tmp101 = strcmp(argv[c],
                                                                                                  "-noasm");
                                                                            }
#line 802
                                                                            if (! __cil_tmp101) {
#line 803
                                                                              VP8GetCPUInfo = (void *)0;
                                                                            } else {
                                                                              {
#line 805
                                                                              __cil_tmp102 = strcmp(argv[c],
                                                                                                    "-version\220");
                                                                              }
#line 805
                                                                              if (! __cil_tmp102) {
                                                                                {
#line 806
                                                                                __cil_tmp104 = WebPGetEncoderVersion();
#line 806
                                                                                version = __cil_tmp104;
#line 807
                                                                                printf("%d.%d.%d\n",
                                                                                       (version >> 16) & 255,
                                                                                       (version >> 8) & 255,
                                                                                       version & 255);
                                                                                }
#line 809
                                                                                return (0);
                                                                              } else {
                                                                                {
#line 810
                                                                                __cil_tmp105 = strcmp(argv[c],
                                                                                                      "-progress");
                                                                                }
#line 810
                                                                                if (! __cil_tmp105) {
#line 811
                                                                                  show_progress = 1;
                                                                                } else {
                                                                                  {
#line 812
                                                                                  __cil_tmp106 = strcmp(argv[c],
                                                                                                        "-quiet");
                                                                                  }
#line 812
                                                                                  if (! __cil_tmp106) {
#line 813
                                                                                    quiet = 1;
                                                                                  } else {
                                                                                    {
#line 814
                                                                                    __cil_tmp107 = strcmp(argv[c],
                                                                                                          "-preset");
                                                                                    }
#line 814
                                                                                    if (! __cil_tmp107) {
#line 814
                                                                                      if (c < argc - 1) {
                                                                                        {
#line 816
                                                                                        c ++;
#line 817
                                                                                        __cil_tmp109 = strcmp(argv[c],
                                                                                                              "default");
                                                                                        }
#line 817
                                                                                        if (! __cil_tmp109) {
#line 818
                                                                                          preset = (enum WebPPreset )0;
                                                                                        } else {
                                                                                          {
#line 819
                                                                                          __cil_tmp110 = strcmp(argv[c],
                                                                                                                "photo");
                                                                                          }
#line 819
                                                                                          if (! __cil_tmp110) {
#line 820
                                                                                            preset = (enum WebPPreset )2;
                                                                                          } else {
                                                                                            {
#line 821
                                                                                            __cil_tmp111 = strcmp(argv[c],
                                                                                                                  "picture");
                                                                                            }
#line 821
                                                                                            if (! __cil_tmp111) {
#line 822
                                                                                              preset = (enum WebPPreset )1;
                                                                                            } else {
                                                                                              {
#line 823
                                                                                              __cil_tmp112 = strcmp(argv[c],
                                                                                                                    "drawing");
                                                                                              }
#line 823
                                                                                              if (! __cil_tmp112) {
#line 824
                                                                                                preset = (enum WebPPreset )3;
                                                                                              } else {
                                                                                                {
#line 825
                                                                                                __cil_tmp113 = strcmp(argv[c],
                                                                                                                      "icon");
                                                                                                }
#line 825
                                                                                                if (! __cil_tmp113) {
#line 826
                                                                                                  preset = (enum WebPPreset )4;
                                                                                                } else {
                                                                                                  {
#line 827
                                                                                                  __cil_tmp114 = strcmp(argv[c],
                                                                                                                        "text");
                                                                                                  }
#line 827
                                                                                                  if (! __cil_tmp114) {
#line 828
                                                                                                    preset = (enum WebPPreset )5;
                                                                                                  } else {
                                                                                                    {
#line 830
                                                                                                    fprintf(stderr,
                                                                                                            "Error! Unrecognized preset: %s\n",
                                                                                                            argv[c]);
                                                                                                    }
#line 831
                                                                                                    goto Error;
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                        {
#line 833
                                                                                        __cil_tmp115 = WebPConfigPreset___0(& config,
                                                                                                                            preset,
                                                                                                                            config.quality);
                                                                                        }
#line 833
                                                                                        if (! __cil_tmp115) {
                                                                                          {
#line 834
                                                                                          fprintf(stderr,
                                                                                                  "Error! Could initialize configuration with preset.\n");
                                                                                          }
#line 835
                                                                                          goto Error;
                                                                                        }
                                                                                      } else {
#line 814
                                                                                        goto _L___16;
                                                                                      }
                                                                                    } else {
                                                                                      _L___16: /* CIL Label */ 
                                                                                      {
#line 837
                                                                                      __cil_tmp116 = strcmp(argv[c],
                                                                                                            "-metadata");
                                                                                      }
#line 837
                                                                                      if (! __cil_tmp116) {
#line 837
                                                                                        if (c < argc - 1) {
#line 838
                                                                                          kTokens[0].option = "all";
#line 838
                                                                                          kTokens[0].flag = 7;
#line 838
                                                                                          kTokens[1].option = "none";
#line 838
                                                                                          kTokens[1].flag = 0;
#line 838
                                                                                          kTokens[2].option = "exif";
#line 838
                                                                                          kTokens[2].flag = 1;
#line 838
                                                                                          kTokens[3].option = "icc";
#line 838
                                                                                          kTokens[3].flag = 2;
#line 838
                                                                                          kTokens[4].option = "xmp";
                                                                                          {
#line 838
                                                                                          kTokens[4].flag = 4;
#line 848
                                                                                          kNumTokens = sizeof(kTokens) / sizeof(kTokens[0]);
#line 849
                                                                                          c ++;
#line 849
                                                                                          start = argv[c];
#line 850
                                                                                          __cil_tmp121 = strlen(start);
#line 850
                                                                                          end = start + __cil_tmp121;
                                                                                          }
                                                                                          {
#line 852
                                                                                          while (1) {
                                                                                            while_continue___0: /* CIL Label */ ;
#line 852
                                                                                            if (! (start < end)) {
#line 852
                                                                                              goto while_break___0;
                                                                                            }
                                                                                            {
#line 854
                                                                                            __cil_tmp124 = strchr(start,
                                                                                                                  ',');
#line 854
                                                                                            token = (char const   *)__cil_tmp124;
                                                                                            }
#line 855
                                                                                            if (token == (void *)0) {
#line 855
                                                                                              token = end;
                                                                                            }
#line 857
                                                                                            i = (size_t )0;
                                                                                            {
#line 857
                                                                                            while (1) {
                                                                                              while_continue___1: /* CIL Label */ ;
#line 857
                                                                                              if (! (i < kNumTokens)) {
#line 857
                                                                                                goto while_break___1;
                                                                                              }
                                                                                              {
#line 858
                                                                                              __cil_tmp126 = strlen(kTokens[i].option);
#line 858
                                                                                              __cil_tmp127 = strncmp(start,
                                                                                                                     kTokens[i].option,
                                                                                                                     __cil_tmp126);
                                                                                              }
                                                                                              {
#line 858
                                                                                              __cil_tmp125 = strlen(kTokens[i].option);
                                                                                              }
#line 858
                                                                                              if ((size_t )(token - start) == __cil_tmp125) {
#line 858
                                                                                                if (! __cil_tmp127) {
#line 860
                                                                                                  if (kTokens[i].flag != 0) {
#line 861
                                                                                                    keep_metadata |= kTokens[i].flag;
                                                                                                  } else {
#line 863
                                                                                                    keep_metadata = 0;
                                                                                                  }
#line 865
                                                                                                  goto while_break___1;
                                                                                                }
                                                                                              }
#line 857
                                                                                              i ++;
                                                                                            }
                                                                                            while_break___1: /* CIL Label */ ;
                                                                                            }
#line 868
                                                                                            if (i == kNumTokens) {
                                                                                              {
#line 869
                                                                                              fprintf(stderr,
                                                                                                      "Error! Unknown metadata type \'%.*s\'\n",
                                                                                                      (int )(token - start),
                                                                                                      start);
#line 871
                                                                                              HelpLong();
                                                                                              }
#line 872
                                                                                              return (- 1);
                                                                                            }
#line 874
                                                                                            start = token + 1;
                                                                                          }
                                                                                          while_break___0: /* CIL Label */ ;
                                                                                          }
                                                                                        } else {
#line 837
                                                                                          goto _L;
                                                                                        }
                                                                                      } else {
                                                                                        _L: /* CIL Label */ 
                                                                                        {
#line 883
                                                                                        __cil_tmp128 = strcmp(argv[c],
                                                                                                              "-v");
                                                                                        }
#line 883
                                                                                        if (! __cil_tmp128) {
#line 884
                                                                                          verbose = 1;
                                                                                        } else
#line 885
                                                                                        if ((int )*(argv[c] + 0) == 45) {
                                                                                          {
#line 886
                                                                                          fprintf(stderr,
                                                                                                  "Error! Unknown option \'%s\'\n",
                                                                                                  argv[c]);
#line 887
                                                                                          HelpLong();
                                                                                          }
#line 888
                                                                                          return (- 1);
                                                                                        } else {
#line 890
                                                                                          in_file = argv[c];
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 687
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 893
  if (in_file == (void *)0) {
    {
#line 894
    fprintf(stderr, "No input file specified!\n");
#line 895
    HelpShort();
    }
#line 896
    goto Error;
  }
#line 901
  if (! quiet) {
#line 901
    if (config.lossless == 1) {
#line 902
      if (config.target_size > 0) {
        {
        {
#line 903
        fprintf(stderr, "Encoding for specified size or PSNR is not supported for lossless encoding. Ignoring such option(s)!\n");
        }
        }
      } else
#line 902
      if (config.target_PSNR > (float )0) {
        {
        {
#line 903
        fprintf(stderr, "Encoding for specified size or PSNR is not supported for lossless encoding. Ignoring such option(s)!\n");
        }
        }
      }
#line 906
      if (config.partition_limit > 0) {
        {
#line 907
        fprintf(stderr, "Partition limit option is not required for lossless encoding. Ignoring this option!\n\220");
        }
      }
    }
  }
  {
#line 912
  __cil_tmp129 = WebPValidateConfig(& config);
  }
#line 912
  if (! __cil_tmp129) {
    {
#line 913
    fprintf(stderr, "Error! Invalid configuration.\n");
    }
#line 914
    goto Error;
  }
#line 918
  if (verbose) {
    {
#line 919
    StopwatchReadAndReset(& stop_watch);
    }
  }
#line 921
  if (keep_metadata == 0) {
#line 921
    tmp___0 = (Metadata *)((void *)0);
  } else {
#line 921
    tmp___0 = & metadata;
  }
  {
#line 921
  __cil_tmp131 = ReadPicture(in_file, & picture, keep_alpha, tmp___0);
  }
#line 921
  if (! __cil_tmp131) {
    {
#line 923
    fprintf(stderr, "Error! Cannot read input picture file \'%s\'\n", in_file);
    }
#line 924
    goto Error;
  }
#line 926
  if (show_progress && ! quiet) {
#line 926
    tmp___1 = & ProgressReport;
  } else {
#line 926
    tmp___1 = (int (*)(int  , WebPPicture * const   ))((void *)0);
  }
#line 926
  picture.progress_hook = tmp___1;
#line 927
  if (keep_alpha == 2) {
    {
#line 928
    WebPCleanupTransparentArea(& picture);
    }
  }
#line 931
  if (verbose) {
    {
#line 932
    __cil_tmp134 = StopwatchReadAndReset(& stop_watch);
#line 932
    read_time = __cil_tmp134;
#line 933
    fprintf(stderr, "Time to read input: %.3fs\n", read_time);
    }
  }
#line 937
  if (out_file) {
    {
#line 938
    out = fopen(out_file, "wb");
    }
#line 939
    if (out == (void *)0) {
      {
#line 940
      fprintf(stderr, "Error! Cannot open output file \'%s\'\n", out_file);
      }
#line 941
      goto Error;
    } else
#line 943
    if (! short_output) {
#line 943
      if (! quiet) {
        {
#line 944
        fprintf(stderr, "Saving file \'%s\'\n", out_file);
        }
      }
    }
#line 947
    if (keep_metadata == 0) {
#line 948
      picture.writer = & MyWriter;
#line 949
      picture.custom_ptr = (void *)out;
    } else {
#line 951
      picture.writer = & WebPMemoryWrite;
#line 952
      picture.custom_ptr = (void *)(& memory_writer);
    }
  } else {
#line 955
    out = (FILE *)((void *)0);
#line 956
    if (! quiet) {
#line 956
      if (! short_output) {
        {
#line 957
        fprintf(stderr, "No output file specified (no -o flag). Encoding will\n");
#line 958
        fprintf(stderr, "be performed, but its results discarded.\n\n");
        }
      }
    }
  }
#line 961
  if (! quiet) {
#line 962
    picture.stats = & stats;
#line 963
    picture.user_data = (void *)in_file;
  }
#line 967
  if (verbose) {
    {
#line 968
    StopwatchReadAndReset(& stop_watch);
    }
  }
#line 970
  if (crop != 0) {
    {
#line 972
    __cil_tmp136 = WebPPictureView(& picture, crop_x, crop_y, crop_w, crop_h, & picture);
    }
#line 972
    if (! __cil_tmp136) {
      {
#line 973
      fprintf(stderr, "Error! Cannot crop picture\n");
      }
#line 974
      goto Error;
    }
  }
#line 977
  if ((resize_w | resize_h) > 0) {
    {
#line 978
    __cil_tmp137 = WebPPictureRescale(& picture, resize_w, resize_h);
    }
#line 978
    if (! __cil_tmp137) {
      {
#line 979
      fprintf(stderr, "Error! Cannot resize picture\n");
      }
#line 980
      goto Error;
    }
  }
#line 983
  if (picture.extra_info_type > 0) {
    {
#line 984
    AllocExtraInfo(& picture);
    }
  }
#line 986
  if (print_distortion >= 0) {
    {
#line 987
    WebPPictureCopy(& picture, & original_picture);
    }
  }
  {
#line 989
  __cil_tmp138 = WebPEncode(& config, & picture);
  }
#line 989
  if (! __cil_tmp138) {
    {
#line 990
    fprintf(stderr, "Error! Cannot encode picture as WebP\n");
#line 991
    fprintf(stderr, "Error code: %d (%s)\n", (unsigned int )picture.error_code, kErrorMessages[picture.error_code]);
    }
#line 993
    goto Error;
  }
#line 995
  if (verbose) {
    {
#line 996
    __cil_tmp140 = StopwatchReadAndReset(& stop_watch);
#line 996
    encode_time = __cil_tmp140;
#line 997
    fprintf(stderr, "Time to encode picture: %.3fs\n", encode_time);
    }
  }
#line 1001
  if (dump_file) {
#line 1002
    if (picture.use_argb) {
      {
#line 1003
      fprintf(stderr, "Warning: can\'t dump file (-d option) in lossless mode.");
      }
    } else {
      {
#line 1004
      __cil_tmp141 = DumpPicture(& picture, dump_file);
      }
#line 1004
      if (! __cil_tmp141) {
        {
#line 1005
        fprintf(stderr, "Warning, couldn\'t dump picture %s\n", dump_file);
        }
      }
    }
  }
#line 1009
  if (out != (void *)0) {
#line 1009
    if (keep_metadata != 0) {
      {
#line 1010
      __cil_tmp142 = WriteWebPWithMetadata(out, & picture, & memory_writer, & metadata,
                                           keep_metadata, & metadata_written);
      }
#line 1010
      if (! __cil_tmp142) {
        {
#line 1012
        fprintf(stderr, "Error writing WebP file with metadata!\n");
        }
#line 1013
        goto Error;
      }
    }
  }
#line 1017
  if (! quiet) {
#line 1018
    if (config.lossless) {
      {
#line 1019
      PrintExtraInfoLossless(& picture, short_output, in_file);
      }
    } else {
      {
#line 1021
      PrintExtraInfoLossy(& picture, short_output, config.low_memory, in_file);
      }
    }
#line 1023
    if (! short_output) {
      {
#line 1024
      PrintMetadataInfo(& metadata, metadata_written);
      }
    }
  }
#line 1027
  if (! quiet) {
#line 1027
    if (! short_output) {
#line 1027
      if (print_distortion >= 0) {
        {
#line 1028
        distortion_names[0] = "PSNR";
#line 1028
        distortion_names[1] = "SSIM";
#line 1028
        distortion_names[2] = "LSIM";
#line 1030
        WebPPictureDistortion(& picture, & original_picture, print_distortion, (float *)values);
#line 1032
        fprintf(stderr, "%s: Y:%.2f U:%.2f V:%.2f A:%.2f  Total:%.2f\n", distortion_names[print_distortion],
                (double )values[0], (double )values[1], (double )values[2], (double )values[3],
                (double )values[4]);
        }
      }
    }
  }
#line 1036
  return_value = 0;
  Error: 
  {
#line 1039
  free(memory_writer.mem);
  }
  {
#line 1040
  free(picture.extra_info);
#line 1041
  MetadataFree(& metadata);
#line 1042
  WebPPictureFree(& picture);
#line 1043
  WebPPictureFree(& original_picture);
  }
#line 1044
  if (out != (void *)0) {
    {
#line 1045
    fclose(out);
    }
  }
#line 1048
  return (return_value);
}
}
