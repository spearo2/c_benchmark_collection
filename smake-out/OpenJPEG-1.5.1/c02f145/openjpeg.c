/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__1 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef unsigned long size_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__2 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__2 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_3 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_3 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_4 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_4 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_5 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_5 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_6 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_6 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_7 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_7 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_9 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_8 {
   unsigned long long __wseq ;
   struct __anonstruct_9 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_11 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_10 {
   unsigned long long __g1_start ;
   struct __anonstruct_11 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_8  ;
   unsigned long long __wseq ;
   struct __anonstruct_9 __wseq32 ;
   union __anonunion_10  ;
   unsigned long long __g1_start ;
   struct __anonstruct_11 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_19 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_19 pthread_barrierattr_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_21 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_20 {
   int __count ;
   union __anonunion_21 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_20 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 63 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef int opj_bool;
#line 99
enum RSIZ_CAPABILITIES {
    STD_RSIZ = 0,
    CINEMA2K = 3,
    CINEMA4K = 4
} ;
#line 103 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef enum RSIZ_CAPABILITIES OPJ_RSIZ_CAPABILITIES;
#line 108
enum CINEMA_MODE {
    OFF = 0,
    CINEMA2K_24 = 1,
    CINEMA2K_48 = 2,
    CINEMA4K_24 = 3
} ;
#line 113 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef enum CINEMA_MODE OPJ_CINEMA_MODE;
#line 118
enum PROG_ORDER {
    PROG_UNKNOWN = -1,
    LRCP = 0,
    RLCP = 1,
    RPCL = 2,
    PCRL = 3,
    CPRL = 4
} ;
#line 125 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef enum PROG_ORDER OPJ_PROG_ORDER;
#line 130
enum COLOR_SPACE {
    CLRSPC_UNKNOWN = -1,
    CLRSPC_UNSPECIFIED = 0,
    CLRSPC_SRGB = 1,
    CLRSPC_GRAY = 2,
    CLRSPC_SYCC = 3
} ;
#line 136 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef enum COLOR_SPACE OPJ_COLOR_SPACE;
#line 145
enum CODEC_FORMAT {
    CODEC_UNKNOWN = -1,
    CODEC_J2K = 0,
    CODEC_JPT = 1,
    CODEC_JP2 = 2
} ;
#line 150 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef enum CODEC_FORMAT OPJ_CODEC_FORMAT;
#line 155
enum LIMIT_DECODING {
    NO_LIMITATION = 0,
    LIMIT_TO_MAIN_HEADER = 1,
    DECODE_ALL_BUT_PACKETS = 2
} ;
#line 159 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef enum LIMIT_DECODING OPJ_LIMIT_DECODING;
#line 172 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef void (*opj_msg_callback)(char const   * , void * );
#line 183 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_event_mgr {
   opj_msg_callback error_handler ;
   opj_msg_callback warning_handler ;
   opj_msg_callback info_handler ;
};
#line 190 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_event_mgr opj_event_mgr_t;
#line 202 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_poc {
   int resno0 ;
   int compno0 ;
   int layno1 ;
   int resno1 ;
   int compno1 ;
   int layno0 ;
   int precno0 ;
   int precno1 ;
   OPJ_PROG_ORDER prg1 ;
   OPJ_PROG_ORDER prg ;
   char progorder[5] ;
   int tile ;
   int tx0 ;
   int tx1 ;
   int ty0 ;
   int ty1 ;
   int layS ;
   int resS ;
   int compS ;
   int prcS ;
   int layE ;
   int resE ;
   int compE ;
   int prcE ;
   int txS ;
   int txE ;
   int tyS ;
   int tyE ;
   int dx ;
   int dy ;
   int lay_t ;
   int res_t ;
   int comp_t ;
   int prc_t ;
   int tx0_t ;
   int ty0_t ;
};
#line 225 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_poc opj_poc_t;
#line 230 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_cparameters {
   opj_bool tile_size_on ;
   int cp_tx0 ;
   int cp_ty0 ;
   int cp_tdx ;
   int cp_tdy ;
   int cp_disto_alloc ;
   int cp_fixed_alloc ;
   int cp_fixed_quality ;
   int *cp_matrice ;
   char *cp_comment ;
   int csty ;
   OPJ_PROG_ORDER prog_order ;
   opj_poc_t POC[32] ;
   int numpocs ;
   int tcp_numlayers ;
   float tcp_rates[100] ;
   float tcp_distoratio[100] ;
   int numresolution ;
   int cblockw_init ;
   int cblockh_init ;
   int mode ;
   int irreversible ;
   int roi_compno ;
   int roi_shift ;
   int res_spec ;
   int prcw_init[33] ;
   int prch_init[33] ;
   char infile[4096] ;
   char outfile[4096] ;
   int index_on ;
   char index[4096] ;
   int image_offset_x0 ;
   int image_offset_y0 ;
   int subsampling_dx ;
   int subsampling_dy ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_epc_on ;
   int jpwl_hprot_MH ;
   int jpwl_hprot_TPH_tileno[16] ;
   int jpwl_hprot_TPH[16] ;
   int jpwl_pprot_tileno[16] ;
   int jpwl_pprot_packno[16] ;
   int jpwl_pprot[16] ;
   int jpwl_sens_size ;
   int jpwl_sens_addr ;
   int jpwl_sens_range ;
   int jpwl_sens_MH ;
   int jpwl_sens_TPH_tileno[16] ;
   int jpwl_sens_TPH[16] ;
   OPJ_CINEMA_MODE cp_cinema ;
   int max_comp_size ;
   OPJ_RSIZ_CAPABILITIES cp_rsiz ;
   char tp_on ;
   char tp_flag ;
   char tcp_mct ;
   opj_bool jpip_on ;
};
#line 356 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_cparameters opj_cparameters_t;
#line 363 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_dparameters {
   int cp_reduce ;
   int cp_layer ;
   char infile[4096] ;
   char outfile[4096] ;
   int decod_format ;
   int cod_format ;
   opj_bool jpwl_correct ;
   int jpwl_exp_comps ;
   int jpwl_max_tiles ;
   OPJ_LIMIT_DECODING cp_limit_decoding ;
   unsigned int flags ;
};
#line 413 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_dparameters opj_dparameters_t;
#line 430 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_common_struct {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 436 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_common_struct opj_common_struct_t;
#line 438 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef opj_common_struct_t *opj_common_ptr;
#line 443 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_cinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 447 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_cinfo opj_cinfo_t;
#line 452 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_dinfo {
   opj_event_mgr_t *event_mgr ;
   void *client_data ;
   opj_bool is_decompressor ;
   OPJ_CODEC_FORMAT codec_format ;
   void *j2k_handle ;
   void *jp2_handle ;
   void *mj2_handle ;
};
#line 456 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_dinfo opj_dinfo_t;
#line 475 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_cio {
   opj_common_ptr cinfo ;
   int openmode ;
   unsigned char *buffer ;
   int length ;
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
};
#line 492 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_cio opj_cio_t;
#line 503 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_image_comp {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
   int resno_decoded ;
   int factor ;
   int *data ;
};
#line 528 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_image_comp opj_image_comp_t;
#line 533 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_image {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   OPJ_COLOR_SPACE color_space ;
   opj_image_comp_t *comps ;
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
};
#line 552 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_image opj_image_t;
#line 557 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_image_comptparm {
   int dx ;
   int dy ;
   int w ;
   int h ;
   int x0 ;
   int y0 ;
   int prec ;
   int bpp ;
   int sgnd ;
};
#line 576 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_image_comptparm opj_image_cmptparm_t;
#line 587 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_packet_info {
   int start_pos ;
   int end_ph_pos ;
   int end_pos ;
   double disto ;
};
#line 596 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_packet_info opj_packet_info_t;
#line 603 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_marker_info_t {
   unsigned short type ;
   int pos ;
   int len ;
};
#line 610 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_marker_info_t opj_marker_info_t;
#line 616 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_tp_info {
   int tp_start_pos ;
   int tp_end_header ;
   int tp_end_pos ;
   int tp_start_pack ;
   int tp_numpacks ;
};
#line 627 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_tp_info opj_tp_info_t;
#line 632 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_tile_info {
   double *thresh ;
   int tileno ;
   int start_pos ;
   int end_header ;
   int end_pos ;
   int pw[33] ;
   int ph[33] ;
   int pdx[33] ;
   int pdy[33] ;
   opj_packet_info_t *packet ;
   int numpix ;
   double distotile ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int num_tps ;
   opj_tp_info_t *tp ;
};
#line 667 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_tile_info opj_tile_info_t;
#line 672 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
struct opj_codestream_info {
   double D_max ;
   int packno ;
   int index_write ;
   int image_w ;
   int image_h ;
   OPJ_PROG_ORDER prog ;
   int tile_x ;
   int tile_y ;
   int tile_Ox ;
   int tile_Oy ;
   int tw ;
   int th ;
   int numcomps ;
   int numlayers ;
   int *numdecompos ;
   int marknum ;
   opj_marker_info_t *marker ;
   int maxmarknum ;
   int main_head_start ;
   int main_head_end ;
   int codestream_size ;
   opj_tile_info_t *tile ;
};
#line 719 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
typedef struct opj_codestream_info opj_codestream_info_t;
#line 47 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.h"
struct opj_bio {
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *bp ;
   unsigned int buf ;
   int ct ;
};
#line 58 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.h"
typedef struct opj_bio opj_bio_t;
#line 100 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
enum J2K_STATUS {
    J2K_STATE_MHSOC = 1,
    J2K_STATE_MHSIZ = 2,
    J2K_STATE_MH = 4,
    J2K_STATE_TPHSOT = 8,
    J2K_STATE_TPH = 16,
    J2K_STATE_MT = 32,
    J2K_STATE_NEOC = 64,
    J2K_STATE_ERR = 128
} ;
#line 109 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
typedef enum J2K_STATUS J2K_STATUS;
#line 116
enum T2_MODE {
    THRESH_CALC = 0,
    FINAL_PASS = 1
} ;
#line 119 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
typedef enum T2_MODE J2K_T2_MODE;
#line 124 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
struct opj_stepsize {
   int expn ;
   int mant ;
};
#line 129 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
typedef struct opj_stepsize opj_stepsize_t;
#line 134 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
struct opj_tccp {
   int csty ;
   int numresolutions ;
   int cblkw ;
   int cblkh ;
   int cblksty ;
   int qmfbid ;
   int qntsty ;
   opj_stepsize_t stepsizes[97] ;
   int numgbits ;
   int roishift ;
   int prcw[33] ;
   int prch[33] ;
};
#line 159 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
typedef struct opj_tccp opj_tccp_t;
#line 166 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
struct opj_tcp {
   int first ;
   int csty ;
   OPJ_PROG_ORDER prg ;
   int numlayers ;
   int mct ;
   float rates[100] ;
   int numpocs ;
   int POC ;
   opj_poc_t pocs[32] ;
   unsigned char *ppt_data ;
   unsigned char *ppt_data_first ;
   int ppt ;
   int ppt_store ;
   int ppt_len ;
   float distoratio[100] ;
   opj_tccp_t *tccps ;
};
#line 199 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
typedef struct opj_tcp opj_tcp_t;
#line 204 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
struct opj_cp {
   OPJ_CINEMA_MODE cinema ;
   int max_comp_size ;
   int img_size ;
   OPJ_RSIZ_CAPABILITIES rsiz ;
   char tp_on ;
   char tp_flag ;
   int tp_pos ;
   int disto_alloc ;
   int fixed_alloc ;
   int fixed_quality ;
   int reduce ;
   int layer ;
   OPJ_LIMIT_DECODING limit_decoding ;
   int tx0 ;
   int ty0 ;
   int tdx ;
   int tdy ;
   char *comment ;
   int tw ;
   int th ;
   int *tileno ;
   int tileno_size ;
   unsigned char *ppm_data ;
   unsigned char *ppm_data_first ;
   int ppm ;
   int ppm_store ;
   int ppm_previous ;
   int ppm_len ;
   opj_tcp_t *tcps ;
   int *matrice ;
};
#line 309 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
typedef struct opj_cp opj_cp_t;
#line 314 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
struct opj_j2k {
   opj_common_ptr cinfo ;
   int state ;
   int curtileno ;
   int tp_num ;
   int cur_tp_num ;
   int *cur_totnum_tp ;
   int tlm_start ;
   int totnum_tp ;
   unsigned char *eot ;
   int sot_start ;
   int sod_start ;
   int pos_correction ;
   unsigned char **tile_data ;
   int *tile_len ;
   opj_tcp_t *default_tcp ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_codestream_info_t *cstr_info ;
   opj_cio_t *cio ;
};
#line 369 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
typedef struct opj_j2k opj_j2k_t;
#line 60 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
struct opj_jp2_cdef_info {
   unsigned short cn ;
   unsigned short typ ;
   unsigned short asoc ;
};
#line 63 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef_info opj_jp2_cdef_info_t;
#line 68 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
struct opj_jp2_cdef {
   opj_jp2_cdef_info_t *info ;
   unsigned short n ;
};
#line 72 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
typedef struct opj_jp2_cdef opj_jp2_cdef_t;
#line 77 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
struct opj_jp2_cmap_comp {
   unsigned short cmp ;
   unsigned char mtyp ;
   unsigned char pcol ;
};
#line 81 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
typedef struct opj_jp2_cmap_comp opj_jp2_cmap_comp_t;
#line 86 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
struct opj_jp2_pclr {
   unsigned int *entries ;
   unsigned char *channel_sign ;
   unsigned char *channel_size ;
   opj_jp2_cmap_comp_t *cmap ;
   unsigned short nr_entries ;
   unsigned short nr_channels ;
};
#line 93 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
typedef struct opj_jp2_pclr opj_jp2_pclr_t;
#line 98 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
struct opj_jp2_color {
   unsigned char *icc_profile_buf ;
   int icc_profile_len ;
   opj_jp2_cdef_t *jp2_cdef ;
   opj_jp2_pclr_t *jp2_pclr ;
   unsigned char jp2_has_colr ;
};
#line 106 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
typedef struct opj_jp2_color opj_jp2_color_t;
#line 111 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
struct opj_jp2_comps {
   int depth ;
   int sgnd ;
   int bpcc ;
};
#line 115 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
typedef struct opj_jp2_comps opj_jp2_comps_t;
#line 120 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
struct opj_jp2 {
   opj_common_ptr cinfo ;
   opj_j2k_t *j2k ;
   unsigned int w ;
   unsigned int h ;
   unsigned int numcomps ;
   unsigned int bpc ;
   unsigned int C ;
   unsigned int UnkC ;
   unsigned int IPR ;
   unsigned int meth ;
   unsigned int approx ;
   unsigned int enumcs ;
   unsigned int precedence ;
   unsigned int brand ;
   unsigned int minversion ;
   unsigned int numcl ;
   unsigned int *cl ;
   opj_jp2_comps_t *comps ;
   unsigned int j2k_codestream_offset ;
   unsigned int j2k_codestream_length ;
   opj_bool jpip_on ;
   opj_bool ignore_pclr_cmap_cdef ;
};
#line 145 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
typedef struct opj_jp2 opj_jp2_t;
#line 150 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
struct opj_jp2_box {
   int length ;
   int type ;
   int init_pos ;
};
#line 154 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
typedef struct opj_jp2_box opj_jp2_box_t;
#line 42 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jpt.h"
struct opj_jpt_msg_header {
   unsigned int Id ;
   unsigned int last_byte ;
   unsigned int Class_Id ;
   unsigned int CSn_Id ;
   unsigned int Msg_offset ;
   unsigned int Msg_length ;
   unsigned int Layer_nb ;
};
#line 57 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jpt.h"
typedef struct opj_jpt_msg_header opj_jpt_msg_header_t;
#line 48 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.h"
struct opj_mqc_state {
   unsigned int qeval ;
   int mps ;
   struct opj_mqc_state *nmps ;
   struct opj_mqc_state *nlps ;
};
#line 57 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.h"
typedef struct opj_mqc_state opj_mqc_state_t;
#line 64 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.h"
struct opj_mqc {
   unsigned int c ;
   unsigned int a ;
   unsigned int ct ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
   opj_mqc_state_t *ctxs[19] ;
   opj_mqc_state_t **curctx ;
};
#line 76 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.h"
typedef struct opj_mqc opj_mqc_t;
#line 46 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/raw.h"
struct opj_raw {
   unsigned char c ;
   unsigned int ct ;
   unsigned int lenmax ;
   unsigned int len ;
   unsigned char *bp ;
   unsigned char *start ;
   unsigned char *end ;
};
#line 61 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/raw.h"
typedef struct opj_raw opj_raw_t;
#line 48 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.h"
struct opj_tgt_node {
   struct opj_tgt_node *parent ;
   int value ;
   int low ;
   int known ;
};
#line 53 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.h"
typedef struct opj_tgt_node opj_tgt_node_t;
#line 58 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.h"
struct opj_tgt_tree {
   int numleafsh ;
   int numleafsv ;
   int numnodes ;
   opj_tgt_node_t *nodes ;
};
#line 63 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.h"
typedef struct opj_tgt_tree opj_tgt_tree_t;
#line 49 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.h"
struct opj_pi_resolution {
   int pdx ;
   int pdy ;
   int pw ;
   int ph ;
};
#line 52 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.h"
typedef struct opj_pi_resolution opj_pi_resolution_t;
#line 57 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.h"
struct opj_pi_comp {
   int dx ;
   int dy ;
   int numresolutions ;
   opj_pi_resolution_t *resolutions ;
};
#line 62 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.h"
typedef struct opj_pi_comp opj_pi_comp_t;
#line 67 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.h"
struct opj_pi_iterator {
   char tp_on ;
   short *include ;
   int step_l ;
   int step_r ;
   int step_c ;
   int step_p ;
   int compno ;
   int resno ;
   int precno ;
   int layno ;
   int first ;
   opj_poc_t poc ;
   int numcomps ;
   opj_pi_comp_t *comps ;
   int tx0 ;
   int ty0 ;
   int tx1 ;
   int ty1 ;
   int x ;
   int y ;
   int dx ;
   int dy ;
};
#line 98 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.h"
typedef struct opj_pi_iterator opj_pi_iterator_t;
#line 47 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_seg {
   unsigned char **data ;
   int dataindex ;
   int numpasses ;
   int len ;
   int maxpasses ;
   int numnewpasses ;
   int newlen ;
};
#line 55 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_seg opj_tcd_seg_t;
#line 60 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_pass {
   int rate ;
   double distortiondec ;
   int term ;
   int len ;
};
#line 64 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_pass opj_tcd_pass_t;
#line 69 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_layer {
   int numpasses ;
   int len ;
   double disto ;
   unsigned char *data ;
};
#line 74 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_layer opj_tcd_layer_t;
#line 79 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_cblk_enc {
   unsigned char *data ;
   opj_tcd_layer_t *layers ;
   opj_tcd_pass_t *passes ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int numpasses ;
   int numpassesinlayers ;
   int totalpasses ;
};
#line 89 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_enc opj_tcd_cblk_enc_t;
#line 91 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_cblk_dec {
   unsigned char *data ;
   opj_tcd_seg_t *segs ;
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numbps ;
   int numlenbits ;
   int len ;
   int numnewpasses ;
   int numsegs ;
};
#line 100 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_cblk_dec opj_tcd_cblk_dec_t;
#line 108 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
union __anonunion_23 {
   opj_tcd_cblk_enc_t *enc ;
   opj_tcd_cblk_dec_t *dec ;
};
#line 105 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_precinct {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int cw ;
   int ch ;
   union __anonunion_23 cblks ;
   opj_tgt_tree_t *incltree ;
   opj_tgt_tree_t *imsbtree ;
};
#line 114 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_precinct opj_tcd_precinct_t;
#line 119 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_band {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int bandno ;
   opj_tcd_precinct_t *precincts ;
   int numbps ;
   float stepsize ;
};
#line 125 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_band opj_tcd_band_t;
#line 130 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_resolution {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int pw ;
   int ph ;
   int numbands ;
   opj_tcd_band_t bands[3] ;
};
#line 135 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_resolution opj_tcd_resolution_t;
#line 140 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_tilecomp {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numresolutions ;
   opj_tcd_resolution_t *resolutions ;
   int *data ;
   int numpix ;
};
#line 146 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_tilecomp opj_tcd_tilecomp_t;
#line 151 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_tile {
   int x0 ;
   int y0 ;
   int x1 ;
   int y1 ;
   int numcomps ;
   opj_tcd_tilecomp_t *comps ;
   int numpix ;
   double distotile ;
   double distolayer[100] ;
   int packno ;
};
#line 160 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_tile opj_tcd_tile_t;
#line 165 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd_image {
   int tw ;
   int th ;
   opj_tcd_tile_t *tiles ;
};
#line 168 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd_image opj_tcd_image_t;
#line 173 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
struct opj_tcd {
   int tp_pos ;
   int tp_num ;
   int cur_tp_num ;
   int cur_totnum_tp ;
   int cur_pino ;
   opj_common_ptr cinfo ;
   opj_tcd_image_t *tcd_image ;
   opj_image_t *image ;
   opj_cp_t *cp ;
   opj_tcd_tile_t *tcd_tile ;
   opj_tcp_t *tcp ;
   int tcd_tileno ;
   double encoding_time ;
};
#line 201 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
typedef struct opj_tcd opj_tcd_t;
#line 88 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.h"
typedef short flag_t;
#line 93 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.h"
struct opj_t1 {
   opj_common_ptr cinfo ;
   opj_mqc_t *mqc ;
   opj_raw_t *raw ;
   int *data ;
   flag_t *flags ;
   int w ;
   int h ;
   int datasize ;
   int flagssize ;
   int flags_stride ;
};
#line 109 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.h"
typedef struct opj_t1 opj_t1_t;
#line 45 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.h"
struct opj_t2 {
   opj_common_ptr cinfo ;
   opj_image_t *image ;
   opj_cp_t *cp ;
};
#line 53 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.h"
typedef struct opj_t2 opj_t2_t;
#line 853 "/usr/include/math.h"
enum __anonenum__45 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__46 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__68 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__69 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__70 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___0 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___1 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___0 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___2 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__100 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__103 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___1 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___3 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___2 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___4 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___3 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___5 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___4 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___6 {
    _ISupper___9 = 256,
    _ISlower___9 = 512,
    _ISalpha___9 = 1024,
    _ISdigit___9 = 2048,
    _ISxdigit___9 = 4096,
    _ISspace___9 = 8192,
    _ISprint___9 = 16384,
    _ISgraph___9 = 32768,
    _ISblank___9 = 1,
    _IScntrl___9 = 2,
    _ISpunct___9 = 4,
    _ISalnum___9 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___5 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___7 {
    _ISupper___10 = 256,
    _ISlower___10 = 512,
    _ISalpha___10 = 1024,
    _ISdigit___10 = 2048,
    _ISxdigit___10 = 4096,
    _ISspace___10 = 8192,
    _ISprint___10 = 16384,
    _ISgraph___10 = 32768,
    _ISblank___10 = 1,
    _IScntrl___10 = 2,
    _ISpunct___10 = 4,
    _ISalnum___10 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___6 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___8 {
    _ISupper___11 = 256,
    _ISlower___11 = 512,
    _ISalpha___11 = 1024,
    _ISdigit___11 = 2048,
    _ISxdigit___11 = 4096,
    _ISspace___11 = 8192,
    _ISprint___11 = 16384,
    _ISgraph___11 = 32768,
    _ISblank___11 = 1,
    _IScntrl___11 = 2,
    _ISpunct___11 = 4,
    _ISalnum___11 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___7 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___9 {
    _ISupper___12 = 256,
    _ISlower___12 = 512,
    _ISalpha___12 = 1024,
    _ISdigit___12 = 2048,
    _ISxdigit___12 = 4096,
    _ISspace___12 = 8192,
    _ISprint___12 = 16384,
    _ISgraph___12 = 32768,
    _ISblank___12 = 1,
    _IScntrl___12 = 2,
    _ISpunct___12 = 4,
    _ISalnum___12 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___8 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___10 {
    _ISupper___13 = 256,
    _ISlower___13 = 512,
    _ISalpha___13 = 1024,
    _ISdigit___13 = 2048,
    _ISxdigit___13 = 4096,
    _ISspace___13 = 8192,
    _ISprint___13 = 16384,
    _ISgraph___13 = 32768,
    _ISblank___13 = 1,
    _IScntrl___13 = 2,
    _ISpunct___13 = 4,
    _ISalnum___13 = 8
} ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 89
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 158
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1
} ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_107 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 47 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_108 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_109 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 59 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_110 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_111 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_112 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 78 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_113 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 85 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_114 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_115 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_116 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_117 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 109 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_118 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 117 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_119 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion_120 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion_107  ;
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
   union __anonunion_108  ;
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
   union __anonunion_109  ;
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
   union __anonunion_110  ;
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
   union __anonunion_111  ;
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
   union __anonunion_112  ;
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
   union __anonunion_113  ;
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
   union __anonunion_114  ;
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
   union __anonunion_115  ;
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
   union __anonunion_116  ;
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
   union __anonunion_117  ;
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
   union __anonunion_118  ;
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
   union __anonunion_119  ;
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
   union __anonunion_120  ;
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 32 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__137 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__140 {
    _ISupper___14 = 256,
    _ISlower___14 = 512,
    _ISalpha___14 = 1024,
    _ISdigit___14 = 2048,
    _ISxdigit___14 = 4096,
    _ISspace___14 = 8192,
    _ISprint___14 = 16384,
    _ISgraph___14 = 32768,
    _ISblank___14 = 1,
    _IScntrl___14 = 2,
    _ISpunct___14 = 4,
    _ISalnum___14 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___9 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___11 {
    _ISupper___15 = 256,
    _ISlower___15 = 512,
    _ISalpha___15 = 1024,
    _ISdigit___15 = 2048,
    _ISxdigit___15 = 4096,
    _ISspace___15 = 8192,
    _ISprint___15 = 16384,
    _ISgraph___15 = 32768,
    _ISblank___15 = 1,
    _IScntrl___15 = 2,
    _ISpunct___15 = 4,
    _ISalnum___15 = 8
} ;
#line 255 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
struct j2k_prog_order {
   OPJ_PROG_ORDER enum_prog ;
   char str_prog[5] ;
};
#line 258 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
typedef struct j2k_prog_order j2k_prog_order_t;
#line 1651 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
struct opj_dec_mstabent {
   int id ;
   int states ;
   void (*handler)(opj_j2k_t * ) ;
};
#line 1658 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
typedef struct opj_dec_mstabent opj_dec_mstabent_t;
#line 853 "/usr/include/math.h"
enum __anonenum__92___10 {
    FP_NAN___16 = 0,
    FP_INFINITE___16 = 1,
    FP_ZERO___16 = 2,
    FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___12 {
    _ISupper___16 = 256,
    _ISlower___16 = 512,
    _ISalpha___16 = 1024,
    _ISdigit___16 = 2048,
    _ISxdigit___16 = 4096,
    _ISspace___16 = 8192,
    _ISprint___16 = 16384,
    _ISgraph___16 = 32768,
    _ISblank___16 = 1,
    _IScntrl___16 = 2,
    _ISpunct___16 = 4,
    _ISalnum___16 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___11 {
    FP_NAN___17 = 0,
    FP_INFINITE___17 = 1,
    FP_ZERO___17 = 2,
    FP_SUBNORMAL___17 = 3,
    FP_NORMAL___17 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___13 {
    _ISupper___17 = 256,
    _ISlower___17 = 512,
    _ISalpha___17 = 1024,
    _ISdigit___17 = 2048,
    _ISxdigit___17 = 4096,
    _ISspace___17 = 8192,
    _ISprint___17 = 16384,
    _ISgraph___17 = 32768,
    _ISblank___17 = 1,
    _IScntrl___17 = 2,
    _ISpunct___17 = 4,
    _ISalnum___17 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___12 {
    FP_NAN___18 = 0,
    FP_INFINITE___18 = 1,
    FP_ZERO___18 = 2,
    FP_SUBNORMAL___18 = 3,
    FP_NORMAL___18 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___14 {
    _ISupper___18 = 256,
    _ISlower___18 = 512,
    _ISalpha___18 = 1024,
    _ISdigit___18 = 2048,
    _ISxdigit___18 = 4096,
    _ISspace___18 = 8192,
    _ISprint___18 = 16384,
    _ISgraph___18 = 32768,
    _ISblank___18 = 1,
    _IScntrl___18 = 2,
    _ISpunct___18 = 4,
    _ISalnum___18 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__92___13 {
    FP_NAN___19 = 0,
    FP_INFINITE___19 = 1,
    FP_ZERO___19 = 2,
    FP_SUBNORMAL___19 = 3,
    FP_NORMAL___19 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__22___15 {
    _ISupper___19 = 256,
    _ISlower___19 = 512,
    _ISalpha___19 = 1024,
    _ISdigit___19 = 2048,
    _ISxdigit___19 = 4096,
    _ISspace___19 = 8192,
    _ISprint___19 = 16384,
    _ISgraph___19 = 32768,
    _ISblank___19 = 1,
    _IScntrl___19 = 2,
    _ISpunct___19 = 4,
    _ISalnum___19 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__45___0 {
    FP_NAN___20 = 0,
    FP_INFINITE___20 = 1,
    FP_ZERO___20 = 2,
    FP_SUBNORMAL___20 = 3,
    FP_NORMAL___20 = 4
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__160 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 6 "../../applications/common/opj_getopt.h"
struct opj_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 12 "../../applications/common/opj_getopt.h"
typedef struct opj_option opj_option_t;
#line 36 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.h"
struct raw_cparameters {
   int rawWidth ;
   int rawHeight ;
   int rawComp ;
   int rawBitDepth ;
   opj_bool rawSigned ;
};
#line 48 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.h"
typedef struct raw_cparameters raw_cparameters_t;
#line 68 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
struct dircnt {
   char *filename_buf ;
   char **filename ;
};
#line 73 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
typedef struct dircnt dircnt_t;
#line 76 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
struct img_folder {
   char *imgdirpath ;
   char const   *out_format ;
   char set_imgdir ;
   char set_out_format ;
};
#line 86 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
typedef struct img_folder img_fol_t;
#line 853 "/usr/include/math.h"
enum __anonenum__161 {
    FP_NAN___21 = 0,
    FP_INFINITE___21 = 1,
    FP_ZERO___21 = 2,
    FP_SUBNORMAL___21 = 3,
    FP_NORMAL___21 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__162 {
    _ISupper___20 = 256,
    _ISlower___20 = 512,
    _ISalpha___20 = 1024,
    _ISdigit___20 = 2048,
    _ISxdigit___20 = 4096,
    _ISspace___20 = 8192,
    _ISprint___20 = 16384,
    _ISgraph___20 = 32768,
    _ISblank___20 = 1,
    _IScntrl___20 = 2,
    _ISpunct___20 = 4,
    _ISalnum___20 = 8
} ;
#line 510 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
typedef unsigned short WORD;
#line 513 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
typedef unsigned int DWORD;
#line 515 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
struct __anonenum__103 {
   WORD bfType ;
   DWORD bfSize ;
   WORD bfReserved1 ;
   WORD bfReserved2 ;
   DWORD bfOffBits ;
};
#line 521 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
typedef struct __anonenum__103 BITMAPFILEHEADER_t;
#line 523 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
struct __anonstruct_163 {
   DWORD biSize ;
   DWORD biWidth ;
   DWORD biHeight ;
   WORD biPlanes ;
   WORD biBitCount ;
   DWORD biCompression ;
   DWORD biSizeImage ;
   DWORD biXpelsPerMeter ;
   DWORD biYpelsPerMeter ;
   DWORD biClrUsed ;
   DWORD biClrImportant ;
};
#line 535 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
typedef struct __anonstruct_163 BITMAPINFOHEADER_t;
#line 1472 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
struct pnm_header {
   int width ;
   int height ;
   int maxval ;
   int depth ;
   int format ;
   char rgb ;
   char rgba ;
   char gray ;
   char graya ;
   char bw ;
   char ok ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__45___1 {
    FP_NAN___22 = 0,
    FP_INFINITE___22 = 1,
    FP_ZERO___22 = 2,
    FP_SUBNORMAL___22 = 3,
    FP_NORMAL___22 = 4
} ;
#line 853
enum __anonenum__45___2 {
    FP_NAN___23 = 0,
    FP_INFINITE___23 = 1,
    FP_ZERO___23 = 2,
    FP_SUBNORMAL___23 = 3,
    FP_NORMAL___23 = 4
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__160___0 {
    DT_UNKNOWN___0 = 0,
    DT_FIFO___0 = 1,
    DT_CHR___0 = 2,
    DT_DIR___0 = 4,
    DT_BLK___0 = 6,
    DT_REG___0 = 8,
    DT_LNK___0 = 10,
    DT_SOCK___0 = 12,
    DT_WHT___0 = 14
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__161___0 {
    FP_NAN___24 = 0,
    FP_INFINITE___24 = 1,
    FP_ZERO___24 = 2,
    FP_SUBNORMAL___24 = 3,
    FP_NORMAL___24 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__162___0 {
    _ISupper___21 = 256,
    _ISlower___21 = 512,
    _ISalpha___21 = 1024,
    _ISdigit___21 = 2048,
    _ISxdigit___21 = 4096,
    _ISspace___21 = 8192,
    _ISprint___21 = 16384,
    _ISgraph___21 = 32768,
    _ISblank___21 = 1,
    _IScntrl___21 = 2,
    _ISpunct___21 = 4,
    _ISalnum___21 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__45___3 {
    FP_NAN___25 = 0,
    FP_INFINITE___25 = 1,
    FP_ZERO___25 = 2,
    FP_SUBNORMAL___25 = 3,
    FP_NORMAL___25 = 4
} ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 75
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 78
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 82
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 88
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 119
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 139
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 149
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 153
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 159
extern char *__tzname[2] ;
#line 160
extern int __daylight ;
#line 161
extern long __timezone ;
#line 166
extern char *tzname[2] ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 174
extern int daylight ;
#line 175
extern long timezone ;
#line 190
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 193
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 196
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 205
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 210
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 213
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 216
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 224
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 229
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 234
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 239
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 242
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 247
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 251
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 257
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 732 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.h"
char const   *opj_version(void) ;
#line 747
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) ;
#line 753
void opj_image_destroy(opj_image_t *image ) ;
#line 772
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) ;
#line 778
void opj_cio_close(opj_cio_t *cio ) ;
#line 785
int cio_tell(opj_cio_t *cio ) ;
#line 791
void cio_seek(opj_cio_t *cio , int pos ) ;
#line 799
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) ;
#line 811
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) ;
#line 816
void opj_destroy_decompress(opj_dinfo_t *dinfo ) ;
#line 821
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) ;
#line 828
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) ;
#line 835
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) ;
#line 844
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 850
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) ;
#line 855
void opj_destroy_compress(opj_cinfo_t *cinfo ) ;
#line 877
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) ;
#line 884
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 893
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) ;
#line 902
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) ;
#line 907
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) ;
#line 46 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k_lib.h"
double opj_clock(void) ;
#line 52 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/event.h"
opj_bool opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt 
                       , ...) ;
#line 67 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.h"
opj_bio_t *bio_create(void) ;
#line 72
void bio_destroy(opj_bio_t *bio ) ;
#line 78
int bio_numbytes(opj_bio_t *bio ) ;
#line 85
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 92
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) ;
#line 99
void bio_write(opj_bio_t *bio , int v , int n ) ;
#line 106
int bio_read(opj_bio_t *bio , int n ) ;
#line 112
int bio_flush(opj_bio_t *bio ) ;
#line 118
int bio_inalign(opj_bio_t *bio ) ;
#line 59 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.h"
int cio_numbytesleft(opj_cio_t *cio ) ;
#line 65
unsigned char *cio_getbp(opj_cio_t *cio ) ;
#line 73
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) ;
#line 80
unsigned int cio_read(opj_cio_t *cio , int n ) ;
#line 86
void cio_skip(opj_cio_t *cio , int n ) ;
#line 43 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/image.h"
opj_image_t *opj_image_create0(void) ;
#line 379 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.h"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) ;
#line 384
void j2k_destroy_decompress(opj_j2k_t *j2k ) ;
#line 391
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) ;
#line 399
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 407
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 413
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) ;
#line 418
void j2k_destroy_compress(opj_j2k_t *j2k ) ;
#line 426
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 430
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) ;
#line 439
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 164 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.h"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 172
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 178
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) ;
#line 183
void jp2_destroy_decompress(opj_jp2_t *jp2 ) ;
#line 190
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) ;
#line 198
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) ;
#line 204
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) ;
#line 209
void jp2_destroy_compress(opj_jp2_t *jp2 ) ;
#line 217
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) ;
#line 226
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 65 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jpt.h"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) ;
#line 73
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) ;
#line 85 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.h"
opj_mqc_t *mqc_create(void) ;
#line 90
void mqc_destroy(opj_mqc_t *mqc ) ;
#line 96
int mqc_numbytes(opj_mqc_t *mqc ) ;
#line 102
void mqc_resetstates(opj_mqc_t *mqc ) ;
#line 110
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) ;
#line 116
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) ;
#line 128
void mqc_encode(opj_mqc_t *mqc , int d ) ;
#line 133
void mqc_flush(opj_mqc_t *mqc ) ;
#line 140
void mqc_bypass_init_enc(opj_mqc_t *mqc ) ;
#line 148
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) ;
#line 155
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) ;
#line 160
void mqc_reset_enc(opj_mqc_t *mqc ) ;
#line 166
int mqc_restart_enc(opj_mqc_t *mqc ) ;
#line 171
void mqc_restart_init_enc(opj_mqc_t *mqc ) ;
#line 176
void mqc_erterm_enc(opj_mqc_t *mqc ) ;
#line 181
void mqc_segmark_enc(opj_mqc_t *mqc ) ;
#line 188
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) ;
#line 194
int mqc_decode(opj_mqc_t *mqc ) ;
#line 70 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/raw.h"
opj_raw_t *raw_create(void) ;
#line 75
void raw_destroy(opj_raw_t *raw ) ;
#line 81
int raw_numbytes(opj_raw_t *raw ) ;
#line 88
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) ;
#line 94
int raw_decode(opj_raw_t *raw ) ;
#line 74 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.h"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) ;
#line 79
void tgt_destroy(opj_tgt_tree_t *tree ) ;
#line 84
void tgt_reset(opj_tgt_tree_t *tree ) ;
#line 91
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) ;
#line 99
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 108
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) ;
#line 112 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.h"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) ;
#line 125
opj_bool pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                          int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 134
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) ;
#line 143
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) ;
#line 150
opj_bool pi_next(opj_pi_iterator_t *pi ) ;
#line 210 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.h"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) ;
#line 216
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) ;
#line 221
void tcd_destroy(opj_tcd_t *tcd ) ;
#line 229
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 234
void tcd_free_encode(opj_tcd_t *tcd ) ;
#line 242
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) ;
#line 249
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) ;
#line 250
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) ;
#line 251
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) ;
#line 252
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) ;
#line 253
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) ;
#line 254
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) ;
#line 264
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) ;
#line 273
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) ;
#line 278
void tcd_free_decode(opj_tcd_t *tcd ) ;
#line 279
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) ;
#line 122 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.h"
opj_t1_t *t1_create(opj_common_ptr cinfo ) ;
#line 127
void t1_destroy(opj_t1_t *t1 ) ;
#line 134
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) ;
#line 141
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) ;
#line 55 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/dwt.h"
void dwt_encode(opj_tcd_tilecomp_t *tilec ) ;
#line 62
void dwt_decode(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 68
int dwt_getgain(int orient ) ;
#line 75
double dwt_getnorm(int level , int orient ) ;
#line 81
void dwt_encode_real(opj_tcd_tilecomp_t *tilec ) ;
#line 88
void dwt_decode_real(opj_tcd_tilecomp_t *tilec , int numres ) ;
#line 94
int dwt_getgain_real(int orient ) ;
#line 101
double dwt_getnorm_real(int level , int orient ) ;
#line 107
void dwt_calc_explicit_stepsizes(opj_tccp_t *tccp , int prec ) ;
#line 74 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.h"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) ;
#line 84
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) ;
#line 93
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) ;
#line 98
void t2_destroy(opj_t2_t *t2 ) ;
#line 55 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mct.h"
void mct_encode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 63
void mct_decode(int *c0 , int *c1 , int *c2 , int n ) ;
#line 69
double mct_getnorm(int compno ) ;
#line 78
void mct_encode_real(int *c0 , int *c1 , int *c2 , int n ) ;
#line 86
void mct_decode_real(float *c0 , float *c1 , float *c2 , int n ) ;
#line 92
double mct_getnorm_real(int compno ) ;
#line 50 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/int.h"
__inline static int int_min(int a , int b ) 
{ 
  int tmp ;

  {
#line 51
  if (a < b) {
#line 51
    tmp = a;
  } else {
#line 51
    tmp = b;
  }
#line 51
  return (tmp);
}
}
#line 57 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/int.h"
__inline static int int_max(int a , int b ) 
{ 
  int tmp ;

  {
#line 58
  if (a > b) {
#line 58
    tmp = a;
  } else {
#line 58
    tmp = b;
  }
#line 58
  return (tmp);
}
}
#line 69 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/int.h"
__inline static int int_clamp(int a , int min , int max ) 
{ 


  {
#line 70
  if (a < min) {
#line 71
    return (min);
  }
#line 72
  if (a > max) {
#line 73
    return (max);
  }
#line 74
  return (a);
}
}
#line 79 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/int.h"
__inline static int int_abs(int a ) 
{ 
  int tmp ;

  {
#line 80
  if (a < 0) {
#line 80
    tmp = - a;
  } else {
#line 80
    tmp = a;
  }
#line 80
  return (tmp);
}
}
#line 86 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/int.h"
__inline static int int_ceildiv(int a , int b ) 
{ 


  {
#line 87
  return (((a + b) - 1) / b);
}
}
#line 93 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/int.h"
__inline static int int_ceildivpow2(int a , int b ) 
{ 


  {
#line 94
  return (((a + (1 << b)) - 1) >> b);
}
}
#line 100 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/int.h"
__inline static int int_floordivpow2(int a , int b ) 
{ 


  {
#line 101
  return (a >> b);
}
}
#line 107 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/int.h"
__inline static int int_floorlog2(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 109
  l = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (a > 1)) {
#line 109
      goto while_break;
    }
#line 110
    a >>= 1;
#line 109
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (l);
}
}
#line 56 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/fix.h"
__inline static int fix_mul(int a , int b ) 
{ 
  long long temp ;

  {
#line 57
  temp = (long long )a * (long long )b;
#line 58
  temp += temp & 4096LL;
#line 59
  return ((int )(temp >> 13));
}
}
#line 53 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cidx_manager.h"
int write_cidx(int offset , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t cstr_info ,
               int j2klen ) ;
#line 68 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/indexbox_manager.h"
int write_tpix(int coff , opj_codestream_info_t cstr_info , int j2klen , opj_cio_t *cio ) ;
#line 79
int write_thix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) ;
#line 92
int write_ppix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 105
int write_phix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) ;
#line 115
void write_manf(int second , int v , opj_jp2_box_t *box , opj_cio_t *cio ) ;
#line 52 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tpix_manager.c"
int write_tpixfaix(int coff , int compno , opj_codestream_info_t cstr_info , int j2klen ,
                   opj_cio_t *cio ) ;
#line 55 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tpix_manager.c"
int write_tpix(int coff , opj_codestream_info_t cstr_info , int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 58
  lenp = cio_tell(cio);
#line 59
  cio_skip(cio, 4);
#line 60
  cio_write(cio, (unsigned long long )1953524088, 4);
#line 62
  write_tpixfaix(coff, 0, cstr_info, j2klen, cio);
#line 64
  __cil_tmp8 = cio_tell(cio);
#line 64
  len = __cil_tmp8 - lenp;
#line 65
  cio_seek(cio, lenp);
#line 66
  cio_write(cio, (unsigned long long )len, 4);
#line 67
  cio_seek(cio, lenp + len);
  }
#line 69
  return (len);
}
}
#line 79
int get_num_max_tile_parts(opj_codestream_info_t cstr_info ) ;
#line 81 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tpix_manager.c"
int write_tpixfaix(int coff , int compno , opj_codestream_info_t cstr_info , int j2klen ,
                   opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int j ;
  int Aux ;
  int num_max_tile_parts ;
  int size_of_coding ;
  opj_tp_info_t tp ;
  int version ;
  int __cil_tmp15 ;
  double __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;

  {
  {
#line 91
  num_max_tile_parts = get_num_max_tile_parts(cstr_info);
#line 93
  __cil_tmp16 = pow((double )2, (double )32);
  }
#line 93
  if ((double )j2klen > __cil_tmp16) {
#line 94
    size_of_coding = 8;
#line 95
    if (num_max_tile_parts == 1) {
#line 95
      tmp = 1;
    } else {
#line 95
      tmp = 3;
    }
#line 95
    version = tmp;
  } else {
#line 98
    size_of_coding = 4;
#line 99
    if (num_max_tile_parts == 1) {
#line 99
      tmp___0 = 0;
    } else {
#line 99
      tmp___0 = 2;
    }
#line 99
    version = tmp___0;
  }
  {
#line 102
  lenp = cio_tell(cio);
#line 103
  cio_skip(cio, 4);
#line 104
  cio_write(cio, (unsigned long long )1717660024, 4);
#line 105
  cio_write(cio, (unsigned long long )version, 1);
#line 107
  cio_write(cio, (unsigned long long )num_max_tile_parts, size_of_coding);
#line 108
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 109
  i = 0;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < cstr_info.tw * cstr_info.th)) {
#line 109
      goto while_break;
    }
#line 110
    j = 0;
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! (j < (cstr_info.tile + i)->num_tps)) {
#line 110
        goto while_break___0;
      }
      {
#line 111
      tp = *((cstr_info.tile + i)->tp + j);
#line 112
      cio_write(cio, (unsigned long long )(tp.tp_start_pos - coff), size_of_coding);
#line 113
      cio_write(cio, (unsigned long long )((tp.tp_end_pos - tp.tp_start_pos) + 1),
                size_of_coding);
      }
#line 114
      if (version & 2) {
#line 115
        if ((cstr_info.tile + i)->num_tps == 1) {
#line 115
          if (*(cstr_info.numdecompos + compno) > 1) {
#line 116
            Aux = *(cstr_info.numdecompos + compno) + 1;
          } else {
#line 118
            Aux = j + 1;
          }
        } else {
#line 118
          Aux = j + 1;
        }
        {
#line 120
        cio_write(cio, (unsigned long long )Aux, 4);
        }
      }
#line 110
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 127
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 127
      if (! (j < num_max_tile_parts)) {
#line 127
        goto while_break___1;
      }
      {
#line 128
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 129
      cio_write(cio, (unsigned long long )0, size_of_coding);
      }
#line 130
      if (version & 2) {
        {
#line 131
        cio_write(cio, (unsigned long long )0, 4);
        }
      }
#line 132
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 109
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  __cil_tmp23 = cio_tell(cio);
#line 136
  len = __cil_tmp23 - lenp;
#line 137
  cio_seek(cio, lenp);
#line 138
  cio_write(cio, (unsigned long long )len, 4);
#line 139
  cio_seek(cio, lenp + len);
  }
#line 141
  return (len);
}
}
#line 145 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tpix_manager.c"
int get_num_max_tile_parts(opj_codestream_info_t cstr_info ) 
{ 
  int num_max_tp ;
  int i ;
  int tmp ;
  int __cil_tmp5 ;

  {
#line 147
  num_max_tp = 0;
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < cstr_info.tw * cstr_info.th)) {
#line 149
      goto while_break;
    }
#line 150
    if ((cstr_info.tile + i)->num_tps > num_max_tp) {
#line 150
      tmp = (cstr_info.tile + i)->num_tps;
    } else {
#line 150
      tmp = num_max_tp;
    }
#line 150
    num_max_tp = tmp;
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (num_max_tp);
}
}
#line 50 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/thix_manager.c"
int write_tilemhix(int coff , opj_codestream_info_t cstr_info , int tileno , opj_cio_t *cio ) ;
#line 52 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/thix_manager.c"
int write_thix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int tileno ;
  opj_jp2_box_t *box ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 58
  lenp = 0;
#line 59
  __cil_tmp9 = calloc((unsigned long )(cstr_info.tw * cstr_info.th), sizeof(opj_jp2_box_t ));
#line 59
  box = (opj_jp2_box_t *)__cil_tmp9;
#line 61
  i = 0;
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < 2)) {
#line 61
      goto while_break;
    }
#line 62
    if (i) {
      {
#line 63
      cio_seek(cio, lenp);
      }
    }
    {
#line 65
    lenp = cio_tell(cio);
#line 66
    cio_skip(cio, 4);
#line 67
    cio_write(cio, (unsigned long long )1952999800, 4);
#line 68
    write_manf(i, cstr_info.tw * cstr_info.th, box, cio);
#line 70
    tileno = 0;
    }
    {
#line 70
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 70
      if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 70
        goto while_break___0;
      }
      {
#line 71
      (box + tileno)->length = write_tilemhix(coff, cstr_info, tileno, cio);
#line 72
      (box + tileno)->type = 1835559288;
      }
#line 70
      tileno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 75
    __cil_tmp13 = cio_tell(cio);
#line 75
    len = __cil_tmp13 - lenp;
#line 76
    cio_seek(cio, lenp);
#line 77
    cio_write(cio, (unsigned long long )len, 4);
#line 78
    cio_seek(cio, lenp + len);
    }
#line 61
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  free(box);
  }
#line 83
  return (len);
}
}
#line 86 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/thix_manager.c"
int write_tilemhix(int coff , opj_codestream_info_t cstr_info , int tileno , opj_cio_t *cio ) 
{ 
  int i ;
  opj_tile_info_t tile ;
  opj_tp_info_t tp ;
  int len ;
  int lenp ;
  opj_marker_info_t *marker ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 94
  lenp = cio_tell(cio);
#line 95
  cio_skip(cio, 4);
#line 96
  cio_write(cio, (unsigned long long )1835559288, 4);
#line 98
  tile = *(cstr_info.tile + tileno);
#line 99
  tp = *(tile.tp + 0);
#line 101
  cio_write(cio, (unsigned long long )((tp.tp_end_header - tp.tp_start_pos) + 1),
            8);
#line 103
  marker = (cstr_info.tile + tileno)->marker;
#line 105
  i = 0;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < (cstr_info.tile + tileno)->marknum)) {
#line 105
      goto while_break;
    }
    {
#line 106
    cio_write(cio, (unsigned long long )(marker + i)->type, 2);
#line 107
    cio_write(cio, (unsigned long long )0, 2);
#line 108
    cio_write(cio, (unsigned long long )((marker + i)->pos - coff), 8);
#line 109
    cio_write(cio, (unsigned long long )(marker + i)->len, 2);
    }
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  __cil_tmp13 = cio_tell(cio);
#line 114
  len = __cil_tmp13 - lenp;
#line 115
  cio_seek(cio, lenp);
#line 116
  cio_write(cio, (unsigned long long )len, 4);
#line 117
  cio_seek(cio, lenp + len);
  }
#line 119
  return (len);
}
}
#line 52 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/ppix_manager.c"
int write_ppixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) ;
#line 54 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/ppix_manager.c"
int write_ppix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int compno ;
  int i ;
  opj_jp2_box_t *box ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 61
  lenp = - 1;
#line 62
  __cil_tmp11 = calloc((unsigned long )cstr_info.numcomps, sizeof(opj_jp2_box_t ));
#line 62
  box = (opj_jp2_box_t *)__cil_tmp11;
#line 64
  i = 0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i < 2)) {
#line 64
      goto while_break;
    }
#line 65
    if (i) {
      {
#line 65
      cio_seek(cio, lenp);
      }
    }
    {
#line 67
    lenp = cio_tell(cio);
#line 68
    cio_skip(cio, 4);
#line 69
    cio_write(cio, (unsigned long long )1886415224, 4);
#line 71
    write_manf(i, cstr_info.numcomps, box, cio);
#line 73
    compno = 0;
    }
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      if (! (compno < cstr_info.numcomps)) {
#line 73
        goto while_break___0;
      }
      {
#line 74
      (box + compno)->length = write_ppixfaix(coff, compno, cstr_info, EPHused, j2klen,
                                              cio);
#line 75
      (box + compno)->type = 1717660024;
      }
#line 73
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 78
    __cil_tmp15 = cio_tell(cio);
#line 78
    len = __cil_tmp15 - lenp;
#line 79
    cio_seek(cio, lenp);
#line 80
    cio_write(cio, (unsigned long long )len, 4);
#line 81
    cio_seek(cio, lenp + len);
    }
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 84
  free(box);
  }
#line 86
  return (len);
}
}
#line 89 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/ppix_manager.c"
int write_ppixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int tileno ;
  int version ;
  int i ;
  int nmax ;
  int size_of_coding ;
  opj_tile_info_t *tile_Idx ;
  opj_packet_info_t packet ;
  int resno ;
  int precno ;
  int layno ;
  int num_packet ;
  int numOfres ;
  int numOfprec ;
  int numOflayers ;
  double __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
  {
#line 96
  packet.start_pos = - 1;
#line 96
  packet.end_ph_pos = packet.start_pos;
#line 96
  packet.end_pos = packet.end_ph_pos;
#line 99
  __cil_tmp23 = pow((double )2, (double )32);
  }
#line 99
  if ((double )j2klen > __cil_tmp23) {
#line 100
    size_of_coding = 8;
#line 101
    version = 1;
  } else {
#line 104
    size_of_coding = 4;
#line 105
    version = 0;
  }
  {
#line 108
  lenp = cio_tell(cio);
#line 109
  cio_skip(cio, 4);
#line 110
  cio_write(cio, (unsigned long long )1717660024, 4);
#line 111
  cio_write(cio, (unsigned long long )version, 1);
#line 113
  nmax = 0;
#line 114
  i = 0;
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i <= *(cstr_info.numdecompos + compno))) {
#line 114
      goto while_break;
    }
#line 115
    nmax += ((cstr_info.tile + 0)->ph[i] * (cstr_info.tile + 0)->pw[i]) * cstr_info.numlayers;
#line 114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  cio_write(cio, (unsigned long long )nmax, size_of_coding);
#line 118
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 120
  tileno = 0;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 120
      goto while_break___0;
    }
#line 121
    tile_Idx = cstr_info.tile + tileno;
#line 123
    num_packet = 0;
#line 124
    numOfres = *(cstr_info.numdecompos + compno) + 1;
#line 126
    resno = 0;
    {
#line 126
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 126
      if (! (resno < numOfres)) {
#line 126
        goto while_break___1;
      }
#line 127
      numOfprec = tile_Idx->pw[resno] * tile_Idx->ph[resno];
#line 128
      precno = 0;
      {
#line 128
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 128
        if (! (precno < numOfprec)) {
#line 128
          goto while_break___2;
        }
#line 129
        numOflayers = cstr_info.numlayers;
#line 130
        layno = 0;
        {
#line 130
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 130
          if (! (layno < numOflayers)) {
#line 130
            goto while_break___3;
          }
          {
#line 133
          if ((int )cstr_info.prog == 0) {
#line 133
            goto case_0;
          }
#line 136
          if ((int )cstr_info.prog == 1) {
#line 136
            goto case_1;
          }
#line 139
          if ((int )cstr_info.prog == 2) {
#line 139
            goto case_2;
          }
#line 142
          if ((int )cstr_info.prog == 3) {
#line 142
            goto case_3;
          }
#line 145
          if ((int )cstr_info.prog == 4) {
#line 145
            goto case_4;
          }
#line 148
          goto switch_default;
          case_0: /* CIL Label */ 
#line 134
          packet = *(tile_Idx->packet + (((layno * numOfres + resno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 135
          goto switch_break;
          case_1: /* CIL Label */ 
#line 137
          packet = *(tile_Idx->packet + (((resno * numOflayers + layno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 138
          goto switch_break;
          case_2: /* CIL Label */ 
#line 140
          packet = *(tile_Idx->packet + (((resno * numOfprec + precno) * cstr_info.numcomps + compno) * numOflayers + layno));
#line 141
          goto switch_break;
          case_3: /* CIL Label */ 
#line 143
          packet = *(tile_Idx->packet + (((precno * cstr_info.numcomps + compno) * numOfres + resno) * numOflayers + layno));
#line 144
          goto switch_break;
          case_4: /* CIL Label */ 
#line 146
          packet = *(tile_Idx->packet + (((compno * numOfprec + precno) * numOfres + resno) * numOflayers + layno));
#line 147
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 149
          fprintf(stderr, "failed to ppix indexing\n\220");
          }
          switch_break: /* CIL Label */ ;
          }
          {
#line 152
          cio_write(cio, (unsigned long long )(packet.start_pos - coff), size_of_coding);
#line 153
          cio_write(cio, (unsigned long long )((packet.end_pos - packet.start_pos) + 1),
                    size_of_coding);
#line 155
          num_packet ++;
          }
#line 130
          layno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 128
        precno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 126
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 160
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 160
      if (! (num_packet < nmax)) {
#line 160
        goto while_break___4;
      }
      {
#line 161
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 162
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 163
      num_packet ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 120
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 167
  __cil_tmp32 = cio_tell(cio);
#line 167
  len = __cil_tmp32 - lenp;
#line 168
  cio_seek(cio, lenp);
#line 169
  cio_write(cio, (unsigned long long )len, 4);
#line 170
  cio_seek(cio, lenp + len);
  }
#line 172
  return (len);
}
}
#line 51 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/phix_manager.c"
int write_phixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) ;
#line 53 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/phix_manager.c"
int write_phix(int coff , opj_codestream_info_t cstr_info , opj_bool EPHused , int j2klen ,
               opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int compno ;
  int i ;
  opj_jp2_box_t *box ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 55
  lenp = 0;
#line 58
  __cil_tmp11 = calloc((unsigned long )cstr_info.numcomps, sizeof(opj_jp2_box_t ));
#line 58
  box = (opj_jp2_box_t *)__cil_tmp11;
#line 60
  i = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < 2)) {
#line 60
      goto while_break;
    }
#line 61
    if (i) {
      {
#line 61
      cio_seek(cio, lenp);
      }
    }
    {
#line 63
    lenp = cio_tell(cio);
#line 64
    cio_skip(cio, 4);
#line 65
    cio_write(cio, (unsigned long long )1885890936, 4);
#line 67
    write_manf(i, cstr_info.numcomps, box, cio);
#line 69
    compno = 0;
    }
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 69
      if (! (compno < cstr_info.numcomps)) {
#line 69
        goto while_break___0;
      }
      {
#line 70
      (box + compno)->length = write_phixfaix(coff, compno, cstr_info, EPHused, j2klen,
                                              cio);
#line 71
      (box + compno)->type = 1717660024;
      }
#line 69
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 74
    __cil_tmp15 = cio_tell(cio);
#line 74
    len = __cil_tmp15 - lenp;
#line 75
    cio_seek(cio, lenp);
#line 76
    cio_write(cio, (unsigned long long )len, 4);
#line 77
    cio_seek(cio, lenp + len);
    }
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  free(box);
  }
#line 82
  return (len);
}
}
#line 85 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/phix_manager.c"
int write_phixfaix(int coff , int compno , opj_codestream_info_t cstr_info , opj_bool EPHused ,
                   int j2klen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int tileno ;
  int version ;
  int i ;
  int nmax ;
  int size_of_coding ;
  opj_tile_info_t *tile_Idx ;
  opj_packet_info_t packet ;
  int resno ;
  int precno ;
  int layno ;
  int num_packet ;
  int numOfres ;
  int numOfprec ;
  int numOflayers ;
  double __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
  {
#line 92
  packet.start_pos = - 1;
#line 92
  packet.end_ph_pos = packet.start_pos;
#line 95
  __cil_tmp23 = pow((double )2, (double )32);
  }
#line 95
  if ((double )j2klen > __cil_tmp23) {
#line 96
    size_of_coding = 8;
#line 97
    version = 1;
  } else {
#line 100
    size_of_coding = 4;
#line 101
    version = 0;
  }
  {
#line 104
  lenp = cio_tell(cio);
#line 105
  cio_skip(cio, 4);
#line 106
  cio_write(cio, (unsigned long long )1717660024, 4);
#line 107
  cio_write(cio, (unsigned long long )version, 1);
#line 109
  nmax = 0;
#line 110
  i = 0;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i <= *(cstr_info.numdecompos + compno))) {
#line 110
      goto while_break;
    }
#line 111
    nmax += ((cstr_info.tile + 0)->ph[i] * (cstr_info.tile + 0)->pw[i]) * cstr_info.numlayers;
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  cio_write(cio, (unsigned long long )nmax, size_of_coding);
#line 114
  cio_write(cio, (unsigned long long )(cstr_info.tw * cstr_info.th), size_of_coding);
#line 116
  tileno = 0;
  }
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 116
    if (! (tileno < cstr_info.tw * cstr_info.th)) {
#line 116
      goto while_break___0;
    }
#line 117
    tile_Idx = cstr_info.tile + tileno;
#line 119
    num_packet = 0;
#line 120
    numOfres = *(cstr_info.numdecompos + compno) + 1;
#line 122
    resno = 0;
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 122
      if (! (resno < numOfres)) {
#line 122
        goto while_break___1;
      }
#line 123
      numOfprec = tile_Idx->pw[resno] * tile_Idx->ph[resno];
#line 124
      precno = 0;
      {
#line 124
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 124
        if (! (precno < numOfprec)) {
#line 124
          goto while_break___2;
        }
#line 125
        numOflayers = cstr_info.numlayers;
#line 126
        layno = 0;
        {
#line 126
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 126
          if (! (layno < numOflayers)) {
#line 126
            goto while_break___3;
          }
          {
#line 129
          if ((int )cstr_info.prog == 0) {
#line 129
            goto case_0;
          }
#line 132
          if ((int )cstr_info.prog == 1) {
#line 132
            goto case_1;
          }
#line 135
          if ((int )cstr_info.prog == 2) {
#line 135
            goto case_2;
          }
#line 138
          if ((int )cstr_info.prog == 3) {
#line 138
            goto case_3;
          }
#line 141
          if ((int )cstr_info.prog == 4) {
#line 141
            goto case_4;
          }
#line 144
          goto switch_default;
          case_0: /* CIL Label */ 
#line 130
          packet = *(tile_Idx->packet + (((layno * numOfres + resno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 131
          goto switch_break;
          case_1: /* CIL Label */ 
#line 133
          packet = *(tile_Idx->packet + (((resno * numOflayers + layno) * cstr_info.numcomps + compno) * numOfprec + precno));
#line 134
          goto switch_break;
          case_2: /* CIL Label */ 
#line 136
          packet = *(tile_Idx->packet + (((resno * numOfprec + precno) * cstr_info.numcomps + compno) * numOflayers + layno));
#line 137
          goto switch_break;
          case_3: /* CIL Label */ 
#line 139
          packet = *(tile_Idx->packet + (((precno * cstr_info.numcomps + compno) * numOfres + resno) * numOflayers + layno));
#line 140
          goto switch_break;
          case_4: /* CIL Label */ 
#line 142
          packet = *(tile_Idx->packet + (((compno * numOfprec + precno) * numOfres + resno) * numOflayers + layno));
#line 143
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 145
          fprintf(stderr, "failed to ppix indexing\n\220");
          }
          switch_break: /* CIL Label */ ;
          }
          {
#line 148
          cio_write(cio, (unsigned long long )(packet.start_pos - coff), size_of_coding);
#line 149
          cio_write(cio, (unsigned long long )((packet.end_ph_pos - packet.start_pos) + 1),
                    size_of_coding);
#line 151
          num_packet ++;
          }
#line 126
          layno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 124
        precno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 122
      resno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 157
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 157
      if (! (num_packet < nmax)) {
#line 157
        goto while_break___4;
      }
      {
#line 158
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 159
      cio_write(cio, (unsigned long long )0, size_of_coding);
#line 160
      num_packet ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 116
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 164
  __cil_tmp32 = cio_tell(cio);
#line 164
  len = __cil_tmp32 - lenp;
#line 165
  cio_seek(cio, lenp);
#line 166
  cio_write(cio, (unsigned long long )len, 4);
#line 167
  cio_seek(cio, lenp + len);
  }
#line 169
  return (len);
}
}
#line 42 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cidx_manager.c"
void write_cptr(int coff , int clen , opj_cio_t *cio ) ;
#line 53
int write_mainmhix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) ;
#line 65
opj_bool check_EPHuse(int coff , opj_marker_info_t *markers , int marknum , opj_cio_t *cio ) ;
#line 68 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cidx_manager.c"
int write_cidx(int offset , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t cstr_info ,
               int j2klen ) 
{ 
  int len ;
  int i ;
  int lenp ;
  opj_jp2_box_t *box ;
  int num_box ;
  opj_bool EPHused ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_bool __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
  {
#line 72
  num_box = 0;
#line 76
  lenp = - 1;
#line 77
  __cil_tmp12 = calloc((unsigned long )32, sizeof(opj_jp2_box_t ));
#line 77
  box = (opj_jp2_box_t *)__cil_tmp12;
#line 79
  i = 0;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 2)) {
#line 79
      goto while_break;
    }
#line 81
    if (i) {
      {
#line 82
      cio_seek(cio, lenp);
      }
    }
    {
#line 84
    lenp = cio_tell(cio);
#line 86
    cio_skip(cio, 4);
#line 87
    cio_write(cio, (unsigned long long )1667851384, 4);
#line 88
    write_cptr(offset, cstr_info.codestream_size, cio);
#line 90
    write_manf(i, num_box, box, cio);
#line 92
    num_box = 0;
#line 93
    (box + num_box)->length = write_mainmhix(offset, cstr_info, cio);
#line 94
    (box + num_box)->type = 1835559288;
#line 95
    num_box ++;
#line 97
    (box + num_box)->length = write_tpix(offset, cstr_info, j2klen, cio);
#line 98
    (box + num_box)->type = 1953524088;
#line 99
    num_box ++;
#line 101
    (box + num_box)->length = write_thix(offset, cstr_info, cio);
#line 102
    (box + num_box)->type = 1952999800;
#line 103
    num_box ++;
#line 105
    EPHused = check_EPHuse(offset, cstr_info.marker, cstr_info.marknum, cio);
#line 107
    (box + num_box)->length = write_ppix(offset, cstr_info, EPHused, j2klen, cio);
#line 108
    (box + num_box)->type = 1886415224;
#line 109
    num_box ++;
#line 111
    (box + num_box)->length = write_phix(offset, cstr_info, EPHused, j2klen, cio);
#line 112
    (box + num_box)->type = 1885890936;
#line 113
    num_box ++;
#line 115
    __cil_tmp25 = cio_tell(cio);
#line 115
    len = __cil_tmp25 - lenp;
#line 116
    cio_seek(cio, lenp);
#line 117
    cio_write(cio, (unsigned long long )len, 4);
#line 118
    cio_seek(cio, lenp + len);
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  free(box);
  }
#line 123
  return (len);
}
}
#line 126 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cidx_manager.c"
void write_cptr(int coff , int clen , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 130
  lenp = cio_tell(cio);
#line 131
  cio_skip(cio, 4);
#line 132
  cio_write(cio, (unsigned long long )1668314226, 4);
#line 133
  cio_write(cio, (unsigned long long )0, 2);
#line 134
  cio_write(cio, (unsigned long long )0, 2);
#line 135
  cio_write(cio, (unsigned long long )coff, 8);
#line 136
  cio_write(cio, (unsigned long long )clen, 8);
#line 137
  __cil_tmp7 = cio_tell(cio);
#line 137
  len = __cil_tmp7 - lenp;
#line 138
  cio_seek(cio, lenp);
#line 139
  cio_write(cio, (unsigned long long )len, 4);
#line 140
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 143 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cidx_manager.c"
void write_manf(int second , int v , opj_jp2_box_t *box , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 147
  lenp = cio_tell(cio);
#line 148
  cio_skip(cio, 4);
#line 149
  cio_write(cio, (unsigned long long )1835101798, 4);
  }
#line 151
  if (second) {
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue: /* CIL Label */ ;
#line 152
      if (! (i < v)) {
#line 152
        goto while_break;
      }
      {
#line 153
      cio_write(cio, (unsigned long long )(box + i)->length, 4);
#line 154
      cio_write(cio, (unsigned long long )(box + i)->type, 4);
      }
#line 152
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 158
  __cil_tmp10 = cio_tell(cio);
#line 158
  len = __cil_tmp10 - lenp;
#line 159
  cio_seek(cio, lenp);
#line 160
  cio_write(cio, (unsigned long long )len, 4);
#line 161
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 164 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cidx_manager.c"
int write_mainmhix(int coff , opj_codestream_info_t cstr_info , opj_cio_t *cio ) 
{ 
  int i ;
  int len ;
  int lenp ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 169
  lenp = cio_tell(cio);
#line 170
  cio_skip(cio, 4);
#line 171
  cio_write(cio, (unsigned long long )1835559288, 4);
#line 173
  cio_write(cio, (unsigned long long )((cstr_info.main_head_end - cstr_info.main_head_start) + 1),
            8);
#line 175
  i = 1;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < cstr_info.marknum)) {
#line 175
      goto while_break;
    }
    {
#line 176
    cio_write(cio, (unsigned long long )(cstr_info.marker + i)->type, 2);
#line 177
    cio_write(cio, (unsigned long long )0, 2);
#line 178
    cio_write(cio, (unsigned long long )((cstr_info.marker + i)->pos - coff), 8);
#line 179
    cio_write(cio, (unsigned long long )(cstr_info.marker + i)->len, 2);
    }
#line 175
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  __cil_tmp9 = cio_tell(cio);
#line 182
  len = __cil_tmp9 - lenp;
#line 183
  cio_seek(cio, lenp);
#line 184
  cio_write(cio, (unsigned long long )len, 4);
#line 185
  cio_seek(cio, lenp + len);
  }
#line 187
  return (len);
}
}
#line 190 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cidx_manager.c"
opj_bool check_EPHuse(int coff , opj_marker_info_t *markers , int marknum , opj_cio_t *cio ) 
{ 
  opj_bool EPHused ;
  int i ;
  int org_pos ;
  unsigned int Scod ;
  int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 192
  EPHused = 0;
#line 193
  i = 0;
#line 197
  i = 0;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < marknum)) {
#line 197
      goto while_break;
    }
#line 198
    if ((int )(markers + i)->type == 65362) {
      {
#line 199
      org_pos = cio_tell(cio);
#line 200
      cio_seek(cio, (coff + (markers + i)->pos) + 2);
#line 202
      Scod = cio_read(cio, 1);
      }
#line 203
      if ((Scod >> 2) & 1U) {
#line 204
        EPHused = 1;
      }
      {
#line 205
      cio_seek(cio, org_pos);
      }
#line 207
      goto while_break;
    }
#line 197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (EPHused);
}
}
#line 40 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.c"
opj_tgt_tree_t *tgt_create(int numleafsh , int numleafsv ) 
{ 
  int nplh[32] ;
  int nplv[32] ;
  opj_tgt_node_t *node ;
  opj_tgt_node_t *parentnode ;
  opj_tgt_node_t *parentnode0 ;
  opj_tgt_tree_t *tree ;
  int i ;
  int j ;
  int k ;
  int numlvls ;
  int n ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
#line 43
  node = (opj_tgt_node_t *)((void *)0);
#line 44
  parentnode = (opj_tgt_node_t *)((void *)0);
#line 45
  parentnode0 = (opj_tgt_node_t *)((void *)0);
#line 46
  tree = (opj_tgt_tree_t *)((void *)0);
#line 51
  __cil_tmp14 = malloc(sizeof(opj_tgt_tree_t ));
#line 51
  tree = (opj_tgt_tree_t *)__cil_tmp14;
  }
#line 52
  if (! tree) {
#line 52
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 53
  tree->numleafsh = numleafsh;
#line 54
  tree->numleafsv = numleafsv;
#line 56
  numlvls = 0;
#line 57
  nplh[0] = numleafsh;
#line 58
  nplv[0] = numleafsv;
#line 59
  tree->numnodes = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    n = nplh[numlvls] * nplv[numlvls];
#line 62
    nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
#line 63
    nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
#line 64
    tree->numnodes += n;
#line 65
    numlvls ++;
#line 60
    if (! (n > 1)) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (tree->numnodes == 0) {
    {
#line 70
    free(tree);
    }
#line 71
    return ((opj_tgt_tree_t *)((void *)0));
  }
  {
#line 74
  __cil_tmp15 = calloc((unsigned long )tree->numnodes, sizeof(opj_tgt_node_t ));
#line 74
  tree->nodes = (opj_tgt_node_t *)__cil_tmp15;
  }
#line 75
  if (! tree->nodes) {
    {
#line 76
    free(tree);
    }
#line 77
    return ((opj_tgt_tree_t *)((void *)0));
  }
#line 80
  node = tree->nodes;
#line 81
  parentnode = tree->nodes + tree->numleafsh * tree->numleafsv;
#line 82
  parentnode0 = parentnode;
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (i < numlvls - 1)) {
#line 84
      goto while_break___0;
    }
#line 85
    j = 0;
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 85
      if (! (j < nplv[i])) {
#line 85
        goto while_break___1;
      }
#line 86
      k = nplh[i];
      {
#line 87
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 87
        k --;
#line 87
        if (! (k >= 0)) {
#line 87
          goto while_break___2;
        }
#line 88
        node->parent = parentnode;
#line 89
        node ++;
#line 90
        k --;
#line 90
        if (k >= 0) {
#line 91
          node->parent = parentnode;
#line 92
          node ++;
        }
#line 94
        parentnode ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 96
      if (j & 1) {
#line 97
        parentnode0 = parentnode;
      } else
#line 96
      if (j == nplv[i] - 1) {
#line 97
        parentnode0 = parentnode;
      } else {
#line 99
        parentnode = parentnode0;
#line 100
        parentnode0 += nplh[i];
      }
#line 85
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 84
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 104
  node->parent = (struct opj_tgt_node *)0;
#line 106
  tgt_reset(tree);
  }
#line 108
  return (tree);
}
}
#line 111 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.c"
void tgt_destroy(opj_tgt_tree_t *tree ) 
{ 


  {
  {
#line 112
  free(tree->nodes);
#line 113
  free(tree);
  }
  return;
}
}
#line 116 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.c"
void tgt_reset(opj_tgt_tree_t *tree ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 119
  if ((void *)0 == tree) {
#line 120
    return;
  }
#line 122
  i = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < tree->numnodes)) {
#line 122
      goto while_break;
    }
#line 123
    (tree->nodes + i)->value = 999;
#line 124
    (tree->nodes + i)->low = 0;
#line 125
    (tree->nodes + i)->known = 0;
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 129 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.c"
void tgt_setvalue(opj_tgt_tree_t *tree , int leafno , int value ) 
{ 
  opj_tgt_node_t *node ;

  {
#line 131
  node = tree->nodes + leafno;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (node && node->value > value)) {
#line 132
      goto while_break;
    }
#line 133
    node->value = value;
#line 134
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 138 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.c"
void tgt_encode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;

  {
#line 144
  stkptr = (opj_tgt_node_t **)stk;
#line 145
  node = tree->nodes + leafno;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! node->parent) {
#line 146
      goto while_break;
    }
#line 147
    __cil_tmp9 = stkptr;
#line 147
    stkptr ++;
#line 147
    *__cil_tmp9 = node;
#line 148
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  low = 0;
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (! 1) {
#line 152
      goto while_break___0;
    }
#line 153
    if (low > node->low) {
#line 154
      node->low = low;
    } else {
#line 156
      low = node->low;
    }
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (low < threshold)) {
#line 159
        goto while_break___1;
      }
#line 160
      if (low >= node->value) {
#line 161
        if (! node->known) {
          {
#line 162
          bio_write(bio, 1, 1);
#line 163
          node->known = 1;
          }
        }
#line 165
        goto while_break___1;
      }
      {
#line 167
      bio_write(bio, 0, 1);
#line 168
      low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 171
    node->low = low;
#line 172
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 173
      goto while_break___0;
    }
#line 174
    stkptr --;
#line 174
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 178 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tgt.c"
int tgt_decode(opj_bio_t *bio , opj_tgt_tree_t *tree , int leafno , int threshold ) 
{ 
  opj_tgt_node_t *stk[31] ;
  opj_tgt_node_t **stkptr ;
  opj_tgt_node_t *node ;
  int low ;
  opj_tgt_node_t **__cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp ;

  {
#line 184
  stkptr = (opj_tgt_node_t **)stk;
#line 185
  node = tree->nodes + leafno;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! node->parent) {
#line 186
      goto while_break;
    }
#line 187
    __cil_tmp9 = stkptr;
#line 187
    stkptr ++;
#line 187
    *__cil_tmp9 = node;
#line 188
    node = node->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  low = 0;
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    if (! 1) {
#line 192
      goto while_break___0;
    }
#line 193
    if (low > node->low) {
#line 194
      node->low = low;
    } else {
#line 196
      low = node->low;
    }
    {
#line 198
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (low < threshold && low < node->value)) {
#line 198
        goto while_break___1;
      }
      {
#line 199
      __cil_tmp10 = bio_read(bio, 1);
      }
#line 199
      if (__cil_tmp10) {
#line 200
        node->value = low;
      } else {
#line 202
        low ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 205
    node->low = low;
#line 206
    if (stkptr == (opj_tgt_node_t **)stk) {
#line 207
      goto while_break___0;
    }
#line 209
    stkptr --;
#line 209
    node = *stkptr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 212
  if (node->value < threshold) {
#line 212
    tmp = 1;
  } else {
#line 212
    tmp = 0;
  }
#line 212
  return (tmp);
}
}
#line 36 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_dump(FILE *fd , opj_tcd_t *tcd , opj_tcd_image_t *img ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 39
  fprintf(fd, "image {\n\220");
#line 40
  fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", img->tw, img->th, (tcd->image)->x0,
          (tcd->image)->x1, (tcd->image)->y0, (tcd->image)->y1);
#line 43
  tileno = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (tileno < img->th * img->tw)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tile = (tcd->tcd_image)->tiles + tileno;
#line 45
    fprintf(fd, "  tile {\n");
#line 46
    fprintf(fd, "    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\n", tile->x0, tile->y0,
            tile->x1, tile->y1, tile->numcomps);
#line 48
    compno = 0;
    }
    {
#line 48
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 48
      if (! (compno < tile->numcomps)) {
#line 48
        goto while_break___0;
      }
      {
#line 49
      tilec = tile->comps + compno;
#line 50
      fprintf(fd, "    tilec {\n");
#line 51
      fprintf(fd, "      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\n", tilec->x0,
              tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);
#line 54
      resno = 0;
      }
      {
#line 54
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 54
        if (! (resno < tilec->numresolutions)) {
#line 54
          goto while_break___1;
        }
        {
#line 55
        res = tilec->resolutions + resno;
#line 56
        fprintf(fd, "\n   res {\n");
#line 57
        fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\n\230\001",
                res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);
#line 60
        bandno = 0;
        }
        {
#line 60
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 60
          if (! (bandno < res->numbands)) {
#line 60
            goto while_break___2;
          }
          {
#line 61
          band = & res->bands[bandno];
#line 62
          fprintf(fd, "        band {\n");
#line 63
          fprintf(fd, "          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\n",
                  band->x0, band->y0, band->x1, band->y1, (double )band->stepsize,
                  band->numbps);
#line 66
          precno = 0;
          }
          {
#line 66
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 66
            if (! (precno < res->pw * res->ph)) {
#line 66
              goto while_break___3;
            }
            {
#line 67
            prec = band->precincts + precno;
#line 68
            fprintf(fd, "          prec {\n");
#line 69
            fprintf(fd, "            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
                    prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
#line 82
            fprintf(fd, "          }\n");
            }
#line 66
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 84
          fprintf(fd, "        }\n");
          }
#line 60
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 86
        fprintf(fd, "      }\n\220");
        }
#line 54
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 88
      fprintf(fd, "    }\n");
      }
#line 48
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 90
    fprintf(fd, "  }\n");
    }
#line 43
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  fprintf(fd, "}\n");
  }
  return;
}
}
#line 100 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
opj_tcd_t *tcd_create(opj_common_ptr cinfo ) 
{ 
  opj_tcd_t *tcd ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 102
  __cil_tmp3 = malloc(sizeof(opj_tcd_t ));
#line 102
  tcd = (opj_tcd_t *)__cil_tmp3;
  }
#line 103
  if (! tcd) {
#line 103
    return ((opj_tcd_t *)((void *)0));
  }
  {
#line 104
  tcd->cinfo = cinfo;
#line 105
  __cil_tmp4 = malloc(sizeof(opj_tcd_image_t ));
#line 105
  tcd->tcd_image = (opj_tcd_image_t *)__cil_tmp4;
  }
#line 106
  if (! tcd->tcd_image) {
    {
#line 107
    free(tcd);
    }
#line 108
    return ((opj_tcd_t *)((void *)0));
  }
#line 111
  return (tcd);
}
}
#line 117 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_destroy(opj_tcd_t *tcd ) 
{ 


  {
#line 118
  if (tcd) {
    {
#line 119
    free(tcd->tcd_image);
#line 120
    free(tcd);
    }
  }
  return;
}
}
#line 126 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_malloc_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  void *__cil_tmp11 ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp23 ;
  void *__cil_tmp24 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int tmp___1 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int x0b ;
  int y0b ;
  int i ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int tmp___5 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int tmp___6 ;
  double __cil_tmp86 ;
  void *__cil_tmp87 ;
  int __cil_tmp88 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  void *__cil_tmp106 ;
  opj_tgt_tree_t *__cil_tmp107 ;
  opj_tgt_tree_t *__cil_tmp108 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  void *__cil_tmp118 ;
  void *__cil_tmp119 ;
  void *__cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int __cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;

  {
  {
#line 129
  tcd->image = image;
#line 130
  tcd->cp = cp;
#line 131
  (tcd->tcd_image)->tw = cp->tw;
#line 132
  (tcd->tcd_image)->th = cp->th;
#line 133
  __cil_tmp11 = malloc(sizeof(opj_tcd_tile_t ));
#line 133
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp11;
#line 135
  tileno = 0;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (tileno < 1)) {
#line 135
      goto while_break;
    }
    {
#line 136
    tcp = cp->tcps + curtileno;
#line 140
    p = curtileno % cp->tw;
#line 141
    q = curtileno / cp->tw;
#line 144
    tile = (tcd->tcd_image)->tiles;
#line 147
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 148
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 149
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 150
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 151
    tile->numcomps = image->numcomps;
#line 155
    j = 0;
    }
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 155
      if (! (j < tcp->numlayers)) {
#line 155
        goto while_break___0;
      }
#line 156
      if (tcp->rates[j]) {
#line 156
        if ((int )cp->tp_on) {
#line 156
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 156
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 156
        tmp___0 = tmp;
      } else {
#line 156
        tmp___0 = (float )0;
      }
#line 156
      tcp->rates[j] = tmp___0;
#line 171
      if (tcp->rates[j]) {
#line 172
        if (j) {
#line 172
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 173
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 172
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 175
        if (! j) {
#line 175
          if (tcp->rates[j] < (float )30) {
#line 176
            tcp->rates[j] = (float )30;
          }
        }
#line 179
        if (j == tcp->numlayers - 1) {
#line 180
          tcp->rates[j] -= (float )2;
        }
      }
#line 155
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 186
    __cil_tmp24 = malloc((unsigned long )image->numcomps * sizeof(opj_tcd_tilecomp_t ));
#line 186
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp24;
#line 187
    compno = 0;
    }
    {
#line 187
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 187
      if (! (compno < tile->numcomps)) {
#line 187
        goto while_break___1;
      }
      {
#line 188
      tccp = tcp->tccps + compno;
#line 190
      tilec = tile->comps + compno;
#line 193
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 194
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 195
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 196
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 198
      __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 198
      tilec->data = (int *)__cil_tmp31;
#line 199
      tilec->numresolutions = tccp->numresolutions;
#line 201
      __cil_tmp32 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 201
      tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp32;
#line 203
      resno = 0;
      }
      {
#line 203
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 203
        if (! (resno < tilec->numresolutions)) {
#line 203
          goto while_break___2;
        }
        {
#line 205
        levelno = (tilec->numresolutions - 1) - resno;
#line 211
        res = tilec->resolutions + resno;
#line 214
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 215
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 216
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 217
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 219
        if (resno == 0) {
#line 219
          tmp___1 = 1;
        } else {
#line 219
          tmp___1 = 3;
        }
#line 219
        res->numbands = tmp___1;
#line 221
        if (tccp->csty & 1) {
#line 222
          pdx = tccp->prcw[resno];
#line 223
          pdy = tccp->prch[resno];
        } else {
#line 225
          pdx = 15;
#line 226
          pdy = 15;
        }
        {
#line 229
        __cil_tmp54 = int_floordivpow2(res->x0, pdx);
#line 229
        tlprcxstart = __cil_tmp54 << pdx;
#line 230
        __cil_tmp55 = int_floordivpow2(res->y0, pdy);
#line 230
        tlprcystart = __cil_tmp55 << pdy;
#line 232
        __cil_tmp56 = int_ceildivpow2(res->x1, pdx);
#line 232
        brprcxend = __cil_tmp56 << pdx;
#line 233
        __cil_tmp57 = int_ceildivpow2(res->y1, pdy);
#line 233
        brprcyend = __cil_tmp57 << pdy;
#line 235
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 236
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 238
        if (resno == 0) {
#line 239
          tlcbgxstart = tlprcxstart;
#line 240
          tlcbgystart = tlprcystart;
#line 241
          brcbgxend = brprcxend;
#line 242
          brcbgyend = brprcyend;
#line 243
          cbgwidthexpn = pdx;
#line 244
          cbgheightexpn = pdy;
        } else {
          {
#line 246
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 247
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 248
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 249
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 250
          cbgwidthexpn = pdx - 1;
#line 251
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 254
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 255
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 257
        bandno = 0;
        }
        {
#line 257
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 257
          if (! (bandno < res->numbands)) {
#line 257
            goto while_break___3;
          }
#line 260
          ss = (opj_stepsize_t *)((void *)0);
#line 262
          band = & res->bands[bandno];
#line 264
          if (resno == 0) {
#line 264
            tmp___2 = 0;
          } else {
#line 264
            tmp___2 = bandno + 1;
          }
#line 264
          band->bandno = tmp___2;
#line 265
          if (band->bandno == 1 || band->bandno == 3) {
#line 265
            tmp___3 = 1;
          } else {
#line 265
            tmp___3 = 0;
          }
#line 265
          x0b = tmp___3;
#line 266
          if (band->bandno == 2 || band->bandno == 3) {
#line 266
            tmp___4 = 1;
          } else {
#line 266
            tmp___4 = 0;
          }
#line 266
          y0b = tmp___4;
#line 268
          if (band->bandno == 0) {
            {
#line 270
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 271
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 272
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 273
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 276
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 277
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 278
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 279
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 282
          if (resno == 0) {
#line 282
            tmp___5 = 0;
          } else {
#line 282
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 282
          ss = & tccp->stepsizes[tmp___5];
#line 283
          if (tccp->qmfbid == 0) {
            {
#line 283
            __cil_tmp83 = dwt_getgain_real(band->bandno);
#line 283
            tmp___6 = __cil_tmp83;
            }
          } else {
            {
#line 283
            __cil_tmp84 = dwt_getgain(band->bandno);
#line 283
            tmp___6 = __cil_tmp84;
            }
          }
          {
#line 283
          gain = tmp___6;
#line 284
          numbps = (image->comps + compno)->prec + gain;
#line 286
          __cil_tmp86 = pow(2., (double )(numbps - ss->expn));
#line 286
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp86);
#line 287
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 289
          __cil_tmp87 = malloc((unsigned long )((3 * res->pw) * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 289
          band->precincts = (opj_tcd_precinct_t *)__cil_tmp87;
#line 291
          i = 0;
          }
          {
#line 291
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 291
            if (! (i < (res->pw * res->ph) * 3)) {
#line 291
              goto while_break___4;
            }
#line 292
            (band->precincts + i)->imsbtree = (opj_tgt_tree_t *)((void *)0);
#line 293
            (band->precincts + i)->incltree = (opj_tgt_tree_t *)((void *)0);
#line 294
            (band->precincts + i)->cblks.enc = (opj_tcd_cblk_enc_t *)((void *)0);
#line 291
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 297
          precno = 0;
          {
#line 297
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 297
            if (! (precno < res->pw * res->ph)) {
#line 297
              goto while_break___5;
            }
            {
#line 300
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 301
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 302
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 303
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 305
            prc = band->precincts + precno;
#line 308
            prc->x0 = int_max(cbgxstart, band->x0);
#line 309
            prc->y0 = int_max(cbgystart, band->y0);
#line 310
            prc->x1 = int_min(cbgxend, band->x1);
#line 311
            prc->y1 = int_min(cbgyend, band->y1);
#line 313
            __cil_tmp102 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 313
            tlcblkxstart = __cil_tmp102 << cblkwidthexpn;
#line 314
            __cil_tmp103 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 314
            tlcblkystart = __cil_tmp103 << cblkheightexpn;
#line 315
            __cil_tmp104 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 315
            brcblkxend = __cil_tmp104 << cblkwidthexpn;
#line 316
            __cil_tmp105 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 316
            brcblkyend = __cil_tmp105 << cblkheightexpn;
#line 317
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 318
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 320
            __cil_tmp106 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 320
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp106;
#line 321
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 322
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 324
            cblkno = 0;
            }
            {
#line 324
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 324
              if (! (cblkno < prc->cw * prc->ch)) {
#line 324
                goto while_break___6;
              }
              {
#line 325
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 326
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 327
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 328
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 330
              cblk = prc->cblks.enc + cblkno;
#line 333
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 334
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 335
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 336
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 337
              __cil_tmp118 = calloc((unsigned long )9730, sizeof(unsigned char ));
#line 337
              cblk->data = (unsigned char *)__cil_tmp118;
#line 339
              *(cblk->data + 0) = (unsigned char )0;
#line 340
              *(cblk->data + 1) = (unsigned char )0;
#line 341
              cblk->data += 2;
#line 342
              __cil_tmp119 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 342
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp119;
#line 343
              __cil_tmp120 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 343
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp120;
              }
#line 324
              cblkno ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 297
            precno ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 257
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 203
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 187
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 135
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 354 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_free_encode(opj_tcd_t *tcd ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 357
  tileno = 0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (tileno < 1)) {
#line 357
      goto while_break;
    }
#line 358
    tile = (tcd->tcd_image)->tiles;
#line 360
    compno = 0;
    {
#line 360
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 360
      if (! (compno < tile->numcomps)) {
#line 360
        goto while_break___0;
      }
#line 361
      tilec = tile->comps + compno;
#line 363
      resno = 0;
      {
#line 363
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 363
        if (! (resno < tilec->numresolutions)) {
#line 363
          goto while_break___1;
        }
#line 364
        res = tilec->resolutions + resno;
#line 366
        bandno = 0;
        {
#line 366
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 366
          if (! (bandno < res->numbands)) {
#line 366
            goto while_break___2;
          }
#line 367
          band = & res->bands[bandno];
#line 369
          precno = 0;
          {
#line 369
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 369
            if (! (precno < res->pw * res->ph)) {
#line 369
              goto while_break___3;
            }
#line 370
            prc = band->precincts + precno;
#line 372
            if (prc->incltree != (void *)0) {
              {
#line 373
              tgt_destroy(prc->incltree);
#line 374
              prc->incltree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 376
            if (prc->imsbtree != (void *)0) {
              {
#line 377
              tgt_destroy(prc->imsbtree);
#line 378
              prc->imsbtree = (opj_tgt_tree_t *)((void *)0);
              }
            }
#line 380
            cblkno = 0;
            {
#line 380
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 380
              if (! (cblkno < prc->cw * prc->ch)) {
#line 380
                goto while_break___4;
              }
              {
#line 381
              free((prc->cblks.enc + cblkno)->data - 2);
#line 382
              free((prc->cblks.enc + cblkno)->layers);
#line 383
              free((prc->cblks.enc + cblkno)->passes);
              }
#line 380
              cblkno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 385
            free(prc->cblks.enc);
            }
#line 369
            precno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 387
          free(band->precincts);
#line 388
          band->precincts = (opj_tcd_precinct_t *)((void *)0);
          }
#line 366
          bandno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 363
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 391
      free(tilec->resolutions);
#line 392
      tilec->resolutions = (opj_tcd_resolution_t *)((void *)0);
      }
#line 360
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 394
    free(tile->comps);
#line 395
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
#line 357
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 397
  free((tcd->tcd_image)->tiles);
#line 398
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)((void *)0);
  }
  return;
}
}
#line 401 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_init_encode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int curtileno ) 
{ 
  int tileno ;
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  int j ;
  int p ;
  int q ;
  opj_tcd_tile_t *tile ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  float tmp ;
  float tmp___0 ;
  int __cil_tmp22 ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int tmp___1 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int tmp___5 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int tmp___6 ;
  double __cil_tmp82 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  void *__cil_tmp100 ;
  opj_tgt_tree_t *__cil_tmp101 ;
  opj_tgt_tree_t *__cil_tmp102 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  void *__cil_tmp112 ;
  void *__cil_tmp113 ;
  void *__cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;
  int __cil_tmp118 ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;

  {
#line 404
  tileno = 0;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! (tileno < 1)) {
#line 404
      goto while_break;
    }
    {
#line 405
    tcp = cp->tcps + curtileno;
#line 408
    p = curtileno % cp->tw;
#line 409
    q = curtileno / cp->tw;
#line 411
    tile = (tcd->tcd_image)->tiles;
#line 414
    tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 415
    tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 416
    tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 417
    tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 419
    tile->numcomps = image->numcomps;
#line 423
    j = 0;
    }
    {
#line 423
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 423
      if (! (j < tcp->numlayers)) {
#line 423
        goto while_break___0;
      }
#line 424
      if (tcp->rates[j]) {
#line 424
        if ((int )cp->tp_on) {
#line 424
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy) - (float )(((tcd->cur_totnum_tp - 1) * 14) / tcp->numlayers);
        } else {
#line 424
          tmp = (float )(((tile->numcomps * (tile->x1 - tile->x0)) * (tile->y1 - tile->y0)) * (image->comps + 0)->prec) / (((tcp->rates[j] * (float )8) * (float )(image->comps + 0)->dx) * (float )(image->comps + 0)->dy);
        }
#line 424
        tmp___0 = tmp;
      } else {
#line 424
        tmp___0 = (float )0;
      }
#line 424
      tcp->rates[j] = tmp___0;
#line 439
      if (tcp->rates[j]) {
#line 440
        if (j) {
#line 440
          if (tcp->rates[j] < tcp->rates[j - 1] + (float )10) {
#line 441
            tcp->rates[j] = tcp->rates[j - 1] + (float )20;
          } else {
#line 440
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 443
        if (! j) {
#line 443
          if (tcp->rates[j] < (float )30) {
#line 444
            tcp->rates[j] = (float )30;
          }
        }
      }
#line 423
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 451
    compno = 0;
    {
#line 451
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 451
      if (! (compno < tile->numcomps)) {
#line 451
        goto while_break___1;
      }
      {
#line 452
      tccp = tcp->tccps + compno;
#line 454
      tilec = tile->comps + compno;
#line 457
      tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 458
      tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 459
      tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 460
      tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 462
      __cil_tmp29 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)) * sizeof(int ));
#line 462
      tilec->data = (int *)__cil_tmp29;
#line 463
      tilec->numresolutions = tccp->numresolutions;
#line 465
      resno = 0;
      }
      {
#line 465
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 465
        if (! (resno < tilec->numresolutions)) {
#line 465
          goto while_break___2;
        }
        {
#line 468
        levelno = (tilec->numresolutions - 1) - resno;
#line 474
        res = tilec->resolutions + resno;
#line 477
        res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 478
        res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 479
        res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 480
        res->y1 = int_ceildivpow2(tilec->y1, levelno);
        }
#line 481
        if (resno == 0) {
#line 481
          tmp___1 = 1;
        } else {
#line 481
          tmp___1 = 3;
        }
#line 481
        res->numbands = tmp___1;
#line 484
        if (tccp->csty & 1) {
#line 485
          pdx = tccp->prcw[resno];
#line 486
          pdy = tccp->prch[resno];
        } else {
#line 488
          pdx = 15;
#line 489
          pdy = 15;
        }
        {
#line 492
        __cil_tmp51 = int_floordivpow2(res->x0, pdx);
#line 492
        tlprcxstart = __cil_tmp51 << pdx;
#line 493
        __cil_tmp52 = int_floordivpow2(res->y0, pdy);
#line 493
        tlprcystart = __cil_tmp52 << pdy;
#line 494
        __cil_tmp53 = int_ceildivpow2(res->x1, pdx);
#line 494
        brprcxend = __cil_tmp53 << pdx;
#line 495
        __cil_tmp54 = int_ceildivpow2(res->y1, pdy);
#line 495
        brprcyend = __cil_tmp54 << pdy;
#line 497
        res->pw = (brprcxend - tlprcxstart) >> pdx;
#line 498
        res->ph = (brprcyend - tlprcystart) >> pdy;
        }
#line 500
        if (resno == 0) {
#line 501
          tlcbgxstart = tlprcxstart;
#line 502
          tlcbgystart = tlprcystart;
#line 503
          brcbgxend = brprcxend;
#line 504
          brcbgyend = brprcyend;
#line 505
          cbgwidthexpn = pdx;
#line 506
          cbgheightexpn = pdy;
        } else {
          {
#line 508
          tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 509
          tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 510
          brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 511
          brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 512
          cbgwidthexpn = pdx - 1;
#line 513
          cbgheightexpn = pdy - 1;
          }
        }
        {
#line 516
        cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 517
        cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 519
        bandno = 0;
        }
        {
#line 519
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 519
          if (! (bandno < res->numbands)) {
#line 519
            goto while_break___3;
          }
#line 522
          ss = (opj_stepsize_t *)((void *)0);
#line 524
          band = & res->bands[bandno];
#line 526
          if (resno == 0) {
#line 526
            tmp___2 = 0;
          } else {
#line 526
            tmp___2 = bandno + 1;
          }
#line 526
          band->bandno = tmp___2;
#line 527
          if (band->bandno == 1 || band->bandno == 3) {
#line 527
            tmp___3 = 1;
          } else {
#line 527
            tmp___3 = 0;
          }
#line 527
          x0b = tmp___3;
#line 528
          if (band->bandno == 2 || band->bandno == 3) {
#line 528
            tmp___4 = 1;
          } else {
#line 528
            tmp___4 = 0;
          }
#line 528
          y0b = tmp___4;
#line 530
          if (band->bandno == 0) {
            {
#line 532
            band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 533
            band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 534
            band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 535
            band->y1 = int_ceildivpow2(tilec->y1, levelno);
            }
          } else {
            {
#line 537
            band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 538
            band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 539
            band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 540
            band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
            }
          }
#line 543
          if (resno == 0) {
#line 543
            tmp___5 = 0;
          } else {
#line 543
            tmp___5 = (3 * (resno - 1) + bandno) + 1;
          }
#line 543
          ss = & tccp->stepsizes[tmp___5];
#line 544
          if (tccp->qmfbid == 0) {
            {
#line 544
            __cil_tmp79 = dwt_getgain_real(band->bandno);
#line 544
            tmp___6 = __cil_tmp79;
            }
          } else {
            {
#line 544
            __cil_tmp80 = dwt_getgain(band->bandno);
#line 544
            tmp___6 = __cil_tmp80;
            }
          }
          {
#line 544
          gain = tmp___6;
#line 545
          numbps = (image->comps + compno)->prec + gain;
#line 546
          __cil_tmp82 = pow(2., (double )(numbps - ss->expn));
#line 546
          band->stepsize = (float )((1. + (double )ss->mant / 2048.) * __cil_tmp82);
#line 547
          band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 549
          precno = 0;
          }
          {
#line 549
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 549
            if (! (precno < res->pw * res->ph)) {
#line 549
              goto while_break___4;
            }
            {
#line 552
            cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 553
            cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 554
            cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 555
            cbgyend = cbgystart + (1 << cbgheightexpn);
#line 557
            prc = band->precincts + precno;
#line 560
            prc->x0 = int_max(cbgxstart, band->x0);
#line 561
            prc->y0 = int_max(cbgystart, band->y0);
#line 562
            prc->x1 = int_min(cbgxend, band->x1);
#line 563
            prc->y1 = int_min(cbgyend, band->y1);
#line 565
            __cil_tmp96 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 565
            tlcblkxstart = __cil_tmp96 << cblkwidthexpn;
#line 566
            __cil_tmp97 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 566
            tlcblkystart = __cil_tmp97 << cblkheightexpn;
#line 567
            __cil_tmp98 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 567
            brcblkxend = __cil_tmp98 << cblkwidthexpn;
#line 568
            __cil_tmp99 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 568
            brcblkyend = __cil_tmp99 << cblkheightexpn;
#line 569
            prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 570
            prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 572
            free(prc->cblks.enc);
#line 573
            __cil_tmp100 = calloc((unsigned long )(prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t ));
#line 573
            prc->cblks.enc = (opj_tcd_cblk_enc_t *)__cil_tmp100;
            }
#line 575
            if (prc->incltree != (void *)0) {
              {
#line 576
              tgt_destroy(prc->incltree);
              }
            }
#line 578
            if (prc->imsbtree != (void *)0) {
              {
#line 579
              tgt_destroy(prc->imsbtree);
              }
            }
            {
#line 582
            prc->incltree = tgt_create(prc->cw, prc->ch);
#line 583
            prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 585
            cblkno = 0;
            }
            {
#line 585
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 585
              if (! (cblkno < prc->cw * prc->ch)) {
#line 585
                goto while_break___5;
              }
              {
#line 586
              cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 587
              cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 588
              cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 589
              cblkyend = cblkystart + (1 << cblkheightexpn);
#line 591
              cblk = prc->cblks.enc + cblkno;
#line 594
              cblk->x0 = int_max(cblkxstart, prc->x0);
#line 595
              cblk->y0 = int_max(cblkystart, prc->y0);
#line 596
              cblk->x1 = int_min(cblkxend, prc->x1);
#line 597
              cblk->y1 = int_min(cblkyend, prc->y1);
#line 598
              __cil_tmp112 = calloc((unsigned long )8194, sizeof(unsigned char ));
#line 598
              cblk->data = (unsigned char *)__cil_tmp112;
#line 600
              *(cblk->data + 0) = (unsigned char )0;
#line 601
              *(cblk->data + 1) = (unsigned char )0;
#line 602
              cblk->data += 2;
#line 603
              __cil_tmp113 = calloc((unsigned long )100, sizeof(opj_tcd_layer_t ));
#line 603
              cblk->layers = (opj_tcd_layer_t *)__cil_tmp113;
#line 604
              __cil_tmp114 = calloc((unsigned long )100, sizeof(opj_tcd_pass_t ));
#line 604
              cblk->passes = (opj_tcd_pass_t *)__cil_tmp114;
              }
#line 585
              cblkno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 549
            precno ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 519
          bandno ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 465
        resno ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 451
      compno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 404
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 615 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_malloc_decode(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int p ;
  int q ;
  unsigned int x0 ;
  unsigned int y0___0 ;
  unsigned int x1 ;
  unsigned int y1___0 ;
  unsigned int w ;
  unsigned int h ;
  void *__cil_tmp15 ;
  opj_tcd_tile_t *tile ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  opj_tcd_tile_t *tile___0 ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int tmp ;
  int __cil_tmp31 ;
  int tmp___0 ;
  int __cil_tmp33 ;
  int tmp___1 ;
  int __cil_tmp35 ;
  int tmp___2 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;

  {
#line 617
  x0 = (unsigned int )0;
#line 617
  y0___0 = (unsigned int )0;
#line 617
  x1 = (unsigned int )0;
  {
#line 617
  y1___0 = (unsigned int )0;
#line 619
  tcd->image = image;
#line 620
  (tcd->tcd_image)->tw = cp->tw;
#line 621
  (tcd->tcd_image)->th = cp->th;
#line 622
  __cil_tmp15 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcd_tile_t ));
#line 622
  (tcd->tcd_image)->tiles = (opj_tcd_tile_t *)__cil_tmp15;
#line 629
  j = 0;
  }
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 629
    if (! (j < cp->tileno_size)) {
#line 629
      goto while_break;
    }
    {
#line 632
    tileno = *(cp->tileno + j);
#line 633
    tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 634
    tile->numcomps = image->numcomps;
#line 635
    __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_tcd_tilecomp_t ));
#line 635
    tile->comps = (opj_tcd_tilecomp_t *)__cil_tmp17;
    }
#line 629
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 638
  i = 0;
  {
#line 638
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 638
    if (! (i < image->numcomps)) {
#line 638
      goto while_break___0;
    }
#line 639
    j = 0;
    {
#line 639
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 639
      if (! (j < cp->tileno_size)) {
#line 639
        goto while_break___1;
      }
      {
#line 645
      tileno = *(cp->tileno + j);
#line 647
      tile___0 = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 648
      tilec = tile___0->comps + i;
#line 650
      p = tileno % cp->tw;
#line 651
      q = tileno / cp->tw;
#line 654
      tile___0->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 655
      tile___0->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 656
      tile___0->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 657
      tile___0->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 659
      tilec->x0 = int_ceildiv(tile___0->x0, (image->comps + i)->dx);
#line 660
      tilec->y0 = int_ceildiv(tile___0->y0, (image->comps + i)->dy);
#line 661
      tilec->x1 = int_ceildiv(tile___0->x1, (image->comps + i)->dx);
#line 662
      tilec->y1 = int_ceildiv(tile___0->y1, (image->comps + i)->dy);
      }
#line 664
      if (j == 0) {
#line 664
        tmp = tilec->x0;
      } else {
        {
#line 664
        __cil_tmp29 = int_min((int )x0, (int )((unsigned int )tilec->x0));
#line 664
        tmp = __cil_tmp29;
        }
      }
#line 664
      x0 = (unsigned int )tmp;
#line 665
      if (j == 0) {
#line 665
        tmp___0 = tilec->y0;
      } else {
        {
#line 665
        __cil_tmp31 = int_min((int )y0___0, (int )((unsigned int )tilec->y0));
#line 665
        tmp___0 = __cil_tmp31;
        }
      }
#line 665
      y0___0 = (unsigned int )tmp___0;
#line 666
      if (j == 0) {
#line 666
        tmp___1 = tilec->x1;
      } else {
        {
#line 666
        __cil_tmp33 = int_max((int )x1, (int )((unsigned int )tilec->x1));
#line 666
        tmp___1 = __cil_tmp33;
        }
      }
#line 666
      x1 = (unsigned int )tmp___1;
#line 667
      if (j == 0) {
#line 667
        tmp___2 = tilec->y1;
      } else {
        {
#line 667
        __cil_tmp35 = int_max((int )y1___0, (int )((unsigned int )tilec->y1));
#line 667
        tmp___2 = __cil_tmp35;
        }
      }
#line 667
      y1___0 = (unsigned int )tmp___2;
#line 639
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 670
    __cil_tmp38 = int_ceildivpow2((int )(x1 - x0), (image->comps + i)->factor);
#line 670
    w = (unsigned int )__cil_tmp38;
#line 671
    __cil_tmp39 = int_ceildivpow2((int )(y1___0 - y0___0), (image->comps + i)->factor);
#line 671
    h = (unsigned int )__cil_tmp39;
#line 673
    (image->comps + i)->w = (int )w;
#line 674
    (image->comps + i)->h = (int )h;
#line 675
    (image->comps + i)->x0 = (int )x0;
#line 676
    (image->comps + i)->y0 = (int )y0___0;
    }
#line 638
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 680 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_malloc_decode_tile(opj_tcd_t *tcd , opj_image_t *image , opj_cp_t *cp , int tileno ,
                            opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcp_t *tcp ;
  opj_tcd_tile_t *tile ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int pdx ;
  int pdy ;
  int levelno ;
  int tlprcxstart ;
  int tlprcystart ;
  int brprcxend ;
  int brprcyend ;
  int tlcbgxstart ;
  int tlcbgystart ;
  int brcbgxend ;
  int brcbgyend ;
  int cbgwidthexpn ;
  int cbgheightexpn ;
  int cblkwidthexpn ;
  int cblkheightexpn ;
  opj_tcd_resolution_t *res ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int tmp ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int x0b ;
  int y0b ;
  int gain ;
  int numbps ;
  opj_stepsize_t *ss ;
  opj_tcd_band_t *band ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int tmp___5 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int tmp___6 ;
  double __cil_tmp74 ;
  void *__cil_tmp75 ;
  int tlcblkxstart ;
  int tlcblkystart ;
  int brcblkxend ;
  int brcblkyend ;
  int cbgxstart ;
  int cbgystart ;
  int cbgxend ;
  int cbgyend ;
  opj_tcd_precinct_t *prc ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  void *__cil_tmp93 ;
  opj_tgt_tree_t *__cil_tmp94 ;
  opj_tgt_tree_t *__cil_tmp95 ;
  int cblkxstart ;
  int cblkystart ;
  int cblkxend ;
  int cblkyend ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;

  {
#line 687
  tcd->cp = cp;
#line 689
  tcp = cp->tcps + *(cp->tileno + tileno);
#line 690
  tile = (tcd->tcd_image)->tiles + *(cp->tileno + tileno);
#line 692
  tileno = *(cp->tileno + tileno);
#line 694
  compno = 0;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    if (! (compno < tile->numcomps)) {
#line 694
      goto while_break;
    }
#line 695
    tccp = tcp->tccps + compno;
#line 696
    tilec = tile->comps + compno;
#line 698
    if (tccp->numresolutions <= 0) {
#line 700
      *(cp->tileno + tileno) = - 1;
#line 701
      return;
    }
    {
#line 705
    tilec->x0 = int_ceildiv(tile->x0, (image->comps + compno)->dx);
#line 706
    tilec->y0 = int_ceildiv(tile->y0, (image->comps + compno)->dy);
#line 707
    tilec->x1 = int_ceildiv(tile->x1, (image->comps + compno)->dx);
#line 708
    tilec->y1 = int_ceildiv(tile->y1, (image->comps + compno)->dy);
#line 710
    tilec->numresolutions = tccp->numresolutions;
#line 711
    __cil_tmp19 = malloc((unsigned long )tilec->numresolutions * sizeof(opj_tcd_resolution_t ));
#line 711
    tilec->resolutions = (opj_tcd_resolution_t *)__cil_tmp19;
#line 713
    resno = 0;
    }
    {
#line 713
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 713
      if (! (resno < tilec->numresolutions)) {
#line 713
        goto while_break___0;
      }
      {
#line 715
      levelno = (tilec->numresolutions - 1) - resno;
#line 721
      res = tilec->resolutions + resno;
#line 724
      res->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 725
      res->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 726
      res->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 727
      res->y1 = int_ceildivpow2(tilec->y1, levelno);
      }
#line 728
      if (resno == 0) {
#line 728
        tmp = 1;
      } else {
#line 728
        tmp = 3;
      }
#line 728
      res->numbands = tmp;
#line 731
      if (tccp->csty & 1) {
#line 732
        pdx = tccp->prcw[resno];
#line 733
        pdy = tccp->prch[resno];
      } else {
#line 735
        pdx = 15;
#line 736
        pdy = 15;
      }
      {
#line 740
      __cil_tmp41 = int_floordivpow2(res->x0, pdx);
#line 740
      tlprcxstart = __cil_tmp41 << pdx;
#line 741
      __cil_tmp42 = int_floordivpow2(res->y0, pdy);
#line 741
      tlprcystart = __cil_tmp42 << pdy;
#line 742
      __cil_tmp43 = int_ceildivpow2(res->x1, pdx);
#line 742
      brprcxend = __cil_tmp43 << pdx;
#line 743
      __cil_tmp44 = int_ceildivpow2(res->y1, pdy);
#line 743
      brprcyend = __cil_tmp44 << pdy;
      }
#line 745
      if (res->x0 == res->x1) {
#line 745
        tmp___0 = 0;
      } else {
#line 745
        tmp___0 = (brprcxend - tlprcxstart) >> pdx;
      }
#line 745
      res->pw = tmp___0;
#line 746
      if (res->y0 == res->y1) {
#line 746
        tmp___1 = 0;
      } else {
#line 746
        tmp___1 = (brprcyend - tlprcystart) >> pdy;
      }
#line 746
      res->ph = tmp___1;
#line 748
      if (resno == 0) {
#line 749
        tlcbgxstart = tlprcxstart;
#line 750
        tlcbgystart = tlprcystart;
#line 751
        brcbgxend = brprcxend;
#line 752
        brcbgyend = brprcyend;
#line 753
        cbgwidthexpn = pdx;
#line 754
        cbgheightexpn = pdy;
      } else {
        {
#line 756
        tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
#line 757
        tlcbgystart = int_ceildivpow2(tlprcystart, 1);
#line 758
        brcbgxend = int_ceildivpow2(brprcxend, 1);
#line 759
        brcbgyend = int_ceildivpow2(brprcyend, 1);
#line 760
        cbgwidthexpn = pdx - 1;
#line 761
        cbgheightexpn = pdy - 1;
        }
      }
      {
#line 764
      cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
#line 765
      cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
#line 767
      bandno = 0;
      }
      {
#line 767
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 767
        if (! (bandno < res->numbands)) {
#line 767
          goto while_break___1;
        }
#line 770
        ss = (opj_stepsize_t *)((void *)0);
#line 772
        band = & res->bands[bandno];
#line 773
        if (resno == 0) {
#line 773
          tmp___2 = 0;
        } else {
#line 773
          tmp___2 = bandno + 1;
        }
#line 773
        band->bandno = tmp___2;
#line 774
        if (band->bandno == 1 || band->bandno == 3) {
#line 774
          tmp___3 = 1;
        } else {
#line 774
          tmp___3 = 0;
        }
#line 774
        x0b = tmp___3;
#line 775
        if (band->bandno == 2 || band->bandno == 3) {
#line 775
          tmp___4 = 1;
        } else {
#line 775
          tmp___4 = 0;
        }
#line 775
        y0b = tmp___4;
#line 777
        if (band->bandno == 0) {
          {
#line 779
          band->x0 = int_ceildivpow2(tilec->x0, levelno);
#line 780
          band->y0 = int_ceildivpow2(tilec->y0, levelno);
#line 781
          band->x1 = int_ceildivpow2(tilec->x1, levelno);
#line 782
          band->y1 = int_ceildivpow2(tilec->y1, levelno);
          }
        } else {
          {
#line 785
          band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
#line 786
          band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
#line 787
          band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
#line 788
          band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
          }
        }
#line 791
        if (resno == 0) {
#line 791
          tmp___5 = 0;
        } else {
#line 791
          tmp___5 = (3 * (resno - 1) + bandno) + 1;
        }
#line 791
        ss = & tccp->stepsizes[tmp___5];
#line 792
        if (tccp->qmfbid == 0) {
          {
#line 792
          __cil_tmp71 = dwt_getgain_real(band->bandno);
#line 792
          tmp___6 = __cil_tmp71;
          }
        } else {
          {
#line 792
          __cil_tmp72 = dwt_getgain(band->bandno);
#line 792
          tmp___6 = __cil_tmp72;
          }
        }
        {
#line 792
        gain = tmp___6;
#line 793
        numbps = (image->comps + compno)->prec + gain;
#line 794
        __cil_tmp74 = pow(2., (double )(numbps - ss->expn));
#line 794
        band->stepsize = (float )(((1. + (double )ss->mant / 2048.) * __cil_tmp74) * 0.5);
#line 795
        band->numbps = (ss->expn + tccp->numgbits) - 1;
#line 797
        __cil_tmp75 = malloc((unsigned long )(res->pw * res->ph) * sizeof(opj_tcd_precinct_t ));
#line 797
        band->precincts = (opj_tcd_precinct_t *)__cil_tmp75;
#line 799
        precno = 0;
        }
        {
#line 799
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 799
          if (! (precno < res->pw * res->ph)) {
#line 799
            goto while_break___2;
          }
          {
#line 801
          cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
#line 802
          cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
#line 803
          cbgxend = cbgxstart + (1 << cbgwidthexpn);
#line 804
          cbgyend = cbgystart + (1 << cbgheightexpn);
#line 806
          prc = band->precincts + precno;
#line 808
          prc->x0 = int_max(cbgxstart, band->x0);
#line 809
          prc->y0 = int_max(cbgystart, band->y0);
#line 810
          prc->x1 = int_min(cbgxend, band->x1);
#line 811
          prc->y1 = int_min(cbgyend, band->y1);
#line 813
          __cil_tmp89 = int_floordivpow2(prc->x0, cblkwidthexpn);
#line 813
          tlcblkxstart = __cil_tmp89 << cblkwidthexpn;
#line 814
          __cil_tmp90 = int_floordivpow2(prc->y0, cblkheightexpn);
#line 814
          tlcblkystart = __cil_tmp90 << cblkheightexpn;
#line 815
          __cil_tmp91 = int_ceildivpow2(prc->x1, cblkwidthexpn);
#line 815
          brcblkxend = __cil_tmp91 << cblkwidthexpn;
#line 816
          __cil_tmp92 = int_ceildivpow2(prc->y1, cblkheightexpn);
#line 816
          brcblkyend = __cil_tmp92 << cblkheightexpn;
#line 817
          prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
#line 818
          prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
#line 820
          __cil_tmp93 = malloc((unsigned long )(prc->cw * prc->ch) * sizeof(opj_tcd_cblk_dec_t ));
#line 820
          prc->cblks.dec = (opj_tcd_cblk_dec_t *)__cil_tmp93;
#line 822
          prc->incltree = tgt_create(prc->cw, prc->ch);
#line 823
          prc->imsbtree = tgt_create(prc->cw, prc->ch);
#line 825
          cblkno = 0;
          }
          {
#line 825
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 825
            if (! (cblkno < prc->cw * prc->ch)) {
#line 825
              goto while_break___3;
            }
            {
#line 826
            cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
#line 827
            cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
#line 828
            cblkxend = cblkxstart + (1 << cblkwidthexpn);
#line 829
            cblkyend = cblkystart + (1 << cblkheightexpn);
#line 831
            cblk = prc->cblks.dec + cblkno;
#line 832
            cblk->data = (unsigned char *)((void *)0);
#line 833
            cblk->segs = (opj_tcd_seg_t *)((void *)0);
#line 835
            cblk->x0 = int_max(cblkxstart, prc->x0);
#line 836
            cblk->y0 = int_max(cblkystart, prc->y0);
#line 837
            cblk->x1 = int_min(cblkxend, prc->x1);
#line 838
            cblk->y1 = int_min(cblkyend, prc->y1);
#line 839
            cblk->numsegs = 0;
            }
#line 825
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 799
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 767
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 713
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 694
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 848 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_makelayer_fixed(opj_tcd_t *tcd , int layno , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int value ;
  int matrice[10][10][3] ;
  int i ;
  int j ;
  int k ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int imsb ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 854
  cp = tcd->cp;
#line 855
  tcd_tile = tcd->tcd_tile;
#line 856
  tcd_tcp = tcd->tcp;
#line 860
  compno = 0;
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if (! (compno < tcd_tile->numcomps)) {
#line 860
      goto while_break;
    }
#line 861
    tilec = tcd_tile->comps + compno;
#line 862
    i = 0;
    {
#line 862
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 862
      if (! (i < tcd_tcp->numlayers)) {
#line 862
        goto while_break___0;
      }
#line 863
      j = 0;
      {
#line 863
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 863
        if (! (j < tilec->numresolutions)) {
#line 863
          goto while_break___1;
        }
#line 864
        k = 0;
        {
#line 864
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 864
          if (! (k < 3)) {
#line 864
            goto while_break___2;
          }
#line 865
          matrice[i][j][k] = (int )((float )*(cp->matrice + (((i * tilec->numresolutions) * 3 + j * 3) + k)) * (float )((double )((tcd->image)->comps + compno)->prec / 16.));
#line 864
          k ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 863
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 862
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 872
    resno = 0;
    {
#line 872
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 872
      if (! (resno < tilec->numresolutions)) {
#line 872
        goto while_break___3;
      }
#line 873
      res = tilec->resolutions + resno;
#line 874
      bandno = 0;
      {
#line 874
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 874
        if (! (bandno < res->numbands)) {
#line 874
          goto while_break___4;
        }
#line 875
        band = & res->bands[bandno];
#line 876
        precno = 0;
        {
#line 876
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 876
          if (! (precno < res->pw * res->ph)) {
#line 876
            goto while_break___5;
          }
#line 877
          prc = band->precincts + precno;
#line 878
          cblkno = 0;
          {
#line 878
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 878
            if (! (cblkno < prc->cw * prc->ch)) {
#line 878
              goto while_break___6;
            }
#line 879
            cblk = prc->cblks.enc + cblkno;
#line 880
            layer = cblk->layers + layno;
#line 882
            imsb = ((tcd->image)->comps + compno)->prec - cblk->numbps;
#line 884
            if (layno == 0) {
#line 885
              value = matrice[layno][resno][bandno];
#line 886
              if (imsb >= value) {
#line 887
                value = 0;
              } else {
#line 889
                value -= imsb;
              }
            } else {
#line 892
              value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];
#line 893
              if (imsb >= matrice[layno - 1][resno][bandno]) {
#line 894
                value -= imsb - matrice[layno - 1][resno][bandno];
#line 895
                if (value < 0) {
#line 896
                  value = 0;
                }
              }
            }
#line 901
            if (layno == 0) {
#line 902
              cblk->numpassesinlayers = 0;
            }
#line 905
            n = cblk->numpassesinlayers;
#line 906
            if (cblk->numpassesinlayers == 0) {
#line 907
              if (value != 0) {
#line 908
                n = (3 * value - 2) + cblk->numpassesinlayers;
              } else {
#line 910
                n = cblk->numpassesinlayers;
              }
            } else {
#line 913
              n = 3 * value + cblk->numpassesinlayers;
            }
#line 916
            layer->numpasses = n - cblk->numpassesinlayers;
#line 918
            if (! layer->numpasses) {
#line 919
              goto while_continue___6;
            }
#line 921
            if (cblk->numpassesinlayers == 0) {
#line 922
              layer->len = (cblk->passes + (n - 1))->rate;
#line 923
              layer->data = cblk->data;
            } else {
#line 925
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 926
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
            }
#line 928
            if (final) {
#line 929
              cblk->numpassesinlayers = n;
            }
#line 878
            cblkno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 876
          precno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 874
        bandno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 872
      resno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 860
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 937 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_rateallocate_fixed(opj_tcd_t *tcd ) 
{ 
  int layno ;
  int __cil_tmp3 ;

  {
#line 939
  layno = 0;
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 939
    if (! (layno < (tcd->tcp)->numlayers)) {
#line 939
      goto while_break;
    }
    {
#line 940
    tcd_makelayer_fixed(tcd, layno, 1);
    }
#line 939
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 944 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_makelayer(opj_tcd_t *tcd , int layno , double thresh , int final ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_layer_t *layer ;
  int n ;
  int dr ;
  double dd ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;

  {
#line 947
  tcd_tile = tcd->tcd_tile;
#line 949
  tcd_tile->distolayer[layno] = (double )0;
#line 951
  compno = 0;
  {
#line 951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 951
    if (! (compno < tcd_tile->numcomps)) {
#line 951
      goto while_break;
    }
#line 952
    tilec = tcd_tile->comps + compno;
#line 953
    resno = 0;
    {
#line 953
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 953
      if (! (resno < tilec->numresolutions)) {
#line 953
        goto while_break___0;
      }
#line 954
      res = tilec->resolutions + resno;
#line 955
      bandno = 0;
      {
#line 955
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 955
        if (! (bandno < res->numbands)) {
#line 955
          goto while_break___1;
        }
#line 956
        band = & res->bands[bandno];
#line 957
        precno = 0;
        {
#line 957
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 957
          if (! (precno < res->pw * res->ph)) {
#line 957
            goto while_break___2;
          }
#line 958
          prc = band->precincts + precno;
#line 959
          cblkno = 0;
          {
#line 959
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 959
            if (! (cblkno < prc->cw * prc->ch)) {
#line 959
              goto while_break___3;
            }
#line 960
            cblk = prc->cblks.enc + cblkno;
#line 961
            layer = cblk->layers + layno;
#line 964
            if (layno == 0) {
#line 965
              cblk->numpassesinlayers = 0;
            }
#line 967
            n = cblk->numpassesinlayers;
#line 968
            passno = cblk->numpassesinlayers;
            {
#line 968
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 968
              if (! (passno < cblk->totalpasses)) {
#line 968
                goto while_break___4;
              }
#line 971
              pass = cblk->passes + passno;
#line 972
              if (n == 0) {
#line 973
                dr = pass->rate;
#line 974
                dd = pass->distortiondec;
              } else {
#line 976
                dr = pass->rate - (cblk->passes + (n - 1))->rate;
#line 977
                dd = pass->distortiondec - (cblk->passes + (n - 1))->distortiondec;
              }
#line 979
              if (! dr) {
#line 980
                if (dd != (double )0) {
#line 981
                  n = passno + 1;
                }
#line 982
                goto while_continue___4;
              }
#line 984
              if (dd / (double )dr >= thresh) {
#line 985
                n = passno + 1;
              }
#line 968
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 987
            layer->numpasses = n - cblk->numpassesinlayers;
#line 989
            if (! layer->numpasses) {
#line 990
              layer->disto = (double )0;
#line 991
              goto while_continue___3;
            }
#line 993
            if (cblk->numpassesinlayers == 0) {
#line 994
              layer->len = (cblk->passes + (n - 1))->rate;
#line 995
              layer->data = cblk->data;
#line 996
              layer->disto = (cblk->passes + (n - 1))->distortiondec;
            } else {
#line 998
              layer->len = (cblk->passes + (n - 1))->rate - (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 999
              layer->data = cblk->data + (cblk->passes + (cblk->numpassesinlayers - 1))->rate;
#line 1000
              layer->disto = (cblk->passes + (n - 1))->distortiondec - (cblk->passes + (cblk->numpassesinlayers - 1))->distortiondec;
            }
#line 1003
            tcd_tile->distolayer[layno] += layer->disto;
#line 1005
            if (final) {
#line 1006
              cblk->numpassesinlayers = n;
            }
#line 959
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 957
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 955
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 953
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 951
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1014 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
opj_bool tcd_rateallocate(opj_tcd_t *tcd , unsigned char *dest , int len , opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int passno ;
  int layno ;
  double min ;
  double max ;
  double cumdisto[100] ;
  double K ;
  double maxSE ;
  opj_cp_t *cp ;
  opj_tcd_tile_t *tcd_tile ;
  opj_tcp_t *tcd_tcp ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  opj_tcd_pass_t *pass ;
  int dr ;
  double dd ;
  double rdslope ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  opj_tile_info_t *tile_info ;
  void *__cil_tmp36 ;
  double lo ;
  double hi ;
  int success ;
  int maxlen ;
  double __cil_tmp41 ;
  int __cil_tmp42 ;
  int tmp ;
  double goodthresh ;
  double stable_thresh ;
  int i ;
  double distotarget ;
  double __cil_tmp48 ;
  opj_t2_t *t2 ;
  opj_t2_t *__cil_tmp50 ;
  double thresh ;
  int l ;
  double distoachieved ;
  int __cil_tmp54 ;
  double tmp___0 ;
  double tmp___1 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  double tmp___2 ;
  double tmp___3 ;
  int __cil_tmp61 ;

  {
#line 1018
  K = (double )1;
#line 1019
  maxSE = (double )0;
#line 1021
  cp = tcd->cp;
#line 1022
  tcd_tile = tcd->tcd_tile;
#line 1023
  tcd_tcp = tcd->tcp;
#line 1025
  min = (double )1.79769313487e+308L;
#line 1026
  max = (double )0;
#line 1028
  tcd_tile->numpix = 0;
#line 1030
  compno = 0;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! (compno < tcd_tile->numcomps)) {
#line 1030
      goto while_break;
    }
#line 1031
    tilec = tcd_tile->comps + compno;
#line 1032
    tilec->numpix = 0;
#line 1034
    resno = 0;
    {
#line 1034
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1034
      if (! (resno < tilec->numresolutions)) {
#line 1034
        goto while_break___0;
      }
#line 1035
      res = tilec->resolutions + resno;
#line 1037
      bandno = 0;
      {
#line 1037
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1037
        if (! (bandno < res->numbands)) {
#line 1037
          goto while_break___1;
        }
#line 1038
        band = & res->bands[bandno];
#line 1040
        precno = 0;
        {
#line 1040
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1040
          if (! (precno < res->pw * res->ph)) {
#line 1040
            goto while_break___2;
          }
#line 1041
          prc = band->precincts + precno;
#line 1043
          cblkno = 0;
          {
#line 1043
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1043
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1043
              goto while_break___3;
            }
#line 1044
            cblk = prc->cblks.enc + cblkno;
#line 1046
            passno = 0;
            {
#line 1046
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1046
              if (! (passno < cblk->totalpasses)) {
#line 1046
                goto while_break___4;
              }
#line 1047
              pass = cblk->passes + passno;
#line 1050
              if (passno == 0) {
#line 1051
                dr = pass->rate;
#line 1052
                dd = pass->distortiondec;
              } else {
#line 1054
                dr = pass->rate - (cblk->passes + (passno - 1))->rate;
#line 1055
                dd = pass->distortiondec - (cblk->passes + (passno - 1))->distortiondec;
              }
#line 1057
              if (dr == 0) {
#line 1058
                goto while_continue___4;
              }
#line 1060
              rdslope = dd / (double )dr;
#line 1061
              if (rdslope < min) {
#line 1062
                min = rdslope;
              }
#line 1064
              if (rdslope > max) {
#line 1065
                max = rdslope;
              }
#line 1046
              passno ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 1070
            tcd_tile->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1071
            tilec->numpix += (cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0);
#line 1043
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1040
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1037
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1034
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1077
    maxSE += (((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.) * ((double )(1 << ((tcd->image)->comps + compno)->prec) - 1.)) * (double )tilec->numpix;
#line 1030
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1083
  if (cstr_info) {
    {
#line 1084
    tile_info = cstr_info->tile + tcd->tcd_tileno;
#line 1085
    tile_info->numpix = tcd_tile->numpix;
#line 1086
    tile_info->distotile = tcd_tile->distotile;
#line 1087
    __cil_tmp36 = malloc((unsigned long )tcd_tcp->numlayers * sizeof(double ));
#line 1087
    tile_info->thresh = (double *)__cil_tmp36;
    }
  }
#line 1090
  layno = 0;
  {
#line 1090
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1090
    if (! (layno < tcd_tcp->numlayers)) {
#line 1090
      goto while_break___5;
    }
#line 1091
    lo = min;
#line 1092
    hi = max;
#line 1093
    success = 0;
#line 1094
    if (tcd_tcp->rates[layno]) {
      {
#line 1094
      __cil_tmp41 = ceil((double )tcd_tcp->rates[layno]);
#line 1094
      __cil_tmp42 = int_min((int )__cil_tmp41, len);
#line 1094
      tmp = __cil_tmp42;
      }
    } else {
#line 1094
      tmp = len;
    }
    {
#line 1094
    maxlen = tmp;
#line 1095
    goodthresh = (double )0;
#line 1096
    stable_thresh = (double )0;
#line 1101
    __cil_tmp48 = pow((double )((float )10), (double )(tcd_tcp->distoratio[layno] / (float )10));
#line 1101
    distotarget = tcd_tile->distotile - (K * maxSE) / __cil_tmp48;
    }
#line 1107
    if (cp->disto_alloc == 1) {
#line 1107
      if (tcd_tcp->rates[layno] > (float )0) {
        _L: /* CIL Label */ 
        {
#line 1108
        __cil_tmp50 = t2_create(tcd->cinfo, tcd->image, cp);
#line 1108
        t2 = __cil_tmp50;
#line 1109
        thresh = (double )0;
#line 1111
        i = 0;
        }
        {
#line 1111
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1111
          if (! (i < 128)) {
#line 1111
            goto while_break___6;
          }
          {
#line 1112
          l = 0;
#line 1113
          distoachieved = (double )0;
#line 1114
          thresh = (lo + hi) / (double )2;
#line 1116
          tcd_makelayer(tcd, layno, thresh, 0);
          }
#line 1118
          if (cp->fixed_quality) {
#line 1119
            if (cp->cinema) {
              {
#line 1120
              l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                    maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                    tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
              }
#line 1121
              if (l == -999) {
#line 1122
                lo = thresh;
#line 1123
                goto while_continue___6;
              } else {
#line 1125
                if (layno == 0) {
#line 1125
                  tmp___0 = tcd_tile->distolayer[0];
                } else {
#line 1125
                  tmp___0 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
                }
#line 1125
                distoachieved = tmp___0;
#line 1127
                if (distoachieved < distotarget) {
#line 1128
                  hi = thresh;
#line 1129
                  stable_thresh = thresh;
#line 1130
                  goto while_continue___6;
                } else {
#line 1132
                  lo = thresh;
                }
              }
            } else {
#line 1136
              if (layno == 0) {
#line 1136
                tmp___1 = tcd_tile->distolayer[0];
              } else {
#line 1136
                tmp___1 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
              }
#line 1136
              distoachieved = tmp___1;
#line 1138
              if (distoachieved < distotarget) {
#line 1139
                hi = thresh;
#line 1140
                stable_thresh = thresh;
#line 1141
                goto while_continue___6;
              }
#line 1143
              lo = thresh;
            }
          } else {
            {
#line 1146
            l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,
                                  maxlen, cstr_info, tcd->cur_tp_num, tcd->tp_pos,
                                  tcd->cur_pino, (J2K_T2_MODE )0, tcd->cur_totnum_tp);
            }
#line 1149
            if (l == -999) {
#line 1150
              lo = thresh;
#line 1151
              goto while_continue___6;
            }
#line 1153
            hi = thresh;
#line 1154
            stable_thresh = thresh;
          }
#line 1111
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1157
        success = 1;
#line 1158
        if (stable_thresh == (double )0) {
#line 1158
          tmp___2 = thresh;
        } else {
#line 1158
          tmp___2 = stable_thresh;
        }
        {
#line 1158
        goodthresh = tmp___2;
#line 1159
        t2_destroy(t2);
        }
      } else {
#line 1107
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1107
    if (cp->fixed_quality == 1) {
#line 1107
      if (tcd_tcp->distoratio[layno] > (float )0) {
#line 1107
        goto _L;
      } else {
#line 1161
        success = 1;
#line 1162
        goodthresh = min;
      }
    } else {
#line 1161
      success = 1;
#line 1162
      goodthresh = min;
    }
#line 1165
    if (! success) {
#line 1166
      return (0);
    }
#line 1169
    if (cstr_info) {
#line 1170
      *((cstr_info->tile + tcd->tcd_tileno)->thresh + layno) = goodthresh;
    }
    {
#line 1172
    tcd_makelayer(tcd, layno, goodthresh, 1);
    }
#line 1175
    if (layno == 0) {
#line 1175
      tmp___3 = tcd_tile->distolayer[0];
    } else {
#line 1175
      tmp___3 = cumdisto[layno - 1] + tcd_tile->distolayer[layno];
    }
#line 1175
    cumdisto[layno] = tmp___3;
#line 1090
    layno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1178
  return (1);
}
}
#line 1181 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
int tcd_encode_tile(opj_tcd_t *tcd , int tileno , unsigned char *dest , int len ,
                    opj_codestream_info_t *cstr_info ) 
{ 
  int compno ;
  int l ;
  int i ;
  int numpacks ;
  opj_tcd_tile_t *tile ;
  opj_tcp_t *tcd_tcp ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_image_t *image ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp18 ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  int x ;
  int y ;
  int adjust ;
  int tmp ;
  int offset_x ;
  int __cil_tmp28 ;
  int offset_y ;
  int __cil_tmp30 ;
  opj_tcd_tilecomp_t *tilec ;
  int tw ;
  int w ;
  int __cil_tmp34 ;
  int *data ;
  int *tile_data ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int *data___0 ;
  int *tile_data___0 ;
  int *__cil_tmp43 ;
  int *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int samples ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int __cil_tmp50 ;
  opj_t1_t *__cil_tmp51 ;
  opj_t2_t *__cil_tmp52 ;
  int __cil_tmp53 ;
  double __cil_tmp54 ;
  opj_tcd_tilecomp_t *tilec___1 ;
  int __cil_tmp56 ;

  {
#line 1183
  numpacks = 0;
#line 1184
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1185
  tcd_tcp = (opj_tcp_t *)((void *)0);
#line 1186
  cp = (opj_cp_t *)((void *)0);
#line 1188
  tcp = (tcd->cp)->tcps + 0;
#line 1189
  tccp = tcp->tccps + 0;
#line 1190
  image = tcd->image;
#line 1192
  t1 = (opj_t1_t *)((void *)0);
#line 1193
  t2 = (opj_t2_t *)((void *)0);
#line 1195
  tcd->tcd_tileno = tileno;
#line 1196
  tcd->tcd_tile = (tcd->tcd_image)->tiles;
#line 1197
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1199
  tile = tcd->tcd_tile;
#line 1200
  tcd_tcp = tcd->tcp;
#line 1201
  cp = tcd->cp;
#line 1203
  if (tcd->cur_tp_num == 0) {
    {
#line 1204
    tcd->encoding_time = opj_clock();
    }
#line 1206
    if (cstr_info) {
#line 1207
      tilec_idx = tile->comps + 0;
#line 1208
      i = 0;
      {
#line 1208
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1208
        if (! (i < tilec_idx->numresolutions)) {
#line 1208
          goto while_break;
        }
#line 1209
        res_idx = tilec_idx->resolutions + i;
#line 1211
        (cstr_info->tile + tileno)->pw[i] = res_idx->pw;
#line 1212
        (cstr_info->tile + tileno)->ph[i] = res_idx->ph;
#line 1214
        numpacks += res_idx->pw * res_idx->ph;
#line 1216
        (cstr_info->tile + tileno)->pdx[i] = tccp->prcw[i];
#line 1217
        (cstr_info->tile + tileno)->pdy[i] = tccp->prch[i];
#line 1208
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1219
      __cil_tmp22 = calloc((unsigned long )((cstr_info->numcomps * cstr_info->numlayers) * numpacks),
                           sizeof(opj_packet_info_t ));
#line 1219
      (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp22;
      }
    }
#line 1225
    compno = 0;
    {
#line 1225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1225
      if (! (compno < tile->numcomps)) {
#line 1225
        goto while_break___0;
      }
#line 1228
      if ((image->comps + compno)->sgnd) {
#line 1228
        tmp = 0;
      } else {
#line 1228
        tmp = 1 << ((image->comps + compno)->prec - 1);
      }
      {
#line 1228
      adjust = tmp;
#line 1229
      __cil_tmp28 = int_ceildiv(image->x0, (image->comps + compno)->dx);
#line 1229
      offset_x = __cil_tmp28;
#line 1230
      __cil_tmp30 = int_ceildiv(image->y0, (image->comps + compno)->dy);
#line 1230
      offset_y = __cil_tmp30;
#line 1232
      tilec = tile->comps + compno;
#line 1233
      tw = tilec->x1 - tilec->x0;
#line 1234
      __cil_tmp34 = int_ceildiv(image->x1 - image->x0, (image->comps + compno)->dx);
#line 1234
      w = __cil_tmp34;
      }
#line 1238
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
#line 1239
        y = tilec->y0;
        {
#line 1239
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1239
          if (! (y < tilec->y1)) {
#line 1239
            goto while_break___1;
          }
#line 1241
          data = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1243
          tile_data = tilec->data + (y - tilec->y0) * tw;
#line 1244
          x = tilec->x0;
          {
#line 1244
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1244
            if (! (x < tilec->x1)) {
#line 1244
              goto while_break___2;
            }
#line 1245
            __cil_tmp38 = data;
#line 1245
            data ++;
#line 1245
            __cil_tmp37 = tile_data;
#line 1245
            tile_data ++;
#line 1245
            *__cil_tmp37 = *__cil_tmp38 - adjust;
#line 1244
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1239
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 1248
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
#line 1249
        y = tilec->y0;
        {
#line 1249
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1249
          if (! (y < tilec->y1)) {
#line 1249
            goto while_break___3;
          }
#line 1251
          data___0 = (image->comps + compno)->data + ((tilec->x0 - offset_x) + (y - offset_y) * w);
#line 1253
          tile_data___0 = tilec->data + (y - tilec->y0) * tw;
#line 1254
          x = tilec->x0;
          {
#line 1254
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1254
            if (! (x < tilec->x1)) {
#line 1254
              goto while_break___4;
            }
#line 1255
            __cil_tmp44 = data___0;
#line 1255
            data___0 ++;
#line 1255
            __cil_tmp43 = tile_data___0;
#line 1255
            tile_data___0 ++;
#line 1255
            *__cil_tmp43 = (*__cil_tmp44 - adjust) << 11;
#line 1254
            x ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1249
          y ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1225
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1263
    if (tcd_tcp->mct) {
#line 1264
      samples = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1265
      if ((tcd_tcp->tccps + 0)->qmfbid == 0) {
        {
#line 1266
        mct_encode_real((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                        samples);
        }
      } else {
        {
#line 1268
        mct_encode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   samples);
        }
      }
    }
#line 1274
    compno = 0;
    {
#line 1274
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1274
      if (! (compno < tile->numcomps)) {
#line 1274
        goto while_break___5;
      }
#line 1275
      tilec___0 = tile->comps + compno;
#line 1276
      if ((tcd_tcp->tccps + compno)->qmfbid == 1) {
        {
#line 1277
        dwt_encode(tilec___0);
        }
      } else
#line 1278
      if ((tcd_tcp->tccps + compno)->qmfbid == 0) {
        {
#line 1279
        dwt_encode_real(tilec___0);
        }
      }
#line 1274
      compno ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1284
    t1 = t1_create(tcd->cinfo);
#line 1285
    t1_encode_cblks(t1, tile, tcd_tcp);
#line 1286
    t1_destroy(t1);
    }
#line 1291
    if (cstr_info) {
#line 1292
      cstr_info->index_write = 0;
    }
#line 1294
    if (cp->disto_alloc) {
      {
      {
#line 1296
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else
#line 1294
    if (cp->fixed_quality) {
      {
      {
#line 1296
      tcd_rateallocate(tcd, dest, len, cstr_info);
      }
      }
    } else {
      {
#line 1299
      tcd_rateallocate_fixed(tcd);
      }
    }
  }
#line 1305
  if (cstr_info) {
#line 1306
    cstr_info->index_write = 1;
  }
  {
#line 1309
  t2 = t2_create(tcd->cinfo, image, cp);
#line 1310
  l = t2_encode_packets(t2, tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,
                        tcd->tp_num, tcd->tp_pos, tcd->cur_pino, (J2K_T2_MODE )1,
                        tcd->cur_totnum_tp);
#line 1311
  t2_destroy(t2);
  }
#line 1316
  if (tcd->cur_tp_num == tcd->cur_totnum_tp - 1) {
    {
#line 1317
    __cil_tmp54 = opj_clock();
#line 1317
    tcd->encoding_time = __cil_tmp54 - tcd->encoding_time;
#line 1318
    opj_event_msg(tcd->cinfo, 4, "- tile encoded in %f s\n", tcd->encoding_time);
#line 1321
    compno = 0;
    }
    {
#line 1321
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1321
      if (! (compno < tile->numcomps)) {
#line 1321
        goto while_break___6;
      }
      {
#line 1322
      tilec___1 = tile->comps + compno;
#line 1323
      free(tilec___1->data);
      }
#line 1321
      compno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1327
  return (l);
}
}
#line 1330 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
opj_bool tcd_decode_tile(opj_tcd_t *tcd , unsigned char *src , int len , int tileno ,
                         opj_codestream_info_t *cstr_info ) 
{ 
  int l ;
  int compno ;
  int eof ;
  double tile_time ;
  double t1_time ;
  double dwt_time ;
  opj_tcd_tile_t *tile ;
  opj_t1_t *t1 ;
  opj_t2_t *t2 ;
  double __cil_tmp15 ;
  int resno ;
  int compno___1 ;
  int numprec ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_tcd_tilecomp_t *tilec_idx ;
  opj_tcd_resolution_t *res_idx ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  void *__cil_tmp25 ;
  opj_t2_t *__cil_tmp26 ;
  int __cil_tmp27 ;
  double __cil_tmp28 ;
  opj_t1_t *__cil_tmp29 ;
  opj_tcd_tilecomp_t *tilec ;
  void *__cil_tmp31 ;
  double __cil_tmp32 ;
  double __cil_tmp33 ;
  opj_tcd_tilecomp_t *tilec___0 ;
  int numres2decode ;
  int __cil_tmp36 ;
  double __cil_tmp37 ;
  int n ;
  opj_tcd_tilecomp_t *tilec___1 ;
  opj_image_comp_t *imagec ;
  opj_tcd_resolution_t *res ;
  int adjust ;
  int tmp ;
  int min ;
  int tmp___0 ;
  int max ;
  int tmp___1 ;
  int tw ;
  int w ;
  int offset_x ;
  int __cil_tmp51 ;
  int offset_y ;
  int __cil_tmp53 ;
  int i ;
  int j ;
  void *__cil_tmp56 ;
  int v ;
  int __cil_tmp58 ;
  float tmp___2 ;
  int v___0 ;
  long __cil_tmp61 ;
  int __cil_tmp62 ;
  double __cil_tmp63 ;

  {
  {
#line 1333
  eof = 0;
#line 1335
  tile = (opj_tcd_tile_t *)((void *)0);
#line 1337
  t1 = (opj_t1_t *)((void *)0);
#line 1338
  t2 = (opj_t2_t *)((void *)0);
#line 1340
  tcd->tcd_tileno = tileno;
#line 1341
  tcd->tcd_tile = (tcd->tcd_image)->tiles + tileno;
#line 1342
  tcd->tcp = (tcd->cp)->tcps + tileno;
#line 1343
  tile = tcd->tcd_tile;
#line 1345
  tile_time = opj_clock();
#line 1346
  opj_event_msg(tcd->cinfo, 4, "tile %d of %d\n", tileno + 1, (tcd->cp)->tw * (tcd->cp)->th);
  }
#line 1349
  if (cstr_info) {
#line 1350
    numprec = 0;
#line 1351
    compno___1 = 0;
    {
#line 1351
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1351
      if (! (compno___1 < cstr_info->numcomps)) {
#line 1351
        goto while_break;
      }
#line 1352
      tcp = (tcd->cp)->tcps + 0;
#line 1353
      tccp = tcp->tccps + compno___1;
#line 1354
      tilec_idx = tile->comps + compno___1;
#line 1355
      resno = 0;
      {
#line 1355
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1355
        if (! (resno < tilec_idx->numresolutions)) {
#line 1355
          goto while_break___0;
        }
#line 1356
        res_idx = tilec_idx->resolutions + resno;
#line 1357
        (cstr_info->tile + tileno)->pw[resno] = res_idx->pw;
#line 1358
        (cstr_info->tile + tileno)->ph[resno] = res_idx->ph;
#line 1359
        numprec += res_idx->pw * res_idx->ph;
#line 1360
        if (tccp->csty & 1) {
#line 1361
          (cstr_info->tile + tileno)->pdx[resno] = tccp->prcw[resno];
#line 1362
          (cstr_info->tile + tileno)->pdy[resno] = tccp->prch[resno];
        } else {
#line 1365
          (cstr_info->tile + tileno)->pdx[resno] = 15;
#line 1366
          (cstr_info->tile + tileno)->pdy[resno] = 15;
        }
#line 1355
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1351
      compno___1 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1370
    __cil_tmp25 = malloc((unsigned long )(cstr_info->numlayers * numprec) * sizeof(opj_packet_info_t ));
#line 1370
    (cstr_info->tile + tileno)->packet = (opj_packet_info_t *)__cil_tmp25;
#line 1371
    cstr_info->packno = 0;
    }
  }
  {
#line 1377
  t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
#line 1378
  l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
#line 1379
  t2_destroy(t2);
  }
#line 1381
  if (l == -999) {
    {
#line 1382
    eof = 1;
#line 1383
    opj_event_msg(tcd->cinfo, 1, "tcd_decode: incomplete bistream\n\220");
    }
  }
  {
#line 1388
  t1_time = opj_clock();
#line 1389
  t1 = t1_create(tcd->cinfo);
  }
#line 1390
  if (t1 == (void *)0) {
    {
#line 1392
    opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
#line 1393
    t1_destroy(t1);
    }
#line 1394
    return (0);
  }
#line 1397
  compno = 0;
  {
#line 1397
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1397
    if (! (compno < tile->numcomps)) {
#line 1397
      goto while_break___1;
    }
    {
#line 1398
    tilec = tile->comps + compno;
#line 1400
    __cil_tmp31 = malloc((unsigned long )((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) + 3) * sizeof(int ));
#line 1400
    tilec->data = (int *)__cil_tmp31;
    }
#line 1401
    if (tilec->data == (void *)0) {
      {
#line 1403
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
      }
#line 1404
      return (0);
    }
    {
#line 1407
    t1_decode_cblks(t1, tilec, (tcd->tcp)->tccps + compno);
    }
#line 1397
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1409
  t1_destroy(t1);
#line 1410
  __cil_tmp32 = opj_clock();
#line 1410
  t1_time = __cil_tmp32 - t1_time;
#line 1411
  opj_event_msg(tcd->cinfo, 4, "- tiers-1 took %f s\n", t1_time);
#line 1415
  dwt_time = opj_clock();
#line 1416
  compno = 0;
  }
  {
#line 1416
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1416
    if (! (compno < tile->numcomps)) {
#line 1416
      goto while_break___2;
    }
#line 1417
    tilec___0 = tile->comps + compno;
#line 1420
    if ((tcd->cp)->reduce != 0) {
#line 1421
      if ((tile->comps + compno)->numresolutions < (tcd->cp)->reduce - 1) {
        {
#line 1422
        opj_event_msg(tcd->cinfo, 1, "Error decoding tile. The number of resolutions to remove [%d+1] is higher than the number  of resolutions in the original codestream [%d]\nModify the cp_reduce parameter.\n",
                      (tcd->cp)->reduce, (tile->comps + compno)->numresolutions);
        }
#line 1424
        return (0);
      } else {
#line 1427
        ((tcd->image)->comps + compno)->resno_decoded = ((tile->comps + compno)->numresolutions - (tcd->cp)->reduce) - 1;
      }
    }
#line 1432
    numres2decode = ((tcd->image)->comps + compno)->resno_decoded + 1;
#line 1433
    if (numres2decode > 0) {
#line 1434
      if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
        {
#line 1435
        dwt_decode(tilec___0, numres2decode);
        }
      } else {
        {
#line 1437
        dwt_decode_real(tilec___0, numres2decode);
        }
      }
    }
#line 1416
    compno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1441
  __cil_tmp37 = opj_clock();
#line 1441
  dwt_time = __cil_tmp37 - dwt_time;
#line 1442
  opj_event_msg(tcd->cinfo, 4, "- dwt took %f s\n\230\001", dwt_time);
  }
#line 1446
  if ((tcd->tcp)->mct) {
#line 1447
    n = ((tile->comps + 0)->x1 - (tile->comps + 0)->x0) * ((tile->comps + 0)->y1 - (tile->comps + 0)->y0);
#line 1449
    if (tile->numcomps >= 3) {
#line 1450
      if (((tcd->tcp)->tccps + 0)->qmfbid == 1) {
        {
#line 1451
        mct_decode((tile->comps + 0)->data, (tile->comps + 1)->data, (tile->comps + 2)->data,
                   n);
        }
      } else {
        {
#line 1457
        mct_decode_real((float *)(tile->comps + 0)->data, (float *)(tile->comps + 1)->data,
                        (float *)(tile->comps + 2)->data, n);
        }
      }
    } else {
      {
#line 1464
      opj_event_msg(tcd->cinfo, 2, "Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n\327\363B\262U",
                    tile->numcomps);
      }
    }
  }
#line 1470
  compno = 0;
  {
#line 1470
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1470
    if (! (compno < tile->numcomps)) {
#line 1470
      goto while_break___3;
    }
#line 1471
    tilec___1 = tile->comps + compno;
#line 1472
    imagec = (tcd->image)->comps + compno;
#line 1473
    res = tilec___1->resolutions + imagec->resno_decoded;
#line 1474
    if (imagec->sgnd) {
#line 1474
      tmp = 0;
    } else {
#line 1474
      tmp = 1 << (imagec->prec - 1);
    }
#line 1474
    adjust = tmp;
#line 1475
    if (imagec->sgnd) {
#line 1475
      tmp___0 = - (1 << (imagec->prec - 1));
    } else {
#line 1475
      tmp___0 = 0;
    }
#line 1475
    min = tmp___0;
#line 1476
    if (imagec->sgnd) {
#line 1476
      tmp___1 = (1 << (imagec->prec - 1)) - 1;
    } else {
#line 1476
      tmp___1 = (1 << imagec->prec) - 1;
    }
    {
#line 1476
    max = tmp___1;
#line 1478
    tw = tilec___1->x1 - tilec___1->x0;
#line 1479
    w = imagec->w;
#line 1481
    __cil_tmp51 = int_ceildivpow2(imagec->x0, imagec->factor);
#line 1481
    offset_x = __cil_tmp51;
#line 1482
    __cil_tmp53 = int_ceildivpow2(imagec->y0, imagec->factor);
#line 1482
    offset_y = __cil_tmp53;
    }
#line 1485
    if (! imagec->data) {
      {
#line 1486
      __cil_tmp56 = malloc((unsigned long )(imagec->w * imagec->h) * sizeof(int ));
#line 1486
      imagec->data = (int *)__cil_tmp56;
      }
    }
#line 1488
    if (! imagec->data) {
      {
#line 1490
      opj_event_msg(tcd->cinfo, 1, "Out of memory\n");
      }
#line 1491
      return (0);
    }
#line 1493
    if (((tcd->tcp)->tccps + compno)->qmfbid == 1) {
#line 1494
      j = res->y0;
      {
#line 1494
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1494
        if (! (j < res->y1)) {
#line 1494
          goto while_break___4;
        }
#line 1495
        i = res->x0;
        {
#line 1495
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1495
          if (! (i < res->x1)) {
#line 1495
            goto while_break___5;
          }
          {
#line 1496
          v = *(tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1497
          v += adjust;
#line 1498
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v, min,
                                                                              max);
          }
#line 1495
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1494
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 1502
      j = res->y0;
      {
#line 1502
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1502
        if (! (j < res->y1)) {
#line 1502
          goto while_break___6;
        }
#line 1503
        i = res->x0;
        {
#line 1503
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1503
          if (! (i < res->x1)) {
#line 1503
            goto while_break___7;
          }
          {
#line 1504
          tmp___2 = *((float *)tilec___1->data + ((i - res->x0) + (j - res->y0) * tw));
#line 1505
          __cil_tmp61 = lrintf(tmp___2);
#line 1505
          v___0 = (int )__cil_tmp61;
#line 1506
          v___0 += adjust;
#line 1507
          *(imagec->data + ((i - offset_x) + (j - offset_y) * w)) = int_clamp(v___0,
                                                                              min,
                                                                              max);
          }
#line 1503
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1502
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 1511
    free(tilec___1->data);
    }
#line 1470
    compno ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1514
  __cil_tmp63 = opj_clock();
#line 1514
  tile_time = __cil_tmp63 - tile_time;
#line 1515
  opj_event_msg(tcd->cinfo, 4, "- tile decoded in %f s\n", tile_time);
  }
#line 1517
  if (eof) {
#line 1518
    return (0);
  }
#line 1521
  return (1);
}
}
#line 1524 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_free_decode(opj_tcd_t *tcd ) 
{ 
  opj_tcd_image_t *tcd_image ;
  int i ;
  int __cil_tmp4 ;

  {
#line 1525
  tcd_image = tcd->tcd_image;
#line 1526
  i = 0;
#line 1527
  i = 0;
  {
#line 1527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1527
    if (! (i < tcd_image->tw * tcd_image->th)) {
#line 1527
      goto while_break;
    }
    {
#line 1529
    tcd_free_decode_tile(tcd, i);
    }
#line 1527
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1532
  free(tcd_image->tiles);
  }
  return;
}
}
#line 1535 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/tcd.c"
void tcd_free_decode_tile(opj_tcd_t *tcd , int tileno ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_image_t *tcd_image ;
  opj_tcd_tile_t *tile ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prec ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 1538
  tcd_image = tcd->tcd_image;
#line 1540
  tile = tcd_image->tiles + tileno;
#line 1541
  if (tile->comps != (void *)0) {
#line 1542
    compno = 0;
    {
#line 1542
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1542
      if (! (compno < tile->numcomps)) {
#line 1542
        goto while_break;
      }
#line 1543
      tilec = tile->comps + compno;
#line 1544
      resno = 0;
      {
#line 1544
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1544
        if (! (resno < tilec->numresolutions)) {
#line 1544
          goto while_break___0;
        }
#line 1545
        res = tilec->resolutions + resno;
#line 1546
        bandno = 0;
        {
#line 1546
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1546
          if (! (bandno < res->numbands)) {
#line 1546
            goto while_break___1;
          }
#line 1547
          band = & res->bands[bandno];
#line 1548
          precno = 0;
          {
#line 1548
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1548
            if (! (precno < res->ph * res->pw)) {
#line 1548
              goto while_break___2;
            }
#line 1549
            prec = band->precincts + precno;
#line 1550
            if (prec->cblks.dec != (void *)0) {
#line 1551
              cblkno = 0;
              {
#line 1551
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1551
                if (! (cblkno < prec->cw * prec->ch)) {
#line 1551
                  goto while_break___3;
                }
                {
#line 1552
                cblk = prec->cblks.dec + cblkno;
#line 1553
                free(cblk->data);
#line 1554
                free(cblk->segs);
                }
#line 1551
                cblkno ++;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 1556
              free(prec->cblks.dec);
              }
            }
#line 1558
            if (prec->imsbtree != (void *)0) {
              {
#line 1558
              tgt_destroy(prec->imsbtree);
              }
            }
#line 1559
            if (prec->incltree != (void *)0) {
              {
#line 1559
              tgt_destroy(prec->incltree);
              }
            }
#line 1548
            precno ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1563
          free(band->precincts);
          }
#line 1546
          bandno ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1544
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1566
      free(tilec->resolutions);
      }
#line 1542
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1568
    free(tile->comps);
#line 1569
    tile->comps = (opj_tcd_tilecomp_t *)((void *)0);
    }
  }
  return;
}
}
#line 40 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) ;
#line 41
static int t2_getcommacode(opj_bio_t *bio ) ;
#line 47
static void t2_putnumpasses(opj_bio_t *bio , int n ) ;
#line 48
static int t2_getnumpasses(opj_bio_t *bio ) ;
#line 60
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) ;
#line 67
static opj_bool t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty ,
                            int first ) ;
#line 79
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) ;
#line 90 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
static void t2_putcommacode(opj_bio_t *bio , int n ) 
{ 


  {
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    n --;
#line 91
    if (! (n >= 0)) {
#line 91
      goto while_break;
    }
    {
#line 92
    bio_write(bio, 1, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 94
  bio_write(bio, 0, 1);
  }
  return;
}
}
#line 97 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
static int t2_getcommacode(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 99
  n = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! __cil_tmp3) {
#line 99
      goto while_break;
    }

#line 99
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return (n);
}
}
#line 105 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
static void t2_putnumpasses(opj_bio_t *bio , int n ) 
{ 


  {
#line 106
  if (n == 1) {
    {
#line 107
    bio_write(bio, 0, 1);
    }
  } else
#line 108
  if (n == 2) {
    {
#line 109
    bio_write(bio, 2, 2);
    }
  } else
#line 110
  if (n <= 5) {
    {
#line 111
    bio_write(bio, 12 | (n - 3), 4);
    }
  } else
#line 112
  if (n <= 36) {
    {
#line 113
    bio_write(bio, 480 | (n - 6), 9);
    }
  } else
#line 114
  if (n <= 164) {
    {
#line 115
    bio_write(bio, 65408 | (n - 37), 16);
    }
  }
  return;
}
}
#line 119 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
static int t2_getnumpasses(opj_bio_t *bio ) 
{ 
  int n ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 121
  __cil_tmp3 = bio_read(bio, 1);
  }
#line 121
  if (! __cil_tmp3) {
#line 122
    return (1);
  }
  {
#line 123
  __cil_tmp4 = bio_read(bio, 1);
  }
#line 123
  if (! __cil_tmp4) {
#line 124
    return (2);
  }
  {
#line 125
  n = bio_read(bio, 2);
  }
#line 125
  if (n != 3) {
#line 126
    return (3 + n);
  }
  {
#line 127
  n = bio_read(bio, 5);
  }
#line 127
  if (n != 31) {
#line 128
    return (6 + n);
  }
  {
#line 129
  __cil_tmp7 = bio_read(bio, 7);
  }
#line 129
  return (37 + __cil_tmp7);
}
}
#line 132 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
static int t2_encode_packet(opj_tcd_tile_t *tile , opj_tcp_t *tcp , opj_pi_iterator_t *pi ,
                            unsigned char *dest , int length , opj_codestream_info_t *cstr_info ,
                            int tileno ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tcd_resolution_t *res ;
  opj_bio_t *bio ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  opj_bio_t *__cil_tmp23 ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  opj_tcd_cblk_enc_t *cblk___0 ;
  opj_tcd_layer_t *layer ;
  int __cil_tmp28 ;
  opj_tcd_cblk_enc_t *cblk___1 ;
  opj_tcd_layer_t *layer___0 ;
  int increment ;
  int nump ;
  int len ;
  int passno ;
  opj_tcd_pass_t *pass ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  opj_packet_info_t *info_PK ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_enc_t *cblk___2 ;
  opj_tcd_layer_t *layer___1 ;
  opj_packet_info_t *info_PK___0 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;

  {
#line 134
  c = dest;
#line 136
  compno = pi->compno;
#line 137
  resno = pi->resno;
#line 138
  precno = pi->precno;
#line 139
  layno = pi->layno;
#line 141
  tilec = tile->comps + compno;
#line 142
  res = tilec->resolutions + resno;
#line 144
  bio = (opj_bio_t *)((void *)0);
#line 147
  if (tcp->csty & 2) {
#line 148
    *(c + 0) = (unsigned char )255;
#line 149
    *(c + 1) = (unsigned char )145;
#line 150
    *(c + 2) = (unsigned char )0;
#line 151
    *(c + 3) = (unsigned char )4;
#line 152
    *(c + 4) = (unsigned char )((tile->packno % 65536) / 256);
#line 153
    *(c + 5) = (unsigned char )((tile->packno % 65536) % 256);
#line 154
    c += 6;
  }
#line 158
  if (! layno) {
#line 159
    bandno = 0;
    {
#line 159
    while (1) {
      while_continue: /* CIL Label */ ;
#line 159
      if (! (bandno < res->numbands)) {
#line 159
        goto while_break;
      }
      {
#line 160
      band = & res->bands[bandno];
#line 161
      prc = band->precincts + precno;
#line 162
      tgt_reset(prc->incltree);
#line 163
      tgt_reset(prc->imsbtree);
#line 164
      cblkno = 0;
      }
      {
#line 164
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 164
        if (! (cblkno < prc->cw * prc->ch)) {
#line 164
          goto while_break___0;
        }
        {
#line 165
        cblk = prc->cblks.enc + cblkno;
#line 166
        cblk->numpasses = 0;
#line 167
        tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
        }
#line 164
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 159
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 172
  bio = bio_create();
#line 173
  bio_init_enc(bio, c, length);
#line 174
  bio_write(bio, 1, 1);
#line 177
  bandno = 0;
  }
  {
#line 177
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 177
    if (! (bandno < res->numbands)) {
#line 177
      goto while_break___1;
    }
#line 178
    band___0 = & res->bands[bandno];
#line 179
    prc___0 = band___0->precincts + precno;
#line 180
    cblkno = 0;
    {
#line 180
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 180
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 180
        goto while_break___2;
      }
#line 181
      cblk___0 = prc___0->cblks.enc + cblkno;
#line 182
      layer = cblk___0->layers + layno;
#line 183
      if (! cblk___0->numpasses) {
#line 183
        if (layer->numpasses) {
          {
#line 184
          tgt_setvalue(prc___0->incltree, cblkno, layno);
          }
        }
      }
#line 180
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 187
    cblkno = 0;
    {
#line 187
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 187
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 187
        goto while_break___3;
      }
#line 188
      cblk___1 = prc___0->cblks.enc + cblkno;
#line 189
      layer___0 = cblk___1->layers + layno;
#line 190
      increment = 0;
#line 191
      nump = 0;
#line 192
      len = 0;
#line 194
      if (! cblk___1->numpasses) {
        {
#line 195
        tgt_encode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 197
        bio_write(bio, layer___0->numpasses != 0, 1);
        }
      }
#line 200
      if (! layer___0->numpasses) {
#line 201
        goto while_continue___3;
      }
#line 204
      if (! cblk___1->numpasses) {
        {
#line 205
        cblk___1->numlenbits = 3;
#line 206
        tgt_encode(bio, prc___0->imsbtree, cblkno, 999);
        }
      }
      {
#line 209
      t2_putnumpasses(bio, layer___0->numpasses);
#line 212
      passno = cblk___1->numpasses;
      }
      {
#line 212
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 212
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 212
          goto while_break___4;
        }
#line 213
        pass = cblk___1->passes + passno;
#line 214
        nump ++;
#line 215
        len += pass->len;
#line 216
        if (pass->term) {
          _L: /* CIL Label */ 
          {
#line 217
          __cil_tmp38 = int_floorlog2(nump);
          }
          {
#line 217
          __cil_tmp37 = int_floorlog2(len);
#line 217
          __cil_tmp39 = int_max(increment, (__cil_tmp37 + 1) - (cblk___1->numlenbits + __cil_tmp38));
#line 217
          increment = __cil_tmp39;
#line 218
          len = 0;
#line 219
          nump = 0;
          }
        } else
#line 216
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
#line 216
          goto _L;
        }
#line 212
        passno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 222
      t2_putcommacode(bio, increment);
#line 225
      cblk___1->numlenbits += increment;
#line 228
      passno = cblk___1->numpasses;
      }
      {
#line 228
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 228
        if (! (passno < cblk___1->numpasses + layer___0->numpasses)) {
#line 228
          goto while_break___5;
        }
#line 229
        pass___0 = cblk___1->passes + passno;
#line 230
        nump ++;
#line 231
        len += pass___0->len;
#line 232
        if (pass___0->term) {
          {
          {
#line 233
          __cil_tmp43 = int_floorlog2(nump);
          }
          {
#line 233
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
          }
#line 234
          len = 0;
#line 235
          nump = 0;
          }
        } else
#line 232
        if (passno == (cblk___1->numpasses + layer___0->numpasses) - 1) {
          {
          {
#line 233
          __cil_tmp43 = int_floorlog2(nump);
          }
          {
#line 233
          bio_write(bio, len, cblk___1->numlenbits + __cil_tmp43);
          }
#line 234
          len = 0;
#line 235
          nump = 0;
          }
        }
#line 228
        passno ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 187
      cblkno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 177
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 241
  __cil_tmp47 = bio_flush(bio);
  }
#line 241
  if (__cil_tmp47) {
    {
#line 242
    bio_destroy(bio);
    }
#line 243
    return (- 999);
  }
  {
#line 246
  __cil_tmp48 = bio_numbytes(bio);
  }
  {
#line 246
  c += __cil_tmp48;
#line 247
  bio_destroy(bio);
  }
#line 250
  if (tcp->csty & 4) {
#line 251
    *(c + 0) = (unsigned char )255;
#line 252
    *(c + 1) = (unsigned char )146;
#line 253
    c += 2;
  }
#line 260
  if (cstr_info) {
#line 260
    if (cstr_info->index_write) {
#line 261
      info_PK = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 262
      info_PK->end_ph_pos = (int )(c - dest);
    }
  }
#line 268
  bandno = 0;
  {
#line 268
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 268
    if (! (bandno < res->numbands)) {
#line 268
      goto while_break___6;
    }
#line 269
    band___1 = & res->bands[bandno];
#line 270
    prc___1 = band___1->precincts + precno;
#line 271
    cblkno = 0;
    {
#line 271
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 271
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 271
        goto while_break___7;
      }
#line 272
      cblk___2 = prc___1->cblks.enc + cblkno;
#line 273
      layer___1 = cblk___2->layers + layno;
#line 274
      if (! layer___1->numpasses) {
#line 275
        goto while_continue___7;
      }
#line 277
      if (c + layer___1->len > dest + length) {
#line 278
        return (- 999);
      }
      {
#line 281
      memcpy(c, layer___1->data, (unsigned long )layer___1->len);
#line 282
      cblk___2->numpasses += layer___1->numpasses;
#line 283
      c += layer___1->len;
      }
#line 285
      if (cstr_info) {
#line 285
        if (cstr_info->index_write) {
#line 286
          info_PK___0 = (cstr_info->tile + tileno)->packet + cstr_info->packno;
#line 287
          info_PK___0->disto += layer___1->disto;
#line 288
          if (cstr_info->D_max < info_PK___0->disto) {
#line 289
            cstr_info->D_max = info_PK___0->disto;
          }
        }
      }
#line 271
      cblkno ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 268
    bandno ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 296
  return ((int )(c - dest));
}
}
#line 299 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
static opj_bool t2_init_seg(opj_tcd_cblk_dec_t *cblk , int index___0 , int cblksty ,
                            int first ) 
{ 
  opj_tcd_seg_t *seg ;
  opj_tcd_seg_t *segs ;
  void *__cil_tmp7 ;
  int tmp ;

  {
  {
#line 302
  __cil_tmp7 = realloc(cblk->segs, (unsigned long )(index___0 + 1) * sizeof(opj_tcd_seg_t ));
#line 302
  segs = (opj_tcd_seg_t *)__cil_tmp7;
  }
#line 304
  if (segs == (void *)0) {
#line 306
    return (0);
  }
#line 308
  cblk->segs = segs;
#line 310
  seg = cblk->segs + index___0;
#line 311
  seg->data = (unsigned char **)((void *)0);
#line 312
  seg->dataindex = 0;
#line 313
  seg->numpasses = 0;
#line 314
  seg->len = 0;
#line 315
  if (cblksty & 4) {
#line 316
    seg->maxpasses = 1;
  } else
#line 318
  if (cblksty & 1) {
#line 319
    if (first) {
#line 320
      seg->maxpasses = 10;
    } else {
#line 322
      if ((seg - 1)->maxpasses == 1 || (seg - 1)->maxpasses == 10) {
#line 322
        tmp = 2;
      } else {
#line 322
        tmp = 1;
      }
#line 322
      seg->maxpasses = tmp;
    }
  } else {
#line 325
    seg->maxpasses = 109;
  }
#line 328
  return (1);
}
}
#line 331 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
static int t2_decode_packet(opj_t2_t *t2 , unsigned char *src , int len , opj_tcd_tile_t *tile ,
                            opj_tcp_t *tcp , opj_pi_iterator_t *pi , opj_packet_info_t *pack_info ) 
{ 
  int bandno ;
  int cblkno ;
  unsigned char *c ;
  opj_cp_t *cp ;
  int compno ;
  int resno ;
  int precno ;
  int layno ;
  opj_tcd_resolution_t *res ;
  unsigned char *hd ;
  int present ;
  opj_bio_t *bio ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_dec_t *cblk ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  opj_bio_t *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  opj_tcd_band_t *band___0 ;
  opj_tcd_precinct_t *prc___0 ;
  int included ;
  int increment ;
  int n ;
  int segno ;
  opj_tcd_cblk_dec_t *cblk___0 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int i ;
  int numimsbs ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  opj_bool __cil_tmp43 ;
  opj_bool __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  opj_bool __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  opj_tcd_band_t *band___1 ;
  opj_tcd_precinct_t *prc___1 ;
  opj_tcd_cblk_dec_t *cblk___1 ;
  opj_tcd_seg_t *seg ;
  int __cil_tmp57 ;
  opj_tcd_seg_t *__cil_tmp58 ;
  int __cil_tmp59 ;
  void *__cil_tmp60 ;
  opj_tcd_seg_t *__cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;

  {
#line 334
  c = src;
#line 336
  cp = t2->cp;
#line 338
  compno = pi->compno;
#line 339
  resno = pi->resno;
#line 340
  precno = pi->precno;
#line 341
  layno = pi->layno;
#line 343
  res = (tile->comps + compno)->resolutions + resno;
#line 345
  hd = (unsigned char *)((void *)0);
#line 348
  bio = (opj_bio_t *)((void *)0);
#line 350
  if (layno == 0) {
#line 351
    bandno = 0;
    {
#line 351
    while (1) {
      while_continue: /* CIL Label */ ;
#line 351
      if (! (bandno < res->numbands)) {
#line 351
        goto while_break;
      }
#line 352
      band = & res->bands[bandno];
#line 353
      prc = band->precincts + precno;
#line 355
      if (band->x1 - band->x0 == 0) {
#line 355
        goto while_continue;
      } else
#line 355
      if (band->y1 - band->y0 == 0) {
#line 355
        goto while_continue;
      }
      {
#line 357
      tgt_reset(prc->incltree);
#line 358
      tgt_reset(prc->imsbtree);
#line 359
      cblkno = 0;
      }
      {
#line 359
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 359
        if (! (cblkno < prc->cw * prc->ch)) {
#line 359
          goto while_break___0;
        }
#line 360
        cblk = prc->cblks.dec + cblkno;
#line 361
        cblk->numsegs = 0;
#line 359
        cblkno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 351
      bandno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 368
  if (tcp->csty & 2) {
#line 369
    if ((int )*c != 255) {
      {
      {
#line 370
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n");
      }
      }
    } else
#line 369
    if ((int )*(c + 1) != 145) {
      {
      {
#line 370
      opj_event_msg(t2->cinfo, 2, "Expected SOP marker\n");
      }
      }
    } else {
#line 372
      c += 6;
    }
  }
  {
#line 385
  bio = bio_create();
  }
#line 387
  if (cp->ppm == 1) {
    {
#line 388
    hd = cp->ppm_data;
#line 389
    bio_init_dec(bio, hd, cp->ppm_len);
    }
  } else
#line 390
  if (tcp->ppt == 1) {
    {
#line 391
    hd = tcp->ppt_data;
#line 392
    bio_init_dec(bio, hd, tcp->ppt_len);
    }
  } else {
    {
#line 394
    hd = c;
#line 395
    bio_init_dec(bio, hd, (int )((src + len) - hd));
    }
  }
  {
#line 398
  present = bio_read(bio, 1);
  }
#line 400
  if (! present) {
    {
#line 401
    bio_inalign(bio);
#line 402
    __cil_tmp27 = bio_numbytes(bio);
    }
    {
#line 402
    hd += __cil_tmp27;
#line 403
    bio_destroy(bio);
    }
#line 407
    if (tcp->csty & 4) {
#line 408
      if ((int )*hd != 255) {
        {
        {
#line 409
        printf("Error : expected EPH marker\n");
        }
        }
      } else
#line 408
      if ((int )*(hd + 1) != 146) {
        {
        {
#line 409
        printf("Error : expected EPH marker\n");
        }
        }
      } else {
#line 411
        hd += 2;
      }
    }
#line 418
    if (pack_info) {
#line 419
      pack_info->end_ph_pos = (int )(c - src);
    }
#line 423
    if (cp->ppm == 1) {
#line 424
      cp->ppm_len += cp->ppm_data - hd;
#line 425
      cp->ppm_data = hd;
#line 426
      return ((int )(c - src));
    }
#line 428
    if (tcp->ppt == 1) {
#line 429
      tcp->ppt_len += tcp->ppt_data - hd;
#line 430
      tcp->ppt_data = hd;
#line 431
      return ((int )(c - src));
    }
#line 434
    return ((int )(hd - src));
  }
#line 437
  bandno = 0;
  {
#line 437
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 437
    if (! (bandno < res->numbands)) {
#line 437
      goto while_break___1;
    }
#line 438
    band___0 = & res->bands[bandno];
#line 439
    prc___0 = band___0->precincts + precno;
#line 441
    if (band___0->x1 - band___0->x0 == 0) {
#line 441
      goto while_continue___1;
    } else
#line 441
    if (band___0->y1 - band___0->y0 == 0) {
#line 441
      goto while_continue___1;
    }
#line 443
    cblkno = 0;
    {
#line 443
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 443
      if (! (cblkno < prc___0->cw * prc___0->ch)) {
#line 443
        goto while_break___2;
      }
#line 445
      cblk___0 = prc___0->cblks.dec + cblkno;
#line 447
      if (! cblk___0->numsegs) {
        {
#line 448
        included = tgt_decode(bio, prc___0->incltree, cblkno, layno + 1);
        }
      } else {
        {
#line 451
        included = bio_read(bio, 1);
        }
      }
#line 454
      if (! included) {
#line 455
        cblk___0->numnewpasses = 0;
#line 456
        goto while_continue___2;
      }
#line 459
      if (! cblk___0->numsegs) {
#line 461
        i = 0;
        {
#line 461
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 461
          if (! (! __cil_tmp39)) {
#line 461
            goto while_break___3;
          }

#line 461
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 464
        numimsbs = i - 1;
#line 465
        cblk___0->numbps = band___0->numbps - numimsbs;
#line 466
        cblk___0->numlenbits = 3;
      }
      {
#line 469
      cblk___0->numnewpasses = t2_getnumpasses(bio);
#line 470
      increment = t2_getcommacode(bio);
#line 472
      cblk___0->numlenbits += increment;
#line 473
      segno = 0;
      }
#line 474
      if (! cblk___0->numsegs) {
        {
#line 475
        __cil_tmp43 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                  1);
        }
#line 475
        if (! __cil_tmp43) {
          {
#line 477
          opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 478
          bio_destroy(bio);
          }
#line 479
          return (- 999);
        }
      } else {
#line 482
        segno = cblk___0->numsegs - 1;
#line 483
        if ((cblk___0->segs + segno)->numpasses == (cblk___0->segs + segno)->maxpasses) {
          {
#line 484
          segno ++;
#line 485
          __cil_tmp44 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                    0);
          }
#line 485
          if (! __cil_tmp44) {
            {
#line 487
            opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 488
            bio_destroy(bio);
            }
#line 489
            return (- 999);
          }
        }
      }
#line 493
      n = cblk___0->numnewpasses;
      {
#line 495
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 496
        (cblk___0->segs + segno)->numnewpasses = int_min((cblk___0->segs + segno)->maxpasses - (cblk___0->segs + segno)->numpasses,
                                                         n);
#line 497
        __cil_tmp46 = int_floorlog2((cblk___0->segs + segno)->numnewpasses);
#line 497
        __cil_tmp47 = bio_read(bio, cblk___0->numlenbits + __cil_tmp46);
#line 497
        (cblk___0->segs + segno)->newlen = __cil_tmp47;
#line 498
        n -= (cblk___0->segs + segno)->numnewpasses;
        }
#line 499
        if (n > 0) {
          {
#line 500
          segno ++;
#line 501
          __cil_tmp48 = t2_init_seg(cblk___0, segno, (tcp->tccps + compno)->cblksty,
                                    0);
          }
#line 501
          if (! __cil_tmp48) {
            {
#line 503
            opj_event_msg(t2->cinfo, 1, "Out of memory\n");
#line 504
            bio_destroy(bio);
            }
#line 505
            return (- 999);
          }
        }
#line 495
        if (! (n > 0)) {
#line 495
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 443
      cblkno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 437
    bandno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 512
  __cil_tmp51 = bio_inalign(bio);
  }
#line 512
  if (__cil_tmp51) {
    {
#line 513
    bio_destroy(bio);
    }
#line 514
    return (- 999);
  }
  {
#line 517
  __cil_tmp52 = bio_numbytes(bio);
  }
  {
#line 517
  hd += __cil_tmp52;
#line 518
  bio_destroy(bio);
  }
#line 521
  if (tcp->csty & 4) {
#line 522
    if ((int )*hd != 255) {
      {
      {
#line 523
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
      }
#line 524
      return (- 999);
    } else
#line 522
    if ((int )*(hd + 1) != 146) {
      {
      {
#line 523
      opj_event_msg(t2->cinfo, 1, "Expected EPH marker\n");
      }
      }
#line 524
      return (- 999);
    } else {
#line 526
      hd += 2;
    }
  }
#line 533
  if (pack_info) {
#line 534
    pack_info->end_ph_pos = (int )(hd - src);
  }
#line 538
  if (cp->ppm == 1) {
#line 539
    cp->ppm_len += cp->ppm_data - hd;
#line 540
    cp->ppm_data = hd;
  } else
#line 541
  if (tcp->ppt == 1) {
#line 542
    tcp->ppt_len += tcp->ppt_data - hd;
#line 543
    tcp->ppt_data = hd;
  } else {
#line 545
    c = hd;
  }
#line 548
  bandno = 0;
  {
#line 548
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 548
    if (! (bandno < res->numbands)) {
#line 548
      goto while_break___5;
    }
#line 549
    band___1 = & res->bands[bandno];
#line 550
    prc___1 = band___1->precincts + precno;
#line 552
    if (band___1->x1 - band___1->x0 == 0) {
#line 552
      goto while_continue___5;
    } else
#line 552
    if (band___1->y1 - band___1->y0 == 0) {
#line 552
      goto while_continue___5;
    }
#line 554
    cblkno = 0;
    {
#line 554
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 554
      if (! (cblkno < prc___1->cw * prc___1->ch)) {
#line 554
        goto while_break___6;
      }
#line 555
      cblk___1 = prc___1->cblks.dec + cblkno;
#line 556
      seg = (opj_tcd_seg_t *)((void *)0);
#line 557
      if (! cblk___1->numnewpasses) {
#line 558
        goto while_continue___6;
      }
#line 559
      if (! cblk___1->numsegs) {
#line 560
        seg = cblk___1->segs + 0;
#line 561
        (cblk___1->numsegs) ++;
#line 562
        cblk___1->len = 0;
      } else {
#line 564
        seg = cblk___1->segs + (cblk___1->numsegs - 1);
#line 565
        if (seg->numpasses == seg->maxpasses) {
#line 566
          seg ++;
#line 567
          (cblk___1->numsegs) ++;
        }
      }
      {
#line 571
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 572
        if (c + seg->newlen > src + len) {
#line 573
          return (- 999);
        }
        {
#line 596
        __cil_tmp60 = realloc(cblk___1->data, (unsigned long )(cblk___1->len + seg->newlen) * sizeof(unsigned char ));
#line 596
        cblk___1->data = (unsigned char *)__cil_tmp60;
#line 597
        memcpy(cblk___1->data + cblk___1->len, c, (unsigned long )seg->newlen);
        }
#line 598
        if (seg->numpasses == 0) {
#line 599
          seg->data = & cblk___1->data;
#line 600
          seg->dataindex = cblk___1->len;
        }
#line 602
        c += seg->newlen;
#line 603
        cblk___1->len += seg->newlen;
#line 604
        seg->len += seg->newlen;
#line 605
        seg->numpasses += seg->numnewpasses;
#line 606
        cblk___1->numnewpasses -= seg->numnewpasses;
#line 607
        if (cblk___1->numnewpasses > 0) {
#line 608
          seg ++;
#line 609
          (cblk___1->numsegs) ++;
        }
#line 571
        if (! (cblk___1->numnewpasses > 0)) {
#line 571
          goto while_break___7;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 554
      cblkno ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 548
    bandno ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 615
  return ((int )(c - src));
}
}
#line 620 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
int t2_encode_packets(opj_t2_t *t2 , int tileno , opj_tcd_tile_t *tile , int maxlayers ,
                      unsigned char *dest , int len , opj_codestream_info_t *cstr_info ,
                      int tpnum , int tppos , int pino , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  unsigned char *c ;
  int e ;
  int compno ;
  opj_pi_iterator_t *pi ;
  int poc ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int pocno ;
  int tmp ;
  int maxcomp ;
  int tmp___0 ;
  opj_pi_iterator_t *__cil_tmp25 ;
  int comp_len ;
  int tpnum___2 ;
  opj_bool __cil_tmp28 ;
  opj_bool __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  opj_bool __cil_tmp33 ;
  int __cil_tmp34 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int tmp___1 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
#line 621
  c = dest;
#line 622
  e = 0;
#line 624
  pi = (opj_pi_iterator_t *)((void *)0);
#line 626
  image = t2->image;
#line 627
  cp = t2->cp;
#line 628
  tcp = cp->tcps + tileno;
#line 629
  if ((unsigned int )cp->cinema == 3U) {
#line 629
    tmp = 2;
  } else {
#line 629
    tmp = 1;
  }
#line 629
  pocno = tmp;
#line 630
  if (cp->max_comp_size > 0) {
#line 630
    tmp___0 = image->numcomps;
  } else {
#line 630
    tmp___0 = 1;
  }
  {
#line 630
  maxcomp = tmp___0;
#line 632
  pi = pi_initialise_encode(image, cp, tileno, t2_mode);
  }
#line 633
  if (! pi) {
#line 635
    return (- 999);
  }
#line 638
  if ((unsigned int )t2_mode == 0U) {
#line 639
    compno = 0;
    {
#line 639
    while (1) {
      while_continue: /* CIL Label */ ;
#line 639
      if (! (compno < maxcomp)) {
#line 639
        goto while_break;
      }
#line 640
      poc = 0;
      {
#line 640
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 640
        if (! (poc < pocno)) {
#line 640
          goto while_break___0;
        }
        {
#line 641
        comp_len = 0;
#line 642
        tpnum___2 = compno;
#line 643
        __cil_tmp28 = pi_create_encode(pi, cp, tileno, poc, tpnum___2, tppos, t2_mode,
                                       cur_totnum_tp);
        }
#line 643
        if (__cil_tmp28) {
          {
#line 644
          opj_event_msg(t2->cinfo, 1, "Error initializing Packet Iterator\nC\262U");
#line 645
          pi_destroy(pi, cp, tileno);
          }
#line 646
          return (- 999);
        }
        {
#line 648
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 648
          __cil_tmp29 = pi_next(pi + poc);
          }
#line 648
          if (! __cil_tmp29) {
#line 648
            goto while_break___1;
          }
#line 649
          if ((pi + poc)->layno < maxlayers) {
            {
#line 650
            e = t2_encode_packet(tile, cp->tcps + tileno, pi + poc, c, (int )((dest + len) - c),
                                 cstr_info, tileno);
#line 651
            comp_len += e;
            }
#line 652
            if (e == -999) {
#line 653
              goto while_break___1;
            } else {
#line 655
              c += e;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 659
        if (e == -999) {
#line 659
          goto while_break___0;
        }
#line 660
        if (cp->max_comp_size) {
#line 661
          if (comp_len > cp->max_comp_size) {
#line 662
            e = - 999;
#line 663
            goto while_break___0;
          }
        }
#line 640
        poc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 667
      if (e == -999) {
#line 667
        goto while_break;
      }
#line 639
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 670
    pi_create_encode(pi, cp, tileno, pino, tpnum, tppos, t2_mode, cur_totnum_tp);
    }
    {
#line 671
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 671
      __cil_tmp33 = pi_next(pi + pino);
      }
#line 671
      if (! __cil_tmp33) {
#line 671
        goto while_break___2;
      }
#line 672
      if ((pi + pino)->layno < maxlayers) {
        {
#line 673
        e = t2_encode_packet(tile, cp->tcps + tileno, pi + pino, c, (int )((dest + len) - c),
                             cstr_info, tileno);
        }
#line 674
        if (e == -999) {
#line 675
          goto while_break___2;
        } else {
#line 677
          c += e;
        }
#line 680
        if (cstr_info) {
#line 681
          if (cstr_info->index_write) {
#line 682
            info_TL = cstr_info->tile + tileno;
#line 683
            info_PK = info_TL->packet + cstr_info->packno;
#line 684
            if (! cstr_info->packno) {
#line 685
              info_PK->start_pos = info_TL->end_header + 1;
            } else {
#line 687
              if ((int )cp->tp_on | tcp->POC && info_PK->start_pos) {
#line 687
                tmp___1 = info_PK->start_pos;
              } else {
#line 687
                tmp___1 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
              }
#line 687
              info_PK->start_pos = tmp___1;
            }
#line 689
            info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 690
            info_PK->end_ph_pos += info_PK->start_pos - 1;
          }
#line 694
          (cstr_info->packno) ++;
        }
#line 697
        (tile->packno) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 702
  pi_destroy(pi, cp, tileno);
  }
#line 704
  if (e == -999) {
#line 705
    return (e);
  }
#line 708
  return ((int )(c - dest));
}
}
#line 711 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
int t2_decode_packets(opj_t2_t *t2 , unsigned char *src , int len , int tileno , opj_tcd_tile_t *tile ,
                      opj_codestream_info_t *cstr_info ) 
{ 
  unsigned char *c ;
  opj_pi_iterator_t *pi ;
  int pino ;
  int e ;
  int n ;
  int curtp ;
  int tp_start_packno ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  opj_pi_iterator_t *__cil_tmp16 ;
  opj_bool __cil_tmp17 ;
  opj_packet_info_t *pack_info ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int __cil_tmp22 ;
  opj_tile_info_t *info_TL ;
  opj_packet_info_t *info_PK ;
  int __cil_tmp25 ;
  int tmp___0 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
#line 712
  c = src;
#line 714
  e = 0;
#line 715
  n = 0;
  {
#line 715
  curtp = 0;
#line 718
  image = t2->image;
#line 719
  cp = t2->cp;
#line 722
  pi = pi_create_decode(image, cp, tileno);
  }
#line 723
  if (! pi) {
#line 725
    return (- 999);
  }
#line 728
  tp_start_packno = 0;
#line 730
  pino = 0;
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 730
    if (! (pino <= (cp->tcps + tileno)->numpocs)) {
#line 730
      goto while_break;
    }
    {
#line 731
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 731
      __cil_tmp17 = pi_next(pi + pino);
      }
#line 731
      if (! __cil_tmp17) {
#line 731
        goto while_break___0;
      }
#line 732
      if (cp->layer == 0) {
        _L: /* CIL Label */ 
#line 734
        if (cstr_info) {
#line 735
          pack_info = (cstr_info->tile + tileno)->packet + cstr_info->packno;
        } else {
#line 737
          pack_info = (opj_packet_info_t *)((void *)0);
        }
        {
#line 738
        e = t2_decode_packet(t2, c, (int )((src + len) - c), tile, cp->tcps + tileno,
                             pi + pino, pack_info);
        }
      } else
#line 732
      if (cp->layer >= (pi + pino)->layno + 1) {
#line 732
        goto _L;
      } else {
#line 740
        e = 0;
      }
#line 742
      if (e == -999) {
        {
#line 744
        pi_destroy(pi, cp, tileno);
        }
#line 745
        return (- 999);
      }
#line 748
      if (e > 0) {
        {
#line 748
        __cil_tmp20 = int_max((pi + pino)->resno, (image->comps + (pi + pino)->compno)->resno_decoded);
#line 748
        tmp = __cil_tmp20;
        }
      } else {
#line 748
        tmp = (image->comps + (pi + pino)->compno)->resno_decoded;
      }
#line 748
      (image->comps + (pi + pino)->compno)->resno_decoded = tmp;
#line 752
      n ++;
#line 755
      if (cstr_info) {
#line 756
        info_TL = cstr_info->tile + tileno;
#line 757
        info_PK = info_TL->packet + cstr_info->packno;
#line 758
        if (! cstr_info->packno) {
#line 759
          info_PK->start_pos = info_TL->end_header + 1;
        } else
#line 760
        if ((info_TL->packet + (cstr_info->packno - 1))->end_pos >= (int )((cstr_info->tile + tileno)->tp + curtp)->tp_end_pos) {
#line 761
          (info_TL->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
#line 762
          (info_TL->tp + curtp)->tp_start_pack = tp_start_packno;
#line 763
          tp_start_packno = cstr_info->packno;
#line 764
          curtp ++;
#line 765
          info_PK->start_pos = ((cstr_info->tile + tileno)->tp + curtp)->tp_end_header + 1;
        } else {
#line 767
          if ((int )cp->tp_on && info_PK->start_pos) {
#line 767
            tmp___0 = info_PK->start_pos;
          } else {
#line 767
            tmp___0 = (info_TL->packet + (cstr_info->packno - 1))->end_pos + 1;
          }
#line 767
          info_PK->start_pos = tmp___0;
        }
#line 769
        info_PK->end_pos = (info_PK->start_pos + e) - 1;
#line 770
        info_PK->end_ph_pos += info_PK->start_pos - 1;
#line 772
        (cstr_info->packno) ++;
      }
#line 776
      if (e == -999) {
#line 777
        goto while_break___0;
      } else {
#line 779
        c += e;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 730
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 784
  if (cstr_info) {
#line 785
    ((cstr_info->tile + tileno)->tp + curtp)->tp_numpacks = cstr_info->packno - tp_start_packno;
#line 786
    ((cstr_info->tile + tileno)->tp + curtp)->tp_start_pack = tp_start_packno;
  }
  {
#line 791
  pi_destroy(pi, cp, tileno);
  }
#line 793
  if (e == -999) {
#line 794
    return (e);
  }
#line 797
  return ((int )(c - src));
}
}
#line 802 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
opj_t2_t *t2_create(opj_common_ptr cinfo , opj_image_t *image , opj_cp_t *cp ) 
{ 
  opj_t2_t *t2 ;
  void *__cil_tmp5 ;

  {
  {
#line 804
  __cil_tmp5 = malloc(sizeof(opj_t2_t ));
#line 804
  t2 = (opj_t2_t *)__cil_tmp5;
  }
#line 805
  if (! t2) {
#line 805
    return ((opj_t2_t *)((void *)0));
  }
#line 806
  t2->cinfo = cinfo;
#line 807
  t2->image = image;
#line 808
  t2->cp = cp;
#line 810
  return (t2);
}
}
#line 813 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t2.c"
void t2_destroy(opj_t2_t *t2 ) 
{ 


  {
#line 814
  if (t2) {
    {
#line 815
    free(t2);
    }
  }
  return;
}
}
#line 3 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1_luts.h"
static char lut_ctxno_zc[1024]  = 
#line 3 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1_luts.h"
  {      (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )1,      (char )1,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )1,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )3,      (char )3,      (char )3,      (char )3, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )5,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )6,      (char )6,      (char )6,      (char )6, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )7,      (char )7,      (char )7,      (char )7, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )8,      (char )8,      (char )8,      (char )8, 
        (char )0,      (char )3,      (char )3,      (char )6, 
        (char )3,      (char )6,      (char )6,      (char )8, 
        (char )3,      (char )6,      (char )6,      (char )8, 
        (char )6,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )1,      (char )4,      (char )4,      (char )7, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )4,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8, 
        (char )2,      (char )5,      (char )5,      (char )7, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )5,      (char )7,      (char )7,      (char )8, 
        (char )7,      (char )8,      (char )8,      (char )8};
#line 38 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1_luts.h"
static char lut_ctxno_sc[256]  = 
#line 38
  {      (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )13,      (char )13,      (char )13,      (char )13, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )13,      (char )12,      (char )13,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )13,      (char )13,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )13,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )11,      (char )12,      (char )11,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )11,      (char )11,      (char )11,      (char )11, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )11,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )11,      (char )11,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )11,      (char )11,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )11,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )11,      (char )11,      (char )11,      (char )11, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )11,      (char )12,      (char )11,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )9,      (char )11,      (char )12, 
        (char )12,      (char )11,      (char )9,      (char )10, 
        (char )13,      (char )12,      (char )10,      (char )9, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )10,      (char )11,      (char )11, 
        (char )12,      (char )13,      (char )9,      (char )10, 
        (char )13,      (char )13,      (char )10,      (char )10, 
        (char )9,      (char )10,      (char )12,      (char )11, 
        (char )10,      (char )9,      (char )13,      (char )12, 
        (char )12,      (char )11,      (char )12,      (char )11, 
        (char )13,      (char )12,      (char )13,      (char )12, 
        (char )9,      (char )10,      (char )12,      (char )13, 
        (char )10,      (char )10,      (char )13,      (char )13, 
        (char )12,      (char )13,      (char )12,      (char )13, 
        (char )13,      (char )13,      (char )13,      (char )13};
#line 57 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1_luts.h"
static char lut_spb[256]  = 
#line 57
  {      (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )0, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )1, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )0,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )1,      (char )0, 
        (char )0,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )0, 
        (char )1,      (char )1,      (char )0,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )0,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )0,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1, 
        (char )1,      (char )1,      (char )1,      (char )1};
#line 68 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig[128]  = 
#line 68
  {      (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )384,      (short )768,      (short )1152, 
        (short )1536,      (short )1920,      (short )2304,      (short )2688, 
        (short )3072,      (short )3456,      (short )3840,      (short )4224, 
        (short )4608,      (short )4992,      (short )5376,      (short )5760, 
        (short )6144,      (short )6528,      (short )6912,      (short )7296, 
        (short )7680,      (short )8064,      (short )8448,      (short )8832, 
        (short )9216,      (short )9600,      (short )9984,      (short )10368, 
        (short )10752,      (short )11136,      (short )11520,      (short )11904, 
        (short )12288,      (short )12672,      (short )13056,      (short )13440, 
        (short )13824,      (short )14208,      (short )14592,      (short )14976, 
        (short )15360,      (short )15744,      (short )16128,      (short )16512, 
        (short )16896,      (short )17280,      (short )17664,      (short )18048, 
        (short )18432,      (short )18816,      (short )19200,      (short )19584, 
        (short )19968,      (short )20352,      (short )20736,      (short )21120, 
        (short )21504,      (short )21888,      (short )22272,      (short )22656, 
        (short )23040,      (short )23424,      (short )23808,      (short )24192, 
        (short )24576,      (short )24960,      (short )25344,      (short )25728, 
        (short )26112,      (short )26496,      (short )26880,      (short )27264, 
        (short )27648,      (short )28032,      (short )28416,      (short )28800, 
        (short )29184,      (short )29568,      (short )29952,      (short )30336};
#line 87 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1_luts.h"
static short lut_nmsedec_sig0[128]  = 
#line 87
  {      (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )128,      (short )128, 
        (short )128,      (short )128,      (short )256,      (short )256, 
        (short )256,      (short )384,      (short )384,      (short )512, 
        (short )512,      (short )640,      (short )640,      (short )768, 
        (short )768,      (short )896,      (short )1024,      (short )1024, 
        (short )1152,      (short )1280,      (short )1408,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2944,      (short )3072, 
        (short )3200,      (short )3328,      (short )3584,      (short )3712, 
        (short )3840,      (short )4096,      (short )4224,      (short )4480, 
        (short )4608,      (short )4864,      (short )4992,      (short )5248, 
        (short )5376,      (short )5632,      (short )5888,      (short )6016, 
        (short )6272,      (short )6528,      (short )6784,      (short )6912, 
        (short )7168,      (short )7424,      (short )7680,      (short )7936, 
        (short )8192,      (short )8448,      (short )8704,      (short )8960, 
        (short )9216,      (short )9472,      (short )9856,      (short )10112, 
        (short )10368,      (short )10624,      (short )11008,      (short )11264, 
        (short )11520,      (short )11904,      (short )12160,      (short )12544, 
        (short )12800,      (short )13184,      (short )13440,      (short )13824, 
        (short )14080,      (short )14464,      (short )14848,      (short )15104, 
        (short )15488,      (short )15872,      (short )16256,      (short )16512, 
        (short )16896,      (short )17280,      (short )17664,      (short )18048, 
        (short )18432,      (short )18816,      (short )19200,      (short )19584, 
        (short )19968,      (short )20352,      (short )20864,      (short )21248, 
        (short )21632,      (short )22016,      (short )22528,      (short )22912, 
        (short )23296,      (short )23808,      (short )24192,      (short )24704, 
        (short )25088,      (short )25600,      (short )25984,      (short )26496, 
        (short )26880,      (short )27392,      (short )27904,      (short )28288, 
        (short )28800,      (short )29312,      (short )29824,      (short )30208, 
        (short )30720,      (short )31232,      (short )31744,      (short )32256};
#line 106 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref[128]  = 
#line 106
  {      (short )6144,      (short )6016,      (short )5888,      (short )5760, 
        (short )5632,      (short )5504,      (short )5376,      (short )5248, 
        (short )5120,      (short )4992,      (short )4864,      (short )4736, 
        (short )4608,      (short )4480,      (short )4352,      (short )4224, 
        (short )4096,      (short )3968,      (short )3840,      (short )3712, 
        (short )3584,      (short )3456,      (short )3328,      (short )3200, 
        (short )3072,      (short )2944,      (short )2816,      (short )2688, 
        (short )2560,      (short )2432,      (short )2304,      (short )2176, 
        (short )2048,      (short )1920,      (short )1792,      (short )1664, 
        (short )1536,      (short )1408,      (short )1280,      (short )1152, 
        (short )1024,      (short )896,      (short )768,      (short )640, 
        (short )512,      (short )384,      (short )256,      (short )128, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )128,      (short )256,      (short )384, 
        (short )512,      (short )640,      (short )768,      (short )896, 
        (short )1024,      (short )1152,      (short )1280,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2816,      (short )2944, 
        (short )3072,      (short )3200,      (short )3328,      (short )3456, 
        (short )3584,      (short )3712,      (short )3840,      (short )3968, 
        (short )4096,      (short )4224,      (short )4352,      (short )4480, 
        (short )4608,      (short )4736,      (short )4864,      (short )4992, 
        (short )5120,      (short )5248,      (short )5376,      (short )5504, 
        (short )5632,      (short )5760,      (short )5888,      (short )6016};
#line 125 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1_luts.h"
static short lut_nmsedec_ref0[128]  = 
#line 125
  {      (short )8192,      (short )7936,      (short )7680,      (short )7424, 
        (short )7168,      (short )6912,      (short )6784,      (short )6528, 
        (short )6272,      (short )6016,      (short )5888,      (short )5632, 
        (short )5376,      (short )5248,      (short )4992,      (short )4864, 
        (short )4608,      (short )4480,      (short )4224,      (short )4096, 
        (short )3840,      (short )3712,      (short )3584,      (short )3328, 
        (short )3200,      (short )3072,      (short )2944,      (short )2688, 
        (short )2560,      (short )2432,      (short )2304,      (short )2176, 
        (short )2048,      (short )1920,      (short )1792,      (short )1664, 
        (short )1536,      (short )1408,      (short )1408,      (short )1280, 
        (short )1152,      (short )1024,      (short )1024,      (short )896, 
        (short )768,      (short )768,      (short )640,      (short )640, 
        (short )512,      (short )512,      (short )384,      (short )384, 
        (short )256,      (short )256,      (short )256,      (short )128, 
        (short )128,      (short )128,      (short )128,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )0,      (short )0, 
        (short )0,      (short )0,      (short )128,      (short )128, 
        (short )128,      (short )128,      (short )256,      (short )256, 
        (short )256,      (short )384,      (short )384,      (short )512, 
        (short )512,      (short )640,      (short )640,      (short )768, 
        (short )768,      (short )896,      (short )1024,      (short )1024, 
        (short )1152,      (short )1280,      (short )1408,      (short )1408, 
        (short )1536,      (short )1664,      (short )1792,      (short )1920, 
        (short )2048,      (short )2176,      (short )2304,      (short )2432, 
        (short )2560,      (short )2688,      (short )2944,      (short )3072, 
        (short )3200,      (short )3328,      (short )3584,      (short )3712, 
        (short )3840,      (short )4096,      (short )4224,      (short )4480, 
        (short )4608,      (short )4864,      (short )4992,      (short )5248, 
        (short )5376,      (short )5632,      (short )5888,      (short )6016, 
        (short )6272,      (short )6528,      (short )6784,      (short )6912, 
        (short )7168,      (short )7424,      (short )7680,      (short )7936};
#line 42 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) ;
#line 43
static char t1_getctxno_sc(int f ) ;
#line 44
static int t1_getctxno_mag(int f ) ;
#line 45
static char t1_getspb(int f ) ;
#line 46
static short t1_getnmsedec_sig(int x , int bitpos ) ;
#line 47
static short t1_getnmsedec_ref(int x , int bitpos ) ;
#line 48
static void t1_updateflags(flag_t *flagsp , int s , int stride ) ;
#line 52
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) ;
#line 65
__inline static void t1_dec_sigpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf , int vsc ) ;
#line 72
__inline static void t1_dec_sigpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf ) ;
#line 78
__inline static void t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int orient , int oneplushalf , int vsc ) ;
#line 88
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) ;
#line 98
static void t1_dec_sigpass_raw(opj_t1_t *t1 , int bpno , int orient , int cblksty ) ;
#line 103
static void t1_dec_sigpass_mqc(opj_t1_t *t1 , int bpno , int orient ) ;
#line 107
static void t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , int bpno , int orient ) ;
#line 114
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) ;
#line 126
__inline static void t1_dec_refpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf , int vsc ) ;
#line 133
__inline static void t1_dec_refpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf ) ;
#line 139
__inline static void t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int poshalf , int neghalf , int vsc ) ;
#line 150
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) ;
#line 159
static void t1_dec_refpass_raw(opj_t1_t *t1 , int bpno , int cblksty ) ;
#line 163
static void t1_dec_refpass_mqc(opj_t1_t *t1 , int bpno ) ;
#line 166
static void t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , int bpno ) ;
#line 172
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) ;
#line 185
static void t1_dec_clnpass_step_partial(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                        int orient , int oneplushalf ) ;
#line 191
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf ) ;
#line 197
static void t1_dec_clnpass_step_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                    int oneplushalf , int partial , int vsc ) ;
#line 208
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) ;
#line 217
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) ;
#line 222
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps , int mct ) ;
#line 246
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , int mct , opj_tcd_tile_t *tile ) ;
#line 266
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) ;
#line 279 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static char t1_getctxno_zc(int f , int orient ) 
{ 


  {
#line 280
  return (lut_ctxno_zc[(orient << 8) | (f & 255)]);
}
}
#line 283 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static char t1_getctxno_sc(int f ) 
{ 


  {
#line 284
  return (lut_ctxno_sc[(f & 4080) >> 4]);
}
}
#line 287 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static int t1_getctxno_mag(int f ) 
{ 
  int tmp1 ;
  int tmp ;
  int tmp2 ;
  int tmp___0 ;

  {
#line 288
  if (f & 255) {
#line 288
    tmp = 15;
  } else {
#line 288
    tmp = 14;
  }
#line 288
  tmp1 = tmp;
#line 289
  if (f & 8192) {
#line 289
    tmp___0 = 16;
  } else {
#line 289
    tmp___0 = tmp1;
  }
#line 289
  tmp2 = tmp___0;
#line 290
  return (tmp2);
}
}
#line 293 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static char t1_getspb(int f ) 
{ 


  {
#line 294
  return (lut_spb[(f & 4080) >> 4]);
}
}
#line 297 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static short t1_getnmsedec_sig(int x , int bitpos ) 
{ 


  {
#line 298
  if (bitpos > 6) {
#line 299
    return (lut_nmsedec_sig[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 302
  return (lut_nmsedec_sig0[x & ((1 << 7) - 1)]);
}
}
#line 305 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static short t1_getnmsedec_ref(int x , int bitpos ) 
{ 


  {
#line 306
  if (bitpos > 6) {
#line 307
    return (lut_nmsedec_ref[(x >> (bitpos - 6)) & ((1 << 7) - 1)]);
  }
#line 310
  return (lut_nmsedec_ref0[x & ((1 << 7) - 1)]);
}
}
#line 313 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_updateflags(flag_t *flagsp , int s , int stride ) 
{ 
  flag_t *np ;
  flag_t *sp ;
  static flag_t mod[8] ;

  {
#line 314
  np = flagsp - stride;
#line 315
  sp = flagsp + stride;
#line 317
  mod[0] = (flag_t )64;
#line 317
  mod[1] = (flag_t )1088;
#line 317
  mod[2] = (flag_t )32;
#line 317
  mod[3] = (flag_t )544;
#line 317
  mod[4] = (flag_t )128;
#line 317
  mod[5] = (flag_t )2176;
#line 317
  mod[6] = (flag_t )16;
#line 317
  mod[7] = (flag_t )272;
#line 324
  *(np + - 1) |= 2;
#line 325
  *(np + 0) |= (int )mod[s];
#line 326
  *(np + 1) |= 4;
#line 328
  *(flagsp + - 1) |= (int )mod[s + 2];
#line 329
  *(flagsp + 0) |= 4096;
#line 330
  *(flagsp + 1) |= (int )mod[s + 4];
#line 332
  *(sp + - 1) |= 1;
#line 333
  *(sp + 0) |= (int )mod[s + 6];
#line 334
  *(sp + 1) |= 8;
  return;
}
}
#line 337 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_enc_sigpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp14 ;
  int tmp___0 ;
  char __cil_tmp16 ;
  int tmp___1 ;
  int __cil_tmp18 ;
  short __cil_tmp19 ;
  char __cil_tmp20 ;
  char __cil_tmp21 ;

  {
#line 350
  mqc = t1->mqc;
#line 352
  if (vsc) {
#line 352
    tmp = (int )*flagsp & -1095;
  } else {
#line 352
    tmp = (int )*flagsp;
  }
#line 352
  flag = tmp;
#line 353
  if (flag & 255) {
#line 353
    if (! (flag & 20480)) {
      {
#line 354
      __cil_tmp14 = int_abs(*datap);
      }
#line 354
      if (__cil_tmp14 & one) {
#line 354
        tmp___0 = 1;
      } else {
#line 354
        tmp___0 = 0;
      }
      {
#line 354
      v = tmp___0;
#line 355
      __cil_tmp16 = t1_getctxno_zc(flag, orient);
#line 355
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp16];
      }
#line 356
      if ((int )type == 1) {
        {
#line 357
        mqc_bypass_enc(mqc, v);
        }
      } else {
        {
#line 359
        mqc_encode(mqc, v);
        }
      }
#line 361
      if (v) {
#line 362
        if (*datap < 0) {
#line 362
          tmp___1 = 1;
        } else {
#line 362
          tmp___1 = 0;
        }
        {
#line 362
        v = tmp___1;
#line 363
        __cil_tmp18 = int_abs(*datap);
#line 363
        __cil_tmp19 = t1_getnmsedec_sig(__cil_tmp18, bpno + 6);
        }
        {
#line 363
        *nmsedec += (int )__cil_tmp19;
#line 364
        __cil_tmp20 = t1_getctxno_sc(flag);
#line 364
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp20];
        }
#line 365
        if ((int )type == 1) {
          {
#line 366
          mqc_bypass_enc(mqc, v);
          }
        } else {
          {
#line 368
          __cil_tmp21 = t1_getspb(flag);
#line 368
          mqc_encode(mqc, v ^ (int )__cil_tmp21);
          }
        }
        {
#line 370
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 372
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 376 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_raw_t *raw ;
  int tmp ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int tmp___0 ;

  {
#line 385
  raw = t1->raw;
#line 389
  if (vsc) {
#line 389
    tmp = (int )*flagsp & -1095;
  } else {
#line 389
    tmp = (int )*flagsp;
  }
#line 389
  flag = tmp;
#line 390
  if (flag & 255) {
#line 390
    if (! (flag & 20480)) {
      {
#line 391
      __cil_tmp11 = raw_decode(raw);
      }
#line 391
      if (__cil_tmp11) {
        {
#line 392
        v = raw_decode(raw);
        }
#line 393
        if (v) {
#line 393
          tmp___0 = - oneplushalf;
        } else {
#line 393
          tmp___0 = oneplushalf;
        }
        {
#line 393
        *datap = tmp___0;
#line 394
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 396
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 400 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int orient , int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int tmp ;

  {
#line 409
  mqc = t1->mqc;
#line 411
  flag = (int )*flagsp;
#line 412
  if (flag & 255) {
#line 412
    if (! (flag & 20480)) {
      {
#line 413
      __cil_tmp9 = t1_getctxno_zc(flag, orient);
#line 413
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 414
      __cil_tmp10 = mqc_decode(mqc);
      }
#line 414
      if (__cil_tmp10) {
        {
#line 415
        __cil_tmp11 = t1_getctxno_sc(flag);
#line 415
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 416
        __cil_tmp13 = t1_getspb(flag);
        }
        {
#line 416
        __cil_tmp12 = mqc_decode(mqc);
#line 416
        v = __cil_tmp12 ^ (int )__cil_tmp13;
        }
#line 417
        if (v) {
#line 417
          tmp = - oneplushalf;
        } else {
#line 417
          tmp = oneplushalf;
        }
        {
#line 417
        *datap = tmp;
#line 418
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 420
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 424 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
__inline static void t1_dec_sigpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int orient , int oneplushalf , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int __cil_tmp14 ;
  char __cil_tmp15 ;
  int tmp___0 ;

  {
#line 434
  mqc = t1->mqc;
#line 436
  if (vsc) {
#line 436
    tmp = (int )*flagsp & -1095;
  } else {
#line 436
    tmp = (int )*flagsp;
  }
#line 436
  flag = tmp;
#line 437
  if (flag & 255) {
#line 437
    if (! (flag & 20480)) {
      {
#line 438
      __cil_tmp11 = t1_getctxno_zc(flag, orient);
#line 438
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 439
      __cil_tmp12 = mqc_decode(mqc);
      }
#line 439
      if (__cil_tmp12) {
        {
#line 440
        __cil_tmp13 = t1_getctxno_sc(flag);
#line 440
        mqc->curctx = & mqc->ctxs[(int )__cil_tmp13];
#line 441
        __cil_tmp15 = t1_getspb(flag);
        }
        {
#line 441
        __cil_tmp14 = mqc_decode(mqc);
#line 441
        v = __cil_tmp14 ^ (int )__cil_tmp15;
        }
#line 442
        if (v) {
#line 442
          tmp___0 = - oneplushalf;
        } else {
#line 442
          tmp___0 = oneplushalf;
        }
        {
#line 442
        *datap = tmp___0;
#line 443
        t1_updateflags(flagsp, v, t1->flags_stride);
        }
      }
#line 445
      *flagsp |= 16384;
    }
  }
  return;
}
}
#line 449 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_enc_sigpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , char type ,
                           int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 458
  *nmsedec = 0;
#line 459
  one = 1 << (bpno + 6);
#line 460
  k = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (k < t1->h)) {
#line 460
      goto while_break;
    }
#line 461
    i = 0;
    {
#line 461
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 461
      if (! (i < t1->w)) {
#line 461
        goto while_break___0;
      }
#line 462
      j = k;
      {
#line 462
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 462
        if (! (j < k + 4 && j < t1->h)) {
#line 462
          goto while_break___1;
        }
#line 463
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 463
          tmp = 1;
        } else {
#line 463
          tmp = 0;
        }
        {
#line 463
        vsc = tmp;
#line 464
        t1_enc_sigpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            type, vsc);
        }
#line 462
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 461
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 460
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 479 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_sigpass_raw(opj_t1_t *t1 , int bpno , int orient , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int vsc ;
  int tmp ;

  {
#line 486
  one = 1 << bpno;
#line 487
  half = one >> 1;
#line 488
  oneplushalf = one | half;
#line 489
  k = 0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (k < t1->h)) {
#line 489
      goto while_break;
    }
#line 490
    i = 0;
    {
#line 490
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 490
      if (! (i < t1->w)) {
#line 490
        goto while_break___0;
      }
#line 491
      j = k;
      {
#line 491
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 491
        if (! (j < k + 4 && j < t1->h)) {
#line 491
          goto while_break___1;
        }
#line 492
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 492
          tmp = 1;
        } else {
#line 492
          tmp = 0;
        }
        {
#line 492
        vsc = tmp;
#line 493
        t1_dec_sigpass_step_raw(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                t1->data + (j * t1->w + i), orient, oneplushalf, vsc);
        }
#line 491
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 490
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 489
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 505 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_sigpass_mqc(opj_t1_t *t1 , int bpno , int orient ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int *data1 ;
  flag_t *flags1 ;
  int *data2 ;
  flag_t *flags2 ;
  int *data2___0 ;
  flag_t *flags2___0 ;

  {
#line 511
  data1 = t1->data;
#line 512
  flags1 = t1->flags + 1;
#line 513
  one = 1 << bpno;
#line 514
  half = one >> 1;
#line 515
  oneplushalf = one | half;
#line 516
  k = 0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (k < (t1->h & -4))) {
#line 516
      goto while_break;
    }
#line 517
    i = 0;
    {
#line 517
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 517
      if (! (i < t1->w)) {
#line 517
        goto while_break___0;
      }
      {
#line 518
      data2 = data1 + i;
#line 519
      flags2 = flags1 + i;
#line 520
      flags2 += t1->flags_stride;
#line 521
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 522
      data2 += t1->w;
#line 523
      flags2 += t1->flags_stride;
#line 524
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 525
      data2 += t1->w;
#line 526
      flags2 += t1->flags_stride;
#line 527
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 528
      data2 += t1->w;
#line 529
      flags2 += t1->flags_stride;
#line 530
      t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
#line 531
      data2 += t1->w;
      }
#line 517
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 533
    data1 += t1->w << 2;
#line 534
    flags1 += t1->flags_stride << 2;
#line 516
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  i = 0;
  {
#line 536
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 536
    if (! (i < t1->w)) {
#line 536
      goto while_break___1;
    }
#line 537
    data2___0 = data1 + i;
#line 538
    flags2___0 = flags1 + i;
#line 539
    j = k;
    {
#line 539
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 539
      if (! (j < t1->h)) {
#line 539
        goto while_break___2;
      }
      {
#line 540
      flags2___0 += t1->flags_stride;
#line 541
      t1_dec_sigpass_step_mqc(t1, flags2___0, data2___0, orient, oneplushalf);
#line 542
      data2___0 += t1->w;
      }
#line 539
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 536
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 547 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_sigpass_mqc_vsc(opj_t1_t *t1 , int bpno , int orient ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int vsc ;
  int tmp ;

  {
#line 553
  one = 1 << bpno;
#line 554
  half = one >> 1;
#line 555
  oneplushalf = one | half;
#line 556
  k = 0;
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (! (k < t1->h)) {
#line 556
      goto while_break;
    }
#line 557
    i = 0;
    {
#line 557
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      if (! (i < t1->w)) {
#line 557
        goto while_break___0;
      }
#line 558
      j = k;
      {
#line 558
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 558
        if (! (j < k + 4 && j < t1->h)) {
#line 558
          goto while_break___1;
        }
#line 559
        if (j == k + 3 || j == t1->h - 1) {
#line 559
          tmp = 1;
        } else {
#line 559
          tmp = 0;
        }
        {
#line 559
        vsc = tmp;
#line 560
        t1_dec_sigpass_step_mqc_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                    t1->data + (j * t1->w + i), orient, oneplushalf,
                                    vsc);
        }
#line 558
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 557
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 556
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 572 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_enc_refpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int bpno ,
                                int one , int *nmsedec , char type , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp13 ;
  short __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;

  {
#line 584
  mqc = t1->mqc;
#line 586
  if (vsc) {
#line 586
    tmp = (int )*flagsp & -1095;
  } else {
#line 586
    tmp = (int )*flagsp;
  }
#line 586
  flag = tmp;
#line 587
  if ((flag & 20480) == 4096) {
    {
#line 588
    __cil_tmp13 = int_abs(*datap);
#line 588
    __cil_tmp14 = t1_getnmsedec_ref(__cil_tmp13, bpno + 6);
    }
    {
#line 588
    *nmsedec += (int )__cil_tmp14;
#line 589
    __cil_tmp15 = int_abs(*datap);
    }
#line 589
    if (__cil_tmp15 & one) {
#line 589
      tmp___0 = 1;
    } else {
#line 589
      tmp___0 = 0;
    }
    {
#line 589
    v = tmp___0;
#line 590
    __cil_tmp17 = t1_getctxno_mag(flag);
#line 590
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp17];
    }
#line 591
    if ((int )type == 1) {
      {
#line 592
      mqc_bypass_enc(mqc, v);
      }
    } else {
      {
#line 594
      mqc_encode(mqc, v);
      }
    }
#line 596
    *flagsp |= 8192;
  }
  return;
}
}
#line 600 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_raw(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf , int vsc ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_raw_t *raw ;
  int tmp ;
  int __cil_tmp12 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 610
  raw = t1->raw;
#line 612
  if (vsc) {
#line 612
    tmp = (int )*flagsp & -1095;
  } else {
#line 612
    tmp = (int )*flagsp;
  }
#line 612
  flag = tmp;
#line 613
  if ((flag & 20480) == 4096) {
    {
#line 614
    v = raw_decode(raw);
    }
#line 615
    if (v) {
#line 615
      tmp___0 = poshalf;
    } else {
#line 615
      tmp___0 = neghalf;
    }
#line 615
    t = tmp___0;
#line 616
    if (*datap < 0) {
#line 616
      tmp___1 = - t;
    } else {
#line 616
      tmp___1 = t;
    }
#line 616
    *datap += tmp___1;
#line 617
    *flagsp |= 8192;
  }
  return;
}
}
#line 621 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_mqc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                             int poshalf , int neghalf ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_mqc_t *mqc ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp ;
  int tmp___0 ;

  {
#line 630
  mqc = t1->mqc;
#line 632
  flag = (int )*flagsp;
#line 633
  if ((flag & 20480) == 4096) {
    {
#line 634
    __cil_tmp10 = t1_getctxno_mag(flag);
#line 634
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp10];
#line 635
    v = mqc_decode(mqc);
    }
#line 636
    if (v) {
#line 636
      tmp = poshalf;
    } else {
#line 636
      tmp = neghalf;
    }
#line 636
    t = tmp;
#line 637
    if (*datap < 0) {
#line 637
      tmp___0 = - t;
    } else {
#line 637
      tmp___0 = t;
    }
#line 637
    *datap += tmp___0;
#line 638
    *flagsp |= 8192;
  }
  return;
}
}
#line 642 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
__inline static void t1_dec_refpass_step_mqc_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                                 int poshalf , int neghalf , int vsc ) 
{ 
  int v ;
  int t ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 652
  mqc = t1->mqc;
#line 654
  if (vsc) {
#line 654
    tmp = (int )*flagsp & -1095;
  } else {
#line 654
    tmp = (int )*flagsp;
  }
#line 654
  flag = tmp;
#line 655
  if ((flag & 20480) == 4096) {
    {
#line 656
    __cil_tmp12 = t1_getctxno_mag(flag);
#line 656
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp12];
#line 657
    v = mqc_decode(mqc);
    }
#line 658
    if (v) {
#line 658
      tmp___0 = poshalf;
    } else {
#line 658
      tmp___0 = neghalf;
    }
#line 658
    t = tmp___0;
#line 659
    if (*datap < 0) {
#line 659
      tmp___1 = - t;
    } else {
#line 659
      tmp___1 = t;
    }
#line 659
    *datap += tmp___1;
#line 660
    *flagsp |= 8192;
  }
  return;
}
}
#line 664 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_enc_refpass(opj_t1_t *t1 , int bpno , int *nmsedec , char type , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int vsc ;
  int tmp ;

  {
#line 672
  *nmsedec = 0;
#line 673
  one = 1 << (bpno + 6);
#line 674
  k = 0;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (k < t1->h)) {
#line 674
      goto while_break;
    }
#line 675
    i = 0;
    {
#line 675
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 675
      if (! (i < t1->w)) {
#line 675
        goto while_break___0;
      }
#line 676
      j = k;
      {
#line 676
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 676
        if (! (j < k + 4 && j < t1->h)) {
#line 676
          goto while_break___1;
        }
#line 677
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 677
          tmp = 1;
        } else {
#line 677
          tmp = 0;
        }
        {
#line 677
        vsc = tmp;
#line 678
        t1_enc_refpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), bpno, one, nmsedec, type,
                            vsc);
        }
#line 676
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 675
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 674
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 692 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_refpass_raw(opj_t1_t *t1 , int bpno , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int vsc ;
  int tmp ;
  int tmp___0 ;

  {
#line 699
  one = 1 << bpno;
#line 700
  poshalf = one >> 1;
#line 701
  if (bpno > 0) {
#line 701
    tmp = - poshalf;
  } else {
#line 701
    tmp = - 1;
  }
#line 701
  neghalf = tmp;
#line 702
  k = 0;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    if (! (k < t1->h)) {
#line 702
      goto while_break;
    }
#line 703
    i = 0;
    {
#line 703
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 703
      if (! (i < t1->w)) {
#line 703
        goto while_break___0;
      }
#line 704
      j = k;
      {
#line 704
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 704
        if (! (j < k + 4 && j < t1->h)) {
#line 704
          goto while_break___1;
        }
#line 705
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 705
          tmp___0 = 1;
        } else {
#line 705
          tmp___0 = 0;
        }
        {
#line 705
        vsc = tmp___0;
#line 706
        t1_dec_refpass_step_raw(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                t1->data + (j * t1->w + i), poshalf, neghalf, vsc);
        }
#line 704
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 703
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 702
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 718 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_refpass_mqc(opj_t1_t *t1 , int bpno ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int *data1 ;
  flag_t *flags1 ;
  int tmp ;
  int *data2 ;
  flag_t *flags2 ;
  int *data2___0 ;
  flag_t *flags2___0 ;

  {
#line 723
  data1 = t1->data;
#line 724
  flags1 = t1->flags + 1;
#line 725
  one = 1 << bpno;
#line 726
  poshalf = one >> 1;
#line 727
  if (bpno > 0) {
#line 727
    tmp = - poshalf;
  } else {
#line 727
    tmp = - 1;
  }
#line 727
  neghalf = tmp;
#line 728
  k = 0;
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    if (! (k < (t1->h & -4))) {
#line 728
      goto while_break;
    }
#line 729
    i = 0;
    {
#line 729
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 729
      if (! (i < t1->w)) {
#line 729
        goto while_break___0;
      }
      {
#line 730
      data2 = data1 + i;
#line 731
      flags2 = flags1 + i;
#line 732
      flags2 += t1->flags_stride;
#line 733
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 734
      data2 += t1->w;
#line 735
      flags2 += t1->flags_stride;
#line 736
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 737
      data2 += t1->w;
#line 738
      flags2 += t1->flags_stride;
#line 739
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 740
      data2 += t1->w;
#line 741
      flags2 += t1->flags_stride;
#line 742
      t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
#line 743
      data2 += t1->w;
      }
#line 729
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 745
    data1 += t1->w << 2;
#line 746
    flags1 += t1->flags_stride << 2;
#line 728
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  i = 0;
  {
#line 748
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 748
    if (! (i < t1->w)) {
#line 748
      goto while_break___1;
    }
#line 749
    data2___0 = data1 + i;
#line 750
    flags2___0 = flags1 + i;
#line 751
    j = k;
    {
#line 751
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 751
      if (! (j < t1->h)) {
#line 751
        goto while_break___2;
      }
      {
#line 752
      flags2___0 += t1->flags_stride;
#line 753
      t1_dec_refpass_step_mqc(t1, flags2___0, data2___0, poshalf, neghalf);
#line 754
      data2___0 += t1->w;
      }
#line 751
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 748
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 759 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_refpass_mqc_vsc(opj_t1_t *t1 , int bpno ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int poshalf ;
  int neghalf ;
  int vsc ;
  int tmp ;
  int tmp___0 ;

  {
#line 765
  one = 1 << bpno;
#line 766
  poshalf = one >> 1;
#line 767
  if (bpno > 0) {
#line 767
    tmp = - poshalf;
  } else {
#line 767
    tmp = - 1;
  }
#line 767
  neghalf = tmp;
#line 768
  k = 0;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (k < t1->h)) {
#line 768
      goto while_break;
    }
#line 769
    i = 0;
    {
#line 769
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 769
      if (! (i < t1->w)) {
#line 769
        goto while_break___0;
      }
#line 770
      j = k;
      {
#line 770
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 770
        if (! (j < k + 4 && j < t1->h)) {
#line 770
          goto while_break___1;
        }
#line 771
        if (j == k + 3 || j == t1->h - 1) {
#line 771
          tmp___0 = 1;
        } else {
#line 771
          tmp___0 = 0;
        }
        {
#line 771
        vsc = tmp___0;
#line 772
        t1_dec_refpass_step_mqc_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                    t1->data + (j * t1->w + i), poshalf, neghalf,
                                    vsc);
        }
#line 770
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 769
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 768
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 784 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_enc_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int bpno , int one , int *nmsedec , int partial ,
                                int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp___0 ;
  int __cil_tmp17 ;
  short __cil_tmp18 ;
  char __cil_tmp19 ;
  int tmp___1 ;
  char __cil_tmp21 ;

  {
#line 797
  mqc = t1->mqc;
#line 799
  if (vsc) {
#line 799
    tmp = (int )*flagsp & -1095;
  } else {
#line 799
    tmp = (int )*flagsp;
  }
#line 799
  flag = tmp;
#line 800
  if (partial) {
#line 801
    goto LABEL_PARTIAL;
  }
#line 803
  if (! ((int )*flagsp & 20480)) {
    {
#line 804
    __cil_tmp14 = t1_getctxno_zc(flag, orient);
#line 804
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
#line 805
    __cil_tmp15 = int_abs(*datap);
    }
#line 805
    if (__cil_tmp15 & one) {
#line 805
      tmp___0 = 1;
    } else {
#line 805
      tmp___0 = 0;
    }
    {
#line 805
    v = tmp___0;
#line 806
    mqc_encode(mqc, v);
    }
#line 807
    if (v) {
      LABEL_PARTIAL: 
      {
#line 809
      __cil_tmp17 = int_abs(*datap);
#line 809
      __cil_tmp18 = t1_getnmsedec_sig(__cil_tmp17, bpno + 6);
      }
      {
#line 809
      *nmsedec += (int )__cil_tmp18;
#line 810
      __cil_tmp19 = t1_getctxno_sc(flag);
#line 810
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp19];
      }
#line 811
      if (*datap < 0) {
#line 811
        tmp___1 = 1;
      } else {
#line 811
        tmp___1 = 0;
      }
      {
#line 811
      v = tmp___1;
#line 812
      __cil_tmp21 = t1_getspb(flag);
#line 812
      mqc_encode(mqc, v ^ (int )__cil_tmp21);
#line 813
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 816
  *flagsp &= ~ 16384;
  return;
}
}
#line 819 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_clnpass_step_partial(opj_t1_t *t1 , flag_t *flagsp , int *datap ,
                                        int orient , int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int tmp ;

  {
  {
#line 827
  mqc = t1->mqc;
#line 831
  flag = (int )*flagsp;
#line 832
  __cil_tmp9 = t1_getctxno_sc(flag);
#line 832
  mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 833
  __cil_tmp11 = t1_getspb(flag);
  }
  {
#line 833
  __cil_tmp10 = mqc_decode(mqc);
#line 833
  v = __cil_tmp10 ^ (int )__cil_tmp11;
  }
#line 834
  if (v) {
#line 834
    tmp = - oneplushalf;
  } else {
#line 834
    tmp = oneplushalf;
  }
  {
#line 834
  *datap = tmp;
#line 835
  t1_updateflags(flagsp, v, t1->flags_stride);
#line 836
  *flagsp &= ~ 16384;
  }
  return;
}
}
#line 839 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_clnpass_step(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                int oneplushalf ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  char __cil_tmp9 ;
  int __cil_tmp10 ;
  char __cil_tmp11 ;
  int __cil_tmp12 ;
  char __cil_tmp13 ;
  int tmp ;

  {
#line 848
  mqc = t1->mqc;
#line 850
  flag = (int )*flagsp;
#line 851
  if (! (flag & 20480)) {
    {
#line 852
    __cil_tmp9 = t1_getctxno_zc(flag, orient);
#line 852
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp9];
#line 853
    __cil_tmp10 = mqc_decode(mqc);
    }
#line 853
    if (__cil_tmp10) {
      {
#line 854
      __cil_tmp11 = t1_getctxno_sc(flag);
#line 854
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp11];
#line 855
      __cil_tmp13 = t1_getspb(flag);
      }
      {
#line 855
      __cil_tmp12 = mqc_decode(mqc);
#line 855
      v = __cil_tmp12 ^ (int )__cil_tmp13;
      }
#line 856
      if (v) {
#line 856
        tmp = - oneplushalf;
      } else {
#line 856
        tmp = oneplushalf;
      }
      {
#line 856
      *datap = tmp;
#line 857
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 860
  *flagsp &= ~ 16384;
  return;
}
}
#line 863 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_clnpass_step_vsc(opj_t1_t *t1 , flag_t *flagsp , int *datap , int orient ,
                                    int oneplushalf , int partial , int vsc ) 
{ 
  int v ;
  int flag ;
  opj_mqc_t *mqc ;
  int tmp ;
  char __cil_tmp12 ;
  int __cil_tmp13 ;
  char __cil_tmp14 ;
  int __cil_tmp15 ;
  char __cil_tmp16 ;
  int tmp___0 ;

  {
#line 874
  mqc = t1->mqc;
#line 876
  if (vsc) {
#line 876
    tmp = (int )*flagsp & -1095;
  } else {
#line 876
    tmp = (int )*flagsp;
  }
#line 876
  flag = tmp;
#line 877
  if (partial) {
#line 878
    goto LABEL_PARTIAL;
  }
#line 880
  if (! (flag & 20480)) {
    {
#line 881
    __cil_tmp12 = t1_getctxno_zc(flag, orient);
#line 881
    mqc->curctx = & mqc->ctxs[(int )__cil_tmp12];
#line 882
    __cil_tmp13 = mqc_decode(mqc);
    }
#line 882
    if (__cil_tmp13) {
      LABEL_PARTIAL: 
      {
#line 884
      __cil_tmp14 = t1_getctxno_sc(flag);
#line 884
      mqc->curctx = & mqc->ctxs[(int )__cil_tmp14];
      }
      {
#line 885
      __cil_tmp16 = t1_getspb(flag);
      }
      {
#line 885
      __cil_tmp15 = mqc_decode(mqc);
#line 885
      v = __cil_tmp15 ^ (int )__cil_tmp16;
      }
#line 886
      if (v) {
#line 886
        tmp___0 = - oneplushalf;
      } else {
#line 886
        tmp___0 = oneplushalf;
      }
      {
#line 886
      *datap = tmp___0;
#line 887
      t1_updateflags(flagsp, v, t1->flags_stride);
      }
    }
  }
#line 890
  *flagsp &= ~ 16384;
  return;
}
}
#line 893 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_enc_clnpass(opj_t1_t *t1 , int bpno , int orient , int *nmsedec , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int agg ;
  int runlen ;
  int vsc ;
  opj_mqc_t *mqc ;
  int __cil_tmp14 ;
  int tmp ;

  {
#line 902
  mqc = t1->mqc;
#line 904
  *nmsedec = 0;
#line 905
  one = 1 << (bpno + 6);
#line 906
  k = 0;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! (k < t1->h)) {
#line 906
      goto while_break;
    }
#line 907
    i = 0;
    {
#line 907
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 907
      if (! (i < t1->w)) {
#line 907
        goto while_break___0;
      }
#line 908
      if (k + 3 < t1->h) {
#line 909
        if (cblksty & 8) {
#line 910
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735);
        } else {
#line 916
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735);
        }
      } else {
#line 922
        agg = 0;
      }
#line 924
      if (agg) {
#line 925
        runlen = 0;
        {
#line 925
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 925
          if (! (runlen < 4)) {
#line 925
            goto while_break___1;
          }
          {
#line 926
          __cil_tmp14 = int_abs(*(t1->data + ((k + runlen) * t1->w + i)));
          }
#line 926
          if (__cil_tmp14 & one) {
#line 927
            goto while_break___1;
          }
#line 925
          runlen ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 929
        mqc->curctx = & mqc->ctxs[(int )17];
#line 930
        mqc_encode(mqc, runlen != 4);
        }
#line 931
        if (runlen == 4) {
#line 932
          goto while_continue___0;
        }
        {
#line 934
        mqc->curctx = & mqc->ctxs[(int )18];
#line 935
        mqc_encode(mqc, runlen >> 1);
#line 936
        mqc_encode(mqc, runlen & 1);
        }
      } else {
#line 938
        runlen = 0;
      }
#line 940
      j = k + runlen;
      {
#line 940
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 940
        if (! (j < k + 4 && j < t1->h)) {
#line 940
          goto while_break___2;
        }
#line 941
        if (cblksty & 8 && (j == k + 3 || j == t1->h - 1)) {
#line 941
          tmp = 1;
        } else {
#line 941
          tmp = 0;
        }
        {
#line 941
        vsc = tmp;
#line 942
        t1_enc_clnpass_step(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                            t1->data + (j * t1->w + i), orient, bpno, one, nmsedec,
                            agg && j == k + runlen, vsc);
        }
#line 940
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 907
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 906
    k += 4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 957 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_dec_clnpass(opj_t1_t *t1 , int bpno , int orient , int cblksty ) 
{ 
  int i ;
  int j ;
  int k ;
  int one ;
  int half ;
  int oneplushalf ;
  int agg ;
  int runlen ;
  int vsc ;
  int segsym ;
  opj_mqc_t *mqc ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp ;
  int *data1 ;
  flag_t *flags1 ;
  int *data2 ;
  flag_t *flags2 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int *data2___0 ;
  flag_t *flags2___0 ;
  int v ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 964
  segsym = cblksty & 32;
#line 966
  mqc = t1->mqc;
#line 968
  one = 1 << bpno;
#line 969
  half = one >> 1;
#line 970
  oneplushalf = one | half;
#line 971
  if (cblksty & 8) {
#line 972
    k = 0;
    {
#line 972
    while (1) {
      while_continue: /* CIL Label */ ;
#line 972
      if (! (k < t1->h)) {
#line 972
        goto while_break;
      }
#line 973
      i = 0;
      {
#line 973
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 973
        if (! (i < t1->w)) {
#line 973
          goto while_break___0;
        }
#line 974
        if (k + 3 < t1->h) {
#line 975
          agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || ((int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & -1095) & 20735);
        } else {
#line 981
          agg = 0;
        }
#line 983
        if (agg) {
          {
#line 984
          mqc->curctx = & mqc->ctxs[(int )17];
#line 985
          __cil_tmp16 = mqc_decode(mqc);
          }
#line 985
          if (! __cil_tmp16) {
#line 986
            goto while_continue___0;
          }
          {
#line 988
          mqc->curctx = & mqc->ctxs[(int )18];
#line 989
          runlen = mqc_decode(mqc);
#line 990
          __cil_tmp18 = mqc_decode(mqc);
#line 990
          runlen = (runlen << 1) | __cil_tmp18;
          }
        } else {
#line 992
          runlen = 0;
        }
#line 994
        j = k + runlen;
        {
#line 994
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 994
          if (! (j < k + 4 && j < t1->h)) {
#line 994
            goto while_break___1;
          }
#line 995
          if (j == k + 3 || j == t1->h - 1) {
#line 995
            tmp = 1;
          } else {
#line 995
            tmp = 0;
          }
          {
#line 995
          vsc = tmp;
#line 996
          t1_dec_clnpass_step_vsc(t1, t1->flags + (((j + 1) * t1->flags_stride + i) + 1),
                                  t1->data + (j * t1->w + i), orient, oneplushalf,
                                  agg && j == k + runlen, vsc);
          }
#line 994
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 973
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 972
      k += 4;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1008
    data1 = t1->data;
#line 1009
    flags1 = t1->flags + 1;
#line 1010
    k = 0;
    {
#line 1010
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1010
      if (! (k < (t1->h & -4))) {
#line 1010
        goto while_break___2;
      }
#line 1011
      i = 0;
      {
#line 1011
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1011
        if (! (i < t1->w)) {
#line 1011
          goto while_break___3;
        }
#line 1012
        data2 = data1 + i;
#line 1013
        flags2 = flags1 + i;
#line 1014
        agg = ! ((((int )*(t1->flags + ((1 + k) * t1->flags_stride + (1 + i))) & 20735 || (int )*(t1->flags + (((1 + k) + 1) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 2) * t1->flags_stride + (1 + i))) & 20735) || (int )*(t1->flags + (((1 + k) + 3) * t1->flags_stride + (1 + i))) & 20735);
#line 1018
        if (agg) {
          {
#line 1019
          mqc->curctx = & mqc->ctxs[(int )17];
#line 1020
          __cil_tmp24 = mqc_decode(mqc);
          }
#line 1020
          if (! __cil_tmp24) {
#line 1021
            goto while_continue___3;
          }
          {
#line 1023
          mqc->curctx = & mqc->ctxs[(int )18];
#line 1024
          runlen = mqc_decode(mqc);
#line 1025
          __cil_tmp26 = mqc_decode(mqc);
#line 1025
          runlen = (runlen << 1) | __cil_tmp26;
#line 1026
          flags2 += runlen * t1->flags_stride;
#line 1027
          data2 += runlen * t1->w;
#line 1028
          j = k + runlen;
          }
          {
#line 1028
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1028
            if (! (j < k + 4 && j < t1->h)) {
#line 1028
              goto while_break___4;
            }
#line 1029
            flags2 += t1->flags_stride;
#line 1030
            if (agg) {
#line 1030
              if (j == k + runlen) {
                {
#line 1031
                t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
                }
              } else {
                {
                {
#line 1033
                t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
                }
                }
              }
            } else {
              {
              {
#line 1033
              t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
              }
              }
            }
#line 1035
            data2 += t1->w;
#line 1028
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 1038
          flags2 += t1->flags_stride;
#line 1039
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1040
          data2 += t1->w;
#line 1041
          flags2 += t1->flags_stride;
#line 1042
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1043
          data2 += t1->w;
#line 1044
          flags2 += t1->flags_stride;
#line 1045
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1046
          data2 += t1->w;
#line 1047
          flags2 += t1->flags_stride;
#line 1048
          t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
#line 1049
          data2 += t1->w;
          }
        }
#line 1011
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1052
      data1 += t1->w << 2;
#line 1053
      flags1 += t1->flags_stride << 2;
#line 1010
      k += 4;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1055
    i = 0;
    {
#line 1055
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1055
      if (! (i < t1->w)) {
#line 1055
        goto while_break___5;
      }
#line 1056
      data2___0 = data1 + i;
#line 1057
      flags2___0 = flags1 + i;
#line 1058
      j = k;
      {
#line 1058
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1058
        if (! (j < t1->h)) {
#line 1058
          goto while_break___6;
        }
        {
#line 1059
        flags2___0 += t1->flags_stride;
#line 1060
        t1_dec_clnpass_step(t1, flags2___0, data2___0, orient, oneplushalf);
#line 1061
        data2___0 += t1->w;
        }
#line 1058
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1055
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1066
  if (segsym) {
    {
#line 1067
    v = 0;
#line 1068
    mqc->curctx = & mqc->ctxs[(int )18];
#line 1069
    v = mqc_decode(mqc);
#line 1070
    __cil_tmp31 = mqc_decode(mqc);
#line 1070
    v = (v << 1) | __cil_tmp31;
#line 1071
    __cil_tmp32 = mqc_decode(mqc);
#line 1071
    v = (v << 1) | __cil_tmp32;
#line 1072
    __cil_tmp33 = mqc_decode(mqc);
#line 1072
    v = (v << 1) | __cil_tmp33;
    }
  }
  return;
}
}
#line 1083 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static double t1_getwmsedec(int nmsedec , int compno , int level , int orient , int bpno ,
                            int qmfbid , double stepsize , int numcomps , int mct ) 
{ 
  double w1 ;
  double w2 ;
  double wmsedec ;
  double __cil_tmp13 ;
  double tmp ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  double tmp___0 ;
  double __cil_tmp18 ;

  {
#line 1095
  if (qmfbid == 1) {
#line 1096
    if (mct && numcomps == 3) {
      {
#line 1096
      __cil_tmp13 = mct_getnorm(compno);
#line 1096
      tmp = __cil_tmp13;
      }
    } else {
#line 1096
      tmp = 1.;
    }
    {
#line 1096
    w1 = tmp;
#line 1097
    w2 = dwt_getnorm(level, orient);
    }
  } else {
#line 1099
    if (mct && numcomps == 3) {
      {
#line 1099
      __cil_tmp16 = mct_getnorm_real(compno);
#line 1099
      tmp___0 = __cil_tmp16;
      }
    } else {
#line 1099
      tmp___0 = 1.;
    }
    {
#line 1099
    w1 = tmp___0;
#line 1100
    w2 = dwt_getnorm_real(level, orient);
    }
  }
#line 1102
  wmsedec = ((w1 * w2) * stepsize) * (double )(1 << bpno);
#line 1103
  wmsedec *= (wmsedec * (double )nmsedec) / 8192.;
#line 1105
  return (wmsedec);
}
}
#line 1108 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static opj_bool allocate_buffers(opj_t1_t *t1 , int w , int h ) 
{ 
  int datasize ;
  int flagssize ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 1113
  datasize = w * h;
#line 1116
  if (datasize > t1->datasize) {
    {
#line 1117
    free(t1->data);
#line 1118
    __cil_tmp6 = malloc((unsigned long )datasize * sizeof(int ));
#line 1118
    t1->data = (int *)__cil_tmp6;
    }
#line 1119
    if (! t1->data) {
#line 1120
      return (0);
    }
#line 1122
    t1->datasize = datasize;
  }
  {
#line 1124
  memset(t1->data, 0, (unsigned long )datasize * sizeof(int ));
#line 1126
  t1->flags_stride = w + 2;
#line 1127
  flagssize = t1->flags_stride * (h + 2);
  }
#line 1129
  if (flagssize > t1->flagssize) {
    {
#line 1130
    free(t1->flags);
#line 1131
    __cil_tmp7 = malloc((unsigned long )flagssize * sizeof(flag_t ));
#line 1131
    t1->flags = (flag_t *)__cil_tmp7;
    }
#line 1132
    if (! t1->flags) {
#line 1133
      return (0);
    }
#line 1135
    t1->flagssize = flagssize;
  }
  {
#line 1137
  memset(t1->flags, 0, (unsigned long )flagssize * sizeof(flag_t ));
#line 1139
  t1->w = w;
#line 1140
  t1->h = h;
  }
#line 1142
  return (1);
}
}
#line 1146 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_encode_cblk(opj_t1_t *t1 , opj_tcd_cblk_enc_t *cblk , int orient ,
                           int compno , int level , int qmfbid , double stepsize ,
                           int cblksty , int numcomps , int mct , opj_tcd_tile_t *tile ) 
{ 
  double cumwmsedec ;
  opj_mqc_t *mqc ;
  int passno ;
  int bpno ;
  int passtype ;
  int nmsedec ;
  int i ;
  int max ;
  char type ;
  double tempwmsedec ;
  int tmp ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int tmp___0 ;
  opj_tcd_pass_t *pass ;
  int correction ;
  int tmp___1 ;
  double __cil_tmp30 ;
  int __cil_tmp31 ;
  int tmp___2 ;
  int __cil_tmp33 ;
  opj_tcd_pass_t *pass___0 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int tmp___3 ;
  int __cil_tmp39 ;

  {
#line 1159
  cumwmsedec = 0.;
#line 1161
  mqc = t1->mqc;
#line 1164
  nmsedec = 0;
#line 1166
  type = (char )0;
#line 1169
  max = 0;
#line 1170
  i = 0;
  {
#line 1170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1170
    if (! (i < t1->w * t1->h)) {
#line 1170
      goto while_break;
    }
    {
#line 1171
    __cil_tmp23 = abs(*(t1->data + i));
#line 1171
    tmp = __cil_tmp23;
#line 1172
    max = int_max(max, tmp);
    }
#line 1170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1175
  if (max) {
    {
#line 1175
    __cil_tmp25 = int_floorlog2(max);
#line 1175
    tmp___0 = (__cil_tmp25 + 1) - 6;
    }
  } else {
#line 1175
    tmp___0 = 0;
  }
  {
#line 1175
  cblk->numbps = tmp___0;
#line 1177
  bpno = cblk->numbps - 1;
#line 1178
  passtype = 2;
#line 1180
  mqc_resetstates(mqc);
#line 1181
  mqc_setstate(mqc, 18, 0, 46);
#line 1182
  mqc_setstate(mqc, 17, 0, 3);
#line 1183
  mqc_setstate(mqc, 0, 0, 4);
#line 1184
  mqc_init_enc(mqc, cblk->data);
#line 1186
  passno = 0;
  }
  {
#line 1186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1186
    if (! (bpno >= 0)) {
#line 1186
      goto while_break___0;
    }
#line 1187
    pass = cblk->passes + passno;
#line 1188
    correction = 3;
#line 1189
    if ((bpno < cblk->numbps - 4 && passtype < 2) && cblksty & 1) {
#line 1189
      tmp___1 = 1;
    } else {
#line 1189
      tmp___1 = 0;
    }
#line 1189
    type = (char )tmp___1;
    {
#line 1192
    if (passtype == 0) {
#line 1192
      goto case_0;
    }
#line 1195
    if (passtype == 1) {
#line 1195
      goto case_1;
    }
#line 1198
    if (passtype == 2) {
#line 1198
      goto case_2;
    }
#line 1191
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1193
    t1_enc_sigpass(t1, bpno, orient, & nmsedec, type, cblksty);
    }
#line 1194
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1196
    t1_enc_refpass(t1, bpno, & nmsedec, type, cblksty);
    }
#line 1197
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1199
    t1_enc_clnpass(t1, bpno, orient, & nmsedec, cblksty);
    }
#line 1201
    if (cblksty & 32) {
      {
#line 1202
      mqc_segmark_enc(mqc);
      }
    }
#line 1203
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1207
    tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize,
                                numcomps, mct);
#line 1208
    cumwmsedec += tempwmsedec;
#line 1209
    tile->distotile += tempwmsedec;
    }
#line 1212
    if (cblksty & 4) {
#line 1212
      if (! (passtype == 2 && bpno - 1 < 0)) {
#line 1213
        if ((int )type == 1) {
          {
#line 1214
          mqc_flush(mqc);
#line 1215
          correction = 1;
          }
        } else {
          {
#line 1218
          mqc_flush(mqc);
#line 1219
          correction = 1;
          }
        }
#line 1221
        pass->term = 1;
      } else {
#line 1212
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1223
    if (bpno < cblk->numbps - 4) {
#line 1223
      if (passtype > 0) {
        _L: /* CIL Label */ 
#line 1223
        if (cblksty & 1) {
#line 1225
          if ((int )type == 1) {
            {
#line 1226
            mqc_flush(mqc);
#line 1227
            correction = 1;
            }
          } else {
            {
#line 1230
            mqc_flush(mqc);
#line 1231
            correction = 1;
            }
          }
#line 1233
          pass->term = 1;
        } else {
#line 1235
          pass->term = 0;
        }
      } else {
#line 1223
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1223
    if (bpno == cblk->numbps - 4) {
#line 1223
      if (passtype == 2) {
#line 1223
        goto _L;
      } else {
#line 1235
        pass->term = 0;
      }
    } else {
#line 1235
      pass->term = 0;
    }
#line 1239
    passtype ++;
#line 1239
    if (passtype == 3) {
#line 1240
      passtype = 0;
#line 1241
      __cil_tmp31 = bpno;
#line 1241
      bpno --;
    }
#line 1244
    if (pass->term) {
#line 1244
      if (bpno > 0) {
#line 1245
        if ((bpno < cblk->numbps - 4 && passtype < 2) && cblksty & 1) {
#line 1245
          tmp___2 = 1;
        } else {
#line 1245
          tmp___2 = 0;
        }
#line 1245
        type = (char )tmp___2;
#line 1246
        if ((int )type == 1) {
          {
#line 1247
          mqc_bypass_init_enc(mqc);
          }
        } else {
          {
#line 1249
          mqc_restart_init_enc(mqc);
          }
        }
      }
    }
    {
#line 1252
    pass->distortiondec = cumwmsedec;
#line 1253
    __cil_tmp33 = mqc_numbytes(mqc);
#line 1253
    pass->rate = __cil_tmp33 + correction;
    }
#line 1256
    if (cblksty & 2) {
      {
#line 1257
      mqc_reset_enc(mqc);
      }
    }
#line 1186
    passno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1261
  if (cblksty & 16) {
    {
#line 1262
    mqc_erterm_enc(mqc);
    }
  } else
#line 1263
  if (! (cblksty & 1)) {
    {
#line 1264
    mqc_flush(mqc);
    }
  }
#line 1266
  cblk->totalpasses = passno;
#line 1268
  passno = 0;
  {
#line 1268
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1268
    if (! (passno < cblk->totalpasses)) {
#line 1268
      goto while_break___1;
    }
    {
#line 1269
    pass___0 = cblk->passes + passno;
#line 1270
    __cil_tmp35 = mqc_numbytes(mqc);
    }
#line 1270
    if (pass___0->rate > __cil_tmp35) {
      {
#line 1271
      pass___0->rate = mqc_numbytes(mqc);
      }
    }
#line 1273
    if (pass___0->rate > 1) {
#line 1273
      if ((int )*(cblk->data + (pass___0->rate - 1)) == 255) {
#line 1274
        __cil_tmp37 = pass___0->rate;
#line 1274
        (pass___0->rate) --;
      }
    }
#line 1276
    if (passno == 0) {
#line 1276
      tmp___3 = 0;
    } else {
#line 1276
      tmp___3 = (cblk->passes + (passno - 1))->rate;
    }
#line 1276
    pass___0->len = pass___0->rate - tmp___3;
#line 1268
    passno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 1280 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
static void t1_decode_cblk(opj_t1_t *t1 , opj_tcd_cblk_dec_t *cblk , int orient ,
                           int roishift , int cblksty ) 
{ 
  opj_raw_t *raw ;
  opj_mqc_t *mqc ;
  int bpno ;
  int passtype ;
  int segno ;
  int passno ;
  char type ;
  opj_bool __cil_tmp13 ;
  opj_tcd_seg_t *seg ;
  int tmp ;
  int __cil_tmp16 ;

  {
  {
#line 1287
  raw = t1->raw;
#line 1288
  mqc = t1->mqc;
#line 1292
  type = (char )0;
#line 1294
  __cil_tmp13 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
  }
#line 1294
  if (! __cil_tmp13) {
#line 1299
    return;
  }
  {
#line 1302
  bpno = (roishift + cblk->numbps) - 1;
#line 1303
  passtype = 2;
#line 1305
  mqc_resetstates(mqc);
#line 1306
  mqc_setstate(mqc, 18, 0, 46);
#line 1307
  mqc_setstate(mqc, 17, 0, 3);
#line 1308
  mqc_setstate(mqc, 0, 0, 4);
#line 1310
  segno = 0;
  }
  {
#line 1310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1310
    if (! (segno < cblk->numsegs)) {
#line 1310
      goto while_break;
    }
#line 1311
    seg = cblk->segs + segno;
#line 1314
    if ((bpno <= (cblk->numbps - 1) - 4 && passtype < 2) && cblksty & 1) {
#line 1314
      tmp = 1;
    } else {
#line 1314
      tmp = 0;
    }
#line 1314
    type = (char )tmp;
#line 1316
    if (seg->data == (void *)0) {
#line 1317
      goto while_continue;
    }
#line 1319
    if ((int )type == 1) {
      {
#line 1320
      raw_init_dec(raw, *(seg->data) + seg->dataindex, seg->len);
      }
    } else {
      {
#line 1322
      mqc_init_dec(mqc, *(seg->data) + seg->dataindex, seg->len);
      }
    }
#line 1325
    passno = 0;
    {
#line 1325
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1325
      if (! (passno < seg->numpasses)) {
#line 1325
        goto while_break___0;
      }
      {
#line 1327
      if (passtype == 0) {
#line 1327
        goto case_0;
      }
#line 1338
      if (passtype == 1) {
#line 1338
        goto case_1;
      }
#line 1349
      if (passtype == 2) {
#line 1349
        goto case_2;
      }
#line 1326
      goto switch_break;
      case_0: /* CIL Label */ 
#line 1328
      if ((int )type == 1) {
        {
#line 1329
        t1_dec_sigpass_raw(t1, bpno + 1, orient, cblksty);
        }
      } else
#line 1331
      if (cblksty & 8) {
        {
#line 1332
        t1_dec_sigpass_mqc_vsc(t1, bpno + 1, orient);
        }
      } else {
        {
#line 1334
        t1_dec_sigpass_mqc(t1, bpno + 1, orient);
        }
      }
#line 1337
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1339
      if ((int )type == 1) {
        {
#line 1340
        t1_dec_refpass_raw(t1, bpno + 1, cblksty);
        }
      } else
#line 1342
      if (cblksty & 8) {
        {
#line 1343
        t1_dec_refpass_mqc_vsc(t1, bpno + 1);
        }
      } else {
        {
#line 1345
        t1_dec_refpass_mqc(t1, bpno + 1);
        }
      }
#line 1348
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1350
      t1_dec_clnpass(t1, bpno + 1, orient, cblksty);
      }
#line 1351
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1354
      if (cblksty & 2) {
#line 1354
        if ((int )type == 0) {
          {
#line 1355
          mqc_resetstates(mqc);
#line 1356
          mqc_setstate(mqc, 18, 0, 46);
#line 1357
          mqc_setstate(mqc, 17, 0, 3);
#line 1358
          mqc_setstate(mqc, 0, 0, 4);
          }
        }
      }
#line 1360
      passtype ++;
#line 1360
      if (passtype == 3) {
#line 1361
        passtype = 0;
#line 1362
        __cil_tmp16 = bpno;
#line 1362
        bpno --;
      }
#line 1325
      passno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1310
    segno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1370 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
opj_t1_t *t1_create(opj_common_ptr cinfo ) 
{ 
  opj_t1_t *t1 ;
  void *__cil_tmp3 ;
  opj_mqc_t *__cil_tmp4 ;
  opj_raw_t *__cil_tmp5 ;

  {
  {
#line 1371
  __cil_tmp3 = malloc(sizeof(opj_t1_t ));
#line 1371
  t1 = (opj_t1_t *)__cil_tmp3;
  }
#line 1372
  if (! t1) {
#line 1373
    return ((opj_t1_t *)((void *)0));
  }
  {
#line 1375
  t1->cinfo = cinfo;
#line 1377
  t1->mqc = mqc_create();
#line 1378
  t1->raw = raw_create();
#line 1380
  t1->data = (int *)((void *)0);
#line 1381
  t1->flags = (flag_t *)((void *)0);
#line 1382
  t1->datasize = 0;
#line 1383
  t1->flagssize = 0;
  }
#line 1385
  return (t1);
}
}
#line 1388 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
void t1_destroy(opj_t1_t *t1 ) 
{ 


  {
#line 1389
  if (t1) {
    {
#line 1391
    mqc_destroy(t1->mqc);
#line 1392
    raw_destroy(t1->raw);
#line 1393
    free(t1->data);
#line 1394
    free(t1->flags);
#line 1395
    free(t1);
    }
  }
  return;
}
}
#line 1399 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
void t1_encode_cblks(opj_t1_t *t1 , opj_tcd_tile_t *tile , opj_tcp_t *tcp ) 
{ 
  int compno ;
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  opj_tcd_tilecomp_t *tilec ;
  opj_tccp_t *tccp ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  int bandconst ;
  double __cil_tmp15 ;
  opj_tcd_precinct_t *prc ;
  opj_tcd_cblk_enc_t *cblk ;
  int *datap ;
  int *tiledp ;
  int cblk_w ;
  int cblk_h ;
  int i ;
  int j ;
  int x ;
  int y ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  opj_bool __cil_tmp28 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp31 ;

  {
#line 1406
  tile->distotile = (double )0;
#line 1408
  compno = 0;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1408
    if (! (compno < tile->numcomps)) {
#line 1408
      goto while_break;
    }
#line 1409
    tilec = tile->comps + compno;
#line 1410
    tccp = tcp->tccps + compno;
#line 1411
    tile_w = tilec->x1 - tilec->x0;
#line 1413
    resno = 0;
    {
#line 1413
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1413
      if (! (resno < tilec->numresolutions)) {
#line 1413
        goto while_break___0;
      }
#line 1414
      res = tilec->resolutions + resno;
#line 1416
      bandno = 0;
      {
#line 1416
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1416
        if (! (bandno < res->numbands)) {
#line 1416
          goto while_break___1;
        }
        {
#line 1417
        band = & res->bands[bandno];
#line 1418
        __cil_tmp15 = floor((double )(band->stepsize * (float )8192));
#line 1418
        bandconst = 67108864 / (int )__cil_tmp15;
#line 1420
        precno = 0;
        }
        {
#line 1420
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1420
          if (! (precno < res->pw * res->ph)) {
#line 1420
            goto while_break___2;
          }
#line 1421
          prc = band->precincts + precno;
#line 1423
          cblkno = 0;
          {
#line 1423
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1423
            if (! (cblkno < prc->cw * prc->ch)) {
#line 1423
              goto while_break___3;
            }
#line 1424
            cblk = prc->cblks.enc + cblkno;
#line 1431
            x = cblk->x0 - band->x0;
#line 1432
            y = cblk->y0 - band->y0;
#line 1433
            if (band->bandno & 1) {
#line 1434
              pres = tilec->resolutions + (resno - 1);
#line 1435
              x += pres->x1 - pres->x0;
            }
#line 1437
            if (band->bandno & 2) {
#line 1438
              pres___0 = tilec->resolutions + (resno - 1);
#line 1439
              y += pres___0->y1 - pres___0->y0;
            }
            {
#line 1442
            __cil_tmp28 = allocate_buffers(t1, cblk->x1 - cblk->x0, cblk->y1 - cblk->y0);
            }
#line 1442
            if (! __cil_tmp28) {
#line 1447
              return;
            }
#line 1450
            datap = t1->data;
#line 1451
            cblk_w = t1->w;
#line 1452
            cblk_h = t1->h;
#line 1454
            tiledp = tilec->data + (y * tile_w + x);
#line 1455
            if (tccp->qmfbid == 1) {
#line 1456
              j = 0;
              {
#line 1456
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1456
                if (! (j < cblk_h)) {
#line 1456
                  goto while_break___4;
                }
#line 1457
                i = 0;
                {
#line 1457
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 1457
                  if (! (i < cblk_w)) {
#line 1457
                    goto while_break___5;
                  }
#line 1458
                  tmp = *(tiledp + (j * tile_w + i));
#line 1459
                  *(datap + (j * cblk_w + i)) = tmp << 6;
#line 1457
                  i ++;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 1456
                j ++;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
#line 1463
              j = 0;
              {
#line 1463
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1463
                if (! (j < cblk_h)) {
#line 1463
                  goto while_break___6;
                }
#line 1464
                i = 0;
                {
#line 1464
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 1464
                  if (! (i < cblk_w)) {
#line 1464
                    goto while_break___7;
                  }
                  {
#line 1465
                  tmp___0 = *(tiledp + (j * tile_w + i));
#line 1466
                  __cil_tmp31 = fix_mul(tmp___0, bandconst);
#line 1466
                  *(datap + (j * cblk_w + i)) = __cil_tmp31 >> 5;
                  }
#line 1464
                  i ++;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 1463
                j ++;
              }
              while_break___6: /* CIL Label */ ;
              }
            }
            {
#line 1474
            t1_encode_cblk(t1, cblk, band->bandno, compno, (tilec->numresolutions - 1) - resno,
                           tccp->qmfbid, (double )band->stepsize, tccp->cblksty, tile->numcomps,
                           tcp->mct, tile);
            }
#line 1423
            cblkno ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1420
          precno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1416
        bandno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1413
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1408
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1494 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/t1.c"
void t1_decode_cblks(opj_t1_t *t1 , opj_tcd_tilecomp_t *tilec , opj_tccp_t *tccp ) 
{ 
  int resno ;
  int bandno ;
  int precno ;
  int cblkno ;
  int tile_w ;
  opj_tcd_resolution_t *res ;
  opj_tcd_band_t *band ;
  opj_tcd_precinct_t *precinct ;
  opj_tcd_cblk_dec_t *cblk ;
  int *datap ;
  int cblk_w ;
  int cblk_h ;
  int x ;
  int y ;
  int i ;
  int j ;
  opj_tcd_resolution_t *pres ;
  opj_tcd_resolution_t *pres___0 ;
  int thresh ;
  int val ;
  int mag ;
  int __cil_tmp25 ;
  int tmp ;
  int *tiledp ;
  int tmp___0 ;
  float *tiledp___0 ;
  float *tiledp2 ;
  float tmp___1 ;
  int *__cil_tmp32 ;
  float *__cil_tmp33 ;

  {
#line 1501
  tile_w = tilec->x1 - tilec->x0;
#line 1503
  resno = 0;
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! (resno < tilec->numresolutions)) {
#line 1503
      goto while_break;
    }
#line 1504
    res = tilec->resolutions + resno;
#line 1506
    bandno = 0;
    {
#line 1506
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1506
      if (! (bandno < res->numbands)) {
#line 1506
        goto while_break___0;
      }
#line 1507
      band = & res->bands[bandno];
#line 1509
      precno = 0;
      {
#line 1509
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1509
        if (! (precno < res->pw * res->ph)) {
#line 1509
          goto while_break___1;
        }
#line 1510
        precinct = band->precincts + precno;
#line 1512
        cblkno = 0;
        {
#line 1512
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1512
          if (! (cblkno < precinct->cw * precinct->ch)) {
#line 1512
            goto while_break___2;
          }
          {
#line 1513
          cblk = precinct->cblks.dec + cblkno;
#line 1519
          t1_decode_cblk(t1, cblk, band->bandno, tccp->roishift, tccp->cblksty);
#line 1526
          x = cblk->x0 - band->x0;
#line 1527
          y = cblk->y0 - band->y0;
          }
#line 1528
          if (band->bandno & 1) {
#line 1529
            pres = tilec->resolutions + (resno - 1);
#line 1530
            x += pres->x1 - pres->x0;
          }
#line 1532
          if (band->bandno & 2) {
#line 1533
            pres___0 = tilec->resolutions + (resno - 1);
#line 1534
            y += pres___0->y1 - pres___0->y0;
          }
#line 1537
          datap = t1->data;
#line 1538
          cblk_w = t1->w;
#line 1539
          cblk_h = t1->h;
#line 1541
          if (tccp->roishift) {
#line 1542
            thresh = 1 << tccp->roishift;
#line 1543
            j = 0;
            {
#line 1543
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1543
              if (! (j < cblk_h)) {
#line 1543
                goto while_break___3;
              }
#line 1544
              i = 0;
              {
#line 1544
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1544
                if (! (i < cblk_w)) {
#line 1544
                  goto while_break___4;
                }
                {
#line 1545
                val = *(datap + (j * cblk_w + i));
#line 1546
                __cil_tmp25 = abs(val);
#line 1546
                mag = __cil_tmp25;
                }
#line 1547
                if (mag >= thresh) {
#line 1548
                  mag >>= tccp->roishift;
#line 1549
                  if (val < 0) {
#line 1549
                    tmp = - mag;
                  } else {
#line 1549
                    tmp = mag;
                  }
#line 1549
                  *(datap + (j * cblk_w + i)) = tmp;
                }
#line 1544
                i ++;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1543
              j ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 1555
          if (tccp->qmfbid == 1) {
#line 1556
            tiledp = tilec->data + (y * tile_w + x);
#line 1557
            j = 0;
            {
#line 1557
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1557
              if (! (j < cblk_h)) {
#line 1557
                goto while_break___5;
              }
#line 1558
              i = 0;
              {
#line 1558
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1558
                if (! (i < cblk_w)) {
#line 1558
                  goto while_break___6;
                }
#line 1559
                tmp___0 = *(datap + (j * cblk_w + i));
#line 1560
                *((int *)tiledp + (j * tile_w + i)) = tmp___0 / 2;
#line 1558
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 1557
              j ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          } else {
#line 1564
            tiledp___0 = (float *)(tilec->data + (y * tile_w + x));
#line 1565
            j = 0;
            {
#line 1565
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1565
              if (! (j < cblk_h)) {
#line 1565
                goto while_break___7;
              }
#line 1566
              tiledp2 = tiledp___0;
#line 1567
              i = 0;
              {
#line 1567
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 1567
                if (! (i < cblk_w)) {
#line 1567
                  goto while_break___8;
                }
#line 1568
                tmp___1 = (float )*datap * band->stepsize;
#line 1569
                *tiledp2 = tmp___1;
#line 1570
                datap ++;
#line 1571
                tiledp2 ++;
#line 1567
                i ++;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 1573
              tiledp___0 += tile_w;
#line 1565
              j ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
          {
#line 1576
          free(cblk->data);
#line 1577
          free(cblk->segs);
          }
#line 1512
          cblkno ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1579
        free(precinct->cblks.dec);
#line 1580
        precinct->cblks.dec = (opj_tcd_cblk_dec_t *)((void *)0);
        }
#line 1509
        precno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1506
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1503
    resno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 45 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/raw.c"
opj_raw_t *raw_create(void) 
{ 
  opj_raw_t *raw ;
  void *__cil_tmp2 ;

  {
  {
#line 46
  __cil_tmp2 = malloc(sizeof(opj_raw_t ));
#line 46
  raw = (opj_raw_t *)__cil_tmp2;
  }
#line 47
  return (raw);
}
}
#line 50 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/raw.c"
void raw_destroy(opj_raw_t *raw ) 
{ 


  {
#line 51
  if (raw) {
    {
#line 52
    free(raw);
    }
  }
  return;
}
}
#line 56 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/raw.c"
int raw_numbytes(opj_raw_t *raw ) 
{ 


  {
#line 57
  return ((int )(raw->bp - raw->start));
}
}
#line 60 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/raw.c"
void raw_init_dec(opj_raw_t *raw , unsigned char *bp , int len ) 
{ 


  {
#line 61
  raw->start = bp;
#line 62
  raw->lenmax = (unsigned int )len;
#line 63
  raw->len = (unsigned int )0;
#line 64
  raw->c = (unsigned char )0;
#line 65
  raw->ct = (unsigned int )0;
  return;
}
}
#line 68 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/raw.c"
int raw_decode(opj_raw_t *raw ) 
{ 
  int d ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
#line 70
  if (raw->ct == 0U) {
#line 71
    raw->ct = (unsigned int )8;
#line 72
    if (raw->len == raw->lenmax) {
#line 73
      raw->c = (unsigned char )255;
    } else {
#line 75
      if ((int )raw->c == 255) {
#line 76
        raw->ct = (unsigned int )7;
      }
#line 78
      raw->c = *(raw->start + raw->len);
#line 79
      (raw->len) ++;
    }
  }
#line 82
  __cil_tmp4 = raw->ct;
#line 82
  (raw->ct) --;
#line 83
  d = ((int )raw->c >> raw->ct) & 1;
#line 85
  return (d);
}
}
#line 46 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
static opj_bool pi_next_lrcp(opj_pi_iterator_t *pi ) ;
#line 52
static opj_bool pi_next_rlcp(opj_pi_iterator_t *pi ) ;
#line 58
static opj_bool pi_next_rpcl(opj_pi_iterator_t *pi ) ;
#line 64
static opj_bool pi_next_pcrl(opj_pi_iterator_t *pi ) ;
#line 70
static opj_bool pi_next_cprl(opj_pi_iterator_t *pi ) ;
#line 82 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
static opj_bool pi_next_lrcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___5 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 83
  comp = (opj_pi_comp_t *)((void *)0);
#line 84
  res = (opj_pi_resolution_t *)((void *)0);
#line 85
  index___5 = (long )0;
#line 87
  if (! pi->first) {
#line 88
    comp = pi->comps + pi->compno;
#line 89
    res = comp->resolutions + pi->resno;
#line 90
    goto LABEL_SKIP;
  } else {
#line 92
    pi->first = 0;
  }
#line 95
  pi->layno = pi->poc.layno0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (pi->layno < pi->poc.layno1)) {
#line 95
      goto while_break;
    }
#line 96
    pi->resno = pi->poc.resno0;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (pi->resno < pi->poc.resno1)) {
#line 96
        goto while_break___0;
      }
#line 98
      pi->compno = pi->poc.compno0;
      {
#line 98
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 98
        if (! (pi->compno < pi->poc.compno1)) {
#line 98
          goto while_break___1;
        }
#line 99
        comp = pi->comps + pi->compno;
#line 100
        if (pi->resno >= comp->numresolutions) {
#line 101
          goto while_continue___1;
        }
#line 103
        res = comp->resolutions + pi->resno;
#line 104
        if (! pi->tp_on) {
#line 105
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 107
        pi->precno = pi->poc.precno0;
        {
#line 107
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 107
          if (! (pi->precno < pi->poc.precno1)) {
#line 107
            goto while_break___2;
          }
#line 108
          index___5 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 109
          if (! *(pi->include + index___5)) {
#line 110
            *(pi->include + index___5) = (short )1;
#line 111
            return (1);
          }
          LABEL_SKIP: ;
#line 107
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 98
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 97
      (pi->resno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 95
    (pi->layno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0);
}
}
#line 122 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
static opj_bool pi_next_rlcp(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___6 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 123
  comp = (opj_pi_comp_t *)((void *)0);
#line 124
  res = (opj_pi_resolution_t *)((void *)0);
#line 125
  index___6 = (long )0;
#line 127
  if (! pi->first) {
#line 128
    comp = pi->comps + pi->compno;
#line 129
    res = comp->resolutions + pi->resno;
#line 130
    goto LABEL_SKIP;
  } else {
#line 132
    pi->first = 0;
  }
#line 135
  pi->resno = pi->poc.resno0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (pi->resno < pi->poc.resno1)) {
#line 135
      goto while_break;
    }
#line 136
    pi->layno = pi->poc.layno0;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (pi->layno < pi->poc.layno1)) {
#line 136
        goto while_break___0;
      }
#line 137
      pi->compno = pi->poc.compno0;
      {
#line 137
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 137
        if (! (pi->compno < pi->poc.compno1)) {
#line 137
          goto while_break___1;
        }
#line 138
        comp = pi->comps + pi->compno;
#line 139
        if (pi->resno >= comp->numresolutions) {
#line 140
          goto while_continue___1;
        }
#line 142
        res = comp->resolutions + pi->resno;
#line 143
        if (! pi->tp_on) {
#line 144
          pi->poc.precno1 = res->pw * res->ph;
        }
#line 146
        pi->precno = pi->poc.precno0;
        {
#line 146
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 146
          if (! (pi->precno < pi->poc.precno1)) {
#line 146
            goto while_break___2;
          }
#line 147
          index___6 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 148
          if (! *(pi->include + index___6)) {
#line 149
            *(pi->include + index___6) = (short )1;
#line 150
            return (1);
          }
          LABEL_SKIP: ;
#line 146
          (pi->precno) ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 137
        (pi->compno) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 136
      (pi->layno) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 135
    (pi->resno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (0);
}
}
#line 161 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
static opj_bool pi_next_rpcl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___7 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
#line 162
  comp = (opj_pi_comp_t *)((void *)0);
#line 163
  res = (opj_pi_resolution_t *)((void *)0);
#line 164
  index___7 = (long )0;
#line 166
  if (! pi->first) {
#line 167
    goto LABEL_SKIP;
  } else {
#line 170
    pi->first = 0;
#line 171
    pi->dx = 0;
#line 172
    pi->dy = 0;
#line 173
    compno = 0;
    {
#line 173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 173
      if (! (compno < pi->numcomps)) {
#line 173
        goto while_break;
      }
#line 174
      comp = pi->comps + compno;
#line 175
      resno = 0;
      {
#line 175
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 175
        if (! (resno < comp->numresolutions)) {
#line 175
          goto while_break___0;
        }
#line 177
        res = comp->resolutions + resno;
#line 178
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 179
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 180
        if (! pi->dx) {
#line 180
          tmp = dx;
        } else {
          {
#line 180
          __cil_tmp9 = int_min(pi->dx, dx);
#line 180
          tmp = __cil_tmp9;
          }
        }
#line 180
        pi->dx = tmp;
#line 181
        if (! pi->dy) {
#line 181
          tmp___0 = dy;
        } else {
          {
#line 181
          __cil_tmp11 = int_min(pi->dy, dy);
#line 181
          tmp___0 = __cil_tmp11;
          }
        }
#line 181
        pi->dy = tmp___0;
#line 175
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 173
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 185
  if (! pi->tp_on) {
#line 186
    pi->poc.ty0 = pi->ty0;
#line 187
    pi->poc.tx0 = pi->tx0;
#line 188
    pi->poc.ty1 = pi->ty1;
#line 189
    pi->poc.tx1 = pi->tx1;
  }
#line 191
  pi->resno = pi->poc.resno0;
  {
#line 191
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 191
    if (! (pi->resno < pi->poc.resno1)) {
#line 191
      goto while_break___1;
    }
#line 192
    pi->y = pi->poc.ty0;
    {
#line 192
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 192
      if (! (pi->y < pi->poc.ty1)) {
#line 192
        goto while_break___2;
      }
#line 193
      pi->x = pi->poc.tx0;
      {
#line 193
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 193
        if (! (pi->x < pi->poc.tx1)) {
#line 193
          goto while_break___3;
        }
#line 194
        pi->compno = pi->poc.compno0;
        {
#line 194
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 194
          if (! (pi->compno < pi->poc.compno1)) {
#line 194
            goto while_break___4;
          }
#line 200
          comp = pi->comps + pi->compno;
#line 201
          if (pi->resno >= comp->numresolutions) {
#line 202
            goto while_continue___4;
          }
          {
#line 204
          res = comp->resolutions + pi->resno;
#line 205
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 206
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 207
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 208
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 209
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 210
          rpx = res->pdx + levelno;
#line 211
          rpy = res->pdy + levelno;
          }
#line 212
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 213
            goto while_continue___4;
          }
#line 215
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 216
            goto while_continue___4;
          }
#line 219
          if (res->pw == 0) {
#line 219
            goto while_continue___4;
          } else
#line 219
          if (res->ph == 0) {
#line 219
            goto while_continue___4;
          }
#line 221
          if (trx0 == trx1) {
#line 221
            goto while_continue___4;
          } else
#line 221
          if (try0 == try1) {
#line 221
            goto while_continue___4;
          }
          {
#line 223
          __cil_tmp30 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 223
          __cil_tmp28 = int_ceildiv(pi->x, comp->dx << levelno);
#line 223
          __cil_tmp29 = int_floordivpow2(__cil_tmp28, res->pdx);
#line 223
          prci = __cil_tmp29 - __cil_tmp30;
#line 225
          __cil_tmp33 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 225
          __cil_tmp31 = int_ceildiv(pi->y, comp->dy << levelno);
#line 225
          __cil_tmp32 = int_floordivpow2(__cil_tmp31, res->pdy);
#line 225
          prcj = __cil_tmp32 - __cil_tmp33;
#line 227
          pi->precno = prci + prcj * res->pw;
#line 228
          pi->layno = pi->poc.layno0;
          }
          {
#line 228
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 228
            if (! (pi->layno < pi->poc.layno1)) {
#line 228
              goto while_break___5;
            }
#line 229
            index___7 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 230
            if (! *(pi->include + index___7)) {
#line 231
              *(pi->include + index___7) = (short )1;
#line 232
              return (1);
            }
            LABEL_SKIP: ;
#line 228
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 194
          (pi->compno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 193
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 192
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 191
    (pi->resno) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 241
  return (0);
}
}
#line 244 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
static opj_bool pi_next_pcrl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___8 ;
  int compno ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;

  {
#line 245
  comp = (opj_pi_comp_t *)((void *)0);
#line 246
  res = (opj_pi_resolution_t *)((void *)0);
#line 247
  index___8 = (long )0;
#line 249
  if (! pi->first) {
#line 250
    comp = pi->comps + pi->compno;
#line 251
    goto LABEL_SKIP;
  } else {
#line 254
    pi->first = 0;
#line 255
    pi->dx = 0;
#line 256
    pi->dy = 0;
#line 257
    compno = 0;
    {
#line 257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 257
      if (! (compno < pi->numcomps)) {
#line 257
        goto while_break;
      }
#line 258
      comp = pi->comps + compno;
#line 259
      resno = 0;
      {
#line 259
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 259
        if (! (resno < comp->numresolutions)) {
#line 259
          goto while_break___0;
        }
#line 261
        res = comp->resolutions + resno;
#line 262
        dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 263
        dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 264
        if (! pi->dx) {
#line 264
          tmp = dx;
        } else {
          {
#line 264
          __cil_tmp9 = int_min(pi->dx, dx);
#line 264
          tmp = __cil_tmp9;
          }
        }
#line 264
        pi->dx = tmp;
#line 265
        if (! pi->dy) {
#line 265
          tmp___0 = dy;
        } else {
          {
#line 265
          __cil_tmp11 = int_min(pi->dy, dy);
#line 265
          tmp___0 = __cil_tmp11;
          }
        }
#line 265
        pi->dy = tmp___0;
#line 259
        resno ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 257
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 269
  if (! pi->tp_on) {
#line 270
    pi->poc.ty0 = pi->ty0;
#line 271
    pi->poc.tx0 = pi->tx0;
#line 272
    pi->poc.ty1 = pi->ty1;
#line 273
    pi->poc.tx1 = pi->tx1;
  }
#line 275
  pi->y = pi->poc.ty0;
  {
#line 275
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 275
    if (! (pi->y < pi->poc.ty1)) {
#line 275
      goto while_break___1;
    }
#line 276
    pi->x = pi->poc.tx0;
    {
#line 276
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 276
      if (! (pi->x < pi->poc.tx1)) {
#line 276
        goto while_break___2;
      }
#line 277
      pi->compno = pi->poc.compno0;
      {
#line 277
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 277
        if (! (pi->compno < pi->poc.compno1)) {
#line 277
          goto while_break___3;
        }
#line 278
        comp = pi->comps + pi->compno;
#line 279
        pi->resno = pi->poc.resno0;
        {
#line 279
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 279
          if (! (pi->resno < __cil_tmp15)) {
#line 279
            goto while_break___4;
          }
          {
#line 285
          res = comp->resolutions + pi->resno;
#line 286
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 287
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 288
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 289
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 290
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 291
          rpx = res->pdx + levelno;
#line 292
          rpy = res->pdy + levelno;
          }
#line 293
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 294
            goto while_continue___4;
          }
#line 296
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 297
            goto while_continue___4;
          }
#line 300
          if (res->pw == 0) {
#line 300
            goto while_continue___4;
          } else
#line 300
          if (res->ph == 0) {
#line 300
            goto while_continue___4;
          }
#line 302
          if (trx0 == trx1) {
#line 302
            goto while_continue___4;
          } else
#line 302
          if (try0 == try1) {
#line 302
            goto while_continue___4;
          }
          {
#line 304
          __cil_tmp31 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 304
          __cil_tmp29 = int_ceildiv(pi->x, comp->dx << levelno);
#line 304
          __cil_tmp30 = int_floordivpow2(__cil_tmp29, res->pdx);
#line 304
          prci = __cil_tmp30 - __cil_tmp31;
#line 306
          __cil_tmp34 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 306
          __cil_tmp32 = int_ceildiv(pi->y, comp->dy << levelno);
#line 306
          __cil_tmp33 = int_floordivpow2(__cil_tmp32, res->pdy);
#line 306
          prcj = __cil_tmp33 - __cil_tmp34;
#line 308
          pi->precno = prci + prcj * res->pw;
#line 309
          pi->layno = pi->poc.layno0;
          }
          {
#line 309
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 309
            if (! (pi->layno < pi->poc.layno1)) {
#line 309
              goto while_break___5;
            }
#line 310
            index___8 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 311
            if (! *(pi->include + index___8)) {
#line 312
              *(pi->include + index___8) = (short )1;
#line 313
              return (1);
            }
            LABEL_SKIP: ;
#line 309
            (pi->layno) ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 279
          (pi->resno) ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 277
        (pi->compno) ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 276
      pi->x += pi->dx - pi->x % pi->dx;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 275
    pi->y += pi->dy - pi->y % pi->dy;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 322
  return (0);
}
}
#line 325 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
static opj_bool pi_next_cprl(opj_pi_iterator_t *pi ) 
{ 
  opj_pi_comp_t *comp ;
  opj_pi_resolution_t *res ;
  long index___9 ;
  int resno ;
  int dx ;
  int dy ;
  int __cil_tmp8 ;
  int tmp ;
  int __cil_tmp10 ;
  int tmp___0 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int levelno ;
  int trx0 ;
  int try0 ;
  int trx1 ;
  int try1 ;
  int rpx ;
  int rpy ;
  int prci ;
  int prcj ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;

  {
#line 326
  comp = (opj_pi_comp_t *)((void *)0);
#line 327
  res = (opj_pi_resolution_t *)((void *)0);
#line 328
  index___9 = (long )0;
#line 330
  if (! pi->first) {
#line 331
    comp = pi->comps + pi->compno;
#line 332
    goto LABEL_SKIP;
  } else {
#line 334
    pi->first = 0;
  }
#line 337
  pi->compno = pi->poc.compno0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (pi->compno < pi->poc.compno1)) {
#line 337
      goto while_break;
    }
#line 339
    comp = pi->comps + pi->compno;
#line 340
    pi->dx = 0;
#line 341
    pi->dy = 0;
#line 342
    resno = 0;
    {
#line 342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 342
      if (! (resno < comp->numresolutions)) {
#line 342
        goto while_break___0;
      }
#line 344
      res = comp->resolutions + resno;
#line 345
      dx = comp->dx * (1 << (((res->pdx + comp->numresolutions) - 1) - resno));
#line 346
      dy = comp->dy * (1 << (((res->pdy + comp->numresolutions) - 1) - resno));
#line 347
      if (! pi->dx) {
#line 347
        tmp = dx;
      } else {
        {
#line 347
        __cil_tmp8 = int_min(pi->dx, dx);
#line 347
        tmp = __cil_tmp8;
        }
      }
#line 347
      pi->dx = tmp;
#line 348
      if (! pi->dy) {
#line 348
        tmp___0 = dy;
      } else {
        {
#line 348
        __cil_tmp10 = int_min(pi->dy, dy);
#line 348
        tmp___0 = __cil_tmp10;
        }
      }
#line 348
      pi->dy = tmp___0;
#line 342
      resno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 350
    if (! pi->tp_on) {
#line 351
      pi->poc.ty0 = pi->ty0;
#line 352
      pi->poc.tx0 = pi->tx0;
#line 353
      pi->poc.ty1 = pi->ty1;
#line 354
      pi->poc.tx1 = pi->tx1;
    }
#line 356
    pi->y = pi->poc.ty0;
    {
#line 356
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 356
      if (! (pi->y < pi->poc.ty1)) {
#line 356
        goto while_break___1;
      }
#line 357
      pi->x = pi->poc.tx0;
      {
#line 357
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 357
        if (! (pi->x < pi->poc.tx1)) {
#line 357
          goto while_break___2;
        }
#line 358
        pi->resno = pi->poc.resno0;
        {
#line 358
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 358
          if (! (pi->resno < __cil_tmp13)) {
#line 358
            goto while_break___3;
          }
          {
#line 364
          res = comp->resolutions + pi->resno;
#line 365
          levelno = (comp->numresolutions - 1) - pi->resno;
#line 366
          trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
#line 367
          try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
#line 368
          trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
#line 369
          try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
#line 370
          rpx = res->pdx + levelno;
#line 371
          rpy = res->pdy + levelno;
          }
#line 372
          if (! (pi->y % (comp->dy << rpy) == 0 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpy)))) {
#line 373
            goto while_continue___3;
          }
#line 375
          if (! (pi->x % (comp->dx << rpx) == 0 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
#line 376
            goto while_continue___3;
          }
#line 379
          if (res->pw == 0) {
#line 379
            goto while_continue___3;
          } else
#line 379
          if (res->ph == 0) {
#line 379
            goto while_continue___3;
          }
#line 381
          if (trx0 == trx1) {
#line 381
            goto while_continue___3;
          } else
#line 381
          if (try0 == try1) {
#line 381
            goto while_continue___3;
          }
          {
#line 383
          __cil_tmp29 = int_floordivpow2(trx0, res->pdx);
          }
          {
#line 383
          __cil_tmp27 = int_ceildiv(pi->x, comp->dx << levelno);
#line 383
          __cil_tmp28 = int_floordivpow2(__cil_tmp27, res->pdx);
#line 383
          prci = __cil_tmp28 - __cil_tmp29;
#line 385
          __cil_tmp32 = int_floordivpow2(try0, res->pdy);
          }
          {
#line 385
          __cil_tmp30 = int_ceildiv(pi->y, comp->dy << levelno);
#line 385
          __cil_tmp31 = int_floordivpow2(__cil_tmp30, res->pdy);
#line 385
          prcj = __cil_tmp31 - __cil_tmp32;
#line 387
          pi->precno = prci + prcj * res->pw;
#line 388
          pi->layno = pi->poc.layno0;
          }
          {
#line 388
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 388
            if (! (pi->layno < pi->poc.layno1)) {
#line 388
              goto while_break___4;
            }
#line 389
            index___9 = (long )(((pi->layno * pi->step_l + pi->resno * pi->step_r) + pi->compno * pi->step_c) + pi->precno * pi->step_p);
#line 390
            if (! *(pi->include + index___9)) {
#line 391
              *(pi->include + index___9) = (short )1;
#line 392
              return (1);
            }
            LABEL_SKIP: ;
#line 388
            (pi->layno) ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 358
          (pi->resno) ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 357
        pi->x += pi->dx - pi->x % pi->dx;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 356
      pi->y += pi->dy - pi->y % pi->dy;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 337
    (pi->compno) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return (0);
}
}
#line 410 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_create_decode(opj_image_t *image , opj_cp_t *cp , int tileno ) 
{ 
  int p ;
  int q ;
  int compno ;
  int resno ;
  int pino ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp12 ;
  int maxres ;
  int maxprec ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  void *__cil_tmp52 ;
  int __cil_tmp53 ;

  {
  {
#line 413
  pi = (opj_pi_iterator_t *)((void *)0);
#line 414
  tcp = (opj_tcp_t *)((void *)0);
#line 415
  tccp = (opj_tccp_t *)((void *)0);
#line 417
  tcp = cp->tcps + tileno;
#line 419
  __cil_tmp12 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 419
  pi = (opj_pi_iterator_t *)__cil_tmp12;
  }
#line 420
  if (! pi) {
#line 422
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 425
  pino = 0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (pino < tcp->numpocs + 1)) {
#line 425
      goto while_break;
    }
    {
#line 426
    maxres = 0;
#line 427
    maxprec = 0;
#line 428
    p = tileno % cp->tw;
#line 429
    q = tileno / cp->tw;
#line 431
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 432
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 433
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 434
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 435
    (pi + pino)->numcomps = image->numcomps;
#line 437
    __cil_tmp19 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 437
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp19;
    }
#line 438
    if (! (pi + pino)->comps) {
      {
#line 440
      pi_destroy(pi, cp, tileno);
      }
#line 441
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 444
    compno = 0;
    {
#line 444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 444
      if (! (compno < pi->numcomps)) {
#line 444
        goto while_break___0;
      }
      {
#line 446
      comp = (pi + pino)->comps + compno;
#line 447
      tccp = tcp->tccps + compno;
#line 448
      comp->dx = (image->comps + compno)->dx;
#line 449
      comp->dy = (image->comps + compno)->dy;
#line 450
      comp->numresolutions = tccp->numresolutions;
#line 452
      __cil_tmp25 = calloc((unsigned long )comp->numresolutions, sizeof(opj_pi_resolution_t ));
#line 452
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp25;
      }
#line 453
      if (! comp->resolutions) {
        {
#line 455
        pi_destroy(pi, cp, tileno);
        }
#line 456
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 459
      tcx0 = int_ceildiv(pi->tx0, comp->dx);
#line 460
      tcy0 = int_ceildiv(pi->ty0, comp->dy);
#line 461
      tcx1 = int_ceildiv(pi->tx1, comp->dx);
#line 462
      tcy1 = int_ceildiv(pi->ty1, comp->dy);
      }
#line 463
      if (comp->numresolutions > maxres) {
#line 464
        maxres = comp->numresolutions;
      }
#line 467
      resno = 0;
      {
#line 467
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 467
        if (! (resno < comp->numresolutions)) {
#line 467
          goto while_break___1;
        }
#line 471
        res = comp->resolutions + resno;
#line 472
        if (tccp->csty & 1) {
#line 473
          res->pdx = tccp->prcw[resno];
#line 474
          res->pdy = tccp->prch[resno];
        } else {
#line 476
          res->pdx = 15;
#line 477
          res->pdy = 15;
        }
        {
#line 479
        levelno = (comp->numresolutions - 1) - resno;
#line 480
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 481
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 482
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 483
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 484
        __cil_tmp44 = int_floordivpow2(rx0, res->pdx);
#line 484
        px0 = __cil_tmp44 << res->pdx;
#line 485
        __cil_tmp45 = int_floordivpow2(ry0, res->pdy);
#line 485
        py0 = __cil_tmp45 << res->pdy;
#line 486
        __cil_tmp46 = int_ceildivpow2(rx1, res->pdx);
#line 486
        px1 = __cil_tmp46 << res->pdx;
#line 487
        __cil_tmp47 = int_ceildivpow2(ry1, res->pdy);
#line 487
        py1 = __cil_tmp47 << res->pdy;
        }
#line 488
        if (rx0 == rx1) {
#line 488
          tmp = 0;
        } else {
#line 488
          tmp = (px1 - px0) >> res->pdx;
        }
#line 488
        res->pw = tmp;
#line 489
        if (ry0 == ry1) {
#line 489
          tmp___0 = 0;
        } else {
#line 489
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 489
        res->ph = tmp___0;
#line 491
        if (res->pw * res->ph > maxprec) {
#line 492
          maxprec = res->pw * res->ph;
        }
#line 467
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 444
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 498
    tccp = tcp->tccps + 0;
#line 499
    (pi + pino)->step_p = 1;
#line 500
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 501
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 502
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 504
    if (pino == 0) {
      {
#line 505
      __cil_tmp52 = calloc((unsigned long )(((image->numcomps * maxres) * tcp->numlayers) * maxprec),
                           sizeof(short ));
#line 505
      (pi + pino)->include = (short *)__cil_tmp52;
      }
#line 506
      if (! (pi + pino)->include) {
        {
#line 508
        pi_destroy(pi, cp, tileno);
        }
#line 509
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 513
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 516
    if (tcp->POC == 0) {
#line 517
      (pi + pino)->first = 1;
#line 518
      (pi + pino)->poc.resno0 = 0;
#line 519
      (pi + pino)->poc.compno0 = 0;
#line 520
      (pi + pino)->poc.layno1 = tcp->numlayers;
#line 521
      (pi + pino)->poc.resno1 = maxres;
#line 522
      (pi + pino)->poc.compno1 = image->numcomps;
#line 523
      (pi + pino)->poc.prg = tcp->prg;
    } else {
#line 525
      (pi + pino)->first = 1;
#line 526
      (pi + pino)->poc.resno0 = tcp->pocs[pino].resno0;
#line 527
      (pi + pino)->poc.compno0 = tcp->pocs[pino].compno0;
#line 528
      (pi + pino)->poc.layno1 = tcp->pocs[pino].layno1;
#line 529
      (pi + pino)->poc.resno1 = tcp->pocs[pino].resno1;
#line 530
      (pi + pino)->poc.compno1 = tcp->pocs[pino].compno1;
#line 531
      (pi + pino)->poc.prg = tcp->pocs[pino].prg;
    }
#line 533
    (pi + pino)->poc.layno0 = 0;
#line 534
    (pi + pino)->poc.precno0 = 0;
#line 535
    (pi + pino)->poc.precno1 = maxprec;
#line 425
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return (pi);
}
}
#line 543 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image , opj_cp_t *cp , int tileno ,
                                        J2K_T2_MODE t2_mode ) 
{ 
  int p ;
  int q ;
  int pino ;
  int compno ;
  int resno ;
  int maxres ;
  int maxprec ;
  opj_pi_iterator_t *pi ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  int tcx0 ;
  int tcy0 ;
  int tcx1 ;
  int tcy1 ;
  opj_pi_comp_t *comp ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int levelno ;
  int rx0 ;
  int ry0 ;
  int rx1 ;
  int ry1 ;
  int px0 ;
  int py0 ;
  int px1 ;
  int py1 ;
  opj_pi_resolution_t *res ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  opj_pi_comp_t *comp___0 ;
  int dx ;
  int dy ;
  opj_pi_resolution_t *res___0 ;
  int __cil_tmp57 ;
  int tmp___1 ;
  int __cil_tmp59 ;
  int tmp___2 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  void *__cil_tmp63 ;
  int tmp___3 ;
  int __cil_tmp65 ;

  {
  {
#line 546
  maxres = 0;
#line 547
  maxprec = 0;
#line 548
  pi = (opj_pi_iterator_t *)((void *)0);
#line 549
  tcp = (opj_tcp_t *)((void *)0);
#line 550
  tccp = (opj_tccp_t *)((void *)0);
#line 552
  tcp = cp->tcps + tileno;
#line 554
  __cil_tmp15 = calloc((unsigned long )(tcp->numpocs + 1), sizeof(opj_pi_iterator_t ));
#line 554
  pi = (opj_pi_iterator_t *)__cil_tmp15;
  }
#line 555
  if (! pi) {
#line 555
    return ((opj_pi_iterator_t *)((void *)0));
  }
#line 556
  pi->tp_on = cp->tp_on;
#line 558
  pino = 0;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (pino < tcp->numpocs + 1)) {
#line 558
      goto while_break;
    }
    {
#line 559
    p = tileno % cp->tw;
#line 560
    q = tileno / cp->tw;
#line 562
    (pi + pino)->tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
#line 563
    (pi + pino)->ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
#line 564
    (pi + pino)->tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
#line 565
    (pi + pino)->ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
#line 566
    (pi + pino)->numcomps = image->numcomps;
#line 568
    __cil_tmp20 = calloc((unsigned long )image->numcomps, sizeof(opj_pi_comp_t ));
#line 568
    (pi + pino)->comps = (opj_pi_comp_t *)__cil_tmp20;
    }
#line 569
    if (! (pi + pino)->comps) {
      {
#line 570
      pi_destroy(pi, cp, tileno);
      }
#line 571
      return ((opj_pi_iterator_t *)((void *)0));
    }
#line 574
    compno = 0;
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 574
      if (! (compno < (pi + pino)->numcomps)) {
#line 574
        goto while_break___0;
      }
      {
#line 576
      comp = (pi + pino)->comps + compno;
#line 577
      tccp = tcp->tccps + compno;
#line 578
      comp->dx = (image->comps + compno)->dx;
#line 579
      comp->dy = (image->comps + compno)->dy;
#line 580
      comp->numresolutions = tccp->numresolutions;
#line 582
      __cil_tmp26 = malloc((unsigned long )comp->numresolutions * sizeof(opj_pi_resolution_t ));
#line 582
      comp->resolutions = (opj_pi_resolution_t *)__cil_tmp26;
      }
#line 583
      if (! comp->resolutions) {
        {
#line 584
        pi_destroy(pi, cp, tileno);
        }
#line 585
        return ((opj_pi_iterator_t *)((void *)0));
      }
      {
#line 588
      tcx0 = int_ceildiv((pi + pino)->tx0, comp->dx);
#line 589
      tcy0 = int_ceildiv((pi + pino)->ty0, comp->dy);
#line 590
      tcx1 = int_ceildiv((pi + pino)->tx1, comp->dx);
#line 591
      tcy1 = int_ceildiv((pi + pino)->ty1, comp->dy);
      }
#line 592
      if (comp->numresolutions > maxres) {
#line 593
        maxres = comp->numresolutions;
      }
#line 596
      resno = 0;
      {
#line 596
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 596
        if (! (resno < comp->numresolutions)) {
#line 596
          goto while_break___1;
        }
#line 600
        res = comp->resolutions + resno;
#line 601
        if (tccp->csty & 1) {
#line 602
          res->pdx = tccp->prcw[resno];
#line 603
          res->pdy = tccp->prch[resno];
        } else {
#line 605
          res->pdx = 15;
#line 606
          res->pdy = 15;
        }
        {
#line 608
        levelno = (comp->numresolutions - 1) - resno;
#line 609
        rx0 = int_ceildivpow2(tcx0, levelno);
#line 610
        ry0 = int_ceildivpow2(tcy0, levelno);
#line 611
        rx1 = int_ceildivpow2(tcx1, levelno);
#line 612
        ry1 = int_ceildivpow2(tcy1, levelno);
#line 613
        __cil_tmp45 = int_floordivpow2(rx0, res->pdx);
#line 613
        px0 = __cil_tmp45 << res->pdx;
#line 614
        __cil_tmp46 = int_floordivpow2(ry0, res->pdy);
#line 614
        py0 = __cil_tmp46 << res->pdy;
#line 615
        __cil_tmp47 = int_ceildivpow2(rx1, res->pdx);
#line 615
        px1 = __cil_tmp47 << res->pdx;
#line 616
        __cil_tmp48 = int_ceildivpow2(ry1, res->pdy);
#line 616
        py1 = __cil_tmp48 << res->pdy;
        }
#line 617
        if (rx0 == rx1) {
#line 617
          tmp = 0;
        } else {
#line 617
          tmp = (px1 - px0) >> res->pdx;
        }
#line 617
        res->pw = tmp;
#line 618
        if (ry0 == ry1) {
#line 618
          tmp___0 = 0;
        } else {
#line 618
          tmp___0 = (py1 - py0) >> res->pdy;
        }
#line 618
        res->ph = tmp___0;
#line 620
        if (res->pw * res->ph > maxprec) {
#line 621
          maxprec = res->pw * res->ph;
        }
#line 596
        resno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 574
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 626
    tccp = tcp->tccps + 0;
#line 627
    (pi + pino)->step_p = 1;
#line 628
    (pi + pino)->step_c = maxprec * (pi + pino)->step_p;
#line 629
    (pi + pino)->step_r = image->numcomps * (pi + pino)->step_c;
#line 630
    (pi + pino)->step_l = maxres * (pi + pino)->step_r;
#line 632
    compno = 0;
    {
#line 632
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 632
      if (! (compno < pi->numcomps)) {
#line 632
        goto while_break___2;
      }
#line 633
      comp___0 = pi->comps + compno;
#line 634
      resno = 0;
      {
#line 634
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 634
        if (! (resno < comp___0->numresolutions)) {
#line 634
          goto while_break___3;
        }
#line 636
        res___0 = comp___0->resolutions + resno;
#line 637
        dx = comp___0->dx * (1 << (((res___0->pdx + comp___0->numresolutions) - 1) - resno));
#line 638
        dy = comp___0->dy * (1 << (((res___0->pdy + comp___0->numresolutions) - 1) - resno));
#line 639
        if (! pi->dx) {
#line 639
          tmp___1 = dx;
        } else {
          {
#line 639
          __cil_tmp57 = int_min(pi->dx, dx);
#line 639
          tmp___1 = __cil_tmp57;
          }
        }
#line 639
        (pi + pino)->dx = tmp___1;
#line 640
        if (! pi->dy) {
#line 640
          tmp___2 = dy;
        } else {
          {
#line 640
          __cil_tmp59 = int_min(pi->dy, dy);
#line 640
          tmp___2 = __cil_tmp59;
          }
        }
#line 640
        (pi + pino)->dy = tmp___2;
#line 634
        resno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 632
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 644
    if (pino == 0) {
      {
#line 645
      __cil_tmp63 = calloc((unsigned long )(tcp->numlayers * (pi + pino)->step_l),
                           sizeof(short ));
#line 645
      (pi + pino)->include = (short *)__cil_tmp63;
      }
#line 646
      if (! (pi + pino)->include) {
        {
#line 647
        pi_destroy(pi, cp, tileno);
        }
#line 648
        return ((opj_pi_iterator_t *)((void *)0));
      }
    } else {
#line 652
      (pi + pino)->include = (pi + (pino - 1))->include;
    }
#line 656
    if (tcp->POC) {
#line 656
      if ((unsigned int )cp->cinema) {
        _L___10: /* CIL Label */ 
#line 657
        tcp->pocs[pino].compS = tcp->pocs[pino].compno0;
#line 658
        tcp->pocs[pino].compE = tcp->pocs[pino].compno1;
#line 659
        tcp->pocs[pino].resS = tcp->pocs[pino].resno0;
#line 660
        tcp->pocs[pino].resE = tcp->pocs[pino].resno1;
#line 661
        tcp->pocs[pino].layE = tcp->pocs[pino].layno1;
#line 662
        tcp->pocs[pino].prg = tcp->pocs[pino].prg1;
#line 663
        if (pino > 0) {
#line 664
          if (tcp->pocs[pino].layE > tcp->pocs[pino - 1].layE) {
#line 664
            tmp___3 = tcp->pocs[pino - 1].layE;
          } else {
#line 664
            tmp___3 = 0;
          }
#line 664
          tcp->pocs[pino].layS = tmp___3;
        }
      } else
#line 656
      if (! cp->cinema) {
#line 656
        if ((unsigned int )t2_mode == 1U) {
#line 656
          goto _L___10;
        } else {
#line 656
          goto _L;
        }
      } else {
#line 656
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 666
      tcp->pocs[pino].compS = 0;
#line 667
      tcp->pocs[pino].compE = image->numcomps;
#line 668
      tcp->pocs[pino].resS = 0;
#line 669
      tcp->pocs[pino].resE = maxres;
#line 670
      tcp->pocs[pino].layS = 0;
#line 671
      tcp->pocs[pino].layE = tcp->numlayers;
#line 672
      tcp->pocs[pino].prg = tcp->prg;
    }
#line 674
    tcp->pocs[pino].prcS = 0;
#line 675
    tcp->pocs[pino].prcE = maxprec;
#line 676
    tcp->pocs[pino].txS = (pi + pino)->tx0;
#line 677
    tcp->pocs[pino].txE = (pi + pino)->tx1;
#line 678
    tcp->pocs[pino].tyS = (pi + pino)->ty0;
#line 679
    tcp->pocs[pino].tyE = (pi + pino)->ty1;
#line 680
    tcp->pocs[pino].dx = (pi + pino)->dx;
#line 681
    tcp->pocs[pino].dy = (pi + pino)->dy;
#line 558
    pino ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return (pi);
}
}
#line 688 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
void pi_destroy(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno ) 
{ 
  int compno ;
  int pino ;
  opj_tcp_t *tcp ;
  opj_pi_comp_t *comp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 690
  tcp = cp->tcps + tileno;
#line 691
  if (pi) {
#line 692
    pino = 0;
    {
#line 692
    while (1) {
      while_continue: /* CIL Label */ ;
#line 692
      if (! (pino < tcp->numpocs + 1)) {
#line 692
        goto while_break;
      }
#line 693
      if ((pi + pino)->comps) {
#line 694
        compno = 0;
        {
#line 694
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 694
          if (! (compno < pi->numcomps)) {
#line 694
            goto while_break___0;
          }
#line 695
          comp = (pi + pino)->comps + compno;
#line 696
          if (comp->resolutions) {
            {
#line 697
            free(comp->resolutions);
            }
          }
#line 694
          compno ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 700
        free((pi + pino)->comps);
        }
      }
#line 692
      pino ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 703
    if (pi->include) {
      {
#line 704
      free(pi->include);
      }
    }
    {
#line 706
    free(pi);
    }
  }
  return;
}
}
#line 710 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
opj_bool pi_next(opj_pi_iterator_t *pi ) 
{ 
  opj_bool __cil_tmp2 ;
  opj_bool __cil_tmp3 ;
  opj_bool __cil_tmp4 ;
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;

  {
  {
#line 712
  if ((int )pi->poc.prg == 0) {
#line 712
    goto case_0;
  }
#line 714
  if ((int )pi->poc.prg == 1) {
#line 714
    goto case_1;
  }
#line 716
  if ((int )pi->poc.prg == 2) {
#line 716
    goto case_2;
  }
#line 718
  if ((int )pi->poc.prg == 3) {
#line 718
    goto case_3;
  }
#line 720
  if ((int )pi->poc.prg == 4) {
#line 720
    goto case_4;
  }
#line 722
  if ((int )pi->poc.prg == -1) {
#line 722
    goto case_neg_1;
  }
#line 711
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 713
  __cil_tmp2 = pi_next_lrcp(pi);
  }
#line 713
  return (__cil_tmp2);
  case_1: /* CIL Label */ 
  {
#line 715
  __cil_tmp3 = pi_next_rlcp(pi);
  }
#line 715
  return (__cil_tmp3);
  case_2: /* CIL Label */ 
  {
#line 717
  __cil_tmp4 = pi_next_rpcl(pi);
  }
#line 717
  return (__cil_tmp4);
  case_3: /* CIL Label */ 
  {
#line 719
  __cil_tmp5 = pi_next_pcrl(pi);
  }
#line 719
  return (__cil_tmp5);
  case_4: /* CIL Label */ 
  {
#line 721
  __cil_tmp6 = pi_next_cprl(pi);
  }
#line 721
  return (__cil_tmp6);
  case_neg_1: /* CIL Label */ 
#line 723
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 726
  return (0);
}
}
#line 729 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/pi.c"
opj_bool pi_create_encode(opj_pi_iterator_t *pi , opj_cp_t *cp , int tileno , int pino ,
                          int tpnum , int tppos , J2K_T2_MODE t2_mode , int cur_totnum_tp ) 
{ 
  char prog[4] ;
  int i ;
  int incr_top ;
  int resetX ;
  opj_tcp_t *tcps ;
  opj_poc_t *tcp ;
  int __cil_tmp15 ;

  {
#line 732
  incr_top = 1;
#line 732
  resetX = 0;
#line 733
  tcps = cp->tcps + tileno;
#line 734
  tcp = & tcps->pocs[pino];
#line 736
  (pi + pino)->first = 1;
#line 737
  (pi + pino)->poc.prg = tcp->prg;
  {
#line 740
  if ((int )tcp->prg == 4) {
#line 740
    goto case_4;
  }
#line 742
  if ((int )tcp->prg == 0) {
#line 742
    goto case_0;
  }
#line 744
  if ((int )tcp->prg == 3) {
#line 744
    goto case_3;
  }
#line 746
  if ((int )tcp->prg == 1) {
#line 746
    goto case_1;
  }
#line 748
  if ((int )tcp->prg == 2) {
#line 748
    goto case_2;
  }
#line 750
  if ((int )tcp->prg == -1) {
#line 750
    goto case_neg_1;
  }
#line 739
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 740
  strncpy((char *)prog, "CPRL\262U", (unsigned long )4);
  }
#line 741
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 742
  strncpy((char *)prog, "LRCP\262U", (unsigned long )4);
  }
#line 743
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 744
  strncpy((char *)prog, "PCRL", (unsigned long )4);
  }
#line 745
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 746
  strncpy((char *)prog, "RLCP\262U", (unsigned long )4);
  }
#line 747
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 748
  strncpy((char *)prog, "RPCL\262U", (unsigned long )4);
  }
#line 749
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 751
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 754
  if (! ((int )cp->tp_on && ((! cp->cinema && (unsigned int )t2_mode == 1U) || (unsigned int )cp->cinema))) {
#line 755
    (pi + pino)->poc.resno0 = tcp->resS;
#line 756
    (pi + pino)->poc.resno1 = tcp->resE;
#line 757
    (pi + pino)->poc.compno0 = tcp->compS;
#line 758
    (pi + pino)->poc.compno1 = tcp->compE;
#line 759
    (pi + pino)->poc.layno0 = tcp->layS;
#line 760
    (pi + pino)->poc.layno1 = tcp->layE;
#line 761
    (pi + pino)->poc.precno0 = tcp->prcS;
#line 762
    (pi + pino)->poc.precno1 = tcp->prcE;
#line 763
    (pi + pino)->poc.tx0 = tcp->txS;
#line 764
    (pi + pino)->poc.ty0 = tcp->tyS;
#line 765
    (pi + pino)->poc.tx1 = tcp->txE;
#line 766
    (pi + pino)->poc.ty1 = tcp->tyE;
  } else
#line 768
  if (tpnum < cur_totnum_tp) {
#line 769
    i = 3;
    {
#line 769
    while (1) {
      while_continue: /* CIL Label */ ;
#line 769
      if (! (i >= 0)) {
#line 769
        goto while_break;
      }
      {
#line 771
      if ((int )prog[i] == 'C') {
#line 771
        goto case_67;
      }
#line 803
      if ((int )prog[i] == 'R') {
#line 803
        goto case_82;
      }
#line 835
      if ((int )prog[i] == 'L') {
#line 835
        goto case_76;
      }
#line 867
      if ((int )prog[i] == 'P') {
#line 867
        goto case_80;
      }
#line 870
      if ((int )prog[i] == 1) {
#line 870
        goto case_1___0;
      }
#line 870
      if ((int )prog[i] == 0) {
#line 870
        goto case_1___0;
      }
#line 901
      goto switch_default;
      case_67: /* CIL Label */ 
#line 772
      if (i > tppos) {
#line 773
        (pi + pino)->poc.compno0 = tcp->compS;
#line 774
        (pi + pino)->poc.compno1 = tcp->compE;
      } else
#line 776
      if (tpnum == 0) {
#line 777
        tcp->comp_t = tcp->compS;
#line 778
        (pi + pino)->poc.compno0 = tcp->comp_t;
#line 779
        (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 780
        (tcp->comp_t) ++;
      } else
#line 782
      if (incr_top == 1) {
#line 783
        if (tcp->comp_t == tcp->compE) {
#line 784
          tcp->comp_t = tcp->compS;
#line 785
          (pi + pino)->poc.compno0 = tcp->comp_t;
#line 786
          (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 787
          (tcp->comp_t) ++;
#line 788
          incr_top = 1;
        } else {
#line 790
          (pi + pino)->poc.compno0 = tcp->comp_t;
#line 791
          (pi + pino)->poc.compno1 = tcp->comp_t + 1;
#line 792
          (tcp->comp_t) ++;
#line 793
          incr_top = 0;
        }
      } else {
#line 796
        (pi + pino)->poc.compno0 = tcp->comp_t - 1;
#line 797
        (pi + pino)->poc.compno1 = tcp->comp_t;
      }
#line 801
      goto switch_break___0;
      case_82: /* CIL Label */ 
#line 804
      if (i > tppos) {
#line 805
        (pi + pino)->poc.resno0 = tcp->resS;
#line 806
        (pi + pino)->poc.resno1 = tcp->resE;
      } else
#line 808
      if (tpnum == 0) {
#line 809
        tcp->res_t = tcp->resS;
#line 810
        (pi + pino)->poc.resno0 = tcp->res_t;
#line 811
        (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 812
        (tcp->res_t) ++;
      } else
#line 814
      if (incr_top == 1) {
#line 815
        if (tcp->res_t == tcp->resE) {
#line 816
          tcp->res_t = tcp->resS;
#line 817
          (pi + pino)->poc.resno0 = tcp->res_t;
#line 818
          (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 819
          (tcp->res_t) ++;
#line 820
          incr_top = 1;
        } else {
#line 822
          (pi + pino)->poc.resno0 = tcp->res_t;
#line 823
          (pi + pino)->poc.resno1 = tcp->res_t + 1;
#line 824
          (tcp->res_t) ++;
#line 825
          incr_top = 0;
        }
      } else {
#line 828
        (pi + pino)->poc.resno0 = tcp->res_t - 1;
#line 829
        (pi + pino)->poc.resno1 = tcp->res_t;
      }
#line 833
      goto switch_break___0;
      case_76: /* CIL Label */ 
#line 836
      if (i > tppos) {
#line 837
        (pi + pino)->poc.layno0 = tcp->layS;
#line 838
        (pi + pino)->poc.layno1 = tcp->layE;
      } else
#line 840
      if (tpnum == 0) {
#line 841
        tcp->lay_t = tcp->layS;
#line 842
        (pi + pino)->poc.layno0 = tcp->lay_t;
#line 843
        (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 844
        (tcp->lay_t) ++;
      } else
#line 846
      if (incr_top == 1) {
#line 847
        if (tcp->lay_t == tcp->layE) {
#line 848
          tcp->lay_t = tcp->layS;
#line 849
          (pi + pino)->poc.layno0 = tcp->lay_t;
#line 850
          (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 851
          (tcp->lay_t) ++;
#line 852
          incr_top = 1;
        } else {
#line 854
          (pi + pino)->poc.layno0 = tcp->lay_t;
#line 855
          (pi + pino)->poc.layno1 = tcp->lay_t + 1;
#line 856
          (tcp->lay_t) ++;
#line 857
          incr_top = 0;
        }
      } else {
#line 860
        (pi + pino)->poc.layno0 = tcp->lay_t - 1;
#line 861
        (pi + pino)->poc.layno1 = tcp->lay_t;
      }
#line 865
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 870
      if ((int )tcp->prg == 1) {
#line 870
        goto case_1___0;
      }
#line 870
      if ((int )tcp->prg == 0) {
#line 870
        goto case_1___0;
      }
#line 901
      goto switch_default;
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
#line 871
      if (i > tppos) {
#line 872
        (pi + pino)->poc.precno0 = tcp->prcS;
#line 873
        (pi + pino)->poc.precno1 = tcp->prcE;
      } else
#line 875
      if (tpnum == 0) {
#line 876
        tcp->prc_t = tcp->prcS;
#line 877
        (pi + pino)->poc.precno0 = tcp->prc_t;
#line 878
        (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 879
        (tcp->prc_t) ++;
      } else
#line 881
      if (incr_top == 1) {
#line 882
        if (tcp->prc_t == tcp->prcE) {
#line 883
          tcp->prc_t = tcp->prcS;
#line 884
          (pi + pino)->poc.precno0 = tcp->prc_t;
#line 885
          (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 886
          (tcp->prc_t) ++;
#line 887
          incr_top = 1;
        } else {
#line 889
          (pi + pino)->poc.precno0 = tcp->prc_t;
#line 890
          (pi + pino)->poc.precno1 = tcp->prc_t + 1;
#line 891
          (tcp->prc_t) ++;
#line 892
          incr_top = 0;
        }
      } else {
#line 895
        (pi + pino)->poc.precno0 = tcp->prc_t - 1;
#line 896
        (pi + pino)->poc.precno1 = tcp->prc_t;
      }
#line 900
      goto switch_break___1;
      switch_default: /* CIL Label */ 
#line 902
      if (i > tppos) {
#line 903
        (pi + pino)->poc.tx0 = tcp->txS;
#line 904
        (pi + pino)->poc.ty0 = tcp->tyS;
#line 905
        (pi + pino)->poc.tx1 = tcp->txE;
#line 906
        (pi + pino)->poc.ty1 = tcp->tyE;
      } else
#line 908
      if (tpnum == 0) {
#line 909
        tcp->tx0_t = tcp->txS;
#line 910
        tcp->ty0_t = tcp->tyS;
#line 911
        (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 912
        (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 913
        (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 914
        (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 915
        tcp->tx0_t = (pi + pino)->poc.tx1;
#line 916
        tcp->ty0_t = (pi + pino)->poc.ty1;
      } else
#line 918
      if (incr_top == 1) {
#line 919
        if (tcp->tx0_t >= tcp->txE) {
#line 920
          if (tcp->ty0_t >= tcp->tyE) {
#line 921
            tcp->ty0_t = tcp->tyS;
#line 922
            (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 923
            (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 924
            tcp->ty0_t = (pi + pino)->poc.ty1;
#line 925
            incr_top = 1;
#line 925
            resetX = 1;
          } else {
#line 927
            (pi + pino)->poc.ty0 = tcp->ty0_t;
#line 928
            (pi + pino)->poc.ty1 = (tcp->ty0_t + tcp->dy) - tcp->ty0_t % tcp->dy;
#line 929
            tcp->ty0_t = (pi + pino)->poc.ty1;
#line 930
            incr_top = 0;
#line 930
            resetX = 1;
          }
#line 932
          if (resetX == 1) {
#line 933
            tcp->tx0_t = tcp->txS;
#line 934
            (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 935
            (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 936
            tcp->tx0_t = (pi + pino)->poc.tx1;
          }
        } else {
#line 939
          (pi + pino)->poc.tx0 = tcp->tx0_t;
#line 940
          (pi + pino)->poc.tx1 = (tcp->tx0_t + tcp->dx) - tcp->tx0_t % tcp->dx;
#line 941
          tcp->tx0_t = (pi + pino)->poc.tx1;
#line 942
          (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 943
          (pi + pino)->poc.ty1 = tcp->ty0_t;
#line 944
          incr_top = 0;
        }
      } else {
#line 947
        (pi + pino)->poc.tx0 = (tcp->tx0_t - tcp->dx) - tcp->tx0_t % tcp->dx;
#line 948
        (pi + pino)->poc.tx1 = tcp->tx0_t;
#line 949
        (pi + pino)->poc.ty0 = (tcp->ty0_t - tcp->dy) - tcp->ty0_t % tcp->dy;
#line 950
        (pi + pino)->poc.ty1 = tcp->ty0_t;
      }
#line 954
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 956
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 769
      __cil_tmp15 = i;
#line 769
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 961
  return (0);
}
}
#line 61 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
char const   *opj_version(void) 
{ 


  {
#line 62
  return ("1.5.0");
}
}
#line 65 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
opj_dinfo_t *opj_create_decompress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_dinfo_t *dinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 66
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_dinfo_t ));
#line 66
  dinfo = (opj_dinfo_t *)__cil_tmp3;
  }
#line 67
  if (! dinfo) {
#line 67
    return ((opj_dinfo_t *)((void *)0));
  }
#line 68
  dinfo->is_decompressor = 1;
  {
#line 71
  if ((int )format == 1) {
#line 71
    goto case_1;
  }
#line 71
  if ((int )format == 0) {
#line 71
    goto case_1;
  }
#line 79
  if ((int )format == 2) {
#line 79
    goto case_2;
  }
#line 88
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 73
  __cil_tmp4 = j2k_create_decompress((opj_common_ptr )dinfo);
#line 73
  dinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 74
  if (! dinfo->j2k_handle) {
    {
#line 75
    free(dinfo);
    }
#line 76
    return ((opj_dinfo_t *)((void *)0));
  }
#line 78
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 81
  __cil_tmp5 = jp2_create_decompress((opj_common_ptr )dinfo);
#line 81
  dinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 82
  if (! dinfo->jp2_handle) {
    {
#line 83
    free(dinfo);
    }
#line 84
    return ((opj_dinfo_t *)((void *)0));
  }
#line 86
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  {
#line 89
  free(dinfo);
  }
#line 90
  return ((opj_dinfo_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 93
  dinfo->codec_format = format;
#line 95
  return (dinfo);
}
}
#line 98 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
void opj_destroy_decompress(opj_dinfo_t *dinfo ) 
{ 


  {
#line 99
  if (dinfo) {
    {
#line 103
    if ((int )dinfo->codec_format == 1) {
#line 103
      goto case_1;
    }
#line 103
    if ((int )dinfo->codec_format == 0) {
#line 103
      goto case_1;
    }
#line 106
    if ((int )dinfo->codec_format == 2) {
#line 106
      goto case_2;
    }
#line 110
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 104
    j2k_destroy_decompress((opj_j2k_t *)dinfo->j2k_handle);
    }
#line 105
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 107
    jp2_destroy_decompress((opj_jp2_t *)dinfo->jp2_handle);
    }
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 114
    free(dinfo);
    }
  }
  return;
}
}
#line 118 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
void opj_set_default_decoder_parameters(opj_dparameters_t *parameters ) 
{ 


  {
#line 119
  if (parameters) {
    {
#line 120
    memset(parameters, 0, sizeof(opj_dparameters_t ));
#line 122
    parameters->cp_layer = 0;
#line 123
    parameters->cp_reduce = 0;
#line 124
    parameters->cp_limit_decoding = (OPJ_LIMIT_DECODING )0;
#line 126
    parameters->decod_format = - 1;
#line 127
    parameters->cod_format = - 1;
#line 128
    parameters->flags = (unsigned int )0;
    }
  }
  return;
}
}
#line 139 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
void opj_setup_decoder(opj_dinfo_t *dinfo , opj_dparameters_t *parameters ) 
{ 


  {
#line 140
  if (dinfo) {
#line 140
    if (parameters) {
      {
#line 143
      if ((int )dinfo->codec_format == 1) {
#line 143
        goto case_1;
      }
#line 143
      if ((int )dinfo->codec_format == 0) {
#line 143
        goto case_1;
      }
#line 146
      if ((int )dinfo->codec_format == 2) {
#line 146
        goto case_2;
      }
#line 150
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
      {
#line 144
      j2k_setup_decoder((opj_j2k_t *)dinfo->j2k_handle, parameters);
      }
#line 145
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 147
      jp2_setup_decoder((opj_jp2_t *)dinfo->jp2_handle, parameters);
      }
#line 148
      goto switch_break;
      switch_default: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
#line 151
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 156 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode(opj_dinfo_t *dinfo , opj_cio_t *cio ) 
{ 
  opj_image_t *__cil_tmp3 ;

  {
  {
#line 157
  __cil_tmp3 = opj_decode_with_info(dinfo, cio, (opj_codestream_info_t *)((void *)0));
  }
#line 157
  return (__cil_tmp3);
}
}
#line 160 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
opj_image_t *opj_decode_with_info(opj_dinfo_t *dinfo , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *__cil_tmp4 ;
  opj_image_t *__cil_tmp5 ;
  opj_image_t *__cil_tmp6 ;

  {
#line 161
  if (dinfo) {
#line 161
    if (cio) {
      {
#line 163
      if ((int )dinfo->codec_format == 0) {
#line 163
        goto case_0;
      }
#line 165
      if ((int )dinfo->codec_format == 1) {
#line 165
        goto case_1;
      }
#line 167
      if ((int )dinfo->codec_format == 2) {
#line 167
        goto case_2;
      }
#line 170
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 164
      __cil_tmp4 = j2k_decode((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 164
      return (__cil_tmp4);
      case_1: /* CIL Label */ 
      {
#line 166
      __cil_tmp5 = j2k_decode_jpt_stream((opj_j2k_t *)dinfo->j2k_handle, cio, cstr_info);
      }
#line 166
      return (__cil_tmp5);
      case_2: /* CIL Label */ 
      {
#line 168
      __cil_tmp6 = opj_jp2_decode((opj_jp2_t *)dinfo->jp2_handle, cio, cstr_info);
      }
#line 168
      return (__cil_tmp6);
      switch_default: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
#line 171
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 174
  return ((opj_image_t *)((void *)0));
}
}
#line 177 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
opj_cinfo_t *opj_create_compress(OPJ_CODEC_FORMAT format ) 
{ 
  opj_cinfo_t *cinfo ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;
  opj_jp2_t *__cil_tmp5 ;

  {
  {
#line 178
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_cinfo_t ));
#line 178
  cinfo = (opj_cinfo_t *)__cil_tmp3;
  }
#line 179
  if (! cinfo) {
#line 179
    return ((opj_cinfo_t *)((void *)0));
  }
#line 180
  cinfo->is_decompressor = 0;
  {
#line 182
  if ((int )format == 0) {
#line 182
    goto case_0;
  }
#line 190
  if ((int )format == 2) {
#line 190
    goto case_2;
  }
#line 200
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 184
  __cil_tmp4 = j2k_create_compress((opj_common_ptr )cinfo);
#line 184
  cinfo->j2k_handle = (void *)__cil_tmp4;
  }
#line 185
  if (! cinfo->j2k_handle) {
    {
#line 186
    free(cinfo);
    }
#line 187
    return ((opj_cinfo_t *)((void *)0));
  }
#line 189
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 192
  __cil_tmp5 = jp2_create_compress((opj_common_ptr )cinfo);
#line 192
  cinfo->jp2_handle = (void *)__cil_tmp5;
  }
#line 193
  if (! cinfo->jp2_handle) {
    {
#line 194
    free(cinfo);
    }
#line 195
    return ((opj_cinfo_t *)((void *)0));
  }
#line 197
  goto switch_break;
  switch_default: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 201
  free(cinfo);
  }
#line 202
  return ((opj_cinfo_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 205
  cinfo->codec_format = format;
#line 207
  return (cinfo);
}
}
#line 210 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
void opj_destroy_compress(opj_cinfo_t *cinfo ) 
{ 


  {
#line 211
  if (cinfo) {
    {
#line 214
    if ((int )cinfo->codec_format == 0) {
#line 214
      goto case_0;
    }
#line 217
    if ((int )cinfo->codec_format == 2) {
#line 217
      goto case_2;
    }
#line 222
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 215
    j2k_destroy_compress((opj_j2k_t *)cinfo->j2k_handle);
    }
#line 216
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 218
    jp2_destroy_compress((opj_jp2_t *)cinfo->jp2_handle);
    }
#line 219
    goto switch_break;
    switch_default: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 223
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 226
    free(cinfo);
    }
  }
  return;
}
}
#line 230 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
void opj_set_default_encoder_parameters(opj_cparameters_t *parameters ) 
{ 


  {
#line 231
  if (parameters) {
    {
#line 232
    memset(parameters, 0, sizeof(opj_cparameters_t ));
#line 234
    parameters->cp_cinema = (OPJ_CINEMA_MODE )0;
#line 235
    parameters->max_comp_size = 0;
#line 236
    parameters->numresolution = 6;
#line 237
    parameters->cp_rsiz = (OPJ_RSIZ_CAPABILITIES )0;
#line 238
    parameters->cblockw_init = 64;
#line 239
    parameters->cblockh_init = 64;
#line 240
    parameters->prog_order = (OPJ_PROG_ORDER )0;
#line 241
    parameters->roi_compno = - 1;
#line 242
    parameters->subsampling_dx = 1;
#line 243
    parameters->subsampling_dy = 1;
#line 244
    parameters->tp_on = (char )0;
#line 245
    parameters->decod_format = - 1;
#line 246
    parameters->cod_format = - 1;
#line 247
    parameters->tcp_rates[0] = (float )0;
#line 248
    parameters->tcp_numlayers = 0;
#line 249
    parameters->cp_disto_alloc = 0;
#line 250
    parameters->cp_fixed_alloc = 0;
#line 251
    parameters->cp_fixed_quality = 0;
#line 252
    parameters->jpip_on = 0;
    }
  }
  return;
}
}
#line 288 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
void opj_setup_encoder(opj_cinfo_t *cinfo , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 


  {
#line 289
  if (cinfo) {
#line 289
    if (parameters) {
#line 289
      if (image) {
        {
#line 291
        if ((int )cinfo->codec_format == 0) {
#line 291
          goto case_0;
        }
#line 294
        if ((int )cinfo->codec_format == 2) {
#line 294
          goto case_2;
        }
#line 299
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 292
        j2k_setup_encoder((opj_j2k_t *)cinfo->j2k_handle, parameters, image);
        }
#line 293
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 295
        jp2_setup_encoder((opj_jp2_t *)cinfo->jp2_handle, parameters, image);
        }
#line 296
        goto switch_break;
        switch_default: /* CIL Label */ 
        case_neg_1: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 300
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  return;
}
}
#line 305 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
opj_bool opj_encode(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image , char *index___0 ) 
{ 
  opj_bool __cil_tmp5 ;

  {
#line 306
  if (index___0 != (void *)0) {
    {
#line 307
    opj_event_msg((opj_common_ptr )cinfo, 2, "Set index to NULL when calling the opj_encode function.\nTo extract the index, use the opj_encode_with_info() function.\nNo index will be generated during this encoding\n");
    }
  }
  {
#line 310
  __cil_tmp5 = opj_encode_with_info(cinfo, cio, image, (opj_codestream_info_t *)((void *)0));
  }
#line 310
  return (__cil_tmp5);
}
}
#line 313 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
opj_bool opj_encode_with_info(opj_cinfo_t *cinfo , opj_cio_t *cio , opj_image_t *image ,
                              opj_codestream_info_t *cstr_info ) 
{ 
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;

  {
#line 314
  if (cinfo) {
#line 314
    if (cio) {
#line 314
      if (image) {
        {
#line 316
        if ((int )cinfo->codec_format == 0) {
#line 316
          goto case_0;
        }
#line 318
        if ((int )cinfo->codec_format == 2) {
#line 318
          goto case_2;
        }
#line 322
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 317
        __cil_tmp5 = j2k_encode((opj_j2k_t *)cinfo->j2k_handle, cio, image, cstr_info);
        }
#line 317
        return (__cil_tmp5);
        case_2: /* CIL Label */ 
        {
#line 319
        __cil_tmp6 = opj_jp2_encode((opj_jp2_t *)cinfo->jp2_handle, cio, image, cstr_info);
        }
#line 319
        return (__cil_tmp6);
        switch_default: /* CIL Label */ 
        case_neg_1: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 323
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 326
  return (0);
}
}
#line 329 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/openjpeg.c"
void opj_destroy_cstr_info(opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  opj_tile_info_t *tile_info ;
  int __cil_tmp4 ;

  {
#line 330
  if (cstr_info) {
#line 332
    tileno = 0;
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
#line 332
      if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 332
        goto while_break;
      }
      {
#line 333
      tile_info = cstr_info->tile + tileno;
#line 334
      free(tile_info->thresh);
#line 335
      free(tile_info->packet);
#line 336
      free(tile_info->tp);
#line 337
      free(tile_info->marker);
      }
#line 332
      tileno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 339
    free(cstr_info->tile);
#line 340
    free(cstr_info->marker);
#line 341
    free(cstr_info->numdecompos);
    }
  }
  return;
}
}
#line 45 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) ;
#line 50
static void mqc_renorme(opj_mqc_t *mqc ) ;
#line 55
static void mqc_codemps(opj_mqc_t *mqc ) ;
#line 60
static void mqc_codelps(opj_mqc_t *mqc ) ;
#line 65
static void mqc_setbits(opj_mqc_t *mqc ) ;
#line 71
__inline static int mqc_mpsexchange(opj_mqc_t *mqc ) ;
#line 77
__inline static int mqc_lpsexchange(opj_mqc_t *mqc ) ;
#line 82
static void mqc_bytein(opj_mqc_t *mqc ) ;
#line 87
__inline static void mqc_renormd(opj_mqc_t *mqc ) ;
#line 95 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
static opj_mqc_state_t mqc_states[94]  = 
#line 95
  {      {(unsigned int )22017, 0, & mqc_states[2], & mqc_states[3]}, 
        {(unsigned int )22017, 1, & mqc_states[3], & mqc_states[2]}, 
        {(unsigned int )13313, 0, & mqc_states[4], & mqc_states[12]}, 
        {(unsigned int )13313, 1, & mqc_states[5], & mqc_states[13]}, 
        {(unsigned int )6145, 0, & mqc_states[6], & mqc_states[18]}, 
        {(unsigned int )6145, 1, & mqc_states[7], & mqc_states[19]}, 
        {(unsigned int )2753, 0, & mqc_states[8], & mqc_states[24]}, 
        {(unsigned int )2753, 1, & mqc_states[9], & mqc_states[25]}, 
        {(unsigned int )1313, 0, & mqc_states[10], & mqc_states[58]}, 
        {(unsigned int )1313, 1, & mqc_states[11], & mqc_states[59]}, 
        {(unsigned int )545, 0, & mqc_states[76], & mqc_states[66]}, 
        {(unsigned int )545, 1, & mqc_states[77], & mqc_states[67]}, 
        {(unsigned int )22017, 0, & mqc_states[14], & mqc_states[13]}, 
        {(unsigned int )22017, 1, & mqc_states[15], & mqc_states[12]}, 
        {(unsigned int )21505, 0, & mqc_states[16], & mqc_states[28]}, 
        {(unsigned int )21505, 1, & mqc_states[17], & mqc_states[29]}, 
        {(unsigned int )18433, 0, & mqc_states[18], & mqc_states[28]}, 
        {(unsigned int )18433, 1, & mqc_states[19], & mqc_states[29]}, 
        {(unsigned int )14337, 0, & mqc_states[20], & mqc_states[28]}, 
        {(unsigned int )14337, 1, & mqc_states[21], & mqc_states[29]}, 
        {(unsigned int )12289, 0, & mqc_states[22], & mqc_states[34]}, 
        {(unsigned int )12289, 1, & mqc_states[23], & mqc_states[35]}, 
        {(unsigned int )9217, 0, & mqc_states[24], & mqc_states[36]}, 
        {(unsigned int )9217, 1, & mqc_states[25], & mqc_states[37]}, 
        {(unsigned int )7169, 0, & mqc_states[26], & mqc_states[40]}, 
        {(unsigned int )7169, 1, & mqc_states[27], & mqc_states[41]}, 
        {(unsigned int )5633, 0, & mqc_states[58], & mqc_states[42]}, 
        {(unsigned int )5633, 1, & mqc_states[59], & mqc_states[43]}, 
        {(unsigned int )22017, 0, & mqc_states[30], & mqc_states[29]}, 
        {(unsigned int )22017, 1, & mqc_states[31], & mqc_states[28]}, 
        {(unsigned int )21505, 0, & mqc_states[32], & mqc_states[28]}, 
        {(unsigned int )21505, 1, & mqc_states[33], & mqc_states[29]}, 
        {(unsigned int )20737, 0, & mqc_states[34], & mqc_states[30]}, 
        {(unsigned int )20737, 1, & mqc_states[35], & mqc_states[31]}, 
        {(unsigned int )18433, 0, & mqc_states[36], & mqc_states[32]}, 
        {(unsigned int )18433, 1, & mqc_states[37], & mqc_states[33]}, 
        {(unsigned int )14337, 0, & mqc_states[38], & mqc_states[34]}, 
        {(unsigned int )14337, 1, & mqc_states[39], & mqc_states[35]}, 
        {(unsigned int )13313, 0, & mqc_states[40], & mqc_states[36]}, 
        {(unsigned int )13313, 1, & mqc_states[41], & mqc_states[37]}, 
        {(unsigned int )12289, 0, & mqc_states[42], & mqc_states[38]}, 
        {(unsigned int )12289, 1, & mqc_states[43], & mqc_states[39]}, 
        {(unsigned int )10241, 0, & mqc_states[44], & mqc_states[38]}, 
        {(unsigned int )10241, 1, & mqc_states[45], & mqc_states[39]}, 
        {(unsigned int )9217, 0, & mqc_states[46], & mqc_states[40]}, 
        {(unsigned int )9217, 1, & mqc_states[47], & mqc_states[41]}, 
        {(unsigned int )8705, 0, & mqc_states[48], & mqc_states[42]}, 
        {(unsigned int )8705, 1, & mqc_states[49], & mqc_states[43]}, 
        {(unsigned int )7169, 0, & mqc_states[50], & mqc_states[44]}, 
        {(unsigned int )7169, 1, & mqc_states[51], & mqc_states[45]}, 
        {(unsigned int )6145, 0, & mqc_states[52], & mqc_states[46]}, 
        {(unsigned int )6145, 1, & mqc_states[53], & mqc_states[47]}, 
        {(unsigned int )5633, 0, & mqc_states[54], & mqc_states[48]}, 
        {(unsigned int )5633, 1, & mqc_states[55], & mqc_states[49]}, 
        {(unsigned int )5121, 0, & mqc_states[56], & mqc_states[50]}, 
        {(unsigned int )5121, 1, & mqc_states[57], & mqc_states[51]}, 
        {(unsigned int )4609, 0, & mqc_states[58], & mqc_states[52]}, 
        {(unsigned int )4609, 1, & mqc_states[59], & mqc_states[53]}, 
        {(unsigned int )4353, 0, & mqc_states[60], & mqc_states[54]}, 
        {(unsigned int )4353, 1, & mqc_states[61], & mqc_states[55]}, 
        {(unsigned int )2753, 0, & mqc_states[62], & mqc_states[56]}, 
        {(unsigned int )2753, 1, & mqc_states[63], & mqc_states[57]}, 
        {(unsigned int )2497, 0, & mqc_states[64], & mqc_states[58]}, 
        {(unsigned int )2497, 1, & mqc_states[65], & mqc_states[59]}, 
        {(unsigned int )2209, 0, & mqc_states[66], & mqc_states[60]}, 
        {(unsigned int )2209, 1, & mqc_states[67], & mqc_states[61]}, 
        {(unsigned int )1313, 0, & mqc_states[68], & mqc_states[62]}, 
        {(unsigned int )1313, 1, & mqc_states[69], & mqc_states[63]}, 
        {(unsigned int )1089, 0, & mqc_states[70], & mqc_states[64]}, 
        {(unsigned int )1089, 1, & mqc_states[71], & mqc_states[65]}, 
        {(unsigned int )673, 0, & mqc_states[72], & mqc_states[66]}, 
        {(unsigned int )673, 1, & mqc_states[73], & mqc_states[67]}, 
        {(unsigned int )545, 0, & mqc_states[74], & mqc_states[68]}, 
        {(unsigned int )545, 1, & mqc_states[75], & mqc_states[69]}, 
        {(unsigned int )321, 0, & mqc_states[76], & mqc_states[70]}, 
        {(unsigned int )321, 1, & mqc_states[77], & mqc_states[71]}, 
        {(unsigned int )273, 0, & mqc_states[78], & mqc_states[72]}, 
        {(unsigned int )273, 1, & mqc_states[79], & mqc_states[73]}, 
        {(unsigned int )133, 0, & mqc_states[80], & mqc_states[74]}, 
        {(unsigned int )133, 1, & mqc_states[81], & mqc_states[75]}, 
        {(unsigned int )73, 0, & mqc_states[82], & mqc_states[76]}, 
        {(unsigned int )73, 1, & mqc_states[83], & mqc_states[77]}, 
        {(unsigned int )37, 0, & mqc_states[84], & mqc_states[78]}, 
        {(unsigned int )37, 1, & mqc_states[85], & mqc_states[79]}, 
        {(unsigned int )21, 0, & mqc_states[86], & mqc_states[80]}, 
        {(unsigned int )21, 1, & mqc_states[87], & mqc_states[81]}, 
        {(unsigned int )9, 0, & mqc_states[88], & mqc_states[82]}, 
        {(unsigned int )9, 1, & mqc_states[89], & mqc_states[83]}, 
        {(unsigned int )5, 0, & mqc_states[90], & mqc_states[84]}, 
        {(unsigned int )5, 1, & mqc_states[91], & mqc_states[85]}, 
        {(unsigned int )1, 0, & mqc_states[90], & mqc_states[86]}, 
        {(unsigned int )1, 1, & mqc_states[91], & mqc_states[87]}, 
        {(unsigned int )22017, 0, & mqc_states[92], & mqc_states[92]}, 
        {(unsigned int )22017, 1, & mqc_states[93], & mqc_states[93]}};
#line 198 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
static void mqc_byteout(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;
  unsigned char *__cil_tmp3 ;
  unsigned char __cil_tmp4 ;
  unsigned char *__cil_tmp5 ;
  unsigned char *__cil_tmp6 ;

  {
#line 199
  if ((int )*(mqc->bp) == 255) {
#line 200
    (mqc->bp) ++;
#line 201
    *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 202
    mqc->c &= (unsigned int )1048575;
#line 203
    mqc->ct = (unsigned int )7;
  } else
#line 205
  if ((mqc->c & 134217728U) == 0U) {
#line 206
    (mqc->bp) ++;
#line 207
    *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 208
    mqc->c &= (unsigned int )524287;
#line 209
    mqc->ct = (unsigned int )8;
  } else {
#line 211
    (*(mqc->bp)) ++;
#line 212
    if ((int )*(mqc->bp) == 255) {
#line 213
      mqc->c &= (unsigned int )134217727;
#line 214
      (mqc->bp) ++;
#line 215
      *(mqc->bp) = (unsigned char )(mqc->c >> 20);
#line 216
      mqc->c &= (unsigned int )1048575;
#line 217
      mqc->ct = (unsigned int )7;
    } else {
#line 219
      (mqc->bp) ++;
#line 220
      *(mqc->bp) = (unsigned char )(mqc->c >> 19);
#line 221
      mqc->c &= (unsigned int )524287;
#line 222
      mqc->ct = (unsigned int )8;
    }
  }
  return;
}
}
#line 228 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
static void mqc_renorme(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    mqc->a <<= 1;
#line 231
    mqc->c <<= 1;
#line 232
    __cil_tmp2 = mqc->ct;
#line 232
    (mqc->ct) --;
#line 233
    if (mqc->ct == 0U) {
      {
#line 234
      mqc_byteout(mqc);
      }
    }
#line 229
    if (! ((mqc->a & 32768U) == 0U)) {
#line 229
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 239 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
static void mqc_codemps(opj_mqc_t *mqc ) 
{ 


  {
#line 240
  mqc->a -= (*(mqc->curctx))->qeval;
#line 241
  if ((mqc->a & 32768U) == 0U) {
#line 242
    if (mqc->a < (*(mqc->curctx))->qeval) {
#line 243
      mqc->a = (*(mqc->curctx))->qeval;
    } else {
#line 245
      mqc->c += (*(mqc->curctx))->qeval;
    }
    {
#line 247
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
#line 248
    mqc_renorme(mqc);
    }
  } else {
#line 250
    mqc->c += (*(mqc->curctx))->qeval;
  }
  return;
}
}
#line 254 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
static void mqc_codelps(opj_mqc_t *mqc ) 
{ 


  {
#line 255
  mqc->a -= (*(mqc->curctx))->qeval;
#line 256
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 257
    mqc->c += (*(mqc->curctx))->qeval;
  } else {
#line 259
    mqc->a = (*(mqc->curctx))->qeval;
  }
  {
#line 261
  *(mqc->curctx) = (*(mqc->curctx))->nlps;
#line 262
  mqc_renorme(mqc);
  }
  return;
}
}
#line 265 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
static void mqc_setbits(opj_mqc_t *mqc ) 
{ 
  unsigned int tempc ;

  {
#line 266
  tempc = mqc->c + mqc->a;
#line 267
  mqc->c |= (unsigned int )65535;
#line 268
  if (mqc->c >= tempc) {
#line 269
    mqc->c -= (unsigned int )32768;
  }
  return;
}
}
#line 273 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
__inline static int mqc_mpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 275
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 276
    d = 1 - (*(mqc->curctx))->mps;
#line 277
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  } else {
#line 279
    d = (*(mqc->curctx))->mps;
#line 280
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  }
#line 283
  return (d);
}
}
#line 286 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
__inline static int mqc_lpsexchange(opj_mqc_t *mqc ) 
{ 
  int d ;

  {
#line 288
  if (mqc->a < (*(mqc->curctx))->qeval) {
#line 289
    mqc->a = (*(mqc->curctx))->qeval;
#line 290
    d = (*(mqc->curctx))->mps;
#line 291
    *(mqc->curctx) = (*(mqc->curctx))->nmps;
  } else {
#line 293
    mqc->a = (*(mqc->curctx))->qeval;
#line 294
    d = 1 - (*(mqc->curctx))->mps;
#line 295
    *(mqc->curctx) = (*(mqc->curctx))->nlps;
  }
#line 298
  return (d);
}
}
#line 309 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
static void mqc_bytein(opj_mqc_t *mqc ) 
{ 
  unsigned int c ;
  unsigned char *__cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 310
  if (mqc->bp != mqc->end) {
#line 312
    if (mqc->bp + 1 != mqc->end) {
#line 313
      c = (unsigned int )*(mqc->bp + 1);
    } else {
#line 315
      c = (unsigned int )255;
    }
#line 317
    if ((int )*(mqc->bp) == 255) {
#line 318
      if (c > 143U) {
#line 319
        mqc->c += (unsigned int )65280;
#line 320
        mqc->ct = (unsigned int )8;
      } else {
#line 322
        (mqc->bp) ++;
#line 323
        mqc->c += c << 9;
#line 324
        mqc->ct = (unsigned int )7;
      }
    } else {
#line 327
      (mqc->bp) ++;
#line 328
      mqc->c += c << 8;
#line 329
      mqc->ct = (unsigned int )8;
    }
  } else {
#line 332
    mqc->c += (unsigned int )65280;
#line 333
    mqc->ct = (unsigned int )8;
  }
  return;
}
}
#line 338 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
__inline static void mqc_renormd(opj_mqc_t *mqc ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (mqc->ct == 0U) {
      {
#line 341
      mqc_bytein(mqc);
      }
    }
#line 343
    mqc->a <<= 1;
#line 344
    mqc->c <<= 1;
#line 345
    __cil_tmp2 = mqc->ct;
#line 345
    (mqc->ct) --;
#line 339
    if (! (mqc->a < 32768U)) {
#line 339
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 355 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
opj_mqc_t *mqc_create(void) 
{ 
  opj_mqc_t *mqc ;
  void *__cil_tmp2 ;

  {
  {
#line 356
  __cil_tmp2 = malloc(sizeof(opj_mqc_t ));
#line 356
  mqc = (opj_mqc_t *)__cil_tmp2;
  }
#line 360
  return (mqc);
}
}
#line 363 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_destroy(opj_mqc_t *mqc ) 
{ 


  {
#line 364
  if (mqc) {
    {
#line 370
    free(mqc);
    }
  }
  return;
}
}
#line 374 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
int mqc_numbytes(opj_mqc_t *mqc ) 
{ 


  {
#line 375
  return ((int )(mqc->bp - mqc->start));
}
}
#line 378 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_init_enc(opj_mqc_t *mqc , unsigned char *bp ) 
{ 


  {
#line 379
  mqc->curctx = & mqc->ctxs[(int )0];
#line 380
  mqc->a = (unsigned int )32768;
#line 381
  mqc->c = (unsigned int )0;
#line 382
  mqc->bp = bp - 1;
#line 383
  mqc->ct = (unsigned int )12;
#line 384
  if ((int )*(mqc->bp) == 255) {
#line 385
    mqc->ct = (unsigned int )13;
  }
#line 387
  mqc->start = bp;
  return;
}
}
#line 390 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_encode(opj_mqc_t *mqc , int d ) 
{ 


  {
#line 391
  if ((*(mqc->curctx))->mps == d) {
    {
#line 392
    mqc_codemps(mqc);
    }
  } else {
    {
#line 394
    mqc_codelps(mqc);
    }
  }
  return;
}
}
#line 398 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_flush(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
  {
#line 399
  mqc_setbits(mqc);
#line 400
  mqc->c <<= mqc->ct;
#line 401
  mqc_byteout(mqc);
#line 402
  mqc->c <<= mqc->ct;
#line 403
  mqc_byteout(mqc);
  }
#line 405
  if ((int )*(mqc->bp) != 255) {
#line 406
    (mqc->bp) ++;
  }
  return;
}
}
#line 410 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_bypass_init_enc(opj_mqc_t *mqc ) 
{ 


  {
#line 411
  mqc->c = (unsigned int )0;
#line 412
  mqc->ct = (unsigned int )8;
  return;
}
}
#line 418 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_bypass_enc(opj_mqc_t *mqc , int d ) 
{ 
  unsigned int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 419
  __cil_tmp3 = mqc->ct;
#line 419
  (mqc->ct) --;
#line 420
  mqc->c += (unsigned int )(d << mqc->ct);
#line 421
  if (mqc->ct == 0U) {
#line 422
    (mqc->bp) ++;
#line 423
    *(mqc->bp) = (unsigned char )mqc->c;
#line 424
    mqc->ct = (unsigned int )8;
#line 425
    if ((int )*(mqc->bp) == 255) {
#line 426
      mqc->ct = (unsigned int )7;
    }
#line 428
    mqc->c = (unsigned int )0;
  }
  return;
}
}
#line 432 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
int mqc_bypass_flush_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char bit_padding ;
  unsigned int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
#line 435
  bit_padding = (unsigned char )0;
#line 437
  if (mqc->ct != 0U) {
    {
#line 438
    while (1) {
      while_continue: /* CIL Label */ ;
#line 438
      if (! (mqc->ct > 0U)) {
#line 438
        goto while_break;
      }
#line 439
      __cil_tmp3 = mqc->ct;
#line 439
      (mqc->ct) --;
#line 440
      mqc->c += (unsigned int )((int )bit_padding << mqc->ct);
#line 441
      bit_padding = (unsigned char )(((int )bit_padding + 1) & 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 443
    (mqc->bp) ++;
#line 444
    *(mqc->bp) = (unsigned char )mqc->c;
#line 445
    mqc->ct = (unsigned int )8;
#line 446
    mqc->c = (unsigned int )0;
  }
#line 449
  return (1);
}
}
#line 452 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_reset_enc(opj_mqc_t *mqc ) 
{ 


  {
  {
#line 453
  mqc_resetstates(mqc);
#line 454
  mqc_setstate(mqc, 18, 0, 46);
#line 455
  mqc_setstate(mqc, 17, 0, 3);
#line 456
  mqc_setstate(mqc, 0, 0, 4);
  }
  return;
}
}
#line 459 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
int mqc_restart_enc(opj_mqc_t *mqc ) 
{ 
  int correction ;
  int n ;

  {
#line 460
  correction = 1;
#line 463
  n = (int )(12U - mqc->ct);
#line 464
  mqc->c <<= mqc->ct;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (n > 0)) {
#line 465
      goto while_break;
    }
    {
#line 466
    mqc_byteout(mqc);
#line 467
    n -= mqc->ct;
#line 468
    mqc->c <<= mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 470
  mqc_byteout(mqc);
  }
#line 472
  return (correction);
}
}
#line 475 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_restart_init_enc(opj_mqc_t *mqc ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
#line 477
  mqc->curctx = & mqc->ctxs[(int )0];
#line 478
  mqc->a = (unsigned int )32768;
#line 479
  mqc->c = (unsigned int )0;
#line 480
  mqc->ct = (unsigned int )12;
#line 481
  __cil_tmp2 = mqc->bp;
#line 481
  (mqc->bp) --;
#line 482
  if ((int )*(mqc->bp) == 255) {
#line 483
    mqc->ct = (unsigned int )13;
  }
  return;
}
}
#line 487 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_erterm_enc(opj_mqc_t *mqc ) 
{ 
  int k ;

  {
#line 488
  k = (int )((11U - mqc->ct) + 1U);
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (k > 0)) {
#line 490
      goto while_break;
    }
    {
#line 491
    mqc->c <<= mqc->ct;
#line 492
    mqc->ct = (unsigned int )0;
#line 493
    mqc_byteout(mqc);
#line 494
    k -= mqc->ct;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  if ((int )*(mqc->bp) != 255) {
    {
#line 498
    mqc_byteout(mqc);
    }
  }
  return;
}
}
#line 502 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_segmark_enc(opj_mqc_t *mqc ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 504
  mqc->curctx = & mqc->ctxs[(int )18];
#line 506
  i = 1;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i < 5)) {
#line 506
      goto while_break;
    }
    {
#line 507
    mqc_encode(mqc, i % 2);
    }
#line 506
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 511 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_init_dec(opj_mqc_t *mqc , unsigned char *bp , int len ) 
{ 


  {
#line 512
  mqc->curctx = & mqc->ctxs[(int )0];
#line 513
  mqc->start = bp;
#line 514
  mqc->end = bp + len;
#line 515
  mqc->bp = bp;
#line 516
  if (len == 0) {
#line 516
    mqc->c = (unsigned int )(255 << 16);
  } else {
#line 517
    mqc->c = (unsigned int )((int )*(mqc->bp) << 16);
  }
  {
#line 556
  mqc_bytein(mqc);
#line 557
  mqc->c <<= 7;
#line 558
  mqc->ct -= (unsigned int )7;
#line 559
  mqc->a = (unsigned int )32768;
  }
  return;
}
}
#line 562 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
int mqc_decode(opj_mqc_t *mqc ) 
{ 
  int d ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 564
  mqc->a -= (*(mqc->curctx))->qeval;
#line 565
  if (mqc->c >> 16 < (*(mqc->curctx))->qeval) {
    {
#line 566
    d = mqc_lpsexchange(mqc);
#line 567
    mqc_renormd(mqc);
    }
  } else {
#line 569
    mqc->c -= (*(mqc->curctx))->qeval << 16;
#line 570
    if ((mqc->a & 32768U) == 0U) {
      {
#line 571
      d = mqc_mpsexchange(mqc);
#line 572
      mqc_renormd(mqc);
      }
    } else {
#line 574
      d = (*(mqc->curctx))->mps;
    }
  }
#line 578
  return (d);
}
}
#line 581 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_resetstates(opj_mqc_t *mqc ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 583
  i = 0;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! (i < 19)) {
#line 583
      goto while_break;
    }
#line 584
    mqc->ctxs[i] = (opj_mqc_state_t *)mqc_states;
#line 583
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 588 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/mqc.c"
void mqc_setstate(opj_mqc_t *mqc , int ctxno , int msb , int prob ) 
{ 


  {
#line 589
  mqc->ctxs[ctxno] = & mqc_states[msb + (prob << 1)];
  return;
}
}
#line 37 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jpt.c"
unsigned int jpt_read_VBAS_info(opj_cio_t *cio , unsigned int value ) 
{ 
  unsigned char elmt ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = cio_read(cio, 1);
#line 40
  elmt = (unsigned char )__cil_tmp4;
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((int )elmt >> 7 == 1)) {
#line 41
      goto while_break;
    }
    {
#line 42
    value <<= 7;
#line 43
    value |= (unsigned int )((int )elmt & 127);
#line 44
    __cil_tmp5 = cio_read(cio, 1);
#line 44
    elmt = (unsigned char )__cil_tmp5;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  value <<= 7;
#line 47
  value |= (unsigned int )((int )elmt & 127);
#line 49
  return (value);
}
}
#line 56 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jpt.c"
void jpt_init_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 57
  header->Id = (unsigned int )0;
#line 58
  header->last_byte = (unsigned int )0;
#line 59
  header->Class_Id = (unsigned int )0;
#line 60
  header->CSn_Id = (unsigned int )0;
#line 61
  header->Msg_offset = (unsigned int )0;
#line 62
  header->Msg_length = (unsigned int )0;
#line 63
  header->Layer_nb = (unsigned int )0;
  return;
}
}
#line 72 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jpt.c"
void jpt_reinit_msg_header(opj_jpt_msg_header_t *header ) 
{ 


  {
#line 73
  header->Id = (unsigned int )0;
#line 74
  header->last_byte = (unsigned int )0;
#line 75
  header->Msg_offset = (unsigned int )0;
#line 76
  header->Msg_length = (unsigned int )0;
  return;
}
}
#line 83 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jpt.c"
void jpt_read_msg_header(opj_common_ptr cinfo , opj_cio_t *cio , opj_jpt_msg_header_t *header ) 
{ 
  unsigned char elmt ;
  unsigned char Class ;
  unsigned char CSn ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 84
  Class = (unsigned char )0;
  {
#line 84
  CSn = (unsigned char )0;
#line 85
  jpt_reinit_msg_header(header);
#line 90
  __cil_tmp7 = cio_read(cio, 1);
#line 90
  elmt = (unsigned char )__cil_tmp7;
  }
  {
#line 94
  if ((((int )elmt >> 5) & 3) == 0) {
#line 94
    goto case_0;
  }
#line 97
  if ((((int )elmt >> 5) & 3) == 1) {
#line 97
    goto case_1;
  }
#line 101
  if ((((int )elmt >> 5) & 3) == 2) {
#line 101
    goto case_2;
  }
#line 105
  if ((((int )elmt >> 5) & 3) == 3) {
#line 105
    goto case_3;
  }
#line 109
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 95
  opj_event_msg(cinfo, 1, "Forbidden value encounter in message header !!\n");
  }
#line 96
  goto switch_break;
  case_1: /* CIL Label */ 
#line 98
  Class = (unsigned char )0;
#line 99
  CSn = (unsigned char )0;
#line 100
  goto switch_break;
  case_2: /* CIL Label */ 
#line 102
  Class = (unsigned char )1;
#line 103
  CSn = (unsigned char )0;
#line 104
  goto switch_break;
  case_3: /* CIL Label */ 
#line 106
  Class = (unsigned char )1;
#line 107
  CSn = (unsigned char )1;
#line 108
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 110
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 114
  if ((((int )elmt >> 4) & 1) == 1) {
#line 115
    header->last_byte = (unsigned int )1;
  }
#line 118
  header->Id |= (unsigned int )((int )elmt & 15);
#line 119
  if ((int )elmt >> 7 == 1) {
    {
#line 120
    header->Id = jpt_read_VBAS_info(cio, header->Id);
    }
  }
#line 125
  if ((int )Class == 1) {
    {
#line 126
    header->Class_Id = (unsigned int )0;
#line 127
    header->Class_Id = jpt_read_VBAS_info(cio, header->Class_Id);
    }
  }
#line 133
  if ((int )CSn == 1) {
    {
#line 134
    header->CSn_Id = (unsigned int )0;
#line 135
    header->CSn_Id = jpt_read_VBAS_info(cio, header->CSn_Id);
    }
  }
  {
#line 141
  header->Msg_offset = jpt_read_VBAS_info(cio, header->Msg_offset);
#line 146
  header->Msg_length = jpt_read_VBAS_info(cio, header->Msg_length);
  }
#line 151
  if ((header->Class_Id & 1U) == 1U) {
    {
#line 152
    header->Layer_nb = (unsigned int )0;
#line 153
    header->Layer_nb = jpt_read_VBAS_info(cio, header->Layer_nb);
    }
  }
  return;
}
}
#line 47 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) ;
#line 55
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 56
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 57
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 58
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 59
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 65
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 72
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 73
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) ;
#line 74
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) ;
#line 75
static void jp2_write_jp(opj_cio_t *cio ) ;
#line 82
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) ;
#line 90
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) ;
#line 97
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) ;
#line 106
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 116
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 126
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) ;
#line 137
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) ;
#line 144
static void write_iptr(int offset , int length , opj_cio_t *cio ) ;
#line 153
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) ;
#line 160 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo , opj_cio_t *cio , opj_jp2_box_t *box ) 
{ 
  int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 161
  box->init_pos = cio_tell(cio);
#line 162
  __cil_tmp5 = cio_read(cio, 4);
#line 162
  box->length = (int )__cil_tmp5;
#line 163
  __cil_tmp6 = cio_read(cio, 4);
#line 163
  box->type = (int )__cil_tmp6;
  }
#line 164
  if (box->length == 1) {
    {
#line 165
    __cil_tmp7 = cio_read(cio, 4);
    }
#line 165
    if (__cil_tmp7 != 0U) {
      {
#line 166
      opj_event_msg(cinfo, 1, "Cannot handle box sizes higher than 2^32\n");
      }
#line 167
      return (0);
    }
    {
#line 169
    __cil_tmp8 = cio_read(cio, 4);
#line 169
    box->length = (int )__cil_tmp8;
    }
#line 170
    if (box->length == 0) {
      {
#line 171
      __cil_tmp9 = cio_numbytesleft(cio);
#line 171
      box->length = __cil_tmp9 + 12;
      }
    }
  } else
#line 173
  if (box->length == 0) {
    {
#line 174
    __cil_tmp10 = cio_numbytesleft(cio);
#line 174
    box->length = __cil_tmp10 + 8;
    }
  }
#line 176
  if (box->length < 0) {
    {
#line 177
    opj_event_msg(cinfo, 1, "Integer overflow in box->length\n\220");
    }
#line 178
    return (0);
  }
#line 181
  return (1);
}
}
#line 208 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 211
  cinfo = jp2->cinfo;
#line 213
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 213
  if (__cil_tmp5 == 0) {
    {
#line 214
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 215
    return (0);
  }
#line 217
  if (1768449138 != box.type) {
    {
#line 218
    opj_event_msg(cinfo, 1, "Expected IHDR Marker\n");
    }
#line 219
    return (0);
  }
  {
#line 222
  jp2->h = cio_read(cio, 4);
#line 223
  jp2->w = cio_read(cio, 4);
#line 224
  jp2->numcomps = cio_read(cio, 2);
#line 225
  __cil_tmp9 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 225
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp9;
#line 227
  jp2->bpc = cio_read(cio, 1);
#line 229
  jp2->C = cio_read(cio, 1);
#line 230
  jp2->UnkC = cio_read(cio, 1);
#line 231
  jp2->IPR = cio_read(cio, 1);
#line 233
  __cil_tmp14 = cio_tell(cio);
  }
#line 233
  if (__cil_tmp14 - box.init_pos != box.length) {
    {
#line 234
    opj_event_msg(cinfo, 1, "Error with IHDR Box\n");
    }
#line 235
    return (0);
  }
#line 238
  return (1);
}
}
#line 241 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void jp2_write_ihdr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 244
  box.init_pos = cio_tell(cio);
#line 245
  cio_skip(cio, 4);
#line 246
  cio_write(cio, (unsigned long long )1768449138, 4);
#line 248
  cio_write(cio, (unsigned long long )jp2->h, 4);
#line 249
  cio_write(cio, (unsigned long long )jp2->w, 4);
#line 250
  cio_write(cio, (unsigned long long )jp2->numcomps, 2);
#line 252
  cio_write(cio, (unsigned long long )jp2->bpc, 1);
#line 254
  cio_write(cio, (unsigned long long )jp2->C, 1);
#line 255
  cio_write(cio, (unsigned long long )jp2->UnkC, 1);
#line 256
  cio_write(cio, (unsigned long long )jp2->IPR, 1);
#line 258
  __cil_tmp5 = cio_tell(cio);
#line 258
  box.length = __cil_tmp5 - box.init_pos;
#line 259
  cio_seek(cio, box.init_pos);
#line 260
  cio_write(cio, (unsigned long long )box.length, 4);
#line 261
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 264 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void jp2_write_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 268
  box.init_pos = cio_tell(cio);
#line 269
  cio_skip(cio, 4);
#line 270
  cio_write(cio, (unsigned long long )1651532643, 4);
#line 272
  i = (unsigned int )0;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < jp2->numcomps)) {
#line 272
      goto while_break;
    }
    {
#line 273
    cio_write(cio, (unsigned long long )(jp2->comps + i)->bpcc, 1);
    }
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  __cil_tmp7 = cio_tell(cio);
#line 276
  box.length = __cil_tmp7 - box.init_pos;
#line 277
  cio_seek(cio, box.init_pos);
#line 278
  cio_write(cio, (unsigned long long )box.length, 4);
#line 279
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 283 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_bpcc(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 287
  cinfo = jp2->cinfo;
#line 289
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 289
  if (__cil_tmp6 == 0) {
    {
#line 290
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 291
    return (0);
  }
#line 293
  if (1651532643 != box.type) {
    {
#line 294
    opj_event_msg(cinfo, 1, "Expected BPCC Marker\nU");
    }
#line 295
    return (0);
  }
#line 298
  i = (unsigned int )0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i < jp2->numcomps)) {
#line 298
      goto while_break;
    }
    {
#line 299
    __cil_tmp7 = cio_read(cio, 1);
#line 299
    (jp2->comps + i)->bpcc = (int )__cil_tmp7;
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 302
  __cil_tmp9 = cio_tell(cio);
  }
#line 302
  if (__cil_tmp9 - box.init_pos != box.length) {
    {
#line 303
    opj_event_msg(cinfo, 1, "Error with BPCC Box\n");
    }
#line 304
    return (0);
  }
#line 307
  return (1);
}
}
#line 310 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void jp2_write_colr(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 313
  box.init_pos = cio_tell(cio);
#line 314
  cio_skip(cio, 4);
#line 315
  cio_write(cio, (unsigned long long )1668246642, 4);
#line 317
  cio_write(cio, (unsigned long long )jp2->meth, 1);
#line 318
  cio_write(cio, (unsigned long long )jp2->precedence, 1);
#line 319
  cio_write(cio, (unsigned long long )jp2->approx, 1);
  }
#line 321
  if (jp2->meth == 2U) {
#line 322
    jp2->enumcs = (unsigned int )0;
  }
  {
#line 324
  cio_write(cio, (unsigned long long )jp2->enumcs, 4);
#line 326
  __cil_tmp5 = cio_tell(cio);
#line 326
  box.length = __cil_tmp5 - box.init_pos;
#line 327
  cio_seek(cio, box.init_pos);
#line 328
  cio_write(cio, (unsigned long long )box.length, 4);
#line 329
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 332 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void jp2_free_pclr(opj_jp2_color_t *color ) 
{ 


  {
  {
#line 334
  free((color->jp2_pclr)->channel_sign);
#line 335
  free((color->jp2_pclr)->channel_size);
#line 336
  free((color->jp2_pclr)->entries);
  }
#line 338
  if ((color->jp2_pclr)->cmap) {
    {
#line 338
    free((color->jp2_pclr)->cmap);
    }
  }
  {
#line 340
  free(color->jp2_pclr);
#line 340
  color->jp2_pclr = (opj_jp2_pclr_t *)((void *)0);
  }
  return;
}
}
#line 343 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void free_color_data(opj_jp2_color_t *color ) 
{ 


  {
#line 345
  if (color->jp2_pclr) {
    {
#line 347
    jp2_free_pclr(color);
    }
  }
#line 349
  if (color->jp2_cdef) {
#line 351
    if ((color->jp2_cdef)->info) {
      {
#line 351
      free((color->jp2_cdef)->info);
      }
    }
    {
#line 352
    free(color->jp2_cdef);
    }
  }
#line 354
  if (color->icc_profile_buf) {
    {
#line 354
    free(color->icc_profile_buf);
    }
  }
  return;
}
}
#line 357 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void jp2_apply_pclr(opj_jp2_color_t *color , opj_image_t *image , opj_common_ptr cinfo ) 
{ 
  opj_image_comp_t *old_comps ;
  opj_image_comp_t *new_comps ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  opj_jp2_cmap_comp_t *cmap ;
  int *src ;
  int *dst ;
  unsigned int j ;
  unsigned int max ;
  unsigned short i ;
  unsigned short nr_channels ;
  unsigned short cmp ;
  unsigned short pcol ;
  int k ;
  int top_k ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
  {
#line 368
  channel_size = (color->jp2_pclr)->channel_size;
#line 369
  channel_sign = (color->jp2_pclr)->channel_sign;
#line 370
  entries = (color->jp2_pclr)->entries;
#line 371
  cmap = (color->jp2_pclr)->cmap;
#line 372
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 374
  old_comps = image->comps;
#line 375
  __cil_tmp20 = malloc((unsigned long )nr_channels * sizeof(opj_image_comp_t ));
#line 375
  new_comps = (opj_image_comp_t *)__cil_tmp20;
#line 378
  i = (unsigned short )0;
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((int )i < (int )nr_channels)) {
#line 378
      goto while_break;
    }
#line 380
    pcol = (unsigned short )(cmap + i)->pcol;
#line 380
    cmp = (cmap + i)->cmp;
#line 382
    if ((int )pcol < (int )nr_channels) {
#line 383
      *(new_comps + pcol) = *(old_comps + cmp);
    } else {
      {
#line 386
      opj_event_msg(cinfo, 1, "Error with pcol value %d (max: %d). skipping\n", (int )pcol,
                    (int )nr_channels);
      }
#line 387
      goto while_continue;
    }
#line 390
    if ((int )(cmap + i)->mtyp == 0) {
#line 392
      (old_comps + cmp)->data = (int *)((void *)0);
#line 392
      goto while_continue;
    }
    {
#line 395
    __cil_tmp21 = malloc((unsigned long )((old_comps + cmp)->w * (old_comps + cmp)->h) * sizeof(int ));
#line 395
    (new_comps + pcol)->data = (int *)__cil_tmp21;
#line 397
    (new_comps + pcol)->prec = (int )*(channel_size + i);
#line 398
    (new_comps + pcol)->sgnd = (int )*(channel_sign + i);
    }
#line 378
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  top_k = (int )(color->jp2_pclr)->nr_entries - 1;
#line 402
  i = (unsigned short )0;
  {
#line 402
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 402
    if (! ((int )i < (int )nr_channels)) {
#line 402
      goto while_break___0;
    }
#line 405
    if ((int )(cmap + i)->mtyp == 0) {
#line 405
      goto while_continue___0;
    }
#line 408
    cmp = (cmap + i)->cmp;
#line 408
    pcol = (unsigned short )(cmap + i)->pcol;
#line 409
    src = (old_comps + cmp)->data;
#line 410
    dst = (new_comps + pcol)->data;
#line 411
    max = (unsigned int )((new_comps + pcol)->w * (new_comps + pcol)->h);
#line 413
    j = (unsigned int )0;
    {
#line 413
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 413
      if (! (j < max)) {
#line 413
        goto while_break___1;
      }
#line 416
      k = *(src + j);
#line 416
      if (k < 0) {
#line 416
        k = 0;
      } else
#line 416
      if (k > top_k) {
#line 416
        k = top_k;
      }
#line 418
      *(dst + j) = (int )*(entries + (k * (int )nr_channels + (int )pcol));
#line 413
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 402
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 421
  max = (unsigned int )image->numcomps;
#line 422
  i = (unsigned short )0;
  {
#line 422
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 422
    if (! ((unsigned int )i < max)) {
#line 422
      goto while_break___2;
    }
#line 424
    if ((old_comps + i)->data) {
      {
#line 424
      free((old_comps + i)->data);
      }
    }
#line 422
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 426
  free(old_comps);
#line 427
  image->comps = new_comps;
#line 428
  image->numcomps = (int )nr_channels;
#line 430
  jp2_free_pclr(color);
  }
  return;
}
}
#line 434 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_pclr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_pclr_t *jp2_pclr ;
  unsigned char *channel_size ;
  unsigned char *channel_sign ;
  unsigned int *entries ;
  unsigned short nr_entries ;
  unsigned short nr_channels ;
  unsigned short i ;
  unsigned short j ;
  unsigned char uc ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int tmp ;
  unsigned int *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;

  {
#line 450
  if (color->jp2_pclr) {
#line 450
    return (0);
  }
  {
#line 452
  __cil_tmp14 = cio_read(cio, 2);
#line 452
  nr_entries = (unsigned short )__cil_tmp14;
#line 453
  __cil_tmp15 = cio_read(cio, 1);
#line 453
  nr_channels = (unsigned short )__cil_tmp15;
#line 455
  __cil_tmp16 = malloc((unsigned long )((int )nr_channels * (int )nr_entries) * sizeof(unsigned int ));
#line 455
  entries = (unsigned int *)__cil_tmp16;
#line 457
  __cil_tmp17 = malloc((unsigned long )nr_channels);
#line 457
  channel_size = (unsigned char *)__cil_tmp17;
#line 458
  __cil_tmp18 = malloc((unsigned long )nr_channels);
#line 458
  channel_sign = (unsigned char *)__cil_tmp18;
#line 460
  __cil_tmp19 = malloc(sizeof(opj_jp2_pclr_t ));
#line 460
  jp2_pclr = (opj_jp2_pclr_t *)__cil_tmp19;
#line 461
  jp2_pclr->channel_sign = channel_sign;
#line 462
  jp2_pclr->channel_size = channel_size;
#line 463
  jp2_pclr->entries = entries;
#line 464
  jp2_pclr->nr_entries = nr_entries;
#line 465
  jp2_pclr->nr_channels = nr_channels;
#line 466
  jp2_pclr->cmap = (opj_jp2_cmap_comp_t *)((void *)0);
#line 468
  color->jp2_pclr = jp2_pclr;
#line 470
  i = (unsigned short )0;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! ((int )i < (int )nr_channels)) {
#line 470
      goto while_break;
    }
    {
#line 472
    __cil_tmp20 = cio_read(cio, 1);
#line 472
    uc = (unsigned char )__cil_tmp20;
#line 473
    *(channel_size + i) = (unsigned char )(((int )uc & 127) + 1);
    }
#line 474
    if ((int )uc & 128) {
#line 474
      tmp = 1;
    } else {
#line 474
      tmp = 0;
    }
#line 474
    *(channel_sign + i) = (unsigned char )tmp;
#line 470
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  j = (unsigned short )0;
  {
#line 477
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 477
    if (! ((int )j < (int )nr_entries)) {
#line 477
      goto while_break___0;
    }
#line 479
    i = (unsigned short )0;
    {
#line 479
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 479
      if (! ((int )i < (int )nr_channels)) {
#line 479
        goto while_break___1;
      }
      {
#line 482
      __cil_tmp22 = entries;
#line 482
      entries ++;
#line 482
      *__cil_tmp22 = cio_read(cio, ((int )*(channel_size + i) + 7) >> 3);
      }
#line 479
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 477
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 486
  return (1);
}
}
#line 489 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_cmap(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cmap_comp_t *cmap ;
  unsigned short i ;
  unsigned short nr_channels ;
  void *__cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
#line 499
  if (color->jp2_pclr == (void *)0) {
#line 499
    return (0);
  }
#line 504
  if ((color->jp2_pclr)->cmap) {
#line 504
    return (0);
  }
  {
#line 506
  nr_channels = (color->jp2_pclr)->nr_channels;
#line 507
  __cil_tmp8 = malloc((unsigned long )nr_channels * sizeof(opj_jp2_cmap_comp_t ));
#line 507
  cmap = (opj_jp2_cmap_comp_t *)__cil_tmp8;
#line 510
  i = (unsigned short )0;
  }
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! ((int )i < (int )nr_channels)) {
#line 510
      goto while_break;
    }
    {
#line 512
    __cil_tmp9 = cio_read(cio, 2);
#line 512
    (cmap + i)->cmp = (unsigned short )__cil_tmp9;
#line 513
    __cil_tmp10 = cio_read(cio, 1);
#line 513
    (cmap + i)->mtyp = (unsigned char )__cil_tmp10;
#line 514
    __cil_tmp11 = cio_read(cio, 1);
#line 514
    (cmap + i)->pcol = (unsigned char )__cil_tmp11;
    }
#line 510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  (color->jp2_pclr)->cmap = cmap;
#line 519
  return (1);
}
}
#line 522 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void jp2_apply_cdef(opj_image_t *image , opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  int color_space ;
  unsigned short i ;
  unsigned short n ;
  unsigned short cn ;
  unsigned short typ ;
  unsigned short asoc ;
  unsigned short acn ;
  opj_image_comp_t saved ;

  {
#line 528
  color_space = (int )image->color_space;
#line 529
  info = (color->jp2_cdef)->info;
#line 530
  n = (color->jp2_cdef)->n;
#line 532
  i = (unsigned short )0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((int )i < (int )n)) {
#line 532
      goto while_break;
    }
#line 535
    asoc = (info + i)->asoc;
#line 535
    if ((int )asoc == 0) {
#line 535
      goto while_continue;
    }
#line 537
    cn = (info + i)->cn;
#line 537
    typ = (info + i)->typ;
#line 537
    acn = (unsigned short )((int )asoc - 1);
#line 539
    if ((int )cn != (int )acn) {
      {
#line 543
      memcpy(& saved, image->comps + cn, sizeof(opj_image_comp_t ));
#line 544
      memcpy(image->comps + cn, image->comps + acn, sizeof(opj_image_comp_t ));
#line 545
      memcpy(image->comps + acn, & saved, sizeof(opj_image_comp_t ));
#line 547
      (info + i)->asoc = (unsigned short )((int )cn + 1);
#line 548
      (info + acn)->asoc = (unsigned short )((int )(info + acn)->cn + 1);
      }
    }
#line 532
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  if ((color->jp2_cdef)->info) {
    {
#line 551
    free((color->jp2_cdef)->info);
    }
  }
  {
#line 553
  free(color->jp2_cdef);
#line 553
  color->jp2_cdef = (opj_jp2_cdef_t *)((void *)0);
  }
  return;
}
}
#line 557 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_cdef(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  opj_jp2_cdef_info_t *info ;
  unsigned short i ;
  unsigned short n ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 569
  if (color->jp2_cdef) {
#line 569
    return (0);
  }
  {
#line 571
  __cil_tmp8 = cio_read(cio, 2);
#line 571
  n = (unsigned short )__cil_tmp8;
  }
#line 571
  if ((int )n == 0) {
#line 571
    return (0);
  }
  {
#line 573
  __cil_tmp9 = malloc((unsigned long )n * sizeof(opj_jp2_cdef_info_t ));
#line 573
  info = (opj_jp2_cdef_info_t *)__cil_tmp9;
#line 576
  __cil_tmp10 = malloc(sizeof(opj_jp2_cdef_t ));
#line 576
  color->jp2_cdef = (opj_jp2_cdef_t *)__cil_tmp10;
#line 577
  (color->jp2_cdef)->info = info;
#line 578
  (color->jp2_cdef)->n = n;
#line 580
  i = (unsigned short )0;
  }
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! ((int )i < (int )n)) {
#line 580
      goto while_break;
    }
    {
#line 582
    __cil_tmp11 = cio_read(cio, 2);
#line 582
    (info + i)->cn = (unsigned short )__cil_tmp11;
#line 583
    __cil_tmp12 = cio_read(cio, 2);
#line 583
    (info + i)->typ = (unsigned short )__cil_tmp12;
#line 584
    __cil_tmp13 = cio_read(cio, 2);
#line 584
    (info + i)->asoc = (unsigned short )__cil_tmp13;
    }
#line 580
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  return (1);
}
}
#line 590 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_colr(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_box_t *box ,
                              opj_jp2_color_t *color ) 
{ 
  int skip_len ;
  opj_common_ptr cinfo ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned char *start ;
  unsigned char *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 599
  if (color->jp2_has_colr) {
#line 599
    return (0);
  }
  {
#line 601
  cinfo = jp2->cinfo;
#line 603
  jp2->meth = cio_read(cio, 1);
#line 604
  jp2->precedence = cio_read(cio, 1);
#line 605
  jp2->approx = cio_read(cio, 1);
  }
#line 607
  if (jp2->meth == 1U) {
    {
#line 609
    jp2->enumcs = cio_read(cio, 4);
    }
  } else
#line 612
  if (jp2->meth == 2U) {
    {
#line 615
    __cil_tmp11 = cio_tell(cio);
#line 615
    skip_len = (box->init_pos + box->length) - __cil_tmp11;
    }
#line 616
    if (skip_len < 0) {
      {
#line 618
      opj_event_msg(cinfo, 1, "Error with COLR box size\n");
      }
#line 619
      return (0);
    }
#line 621
    if (skip_len > 0) {
      {
#line 625
      start = cio_getbp(cio);
#line 626
      __cil_tmp14 = malloc((unsigned long )skip_len);
#line 626
      color->icc_profile_buf = (unsigned char *)__cil_tmp14;
#line 627
      color->icc_profile_len = skip_len;
#line 629
      __cil_tmp15 = cio_tell(cio);
#line 629
      cio_skip(cio, (box->init_pos + box->length) - __cil_tmp15);
#line 631
      memcpy(color->icc_profile_buf, start, (unsigned long )skip_len);
      }
    }
  }
  {
#line 635
  __cil_tmp16 = cio_tell(cio);
  }
#line 635
  if (__cil_tmp16 - box->init_pos != box->length) {
    {
#line 637
    opj_event_msg(cinfo, 1, "Error with COLR Box\n");
    }
#line 638
    return (0);
  }
#line 640
  color->jp2_has_colr = (unsigned char )1;
#line 642
  return (1);
}
}
#line 645 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
opj_bool jp2_read_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_jp2_box_t box ;
  int jp2h_end ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  opj_bool __cil_tmp9 ;
  opj_bool __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;
  opj_bool __cil_tmp13 ;
  opj_bool __cil_tmp14 ;
  opj_bool __cil_tmp15 ;
  opj_bool __cil_tmp16 ;
  opj_bool __cil_tmp17 ;
  opj_bool __cil_tmp18 ;
  opj_bool __cil_tmp19 ;
  opj_bool __cil_tmp20 ;
  opj_bool __cil_tmp21 ;

  {
  {
#line 650
  cinfo = jp2->cinfo;
#line 652
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 652
  if (__cil_tmp7 == 0) {
#line 652
    return (0);
  }
  {
#line 653
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    if (1785737832 != box.type) {
#line 656
      if (box.type == 1785737827) {
        {
#line 658
        opj_event_msg(cinfo, 1, "Expected JP2H Marker\nU");
        }
#line 659
        return (0);
      }
#line 661
      if (box.length <= 8) {
#line 661
        return (0);
      }
      {
#line 662
      cio_skip(cio, box.length - 8);
      }
#line 664
      if (cio->bp >= cio->end) {
#line 664
        return (0);
      }
      {
#line 666
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 666
      if (__cil_tmp8 == 0) {
#line 666
        return (0);
      }
    }
#line 653
    if (! (1785737832 != box.type)) {
#line 653
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 670
  __cil_tmp9 = jp2_read_ihdr(jp2, cio);
  }
#line 670
  if (! __cil_tmp9) {
#line 671
    return (0);
  }
#line 672
  jp2h_end = box.init_pos + box.length;
#line 674
  if (jp2->bpc == 255U) {
    {
#line 676
    __cil_tmp10 = jp2_read_bpcc(jp2, cio);
    }
#line 676
    if (! __cil_tmp10) {
#line 677
      return (0);
    }
  }
  {
#line 679
  __cil_tmp11 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 679
  if (__cil_tmp11 == 0) {
#line 679
    return (0);
  }
  {
#line 681
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 681
    __cil_tmp12 = cio_tell(cio);
    }
#line 681
    if (! (__cil_tmp12 < jp2h_end)) {
#line 681
      goto while_break___0;
    }
#line 683
    if (box.type == 1668246642) {
      {
#line 685
      __cil_tmp13 = jp2_read_colr(jp2, cio, & box, color);
      }
#line 685
      if (! __cil_tmp13) {
#line 687
        if (box.length <= 8) {
#line 687
          return (0);
        }
        {
#line 688
        cio_seek(cio, box.init_pos + 8);
#line 689
        cio_skip(cio, box.length - 8);
        }
      }
      {
#line 691
      __cil_tmp14 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 691
      if (__cil_tmp14 == 0) {
#line 691
        return (0);
      }
#line 692
      goto while_continue___0;
    }
#line 694
    if (box.type == 1667523942) {
#line 694
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 696
        __cil_tmp15 = jp2_read_cdef(jp2, cio, & box, color);
        }
#line 696
        if (! __cil_tmp15) {
#line 698
          if (box.length <= 8) {
#line 698
            return (0);
          }
          {
#line 699
          cio_seek(cio, box.init_pos + 8);
#line 700
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 702
        __cil_tmp16 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 702
        if (__cil_tmp16 == 0) {
#line 702
          return (0);
        }
#line 703
        goto while_continue___0;
      }
    }
#line 705
    if (box.type == 1885564018) {
#line 705
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 707
        __cil_tmp17 = jp2_read_pclr(jp2, cio, & box, color);
        }
#line 707
        if (! __cil_tmp17) {
#line 709
          if (box.length <= 8) {
#line 709
            return (0);
          }
          {
#line 710
          cio_seek(cio, box.init_pos + 8);
#line 711
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 713
        __cil_tmp18 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 713
        if (__cil_tmp18 == 0) {
#line 713
          return (0);
        }
#line 714
        goto while_continue___0;
      }
    }
#line 716
    if (box.type == 1668112752) {
#line 716
      if (! jp2->ignore_pclr_cmap_cdef) {
        {
#line 718
        __cil_tmp19 = jp2_read_cmap(jp2, cio, & box, color);
        }
#line 718
        if (! __cil_tmp19) {
#line 720
          if (box.length <= 8) {
#line 720
            return (0);
          }
          {
#line 721
          cio_seek(cio, box.init_pos + 8);
#line 722
          cio_skip(cio, box.length - 8);
          }
        }
        {
#line 724
        __cil_tmp20 = jp2_read_boxhdr(cinfo, cio, & box);
        }
#line 724
        if (__cil_tmp20 == 0) {
#line 724
          return (0);
        }
#line 725
        goto while_continue___0;
      }
    }
#line 727
    if (box.length <= 8) {
#line 727
      return (0);
    }
    {
#line 728
    cio_seek(cio, box.init_pos + 8);
#line 729
    cio_skip(cio, box.length - 8);
#line 730
    __cil_tmp21 = jp2_read_boxhdr(cinfo, cio, & box);
    }
#line 730
    if (__cil_tmp21 == 0) {
#line 730
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 734
  cio_seek(cio, jp2h_end);
  }
#line 737
  return ((int )color->jp2_has_colr == 1);
}
}
#line 741 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
opj_image_t *opj_jp2_decode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_common_ptr cinfo ;
  opj_image_t *image ;
  opj_jp2_color_t color ;
  opj_bool __cil_tmp7 ;
  opj_image_t *__cil_tmp8 ;

  {
#line 745
  image = (opj_image_t *)((void *)0);
#line 748
  if (! jp2) {
#line 750
    return ((opj_image_t *)((void *)0));
  } else
#line 748
  if (! cio) {
#line 750
    return ((opj_image_t *)((void *)0));
  }
  {
#line 752
  memset(& color, 0, sizeof(opj_jp2_color_t ));
#line 753
  cinfo = jp2->cinfo;
#line 756
  __cil_tmp7 = jp2_read_struct(jp2, cio, & color);
  }
#line 756
  if (! __cil_tmp7) {
    {
#line 758
    free_color_data(& color);
#line 759
    opj_event_msg(cinfo, 1, "Failed to decode jp2 structure\n");
    }
#line 760
    return ((opj_image_t *)((void *)0));
  }
  {
#line 764
  image = j2k_decode(jp2->j2k, cio, cstr_info);
  }
#line 766
  if (! image) {
    {
#line 768
    free_color_data(& color);
#line 769
    opj_event_msg(cinfo, 1, "Failed to decode J2K image\n");
    }
#line 770
    return ((opj_image_t *)((void *)0));
  }
#line 773
  if (! jp2->ignore_pclr_cmap_cdef) {
#line 776
    if (jp2->enumcs == 16U) {
#line 777
      image->color_space = (OPJ_COLOR_SPACE )1;
    } else
#line 778
    if (jp2->enumcs == 17U) {
#line 779
      image->color_space = (OPJ_COLOR_SPACE )2;
    } else
#line 780
    if (jp2->enumcs == 18U) {
#line 781
      image->color_space = (OPJ_COLOR_SPACE )3;
    } else {
#line 783
      image->color_space = (OPJ_COLOR_SPACE )-1;
    }
#line 785
    if (color.jp2_cdef) {
      {
#line 787
      jp2_apply_cdef(image, & color);
      }
    }
#line 789
    if (color.jp2_pclr) {
#line 792
      if (! (color.jp2_pclr)->cmap) {
        {
#line 793
        jp2_free_pclr(& color);
        }
      } else {
        {
#line 795
        jp2_apply_pclr(& color, image, cinfo);
        }
      }
    }
#line 797
    if (color.icc_profile_buf) {
#line 799
      image->icc_profile_buf = color.icc_profile_buf;
#line 800
      color.icc_profile_buf = (unsigned char *)((void *)0);
#line 801
      image->icc_profile_len = color.icc_profile_len;
    }
  }
#line 805
  return (image);
}
}
#line 810 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
void jp2_write_jp2h(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 813
  box.init_pos = cio_tell(cio);
#line 814
  cio_skip(cio, 4);
#line 815
  cio_write(cio, (unsigned long long )1785737832, 4);
#line 817
  jp2_write_ihdr(jp2, cio);
  }
#line 819
  if (jp2->bpc == 255U) {
    {
#line 820
    jp2_write_bpcc(jp2, cio);
    }
  }
  {
#line 822
  jp2_write_colr(jp2, cio);
#line 824
  __cil_tmp5 = cio_tell(cio);
#line 824
  box.length = __cil_tmp5 - box.init_pos;
#line 825
  cio_seek(cio, box.init_pos);
#line 826
  cio_write(cio, (unsigned long long )box.length, 4);
#line 827
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 830 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void jp2_write_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  unsigned int i ;
  opj_jp2_box_t box ;
  int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 834
  box.init_pos = cio_tell(cio);
#line 835
  cio_skip(cio, 4);
#line 836
  cio_write(cio, (unsigned long long )1718909296, 4);
#line 838
  cio_write(cio, (unsigned long long )jp2->brand, 4);
#line 839
  cio_write(cio, (unsigned long long )jp2->minversion, 4);
#line 841
  i = (unsigned int )0;
  }
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;
#line 841
    if (! (i < jp2->numcl)) {
#line 841
      goto while_break;
    }
    {
#line 842
    cio_write(cio, (unsigned long long )*(jp2->cl + i), 4);
    }
#line 841
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 845
  __cil_tmp7 = cio_tell(cio);
#line 845
  box.length = __cil_tmp7 - box.init_pos;
#line 846
  cio_seek(cio, box.init_pos);
#line 847
  cio_write(cio, (unsigned long long )box.length, 4);
#line 848
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 851 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_ftyp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  int i ;
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 855
  cinfo = jp2->cinfo;
#line 857
  __cil_tmp6 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 857
  if (__cil_tmp6 == 0) {
    {
#line 858
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 859
    return (0);
  }
#line 861
  if (1718909296 != box.type) {
    {
#line 862
    opj_event_msg(cinfo, 1, "Expected FTYP Marker\nU");
    }
#line 863
    return (0);
  }
  {
#line 866
  jp2->brand = cio_read(cio, 4);
#line 867
  jp2->minversion = cio_read(cio, 4);
#line 868
  jp2->numcl = (unsigned int )((box.length - 16) / 4);
#line 869
  __cil_tmp9 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 869
  jp2->cl = (unsigned int *)__cil_tmp9;
#line 871
  i = 0;
  }
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 871
    if (! (i < (int )jp2->numcl)) {
#line 871
      goto while_break;
    }
    {
#line 872
    *(jp2->cl + i) = cio_read(cio, 4);
    }
#line 871
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 875
  __cil_tmp12 = cio_tell(cio);
  }
#line 875
  if (__cil_tmp12 - box.init_pos != box.length) {
    {
#line 876
    opj_event_msg(cinfo, 1, "Error with FTYP Box\n\262U");
    }
#line 877
    return (0);
  }
#line 880
  return (1);
}
}
#line 883 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static int jp2_write_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  unsigned int j2k_codestream_offset ;
  unsigned int j2k_codestream_length ;
  opj_jp2_box_t box ;
  opj_j2k_t *j2k ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  opj_bool __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 887
  j2k = jp2->j2k;
#line 889
  box.init_pos = cio_tell(cio);
#line 890
  cio_skip(cio, 4);
#line 891
  cio_write(cio, (unsigned long long )1785737827, 4);
#line 894
  __cil_tmp10 = cio_tell(cio);
#line 894
  j2k_codestream_offset = (unsigned int )__cil_tmp10;
#line 895
  __cil_tmp11 = j2k_encode(j2k, cio, image, cstr_info);
  }
#line 895
  if (! __cil_tmp11) {
    {
#line 896
    opj_event_msg(j2k->cinfo, 1, "Failed to encode image\n");
    }
#line 897
    return (0);
  }
  {
#line 899
  __cil_tmp12 = cio_tell(cio);
#line 899
  j2k_codestream_length = (unsigned int )__cil_tmp12 - j2k_codestream_offset;
#line 901
  jp2->j2k_codestream_offset = j2k_codestream_offset;
#line 902
  jp2->j2k_codestream_length = j2k_codestream_length;
#line 904
  box.length = (int )(8U + jp2->j2k_codestream_length);
#line 905
  cio_seek(cio, box.init_pos);
#line 906
  cio_write(cio, (unsigned long long )box.length, 4);
#line 907
  cio_seek(cio, box.init_pos + box.length);
  }
#line 909
  return (box.length);
}
}
#line 912 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp2c(opj_jp2_t *jp2 , opj_cio_t *cio , unsigned int *j2k_codestream_length ,
                              unsigned int *j2k_codestream_offset ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp7 ;
  opj_bool __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 915
  cinfo = jp2->cinfo;
#line 917
  __cil_tmp7 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 917
  if (__cil_tmp7 == 0) {
    {
#line 918
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 919
    return (0);
  }
  {
#line 921
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (1785737827 != box.type) {
#line 923
      if (box.length <= 8) {
#line 923
        return (0);
      }
      {
#line 924
      cio_skip(cio, box.length - 8);
#line 925
      __cil_tmp8 = jp2_read_boxhdr(cinfo, cio, & box);
      }
#line 925
      if (__cil_tmp8 == 0) {
#line 925
        return (0);
      }
    }
#line 921
    if (! (1785737827 != box.type)) {
#line 921
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 929
  __cil_tmp9 = cio_tell(cio);
#line 929
  *j2k_codestream_offset = (unsigned int )__cil_tmp9;
  }
#line 930
  if (box.length <= 8) {
#line 930
    return (0);
  }
#line 931
  *j2k_codestream_length = (unsigned int )(box.length - 8);
#line 933
  return (1);
}
}
#line 936 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void jp2_write_jp(opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 939
  box.init_pos = cio_tell(cio);
#line 940
  cio_skip(cio, 4);
#line 941
  cio_write(cio, (unsigned long long )1783636000, 4);
#line 942
  cio_write(cio, (unsigned long long )218793738, 4);
#line 944
  __cil_tmp4 = cio_tell(cio);
#line 944
  box.length = __cil_tmp4 - box.init_pos;
#line 945
  cio_seek(cio, box.init_pos);
#line 946
  cio_write(cio, (unsigned long long )box.length, 4);
#line 947
  cio_seek(cio, box.init_pos + box.length);
  }
  return;
}
}
#line 950 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_jp(opj_jp2_t *jp2 , opj_cio_t *cio ) 
{ 
  opj_jp2_box_t box ;
  opj_common_ptr cinfo ;
  opj_bool __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 953
  cinfo = jp2->cinfo;
#line 955
  __cil_tmp5 = jp2_read_boxhdr(cinfo, cio, & box);
  }
#line 955
  if (__cil_tmp5 == 0) {
    {
#line 956
    opj_event_msg(cinfo, 1, "Failed to read boxhdr\n");
    }
#line 957
    return (0);
  }
#line 959
  if (1783636000 != box.type) {
    {
#line 960
    opj_event_msg(cinfo, 1, "Expected JP Marker\n");
    }
#line 961
    return (0);
  }
  {
#line 963
  __cil_tmp6 = cio_read(cio, 4);
  }
#line 963
  if (218793738U != __cil_tmp6) {
    {
#line 964
    opj_event_msg(cinfo, 1, "Error with JP Marker\n");
    }
#line 965
    return (0);
  }
  {
#line 967
  __cil_tmp7 = cio_tell(cio);
  }
#line 967
  if (__cil_tmp7 - box.init_pos != box.length) {
    {
#line 968
    opj_event_msg(cinfo, 1, "Error with JP Box size\n");
    }
#line 969
    return (0);
  }
#line 972
  return (1);
}
}
#line 976 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static opj_bool jp2_read_struct(opj_jp2_t *jp2 , opj_cio_t *cio , opj_jp2_color_t *color ) 
{ 
  opj_bool __cil_tmp4 ;
  opj_bool __cil_tmp5 ;
  opj_bool __cil_tmp6 ;
  opj_bool __cil_tmp7 ;

  {
  {
#line 978
  __cil_tmp4 = jp2_read_jp(jp2, cio);
  }
#line 978
  if (! __cil_tmp4) {
#line 979
    return (0);
  }
  {
#line 980
  __cil_tmp5 = jp2_read_ftyp(jp2, cio);
  }
#line 980
  if (! __cil_tmp5) {
#line 981
    return (0);
  }
  {
#line 982
  __cil_tmp6 = jp2_read_jp2h(jp2, cio, color);
  }
#line 982
  if (! __cil_tmp6) {
#line 983
    return (0);
  }
  {
#line 984
  __cil_tmp7 = jp2_read_jp2c(jp2, cio, & jp2->j2k_codestream_length, & jp2->j2k_codestream_offset);
  }
#line 984
  if (! __cil_tmp7) {
#line 985
    return (0);
  }
#line 987
  return (1);
}
}
#line 991 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static int write_fidx(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                      opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 995
  lenp = cio_tell(cio);
#line 996
  cio_skip(cio, 4);
#line 997
  cio_write(cio, (unsigned long long )1718183032, 4);
#line 999
  write_prxy(offset_jp2c, length_jp2c, offset_idx, length_idx, cio);
#line 1001
  __cil_tmp9 = cio_tell(cio);
#line 1001
  len = __cil_tmp9 - lenp;
#line 1002
  cio_seek(cio, lenp);
#line 1003
  cio_write(cio, (unsigned long long )len, 4);
#line 1004
  cio_seek(cio, lenp + len);
  }
#line 1006
  return (len);
}
}
#line 1009 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void write_prxy(int offset_jp2c , int length_jp2c , int offset_idx , int length_idx ,
                       opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1013
  lenp = cio_tell(cio);
#line 1014
  cio_skip(cio, 4);
#line 1015
  cio_write(cio, (unsigned long long )1886550137, 4);
#line 1017
  cio_write(cio, (unsigned long long )offset_jp2c, 8);
#line 1018
  cio_write(cio, (unsigned long long )length_jp2c, 4);
#line 1019
  cio_write(cio, (unsigned long long )1785737827, 4);
#line 1021
  cio_write(cio, (unsigned long long )1, 1);
#line 1023
  cio_write(cio, (unsigned long long )offset_idx, 8);
#line 1024
  cio_write(cio, (unsigned long long )length_idx, 4);
#line 1025
  cio_write(cio, (unsigned long long )1667851384, 4);
#line 1027
  __cil_tmp9 = cio_tell(cio);
#line 1027
  len = __cil_tmp9 - lenp;
#line 1028
  cio_seek(cio, lenp);
#line 1029
  cio_write(cio, (unsigned long long )len, 4);
#line 1030
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1033 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
static void write_iptr(int offset , int length , opj_cio_t *cio ) 
{ 
  int len ;
  int lenp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1037
  lenp = cio_tell(cio);
#line 1038
  cio_skip(cio, 4);
#line 1039
  cio_write(cio, (unsigned long long )1768977522, 4);
#line 1041
  cio_write(cio, (unsigned long long )offset, 8);
#line 1042
  cio_write(cio, (unsigned long long )length, 8);
#line 1044
  __cil_tmp7 = cio_tell(cio);
#line 1044
  len = __cil_tmp7 - lenp;
#line 1045
  cio_seek(cio, lenp);
#line 1046
  cio_write(cio, (unsigned long long )len, 4);
#line 1047
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 1055 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 1056
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_jp2_t ));
#line 1056
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1057
  if (jp2) {
    {
#line 1058
    jp2->cinfo = cinfo;
#line 1060
    jp2->j2k = j2k_create_decompress(cinfo);
    }
#line 1061
    if (jp2->j2k == (void *)0) {
      {
#line 1062
      jp2_destroy_decompress(jp2);
      }
#line 1063
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1066
  return (jp2);
}
}
#line 1069 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
void jp2_destroy_decompress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1070
  if (jp2) {
    {
#line 1072
    j2k_destroy_decompress(jp2->j2k);
    }
#line 1074
    if (jp2->comps) {
      {
#line 1075
      free(jp2->comps);
      }
    }
#line 1077
    if (jp2->cl) {
      {
#line 1078
      free(jp2->cl);
      }
    }
    {
#line 1080
    free(jp2);
    }
  }
  return;
}
}
#line 1084 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
void jp2_setup_decoder(opj_jp2_t *jp2 , opj_dparameters_t *parameters ) 
{ 


  {
  {
#line 1086
  j2k_setup_decoder(jp2->j2k, parameters);
#line 1088
  jp2->ignore_pclr_cmap_cdef = (opj_bool )(parameters->flags & 1U);
  }
  return;
}
}
#line 1095 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
opj_jp2_t *jp2_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_jp2_t *jp2 ;
  void *__cil_tmp3 ;
  opj_j2k_t *__cil_tmp4 ;

  {
  {
#line 1096
  __cil_tmp3 = malloc(sizeof(opj_jp2_t ));
#line 1096
  jp2 = (opj_jp2_t *)__cil_tmp3;
  }
#line 1097
  if (jp2) {
    {
#line 1098
    jp2->cinfo = cinfo;
#line 1100
    jp2->j2k = j2k_create_compress(cinfo);
    }
#line 1101
    if (jp2->j2k == (void *)0) {
      {
#line 1102
      jp2_destroy_compress(jp2);
      }
#line 1103
      return ((opj_jp2_t *)((void *)0));
    }
  }
#line 1106
  return (jp2);
}
}
#line 1109 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
void jp2_destroy_compress(opj_jp2_t *jp2 ) 
{ 


  {
#line 1110
  if (jp2) {
    {
#line 1112
    j2k_destroy_compress(jp2->j2k);
    }
#line 1114
    if (jp2->comps) {
      {
#line 1115
      free(jp2->comps);
      }
    }
#line 1117
    if (jp2->cl) {
      {
#line 1118
      free(jp2->cl);
      }
    }
    {
#line 1120
    free(jp2);
    }
  }
  return;
}
}
#line 1124 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
void jp2_setup_encoder(opj_jp2_t *jp2 , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int depth_0 ;
  int sign ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  int depth ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1128
  if (! jp2) {
#line 1129
    return;
  } else
#line 1128
  if (! parameters) {
#line 1129
    return;
  } else
#line 1128
  if (! image) {
#line 1129
    return;
  }
#line 1135
  if (image->numcomps < 1) {
    {
    {
#line 1136
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 1137
    return;
  } else
#line 1135
  if (image->numcomps > 16384) {
    {
    {
#line 1136
    opj_event_msg(jp2->cinfo, 1, "Invalid number of components specified while setting up JP2 encoder\n");
    }
    }
#line 1137
    return;
  }
  {
#line 1140
  j2k_setup_encoder(jp2->j2k, parameters, image);
#line 1147
  jp2->brand = (unsigned int )1785737760;
#line 1148
  jp2->minversion = (unsigned int )0;
#line 1149
  jp2->numcl = (unsigned int )1;
#line 1150
  __cil_tmp7 = malloc((unsigned long )jp2->numcl * sizeof(unsigned int ));
#line 1150
  jp2->cl = (unsigned int *)__cil_tmp7;
#line 1151
  *(jp2->cl + 0) = (unsigned int )1785737760;
#line 1155
  jp2->numcomps = (unsigned int )image->numcomps;
#line 1156
  __cil_tmp8 = malloc((unsigned long )jp2->numcomps * sizeof(opj_jp2_comps_t ));
#line 1156
  jp2->comps = (opj_jp2_comps_t *)__cil_tmp8;
#line 1157
  jp2->h = (unsigned int )(image->y1 - image->y0);
#line 1158
  jp2->w = (unsigned int )(image->x1 - image->x0);
#line 1160
  depth_0 = (image->comps + 0)->prec - 1;
#line 1161
  sign = (image->comps + 0)->sgnd;
#line 1162
  jp2->bpc = (unsigned int )(depth_0 + (sign << 7));
#line 1163
  i = 1;
  }
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1163
    if (! (i < image->numcomps)) {
#line 1163
      goto while_break;
    }
#line 1164
    depth = (image->comps + i)->prec - 1;
#line 1165
    sign = (image->comps + i)->sgnd;
#line 1166
    if (depth_0 != depth) {
#line 1167
      jp2->bpc = (unsigned int )255;
    }
#line 1163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1169
  jp2->C = (unsigned int )7;
#line 1170
  jp2->UnkC = (unsigned int )0;
#line 1171
  jp2->IPR = (unsigned int )0;
#line 1175
  i = 0;
  {
#line 1175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1175
    if (! (i < image->numcomps)) {
#line 1175
      goto while_break___0;
    }
#line 1176
    (jp2->comps + i)->bpcc = ((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7);
#line 1175
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1178
  jp2->meth = (unsigned int )1;
#line 1179
  if ((int )image->color_space == 1) {
#line 1180
    jp2->enumcs = (unsigned int )16;
  } else
#line 1181
  if ((int )image->color_space == 2) {
#line 1182
    jp2->enumcs = (unsigned int )17;
  } else
#line 1183
  if ((int )image->color_space == 3) {
#line 1184
    jp2->enumcs = (unsigned int )18;
  }
#line 1185
  jp2->precedence = (unsigned int )0;
#line 1186
  jp2->approx = (unsigned int )0;
#line 1188
  jp2->jpip_on = parameters->jpip_on;
  return;
}
}
#line 1191 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/jp2.c"
opj_bool opj_jp2_encode(opj_jp2_t *jp2 , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int pos_iptr ;
  int pos_cidx ;
  int pos_jp2c ;
  int len_jp2c ;
  int len_cidx ;
  int end_pos ;
  int pos_fidx ;
  int len_fidx ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1194
  pos_iptr = - 1;
#line 1194
  pos_jp2c = pos_iptr;
#line 1199
  jp2_write_jp(cio);
#line 1201
  jp2_write_ftyp(jp2, cio);
#line 1203
  jp2_write_jp2h(jp2, cio);
  }
#line 1205
  if (jp2->jpip_on) {
    {
#line 1206
    pos_iptr = cio_tell(cio);
#line 1207
    cio_skip(cio, 24);
#line 1209
    pos_jp2c = cio_tell(cio);
    }
  }
  {
#line 1213
  len_jp2c = jp2_write_jp2c(jp2, cio, image, cstr_info);
  }
#line 1213
  if (! len_jp2c) {
    {
#line 1214
    opj_event_msg(jp2->cinfo, 1, "Failed to encode image\n");
    }
#line 1215
    return (0);
  }
#line 1218
  if (jp2->jpip_on) {
    {
#line 1219
    pos_cidx = cio_tell(cio);
#line 1221
    len_cidx = write_cidx(pos_jp2c + 8, cio, image, *cstr_info, len_jp2c - 8);
#line 1223
    pos_fidx = cio_tell(cio);
#line 1224
    len_fidx = write_fidx(pos_jp2c, len_jp2c, pos_cidx, len_cidx, cio);
#line 1226
    end_pos = cio_tell(cio);
#line 1228
    cio_seek(cio, pos_iptr);
#line 1229
    write_iptr(pos_fidx, len_fidx, cio);
#line 1231
    cio_seek(cio, end_pos);
    }
  }
#line 1234
  return (1);
}
}
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 75
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 83
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 141
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 145
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 87
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 93
extern  __attribute__((__nothrow__)) int getpriority(__priority_which_t __which ,
                                                     id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 46 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 36 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k_lib.c"
double opj_clock(void) 
{ 
  struct rusage t ;
  double procTime ;

  {
  {
#line 51
  getrusage(0, & t);
#line 54
  procTime = (double )(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
  }
#line 56
  return (procTime + (double )(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-06);
}
}
#line 46 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) ;
#line 51
static void j2k_read_soc(opj_j2k_t *j2k ) ;
#line 56
static void j2k_write_siz(opj_j2k_t *j2k ) ;
#line 61
static void j2k_read_siz(opj_j2k_t *j2k ) ;
#line 66
static void j2k_write_com(opj_j2k_t *j2k ) ;
#line 71
static void j2k_read_com(opj_j2k_t *j2k ) ;
#line 77
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) ;
#line 83
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) ;
#line 88
static void j2k_write_cod(opj_j2k_t *j2k ) ;
#line 93
static void j2k_read_cod(opj_j2k_t *j2k ) ;
#line 99
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) ;
#line 104
static void j2k_read_coc(opj_j2k_t *j2k ) ;
#line 110
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) ;
#line 117
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) ;
#line 122
static void j2k_write_qcd(opj_j2k_t *j2k ) ;
#line 127
static void j2k_read_qcd(opj_j2k_t *j2k ) ;
#line 133
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) ;
#line 138
static void j2k_read_qcc(opj_j2k_t *j2k ) ;
#line 143
static void j2k_write_poc(opj_j2k_t *j2k ) ;
#line 148
static void j2k_read_poc(opj_j2k_t *j2k ) ;
#line 153
static void j2k_read_crg(opj_j2k_t *j2k ) ;
#line 158
static void j2k_read_tlm(opj_j2k_t *j2k ) ;
#line 163
static void j2k_read_plm(opj_j2k_t *j2k ) ;
#line 168
static void j2k_read_plt(opj_j2k_t *j2k ) ;
#line 173
static void j2k_read_ppm(opj_j2k_t *j2k ) ;
#line 178
static void j2k_read_ppt(opj_j2k_t *j2k ) ;
#line 183
static void j2k_write_tlm(opj_j2k_t *j2k ) ;
#line 188
static void j2k_write_sot(opj_j2k_t *j2k ) ;
#line 193
static void j2k_read_sot(opj_j2k_t *j2k ) ;
#line 199
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) ;
#line 204
static void j2k_read_sod(opj_j2k_t *j2k ) ;
#line 211
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) ;
#line 216
static void j2k_read_rgn(opj_j2k_t *j2k ) ;
#line 221
static void j2k_write_eoc(opj_j2k_t *j2k ) ;
#line 226
static void j2k_read_eoc(opj_j2k_t *j2k ) ;
#line 231
static void j2k_read_unk(opj_j2k_t *j2k ) ;
#line 239
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 248
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) ;
#line 260 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
j2k_prog_order_t j2k_prog_order_list[6]  = {      {(OPJ_PROG_ORDER )4, {"CPRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )0, {"LRCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )3, {"PCRL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )1, {"RLCP", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )2, {"RPCL", (char )0, (char )0, (char )0, (char )0}}, 
        {(OPJ_PROG_ORDER )(- 1), {"\250", (char )0, (char )0, (char )0, (char )0}}};
#line 269 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order ) 
{ 
  j2k_prog_order_t *po ;
  j2k_prog_order_t *__cil_tmp3 ;

  {
#line 271
  po = (j2k_prog_order_t *)j2k_prog_order_list;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! ((int )po->enum_prog != -1)) {
#line 271
      goto while_break;
    }
#line 272
    if ((int )po->enum_prog == (int )prg_order) {
#line 273
      goto while_break;
    }
#line 271
    po ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return ((char *)po->str_prog);
}
}
#line 280 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static int j2k_get_num_tp(opj_cp_t *cp , int pino , int tileno ) 
{ 
  char *prog ;
  int i ;
  int tpnum ;
  int tpend ;
  opj_tcp_t *tcp ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 283
  tpnum = 1;
  {
#line 283
  tpend = 0;
#line 284
  tcp = cp->tcps + tileno;
#line 285
  prog = j2k_convert_progression_order(tcp->prg);
  }
#line 287
  if ((int )cp->tp_on == 1) {
#line 288
    i = 0;
    {
#line 288
    while (1) {
      while_continue: /* CIL Label */ ;
#line 288
      if (! (i < 4)) {
#line 288
        goto while_break;
      }
#line 289
      if (tpend != 1) {
#line 290
        if ((int )cp->tp_flag == (int )*(prog + i)) {
#line 291
          tpend = 1;
#line 291
          cp->tp_pos = i;
        }
        {
#line 294
        if ((int )*(prog + i) == 'C') {
#line 294
          goto case_67;
        }
#line 297
        if ((int )*(prog + i) == 'R') {
#line 297
          goto case_82;
        }
#line 300
        if ((int )*(prog + i) == 'P') {
#line 300
          goto case_80;
        }
#line 303
        if ((int )*(prog + i) == 'L') {
#line 303
          goto case_76;
        }
#line 293
        goto switch_break;
        case_67: /* CIL Label */ 
#line 295
        tpnum *= tcp->pocs[pino].compE;
#line 296
        goto switch_break;
        case_82: /* CIL Label */ 
#line 298
        tpnum *= tcp->pocs[pino].resE;
#line 299
        goto switch_break;
        case_80: /* CIL Label */ 
#line 301
        tpnum *= tcp->pocs[pino].prcE;
#line 302
        goto switch_break;
        case_76: /* CIL Label */ 
#line 304
        tpnum *= tcp->pocs[pino].layE;
#line 305
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 288
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 310
    tpnum = 1;
  }
#line 312
  return (tpnum);
}
}
#line 316 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
int j2k_calculate_tp(opj_cp_t *cp , int img_numcomp , opj_image_t *image , opj_j2k_t *j2k ) 
{ 
  int pino ;
  int tileno ;
  int totnum_tp ;
  void *__cil_tmp8 ;
  int cur_totnum_tp ;
  opj_tcp_t *tcp ;
  int tp_num ;
  opj_pi_iterator_t *pi ;
  opj_pi_iterator_t *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 317
  totnum_tp = 0;
#line 321
  __cil_tmp8 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 321
  j2k->cur_totnum_tp = (int *)__cil_tmp8;
#line 322
  tileno = 0;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (tileno < cp->tw * cp->th)) {
#line 322
      goto while_break;
    }
#line 323
    cur_totnum_tp = 0;
#line 324
    tcp = cp->tcps + tileno;
#line 325
    pino = 0;
    {
#line 325
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 325
      if (! (pino <= tcp->numpocs)) {
#line 325
        goto while_break___0;
      }
      {
#line 326
      tp_num = 0;
#line 327
      __cil_tmp13 = pi_initialise_encode(image, cp, tileno, (J2K_T2_MODE )1);
#line 327
      pi = __cil_tmp13;
      }
#line 328
      if (! pi) {
#line 328
        return (- 1);
      }
      {
#line 329
      tp_num = j2k_get_num_tp(cp, pino, tileno);
#line 330
      totnum_tp += tp_num;
#line 331
      cur_totnum_tp += tp_num;
#line 332
      pi_destroy(pi, cp, tileno);
      }
#line 325
      pino ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 334
    *(j2k->cur_totnum_tp + tileno) = cur_totnum_tp;
#line 336
    if (j2k->cstr_info) {
      {
#line 337
      ((j2k->cstr_info)->tile + tileno)->num_tps = cur_totnum_tp;
#line 338
      __cil_tmp16 = malloc((unsigned long )cur_totnum_tp * sizeof(opj_tp_info_t ));
#line 338
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp16;
      }
    }
#line 322
    tileno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return (totnum_tp);
}
}
#line 345 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_soc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;
  int __cil_tmp3 ;

  {
  {
#line 346
  cio = j2k->cio;
#line 347
  cio_write(cio, (unsigned long long )65359, 2);
  }
#line 349
  if (j2k->cstr_info) {
    {
#line 350
    __cil_tmp3 = cio_tell(cio);
#line 350
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65359, __cil_tmp3, 0);
    }
  }
  return;
}
}
#line 361 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_soc(opj_j2k_t *j2k ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 362
  j2k->state = 2;
#line 364
  if (j2k->cstr_info) {
    {
#line 365
    __cil_tmp2 = cio_tell(j2k->cio);
#line 365
    (j2k->cstr_info)->main_head_start = __cil_tmp2 - 2;
#line 366
    __cil_tmp3 = cio_numbytesleft(j2k->cio);
#line 366
    (j2k->cstr_info)->codestream_size = (__cil_tmp3 + 2) - (j2k->cstr_info)->main_head_start;
    }
  }
  return;
}
}
#line 370 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_siz(opj_j2k_t *j2k ) 
{ 
  int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 374
  cio = j2k->cio;
#line 375
  image = j2k->image;
#line 376
  cp = j2k->cp;
#line 378
  cio_write(cio, (unsigned long long )65361, 2);
#line 379
  lenp = cio_tell(cio);
#line 380
  cio_skip(cio, 2);
#line 381
  cio_write(cio, (unsigned long long )cp->rsiz, 2);
#line 382
  cio_write(cio, (unsigned long long )image->x1, 4);
#line 383
  cio_write(cio, (unsigned long long )image->y1, 4);
#line 384
  cio_write(cio, (unsigned long long )image->x0, 4);
#line 385
  cio_write(cio, (unsigned long long )image->y0, 4);
#line 386
  cio_write(cio, (unsigned long long )cp->tdx, 4);
#line 387
  cio_write(cio, (unsigned long long )cp->tdy, 4);
#line 388
  cio_write(cio, (unsigned long long )cp->tx0, 4);
#line 389
  cio_write(cio, (unsigned long long )cp->ty0, 4);
#line 390
  cio_write(cio, (unsigned long long )image->numcomps, 2);
#line 391
  i = 0;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (i < image->numcomps)) {
#line 391
      goto while_break;
    }
    {
#line 392
    cio_write(cio, (unsigned long long )(((image->comps + i)->prec - 1) + ((image->comps + i)->sgnd << 7)),
              1);
#line 393
    cio_write(cio, (unsigned long long )(image->comps + i)->dx, 1);
#line 394
    cio_write(cio, (unsigned long long )(image->comps + i)->dy, 1);
    }
#line 391
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 396
  __cil_tmp10 = cio_tell(cio);
#line 396
  len = __cil_tmp10 - lenp;
#line 397
  cio_seek(cio, lenp);
#line 398
  cio_write(cio, (unsigned long long )len, 2);
#line 399
  cio_seek(cio, lenp + len);
  }
#line 401
  if (j2k->cstr_info) {
    {
#line 402
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65361, lenp, len);
    }
  }
  return;
}
}
#line 405 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_siz(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  opj_cp_t *cp ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  void *__cil_tmp17 ;
  int tmp ;
  int w ;
  int h ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  int __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp38 ;

  {
  {
#line 408
  cio = j2k->cio;
#line 409
  image = j2k->image;
#line 410
  cp = j2k->cp;
#line 412
  __cil_tmp7 = cio_read(cio, 2);
#line 412
  len = (int )__cil_tmp7;
#line 413
  cio_read(cio, 2);
#line 414
  __cil_tmp8 = cio_read(cio, 4);
#line 414
  image->x1 = (int )__cil_tmp8;
#line 415
  __cil_tmp9 = cio_read(cio, 4);
#line 415
  image->y1 = (int )__cil_tmp9;
#line 416
  __cil_tmp10 = cio_read(cio, 4);
#line 416
  image->x0 = (int )__cil_tmp10;
#line 417
  __cil_tmp11 = cio_read(cio, 4);
#line 417
  image->y0 = (int )__cil_tmp11;
#line 418
  __cil_tmp12 = cio_read(cio, 4);
#line 418
  cp->tdx = (int )__cil_tmp12;
#line 419
  __cil_tmp13 = cio_read(cio, 4);
#line 419
  cp->tdy = (int )__cil_tmp13;
#line 420
  __cil_tmp14 = cio_read(cio, 4);
#line 420
  cp->tx0 = (int )__cil_tmp14;
#line 421
  __cil_tmp15 = cio_read(cio, 4);
#line 421
  cp->ty0 = (int )__cil_tmp15;
  }
#line 423
  if (image->x0 < 0) {
    {
    {
    {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 427
    return;
  } else
#line 423
  if (image->x1 < 0) {
    {
    {
    {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 427
    return;
  } else
#line 423
  if (image->y0 < 0) {
    {
    {
    {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 427
    return;
  } else
#line 423
  if (image->y1 < 0) {
    {
    {
    {
    {
#line 424
    opj_event_msg(j2k->cinfo, 1, "%s: invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
                  image->x0, image->x1, image->y0, image->y1);
    }
    }
    }
    }
#line 427
    return;
  }
  {
#line 430
  __cil_tmp16 = cio_read(cio, 2);
#line 430
  image->numcomps = (int )__cil_tmp16;
#line 471
  __cil_tmp17 = calloc((unsigned long )image->numcomps, sizeof(opj_image_comp_t ));
#line 471
  image->comps = (opj_image_comp_t *)__cil_tmp17;
#line 472
  i = 0;
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! (i < image->numcomps)) {
#line 472
      goto while_break;
    }
    {
#line 474
    __cil_tmp21 = cio_read(cio, 1);
#line 474
    tmp = (int )__cil_tmp21;
#line 475
    (image->comps + i)->prec = (tmp & 127) + 1;
#line 476
    (image->comps + i)->sgnd = tmp >> 7;
#line 477
    __cil_tmp22 = cio_read(cio, 1);
#line 477
    (image->comps + i)->dx = (int )__cil_tmp22;
#line 478
    __cil_tmp23 = cio_read(cio, 1);
#line 478
    (image->comps + i)->dy = (int )__cil_tmp23;
#line 510
    w = int_ceildiv(image->x1 - image->x0, (image->comps + i)->dx);
#line 511
    h = int_ceildiv(image->y1 - image->y0, (image->comps + i)->dy);
#line 513
    (image->comps + i)->resno_decoded = 0;
#line 514
    (image->comps + i)->factor = cp->reduce;
    }
#line 472
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 517
  cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 518
  cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
#line 560
  __cil_tmp29 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 560
  cp->tcps = (opj_tcp_t *)__cil_tmp29;
  }
#line 561
  if (cp->tcps == (void *)0) {
    {
#line 563
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 564
    return;
  }
  {
#line 566
  __cil_tmp30 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(int ));
#line 566
  cp->tileno = (int *)__cil_tmp30;
  }
#line 567
  if (cp->tileno == (void *)0) {
    {
#line 569
    opj_event_msg(j2k->cinfo, 1, "Out of memory\n");
    }
#line 570
    return;
  }
#line 572
  cp->tileno_size = 0;
#line 587
  i = 0;
  {
#line 587
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 587
    if (! (i < cp->tw * cp->th)) {
#line 587
      goto while_break___0;
    }
#line 588
    (cp->tcps + i)->POC = 0;
#line 589
    (cp->tcps + i)->numpocs = 0;
#line 590
    (cp->tcps + i)->first = 1;
#line 587
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 594
  cp->ppm = 0;
#line 595
  cp->ppm_data = (unsigned char *)((void *)0);
#line 596
  cp->ppm_data_first = (unsigned char *)((void *)0);
#line 597
  cp->ppm_previous = 0;
#line 598
  cp->ppm_store = 0;
#line 600
  __cil_tmp32 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 600
  (j2k->default_tcp)->tccps = (opj_tccp_t *)__cil_tmp32;
#line 601
  i = 0;
  }
  {
#line 601
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 601
    if (! (i < cp->tw * cp->th)) {
#line 601
      goto while_break___1;
    }
    {
#line 602
    __cil_tmp33 = malloc((unsigned long )image->numcomps * sizeof(opj_tccp_t ));
#line 602
    (cp->tcps + i)->tccps = (opj_tccp_t *)__cil_tmp33;
    }
#line 601
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 604
  __cil_tmp35 = calloc((unsigned long )(cp->tw * cp->th), sizeof(unsigned char *));
#line 604
  j2k->tile_data = (unsigned char **)__cil_tmp35;
#line 605
  __cil_tmp36 = calloc((unsigned long )(cp->tw * cp->th), sizeof(int ));
#line 605
  j2k->tile_len = (int *)__cil_tmp36;
#line 606
  j2k->state = 4;
  }
#line 609
  if (j2k->cstr_info) {
    {
#line 610
    cstr_info = j2k->cstr_info;
#line 611
    cstr_info->image_w = image->x1 - image->x0;
#line 612
    cstr_info->image_h = image->y1 - image->y0;
#line 613
    cstr_info->numcomps = image->numcomps;
#line 614
    cstr_info->tw = cp->tw;
#line 615
    cstr_info->th = cp->th;
#line 616
    cstr_info->tile_x = cp->tdx;
#line 617
    cstr_info->tile_y = cp->tdy;
#line 618
    cstr_info->tile_Ox = cp->tx0;
#line 619
    cstr_info->tile_Oy = cp->ty0;
#line 620
    __cil_tmp38 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tile_info_t ));
#line 620
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp38;
    }
  }
  return;
}
}
#line 624 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_com(opj_j2k_t *j2k ) 
{ 
  unsigned int i ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  char *comment ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 628
  if ((j2k->cp)->comment) {
    {
#line 629
    cio = j2k->cio;
#line 630
    comment = (j2k->cp)->comment;
#line 632
    cio_write(cio, (unsigned long long )65380, 2);
#line 633
    lenp = cio_tell(cio);
#line 634
    cio_skip(cio, 2);
#line 635
    cio_write(cio, (unsigned long long )1, 2);
#line 636
    i = (unsigned int )0;
    }
    {
#line 636
    while (1) {
      while_continue: /* CIL Label */ ;
#line 636
      if (! ((unsigned long )i < __cil_tmp8)) {
#line 636
        goto while_break;
      }
      {
#line 637
      cio_write(cio, (unsigned long long )*(comment + i), 1);
      }
#line 636
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 639
    __cil_tmp10 = cio_tell(cio);
#line 639
    len = __cil_tmp10 - lenp;
#line 640
    cio_seek(cio, lenp);
#line 641
    cio_write(cio, (unsigned long long )len, 2);
#line 642
    cio_seek(cio, lenp + len);
    }
#line 645
    if (j2k->cstr_info) {
      {
#line 646
      j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65380, lenp, len);
      }
    }
  }
  return;
}
}
#line 651 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_com(opj_j2k_t *j2k ) 
{ 
  int len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp4 ;

  {
  {
#line 654
  cio = j2k->cio;
#line 656
  __cil_tmp4 = cio_read(cio, 2);
#line 656
  len = (int )__cil_tmp4;
#line 657
  cio_skip(cio, len - 2);
  }
  return;
}
}
#line 660 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int __cil_tmp8 ;

  {
  {
#line 663
  cp = j2k->cp;
#line 664
  tcp = cp->tcps + j2k->curtileno;
#line 665
  tccp = tcp->tccps + compno;
#line 666
  cio = j2k->cio;
#line 668
  cio_write(cio, (unsigned long long )(tccp->numresolutions - 1), 1);
#line 669
  cio_write(cio, (unsigned long long )(tccp->cblkw - 2), 1);
#line 670
  cio_write(cio, (unsigned long long )(tccp->cblkh - 2), 1);
#line 671
  cio_write(cio, (unsigned long long )tccp->cblksty, 1);
#line 672
  cio_write(cio, (unsigned long long )tccp->qmfbid, 1);
  }
#line 674
  if (tccp->csty & 1) {
#line 675
    i = 0;
    {
#line 675
    while (1) {
      while_continue: /* CIL Label */ ;
#line 675
      if (! (i < tccp->numresolutions)) {
#line 675
        goto while_break;
      }
      {
#line 676
      cio_write(cio, (unsigned long long )(tccp->prcw[i] + (tccp->prch[i] << 4)),
                1);
      }
#line 675
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 681 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_cox(opj_j2k_t *j2k , int compno ) 
{ 
  int i ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int tmp___0 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 684
  cp = j2k->cp;
#line 685
  if (j2k->state == 16) {
#line 685
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 685
    tmp = j2k->default_tcp;
  }
  {
#line 685
  tcp = tmp;
#line 686
  tccp = tcp->tccps + compno;
#line 687
  cio = j2k->cio;
#line 689
  __cil_tmp9 = cio_read(cio, 1);
#line 689
  tccp->numresolutions = (int )(__cil_tmp9 + 1U);
  }
#line 692
  if (cp->reduce >= tccp->numresolutions) {
    {
#line 693
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number of resolutions of this component\nModify the cp_reduce parameter.\n\n",
                  compno);
#line 695
    j2k->state |= 128;
    }
  }
#line 697
  if (tccp->numresolutions > 33) {
    {
#line 698
    opj_event_msg(j2k->cinfo, 1, "Error decoding component %d.\nThe number of resolutions is too big: %d vs max= %d. Truncating.\n\n",
                  compno, tccp->numresolutions, 33);
#line 700
    j2k->state |= 128;
#line 701
    tccp->numresolutions = 33;
    }
  }
  {
#line 704
  __cil_tmp10 = cio_read(cio, 1);
#line 704
  tccp->cblkw = (int )(__cil_tmp10 + 2U);
#line 705
  __cil_tmp11 = cio_read(cio, 1);
#line 705
  tccp->cblkh = (int )(__cil_tmp11 + 2U);
#line 706
  __cil_tmp12 = cio_read(cio, 1);
#line 706
  tccp->cblksty = (int )__cil_tmp12;
#line 707
  __cil_tmp13 = cio_read(cio, 1);
#line 707
  tccp->qmfbid = (int )__cil_tmp13;
  }
#line 708
  if (tccp->csty & 1) {
#line 709
    i = 0;
    {
#line 709
    while (1) {
      while_continue: /* CIL Label */ ;
#line 709
      if (! (i < tccp->numresolutions)) {
#line 709
        goto while_break;
      }
      {
#line 710
      __cil_tmp15 = cio_read(cio, 1);
#line 710
      tmp___0 = (int )__cil_tmp15;
#line 711
      tccp->prcw[i] = tmp___0 & 15;
#line 712
      tccp->prch[i] = tmp___0 >> 4;
      }
#line 709
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 717
  if (j2k->cstr_info) {
#line 717
    if (compno == 0) {
#line 718
      i = 0;
      {
#line 718
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 718
        if (! (i < tccp->numresolutions)) {
#line 718
          goto while_break___0;
        }
#line 719
        if (tccp->csty & 1) {
#line 720
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = tccp->prcw[i];
#line 721
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdy[i] = tccp->prch[i];
        } else {
#line 724
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
#line 725
          ((j2k->cstr_info)->tile + j2k->curtileno)->pdx[i] = 15;
        }
#line 718
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 732 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_cod(opj_j2k_t *j2k ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 733
  cp = (opj_cp_t *)((void *)0);
#line 734
  tcp = (opj_tcp_t *)((void *)0);
#line 737
  cio = j2k->cio;
#line 739
  cio_write(cio, (unsigned long long )65362, 2);
#line 741
  lenp = cio_tell(cio);
#line 742
  cio_skip(cio, 2);
#line 744
  cp = j2k->cp;
#line 745
  tcp = cp->tcps + j2k->curtileno;
#line 747
  cio_write(cio, (unsigned long long )tcp->csty, 1);
#line 748
  cio_write(cio, (unsigned long long )tcp->prg, 1);
#line 749
  cio_write(cio, (unsigned long long )tcp->numlayers, 2);
#line 750
  cio_write(cio, (unsigned long long )tcp->mct, 1);
#line 752
  j2k_write_cox(j2k, 0);
#line 753
  __cil_tmp8 = cio_tell(cio);
#line 753
  len = __cil_tmp8 - lenp;
#line 754
  cio_seek(cio, lenp);
#line 755
  cio_write(cio, (unsigned long long )len, 2);
#line 756
  cio_seek(cio, lenp + len);
  }
#line 758
  if (j2k->cstr_info) {
    {
#line 759
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65362, lenp, len);
    }
  }
  return;
}
}
#line 763 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_cod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_codestream_info_t *cstr_info ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 766
  cio = j2k->cio;
#line 767
  cp = j2k->cp;
#line 768
  if (j2k->state == 16) {
#line 768
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 768
    tmp = j2k->default_tcp;
  }
  {
#line 768
  tcp = tmp;
#line 769
  image = j2k->image;
#line 771
  __cil_tmp10 = cio_read(cio, 2);
#line 771
  len = (int )__cil_tmp10;
#line 772
  __cil_tmp11 = cio_read(cio, 1);
#line 772
  tcp->csty = (int )__cil_tmp11;
#line 773
  __cil_tmp12 = cio_read(cio, 1);
#line 773
  tcp->prg = (OPJ_PROG_ORDER )__cil_tmp12;
#line 774
  __cil_tmp13 = cio_read(cio, 2);
#line 774
  tcp->numlayers = (int )__cil_tmp13;
#line 775
  __cil_tmp14 = cio_read(cio, 1);
#line 775
  tcp->mct = (int )__cil_tmp14;
#line 777
  pos = cio_tell(cio);
#line 778
  i = 0;
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 778
    if (! (i < image->numcomps)) {
#line 778
      goto while_break;
    }
    {
#line 779
    (tcp->tccps + i)->csty = tcp->csty & 1;
#line 780
    cio_seek(cio, pos);
#line 781
    j2k_read_cox(j2k, i);
    }
#line 778
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  if (j2k->cstr_info) {
    {
#line 786
    cstr_info = j2k->cstr_info;
#line 787
    cstr_info->prog = tcp->prg;
#line 788
    cstr_info->numlayers = tcp->numlayers;
#line 789
    __cil_tmp18 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 789
    cstr_info->numdecompos = (int *)__cil_tmp18;
#line 790
    i = 0;
    }
    {
#line 790
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 790
      if (! (i < image->numcomps)) {
#line 790
        goto while_break___0;
      }
#line 791
      *(cstr_info->numdecompos + i) = (tcp->tccps + i)->numresolutions - 1;
#line 790
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 796 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_coc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;

  {
  {
#line 799
  cp = j2k->cp;
#line 800
  tcp = cp->tcps + j2k->curtileno;
#line 801
  image = j2k->image;
#line 802
  cio = j2k->cio;
#line 804
  cio_write(cio, (unsigned long long )65363, 2);
#line 805
  lenp = cio_tell(cio);
#line 806
  cio_skip(cio, 2);
  }
#line 807
  if (image->numcomps <= 256) {
#line 807
    tmp = 1;
  } else {
#line 807
    tmp = 2;
  }
  {
#line 807
  cio_write(cio, (unsigned long long )compno, tmp);
#line 808
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->csty, 1);
#line 809
  j2k_write_cox(j2k, compno);
#line 810
  __cil_tmp11 = cio_tell(cio);
#line 810
  len = __cil_tmp11 - lenp;
#line 811
  cio_seek(cio, lenp);
#line 812
  cio_write(cio, (unsigned long long )len, 2);
#line 813
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 816 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_coc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_image_t *image ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  int tmp___0 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;

  {
#line 819
  cp = j2k->cp;
#line 820
  if (j2k->state == 16) {
#line 820
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 820
    tmp = j2k->default_tcp;
  }
  {
#line 820
  tcp = tmp;
#line 821
  image = j2k->image;
#line 822
  cio = j2k->cio;
#line 824
  __cil_tmp9 = cio_read(cio, 2);
#line 824
  len = (int )__cil_tmp9;
  }
#line 825
  if (image->numcomps <= 256) {
#line 825
    tmp___0 = 1;
  } else {
#line 825
    tmp___0 = 2;
  }
  {
#line 825
  __cil_tmp11 = cio_read(cio, tmp___0);
#line 825
  compno = (int )__cil_tmp11;
#line 826
  __cil_tmp12 = cio_read(cio, 1);
#line 826
  (tcp->tccps + compno)->csty = (int )__cil_tmp12;
#line 827
  j2k_read_cox(j2k, compno);
  }
  return;
}
}
#line 830 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_qcx(opj_j2k_t *j2k , int compno ) 
{ 
  int bandno ;
  int numbands ;
  int expn ;
  int mant ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  int __cil_tmp12 ;

  {
  {
#line 834
  cp = j2k->cp;
#line 835
  tcp = cp->tcps + j2k->curtileno;
#line 836
  tccp = tcp->tccps + compno;
#line 837
  cio = j2k->cio;
#line 839
  cio_write(cio, (unsigned long long )(tccp->qntsty + (tccp->numgbits << 5)), 1);
  }
#line 840
  if (tccp->qntsty == 1) {
#line 840
    tmp = 1;
  } else {
#line 840
    tmp = tccp->numresolutions * 3 - 2;
  }
#line 840
  numbands = tmp;
#line 842
  bandno = 0;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 842
    if (! (bandno < numbands)) {
#line 842
      goto while_break;
    }
#line 843
    expn = tccp->stepsizes[bandno].expn;
#line 844
    mant = tccp->stepsizes[bandno].mant;
#line 846
    if (tccp->qntsty == 0) {
      {
#line 847
      cio_write(cio, (unsigned long long )(expn << 3), 1);
      }
    } else {
      {
#line 849
      cio_write(cio, (unsigned long long )((expn << 11) + mant), 2);
      }
    }
#line 842
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 854 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_qcx(opj_j2k_t *j2k , int compno , int len ) 
{ 
  int tmp ;
  int bandno ;
  int numbands ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp___11 ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  int tmp___12 ;
  int tmp___13 ;
  int expn ;
  int mant ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp___14 ;
  int __cil_tmp21 ;

  {
#line 858
  cp = j2k->cp;
#line 859
  if (j2k->state == 16) {
#line 859
    tmp___11 = cp->tcps + j2k->curtileno;
  } else {
#line 859
    tmp___11 = j2k->default_tcp;
  }
  {
#line 859
  tcp = tmp___11;
#line 860
  tccp = tcp->tccps + compno;
#line 861
  cio = j2k->cio;
#line 863
  __cil_tmp12 = cio_read(cio, 1);
#line 863
  tmp = (int )__cil_tmp12;
#line 864
  tccp->qntsty = tmp & 31;
#line 865
  tccp->numgbits = tmp >> 5;
  }
#line 866
  if (tccp->qntsty == 1) {
#line 866
    tmp___13 = 1;
  } else {
#line 866
    if (tccp->qntsty == 0) {
#line 866
      tmp___12 = len - 1;
    } else {
#line 866
      tmp___12 = (len - 1) / 2;
    }
#line 866
    tmp___13 = tmp___12;
  }
#line 866
  numbands = tmp___13;
#line 892
  if (numbands < 0) {
    {
    {
#line 893
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
    }
  } else
#line 892
  if (numbands >= 97) {
    {
    {
#line 893
    opj_event_msg(j2k->cinfo, 2, "bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n",
                  numbands, 97);
    }
    }
  }
#line 900
  bandno = 0;
  {
#line 900
  while (1) {
    while_continue: /* CIL Label */ ;
#line 900
    if (! (bandno < numbands)) {
#line 900
      goto while_break;
    }
#line 902
    if (tccp->qntsty == 0) {
      {
#line 903
      __cil_tmp17 = cio_read(cio, 1);
#line 903
      expn = (int )(__cil_tmp17 >> 3);
#line 904
      mant = 0;
      }
    } else {
      {
#line 906
      __cil_tmp18 = cio_read(cio, 2);
#line 906
      tmp = (int )__cil_tmp18;
#line 907
      expn = tmp >> 11;
#line 908
      mant = tmp & 2047;
      }
    }
#line 910
    if (bandno < 97) {
#line 911
      tccp->stepsizes[bandno].expn = expn;
#line 912
      tccp->stepsizes[bandno].mant = mant;
    }
#line 900
    bandno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 917
  if (tccp->qntsty == 1) {
#line 918
    bandno = 1;
    {
#line 918
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 918
      if (! (bandno < 97)) {
#line 918
        goto while_break___0;
      }
#line 919
      if (tccp->stepsizes[0].expn - (bandno - 1) / 3 > 0) {
#line 919
        tmp___14 = tccp->stepsizes[0].expn - (bandno - 1) / 3;
      } else {
#line 919
        tmp___14 = 0;
      }
#line 919
      tccp->stepsizes[bandno].expn = tmp___14;
#line 922
      tccp->stepsizes[bandno].mant = tccp->stepsizes[0].mant;
#line 918
      bandno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 928 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_qcd(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 931
  cio = j2k->cio;
#line 933
  cio_write(cio, (unsigned long long )65372, 2);
#line 934
  lenp = cio_tell(cio);
#line 935
  cio_skip(cio, 2);
#line 936
  j2k_write_qcx(j2k, 0);
#line 937
  __cil_tmp6 = cio_tell(cio);
#line 937
  len = __cil_tmp6 - lenp;
#line 938
  cio_seek(cio, lenp);
#line 939
  cio_write(cio, (unsigned long long )len, 2);
#line 940
  cio_seek(cio, lenp + len);
  }
#line 942
  if (j2k->cstr_info) {
    {
#line 943
    j2k_add_mhmarker(j2k->cstr_info, (unsigned short )65372, lenp, len);
    }
  }
  return;
}
}
#line 946 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_qcd(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int pos ;
  opj_cio_t *cio ;
  opj_image_t *image ;
  unsigned int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 949
  cio = j2k->cio;
#line 950
  image = j2k->image;
#line 952
  __cil_tmp7 = cio_read(cio, 2);
#line 952
  len = (int )__cil_tmp7;
#line 953
  pos = cio_tell(cio);
#line 954
  i = 0;
  }
  {
#line 954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 954
    if (! (i < image->numcomps)) {
#line 954
      goto while_break;
    }
    {
#line 955
    cio_seek(cio, pos);
#line 956
    j2k_read_qcx(j2k, i, len - 2);
    }
#line 954
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 960 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_qcc(opj_j2k_t *j2k , int compno ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;

  {
  {
#line 963
  cio = j2k->cio;
#line 965
  cio_write(cio, (unsigned long long )65373, 2);
#line 966
  lenp = cio_tell(cio);
#line 967
  cio_skip(cio, 2);
  }
#line 968
  if ((j2k->image)->numcomps <= 256) {
#line 968
    tmp = 1;
  } else {
#line 968
    tmp = 2;
  }
  {
#line 968
  cio_write(cio, (unsigned long long )compno, tmp);
#line 969
  j2k_write_qcx(j2k, compno);
#line 970
  __cil_tmp8 = cio_tell(cio);
#line 970
  len = __cil_tmp8 - lenp;
#line 971
  cio_seek(cio, lenp);
#line 972
  cio_write(cio, (unsigned long long )len, 2);
#line 973
  cio_seek(cio, lenp + len);
  }
  return;
}
}
#line 976 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_qcc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int numcomp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp6 ;
  int tmp ;
  unsigned int __cil_tmp8 ;
  int tmp___0 ;

  {
  {
#line 978
  numcomp = (j2k->image)->numcomps;
#line 979
  cio = j2k->cio;
#line 981
  __cil_tmp6 = cio_read(cio, 2);
#line 981
  len = (int )__cil_tmp6;
  }
#line 982
  if (numcomp <= 256) {
#line 982
    tmp = 1;
  } else {
#line 982
    tmp = 2;
  }
  {
#line 982
  __cil_tmp8 = cio_read(cio, tmp);
#line 982
  compno = (int )__cil_tmp8;
  }
#line 1010
  if (numcomp <= 256) {
#line 1010
    tmp___0 = 1;
  } else {
#line 1010
    tmp___0 = 2;
  }
  {
#line 1010
  j2k_read_qcx(j2k, compno, (len - 2) - tmp___0);
  }
  return;
}
}
#line 1013 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tccp_t *tccp ;
  opj_cio_t *cio ;
  int tmp ;
  opj_poc_t *poc ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp___1 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1016
  numcomps = (j2k->image)->numcomps;
#line 1018
  cp = j2k->cp;
#line 1019
  tcp = cp->tcps + j2k->curtileno;
#line 1020
  tccp = tcp->tccps + 0;
#line 1021
  cio = j2k->cio;
#line 1023
  numpchgs = 1 + tcp->numpocs;
#line 1024
  cio_write(cio, (unsigned long long )65375, 2);
  }
#line 1025
  if (numcomps <= 256) {
#line 1025
    tmp = 1;
  } else {
#line 1025
    tmp = 2;
  }
  {
#line 1025
  len = 2 + (5 + 2 * tmp) * numpchgs;
#line 1026
  cio_write(cio, (unsigned long long )len, 2);
#line 1027
  i = 0;
  }
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1027
    if (! (i < numpchgs)) {
#line 1027
      goto while_break;
    }
    {
#line 1028
    poc = & tcp->pocs[i];
#line 1029
    cio_write(cio, (unsigned long long )poc->resno0, 1);
    }
#line 1030
    if (numcomps <= 256) {
#line 1030
      tmp___0 = 1;
    } else {
#line 1030
      tmp___0 = 2;
    }
    {
#line 1030
    cio_write(cio, (unsigned long long )poc->compno0, tmp___0);
#line 1031
    cio_write(cio, (unsigned long long )poc->layno1, 2);
#line 1032
    poc->layno1 = int_min(poc->layno1, tcp->numlayers);
#line 1033
    cio_write(cio, (unsigned long long )poc->resno1, 1);
#line 1034
    poc->resno1 = int_min(poc->resno1, tccp->numresolutions);
    }
#line 1035
    if (numcomps <= 256) {
#line 1035
      tmp___1 = 1;
    } else {
#line 1035
      tmp___1 = 2;
    }
    {
#line 1035
    cio_write(cio, (unsigned long long )poc->compno1, tmp___1);
#line 1036
    poc->compno1 = int_min(poc->compno1, numcomps);
#line 1037
    cio_write(cio, (unsigned long long )poc->prg, 1);
    }
#line 1027
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1041 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_poc(opj_j2k_t *j2k ) 
{ 
  int len ;
  int numpchgs ;
  int i ;
  int old_poc ;
  int numcomps ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  int tmp___1 ;
  opj_poc_t *poc ;
  unsigned int __cil_tmp15 ;
  int tmp___2 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int tmp___3 ;
  unsigned int __cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int __cil_tmp24 ;

  {
#line 1044
  numcomps = (j2k->image)->numcomps;
#line 1046
  cp = j2k->cp;
#line 1047
  if (j2k->state == 16) {
#line 1047
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1047
    tmp = j2k->default_tcp;
  }
#line 1047
  tcp = tmp;
#line 1048
  cio = j2k->cio;
#line 1050
  if (tcp->POC) {
#line 1050
    tmp___0 = tcp->numpocs + 1;
  } else {
#line 1050
    tmp___0 = 0;
  }
  {
#line 1050
  old_poc = tmp___0;
#line 1051
  tcp->POC = 1;
#line 1052
  __cil_tmp12 = cio_read(cio, 2);
#line 1052
  len = (int )__cil_tmp12;
  }
#line 1053
  if (numcomps <= 256) {
#line 1053
    tmp___1 = 1;
  } else {
#line 1053
    tmp___1 = 2;
  }
#line 1053
  numpchgs = (len - 2) / (5 + 2 * tmp___1);
#line 1055
  i = old_poc;
  {
#line 1055
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1055
    if (! (i < numpchgs + old_poc)) {
#line 1055
      goto while_break;
    }
    {
#line 1057
    poc = & tcp->pocs[i];
#line 1058
    __cil_tmp15 = cio_read(cio, 1);
#line 1058
    poc->resno0 = (int )__cil_tmp15;
    }
#line 1059
    if (numcomps <= 256) {
#line 1059
      tmp___2 = 1;
    } else {
#line 1059
      tmp___2 = 2;
    }
    {
#line 1059
    __cil_tmp17 = cio_read(cio, tmp___2);
#line 1059
    poc->compno0 = (int )__cil_tmp17;
#line 1060
    __cil_tmp18 = cio_read(cio, 2);
#line 1060
    poc->layno1 = (int )__cil_tmp18;
#line 1061
    __cil_tmp19 = cio_read(cio, 1);
#line 1061
    poc->resno1 = (int )__cil_tmp19;
    }
#line 1062
    if (numcomps <= 256) {
#line 1062
      tmp___3 = 1;
    } else {
#line 1062
      tmp___3 = 2;
    }
    {
#line 1062
    __cil_tmp21 = cio_read(cio, tmp___3);
#line 1062
    __cil_tmp22 = int_min((int )__cil_tmp21, (int )((unsigned int )numcomps));
#line 1062
    poc->compno1 = __cil_tmp22;
#line 1064
    __cil_tmp23 = cio_read(cio, 1);
#line 1064
    poc->prg = (OPJ_PROG_ORDER )__cil_tmp23;
    }
#line 1055
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1067
  tcp->numpocs = (numpchgs + old_poc) - 1;
  return;
}
}
#line 1070 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_crg(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Xcrg_i ;
  int Ycrg_i ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1073
  cio = j2k->cio;
#line 1074
  numcomps = (j2k->image)->numcomps;
#line 1076
  __cil_tmp8 = cio_read(cio, 2);
#line 1076
  len = (int )__cil_tmp8;
#line 1077
  i = 0;
  }
  {
#line 1077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1077
    if (! (i < numcomps)) {
#line 1077
      goto while_break;
    }
    {
#line 1078
    __cil_tmp9 = cio_read(cio, 2);
#line 1078
    Xcrg_i = (int )__cil_tmp9;
#line 1079
    __cil_tmp10 = cio_read(cio, 2);
#line 1079
    Ycrg_i = (int )__cil_tmp10;
    }
#line 1077
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1083 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_tlm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Ztlm ;
  int Stlm ;
  int ST ;
  int SP ;
  int tile_tlm ;
  int i ;
  long Ttlm_i ;
  long Ptlm_i ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int tmp ;
  unsigned int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 1087
  cio = j2k->cio;
#line 1089
  __cil_tmp12 = cio_read(cio, 2);
#line 1089
  len = (int )__cil_tmp12;
#line 1090
  __cil_tmp13 = cio_read(cio, 1);
#line 1090
  Ztlm = (int )__cil_tmp13;
#line 1091
  __cil_tmp14 = cio_read(cio, 1);
#line 1091
  Stlm = (int )__cil_tmp14;
#line 1092
  ST = ((Stlm >> 4) & 1) + ((Stlm >> 4) & 2);
#line 1093
  SP = (Stlm >> 6) & 1;
#line 1094
  tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
#line 1095
  i = 0;
  }
  {
#line 1095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1095
    if (! (i < tile_tlm)) {
#line 1095
      goto while_break;
    }
    {
#line 1096
    __cil_tmp15 = cio_read(cio, ST);
#line 1096
    Ttlm_i = (long )__cil_tmp15;
    }
#line 1097
    if (SP) {
#line 1097
      tmp = 4;
    } else {
#line 1097
      tmp = 2;
    }
    {
#line 1097
    __cil_tmp17 = cio_read(cio, tmp);
#line 1097
    Ptlm_i = (long )__cil_tmp17;
    }
#line 1095
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1101 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_plm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplm ;
  int Nplm ;
  int add ;
  int packet_len ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 1102
  packet_len = 0;
#line 1104
  cio = j2k->cio;
#line 1106
  __cil_tmp9 = cio_read(cio, 2);
#line 1106
  len = (int )__cil_tmp9;
#line 1107
  __cil_tmp10 = cio_read(cio, 1);
#line 1107
  Zplm = (int )__cil_tmp10;
#line 1108
  len -= 3;
  }
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1109
    if (! (len > 0)) {
#line 1109
      goto while_break;
    }
    {
#line 1110
    __cil_tmp11 = cio_read(cio, 4);
#line 1110
    Nplm = (int )__cil_tmp11;
#line 1111
    len -= 4;
#line 1112
    i = Nplm;
    }
    {
#line 1112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1112
      if (! (i > 0)) {
#line 1112
        goto while_break___0;
      }
      {
#line 1113
      __cil_tmp12 = cio_read(cio, 1);
#line 1113
      add = (int )__cil_tmp12;
#line 1114
      __cil_tmp13 = len;
#line 1114
      len --;
#line 1115
      packet_len = (packet_len << 7) + add;
      }
#line 1116
      if ((add & 128) == 0) {
#line 1118
        packet_len = 0;
      }
#line 1120
      if (len <= 0) {
#line 1121
        goto while_break___0;
      }
#line 1112
      __cil_tmp14 = i;
#line 1112
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1126 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_plt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int i ;
  int Zplt ;
  int packet_len ;
  int add ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1127
  packet_len = 0;
#line 1129
  cio = j2k->cio;
#line 1131
  __cil_tmp8 = cio_read(cio, 2);
#line 1131
  len = (int )__cil_tmp8;
#line 1132
  __cil_tmp9 = cio_read(cio, 1);
#line 1132
  Zplt = (int )__cil_tmp9;
#line 1133
  i = len - 3;
  }
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! (i > 0)) {
#line 1133
      goto while_break;
    }
    {
#line 1134
    __cil_tmp10 = cio_read(cio, 1);
#line 1134
    add = (int )__cil_tmp10;
#line 1135
    packet_len = (packet_len << 7) + add;
    }
#line 1136
    if ((add & 128) == 0) {
#line 1138
      packet_len = 0;
    }
#line 1133
    __cil_tmp11 = i;
#line 1133
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1143 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_ppm(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppm ;
  int i ;
  int j ;
  int N_ppm ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 1147
  cp = j2k->cp;
#line 1148
  cio = j2k->cio;
#line 1150
  __cil_tmp9 = cio_read(cio, 2);
#line 1150
  len = (int )__cil_tmp9;
#line 1151
  cp->ppm = 1;
#line 1153
  __cil_tmp10 = cio_read(cio, 1);
#line 1153
  Z_ppm = (int )__cil_tmp10;
#line 1154
  len -= 3;
  }
  {
#line 1155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1155
    if (! (len > 0)) {
#line 1155
      goto while_break;
    }
#line 1156
    if (cp->ppm_previous == 0) {
      {
#line 1157
      __cil_tmp11 = cio_read(cio, 4);
#line 1157
      N_ppm = (int )__cil_tmp11;
#line 1158
      len -= 4;
      }
    } else {
#line 1160
      N_ppm = cp->ppm_previous;
    }
#line 1162
    j = cp->ppm_store;
#line 1163
    if (Z_ppm == 0) {
      {
#line 1164
      __cil_tmp12 = malloc((unsigned long )N_ppm * sizeof(unsigned char ));
#line 1164
      cp->ppm_data = (unsigned char *)__cil_tmp12;
#line 1165
      cp->ppm_data_first = cp->ppm_data;
#line 1166
      cp->ppm_len = N_ppm;
      }
    } else {
      {
#line 1168
      __cil_tmp13 = realloc(cp->ppm_data, (unsigned long )(N_ppm + cp->ppm_store) * sizeof(unsigned char ));
#line 1168
      cp->ppm_data = (unsigned char *)__cil_tmp13;
#line 1186
      cp->ppm_data_first = cp->ppm_data;
#line 1187
      cp->ppm_len = N_ppm + cp->ppm_store;
      }
    }
#line 1189
    i = N_ppm;
    {
#line 1189
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1189
      if (! (i > 0)) {
#line 1189
        goto while_break___0;
      }
      {
#line 1190
      __cil_tmp14 = cio_read(cio, 1);
#line 1190
      *(cp->ppm_data + j) = (unsigned char )__cil_tmp14;
#line 1191
      j ++;
#line 1192
      __cil_tmp16 = len;
#line 1192
      len --;
      }
#line 1193
      if (len == 0) {
#line 1194
        goto while_break___0;
      }
#line 1189
      __cil_tmp17 = i;
#line 1189
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1196
    cp->ppm_previous = i - 1;
#line 1197
    cp->ppm_store = j;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1201 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_ppt(opj_j2k_t *j2k ) 
{ 
  int len ;
  int Z_ppt ;
  int i ;
  int j ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 1202
  j = 0;
#line 1204
  cp = j2k->cp;
#line 1205
  tcp = cp->tcps + j2k->curtileno;
#line 1206
  cio = j2k->cio;
#line 1208
  __cil_tmp9 = cio_read(cio, 2);
#line 1208
  len = (int )__cil_tmp9;
#line 1209
  __cil_tmp10 = cio_read(cio, 1);
#line 1209
  Z_ppt = (int )__cil_tmp10;
#line 1210
  tcp->ppt = 1;
  }
#line 1211
  if (Z_ppt == 0) {
    {
#line 1212
    __cil_tmp11 = malloc((unsigned long )(len - 3) * sizeof(unsigned char ));
#line 1212
    tcp->ppt_data = (unsigned char *)__cil_tmp11;
#line 1213
    tcp->ppt_data_first = tcp->ppt_data;
#line 1214
    tcp->ppt_store = 0;
#line 1215
    tcp->ppt_len = len - 3;
    }
  } else {
    {
#line 1217
    __cil_tmp12 = realloc(tcp->ppt_data, (unsigned long )((len - 3) + tcp->ppt_store) * sizeof(unsigned char ));
#line 1217
    tcp->ppt_data = (unsigned char *)__cil_tmp12;
#line 1218
    tcp->ppt_data_first = tcp->ppt_data;
#line 1219
    tcp->ppt_len = (len - 3) + tcp->ppt_store;
    }
  }
#line 1221
  j = tcp->ppt_store;
#line 1222
  i = len - 3;
  {
#line 1222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1222
    if (! (i > 0)) {
#line 1222
      goto while_break;
    }
    {
#line 1223
    __cil_tmp13 = cio_read(cio, 1);
#line 1223
    *(tcp->ppt_data + j) = (unsigned char )__cil_tmp13;
#line 1224
    j ++;
    }
#line 1222
    __cil_tmp15 = i;
#line 1222
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1226
  tcp->ppt_store = j;
  return;
}
}
#line 1229 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_tlm(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  opj_cio_t *cio ;
  int __cil_tmp4 ;

  {
  {
#line 1231
  cio = j2k->cio;
#line 1232
  j2k->tlm_start = cio_tell(cio);
#line 1233
  cio_write(cio, (unsigned long long )65365, 2);
#line 1234
  lenp = 4 + 5 * j2k->totnum_tp;
#line 1235
  cio_write(cio, (unsigned long long )lenp, 2);
#line 1236
  cio_write(cio, (unsigned long long )0, 1);
#line 1237
  cio_write(cio, (unsigned long long )80, 1);
#line 1238
  cio_skip(cio, 5 * j2k->totnum_tp);
  }
  return;
}
}
#line 1241 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_sot(opj_j2k_t *j2k ) 
{ 
  int lenp ;
  int len ;
  opj_cio_t *cio ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1244
  cio = j2k->cio;
#line 1246
  j2k->sot_start = cio_tell(cio);
#line 1247
  cio_write(cio, (unsigned long long )65424, 2);
#line 1248
  lenp = cio_tell(cio);
#line 1249
  cio_skip(cio, 2);
#line 1250
  cio_write(cio, (unsigned long long )j2k->curtileno, 2);
#line 1251
  cio_skip(cio, 4);
#line 1252
  cio_write(cio, (unsigned long long )j2k->cur_tp_num, 1);
#line 1253
  cio_write(cio, (unsigned long long )*(j2k->cur_totnum_tp + j2k->curtileno), 1);
#line 1254
  __cil_tmp7 = cio_tell(cio);
#line 1254
  len = __cil_tmp7 - lenp;
#line 1255
  cio_seek(cio, lenp);
#line 1256
  cio_write(cio, (unsigned long long )len, 2);
#line 1257
  cio_seek(cio, lenp + len);
  }
#line 1266
  if (j2k->cstr_info) {
#line 1266
    if (j2k->cur_tp_num == 0) {
      {
#line 1267
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short )65424, lenp,
                       len);
      }
    }
  }
  return;
}
}
#line 1271 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_sot(opj_j2k_t *j2k ) 
{ 
  int len ;
  int tileno ;
  int totlen ;
  int partno ;
  int numparts ;
  int i ;
  opj_tcp_t *tcp ;
  char status ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned char *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  opj_tccp_t *tmp___0 ;
  int __cil_tmp31 ;

  {
  {
#line 1273
  tcp = (opj_tcp_t *)((void *)0);
#line 1274
  status = (char )0;
#line 1276
  cp = j2k->cp;
#line 1277
  cio = j2k->cio;
#line 1279
  __cil_tmp12 = cio_read(cio, 2);
#line 1279
  len = (int )__cil_tmp12;
#line 1280
  __cil_tmp13 = cio_read(cio, 2);
#line 1280
  tileno = (int )__cil_tmp13;
  }
#line 1310
  if (tileno < 0) {
    {
    {
#line 1311
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
    }
#line 1314
    return;
  } else
#line 1310
  if (tileno >= cp->tw * cp->th) {
    {
    {
#line 1311
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile number (%d out of a maximum of %d)\n",
                  tileno, cp->tw * cp->th);
    }
    }
#line 1314
    return;
  }
#line 1318
  if (cp->tileno_size == 0) {
#line 1319
    *(cp->tileno + cp->tileno_size) = tileno;
#line 1320
    (cp->tileno_size) ++;
  } else {
#line 1322
    i = 0;
    {
#line 1323
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1323
      if (! (i < cp->tileno_size && (int )status == 0)) {
#line 1323
        goto while_break;
      }
#line 1324
      if (*(cp->tileno + i) == tileno) {
#line 1324
        tmp = 1;
      } else {
#line 1324
        tmp = 0;
      }
#line 1324
      status = (char )tmp;
#line 1325
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1327
    if ((int )status == 0) {
#line 1328
      *(cp->tileno + cp->tileno_size) = tileno;
#line 1329
      (cp->tileno_size) ++;
    }
  }
  {
#line 1333
  __cil_tmp18 = cio_read(cio, 4);
#line 1333
  totlen = (int )__cil_tmp18;
#line 1359
  __cil_tmp19 = cio_numbytesleft(cio);
  }
#line 1359
  if (totlen < 0) {
    {
    {
#line 1360
    __cil_tmp20 = cio_numbytesleft(cio);
    }
    {
#line 1360
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
    }
#line 1363
    return;
  } else
#line 1359
  if (totlen > __cil_tmp19 + 8) {
    {
    {
#line 1360
    __cil_tmp20 = cio_numbytesleft(cio);
    }
    {
#line 1360
    opj_event_msg(j2k->cinfo, 1, "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
                  totlen, __cil_tmp20 + 8);
    }
    }
#line 1363
    return;
  }
#line 1367
  if (! totlen) {
    {
#line 1368
    __cil_tmp21 = cio_numbytesleft(cio);
#line 1368
    totlen = __cil_tmp21 + 8;
    }
  }
  {
#line 1370
  __cil_tmp22 = cio_read(cio, 1);
#line 1370
  partno = (int )__cil_tmp22;
#line 1371
  __cil_tmp23 = cio_read(cio, 1);
#line 1371
  numparts = (int )__cil_tmp23;
  }
#line 1373
  if (partno >= numparts) {
    {
#line 1374
    opj_event_msg(j2k->cinfo, 2, "SOT marker inconsistency in tile %d: tile-part index greater (%d) than number of tile-parts (%d)\n",
                  tileno, partno, numparts);
#line 1375
    numparts = partno + 1;
    }
  }
  {
#line 1378
  j2k->curtileno = tileno;
#line 1379
  j2k->cur_tp_num = partno;
#line 1380
  __cil_tmp24 = cio_getbp(cio);
#line 1380
  j2k->eot = (__cil_tmp24 - 12) + totlen;
#line 1381
  j2k->state = 16;
#line 1382
  tcp = cp->tcps + j2k->curtileno;
  }
#line 1385
  if (j2k->cstr_info) {
#line 1386
    if (tcp->first) {
#line 1387
      if (tileno == 0) {
        {
#line 1388
        __cil_tmp25 = cio_tell(cio);
#line 1388
        (j2k->cstr_info)->main_head_end = __cil_tmp25 - 13;
        }
      }
      {
#line 1389
      ((j2k->cstr_info)->tile + tileno)->tileno = tileno;
#line 1390
      __cil_tmp26 = cio_tell(cio);
#line 1390
      ((j2k->cstr_info)->tile + tileno)->start_pos = __cil_tmp26 - 12;
#line 1391
      ((j2k->cstr_info)->tile + tileno)->end_pos = (((j2k->cstr_info)->tile + tileno)->start_pos + totlen) - 1;
      }
    } else {
#line 1393
      ((j2k->cstr_info)->tile + tileno)->end_pos += totlen;
    }
#line 1395
    ((j2k->cstr_info)->tile + tileno)->num_tps = numparts;
#line 1396
    if (numparts) {
      {
#line 1397
      __cil_tmp27 = realloc(((j2k->cstr_info)->tile + tileno)->tp, (unsigned long )numparts * sizeof(opj_tp_info_t ));
#line 1397
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp27;
      }
    } else {
      {
#line 1399
      __cil_tmp28 = realloc(((j2k->cstr_info)->tile + tileno)->tp, 10UL * sizeof(opj_tp_info_t ));
#line 1399
      ((j2k->cstr_info)->tile + tileno)->tp = (opj_tp_info_t *)__cil_tmp28;
      }
    }
    {
#line 1400
    __cil_tmp29 = cio_tell(cio);
#line 1400
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos = __cil_tmp29 - 12;
#line 1401
    (((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_end_pos = ((((j2k->cstr_info)->tile + tileno)->tp + partno)->tp_start_pos + totlen) - 1;
    }
  }
#line 1405
  if (tcp->first == 1) {
    {
#line 1407
    tmp___0 = tcp->tccps;
#line 1408
    memcpy(tcp, j2k->default_tcp, sizeof(opj_tcp_t ));
#line 1409
    tcp->ppt = 0;
#line 1410
    tcp->ppt_data = (unsigned char *)((void *)0);
#line 1411
    tcp->ppt_data_first = (unsigned char *)((void *)0);
#line 1412
    tcp->tccps = tmp___0;
#line 1414
    i = 0;
    }
    {
#line 1414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1414
      if (! (i < (j2k->image)->numcomps)) {
#line 1414
        goto while_break___0;
      }
#line 1415
      *(tcp->tccps + i) = *((j2k->default_tcp)->tccps + i);
#line 1414
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1417
    (cp->tcps + j2k->curtileno)->first = 0;
  }
  return;
}
}
#line 1421 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_sod(opj_j2k_t *j2k , void *tile_coder ) 
{ 
  int l ;
  int layno ;
  int totlen ;
  opj_tcp_t *tcp ;
  opj_codestream_info_t *cstr_info ;
  opj_tcd_t *tcd ;
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1424
  tcp = (opj_tcp_t *)((void *)0);
#line 1425
  cstr_info = (opj_codestream_info_t *)((void *)0);
#line 1427
  tcd = (opj_tcd_t *)tile_coder;
#line 1428
  cp = j2k->cp;
#line 1429
  cio = j2k->cio;
#line 1431
  tcd->tp_num = j2k->tp_num;
#line 1432
  tcd->cur_tp_num = j2k->cur_tp_num;
#line 1434
  cio_write(cio, (unsigned long long )65427, 2);
  }
#line 1436
  if (j2k->cstr_info) {
#line 1436
    if (j2k->cur_tp_num == 0) {
      {
#line 1437
      __cil_tmp11 = cio_tell(cio);
#line 1437
      j2k_add_tlmarker(j2k->curtileno, j2k->cstr_info, (unsigned short )65427, __cil_tmp11,
                       0);
      }
    }
  }
#line 1440
  if (j2k->curtileno == 0) {
    {
#line 1441
    __cil_tmp12 = cio_tell(cio);
#line 1441
    j2k->sod_start = __cil_tmp12 + j2k->pos_correction;
    }
  }
#line 1445
  cstr_info = j2k->cstr_info;
#line 1446
  if (cstr_info) {
#line 1447
    if (! j2k->cur_tp_num) {
      {
#line 1448
      __cil_tmp13 = cio_tell(cio);
#line 1448
      (cstr_info->tile + j2k->curtileno)->end_header = (__cil_tmp13 + j2k->pos_correction) - 1;
#line 1449
      ((j2k->cstr_info)->tile + j2k->curtileno)->tileno = j2k->curtileno;
      }
    } else {
      {
#line 1452
      __cil_tmp14 = cio_tell(cio);
      }
#line 1452
      if (((cstr_info->tile + j2k->curtileno)->packet + (cstr_info->packno - 1))->end_pos < __cil_tmp14) {
        {
#line 1453
        ((cstr_info->tile + j2k->curtileno)->packet + cstr_info->packno)->start_pos = cio_tell(cio);
        }
      }
    }
  }
#line 1464
  tcp = cp->tcps + j2k->curtileno;
#line 1465
  layno = 0;
  {
#line 1465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1465
    if (! (layno < tcp->numlayers)) {
#line 1465
      goto while_break;
    }
#line 1466
    if (tcp->rates[layno] > (float )(j2k->sod_start / (cp->th * cp->tw))) {
#line 1467
      tcp->rates[layno] -= (float )(j2k->sod_start / (cp->th * cp->tw));
    } else
#line 1468
    if (tcp->rates[layno]) {
#line 1469
      tcp->rates[layno] = (float )1;
    }
#line 1465
    layno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1472
  if (j2k->cur_tp_num == 0) {
#line 1473
    ((tcd->tcd_image)->tiles)->packno = 0;
#line 1474
    if (cstr_info) {
#line 1475
      cstr_info->packno = 0;
    }
  }
  {
#line 1478
  __cil_tmp17 = cio_getbp(cio);
  }
  {
#line 1478
  __cil_tmp18 = cio_numbytesleft(cio);
#line 1478
  __cil_tmp19 = tcd_encode_tile(tcd, j2k->curtileno, __cil_tmp17, __cil_tmp18 - 2,
                                cstr_info);
#line 1478
  l = __cil_tmp19;
#line 1481
  __cil_tmp20 = cio_tell(cio);
#line 1481
  totlen = (__cil_tmp20 + l) - j2k->sot_start;
#line 1482
  cio_seek(cio, j2k->sot_start + 6);
#line 1483
  cio_write(cio, (unsigned long long )totlen, 4);
#line 1484
  cio_seek(cio, j2k->sot_start + totlen);
  }
#line 1486
  if (cp->cinema) {
    {
#line 1487
    cio_seek(cio, (j2k->tlm_start + 6) + 5 * j2k->cur_tp_num);
#line 1488
    cio_write(cio, (unsigned long long )j2k->curtileno, 1);
#line 1489
    cio_write(cio, (unsigned long long )totlen, 4);
    }
  }
  {
#line 1491
  cio_seek(cio, j2k->sot_start + totlen);
  }
  return;
}
}
#line 1494 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_sod(opj_j2k_t *j2k ) 
{ 
  int len ;
  int truncate ;
  int i ;
  unsigned char *data ;
  unsigned char *data_ptr ;
  opj_cio_t *cio ;
  int curtileno ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *s ;
  unsigned char *e ;
  unsigned char *__cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 1495
  truncate = 0;
#line 1496
  data = (unsigned char *)((void *)0);
#line 1496
  data_ptr = (unsigned char *)((void *)0);
#line 1498
  cio = j2k->cio;
#line 1499
  curtileno = j2k->curtileno;
#line 1502
  if (j2k->cstr_info) {
    {
#line 1503
    __cil_tmp9 = cio_tell(cio);
#line 1503
    (((j2k->cstr_info)->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp9 + j2k->pos_correction) - 1;
    }
#line 1505
    if (j2k->cur_tp_num == 0) {
      {
#line 1506
      __cil_tmp10 = cio_tell(cio);
#line 1506
      ((j2k->cstr_info)->tile + j2k->curtileno)->end_header = (__cil_tmp10 + j2k->pos_correction) - 1;
      }
    }
#line 1507
    (j2k->cstr_info)->packno = 0;
  }
  {
#line 1510
  __cil_tmp11 = cio_getbp(cio);
  }
  {
#line 1510
  __cil_tmp12 = cio_numbytesleft(cio);
#line 1510
  __cil_tmp13 = int_min((int )(j2k->eot - __cil_tmp11), __cil_tmp12 + 1);
#line 1510
  len = __cil_tmp13;
#line 1512
  __cil_tmp14 = cio_numbytesleft(cio);
  }
#line 1512
  if (len == __cil_tmp14 + 1) {
#line 1513
    truncate = 1;
  }
  {
#line 1519
  s = cio_getbp(cio);
#line 1520
  e = s + len;
  }
#line 1522
  if (len > 8) {
#line 1522
    s = e - 8;
  }
#line 1524
  if ((int )*(e + -2) == 0) {
#line 1524
    if ((int )*(e + -1) == 0) {
      {
#line 1526
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1526
        if (! (e > s)) {
#line 1526
          goto while_break;
        }
#line 1528
        if ((int )*(e + -2) == 255) {
#line 1528
          if ((int )*(e + -1) == 217) {
#line 1528
            goto while_break;
          }
        }
#line 1529
        len --;
#line 1529
        e --;
#line 1529
        truncate = 1;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1534
  data = *(j2k->tile_data + curtileno);
#line 1535
  __cil_tmp18 = realloc(data, (unsigned long )(*(j2k->tile_len + curtileno) + len) * sizeof(unsigned char ));
#line 1535
  data = (unsigned char *)__cil_tmp18;
#line 1537
  data_ptr = data + *(j2k->tile_len + curtileno);
#line 1538
  i = 0;
  }
  {
#line 1538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1538
    if (! (i < len)) {
#line 1538
      goto while_break___0;
    }
    {
#line 1539
    __cil_tmp19 = cio_read(cio, 1);
#line 1539
    *(data_ptr + i) = (unsigned char )__cil_tmp19;
    }
#line 1538
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1542
  *(j2k->tile_len + curtileno) += len;
#line 1543
  *(j2k->tile_data + curtileno) = data;
#line 1545
  if (! truncate) {
#line 1546
    j2k->state = 8;
  } else {
#line 1548
    j2k->state = 64;
  }
#line 1550
  (j2k->cur_tp_num) ++;
  return;
}
}
#line 1553 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_rgn(opj_j2k_t *j2k , int compno , int tileno ) 
{ 
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_cio_t *cio ;
  int numcomps ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1554
  cp = j2k->cp;
#line 1555
  tcp = cp->tcps + tileno;
#line 1556
  cio = j2k->cio;
#line 1557
  numcomps = (j2k->image)->numcomps;
#line 1559
  cio_write(cio, (unsigned long long )65374, 2);
  }
#line 1560
  if (numcomps <= 256) {
#line 1560
    tmp = 5;
  } else {
#line 1560
    tmp = 6;
  }
  {
#line 1560
  cio_write(cio, (unsigned long long )tmp, 2);
  }
#line 1561
  if (numcomps <= 256) {
#line 1561
    tmp___0 = 1;
  } else {
#line 1561
    tmp___0 = 2;
  }
  {
#line 1561
  cio_write(cio, (unsigned long long )compno, tmp___0);
#line 1562
  cio_write(cio, (unsigned long long )0, 1);
#line 1563
  cio_write(cio, (unsigned long long )(tcp->tccps + compno)->roishift, 1);
  }
  return;
}
}
#line 1566 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_rgn(opj_j2k_t *j2k ) 
{ 
  int len ;
  int compno ;
  int roisty ;
  opj_cp_t *cp ;
  opj_tcp_t *tcp ;
  opj_tcp_t *tmp ;
  opj_cio_t *cio ;
  int numcomps ;
  unsigned int __cil_tmp10 ;
  int tmp___0 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 1569
  cp = j2k->cp;
#line 1570
  if (j2k->state == 16) {
#line 1570
    tmp = cp->tcps + j2k->curtileno;
  } else {
#line 1570
    tmp = j2k->default_tcp;
  }
  {
#line 1570
  tcp = tmp;
#line 1571
  cio = j2k->cio;
#line 1572
  numcomps = (j2k->image)->numcomps;
#line 1574
  __cil_tmp10 = cio_read(cio, 2);
#line 1574
  len = (int )__cil_tmp10;
  }
#line 1575
  if (numcomps <= 256) {
#line 1575
    tmp___0 = 1;
  } else {
#line 1575
    tmp___0 = 2;
  }
  {
#line 1575
  __cil_tmp12 = cio_read(cio, tmp___0);
#line 1575
  compno = (int )__cil_tmp12;
#line 1576
  __cil_tmp13 = cio_read(cio, 1);
#line 1576
  roisty = (int )__cil_tmp13;
#line 1593
  __cil_tmp14 = cio_read(cio, 1);
#line 1593
  (tcp->tccps + compno)->roishift = (int )__cil_tmp14;
  }
  return;
}
}
#line 1596 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_write_eoc(opj_j2k_t *j2k ) 
{ 
  opj_cio_t *cio ;

  {
  {
#line 1597
  cio = j2k->cio;
#line 1599
  cio_write(cio, (unsigned long long )65497, 2);
  }
  return;
}
}
#line 1609 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_eoc(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  opj_bool success ;
  opj_tcd_t *tcd ;
  opj_tcd_t *__cil_tmp6 ;
  opj_bool __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 1611
  success = 0;
#line 1614
  if ((unsigned int )(j2k->cp)->limit_decoding != 2U) {
    {
#line 1615
    __cil_tmp6 = tcd_create(j2k->cinfo);
#line 1615
    tcd = __cil_tmp6;
#line 1616
    tcd_malloc_decode(tcd, j2k->image, j2k->cp);
#line 1617
    i = 0;
    }
    {
#line 1617
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1617
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1617
        goto while_break;
      }
      {
#line 1618
      tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
      }
#line 1619
      if (*((j2k->cp)->tileno + i) != -1) {
        {
#line 1621
        tileno = *((j2k->cp)->tileno + i);
#line 1622
        success = tcd_decode_tile(tcd, *(j2k->tile_data + tileno), *(j2k->tile_len + tileno),
                                  tileno, j2k->cstr_info);
#line 1623
        free(*(j2k->tile_data + tileno));
#line 1624
        *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
#line 1625
        tcd_free_decode_tile(tcd, i);
        }
      } else {
#line 1628
        success = 0;
      }
#line 1629
      if (success == 0) {
#line 1630
        j2k->state |= 128;
#line 1631
        goto while_break;
      }
#line 1617
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1634
    tcd_free_decode(tcd);
#line 1635
    tcd_destroy(tcd);
    }
  } else {
#line 1639
    i = 0;
    {
#line 1639
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1639
      if (! (i < (j2k->cp)->tileno_size)) {
#line 1639
        goto while_break___0;
      }
      {
#line 1640
      tileno = *((j2k->cp)->tileno + i);
#line 1641
      free(*(j2k->tile_data + tileno));
#line 1642
      *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
      }
#line 1639
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1645
  if (j2k->state & 128) {
#line 1646
    j2k->state = 160;
  } else {
#line 1648
    j2k->state = 32;
  }
  return;
}
}
#line 1660 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
opj_dec_mstabent_t j2k_dec_mstab[20]  = 
#line 1660
  {      {65359, 1, & j2k_read_soc}, 
        {65424, 12, & j2k_read_sot}, 
        {65427, 16, & j2k_read_sod}, 
        {65497, 8, & j2k_read_eoc}, 
        {65361, 2, & j2k_read_siz}, 
        {65362, 20, & j2k_read_cod}, 
        {65363, 20, & j2k_read_coc}, 
        {65374, 20, & j2k_read_rgn}, 
        {65372, 20, & j2k_read_qcd}, 
        {65373, 20, & j2k_read_qcc}, 
        {65375, 20, & j2k_read_poc}, 
        {65365, 4, & j2k_read_tlm}, 
        {65367, 4, & j2k_read_plm}, 
        {65368, 16, & j2k_read_plt}, 
        {65376, 4, & j2k_read_ppm}, 
        {65377, 16, & j2k_read_ppt}, 
        {65425, 0, (void (*)(opj_j2k_t * ))0}, 
        {65379, 4, & j2k_read_crg}, 
        {65380, 20, & j2k_read_com}, 
        {0, 20, & j2k_read_unk}};
#line 1695 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_read_unk(opj_j2k_t *j2k ) 
{ 


  {
  {
#line 1696
  opj_event_msg(j2k->cinfo, 2, "Unknown marker\n");
  }
  return;
}
}
#line 1761 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static opj_dec_mstabent_t *j2k_dec_mstab_lookup(int id ) 
{ 
  opj_dec_mstabent_t *e ;
  opj_dec_mstabent_t *__cil_tmp3 ;

  {
#line 1763
  e = (opj_dec_mstabent_t *)j2k_dec_mstab;
  {
#line 1763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1763
    if (! (e->id != 0)) {
#line 1763
      goto while_break;
    }
#line 1764
    if (e->id == id) {
#line 1765
      goto while_break;
    }
#line 1763
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1768
  return (e);
}
}
#line 1775 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_decompress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 1776
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 1776
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 1777
  if (! j2k) {
#line 1778
    return ((opj_j2k_t *)((void *)0));
  }
  {
#line 1780
  __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_tcp_t ));
#line 1780
  j2k->default_tcp = (opj_tcp_t *)__cil_tmp4;
  }
#line 1781
  if (! j2k->default_tcp) {
    {
#line 1782
    free(j2k);
    }
#line 1783
    return ((opj_j2k_t *)((void *)0));
  }
#line 1786
  j2k->cinfo = cinfo;
#line 1787
  j2k->tile_data = (unsigned char **)((void *)0);
#line 1789
  return (j2k);
}
}
#line 1792 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
void j2k_destroy_decompress(opj_j2k_t *j2k ) 
{ 
  int i ;
  int tileno ;
  int __cil_tmp4 ;
  opj_tcp_t *default_tcp ;
  opj_cp_t *cp ;
  int __cil_tmp7 ;

  {
#line 1793
  i = 0;
#line 1795
  if (j2k->tile_len != (void *)0) {
    {
#line 1796
    free(j2k->tile_len);
    }
  }
#line 1798
  if (j2k->tile_data != (void *)0) {
#line 1799
    if (j2k->cp != (void *)0) {
#line 1800
      i = 0;
      {
#line 1800
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1800
        if (! (i < (j2k->cp)->tileno_size)) {
#line 1800
          goto while_break;
        }
        {
#line 1801
        tileno = *((j2k->cp)->tileno + i);
#line 1802
        free(*(j2k->tile_data + tileno));
#line 1803
        *(j2k->tile_data + tileno) = (unsigned char *)((void *)0);
        }
#line 1800
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1807
    free(j2k->tile_data);
    }
  }
#line 1809
  if (j2k->default_tcp != (void *)0) {
#line 1810
    default_tcp = j2k->default_tcp;
#line 1811
    if (default_tcp->ppt_data_first != (void *)0) {
      {
#line 1812
      free(default_tcp->ppt_data_first);
      }
    }
#line 1814
    if ((j2k->default_tcp)->tccps != (void *)0) {
      {
#line 1815
      free((j2k->default_tcp)->tccps);
      }
    }
    {
#line 1817
    free(j2k->default_tcp);
    }
  }
#line 1819
  if (j2k->cp != (void *)0) {
#line 1820
    cp = j2k->cp;
#line 1821
    if (cp->tcps != (void *)0) {
#line 1822
      i = 0;
      {
#line 1822
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1822
        if (! (i < cp->tw * cp->th)) {
#line 1822
          goto while_break___0;
        }
#line 1823
        if ((cp->tcps + i)->ppt_data_first != (void *)0) {
          {
#line 1824
          free((cp->tcps + i)->ppt_data_first);
          }
        }
#line 1826
        if ((cp->tcps + i)->tccps != (void *)0) {
          {
#line 1827
          free((cp->tcps + i)->tccps);
          }
        }
#line 1822
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1830
      free(cp->tcps);
      }
    }
#line 1832
    if (cp->ppm_data_first != (void *)0) {
      {
#line 1833
      free(cp->ppm_data_first);
      }
    }
#line 1835
    if (cp->tileno != (void *)0) {
      {
#line 1836
      free(cp->tileno);
      }
    }
#line 1838
    if (cp->comment != (void *)0) {
      {
#line 1839
      free(cp->comment);
      }
    }
    {
#line 1842
    free(cp);
    }
  }
  {
#line 1844
  free(j2k);
  }
  return;
}
}
#line 1847 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
void j2k_setup_decoder(opj_j2k_t *j2k , opj_dparameters_t *parameters ) 
{ 
  opj_cp_t *cp ;
  void *__cil_tmp4 ;

  {
#line 1848
  if (j2k) {
#line 1848
    if (parameters) {
      {
#line 1850
      __cil_tmp4 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 1850
      cp = (opj_cp_t *)__cil_tmp4;
#line 1851
      cp->reduce = parameters->cp_reduce;
#line 1852
      cp->layer = parameters->cp_layer;
#line 1853
      cp->limit_decoding = parameters->cp_limit_decoding;
#line 1863
      j2k->cp = cp;
      }
    }
  }
  return;
}
}
#line 1867 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
opj_image_t *j2k_decode(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp6 ;
  opj_dec_mstabent_t *e ;
  int id ;
  unsigned int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  opj_dec_mstabent_t *__cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 1868
  image = (opj_image_t *)((void *)0);
#line 1870
  cinfo = j2k->cinfo;
#line 1872
  j2k->cio = cio;
#line 1873
  j2k->cstr_info = cstr_info;
#line 1874
  if (cstr_info) {
    {
#line 1875
    memset(cstr_info, 0, sizeof(opj_codestream_info_t ));
    }
  }
  {
#line 1878
  image = opj_image_create0();
#line 1879
  j2k->image = image;
#line 1881
  j2k->state = 1;
  }
  {
#line 1883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1883
    if (! 1) {
#line 1883
      goto while_break;
    }
    {
#line 1885
    __cil_tmp9 = cio_read(cio, 2);
#line 1885
    id = (int )__cil_tmp9;
    }
#line 1925
    if (id >> 8 != 255) {
      {
#line 1926
      __cil_tmp10 = cio_numbytesleft(cio);
      }
#line 1926
      if (__cil_tmp10 != 0) {
        {
#line 1928
        __cil_tmp11 = cio_tell(cio);
#line 1928
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp11 - 2,
                      id);
#line 1929
        opj_image_destroy(image);
        }
#line 1930
        return ((opj_image_t *)0);
      }
      {
#line 1932
      __cil_tmp12 = cio_tell(cio);
#line 1932
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp12 - 2,
                    id);
#line 1933
      j2k->state = 64;
      }
#line 1934
      goto while_break;
    }
    {
#line 1936
    e = j2k_dec_mstab_lookup(id);
    }
#line 1938
    if (! (j2k->state & e->states)) {
      {
#line 1939
      opj_image_destroy(image);
#line 1940
      __cil_tmp14 = cio_tell(cio);
#line 1940
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\n", __cil_tmp14 - 2, id);
      }
#line 1941
      return ((opj_image_t *)0);
    }
#line 1944
    if (e->id == 65424) {
#line 1944
      if ((unsigned int )(j2k->cp)->limit_decoding == 1U) {
        {
#line 1945
        opj_event_msg(cinfo, 4, "Main Header decoded.\n");
        }
#line 1946
        return (image);
      }
    }
#line 1949
    if (e->handler) {
      {
#line 1950
      (*(e->handler))(j2k);
      }
    }
#line 1952
    if (j2k->state & 128) {
      {
#line 1954
      opj_image_destroy(image);
      }
#line 1955
      return ((opj_image_t *)((void *)0));
    }
#line 1958
    if (j2k->state == 32) {
#line 1959
      goto while_break;
    }
#line 1961
    if (j2k->state == 64) {
#line 1962
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1965
  if (j2k->state == 64) {
    {
#line 1966
    j2k_read_eoc(j2k);
    }
  }
#line 1969
  if (j2k->state != 32) {
    {
#line 1970
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 1972
  return (image);
}
}
#line 1979 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
opj_image_t *j2k_decode_jpt_stream(opj_j2k_t *j2k , opj_cio_t *cio , opj_codestream_info_t *cstr_info ) 
{ 
  opj_image_t *image ;
  opj_jpt_msg_header_t header ;
  int position ;
  opj_common_ptr cinfo ;
  opj_image_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  opj_dec_mstabent_t *e ;
  int id ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  opj_dec_mstabent_t *__cil_tmp19 ;
  int __cil_tmp20 ;

  {
  {
#line 1980
  image = (opj_image_t *)((void *)0);
#line 1983
  cinfo = j2k->cinfo;
#line 1987
  j2k->cio = cio;
#line 1990
  image = opj_image_create0();
#line 1991
  j2k->image = image;
#line 1993
  j2k->state = 1;
#line 1996
  jpt_init_msg_header(& header);
#line 1998
  jpt_read_msg_header(cinfo, cio, & header);
#line 2000
  position = cio_tell(cio);
  }
#line 2001
  if (header.Class_Id != 6U) {
    {
#line 2002
    opj_image_destroy(image);
#line 2003
    opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Main header first [class_Id %d] !\n",
                  header.Class_Id);
    }
#line 2004
    return ((opj_image_t *)0);
  }
  {
#line 2007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2007
    if (! 1) {
#line 2007
      goto while_break;
    }
    {
#line 2008
    e = (opj_dec_mstabent_t *)((void *)0);
#line 2011
    __cil_tmp12 = cio_numbytesleft(cio);
    }
#line 2011
    if (! __cil_tmp12) {
      {
#line 2012
      j2k_read_eoc(j2k);
      }
#line 2013
      return (image);
    }
    {
#line 2016
    __cil_tmp13 = cio_tell(cio);
    }
#line 2016
    if ((unsigned int )(__cil_tmp13 - position) == header.Msg_length) {
      {
#line 2017
      jpt_read_msg_header(cinfo, cio, & header);
#line 2018
      position = cio_tell(cio);
      }
#line 2019
      if (header.Class_Id != 4U) {
        {
#line 2020
        opj_image_destroy(image);
#line 2021
        opj_event_msg(cinfo, 1, "[JPT-stream] : Expecting Tile info !\n");
        }
#line 2022
        return ((opj_image_t *)0);
      }
    }
    {
#line 2026
    __cil_tmp15 = cio_read(cio, 2);
#line 2026
    id = (int )__cil_tmp15;
    }
#line 2027
    if (id >> 8 != 255) {
      {
#line 2028
      __cil_tmp16 = cio_numbytesleft(cio);
      }
#line 2028
      if (__cil_tmp16 != 0) {
        {
#line 2030
        __cil_tmp17 = cio_tell(cio);
#line 2030
        opj_event_msg(cinfo, 1, "%.8x: expected a marker instead of %x\n", __cil_tmp17 - 2,
                      id);
#line 2031
        opj_image_destroy(image);
        }
#line 2032
        return ((opj_image_t *)0);
      }
      {
#line 2034
      __cil_tmp18 = cio_tell(cio);
#line 2034
      opj_event_msg(cinfo, 2, "%.8x: expected a marker instead of %x\n", __cil_tmp18 - 2,
                    id);
#line 2035
      j2k->state = 64;
      }
#line 2036
      goto while_break;
    }
    {
#line 2038
    e = j2k_dec_mstab_lookup(id);
    }
#line 2039
    if (! (j2k->state & e->states)) {
      {
#line 2040
      opj_image_destroy(image);
#line 2041
      __cil_tmp20 = cio_tell(cio);
#line 2041
      opj_event_msg(cinfo, 1, "%.8x: unexpected marker %x\nD\262U", __cil_tmp20 - 2,
                    id);
      }
#line 2042
      return ((opj_image_t *)0);
    }
#line 2044
    if (e->handler) {
      {
#line 2045
      (*(e->handler))(j2k);
      }
    }
#line 2047
    if (j2k->state == 32) {
#line 2048
      goto while_break;
    }
#line 2050
    if (j2k->state == 64) {
#line 2051
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2054
  if (j2k->state == 64) {
    {
#line 2055
    j2k_read_eoc(j2k);
    }
  }
#line 2058
  if (j2k->state != 32) {
    {
#line 2059
    opj_event_msg(cinfo, 2, "Incomplete bitstream\n");
    }
  }
#line 2062
  return (image);
}
}
#line 2069 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
opj_j2k_t *j2k_create_compress(opj_common_ptr cinfo ) 
{ 
  opj_j2k_t *j2k ;
  void *__cil_tmp3 ;

  {
  {
#line 2070
  __cil_tmp3 = calloc((unsigned long )1, sizeof(opj_j2k_t ));
#line 2070
  j2k = (opj_j2k_t *)__cil_tmp3;
  }
#line 2071
  if (j2k) {
#line 2072
    j2k->cinfo = cinfo;
  }
#line 2074
  return (j2k);
}
}
#line 2077 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
void j2k_destroy_compress(opj_j2k_t *j2k ) 
{ 
  int tileno ;
  opj_cp_t *cp ;
  int __cil_tmp4 ;

  {
#line 2080
  if (! j2k) {
#line 2080
    return;
  }
#line 2081
  if (j2k->cp != (void *)0) {
#line 2082
    cp = j2k->cp;
#line 2084
    if (cp->comment) {
      {
#line 2085
      free(cp->comment);
      }
    }
#line 2087
    if (cp->matrice) {
      {
#line 2088
      free(cp->matrice);
      }
    }
#line 2090
    tileno = 0;
    {
#line 2090
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2090
      if (! (tileno < cp->tw * cp->th)) {
#line 2090
        goto while_break;
      }
      {
#line 2091
      free((cp->tcps + tileno)->tccps);
      }
#line 2090
      tileno ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2093
    free(cp->tcps);
#line 2094
    free(cp);
    }
  }
  {
#line 2097
  free(j2k);
  }
  return;
}
}
#line 2100 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
void j2k_setup_encoder(opj_j2k_t *j2k , opj_cparameters_t *parameters , opj_image_t *image ) 
{ 
  int i ;
  int j ;
  int tileno ;
  int numpocs_tile ;
  opj_cp_t *cp ;
  void *__cil_tmp9 ;
  size_t array_size ;
  void *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  opj_tcp_t *tcp ;
  int __cil_tmp19 ;
  opj_poc_t *tcp_poc ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;
  opj_tccp_t *tccp ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp29 ;
  int p ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int res_spec ;
  int size_prcw ;
  int size_prch ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;

  {
#line 2102
  cp = (opj_cp_t *)((void *)0);
#line 2104
  if (! j2k) {
#line 2105
    return;
  } else
#line 2104
  if (! parameters) {
#line 2105
    return;
  } else
#line 2104
  if (! image) {
#line 2105
    return;
  }
  {
#line 2109
  __cil_tmp9 = calloc((unsigned long )1, sizeof(opj_cp_t ));
#line 2109
  cp = (opj_cp_t *)__cil_tmp9;
#line 2112
  j2k->cp = cp;
#line 2115
  cp->tw = 1;
#line 2116
  cp->th = 1;
#line 2121
  cp->cinema = parameters->cp_cinema;
#line 2122
  cp->max_comp_size = parameters->max_comp_size;
#line 2123
  cp->rsiz = parameters->cp_rsiz;
#line 2124
  cp->disto_alloc = parameters->cp_disto_alloc;
#line 2125
  cp->fixed_alloc = parameters->cp_fixed_alloc;
#line 2126
  cp->fixed_quality = parameters->cp_fixed_quality;
  }
#line 2129
  if (parameters->cp_matrice) {
    {
#line 2130
    array_size = (unsigned long )((parameters->tcp_numlayers * parameters->numresolution) * 3) * sizeof(int );
#line 2131
    __cil_tmp11 = malloc(array_size);
#line 2131
    cp->matrice = (int *)__cil_tmp11;
#line 2132
    memcpy(cp->matrice, parameters->cp_matrice, array_size);
    }
  }
#line 2136
  cp->tdx = parameters->cp_tdx;
#line 2137
  cp->tdy = parameters->cp_tdy;
#line 2140
  cp->tx0 = parameters->cp_tx0;
#line 2141
  cp->ty0 = parameters->cp_ty0;
#line 2144
  if (parameters->cp_comment) {
    {
#line 2145
    __cil_tmp12 = strlen((char const   *)parameters->cp_comment);
#line 2145
    __cil_tmp13 = malloc(__cil_tmp12 + 1UL);
#line 2145
    cp->comment = (char *)__cil_tmp13;
    }
#line 2146
    if (cp->comment) {
      {
#line 2147
      strcpy(cp->comment, (char const   *)parameters->cp_comment);
      }
    }
  }
#line 2155
  if (parameters->tile_size_on) {
    {
#line 2156
    cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
#line 2157
    cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
    }
  } else {
#line 2159
    cp->tdx = image->x1 - cp->tx0;
#line 2160
    cp->tdy = image->y1 - cp->ty0;
  }
#line 2163
  if (parameters->tp_on) {
#line 2164
    cp->tp_flag = parameters->tp_flag;
#line 2165
    cp->tp_on = (char )1;
  }
#line 2168
  cp->img_size = 0;
#line 2169
  i = 0;
  {
#line 2169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2169
    if (! (i < image->numcomps)) {
#line 2169
      goto while_break;
    }
#line 2170
    cp->img_size += ((image->comps + i)->w * (image->comps + i)->h) * (image->comps + i)->prec;
#line 2169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2233
  __cil_tmp17 = calloc((unsigned long )(cp->tw * cp->th), sizeof(opj_tcp_t ));
#line 2233
  cp->tcps = (opj_tcp_t *)__cil_tmp17;
#line 2235
  tileno = 0;
  }
  {
#line 2235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2235
    if (! (tileno < cp->tw * cp->th)) {
#line 2235
      goto while_break___0;
    }
#line 2236
    tcp = cp->tcps + tileno;
#line 2237
    tcp->numlayers = parameters->tcp_numlayers;
#line 2238
    j = 0;
    {
#line 2238
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2238
      if (! (j < tcp->numlayers)) {
#line 2238
        goto while_break___1;
      }
#line 2239
      if (cp->cinema) {
#line 2240
        if (cp->fixed_quality) {
#line 2241
          tcp->distoratio[j] = parameters->tcp_distoratio[j];
        }
#line 2243
        tcp->rates[j] = parameters->tcp_rates[j];
      } else
#line 2245
      if (cp->fixed_quality) {
#line 2246
        tcp->distoratio[j] = parameters->tcp_distoratio[j];
      } else {
#line 2248
        tcp->rates[j] = parameters->tcp_rates[j];
      }
#line 2238
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2252
    tcp->csty = parameters->csty;
#line 2253
    tcp->prg = parameters->prog_order;
#line 2254
    tcp->mct = (int )parameters->tcp_mct;
#line 2256
    numpocs_tile = 0;
#line 2257
    tcp->POC = 0;
#line 2258
    if (parameters->numpocs) {
#line 2260
      tcp->POC = 1;
#line 2261
      i = 0;
      {
#line 2261
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2261
        if (! (i < parameters->numpocs)) {
#line 2261
          goto while_break___2;
        }
#line 2262
        if (tileno == parameters->POC[i].tile - 1) {
          _L: /* CIL Label */ 
#line 2263
          tcp_poc = & tcp->pocs[numpocs_tile];
#line 2264
          tcp_poc->resno0 = parameters->POC[numpocs_tile].resno0;
#line 2265
          tcp_poc->compno0 = parameters->POC[numpocs_tile].compno0;
#line 2266
          tcp_poc->layno1 = parameters->POC[numpocs_tile].layno1;
#line 2267
          tcp_poc->resno1 = parameters->POC[numpocs_tile].resno1;
#line 2268
          tcp_poc->compno1 = parameters->POC[numpocs_tile].compno1;
#line 2269
          tcp_poc->prg1 = parameters->POC[numpocs_tile].prg1;
#line 2270
          tcp_poc->tile = parameters->POC[numpocs_tile].tile;
#line 2271
          numpocs_tile ++;
        } else
#line 2262
        if (parameters->POC[i].tile == -1) {
#line 2262
          goto _L;
        }
#line 2261
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2274
      tcp->numpocs = numpocs_tile - 1;
    } else {
#line 2276
      tcp->numpocs = 0;
    }
    {
#line 2279
    __cil_tmp23 = calloc((unsigned long )image->numcomps, sizeof(opj_tccp_t ));
#line 2279
    tcp->tccps = (opj_tccp_t *)__cil_tmp23;
#line 2281
    i = 0;
    }
    {
#line 2281
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2281
      if (! (i < image->numcomps)) {
#line 2281
        goto while_break___3;
      }
      {
#line 2282
      tccp = tcp->tccps + i;
#line 2283
      tccp->csty = parameters->csty & 1;
#line 2284
      tccp->numresolutions = parameters->numresolution;
#line 2285
      tccp->cblkw = int_floorlog2(parameters->cblockw_init);
#line 2286
      tccp->cblkh = int_floorlog2(parameters->cblockh_init);
#line 2287
      tccp->cblksty = parameters->mode;
      }
#line 2288
      if (parameters->irreversible) {
#line 2288
        tmp = 0;
      } else {
#line 2288
        tmp = 1;
      }
#line 2288
      tccp->qmfbid = tmp;
#line 2289
      if (parameters->irreversible) {
#line 2289
        tmp___0 = 2;
      } else {
#line 2289
        tmp___0 = 0;
      }
#line 2289
      tccp->qntsty = tmp___0;
#line 2290
      tccp->numgbits = 2;
#line 2291
      if (i == parameters->roi_compno) {
#line 2292
        tccp->roishift = parameters->roi_shift;
      } else {
#line 2294
        tccp->roishift = 0;
      }
#line 2297
      if (parameters->cp_cinema) {
#line 2300
        tccp->prcw[0] = 7;
#line 2301
        tccp->prch[0] = 7;
#line 2303
        j = 1;
        {
#line 2303
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2303
          if (! (j < tccp->numresolutions)) {
#line 2303
            goto while_break___4;
          }
#line 2304
          tccp->prcw[j] = 8;
#line 2305
          tccp->prch[j] = 8;
#line 2303
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 2308
      if (parameters->csty & 1) {
#line 2309
        p = 0;
#line 2310
        j = tccp->numresolutions - 1;
        {
#line 2310
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2310
          if (! (j >= 0)) {
#line 2310
            goto while_break___5;
          }
#line 2311
          if (p < parameters->res_spec) {
#line 2313
            if (parameters->prcw_init[p] < 1) {
#line 2314
              tccp->prcw[j] = 1;
            } else {
              {
#line 2316
              tccp->prcw[j] = int_floorlog2(parameters->prcw_init[p]);
              }
            }
#line 2319
            if (parameters->prch_init[p] < 1) {
#line 2320
              tccp->prch[j] = 1;
            } else {
              {
#line 2322
              tccp->prch[j] = int_floorlog2(parameters->prch_init[p]);
              }
            }
          } else {
#line 2326
            res_spec = parameters->res_spec;
#line 2327
            size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2328
            size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
#line 2330
            if (size_prcw < 1) {
#line 2331
              tccp->prcw[j] = 1;
            } else {
              {
#line 2333
              tccp->prcw[j] = int_floorlog2(size_prcw);
              }
            }
#line 2336
            if (size_prch < 1) {
#line 2337
              tccp->prch[j] = 1;
            } else {
              {
#line 2339
              tccp->prch[j] = int_floorlog2(size_prch);
              }
            }
          }
#line 2342
          p ++;
#line 2310
          __cil_tmp39 = j;
#line 2310
          j --;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 2346
        j = 0;
        {
#line 2346
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2346
          if (! (j < tccp->numresolutions)) {
#line 2346
            goto while_break___6;
          }
#line 2347
          tccp->prcw[j] = 15;
#line 2348
          tccp->prch[j] = 15;
#line 2346
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 2353
      dwt_calc_explicit_stepsizes(tccp, (image->comps + i)->prec);
      }
#line 2281
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2235
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 2358 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
opj_bool j2k_encode(opj_j2k_t *j2k , opj_cio_t *cio , opj_image_t *image , opj_codestream_info_t *cstr_info ) 
{ 
  int tileno ;
  int compno ;
  opj_cp_t *cp ;
  opj_tcd_t *tcd ;
  int compno___15 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  opj_tcp_t *tcp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_tcd_t *__cil_tmp20 ;
  int pino ;
  int tilepartno ;
  int acc_pack_num ;
  opj_tcp_t *tcp___0 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;
  int tot_num_tp ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;

  {
#line 2360
  cp = (opj_cp_t *)((void *)0);
#line 2362
  tcd = (opj_tcd_t *)((void *)0);
#line 2364
  j2k->cio = cio;
#line 2365
  j2k->image = image;
#line 2367
  cp = j2k->cp;
#line 2370
  j2k->cstr_info = cstr_info;
#line 2371
  if (cstr_info) {
    {
#line 2373
    __cil_tmp10 = malloc((unsigned long )(cp->tw * cp->th) * sizeof(opj_tile_info_t ));
#line 2373
    cstr_info->tile = (opj_tile_info_t *)__cil_tmp10;
#line 2374
    cstr_info->image_w = image->x1 - image->x0;
#line 2375
    cstr_info->image_h = image->y1 - image->y0;
#line 2376
    cstr_info->prog = (cp->tcps + 0)->prg;
#line 2377
    cstr_info->tw = cp->tw;
#line 2378
    cstr_info->th = cp->th;
#line 2379
    cstr_info->tile_x = cp->tdx;
#line 2380
    cstr_info->tile_y = cp->tdy;
#line 2381
    cstr_info->tile_Ox = cp->tx0;
#line 2382
    cstr_info->tile_Oy = cp->ty0;
#line 2383
    cstr_info->numcomps = image->numcomps;
#line 2384
    cstr_info->numlayers = (cp->tcps + 0)->numlayers;
#line 2385
    __cil_tmp11 = malloc((unsigned long )image->numcomps * sizeof(int ));
#line 2385
    cstr_info->numdecompos = (int *)__cil_tmp11;
#line 2386
    compno___15 = 0;
    }
    {
#line 2386
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2386
      if (! (compno___15 < image->numcomps)) {
#line 2386
        goto while_break;
      }
#line 2387
      *(cstr_info->numdecompos + compno___15) = ((cp->tcps + 0)->tccps)->numresolutions - 1;
#line 2386
      compno___15 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2389
    cstr_info->D_max = 0.;
#line 2390
    cstr_info->main_head_start = cio_tell(cio);
#line 2391
    cstr_info->maxmarknum = 100;
#line 2392
    __cil_tmp14 = malloc((unsigned long )cstr_info->maxmarknum * sizeof(opj_marker_info_t ));
#line 2392
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp14;
#line 2393
    cstr_info->marknum = 0;
    }
  }
  {
#line 2397
  j2k_write_soc(j2k);
#line 2398
  j2k_write_siz(j2k);
#line 2399
  j2k_write_cod(j2k);
#line 2400
  j2k_write_qcd(j2k);
  }
#line 2402
  if (cp->cinema) {
#line 2403
    compno = 1;
    {
#line 2403
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2403
      if (! (compno < image->numcomps)) {
#line 2403
        goto while_break___0;
      }
      {
#line 2404
      j2k_write_coc(j2k, compno);
#line 2405
      j2k_write_qcc(j2k, compno);
      }
#line 2403
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2409
  compno = 0;
  {
#line 2409
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2409
    if (! (compno < image->numcomps)) {
#line 2409
      goto while_break___1;
    }
#line 2410
    tcp = cp->tcps + 0;
#line 2411
    if ((tcp->tccps + compno)->roishift) {
      {
#line 2412
      j2k_write_rgn(j2k, compno, 0);
      }
    }
#line 2409
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2414
  if (cp->comment != (void *)0) {
    {
#line 2415
    j2k_write_com(j2k);
    }
  }
  {
#line 2418
  j2k->totnum_tp = j2k_calculate_tp(cp, image->numcomps, image, j2k);
  }
#line 2420
  if (cp->cinema) {
    {
#line 2421
    j2k_write_tlm(j2k);
    }
#line 2422
    if ((unsigned int )cp->cinema == 3U) {
      {
#line 2423
      j2k_write_poc(j2k);
      }
    }
  }
#line 2431
  if (cstr_info) {
    {
#line 2432
    __cil_tmp19 = cio_tell(cio);
#line 2432
    cstr_info->main_head_end = __cil_tmp19 - 1;
    }
  }
  {
#line 2438
  tcd = tcd_create(j2k->cinfo);
#line 2441
  tileno = 0;
  }
  {
#line 2441
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2441
    if (! (tileno < cp->tw * cp->th)) {
#line 2441
      goto while_break___2;
    }
    {
#line 2443
    tilepartno = 0;
#line 2445
    acc_pack_num = 0;
#line 2449
    tcp___0 = cp->tcps + tileno;
#line 2450
    opj_event_msg(j2k->cinfo, 4, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
#line 2452
    j2k->curtileno = tileno;
#line 2453
    j2k->cur_tp_num = 0;
#line 2454
    tcd->cur_totnum_tp = *(j2k->cur_totnum_tp + j2k->curtileno);
    }
#line 2456
    if (tileno == 0) {
      {
#line 2457
      tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
      }
    } else {
      {
#line 2459
      tcd_init_encode(tcd, image, cp, j2k->curtileno);
      }
    }
#line 2463
    if (cstr_info) {
      {
#line 2464
      __cil_tmp25 = cio_tell(cio);
#line 2464
      (cstr_info->tile + j2k->curtileno)->start_pos = __cil_tmp25 + j2k->pos_correction;
#line 2465
      (cstr_info->tile + j2k->curtileno)->maxmarknum = 10;
#line 2466
      __cil_tmp26 = malloc((unsigned long )(cstr_info->tile + j2k->curtileno)->maxmarknum * sizeof(opj_marker_info_t ));
#line 2466
      (cstr_info->tile + j2k->curtileno)->marker = (opj_marker_info_t *)__cil_tmp26;
#line 2467
      (cstr_info->tile + j2k->curtileno)->marknum = 0;
      }
    }
#line 2471
    pino = 0;
    {
#line 2471
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2471
      if (! (pino <= tcp___0->numpocs)) {
#line 2471
        goto while_break___3;
      }
      {
#line 2473
      tcd->cur_pino = pino;
#line 2476
      tot_num_tp = j2k_get_num_tp(cp, pino, tileno);
#line 2477
      tcd->tp_pos = cp->tp_pos;
#line 2479
      tilepartno = 0;
      }
      {
#line 2479
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2479
        if (! (tilepartno < tot_num_tp)) {
#line 2479
          goto while_break___4;
        }
#line 2480
        j2k->tp_num = tilepartno;
#line 2482
        if (cstr_info) {
          {
#line 2483
          __cil_tmp29 = cio_tell(cio);
#line 2483
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pos = __cil_tmp29 + j2k->pos_correction;
          }
        }
        {
#line 2486
        j2k_write_sot(j2k);
        }
#line 2488
        if (j2k->cur_tp_num == 0) {
#line 2488
          if ((unsigned int )cp->cinema == 0U) {
#line 2489
            compno = 1;
            {
#line 2489
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2489
              if (! (compno < image->numcomps)) {
#line 2489
                goto while_break___5;
              }
              {
#line 2490
              j2k_write_coc(j2k, compno);
#line 2491
              j2k_write_qcc(j2k, compno);
              }
#line 2489
              compno ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2493
            if ((cp->tcps + tileno)->numpocs) {
              {
#line 2494
              j2k_write_poc(j2k);
              }
            }
          }
        }
#line 2499
        if (cstr_info) {
          {
#line 2500
          __cil_tmp31 = cio_tell(cio);
#line 2500
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_header = (__cil_tmp31 + j2k->pos_correction) + 1;
          }
        }
        {
#line 2504
        j2k_write_sod(j2k, tcd);
        }
#line 2507
        if (cstr_info) {
          {
#line 2508
          __cil_tmp32 = cio_tell(cio);
#line 2508
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_end_pos = (__cil_tmp32 + j2k->pos_correction) - 1;
#line 2510
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_start_pack = acc_pack_num;
#line 2512
          ((cstr_info->tile + j2k->curtileno)->tp + j2k->cur_tp_num)->tp_numpacks = cstr_info->packno - acc_pack_num;
#line 2514
          acc_pack_num = cstr_info->packno;
          }
        }
#line 2518
        (j2k->cur_tp_num) ++;
#line 2479
        tilepartno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2471
      pino ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2521
    if (cstr_info) {
      {
#line 2522
      __cil_tmp36 = cio_tell(cio);
#line 2522
      (cstr_info->tile + j2k->curtileno)->end_pos = (__cil_tmp36 + j2k->pos_correction) - 1;
      }
    }
#line 2441
    tileno ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2545
  tcd_free_encode(tcd);
#line 2546
  tcd_destroy(tcd);
#line 2548
  free(j2k->cur_totnum_tp);
#line 2550
  j2k_write_eoc(j2k);
  }
#line 2552
  if (cstr_info) {
    {
#line 2553
    __cil_tmp38 = cio_tell(cio);
#line 2553
    cstr_info->codestream_size = __cil_tmp38 + j2k->pos_correction;
#line 2558
    cstr_info->codestream_size -= cstr_info->main_head_start;
    }
  }
#line 2574
  return (1);
}
}
#line 2577 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  void *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 2579
  if (! cstr_info) {
#line 2580
    return;
  }
#line 2583
  if (cstr_info->marknum + 1 > cstr_info->maxmarknum) {
    {
#line 2584
    cstr_info->maxmarknum = 100 + (int )((float )cstr_info->maxmarknum * 1.f);
#line 2585
    __cil_tmp5 = realloc(cstr_info->marker, (unsigned long )cstr_info->maxmarknum);
#line 2585
    cstr_info->marker = (opj_marker_info_t *)__cil_tmp5;
    }
  }
#line 2589
  (cstr_info->marker + cstr_info->marknum)->type = type;
#line 2590
  (cstr_info->marker + cstr_info->marknum)->pos = pos;
#line 2591
  (cstr_info->marker + cstr_info->marknum)->len = len;
#line 2592
  (cstr_info->marknum) ++;
  return;
}
}
#line 2596 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/j2k.c"
static void j2k_add_tlmarker(int tileno , opj_codestream_info_t *cstr_info , unsigned short type ,
                             int pos , int len ) 
{ 
  opj_marker_info_t *marker ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 2600
  if (! cstr_info) {
#line 2601
    return;
  }
#line 2604
  if ((cstr_info->tile + tileno)->marknum + 1 > (cstr_info->tile + tileno)->maxmarknum) {
    {
#line 2605
    (cstr_info->tile + tileno)->maxmarknum = 100 + (int )((float )(cstr_info->tile + tileno)->maxmarknum * 1.f);
#line 2606
    __cil_tmp7 = realloc((cstr_info->tile + tileno)->marker, (unsigned long )cstr_info->maxmarknum);
#line 2606
    (cstr_info->tile + tileno)->marker = (opj_marker_info_t *)__cil_tmp7;
    }
  }
#line 2609
  marker = (cstr_info->tile + tileno)->marker + (cstr_info->tile + tileno)->marknum;
#line 2612
  marker->type = type;
#line 2613
  marker->pos = pos;
#line 2614
  marker->len = len;
#line 2615
  ((cstr_info->tile + tileno)->marknum) ++;
  return;
}
}
#line 29 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/image.c"
opj_image_t *opj_image_create0(void) 
{ 
  opj_image_t *image ;
  void *__cil_tmp2 ;

  {
  {
#line 30
  __cil_tmp2 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 30
  image = (opj_image_t *)__cil_tmp2;
  }
#line 31
  return (image);
}
}
#line 34 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/image.c"
opj_image_t *opj_image_create(int numcmpts , opj_image_cmptparm_t *cmptparms , OPJ_COLOR_SPACE clrspc ) 
{ 
  int compno ;
  opj_image_t *image ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  opj_image_comp_t *comp ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 36
  image = (opj_image_t *)((void *)0);
#line 38
  __cil_tmp6 = calloc((unsigned long )1, sizeof(opj_image_t ));
#line 38
  image = (opj_image_t *)__cil_tmp6;
  }
#line 39
  if (image) {
    {
#line 40
    image->color_space = clrspc;
#line 41
    image->numcomps = numcmpts;
#line 43
    __cil_tmp7 = malloc((unsigned long )image->numcomps * sizeof(opj_image_comp_t ));
#line 43
    image->comps = (opj_image_comp_t *)__cil_tmp7;
    }
#line 44
    if (! image->comps) {
      {
#line 45
      fprintf(stderr, "Unable to allocate memory for image.\n");
#line 46
      opj_image_destroy(image);
      }
#line 47
      return ((opj_image_t *)((void *)0));
    }
#line 50
    compno = 0;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (compno < numcmpts)) {
#line 50
        goto while_break;
      }
      {
#line 51
      comp = image->comps + compno;
#line 52
      comp->dx = (cmptparms + compno)->dx;
#line 53
      comp->dy = (cmptparms + compno)->dy;
#line 54
      comp->w = (cmptparms + compno)->w;
#line 55
      comp->h = (cmptparms + compno)->h;
#line 56
      comp->x0 = (cmptparms + compno)->x0;
#line 57
      comp->y0 = (cmptparms + compno)->y0;
#line 58
      comp->prec = (cmptparms + compno)->prec;
#line 59
      comp->bpp = (cmptparms + compno)->bpp;
#line 60
      comp->sgnd = (cmptparms + compno)->sgnd;
#line 61
      __cil_tmp9 = calloc((unsigned long )(comp->w * comp->h), sizeof(int ));
#line 61
      comp->data = (int *)__cil_tmp9;
      }
#line 62
      if (! comp->data) {
        {
#line 63
        fprintf(stderr, "Unable to allocate memory for image.\n");
#line 64
        opj_image_destroy(image);
        }
#line 65
        return ((opj_image_t *)((void *)0));
      }
#line 50
      compno ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 70
  return (image);
}
}
#line 73 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/image.c"
void opj_image_destroy(opj_image_t *image ) 
{ 
  int i ;
  opj_image_comp_t *image_comp ;
  int __cil_tmp4 ;

  {
#line 75
  if (image) {
#line 76
    if (image->comps) {
#line 78
      i = 0;
      {
#line 78
      while (1) {
        while_continue: /* CIL Label */ ;
#line 78
        if (! (i < image->numcomps)) {
#line 78
          goto while_break;
        }
#line 79
        image_comp = image->comps + i;
#line 80
        if (image_comp->data) {
          {
#line 81
          free(image_comp->data);
          }
        }
#line 78
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 84
      free(image->comps);
      }
    }
    {
#line 86
    free(image);
    }
  }
  return;
}
}
#line 65 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/event.c"
opj_event_mgr_t *opj_set_event_mgr(opj_common_ptr cinfo , opj_event_mgr_t *event_mgr ,
                                   void *context ) 
{ 
  opj_event_mgr_t *previous ;

  {
#line 66
  if (cinfo) {
#line 67
    previous = cinfo->event_mgr;
#line 68
    cinfo->event_mgr = event_mgr;
#line 69
    cinfo->client_data = context;
#line 70
    return (previous);
  }
#line 73
  return ((opj_event_mgr_t *)((void *)0));
}
}
#line 76 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/event.c"
opj_bool opj_event_msg(opj_common_ptr cinfo , int event_type , char const   *fmt 
                       , ...) 
{ 
  opj_msg_callback msg_handler ;
  opj_event_mgr_t *event_mgr ;
  va_list arg ;
  int str_length ;
  char message[512] ;
  int __cil_tmp9 ;

  {
#line 78
  msg_handler = (opj_msg_callback )((void *)0);
#line 80
  event_mgr = cinfo->event_mgr;
#line 81
  if (event_mgr != (void *)0) {
    {
#line 83
    if (event_type == 1) {
#line 83
      goto case_1;
    }
#line 86
    if (event_type == 2) {
#line 86
      goto case_2;
    }
#line 89
    if (event_type == 4) {
#line 89
      goto case_4;
    }
#line 92
    goto switch_default;
    case_1: /* CIL Label */ 
#line 84
    msg_handler = event_mgr->error_handler;
#line 85
    goto switch_break;
    case_2: /* CIL Label */ 
#line 87
    msg_handler = event_mgr->warning_handler;
#line 88
    goto switch_break;
    case_4: /* CIL Label */ 
#line 90
    msg_handler = event_mgr->info_handler;
#line 91
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 93
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 95
    if (msg_handler == (void *)0) {
#line 96
      return (0);
    }
  } else {
#line 99
    return (0);
  }
#line 102
  if (fmt != (void *)0) {
#line 102
    if (event_mgr != (void *)0) {
      {
#line 107
      __builtin_va_start((void *)arg, fmt);
#line 109
      str_length = vsnprintf((char *)message, (unsigned long )512, fmt, (void *)arg);
#line 111
      __builtin_va_end((void *)arg);
      }
#line 114
      if (str_length > -1) {
#line 114
        if (str_length < 512) {
          {
#line 115
          (*msg_handler)((char const   *)((char *)message), cinfo->client_data);
          }
        } else {
#line 116
          return (0);
        }
      } else {
#line 116
        return (0);
      }
    }
  }
#line 119
  return (1);
}
}
#line 36 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
opj_cio_t *opj_cio_open(opj_common_ptr cinfo , unsigned char *buffer , int length ) 
{ 
  opj_cp_t *cp ;
  opj_cio_t *cio ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 37
  cp = (opj_cp_t *)((void *)0);
#line 38
  __cil_tmp6 = malloc(sizeof(opj_cio_t ));
#line 38
  cio = (opj_cio_t *)__cil_tmp6;
  }
#line 39
  if (! cio) {
#line 39
    return ((opj_cio_t *)((void *)0));
  }
#line 40
  cio->cinfo = cinfo;
#line 41
  if (buffer) {
#line 41
    if (length) {
#line 43
      cio->openmode = 1;
#line 44
      cio->buffer = buffer;
#line 45
      cio->length = length;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 47
  if (! buffer) {
#line 47
    if (! length) {
#line 47
      if (cinfo) {
#line 49
        cio->openmode = 2;
        {
#line 51
        if ((int )cinfo->codec_format == 0) {
#line 51
          goto case_0;
        }
#line 54
        if ((int )cinfo->codec_format == 2) {
#line 54
          goto case_2;
        }
#line 57
        goto switch_default;
        case_0: /* CIL Label */ 
#line 52
        cp = ((opj_j2k_t *)cinfo->j2k_handle)->cp;
#line 53
        goto switch_break;
        case_2: /* CIL Label */ 
#line 55
        cp = (((opj_jp2_t *)cinfo->jp2_handle)->j2k)->cp;
#line 56
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 58
        free(cio);
        }
#line 59
        return ((opj_cio_t *)((void *)0));
        switch_break: /* CIL Label */ ;
        }
        {
#line 61
        cio->length = (int )((unsigned int )(0.162500000001 * (double )cp->img_size + (double )2000));
#line 62
        __cil_tmp7 = malloc((unsigned long )cio->length);
#line 62
        cio->buffer = (unsigned char *)__cil_tmp7;
        }
#line 63
        if (! cio->buffer) {
          {
#line 64
          opj_event_msg(cio->cinfo, 1, "Error allocating memory for compressed bitstream\n");
#line 65
          free(cio);
          }
#line 66
          return ((opj_cio_t *)((void *)0));
        }
      } else {
        {
        {
        {
#line 70
        free(cio);
        }
        }
        }
#line 71
        return ((opj_cio_t *)((void *)0));
      }
    } else {
      {
      {
      {
#line 70
      free(cio);
      }
      }
      }
#line 71
      return ((opj_cio_t *)((void *)0));
    }
  } else {
    {
    {
    {
#line 70
    free(cio);
    }
    }
    }
#line 71
    return ((opj_cio_t *)((void *)0));
  }
#line 75
  cio->start = cio->buffer;
#line 76
  cio->end = cio->buffer + cio->length;
#line 77
  cio->bp = cio->buffer;
#line 79
  return (cio);
}
}
#line 82 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
void opj_cio_close(opj_cio_t *cio ) 
{ 


  {
#line 83
  if (cio) {
#line 84
    if (cio->openmode == 2) {
      {
#line 86
      free(cio->buffer);
      }
    }
    {
#line 89
    free(cio);
    }
  }
  return;
}
}
#line 99 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
int cio_tell(opj_cio_t *cio ) 
{ 


  {
#line 100
  return ((int )(cio->bp - cio->start));
}
}
#line 108 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
void cio_seek(opj_cio_t *cio , int pos ) 
{ 


  {
#line 109
  cio->bp = cio->start + pos;
  return;
}
}
#line 115 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
int cio_numbytesleft(opj_cio_t *cio ) 
{ 


  {
#line 116
  return ((int )(cio->end - cio->bp));
}
}
#line 122 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
unsigned char *cio_getbp(opj_cio_t *cio ) 
{ 


  {
#line 123
  return (cio->bp);
}
}
#line 129 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
opj_bool cio_byteout(opj_cio_t *cio , unsigned char v ) 
{ 
  unsigned char *__cil_tmp3 ;

  {
#line 130
  if (cio->bp >= cio->end) {
    {
#line 131
    opj_event_msg(cio->cinfo, 1, "write error\n\262U");
    }
#line 132
    return (0);
  }
#line 134
  __cil_tmp3 = cio->bp;
#line 134
  (cio->bp) ++;
#line 134
  *__cil_tmp3 = v;
#line 135
  return (1);
}
}
#line 141 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
unsigned char cio_bytein(opj_cio_t *cio ) 
{ 
  unsigned char *__cil_tmp2 ;

  {
#line 142
  if (cio->bp >= cio->end) {
    {
#line 143
    opj_event_msg(cio->cinfo, 1, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n",
                  cio->start, cio->bp, cio->end);
    }
#line 144
    return ((unsigned char )0);
  }
#line 146
  __cil_tmp2 = cio->bp;
#line 146
  (cio->bp) ++;
#line 146
  return (*__cil_tmp2);
}
}
#line 155 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
unsigned int cio_write(opj_cio_t *cio , unsigned long long v , int n ) 
{ 
  int i ;
  opj_bool __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 157
  i = n - 1;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i >= 0)) {
#line 157
      goto while_break;
    }
    {
#line 158
    __cil_tmp5 = cio_byteout(cio, (unsigned char )((v >> (i << 3)) & 255ULL));
    }
#line 158
    if (! __cil_tmp5) {
#line 159
      return ((unsigned int )0);
    }
#line 157
    __cil_tmp6 = i;
#line 157
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return ((unsigned int )n);
}
}
#line 171 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
unsigned int cio_read(opj_cio_t *cio , int n ) 
{ 
  int i ;
  unsigned int v ;
  unsigned char __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 174
  v = (unsigned int )0;
#line 175
  i = n - 1;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i >= 0)) {
#line 175
      goto while_break;
    }
    {
#line 176
    __cil_tmp5 = cio_bytein(cio);
    }
#line 176
    v += (unsigned int )((int )__cil_tmp5 << (i << 3));
#line 175
    __cil_tmp6 = i;
#line 175
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return (v);
}
}
#line 186 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/cio.c"
void cio_skip(opj_cio_t *cio , int n ) 
{ 


  {
#line 187
  cio->bp += n;
  return;
}
}
#line 45 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , int b ) ;
#line 51
static int bio_getbit(opj_bio_t *bio ) ;
#line 57
static int bio_byteout(opj_bio_t *bio ) ;
#line 63
static int bio_bytein(opj_bio_t *bio ) ;
#line 75 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
static int bio_byteout(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 76
  bio->buf = (bio->buf << 8) & 65535U;
#line 77
  if (bio->buf == 65280U) {
#line 77
    tmp = 7;
  } else {
#line 77
    tmp = 8;
  }
#line 77
  bio->ct = tmp;
#line 78
  if (bio->bp >= bio->end) {
#line 79
    return (1);
  }
#line 81
  __cil_tmp3 = bio->bp;
#line 81
  (bio->bp) ++;
#line 81
  *__cil_tmp3 = (unsigned char )(bio->buf >> 8);
#line 82
  return (0);
}
}
#line 85 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
static int bio_bytein(opj_bio_t *bio ) 
{ 
  int tmp ;
  unsigned char *__cil_tmp3 ;

  {
#line 86
  bio->buf = (bio->buf << 8) & 65535U;
#line 87
  if (bio->buf == 65280U) {
#line 87
    tmp = 7;
  } else {
#line 87
    tmp = 8;
  }
#line 87
  bio->ct = tmp;
#line 88
  if (bio->bp >= bio->end) {
#line 89
    return (1);
  }
#line 91
  __cil_tmp3 = bio->bp;
#line 91
  (bio->bp) ++;
#line 91
  bio->buf |= (unsigned int )*__cil_tmp3;
#line 92
  return (0);
}
}
#line 95 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
static void bio_putbit(opj_bio_t *bio , int b ) 
{ 
  int __cil_tmp3 ;

  {
#line 96
  if (bio->ct == 0) {
    {
#line 97
    bio_byteout(bio);
    }
  }
#line 99
  __cil_tmp3 = bio->ct;
#line 99
  (bio->ct) --;
#line 100
  bio->buf |= (unsigned int )(b << bio->ct);
  return;
}
}
#line 103 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
static int bio_getbit(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 104
  if (bio->ct == 0) {
    {
#line 105
    bio_bytein(bio);
    }
  }
#line 107
  __cil_tmp2 = bio->ct;
#line 107
  (bio->ct) --;
#line 108
  return ((int )((bio->buf >> bio->ct) & 1U));
}
}
#line 117 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
opj_bio_t *bio_create(void) 
{ 
  opj_bio_t *bio ;
  void *__cil_tmp2 ;

  {
  {
#line 118
  __cil_tmp2 = malloc(sizeof(opj_bio_t ));
#line 118
  bio = (opj_bio_t *)__cil_tmp2;
  }
#line 119
  return (bio);
}
}
#line 122 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
void bio_destroy(opj_bio_t *bio ) 
{ 


  {
#line 123
  if (bio) {
    {
#line 124
    free(bio);
    }
  }
  return;
}
}
#line 128 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
int bio_numbytes(opj_bio_t *bio ) 
{ 


  {
#line 129
  return ((int )(bio->bp - bio->start));
}
}
#line 132 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
void bio_init_enc(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 133
  bio->start = bp;
#line 134
  bio->end = bp + len;
#line 135
  bio->bp = bp;
#line 136
  bio->buf = (unsigned int )0;
#line 137
  bio->ct = 8;
  return;
}
}
#line 140 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
void bio_init_dec(opj_bio_t *bio , unsigned char *bp , int len ) 
{ 


  {
#line 141
  bio->start = bp;
#line 142
  bio->end = bp + len;
#line 143
  bio->bp = bp;
#line 144
  bio->buf = (unsigned int )0;
#line 145
  bio->ct = 0;
  return;
}
}
#line 148 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
void bio_write(opj_bio_t *bio , int v , int n ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 150
  i = n - 1;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i >= 0)) {
#line 150
      goto while_break;
    }
    {
#line 151
    bio_putbit(bio, (v >> i) & 1);
    }
#line 150
    __cil_tmp5 = i;
#line 150
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 155 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
int bio_read(opj_bio_t *bio , int n ) 
{ 
  int i ;
  int v ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 157
  v = 0;
#line 158
  i = n - 1;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i >= 0)) {
#line 158
      goto while_break;
    }
    {
#line 159
    __cil_tmp5 = bio_getbit(bio);
    }
#line 159
    v += __cil_tmp5 << i;
#line 158
    __cil_tmp6 = i;
#line 158
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (v);
}
}
#line 164 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
int bio_flush(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 165
  bio->ct = 0;
#line 166
  __cil_tmp2 = bio_byteout(bio);
  }
#line 166
  if (__cil_tmp2) {
#line 167
    return (1);
  }
#line 169
  if (bio->ct == 7) {
    {
#line 170
    bio->ct = 0;
#line 171
    __cil_tmp3 = bio_byteout(bio);
    }
#line 171
    if (__cil_tmp3) {
#line 172
      return (1);
    }
  }
#line 175
  return (0);
}
}
#line 178 "/doner/openjpeg/openjpeg-c02f145/libopenjpeg/bio.c"
int bio_inalign(opj_bio_t *bio ) 
{ 
  int __cil_tmp2 ;

  {
#line 179
  bio->ct = 0;
#line 180
  if ((bio->buf & 255U) == 255U) {
    {
#line 181
    __cil_tmp2 = bio_bytein(bio);
    }
#line 181
    if (__cil_tmp2) {
#line 182
      return (1);
    }
#line 184
    bio->ct = 0;
  }
#line 186
  return (0);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 18 "../../applications/common/opj_getopt.h"
int opj_opterr ;
#line 19
int opj_optind ;
#line 20
int opj_optopt ;
#line 21
int opj_optreset ;
#line 22
char *opj_optarg ;
#line 24
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) ;
#line 25
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) ;
#line 27
void reset_options_reading(void) ;
#line 51 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.h"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 52
int imagetotga(opj_image_t *image , char const   *outfile ) ;
#line 55
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 56
int imagetobmp(opj_image_t *image , char const   *outfile ) ;
#line 59
opj_image_t *tiftoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 60
int imagetotif(opj_image_t *image , char const   *outfile ) ;
#line 67
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 68
int imagetopgx(opj_image_t *image , char const   *outfile ) ;
#line 70
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 71
int imagetopnm(opj_image_t *image , char const   *outfile ) ;
#line 74
int imagetoraw(opj_image_t *image , char const   *outfile ) ;
#line 75
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) ;
#line 78
extern int imagetopng(opj_image_t *image , char const   *write_idf ) ;
#line 79
extern opj_image_t *pngtoimage(char const   *filename , opj_cparameters_t *parameters ) ;
#line 42 "/doner/openjpeg/openjpeg-c02f145/applications/codec/index.h"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) ;
#line 35 "../../applications/common/color.h"
void color_sycc_to_rgb(opj_image_t *img ) ;
#line 36
extern void color_apply_icc_profile(opj_image_t *image ) ;
#line 88 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
void decode_help_display(void) 
{ 


  {
  {
#line 89
  fprintf(stdout, "HELP for j2k_to_image\n----\n\n\262U");
#line 90
  fprintf(stdout, "- the -h option displays this help information on screen\n\n\260D\262U");
#line 93
  fprintf(stdout, "List of parameters for the JPEG 2000 decoder:\n\001");
#line 99
  fprintf(stdout, "\n\235\001");
#line 100
  fprintf(stdout, "\n\244\001");
#line 101
  fprintf(stdout, "  -ImgDir \nD\262U");
#line 102
  fprintf(stdout, "\tImage file Directory path \n");
#line 103
  fprintf(stdout, "  -OutFor \nD\262U");
#line 104
  fprintf(stdout, "    REQUIRED only if -ImgDir is used\n");
#line 105
  fprintf(stdout, "\t  Need to specify only format without filename <BMP>  \n\220");
#line 106
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA formats\nU");
#line 107
  fprintf(stdout, "  -i <compressed file>\n");
#line 108
  fprintf(stdout, "    REQUIRED only if an Input image directory not specified\n\262U");
#line 109
  fprintf(stdout, "    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n\220");
#line 110
  fprintf(stdout, "    is identified based on its suffix.\n");
#line 111
  fprintf(stdout, "  -o <decompressed file>\n");
#line 112
  fprintf(stdout, "    REQUIRED\n");
#line 113
  fprintf(stdout, "    Currently accepts PGM, PPM, PNM, PGX, PNG, BMP, TIF, RAW and TGA files\n");
#line 114
  fprintf(stdout, "    Binary data is written to the file (not ascii). If a PGX\n");
#line 115
  fprintf(stdout, "    filename is given, there will be as many output files as there are\n");
#line 116
  fprintf(stdout, "    components: an indice starting from 0 will then be appended to the\n");
#line 117
  fprintf(stdout, "    output filename, just before the \"pgx\" extension. If a PGM filename\n\220");
#line 118
  fprintf(stdout, "    is given and there are more than one component, only the first component\n");
#line 119
  fprintf(stdout, "    will be written to the file.\n");
#line 120
  fprintf(stdout, "  -r <reduce factor>\n");
#line 121
  fprintf(stdout, "    Set the number of highest resolution levels to be discarded. The\n");
#line 122
  fprintf(stdout, "    image resolution is effectively divided by 2 to the power of the\n");
#line 123
  fprintf(stdout, "    number of discarded levels. The reduce factor is limited by the\n");
#line 124
  fprintf(stdout, "    smallest total number of decomposition levels among tiles.\n");
#line 125
  fprintf(stdout, "  -l <number of quality layers to decode>\n");
#line 126
  fprintf(stdout, "    Set the maximum number of quality layers to decode. If there are\n");
#line 127
  fprintf(stdout, "    less quality layers than the specified number, all the quality layers\n");
#line 128
  fprintf(stdout, "    are decoded.\n");
#line 129
  fprintf(stdout, "  -x  \n");
#line 130
  fprintf(stdout, "    Create an index file *.Idx (-x index_name.Idx) \n");
#line 131
  fprintf(stdout, "\n");
#line 142
  fprintf(stdout, "\n");
  }
  return;
}
}
#line 147 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int get_num_images(char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int num_images ;
  DIR *__cil_tmp5 ;
  struct dirent *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 150
  num_images = 0;
#line 154
  dir = opendir((char const   *)imgdirpath);
  }
#line 155
  if (! dir) {
    {
#line 156
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 157
    return (0);
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 160
    content = readdir(dir);
    }
#line 160
    if (! (content != (void *)0)) {
#line 160
      goto while_break;
    }
    {
#line 161
    __cil_tmp8 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 161
    __cil_tmp7 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 161
    if (__cil_tmp7 == 0) {
#line 162
      goto while_continue;
    } else
#line 161
    if (__cil_tmp8 == 0) {
#line 162
      goto while_continue;
    }
#line 163
    num_images ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (num_images);
}
}
#line 168 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int load_images(dircnt_t *dirptr , char *imgdirpath ) 
{ 
  DIR *dir ;
  struct dirent *content ;
  int i ;
  DIR *__cil_tmp6 ;
  struct dirent *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 171
  i = 0;
#line 175
  dir = opendir((char const   *)imgdirpath);
  }
#line 176
  if (! dir) {
    {
#line 177
    fprintf(stderr, "Could not open Folder %s\n", imgdirpath);
    }
#line 178
    return (1);
  } else {
    {
#line 180
    fprintf(stderr, "Folder opened successfully\n");
    }
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 183
    content = readdir(dir);
    }
#line 183
    if (! (content != (void *)0)) {
#line 183
      goto while_break;
    }
    {
#line 184
    __cil_tmp9 = strcmp("..", (char const   *)((char *)content->d_name));
    }
    {
#line 184
    __cil_tmp8 = strcmp(".", (char const   *)((char *)content->d_name));
    }
#line 184
    if (__cil_tmp8 == 0) {
#line 185
      goto while_continue;
    } else
#line 184
    if (__cil_tmp9 == 0) {
#line 185
      goto while_continue;
    }
    {
#line 187
    strcpy(*(dirptr->filename + i), (char const   *)((char *)content->d_name));
#line 188
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return (0);
}
}
#line 193 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int get_file_format(char *filename ) 
{ 
  unsigned int i ;
  static char const   *extension[14] ;
  static int const   format[14] ;
  char *ext ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 195
  extension[0] = "pgx";
#line 195
  extension[1] = "pnm";
#line 195
  extension[2] = "pgm";
#line 195
  extension[3] = "ppm";
#line 195
  extension[4] = "bmpD\262U";
#line 195
  extension[5] = "tif";
#line 195
  extension[6] = "rawD\262U";
#line 195
  extension[7] = "tga";
#line 195
  extension[8] = "pngD\262U";
#line 195
  extension[9] = "j2kD\262U";
#line 195
  extension[10] = "jp2D\262U";
#line 195
  extension[11] = "jptD\262U";
#line 195
  extension[12] = "j2cD\262U";
#line 195
  extension[13] = "jpcD\262U";
#line 196
  format[0] = 11;
#line 196
  format[1] = 10;
#line 196
  format[2] = 10;
#line 196
  format[3] = 10;
#line 196
  format[4] = 12;
#line 196
  format[5] = 14;
#line 196
  format[6] = 15;
#line 196
  format[7] = 16;
#line 196
  format[8] = 17;
#line 196
  format[9] = 0;
#line 196
  format[10] = 1;
#line 196
  format[11] = 2;
#line 196
  format[12] = 0;
#line 196
  format[13] = 0;
#line 197
  __cil_tmp6 = strrchr((char const   *)filename, '.');
#line 197
  ext = __cil_tmp6;
  }
#line 198
  if (ext == (void *)0) {
#line 199
    return (- 1);
  }
#line 200
  ext ++;
#line 201
  if (ext) {
#line 202
    i = (unsigned int )0;
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;
#line 202
      if (! ((unsigned long )i < sizeof(format) / sizeof(*((int const   *)format)))) {
#line 202
        goto while_break;
      }
      {
#line 203
      __cil_tmp8 = strncasecmp((char const   *)ext, extension[i], (unsigned long )3);
      }
#line 203
      if (__cil_tmp8 == 0) {
#line 204
        return (format[i]);
      }
#line 202
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 209
  return (- 1);
}
}
#line 212 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
char get_next_file(int imageno , dircnt_t *dirptr , img_fol_t *img_fol , opj_dparameters_t *parameters ) 
{ 
  char image_filename[4096] ;
  char infilename[4096] ;
  char outfilename[4096] ;
  char temp_ofname[4096] ;
  char *temp_p ;
  char temp1[4096] ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 214
  temp1 = "\002";
#line 216
  strcpy((char *)image_filename, (char const   *)*(dirptr->filename + imageno));
#line 217
  fprintf(stderr, "File Number %d \"%s\"\n", imageno, (char *)image_filename);
#line 218
  parameters->decod_format = get_file_format((char *)image_filename);
  }
#line 219
  if (parameters->decod_format == -1) {
#line 220
    return ((char )1);
  }
  {
#line 221
  sprintf((char *)infilename, "%s/%sU", img_fol->imgdirpath, (char *)image_filename);
#line 222
  strncpy((char *)parameters->infile, (char const   *)((char *)infilename), sizeof(infilename));
#line 225
  __cil_tmp12 = strtok((char *)image_filename, ".\322\265D\262U");
#line 225
  strcpy((char *)temp_ofname, (char const   *)__cil_tmp12);
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    temp_p = strtok((char *)((void *)0), ".");
    }
#line 226
    if (! (temp_p != (void *)0)) {
#line 226
      goto while_break;
    }
    {
#line 227
    strcat((char *)temp_ofname, (char const   *)((char *)temp1));
#line 228
    sprintf((char *)temp1, ".%sD\262U", temp_p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  if ((int )img_fol->set_out_format == 1) {
    {
#line 231
    sprintf((char *)outfilename, "%s/%s.%s\230\001", img_fol->imgdirpath, (char *)temp_ofname,
            img_fol->out_format);
#line 232
    strncpy((char *)parameters->outfile, (char const   *)((char *)outfilename), sizeof(outfilename));
    }
  }
#line 234
  return ((char )0);
}
}
#line 238 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int parse_cmdline_decoder(int argc , char **argv , opj_dparameters_t *parameters ,
                          img_fol_t *img_fol , char *indexfilename ) 
{ 
  int totlen ;
  int c ;
  opj_option_t long_option[2] ;
  char const   optlist[12] ;
  int __cil_tmp10 ;
  char *infile ;
  int __cil_tmp12 ;
  char *outfile ;
  int __cil_tmp14 ;
  char outformat[50] ;
  char *of ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  char *index___16 ;

  {
#line 241
  long_option[0].name = "ImgDir";
#line 241
  long_option[0].has_arg = 1;
#line 241
  long_option[0].flag = (int *)((void *)0);
#line 241
  long_option[0].val = 'y';
#line 241
  long_option[1].name = "OutFor";
#line 241
  long_option[1].has_arg = 1;
#line 241
  long_option[1].flag = (int *)((void *)0);
#line 241
  long_option[1].val = 'O';
#line 246
  optlist = "i:o:r:l:x:h";
#line 254
  totlen = (int )sizeof(long_option);
#line 255
  img_fol->set_out_format = (char )0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 257
    c = opj_getopt_long(argc, (char * const  [])argv, (char const   *)optlist, (opj_option_t *)long_option,
                        totlen);
    }
#line 258
    if (c == -1) {
#line 259
      goto while_break;
    }
    {
#line 261
    if (c == 'i') {
#line 261
      goto case_105;
    }
#line 268
    if (c == 2) {
#line 268
      goto case_2;
    }
#line 268
    if (c == 1) {
#line 268
      goto case_2;
    }
#line 268
    if (c == 0) {
#line 268
      goto case_2;
    }
#line 282
    if (c == 'o') {
#line 282
      goto case_111;
    }
#line 293
    if (c == 17) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 16) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 15) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 14) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 12) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 10) {
#line 293
      goto case_17;
    }
#line 293
    if (c == 11) {
#line 293
      goto case_17;
    }
#line 305
    if (c == 'O') {
#line 305
      goto case_79;
    }
#line 313
    if (c == 11) {
#line 313
      goto case_11___0;
    }
#line 316
    if (c == 10) {
#line 316
      goto case_10___0;
    }
#line 319
    if (c == 12) {
#line 319
      goto case_12___0;
    }
#line 322
    if (c == 14) {
#line 322
      goto case_14___0;
    }
#line 325
    if (c == 15) {
#line 325
      goto case_15___0;
    }
#line 328
    if (c == 16) {
#line 328
      goto case_16___0;
    }
#line 331
    if (c == 17) {
#line 331
      goto case_17___0;
    }
#line 345
    if (c == 'r') {
#line 345
      goto case_114;
    }
#line 354
    if (c == 'l') {
#line 354
      goto case_108;
    }
#line 362
    if (c == 'h') {
#line 362
      goto case_104;
    }
#line 368
    if (c == 'y') {
#line 368
      goto case_121;
    }
#line 376
    if (c == 'x') {
#line 376
      goto case_120;
    }
#line 456
    goto switch_default___2;
    case_105: /* CIL Label */ 
    {
#line 263
    infile = opj_optarg;
#line 264
    parameters->decod_format = get_file_format(infile);
    }
    {
#line 268
    if (parameters->decod_format == 2) {
#line 268
      goto case_2;
    }
#line 268
    if (parameters->decod_format == 1) {
#line 268
      goto case_2;
    }
#line 268
    if (parameters->decod_format == 0) {
#line 268
      goto case_2;
    }
#line 270
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 269
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 271
    fprintf(stderr, "!! Unrecognized format for infile : %s [accept only *.j2k, *.jp2, *.jpc or *.jpt] !!\n\n",
            infile);
    }
#line 274
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 276
    strncpy((char *)parameters->infile, (char const   *)infile, sizeof(parameters->infile) - 1UL);
    }
#line 278
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 284
    outfile = opj_optarg;
#line 285
    parameters->cod_format = get_file_format(outfile);
    }
    {
#line 293
    if (parameters->cod_format == 17) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 16) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 15) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 14) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 12) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 10) {
#line 293
      goto case_17;
    }
#line 293
    if (parameters->cod_format == 11) {
#line 293
      goto case_17;
    }
#line 295
    goto switch_default___0;
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 294
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 296
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            outfile);
    }
#line 297
    return (1);
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 299
    strncpy((char *)parameters->outfile, (char const   *)outfile, sizeof(parameters->outfile) - 1UL);
    }
#line 301
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 308
    of = opj_optarg;
#line 309
    sprintf((char *)outformat, ".%s", of);
#line 310
    img_fol->set_out_format = (char )1;
#line 311
    parameters->cod_format = get_file_format((char *)outformat);
    }
    {
#line 313
    if (parameters->cod_format == 11) {
#line 313
      goto case_11___0;
    }
#line 316
    if (parameters->cod_format == 10) {
#line 316
      goto case_10___0;
    }
#line 319
    if (parameters->cod_format == 12) {
#line 319
      goto case_12___0;
    }
#line 322
    if (parameters->cod_format == 14) {
#line 322
      goto case_14___0;
    }
#line 325
    if (parameters->cod_format == 15) {
#line 325
      goto case_15___0;
    }
#line 328
    if (parameters->cod_format == 16) {
#line 328
      goto case_16___0;
    }
#line 331
    if (parameters->cod_format == 17) {
#line 331
      goto case_17___0;
    }
#line 334
    goto switch_default___1;
    case_11___0: /* CIL Label */ 
#line 314
    img_fol->out_format = "pgx";
#line 315
    goto switch_break___2;
    case_10___0: /* CIL Label */ 
#line 317
    img_fol->out_format = "ppm";
#line 318
    goto switch_break___2;
    case_12___0: /* CIL Label */ 
#line 320
    img_fol->out_format = "bmp";
#line 321
    goto switch_break___2;
    case_14___0: /* CIL Label */ 
#line 323
    img_fol->out_format = "tif";
#line 324
    goto switch_break___2;
    case_15___0: /* CIL Label */ 
#line 326
    img_fol->out_format = "raw";
#line 327
    goto switch_break___2;
    case_16___0: /* CIL Label */ 
#line 329
    img_fol->out_format = "raw";
#line 330
    goto switch_break___2;
    case_17___0: /* CIL Label */ 
#line 332
    img_fol->out_format = "png";
#line 333
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 335
    fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n",
            (char *)outformat);
    }
#line 336
    return (1);
#line 337
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 340
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 347
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_reduce);
    }
#line 349
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 356
    sscanf((char const   *)opj_optarg, "%d", & parameters->cp_layer);
    }
#line 358
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 363
    decode_help_display();
    }
#line 364
    return (1);
    case_121: /* CIL Label */ 
    {
#line 370
    __cil_tmp18 = strlen((char const   *)opj_optarg);
#line 370
    __cil_tmp19 = malloc(__cil_tmp18 + 1UL);
#line 370
    img_fol->imgdirpath = (char *)__cil_tmp19;
#line 371
    strcpy(img_fol->imgdirpath, (char const   *)opj_optarg);
#line 372
    img_fol->set_imgdir = (char )1;
    }
#line 374
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 378
    index___16 = opj_optarg;
#line 379
    strncpy(indexfilename, (char const   *)index___16, (unsigned long )4096);
    }
#line 381
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 457
    fprintf(stderr, "WARNING -> this option is not valid \"-%c %s\"\n", c, opj_optarg);
    }
#line 458
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 256
    if (! (c != -1)) {
#line 256
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  if ((int )img_fol->set_imgdir == 1) {
#line 464
    if (! ((int )parameters->infile[0] == 0)) {
      {
#line 465
      fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
      }
#line 466
      return (1);
    }
#line 468
    if ((int )img_fol->set_out_format == 0) {
      {
#line 469
      fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
#line 470
      fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
      }
#line 471
      return (1);
    }
#line 473
    if (! ((int )parameters->outfile[0] == 0)) {
      {
#line 474
      fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
      }
#line 475
      return (1);
    }
  } else
#line 478
  if ((int )parameters->infile[0] == 0) {
    {
    {
#line 479
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
    }
    {
#line 480
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 481
    return (1);
  } else
#line 478
  if ((int )parameters->outfile[0] == 0) {
    {
    {
#line 479
    fprintf(stderr, "Example: %s -i image.j2k -o image.pgm\n", *(argv + 0));
    }
    {
#line 480
    fprintf(stderr, "    Try: %s -h\n", *(argv + 0));
    }
    }
#line 481
    return (1);
  }
#line 485
  return (0);
}
}
#line 493 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
void error_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 494
  stream = (FILE *)client_data;
#line 495
  fprintf(stream, "[ERROR] %s", msg);
  }
  return;
}
}
#line 500 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
void warning_callback(char const   *msg , void *client_data ) 
{ 
  FILE *stream ;

  {
  {
#line 501
  stream = (FILE *)client_data;
#line 502
  fprintf(stream, "[WARNING] %s\262U", msg);
  }
  return;
}
}
#line 507 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
void info_callback(char const   *msg , void *client_data ) 
{ 


  {
  {
#line 509
  fprintf(stdout, "[INFO] %s\302\266D\262U", msg);
  }
  return;
}
}
#line 514 "/doner/openjpeg/openjpeg-c02f145/applications/codec/j2k_to_image.c"
int main(int argc , char **argv ) 
{ 
  opj_dparameters_t parameters ;
  img_fol_t img_fol ;
  opj_event_mgr_t event_mgr ;
  opj_image_t *image ;
  FILE *fsrc ;
  unsigned char *src ;
  int file_length ;
  int num_images ;
  int i ;
  int imageno ;
  dircnt_t *dirptr ;
  opj_dinfo_t *dinfo ;
  opj_cio_t *cio ;
  opj_codestream_info_t cstr_info ;
  char indexfilename[4096] ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  char __cil_tmp25 ;
  FILE *__cil_tmp26 ;
  long __cil_tmp27 ;
  void *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  opj_dinfo_t *__cil_tmp30 ;
  opj_cio_t *__cil_tmp31 ;
  opj_image_t *__cil_tmp32 ;
  opj_image_t *__cil_tmp33 ;
  opj_bool bSuccess ;
  int __cil_tmp35 ;
  opj_dinfo_t *__cil_tmp36 ;
  opj_cio_t *__cil_tmp37 ;
  opj_image_t *__cil_tmp38 ;
  opj_image_t *__cil_tmp39 ;
  opj_bool bSuccess___0 ;
  int __cil_tmp41 ;
  opj_dinfo_t *__cil_tmp42 ;
  opj_cio_t *__cil_tmp43 ;
  opj_image_t *__cil_tmp44 ;
  opj_image_t *__cil_tmp45 ;
  opj_bool bSuccess___1 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;

  {
  {
#line 518
  image = (opj_image_t *)((void *)0);
#line 519
  fsrc = (FILE *)((void *)0);
#line 520
  src = (unsigned char *)((void *)0);
#line 524
  dirptr = (dircnt_t *)((void *)0);
#line 525
  dinfo = (opj_dinfo_t *)((void *)0);
#line 526
  cio = (opj_cio_t *)((void *)0);
#line 531
  memset(& event_mgr, 0, sizeof(opj_event_mgr_t ));
#line 532
  event_mgr.error_handler = & error_callback;
#line 533
  event_mgr.warning_handler = & warning_callback;
#line 534
  event_mgr.info_handler = & info_callback;
#line 537
  opj_set_default_decoder_parameters(& parameters);
#line 540
  *((char *)indexfilename) = (char )0;
#line 541
  memset(& img_fol, 0, sizeof(img_fol_t ));
#line 544
  __cil_tmp18 = parse_cmdline_decoder(argc, argv, & parameters, & img_fol, (char *)indexfilename);
  }
#line 544
  if (__cil_tmp18 == 1) {
#line 545
    return (1);
  }
#line 549
  if ((int )img_fol.set_imgdir == 1) {
    {
#line 550
    num_images = get_num_images(img_fol.imgdirpath);
#line 552
    __cil_tmp20 = malloc(sizeof(dircnt_t ));
#line 552
    dirptr = (dircnt_t *)__cil_tmp20;
    }
#line 553
    if (dirptr) {
      {
#line 554
      __cil_tmp21 = malloc((unsigned long )(num_images * 4096) * sizeof(char ));
#line 554
      dirptr->filename_buf = (char *)__cil_tmp21;
#line 555
      __cil_tmp22 = malloc((unsigned long )num_images * sizeof(char *));
#line 555
      dirptr->filename = (char **)__cil_tmp22;
      }
#line 557
      if (! dirptr->filename_buf) {
#line 558
        return (1);
      }
#line 560
      i = 0;
      {
#line 560
      while (1) {
        while_continue: /* CIL Label */ ;
#line 560
        if (! (i < num_images)) {
#line 560
          goto while_break;
        }
#line 561
        *(dirptr->filename + i) = dirptr->filename_buf + i * 4096;
#line 560
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 564
    __cil_tmp24 = load_images(dirptr, img_fol.imgdirpath);
    }
#line 564
    if (__cil_tmp24 == 1) {
#line 565
      return (1);
    }
#line 567
    if (num_images == 0) {
      {
#line 568
      fprintf(stdout, "Folder is empty\n\220");
      }
#line 569
      return (1);
    }
  } else {
#line 572
    num_images = 1;
  }
#line 576
  imageno = 0;
  {
#line 576
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 576
    if (! (imageno < num_images)) {
#line 576
      goto while_break___0;
    }
    {
#line 577
    image = (opj_image_t *)((void *)0);
#line 578
    fprintf(stderr, "\n\027\267D\262U");
    }
#line 580
    if ((int )img_fol.set_imgdir == 1) {
      {
#line 581
      __cil_tmp25 = get_next_file(imageno, dirptr, & img_fol, & parameters);
      }
#line 581
      if (__cil_tmp25) {
        {
#line 582
        fprintf(stderr, "skipping file...\n");
        }
#line 583
        goto while_continue___0;
      }
    }
    {
#line 589
    fsrc = fopen((char const   *)((char *)parameters.infile), "rb");
    }
#line 590
    if (! fsrc) {
      {
#line 591
      fprintf(stderr, "ERROR -> failed to open %s for reading\n", (char *)parameters.infile);
      }
#line 592
      return (1);
    }
    {
#line 594
    fseek(fsrc, (long )0, 2);
#line 595
    __cil_tmp27 = ftell(fsrc);
#line 595
    file_length = (int )__cil_tmp27;
#line 596
    fseek(fsrc, (long )0, 0);
#line 597
    __cil_tmp28 = malloc((unsigned long )file_length);
#line 597
    src = (unsigned char *)__cil_tmp28;
#line 598
    __cil_tmp29 = fread(src, (unsigned long )1, (unsigned long )file_length, fsrc);
    }
#line 598
    if (__cil_tmp29 != (size_t )file_length) {
      {
#line 600
      free(src);
#line 601
      fclose(fsrc);
#line 602
      fprintf(stderr, "\nERROR: fread return a number of element different from the expected.\n");
      }
#line 603
      return (1);
    }
    {
#line 605
    fclose(fsrc);
    }
    {
#line 611
    if (parameters.decod_format == 0) {
#line 611
      goto case_0;
    }
#line 654
    if (parameters.decod_format == 1) {
#line 654
      goto case_1;
    }
#line 697
    if (parameters.decod_format == 2) {
#line 697
      goto case_2;
    }
#line 740
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 616
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )0);
#line 619
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 622
    opj_setup_decoder(dinfo, & parameters);
#line 625
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 628
    if (*((char *)indexfilename)) {
      {
#line 629
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 631
      image = opj_decode(dinfo, cio);
      }
    }
#line 632
    if (! image) {
      {
#line 633
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 634
      opj_destroy_decompress(dinfo);
#line 635
      opj_cio_close(cio);
#line 636
      free(src);
      }
#line 637
      return (1);
    }
    {
#line 641
    opj_cio_close(cio);
    }
#line 644
    if (*((char *)indexfilename)) {
      {
#line 646
      bSuccess = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 647
      if (bSuccess) {
        {
#line 648
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 652
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 659
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )2);
#line 662
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 665
    opj_setup_decoder(dinfo, & parameters);
#line 668
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 671
    if (*((char *)indexfilename)) {
      {
#line 672
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 674
      image = opj_decode(dinfo, cio);
      }
    }
#line 675
    if (! image) {
      {
#line 676
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 677
      opj_destroy_decompress(dinfo);
#line 678
      opj_cio_close(cio);
#line 679
      free(src);
      }
#line 680
      return (1);
    }
    {
#line 684
    opj_cio_close(cio);
    }
#line 687
    if (*((char *)indexfilename)) {
      {
#line 689
      bSuccess___0 = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 690
      if (bSuccess___0) {
        {
#line 691
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 695
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 702
    dinfo = opj_create_decompress((OPJ_CODEC_FORMAT )1);
#line 705
    opj_set_event_mgr((opj_common_ptr )dinfo, & event_mgr, stderr);
#line 708
    opj_setup_decoder(dinfo, & parameters);
#line 711
    cio = opj_cio_open((opj_common_ptr )dinfo, src, file_length);
    }
#line 714
    if (*((char *)indexfilename)) {
      {
#line 715
      image = opj_decode_with_info(dinfo, cio, & cstr_info);
      }
    } else {
      {
#line 717
      image = opj_decode(dinfo, cio);
      }
    }
#line 718
    if (! image) {
      {
#line 719
      fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
#line 720
      opj_destroy_decompress(dinfo);
#line 721
      opj_cio_close(cio);
#line 722
      free(src);
      }
#line 723
      return (1);
    }
    {
#line 727
    opj_cio_close(cio);
    }
#line 730
    if (*((char *)indexfilename)) {
      {
#line 732
      bSuccess___1 = write_index_file(& cstr_info, (char *)indexfilename);
      }
#line 733
      if (bSuccess___1) {
        {
#line 734
        fprintf(stderr, "Failed to output index file\n");
        }
      }
    }
#line 738
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 741
    fprintf(stderr, "skipping file..\n\220");
    }
#line 742
    goto while_continue___0;
    switch_break: /* CIL Label */ ;
    }
    {
#line 746
    free(src);
#line 747
    src = (unsigned char *)((void *)0);
    }
#line 749
    if ((int )image->color_space == 3) {
      {
#line 751
      color_sycc_to_rgb(image);
      }
    }
#line 754
    if (image->icc_profile_buf) {
      {
#line 760
      free(image->icc_profile_buf);
#line 761
      image->icc_profile_buf = (unsigned char *)((void *)0);
#line 761
      image->icc_profile_len = 0;
      }
    }
    {
#line 767
    if (parameters.cod_format == 10) {
#line 767
      goto case_10;
    }
#line 776
    if (parameters.cod_format == 11) {
#line 776
      goto case_11;
    }
#line 785
    if (parameters.cod_format == 12) {
#line 785
      goto case_12;
    }
#line 803
    if (parameters.cod_format == 15) {
#line 803
      goto case_15;
    }
#line 812
    if (parameters.cod_format == 16) {
#line 812
      goto case_16;
    }
#line 833
    goto switch_default___0;
    case_10: /* CIL Label */ 
    {
#line 768
    __cil_tmp48 = imagetopnm(image, (char const   *)((char *)parameters.outfile));
    }
#line 768
    if (__cil_tmp48) {
      {
#line 769
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 772
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 774
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 777
    __cil_tmp49 = imagetopgx(image, (char const   *)((char *)parameters.outfile));
    }
#line 777
    if (__cil_tmp49) {
      {
#line 778
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 781
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 783
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 786
    __cil_tmp50 = imagetobmp(image, (char const   *)((char *)parameters.outfile));
    }
#line 786
    if (__cil_tmp50) {
      {
#line 787
      fprintf(stdout, "Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 790
      fprintf(stdout, "Generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 792
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 804
    __cil_tmp51 = imagetoraw(image, (char const   *)((char *)parameters.outfile));
    }
#line 804
    if (__cil_tmp51) {
      {
#line 805
      fprintf(stdout, "Error generating raw file. Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 808
      fprintf(stdout, "Successfully generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 810
    goto switch_break___0;
    case_16: /* CIL Label */ 
    {
#line 813
    __cil_tmp52 = imagetotga(image, (char const   *)((char *)parameters.outfile));
    }
#line 813
    if (__cil_tmp52) {
      {
#line 814
      fprintf(stdout, "Error generating tga file. Outfile %s not generated\n", (char *)parameters.outfile);
      }
    } else {
      {
#line 817
      fprintf(stdout, "Successfully generated Outfile %s\n", (char *)parameters.outfile);
      }
    }
#line 819
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 834
    fprintf(stderr, "Outfile %s not generated\n", (char *)parameters.outfile);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 838
    if (dinfo) {
      {
#line 839
      opj_destroy_decompress(dinfo);
      }
    }
#line 842
    if (*((char *)indexfilename)) {
      {
#line 843
      opj_destroy_cstr_info(& cstr_info);
      }
    }
    {
#line 845
    opj_image_destroy(image);
    }
#line 576
    imageno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 848
  return (0);
}
}
#line 43 "/doner/openjpeg/openjpeg-c02f145/applications/codec/index.c"
int write_index_file(opj_codestream_info_t *cstr_info , char *index___0 ) 
{ 
  int tileno ;
  int compno ;
  int layno ;
  int resno ;
  int precno ;
  int pack_nb ;
  int x ;
  int y ;
  FILE *stream ;
  double total_disto ;
  int tilepartno ;
  char disto_on ;
  char numpix_on ;
  FILE *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int start_pos ;
  int end_ph_pos ;
  int end_pos ;
  double disto ;
  int max_numdecompos ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int prec_max ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int prec_max___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int numprec ;
  int x0 ;
  double __cil_tmp40 ;
  int y0___17 ;
  double __cil_tmp42 ;
  int x1 ;
  int y1___18 ;
  int pcnx ;
  int pcx ;
  double __cil_tmp47 ;
  int pcy ;
  double __cil_tmp49 ;
  int precno_x ;
  double __cil_tmp51 ;
  int precno_y ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int x0___0 ;
  double __cil_tmp62 ;
  int y0___19 ;
  double __cil_tmp64 ;
  int x1___0 ;
  int y1___20 ;
  int max_numprec ;
  int numprec___0 ;
  int __cil_tmp69 ;
  int numprec___1 ;
  int pcnx___0 ;
  int pcx___0 ;
  double __cil_tmp73 ;
  int pcy___0 ;
  double __cil_tmp75 ;
  int precno_x___0 ;
  double __cil_tmp77 ;
  int precno_y___0 ;
  double __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int max_numprec___0 ;
  int numprec___2 ;
  int __cil_tmp89 ;
  int x0___1 ;
  double __cil_tmp91 ;
  int y0___21 ;
  double __cil_tmp93 ;
  int x1___1 ;
  int y1___22 ;
  int numprec___3 ;
  int pcnx___1 ;
  int pcx___1 ;
  double __cil_tmp99 ;
  int pcy___1 ;
  double __cil_tmp101 ;
  int precno_x___1 ;
  double __cil_tmp103 ;
  int precno_y___1 ;
  double __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;

  {
#line 45
  stream = (FILE *)((void *)0);
#line 46
  total_disto = (double )0;
#line 57
  if (! cstr_info) {
#line 58
    return (1);
  }
  {
#line 60
  stream = fopen((char const   *)index___0, "w");
  }
#line 61
  if (! stream) {
    {
#line 62
    fprintf(stderr, "failed to open index file [%s] for writing\n", index___0);
    }
#line 63
    return (1);
  }
#line 66
  if ((cstr_info->tile + 0)->distotile) {
#line 67
    disto_on = (char )1;
  } else {
#line 69
    disto_on = (char )0;
  }
#line 71
  if ((cstr_info->tile + 0)->numpix) {
#line 72
    numpix_on = (char )1;
  } else {
#line 74
    numpix_on = (char )0;
  }
  {
#line 76
  fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
#line 77
  fprintf(stream, "%d\n", (int )cstr_info->prog);
#line 78
  fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
#line 79
  fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
#line 80
  fprintf(stream, "%d\n", cstr_info->numcomps);
#line 81
  fprintf(stream, "%d\n", cstr_info->numlayers);
#line 82
  fprintf(stream, "%d\n", *(cstr_info->numdecompos + 0));
#line 84
  resno = *(cstr_info->numdecompos + 0);
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (resno >= 0)) {
#line 84
      goto while_break;
    }
    {
#line 85
    fprintf(stream, "[%d,%d] \251", 1 << (cstr_info->tile + 0)->pdx[resno], 1 << (cstr_info->tile + 0)->pdx[resno]);
    }
#line 84
    __cil_tmp17 = resno;
#line 84
    resno --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  fprintf(stream, "\n");
#line 91
  fprintf(stream, "%d\n", cstr_info->main_head_start);
#line 93
  fprintf(stream, "%d\n", cstr_info->main_head_end);
#line 94
  fprintf(stream, "%d\n", cstr_info->codestream_size);
#line 96
  fprintf(stream, "\nINFO ON TILES\n");
#line 97
  fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
  }
#line 98
  if (disto_on) {
    {
#line 99
    fprintf(stream, "         disto");
    }
  }
#line 100
  if (numpix_on) {
    {
#line 101
    fprintf(stream, "     nbpix");
    }
  }
#line 102
  if ((int )disto_on) {
#line 102
    if ((int )numpix_on) {
      {
#line 103
      fprintf(stream, "  disto/nbpix");
      }
    }
  }
  {
#line 104
  fprintf(stream, "\n");
#line 106
  tileno = 0;
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 106
      goto while_break___0;
    }
    {
#line 107
    fprintf(stream, "%4d %9d %9d %9d %9d", (cstr_info->tile + tileno)->tileno, (cstr_info->tile + tileno)->start_pos,
            (cstr_info->tile + tileno)->end_header, (cstr_info->tile + tileno)->end_pos,
            (cstr_info->tile + tileno)->num_tps);
    }
#line 113
    if (disto_on) {
      {
#line 114
      fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile);
      }
    }
#line 115
    if (numpix_on) {
      {
#line 116
      fprintf(stream, " %9d", (cstr_info->tile + tileno)->numpix);
      }
    }
#line 117
    if ((int )disto_on) {
#line 117
      if ((int )numpix_on) {
        {
#line 118
        fprintf(stream, " %9e", (cstr_info->tile + tileno)->distotile / (double )(cstr_info->tile + tileno)->numpix);
        }
      }
    }
    {
#line 119
    fprintf(stream, "\n");
    }
#line 106
    tileno ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  tileno = 0;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 122
    if (! (tileno < cstr_info->tw * cstr_info->th)) {
#line 122
      goto while_break___1;
    }
#line 124
    disto = (double )0;
#line 125
    max_numdecompos = 0;
#line 126
    pack_nb = 0;
#line 128
    compno = 0;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (! (compno < cstr_info->numcomps)) {
#line 128
        goto while_break___2;
      }
#line 129
      if (max_numdecompos < *(cstr_info->numdecompos + compno)) {
#line 130
        max_numdecompos = *(cstr_info->numdecompos + compno);
      }
#line 128
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 133
    fprintf(stream, "\nTILE %d DETAILS\n", tileno);
#line 134
    fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
#line 135
    tilepartno = 0;
    }
    {
#line 135
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 135
      if (! (tilepartno < (cstr_info->tile + tileno)->num_tps)) {
#line 135
        goto while_break___3;
      }
      {
#line 136
      fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n\230\001", tilepartno, tileno,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pack, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_numpacks,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_start_pos, ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_header,
              ((cstr_info->tile + tileno)->tp + tilepartno)->tp_end_pos);
      }
#line 135
      tilepartno ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 145
    if ((int )cstr_info->prog == 0) {
      {
#line 146
      fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
      }
#line 147
      if (disto_on) {
        {
#line 148
        fprintf(stream, " disto");
        }
      }
      {
#line 149
      fprintf(stream, "\n");
#line 151
      layno = 0;
      }
      {
#line 151
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 151
        if (! (layno < cstr_info->numlayers)) {
#line 151
          goto while_break___4;
        }
#line 152
        resno = 0;
        {
#line 152
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 152
          if (! (resno < max_numdecompos + 1)) {
#line 152
            goto while_break___5;
          }
#line 153
          compno = 0;
          {
#line 153
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 153
            if (! (compno < cstr_info->numcomps)) {
#line 153
              goto while_break___6;
            }
#line 155
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 156
              goto while_break___6;
            }
#line 157
            prec_max = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 158
            precno = 0;
            {
#line 158
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 158
              if (! (precno < prec_max)) {
#line 158
                goto while_break___7;
              }
              {
#line 159
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 160
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 161
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 162
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 163
              fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d", pack_nb,
                      tileno, layno, resno, compno, precno, start_pos, end_ph_pos,
                      end_pos);
              }
#line 165
              if (disto_on) {
                {
#line 166
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 167
              fprintf(stream, "\n");
#line 168
              total_disto += disto;
#line 169
              pack_nb ++;
              }
#line 158
              precno ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 153
            compno ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 152
          resno ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 151
        layno ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 176
    if ((int )cstr_info->prog == 1) {
      {
#line 177
      fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
      }
#line 178
      if (disto_on) {
        {
#line 179
        fprintf(stream, " disto");
        }
      }
      {
#line 180
      fprintf(stream, "\n");
#line 182
      resno = 0;
      }
      {
#line 182
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 182
        if (! (resno < max_numdecompos + 1)) {
#line 182
          goto while_break___8;
        }
#line 183
        layno = 0;
        {
#line 183
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 183
          if (! (layno < cstr_info->numlayers)) {
#line 183
            goto while_break___9;
          }
#line 184
          compno = 0;
          {
#line 184
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 184
            if (! (compno < cstr_info->numcomps)) {
#line 184
              goto while_break___10;
            }
#line 186
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 187
              goto while_break___10;
            }
#line 188
            prec_max___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 189
            precno = 0;
            {
#line 189
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 189
              if (! (precno < prec_max___0)) {
#line 189
                goto while_break___11;
              }
              {
#line 190
              start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 191
              end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 192
              end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 193
              disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 194
              fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d", pack_nb, tileno,
                      resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
              }
#line 196
              if (disto_on) {
                {
#line 197
                fprintf(stream, " %8e", disto);
                }
              }
              {
#line 198
              fprintf(stream, "\n");
#line 199
              total_disto += disto;
#line 200
              pack_nb ++;
              }
#line 189
              precno ++;
            }
            while_break___11: /* CIL Label */ ;
            }
#line 184
            compno ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 183
          layno ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 182
        resno ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 207
    if ((int )cstr_info->prog == 2) {
      {
#line 209
      fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos");
      }
#line 210
      if (disto_on) {
        {
#line 211
        fprintf(stream, " disto");
        }
      }
      {
#line 212
      fprintf(stream, "\n");
#line 214
      resno = 0;
      }
      {
#line 214
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 214
        if (! (resno < max_numdecompos + 1)) {
#line 214
          goto while_break___12;
        }
#line 215
        numprec = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 216
        precno = 0;
        {
#line 216
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 216
          if (! (precno < numprec)) {
#line 216
            goto while_break___13;
          }
          {
#line 218
          __cil_tmp40 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 218
          x0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp40 * cstr_info->tw) * cstr_info->tile_x;
#line 219
          __cil_tmp42 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 219
          y0___17 = cstr_info->tile_Ox + (int )__cil_tmp42 * cstr_info->tile_y;
#line 220
          x1 = x0 + cstr_info->tile_x;
#line 221
          y1___18 = y0___17 + cstr_info->tile_y;
#line 222
          compno = 0;
          }
          {
#line 222
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 222
            if (! (compno < cstr_info->numcomps)) {
#line 222
              goto while_break___14;
            }
            {
#line 223
            pcnx = (cstr_info->tile + tileno)->pw[resno];
#line 224
            __cil_tmp47 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 224
            pcx = (int )__cil_tmp47;
#line 225
            __cil_tmp49 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 225
            pcy = (int )__cil_tmp49;
#line 226
            __cil_tmp51 = floor((double )((float )precno / (float )pcnx));
#line 226
            precno_x = precno - (int )__cil_tmp51 * pcnx;
#line 227
            __cil_tmp53 = floor((double )((float )precno / (float )pcnx));
#line 227
            precno_y = (int )__cil_tmp53;
            }
#line 228
            if (resno > *(cstr_info->numdecompos + compno)) {
#line 229
              goto while_break___14;
            }
#line 230
            y = y0___17;
            {
#line 230
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 230
              if (! (y < y1___18)) {
#line 230
                goto while_break___15;
              }
#line 231
              if (precno_y * pcy == y) {
#line 232
                x = x0;
                {
#line 232
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 232
                  if (! (x < x1)) {
#line 232
                    goto while_break___16;
                  }
#line 233
                  if (precno_x * pcx == x) {
#line 234
                    layno = 0;
                    {
#line 234
                    while (1) {
                      while_continue___17: /* CIL Label */ ;
#line 234
                      if (! (layno < cstr_info->numlayers)) {
#line 234
                        goto while_break___17;
                      }
                      {
#line 235
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 236
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 237
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 238
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 239
                      fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d", pack_nb,
                              tileno, resno, precno, compno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 241
                      if (disto_on) {
                        {
#line 242
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 243
                      fprintf(stream, "\n");
#line 244
                      total_disto += disto;
#line 245
                      pack_nb ++;
                      }
#line 234
                      layno ++;
                    }
                    while_break___17: /* CIL Label */ ;
                    }
                  }
#line 232
                  x ++;
                }
                while_break___16: /* CIL Label */ ;
                }
              }
#line 230
              y ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 222
            compno ++;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 216
          precno ++;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 214
        resno ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    } else
#line 256
    if ((int )cstr_info->prog == 3) {
      {
#line 258
      __cil_tmp62 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 258
      x0___0 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp62 * cstr_info->tw) * cstr_info->tile_x;
#line 259
      __cil_tmp64 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 259
      y0___19 = cstr_info->tile_Ox + (int )__cil_tmp64 * cstr_info->tile_y;
#line 260
      x1___0 = x0___0 + cstr_info->tile_x;
#line 261
      y1___20 = y0___19 + cstr_info->tile_y;
#line 264
      max_numprec = 0;
#line 265
      resno = 0;
      }
      {
#line 265
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 265
        if (! (resno < max_numdecompos + 1)) {
#line 265
          goto while_break___18;
        }
#line 266
        numprec___0 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 267
        if (numprec___0 > max_numprec) {
#line 268
          max_numprec = numprec___0;
        }
#line 265
        resno ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 271
      fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos");
      }
#line 272
      if (disto_on) {
        {
#line 273
        fprintf(stream, " disto");
        }
      }
      {
#line 274
      fprintf(stream, "\n");
#line 276
      precno = 0;
      }
      {
#line 276
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 276
        if (! (precno < max_numprec)) {
#line 276
          goto while_break___19;
        }
#line 277
        compno = 0;
        {
#line 277
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 277
          if (! (compno < cstr_info->numcomps)) {
#line 277
            goto while_break___20;
          }
#line 278
          resno = 0;
          {
#line 278
          while (1) {
            while_continue___21: /* CIL Label */ ;
#line 278
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 278
              goto while_break___21;
            }
            {
#line 279
            numprec___1 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 280
            pcnx___0 = (cstr_info->tile + tileno)->pw[resno];
#line 281
            __cil_tmp73 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 281
            pcx___0 = (int )__cil_tmp73;
#line 282
            __cil_tmp75 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 282
            pcy___0 = (int )__cil_tmp75;
#line 283
            __cil_tmp77 = floor((double )((float )precno / (float )pcnx___0));
#line 283
            precno_x___0 = precno - (int )__cil_tmp77 * pcnx___0;
#line 284
            __cil_tmp79 = floor((double )((float )precno / (float )pcnx___0));
#line 284
            precno_y___0 = (int )__cil_tmp79;
            }
#line 285
            if (precno >= numprec___1) {
#line 286
              goto while_continue___21;
            }
#line 287
            y = y0___19;
            {
#line 287
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 287
              if (! (y < y1___20)) {
#line 287
                goto while_break___22;
              }
#line 288
              if (precno_y___0 * pcy___0 == y) {
#line 289
                x = x0___0;
                {
#line 289
                while (1) {
                  while_continue___23: /* CIL Label */ ;
#line 289
                  if (! (x < x1___0)) {
#line 289
                    goto while_break___23;
                  }
#line 290
                  if (precno_x___0 * pcx___0 == x) {
#line 291
                    layno = 0;
                    {
#line 291
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 291
                      if (! (layno < cstr_info->numlayers)) {
#line 291
                        goto while_break___24;
                      }
                      {
#line 292
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 293
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 294
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 295
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 296
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, precno, compno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 298
                      if (disto_on) {
                        {
#line 299
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 300
                      fprintf(stream, "\n");
#line 301
                      total_disto += disto;
#line 302
                      pack_nb ++;
                      }
#line 291
                      layno ++;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                  }
#line 289
                  x ++;
                }
                while_break___23: /* CIL Label */ ;
                }
              }
#line 287
              y ++;
            }
            while_break___22: /* CIL Label */ ;
            }
#line 278
            resno ++;
          }
          while_break___21: /* CIL Label */ ;
          }
#line 277
          compno ++;
        }
        while_break___20: /* CIL Label */ ;
        }
#line 276
        precno ++;
      }
      while_break___19: /* CIL Label */ ;
      }
    } else {
#line 315
      max_numprec___0 = 0;
#line 316
      resno = 0;
      {
#line 316
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 316
        if (! (resno < max_numdecompos + 1)) {
#line 316
          goto while_break___25;
        }
#line 317
        numprec___2 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 318
        if (numprec___2 > max_numprec___0) {
#line 319
          max_numprec___0 = numprec___2;
        }
#line 316
        resno ++;
      }
      while_break___25: /* CIL Label */ ;
      }
      {
#line 322
      fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos");
      }
#line 323
      if (disto_on) {
        {
#line 324
        fprintf(stream, " disto");
        }
      }
      {
#line 325
      fprintf(stream, "\n");
#line 327
      compno = 0;
      }
      {
#line 327
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 327
        if (! (compno < cstr_info->numcomps)) {
#line 327
          goto while_break___26;
        }
        {
#line 329
        __cil_tmp91 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 329
        x0___1 = (cstr_info->tile_Ox + tileno) - ((int )__cil_tmp91 * cstr_info->tw) * cstr_info->tile_x;
#line 330
        __cil_tmp93 = floor((double )((float )tileno / (float )cstr_info->tw));
#line 330
        y0___21 = cstr_info->tile_Ox + (int )__cil_tmp93 * cstr_info->tile_y;
#line 331
        x1___1 = x0___1 + cstr_info->tile_x;
#line 332
        y1___22 = y0___21 + cstr_info->tile_y;
#line 334
        precno = 0;
        }
        {
#line 334
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 334
          if (! (precno < max_numprec___0)) {
#line 334
            goto while_break___27;
          }
#line 335
          resno = 0;
          {
#line 335
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 335
            if (! (resno < *(cstr_info->numdecompos + compno) + 1)) {
#line 335
              goto while_break___28;
            }
            {
#line 336
            numprec___3 = (cstr_info->tile + tileno)->pw[resno] * (cstr_info->tile + tileno)->ph[resno];
#line 337
            pcnx___1 = (cstr_info->tile + tileno)->pw[resno];
#line 338
            __cil_tmp99 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdx[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 338
            pcx___1 = (int )__cil_tmp99;
#line 339
            __cil_tmp101 = pow((double )2, (double )(((cstr_info->tile + tileno)->pdy[resno] + *(cstr_info->numdecompos + compno)) - resno));
#line 339
            pcy___1 = (int )__cil_tmp101;
#line 340
            __cil_tmp103 = floor((double )((float )precno / (float )pcnx___1));
#line 340
            precno_x___1 = precno - (int )__cil_tmp103 * pcnx___1;
#line 341
            __cil_tmp105 = floor((double )((float )precno / (float )pcnx___1));
#line 341
            precno_y___1 = (int )__cil_tmp105;
            }
#line 342
            if (precno >= numprec___3) {
#line 343
              goto while_continue___28;
            }
#line 345
            y = y0___21;
            {
#line 345
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 345
              if (! (y < y1___22)) {
#line 345
                goto while_break___29;
              }
#line 346
              if (precno_y___1 * pcy___1 == y) {
#line 347
                x = x0___1;
                {
#line 347
                while (1) {
                  while_continue___30: /* CIL Label */ ;
#line 347
                  if (! (x < x1___1)) {
#line 347
                    goto while_break___30;
                  }
#line 348
                  if (precno_x___1 * pcx___1 == x) {
#line 349
                    layno = 0;
                    {
#line 349
                    while (1) {
                      while_continue___31: /* CIL Label */ ;
#line 349
                      if (! (layno < cstr_info->numlayers)) {
#line 349
                        goto while_break___31;
                      }
                      {
#line 350
                      start_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->start_pos;
#line 351
                      end_ph_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_ph_pos;
#line 352
                      end_pos = ((cstr_info->tile + tileno)->packet + pack_nb)->end_pos;
#line 353
                      disto = ((cstr_info->tile + tileno)->packet + pack_nb)->disto;
#line 354
                      fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d", pack_nb,
                              tileno, compno, precno, resno, layno, start_pos, end_ph_pos,
                              end_pos);
                      }
#line 356
                      if (disto_on) {
                        {
#line 357
                        fprintf(stream, " %8e", disto);
                        }
                      }
                      {
#line 358
                      fprintf(stream, "\n");
#line 359
                      total_disto += disto;
#line 360
                      pack_nb ++;
                      }
#line 349
                      layno ++;
                    }
                    while_break___31: /* CIL Label */ ;
                    }
                  }
#line 347
                  x ++;
                }
                while_break___30: /* CIL Label */ ;
                }
              }
#line 345
              y ++;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 335
            resno ++;
          }
          while_break___28: /* CIL Label */ ;
          }
#line 334
          precno ++;
        }
        while_break___27: /* CIL Label */ ;
        }
#line 327
        compno ++;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 122
    tileno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 372
  if (disto_on) {
    {
#line 373
    fprintf(stream, "%8e\n", cstr_info->D_max);
#line 374
    fprintf(stream, "%.8e\n", total_disto);
    }
  }
#line 378
  if (cstr_info->marknum) {
    {
#line 379
    fprintf(stream, "\nMARKER LIST\n");
#line 380
    fprintf(stream, "%d\n", cstr_info->marknum);
#line 381
    fprintf(stream, "type\tstart_pos    length\n");
#line 382
    x = 0;
    }
    {
#line 382
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 382
      if (! (x < cstr_info->marknum)) {
#line 382
        goto while_break___32;
      }
      {
#line 383
      fprintf(stream, "%X\t%9d %9d\n", (int )(cstr_info->marker + x)->type, (cstr_info->marker + x)->pos,
              (cstr_info->marker + x)->len);
      }
#line 382
      x ++;
    }
    while_break___32: /* CIL Label */ ;
    }
  }
  {
#line 386
  fclose(stream);
#line 388
  fprintf(stderr, "Generated index file %s\n\230\001", index___0);
  }
#line 390
  return (0);
}
}
#line 56 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int int_floorlog2___20(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 58
  l = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (a > 1)) {
#line 58
      goto while_break;
    }
#line 59
    a >>= 1;
#line 58
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (l);
}
}
#line 95 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned short get_ushort(unsigned short val ) 
{ 


  {
#line 100
  return (val);
}
}
#line 107 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int tga_readheader(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                          unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char *tga ;
  unsigned char id_len ;
  unsigned char cmap_type ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_index ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short x_origin ;
  unsigned short y_origin ;
  unsigned short image_w ;
  unsigned short image_h ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned short __cil_tmp22 ;
  unsigned short __cil_tmp23 ;
  unsigned short __cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  unsigned short __cil_tmp26 ;
  unsigned short __cil_tmp27 ;
  unsigned char *id ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
#line 117
  if (! bits_per_pixel) {
#line 118
    return (0);
  } else
#line 117
  if (! width) {
#line 118
    return (0);
  } else
#line 117
  if (! height) {
#line 118
    return (0);
  } else
#line 117
  if (! flip_image) {
#line 118
    return (0);
  }
  {
#line 119
  __cil_tmp20 = malloc((unsigned long )18);
#line 119
  tga = (unsigned char *)__cil_tmp20;
#line 121
  __cil_tmp21 = fread(tga, (unsigned long )18, (unsigned long )1, fp);
  }
#line 121
  if (__cil_tmp21 != 1UL) {
    {
#line 123
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 124
    return (0);
  }
  {
#line 126
  id_len = (unsigned char )*(tga + 0);
#line 127
  cmap_type = (unsigned char )*(tga + 1);
#line 128
  image_type = (unsigned char )*(tga + 2);
#line 129
  cmap_index = get_ushort(*((unsigned short *)(tga + 3)));
#line 130
  cmap_len = get_ushort(*((unsigned short *)(tga + 5)));
#line 131
  cmap_entry_size = (unsigned short )((unsigned char )*(tga + 7));
#line 134
  x_origin = get_ushort(*((unsigned short *)(tga + 8)));
#line 135
  y_origin = get_ushort(*((unsigned short *)(tga + 10)));
#line 136
  image_w = get_ushort(*((unsigned short *)(tga + 12)));
#line 137
  image_h = get_ushort(*((unsigned short *)(tga + 14)));
#line 138
  pixel_depth = (unsigned char )*(tga + 16);
#line 139
  image_desc = (unsigned char )*(tga + 17);
#line 141
  free(tga);
#line 143
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 144
  *width = (unsigned int )image_w;
#line 145
  *height = (unsigned int )image_h;
  }
#line 148
  if (id_len) {
    {
#line 150
    __cil_tmp29 = malloc((unsigned long )id_len);
#line 150
    id = (unsigned char *)__cil_tmp29;
#line 151
    __cil_tmp30 = fread(id, (unsigned long )id_len, (unsigned long )1, fp);
    }
#line 151
    if (! __cil_tmp30) {
      {
#line 153
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 154
      free(id);
      }
#line 155
      return (0);
    }
    {
#line 157
    free(id);
    }
  }
#line 163
  if ((int )image_type > 8) {
    {
#line 165
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 166
    return (0);
  }
#line 169
  *flip_image = ! ((int )image_desc & 32);
#line 172
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 174
  if (palette_size > 0) {
    {
#line 176
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 177
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 179
  return (1);
}
}
#line 192 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int tga_writeheader(FILE *fp , int bits_per_pixel , int width , int height ,
                           opj_bool flip_image ) 
{ 
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned short us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 199
  if (! bits_per_pixel) {
#line 200
    return (0);
  } else
#line 199
  if (! width) {
#line 200
    return (0);
  } else
#line 199
  if (! height) {
#line 200
    return (0);
  }
#line 202
  pixel_depth = (unsigned char )0;
#line 204
  if (bits_per_pixel < 256) {
#line 205
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 207
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_headerU");
    }
#line 208
    return (0);
  }
  {
#line 210
  uc0 = (unsigned char )0;
#line 212
  __cil_tmp13 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 212
  if (__cil_tmp13 != 1UL) {
#line 212
    goto fails;
  }
  {
#line 213
  __cil_tmp14 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 213
  if (__cil_tmp14 != 1UL) {
#line 213
    goto fails;
  }
  {
#line 215
  image_type = (unsigned char )2;
#line 216
  __cil_tmp15 = fwrite(& image_type, (unsigned long )1, (unsigned long )1, fp);
  }
#line 216
  if (__cil_tmp15 != 1UL) {
#line 216
    goto fails;
  }
  {
#line 218
  us0 = (unsigned short )0;
#line 219
  __cil_tmp16 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 219
  if (__cil_tmp16 != 1UL) {
#line 219
    goto fails;
  }
  {
#line 220
  __cil_tmp17 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 220
  if (__cil_tmp17 != 1UL) {
#line 220
    goto fails;
  }
  {
#line 221
  __cil_tmp18 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 221
  if (__cil_tmp18 != 1UL) {
#line 221
    goto fails;
  }
  {
#line 223
  __cil_tmp19 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 223
  if (__cil_tmp19 != 1UL) {
#line 223
    goto fails;
  }
  {
#line 224
  __cil_tmp20 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 224
  if (__cil_tmp20 != 1UL) {
#line 224
    goto fails;
  }
  {
#line 226
  image_w = (unsigned short )width;
#line 227
  image_h = (unsigned short )height;
#line 230
  __cil_tmp21 = fwrite(& image_w, (unsigned long )2, (unsigned long )1, fp);
  }
#line 230
  if (__cil_tmp21 != 1UL) {
#line 230
    goto fails;
  }
  {
#line 231
  __cil_tmp22 = fwrite(& image_h, (unsigned long )2, (unsigned long )1, fp);
  }
#line 231
  if (__cil_tmp22 != 1UL) {
#line 231
    goto fails;
  }
  {
#line 239
  __cil_tmp23 = fwrite(& pixel_depth, (unsigned long )1, (unsigned long )1, fp);
  }
#line 239
  if (__cil_tmp23 != 1UL) {
#line 239
    goto fails;
  }
#line 241
  image_desc = (unsigned char )8;
#line 243
  if (flip_image) {
#line 244
    image_desc |= 32;
  }
  {
#line 245
  __cil_tmp24 = fwrite(& image_desc, (unsigned long )1, (unsigned long )1, fp);
  }
#line 245
  if (__cil_tmp24 != 1UL) {
#line 245
    goto fails;
  }
#line 247
  return (1);
  fails: 
  {
#line 250
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 251
  return (0);
}
}
#line 254 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *tgatoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  opj_image_t *image ;
  unsigned int image_width ;
  unsigned int image_height ;
  unsigned int pixel_bit_depth ;
  unsigned int x ;
  unsigned int y ;
  int flip_image ;
  opj_image_cmptparm_t cmptparm[4] ;
  int numcomps ;
  OPJ_COLOR_SPACE color_space ;
  opj_bool mono ;
  opj_bool save_alpha ;
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  FILE *__cil_tmp19 ;
  int __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp23 ;
  opj_image_t *__cil_tmp24 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int index___23 ;
  unsigned char r ;
  unsigned char g ;
  unsigned char b ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  unsigned char r___0 ;
  unsigned char g___0 ;
  unsigned char b___0 ;
  unsigned char a ;
  unsigned long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;

  {
  {
#line 259
  flip_image = 0;
#line 268
  f = fopen(filename, "rb\340D\262U");
  }
#line 269
  if (! f) {
    {
#line 270
    fprintf(stderr, "Failed to open %s for reading !!\n\212\340D\262U", filename);
    }
#line 271
    return ((opj_image_t *)0);
  }
  {
#line 274
  __cil_tmp20 = tga_readheader(f, & pixel_bit_depth, & image_width, & image_height,
                               & flip_image);
  }
#line 274
  if (! __cil_tmp20) {
#line 275
    return ((opj_image_t *)((void *)0));
  }
#line 278
  if (! (pixel_bit_depth == 24U || pixel_bit_depth == 32U)) {
#line 279
    return ((opj_image_t *)((void *)0));
  }
  {
#line 282
  memset(& cmptparm[0], 0, 4UL * sizeof(opj_image_cmptparm_t ));
#line 284
  mono = pixel_bit_depth == 8U || pixel_bit_depth == 16U;
#line 285
  save_alpha = pixel_bit_depth == 16U || pixel_bit_depth == 32U;
  }
#line 287
  if (mono) {
#line 288
    color_space = (OPJ_COLOR_SPACE )2;
#line 289
    if (save_alpha) {
#line 289
      tmp = 2;
    } else {
#line 289
      tmp = 1;
    }
#line 289
    numcomps = tmp;
  } else {
#line 292
    if (save_alpha) {
#line 292
      tmp___0 = 4;
    } else {
#line 292
      tmp___0 = 3;
    }
#line 292
    numcomps = tmp___0;
#line 293
    color_space = (OPJ_COLOR_SPACE )1;
  }
#line 296
  subsampling_dx = parameters->subsampling_dx;
#line 297
  subsampling_dy = parameters->subsampling_dy;
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (i < numcomps)) {
#line 299
      goto while_break;
    }
#line 300
    cmptparm[i].prec = 8;
#line 301
    cmptparm[i].bpp = 8;
#line 302
    cmptparm[i].sgnd = 0;
#line 303
    cmptparm[i].dx = subsampling_dx;
#line 304
    cmptparm[i].dy = subsampling_dy;
#line 305
    cmptparm[i].w = (int )image_width;
#line 306
    cmptparm[i].h = (int )image_height;
#line 299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  image = opj_image_create(numcomps, & cmptparm[0], color_space);
  }
#line 312
  if (! image) {
#line 313
    return ((opj_image_t *)((void *)0));
  }
#line 316
  image->x0 = parameters->image_offset_x0;
#line 317
  image->y0 = parameters->image_offset_y0;
#line 318
  if (! image->x0) {
#line 318
    tmp___1 = (image_width - 1U) * (unsigned int )subsampling_dx + 1U;
  } else {
#line 318
    tmp___1 = ((unsigned int )image->x0 + (image_width - 1U) * (unsigned int )subsampling_dx) + 1U;
  }
#line 318
  image->x1 = (int )tmp___1;
#line 319
  if (! image->y0) {
#line 319
    tmp___2 = (image_height - 1U) * (unsigned int )subsampling_dy + 1U;
  } else {
#line 319
    tmp___2 = ((unsigned int )image->y0 + (image_height - 1U) * (unsigned int )subsampling_dy) + 1U;
  }
#line 319
  image->y1 = (int )tmp___2;
#line 322
  y = (unsigned int )0;
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 322
    if (! (y < image_height)) {
#line 322
      goto while_break___0;
    }
#line 326
    if (flip_image) {
#line 327
      index___23 = (int )(((image_height - y) - 1U) * image_width);
    } else {
#line 329
      index___23 = (int )(y * image_width);
    }
#line 331
    if (numcomps == 3) {
#line 333
      x = (unsigned int )0;
      {
#line 333
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 333
        if (! (x < image_width)) {
#line 333
          goto while_break___1;
        }
        {
#line 337
        __cil_tmp31 = fread(& b, (unsigned long )1, (unsigned long )1, f);
        }
#line 337
        if (! __cil_tmp31) {
          {
#line 339
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 340
          opj_image_destroy(image);
          }
#line 341
          return ((opj_image_t *)((void *)0));
        }
        {
#line 343
        __cil_tmp32 = fread(& g, (unsigned long )1, (unsigned long )1, f);
        }
#line 343
        if (! __cil_tmp32) {
          {
#line 345
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 346
          opj_image_destroy(image);
          }
#line 347
          return ((opj_image_t *)((void *)0));
        }
        {
#line 349
        __cil_tmp33 = fread(& r, (unsigned long )1, (unsigned long )1, f);
        }
#line 349
        if (! __cil_tmp33) {
          {
#line 351
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 352
          opj_image_destroy(image);
          }
#line 353
          return ((opj_image_t *)((void *)0));
        }
#line 356
        *((image->comps + 0)->data + index___23) = (int )r;
#line 357
        *((image->comps + 1)->data + index___23) = (int )g;
#line 358
        *((image->comps + 2)->data + index___23) = (int )b;
#line 359
        index___23 ++;
#line 333
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 362
    if (numcomps == 4) {
#line 364
      x = (unsigned int )0;
      {
#line 364
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 364
        if (! (x < image_width)) {
#line 364
          goto while_break___2;
        }
        {
#line 367
        __cil_tmp40 = fread(& b___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 367
        if (! __cil_tmp40) {
          {
#line 369
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 370
          opj_image_destroy(image);
          }
#line 371
          return ((opj_image_t *)((void *)0));
        }
        {
#line 373
        __cil_tmp41 = fread(& g___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 373
        if (! __cil_tmp41) {
          {
#line 375
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 376
          opj_image_destroy(image);
          }
#line 377
          return ((opj_image_t *)((void *)0));
        }
        {
#line 379
        __cil_tmp42 = fread(& r___0, (unsigned long )1, (unsigned long )1, f);
        }
#line 379
        if (! __cil_tmp42) {
          {
#line 381
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 382
          opj_image_destroy(image);
          }
#line 383
          return ((opj_image_t *)((void *)0));
        }
        {
#line 385
        __cil_tmp43 = fread(& a, (unsigned long )1, (unsigned long )1, f);
        }
#line 385
        if (! __cil_tmp43) {
          {
#line 387
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 388
          opj_image_destroy(image);
          }
#line 389
          return ((opj_image_t *)((void *)0));
        }
#line 392
        *((image->comps + 0)->data + index___23) = (int )r___0;
#line 393
        *((image->comps + 1)->data + index___23) = (int )g___0;
#line 394
        *((image->comps + 2)->data + index___23) = (int )b___0;
#line 395
        *((image->comps + 3)->data + index___23) = (int )a;
#line 396
        index___23 ++;
#line 364
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 400
      fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
      }
    }
#line 322
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 403
  return (image);
}
}
#line 406 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetotga(opj_image_t *image , char const   *outfile ) 
{ 
  int width ;
  int height ;
  int bpp ;
  int x ;
  int y ;
  opj_bool write_alpha ;
  int i ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  unsigned int alpha_channel ;
  float r ;
  float g ;
  float b ;
  float a ;
  unsigned char value ;
  float scale ;
  FILE *fdest ;
  size_t res ;
  FILE *__cil_tmp22 ;
  int __cil_tmp23 ;
  int tmp ;
  int __cil_tmp25 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int index___24 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
  {
#line 417
  fdest = fopen(outfile, "wb");
  }
#line 418
  if (! fdest) {
    {
#line 419
    fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
    }
#line 420
    return (1);
  }
#line 423
  i = 0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (i < image->numcomps - 1)) {
#line 423
      goto while_break;
    }
#line 424
    if ((image->comps + 0)->dx != (image->comps + (i + 1))->dx) {
      {
      {
      {
#line 427
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 428
      return (1);
    } else
#line 424
    if ((image->comps + 0)->dy != (image->comps + (i + 1))->dy) {
      {
      {
      {
#line 427
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 428
      return (1);
    } else
#line 424
    if ((image->comps + 0)->prec != (image->comps + (i + 1))->prec) {
      {
      {
      {
#line 427
      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
      }
      }
      }
#line 428
      return (1);
    }
#line 423
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  width = (image->comps + 0)->w;
#line 433
  height = (image->comps + 0)->h;
#line 436
  write_alpha = image->numcomps == 2 || image->numcomps == 4;
#line 439
  if (write_alpha) {
#line 439
    tmp = 32;
  } else {
#line 439
    tmp = 24;
  }
  {
#line 439
  bpp = tmp;
#line 440
  __cil_tmp25 = tga_writeheader(fdest, bpp, width, height, 1);
  }
#line 440
  if (! __cil_tmp25) {
#line 441
    return (1);
  }
#line 443
  alpha_channel = (unsigned int )(image->numcomps - 1);
#line 445
  scale = 255.f / (float )((1 << (image->comps + 0)->prec) - 1);
#line 447
  if ((image->comps + 0)->sgnd) {
#line 447
    tmp___0 = 1 << ((image->comps + 0)->prec - 1);
  } else {
#line 447
    tmp___0 = 0;
  }
#line 447
  adjustR = tmp___0;
#line 448
  if ((image->comps + 1)->sgnd) {
#line 448
    tmp___1 = 1 << ((image->comps + 1)->prec - 1);
  } else {
#line 448
    tmp___1 = 0;
  }
#line 448
  adjustG = tmp___1;
#line 449
  if ((image->comps + 2)->sgnd) {
#line 449
    tmp___2 = 1 << ((image->comps + 2)->prec - 1);
  } else {
#line 449
    tmp___2 = 0;
  }
#line 449
  adjustB = tmp___2;
#line 451
  y = 0;
  {
#line 451
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 451
    if (! (y < height)) {
#line 451
      goto while_break___0;
    }
#line 452
    index___24 = (unsigned int )(y * width);
#line 454
    x = 0;
    {
#line 454
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 454
      if (! (x < width)) {
#line 454
        goto while_break___1;
      }
#line 455
      r = (float )(*((image->comps + 0)->data + index___24) + adjustR);
#line 457
      if (image->numcomps > 2) {
#line 458
        g = (float )(*((image->comps + 1)->data + index___24) + adjustG);
#line 459
        b = (float )(*((image->comps + 2)->data + index___24) + adjustB);
      } else {
#line 462
        g = r;
#line 463
        b = r;
      }
      {
#line 467
      value = (unsigned char )(b * scale);
#line 468
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 469
      if (res < 1UL) {
        {
#line 470
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 471
        return (1);
      }
      {
#line 474
      value = (unsigned char )(g * scale);
#line 475
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 476
      if (res < 1UL) {
        {
#line 477
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 478
        return (1);
      }
      {
#line 481
      value = (unsigned char )(r * scale);
#line 482
      res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
      }
#line 483
      if (res < 1UL) {
        {
#line 484
        fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
        }
#line 485
        return (1);
      }
#line 488
      if (write_alpha) {
        {
#line 489
        a = (float )*((image->comps + alpha_channel)->data + index___24);
#line 490
        value = (unsigned char )(a * scale);
#line 491
        res = fwrite(& value, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 492
        if (res < 1UL) {
          {
#line 493
          fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
          }
#line 494
          return (1);
        }
      }
#line 454
      __cil_tmp35 = index___24;
#line 454
      index___24 ++;
#line 454
      __cil_tmp34 = x;
#line 454
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 451
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 500
  return (0);
}
}
#line 537 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *bmptoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  int i ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[3] ;
  opj_image_t *image ;
  FILE *IN ;
  BITMAPFILEHEADER_t File_h ;
  BITMAPINFOHEADER_t Info_h ;
  unsigned char *RGB ;
  unsigned char *table_R ;
  unsigned char *table_G ;
  unsigned char *table_B ;
  unsigned int j ;
  unsigned int PAD ;
  int x ;
  int y ;
  int index___25 ;
  int gray_scale ;
  int has_color ;
  DWORD W ;
  DWORD H ;
  FILE *__cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  opj_image_t *__cil_tmp84 ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  void *__cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned char *scanline ;
  unsigned char *pixel ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  void *__cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  unsigned int __cil_tmp101 ;
  DWORD __cil_tmp102 ;
  int tmp___2 ;
  int tmp___3 ;
  int __cil_tmp105 ;
  opj_image_t *__cil_tmp106 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp109 ;
  unsigned long __cil_tmp110 ;
  int __cil_tmp111 ;
  unsigned int __cil_tmp112 ;
  unsigned char pixel_index ;
  int __cil_tmp114 ;
  unsigned int __cil_tmp115 ;
  unsigned char *pix ;
  unsigned char *beyond ;
  int *gray ;
  int *red ;
  int *green ;
  int *blue ;
  unsigned int x___27 ;
  unsigned int y___28 ;
  unsigned int max ;
  int i___29 ;
  int c ;
  int c1 ;
  unsigned char uc ;
  void *__cil_tmp129 ;
  void *__cil_tmp130 ;
  void *__cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  int __cil_tmp134 ;
  unsigned int __cil_tmp135 ;
  int tmp___6 ;
  int tmp___7 ;
  int __cil_tmp138 ;
  opj_image_t *__cil_tmp139 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp142 ;
  int __cil_tmp143 ;
  int __cil_tmp144 ;
  int __cil_tmp145 ;
  unsigned int __cil_tmp146 ;
  unsigned char *__cil_tmp147 ;
  int __cil_tmp148 ;
  int __cil_tmp149 ;
  int __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  unsigned int __cil_tmp153 ;
  unsigned char *__cil_tmp154 ;
  unsigned int __cil_tmp155 ;
  unsigned char *__cil_tmp156 ;
  int *__cil_tmp157 ;
  unsigned int __cil_tmp158 ;
  unsigned char *__cil_tmp159 ;
  int *__cil_tmp160 ;
  int *__cil_tmp161 ;
  int *__cil_tmp162 ;

  {
  {
#line 539
  subsampling_dx = parameters->subsampling_dx;
#line 540
  subsampling_dy = parameters->subsampling_dy;
#line 545
  image = (opj_image_t *)((void *)0);
#line 552
  PAD = (unsigned int )0;
#line 555
  gray_scale = 1;
#line 559
  IN = fopen(filename, "rb\341D\262U");
  }
#line 560
  if (! IN) {
    {
#line 562
    fprintf(stderr, "Failed to open %s for reading !!\n\223\341D\262U", filename);
    }
#line 563
    return ((opj_image_t *)((void *)0));
  }
  {
#line 566
  __cil_tmp29 = getc(IN);
#line 566
  File_h.bfType = (WORD )__cil_tmp29;
#line 567
  __cil_tmp30 = getc(IN);
#line 567
  File_h.bfType = (WORD )((__cil_tmp30 << 8) + (int )File_h.bfType);
  }
#line 569
  if ((int )File_h.bfType != 19778) {
    {
#line 571
    fprintf(stderr, "Error, not a BMP file!\n");
#line 572
    fclose(IN);
    }
#line 573
    return ((opj_image_t *)((void *)0));
  }
  {
#line 577
  __cil_tmp31 = getc(IN);
#line 577
  File_h.bfSize = (DWORD )__cil_tmp31;
#line 578
  __cil_tmp32 = getc(IN);
#line 578
  File_h.bfSize = (unsigned int )(__cil_tmp32 << 8) + File_h.bfSize;
#line 579
  __cil_tmp33 = getc(IN);
#line 579
  File_h.bfSize = (unsigned int )(__cil_tmp33 << 16) + File_h.bfSize;
#line 580
  __cil_tmp34 = getc(IN);
#line 580
  File_h.bfSize = (unsigned int )(__cil_tmp34 << 24) + File_h.bfSize;
#line 582
  __cil_tmp35 = getc(IN);
#line 582
  File_h.bfReserved1 = (WORD )__cil_tmp35;
#line 583
  __cil_tmp36 = getc(IN);
#line 583
  File_h.bfReserved1 = (WORD )((__cil_tmp36 << 8) + (int )File_h.bfReserved1);
#line 585
  __cil_tmp37 = getc(IN);
#line 585
  File_h.bfReserved2 = (WORD )__cil_tmp37;
#line 586
  __cil_tmp38 = getc(IN);
#line 586
  File_h.bfReserved2 = (WORD )((__cil_tmp38 << 8) + (int )File_h.bfReserved2);
#line 588
  __cil_tmp39 = getc(IN);
#line 588
  File_h.bfOffBits = (DWORD )__cil_tmp39;
#line 589
  __cil_tmp40 = getc(IN);
#line 589
  File_h.bfOffBits = (unsigned int )(__cil_tmp40 << 8) + File_h.bfOffBits;
#line 590
  __cil_tmp41 = getc(IN);
#line 590
  File_h.bfOffBits = (unsigned int )(__cil_tmp41 << 16) + File_h.bfOffBits;
#line 591
  __cil_tmp42 = getc(IN);
#line 591
  File_h.bfOffBits = (unsigned int )(__cil_tmp42 << 24) + File_h.bfOffBits;
#line 596
  __cil_tmp43 = getc(IN);
#line 596
  Info_h.biSize = (DWORD )__cil_tmp43;
#line 597
  __cil_tmp44 = getc(IN);
#line 597
  Info_h.biSize = (unsigned int )(__cil_tmp44 << 8) + Info_h.biSize;
#line 598
  __cil_tmp45 = getc(IN);
#line 598
  Info_h.biSize = (unsigned int )(__cil_tmp45 << 16) + Info_h.biSize;
#line 599
  __cil_tmp46 = getc(IN);
#line 599
  Info_h.biSize = (unsigned int )(__cil_tmp46 << 24) + Info_h.biSize;
  }
#line 601
  if (Info_h.biSize != 40U) {
    {
#line 603
    fprintf(stderr, "Error, unknown BMP header size %d\n\341D\262U", Info_h.biSize);
#line 604
    fclose(IN);
    }
#line 605
    return ((opj_image_t *)((void *)0));
  }
  {
#line 607
  __cil_tmp47 = getc(IN);
#line 607
  Info_h.biWidth = (DWORD )__cil_tmp47;
#line 608
  __cil_tmp48 = getc(IN);
#line 608
  Info_h.biWidth = (unsigned int )(__cil_tmp48 << 8) + Info_h.biWidth;
#line 609
  __cil_tmp49 = getc(IN);
#line 609
  Info_h.biWidth = (unsigned int )(__cil_tmp49 << 16) + Info_h.biWidth;
#line 610
  __cil_tmp50 = getc(IN);
#line 610
  Info_h.biWidth = (unsigned int )(__cil_tmp50 << 24) + Info_h.biWidth;
#line 611
  w = (int )Info_h.biWidth;
#line 613
  __cil_tmp51 = getc(IN);
#line 613
  Info_h.biHeight = (DWORD )__cil_tmp51;
#line 614
  __cil_tmp52 = getc(IN);
#line 614
  Info_h.biHeight = (unsigned int )(__cil_tmp52 << 8) + Info_h.biHeight;
#line 615
  __cil_tmp53 = getc(IN);
#line 615
  Info_h.biHeight = (unsigned int )(__cil_tmp53 << 16) + Info_h.biHeight;
#line 616
  __cil_tmp54 = getc(IN);
#line 616
  Info_h.biHeight = (unsigned int )(__cil_tmp54 << 24) + Info_h.biHeight;
#line 617
  h = (int )Info_h.biHeight;
#line 619
  __cil_tmp55 = getc(IN);
#line 619
  Info_h.biPlanes = (WORD )__cil_tmp55;
#line 620
  __cil_tmp56 = getc(IN);
#line 620
  Info_h.biPlanes = (WORD )((__cil_tmp56 << 8) + (int )Info_h.biPlanes);
#line 622
  __cil_tmp57 = getc(IN);
#line 622
  Info_h.biBitCount = (WORD )__cil_tmp57;
#line 623
  __cil_tmp58 = getc(IN);
#line 623
  Info_h.biBitCount = (WORD )((__cil_tmp58 << 8) + (int )Info_h.biBitCount);
#line 625
  __cil_tmp59 = getc(IN);
#line 625
  Info_h.biCompression = (DWORD )__cil_tmp59;
#line 626
  __cil_tmp60 = getc(IN);
#line 626
  Info_h.biCompression = (unsigned int )(__cil_tmp60 << 8) + Info_h.biCompression;
#line 627
  __cil_tmp61 = getc(IN);
#line 627
  Info_h.biCompression = (unsigned int )(__cil_tmp61 << 16) + Info_h.biCompression;
#line 628
  __cil_tmp62 = getc(IN);
#line 628
  Info_h.biCompression = (unsigned int )(__cil_tmp62 << 24) + Info_h.biCompression;
#line 630
  __cil_tmp63 = getc(IN);
#line 630
  Info_h.biSizeImage = (DWORD )__cil_tmp63;
#line 631
  __cil_tmp64 = getc(IN);
#line 631
  Info_h.biSizeImage = (unsigned int )(__cil_tmp64 << 8) + Info_h.biSizeImage;
#line 632
  __cil_tmp65 = getc(IN);
#line 632
  Info_h.biSizeImage = (unsigned int )(__cil_tmp65 << 16) + Info_h.biSizeImage;
#line 633
  __cil_tmp66 = getc(IN);
#line 633
  Info_h.biSizeImage = (unsigned int )(__cil_tmp66 << 24) + Info_h.biSizeImage;
#line 635
  __cil_tmp67 = getc(IN);
#line 635
  Info_h.biXpelsPerMeter = (DWORD )__cil_tmp67;
#line 636
  __cil_tmp68 = getc(IN);
#line 636
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp68 << 8) + Info_h.biXpelsPerMeter;
#line 637
  __cil_tmp69 = getc(IN);
#line 637
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp69 << 16) + Info_h.biXpelsPerMeter;
#line 638
  __cil_tmp70 = getc(IN);
#line 638
  Info_h.biXpelsPerMeter = (unsigned int )(__cil_tmp70 << 24) + Info_h.biXpelsPerMeter;
#line 640
  __cil_tmp71 = getc(IN);
#line 640
  Info_h.biYpelsPerMeter = (DWORD )__cil_tmp71;
#line 641
  __cil_tmp72 = getc(IN);
#line 641
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp72 << 8) + Info_h.biYpelsPerMeter;
#line 642
  __cil_tmp73 = getc(IN);
#line 642
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp73 << 16) + Info_h.biYpelsPerMeter;
#line 643
  __cil_tmp74 = getc(IN);
#line 643
  Info_h.biYpelsPerMeter = (unsigned int )(__cil_tmp74 << 24) + Info_h.biYpelsPerMeter;
#line 645
  __cil_tmp75 = getc(IN);
#line 645
  Info_h.biClrUsed = (DWORD )__cil_tmp75;
#line 646
  __cil_tmp76 = getc(IN);
#line 646
  Info_h.biClrUsed = (unsigned int )(__cil_tmp76 << 8) + Info_h.biClrUsed;
#line 647
  __cil_tmp77 = getc(IN);
#line 647
  Info_h.biClrUsed = (unsigned int )(__cil_tmp77 << 16) + Info_h.biClrUsed;
#line 648
  __cil_tmp78 = getc(IN);
#line 648
  Info_h.biClrUsed = (unsigned int )(__cil_tmp78 << 24) + Info_h.biClrUsed;
#line 650
  __cil_tmp79 = getc(IN);
#line 650
  Info_h.biClrImportant = (DWORD )__cil_tmp79;
#line 651
  __cil_tmp80 = getc(IN);
#line 651
  Info_h.biClrImportant = (unsigned int )(__cil_tmp80 << 8) + Info_h.biClrImportant;
#line 652
  __cil_tmp81 = getc(IN);
#line 652
  Info_h.biClrImportant = (unsigned int )(__cil_tmp81 << 16) + Info_h.biClrImportant;
#line 653
  __cil_tmp82 = getc(IN);
#line 653
  Info_h.biClrImportant = (unsigned int )(__cil_tmp82 << 24) + Info_h.biClrImportant;
  }
#line 657
  if ((int )Info_h.biBitCount == 24) {
    {
#line 659
    numcomps = 3;
#line 660
    color_space = (OPJ_COLOR_SPACE )1;
#line 662
    memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 663
    i = 0;
    }
    {
#line 663
    while (1) {
      while_continue: /* CIL Label */ ;
#line 663
      if (! (i < numcomps)) {
#line 663
        goto while_break;
      }
#line 665
      cmptparm[i].prec = 8;
#line 666
      cmptparm[i].bpp = 8;
#line 667
      cmptparm[i].sgnd = 0;
#line 668
      cmptparm[i].dx = subsampling_dx;
#line 669
      cmptparm[i].dy = subsampling_dy;
#line 670
      cmptparm[i].w = w;
#line 671
      cmptparm[i].h = h;
#line 663
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 674
    image = opj_image_create(numcomps, & cmptparm[0], color_space);
    }
#line 675
    if (! image) {
      {
#line 677
      fclose(IN);
      }
#line 678
      return ((opj_image_t *)((void *)0));
    }
#line 682
    image->x0 = parameters->image_offset_x0;
#line 683
    image->y0 = parameters->image_offset_y0;
#line 684
    if (! image->x0) {
#line 684
      tmp = (w - 1) * subsampling_dx + 1;
    } else {
#line 684
      tmp = (image->x0 + (w - 1) * subsampling_dx) + 1;
    }
#line 684
    image->x1 = tmp;
#line 685
    if (! image->y0) {
#line 685
      tmp___0 = (h - 1) * subsampling_dy + 1;
    } else {
#line 685
      tmp___0 = (image->y0 + (h - 1) * subsampling_dy) + 1;
    }
    {
#line 685
    image->y1 = tmp___0;
#line 690
    fseek(IN, (long )0, 0);
#line 691
    fseek(IN, (long )File_h.bfOffBits, 0);
#line 693
    W = Info_h.biWidth;
#line 694
    H = Info_h.biHeight;
    }
#line 698
    if ((3U * W) % 4U) {
#line 698
      tmp___1 = 4U - (3U * W) % 4U;
    } else {
#line 698
      tmp___1 = (unsigned int )0;
    }
    {
#line 698
    PAD = tmp___1;
#line 700
    __cil_tmp88 = malloc((unsigned long )((3U * W + PAD) * H) * sizeof(unsigned char ));
#line 700
    RGB = (unsigned char *)__cil_tmp88;
#line 703
    __cil_tmp89 = fread(RGB, sizeof(unsigned char ), (unsigned long )((3U * W + PAD) * H),
                        IN);
    }
#line 703
    if (__cil_tmp89 != (unsigned long )((3U * W + PAD) * H)) {
      {
#line 705
      free(RGB);
#line 706
      opj_image_destroy(image);
#line 707
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
      }
#line 708
      return ((opj_image_t *)((void *)0));
    }
#line 711
    index___25 = 0;
#line 713
    y = 0;
    {
#line 713
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 713
      if (! (y < (int )H)) {
#line 713
        goto while_break___0;
      }
#line 715
      scanline = RGB + (3U * W + PAD) * ((H - 1U) - (unsigned int )y);
#line 716
      x = 0;
      {
#line 716
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 716
        if (! (x < (int )W)) {
#line 716
          goto while_break___1;
        }
#line 718
        pixel = scanline + 3 * x;
#line 719
        *((image->comps + 0)->data + index___25) = (int )*(pixel + 2);
#line 720
        *((image->comps + 1)->data + index___25) = (int )*(pixel + 1);
#line 721
        *((image->comps + 2)->data + index___25) = (int )*(pixel + 0);
#line 722
        index___25 ++;
#line 716
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 713
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 725
    free(RGB);
    }
  } else
#line 728
  if ((int )Info_h.biBitCount == 8) {
#line 728
    if (Info_h.biCompression == 0U) {
#line 730
      if (Info_h.biClrUsed == 0U) {
#line 730
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 732
      if (Info_h.biClrUsed > 256U) {
#line 732
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 734
      __cil_tmp95 = malloc(256UL * sizeof(unsigned char ));
#line 734
      table_R = (unsigned char *)__cil_tmp95;
#line 735
      __cil_tmp96 = malloc(256UL * sizeof(unsigned char ));
#line 735
      table_G = (unsigned char *)__cil_tmp96;
#line 736
      __cil_tmp97 = malloc(256UL * sizeof(unsigned char ));
#line 736
      table_B = (unsigned char *)__cil_tmp97;
#line 738
      has_color = 0;
#line 739
      j = (unsigned int )0;
      }
      {
#line 739
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 739
        if (! (j < Info_h.biClrUsed)) {
#line 739
          goto while_break___2;
        }
        {
#line 741
        __cil_tmp98 = getc(IN);
#line 741
        *(table_B + j) = (unsigned char )__cil_tmp98;
#line 742
        __cil_tmp99 = getc(IN);
#line 742
        *(table_G + j) = (unsigned char )__cil_tmp99;
#line 743
        __cil_tmp100 = getc(IN);
#line 743
        *(table_R + j) = (unsigned char )__cil_tmp100;
#line 744
        getc(IN);
#line 745
        has_color += ! ((int )*(table_R + j) == (int )*(table_G + j) && (int )*(table_R + j) == (int )*(table_B + j));
        }
#line 739
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 748
      if (has_color) {
#line 748
        gray_scale = 0;
      }
      {
#line 751
      fseek(IN, (long )0, 0);
#line 752
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 754
      W = Info_h.biWidth;
#line 755
      H = Info_h.biHeight;
      }
#line 756
      if (Info_h.biWidth % 2U) {
#line 757
        W ++;
      }
#line 759
      if (gray_scale) {
#line 759
        tmp___2 = 1;
      } else {
#line 759
        tmp___2 = 3;
      }
#line 759
      numcomps = tmp___2;
#line 760
      if (gray_scale) {
#line 760
        tmp___3 = 2;
      } else {
#line 760
        tmp___3 = 1;
      }
      {
#line 760
      color_space = (OPJ_COLOR_SPACE )tmp___3;
#line 762
      memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 763
      i = 0;
      }
      {
#line 763
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 763
        if (! (i < numcomps)) {
#line 763
          goto while_break___3;
        }
#line 765
        cmptparm[i].prec = 8;
#line 766
        cmptparm[i].bpp = 8;
#line 767
        cmptparm[i].sgnd = 0;
#line 768
        cmptparm[i].dx = subsampling_dx;
#line 769
        cmptparm[i].dy = subsampling_dy;
#line 770
        cmptparm[i].w = w;
#line 771
        cmptparm[i].h = h;
#line 763
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 774
      image = opj_image_create(numcomps, & cmptparm[0], color_space);
      }
#line 775
      if (! image) {
        {
#line 777
        fclose(IN);
#line 778
        free(table_R);
#line 778
        free(table_G);
#line 778
        free(table_B);
        }
#line 779
        return ((opj_image_t *)((void *)0));
      }
#line 783
      image->x0 = parameters->image_offset_x0;
#line 784
      image->y0 = parameters->image_offset_y0;
#line 785
      if (! image->x0) {
#line 785
        tmp___4 = (w - 1) * subsampling_dx + 1;
      } else {
#line 785
        tmp___4 = (image->x0 + (w - 1) * subsampling_dx) + 1;
      }
#line 785
      image->x1 = tmp___4;
#line 786
      if (! image->y0) {
#line 786
        tmp___5 = (h - 1) * subsampling_dy + 1;
      } else {
#line 786
        tmp___5 = (image->y0 + (h - 1) * subsampling_dy) + 1;
      }
      {
#line 786
      image->y1 = tmp___5;
#line 790
      __cil_tmp109 = malloc((unsigned long )(W * H) * sizeof(unsigned char ));
#line 790
      RGB = (unsigned char *)__cil_tmp109;
#line 792
      __cil_tmp110 = fread(RGB, sizeof(unsigned char ), (unsigned long )(W * H), IN);
      }
#line 792
      if (__cil_tmp110 != (unsigned long )(W * H)) {
        {
#line 794
        free(table_R);
#line 795
        free(table_G);
#line 796
        free(table_B);
#line 797
        free(RGB);
#line 798
        opj_image_destroy(image);
#line 799
        fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
        }
#line 800
        return ((opj_image_t *)((void *)0));
      }
#line 802
      if (gray_scale) {
#line 804
        index___25 = 0;
#line 805
        j = (unsigned int )0;
        {
#line 805
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 805
          if (! (j < W * H)) {
#line 805
            goto while_break___4;
          }
#line 807
          if (j % W < W - 1U) {
#line 807
            if (Info_h.biWidth % 2U) {
#line 809
              *((image->comps + 0)->data + index___25) = (int )*(table_R + *(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 811
              index___25 ++;
            } else {
#line 807
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 807
          if (! (Info_h.biWidth % 2U)) {
#line 809
            *((image->comps + 0)->data + index___25) = (int )*(table_R + *(RGB + ((W * H - (j / W + 1U) * W) + j % W)));
#line 811
            index___25 ++;
          }
#line 805
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 818
        index___25 = 0;
#line 819
        j = (unsigned int )0;
        {
#line 819
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 819
          if (! (j < W * H)) {
#line 819
            goto while_break___5;
          }
#line 821
          if (j % W < W - 1U) {
#line 821
            if (Info_h.biWidth % 2U) {
#line 824
              pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 826
              *((image->comps + 0)->data + index___25) = (int )*(table_R + pixel_index);
#line 827
              *((image->comps + 1)->data + index___25) = (int )*(table_G + pixel_index);
#line 828
              *((image->comps + 2)->data + index___25) = (int )*(table_B + pixel_index);
#line 829
              index___25 ++;
            } else {
#line 821
              goto _L___26;
            }
          } else
          _L___26: /* CIL Label */ 
#line 821
          if (! (Info_h.biWidth % 2U)) {
#line 824
            pixel_index = *(RGB + ((W * H - (j / W + 1U) * W) + j % W));
#line 826
            *((image->comps + 0)->data + index___25) = (int )*(table_R + pixel_index);
#line 827
            *((image->comps + 1)->data + index___25) = (int )*(table_G + pixel_index);
#line 828
            *((image->comps + 2)->data + index___25) = (int )*(table_B + pixel_index);
#line 829
            index___25 ++;
          }
#line 819
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 833
      free(RGB);
#line 834
      free(table_R);
#line 835
      free(table_G);
#line 836
      free(table_B);
      }
    } else {
#line 728
      goto _L___30;
    }
  } else
  _L___30: /* CIL Label */ 
#line 839
  if ((int )Info_h.biBitCount == 8) {
#line 839
    if (Info_h.biCompression == 1U) {
#line 847
      if (Info_h.biClrUsed == 0U) {
#line 848
        Info_h.biClrUsed = (DWORD )256;
      } else
#line 849
      if (Info_h.biClrUsed > 256U) {
#line 850
        Info_h.biClrUsed = (DWORD )256;
      }
      {
#line 852
      __cil_tmp129 = malloc(256UL * sizeof(unsigned char ));
#line 852
      table_R = (unsigned char *)__cil_tmp129;
#line 853
      __cil_tmp130 = malloc(256UL * sizeof(unsigned char ));
#line 853
      table_G = (unsigned char *)__cil_tmp130;
#line 854
      __cil_tmp131 = malloc(256UL * sizeof(unsigned char ));
#line 854
      table_B = (unsigned char *)__cil_tmp131;
#line 856
      has_color = 0;
#line 857
      j = (unsigned int )0;
      }
      {
#line 857
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 857
        if (! (j < Info_h.biClrUsed)) {
#line 857
          goto while_break___6;
        }
        {
#line 859
        __cil_tmp132 = getc(IN);
#line 859
        *(table_B + j) = (unsigned char )__cil_tmp132;
#line 860
        __cil_tmp133 = getc(IN);
#line 860
        *(table_G + j) = (unsigned char )__cil_tmp133;
#line 861
        __cil_tmp134 = getc(IN);
#line 861
        *(table_R + j) = (unsigned char )__cil_tmp134;
#line 862
        getc(IN);
#line 863
        has_color += ! ((int )*(table_R + j) == (int )*(table_G + j) && (int )*(table_R + j) == (int )*(table_B + j));
        }
#line 857
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 866
      if (has_color) {
#line 867
        gray_scale = 0;
      }
#line 869
      if (gray_scale) {
#line 869
        tmp___6 = 1;
      } else {
#line 869
        tmp___6 = 3;
      }
#line 869
      numcomps = tmp___6;
#line 870
      if (gray_scale) {
#line 870
        tmp___7 = 2;
      } else {
#line 870
        tmp___7 = 1;
      }
      {
#line 870
      color_space = (OPJ_COLOR_SPACE )tmp___7;
#line 872
      memset(& cmptparm[0], 0, 3UL * sizeof(opj_image_cmptparm_t ));
#line 873
      i___29 = 0;
      }
      {
#line 873
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 873
        if (! (i___29 < numcomps)) {
#line 873
          goto while_break___7;
        }
#line 875
        cmptparm[i___29].prec = 8;
#line 876
        cmptparm[i___29].bpp = 8;
#line 877
        cmptparm[i___29].sgnd = 0;
#line 878
        cmptparm[i___29].dx = subsampling_dx;
#line 879
        cmptparm[i___29].dy = subsampling_dy;
#line 880
        cmptparm[i___29].w = w;
#line 881
        cmptparm[i___29].h = h;
#line 873
        i___29 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 884
      image = opj_image_create(numcomps, & cmptparm[0], color_space);
      }
#line 885
      if (! image) {
        {
#line 887
        fclose(IN);
#line 888
        free(table_R);
#line 889
        free(table_G);
#line 890
        free(table_B);
        }
#line 891
        return ((opj_image_t *)((void *)0));
      }
#line 895
      image->x0 = parameters->image_offset_x0;
#line 896
      image->y0 = parameters->image_offset_y0;
#line 897
      if (! image->x0) {
#line 897
        tmp___8 = (w - 1) * subsampling_dx + 1;
      } else {
#line 897
        tmp___8 = (image->x0 + (w - 1) * subsampling_dx) + 1;
      }
#line 897
      image->x1 = tmp___8;
#line 899
      if (! image->y0) {
#line 899
        tmp___9 = (h - 1) * subsampling_dy + 1;
      } else {
#line 899
        tmp___9 = (image->y0 + (h - 1) * subsampling_dy) + 1;
      }
      {
#line 899
      image->y1 = tmp___9;
#line 905
      fseek(IN, (long )0, 0);
#line 906
      fseek(IN, (long )File_h.bfOffBits, 0);
#line 908
      W = Info_h.biWidth;
#line 909
      H = Info_h.biHeight;
#line 910
      __cil_tmp142 = calloc((unsigned long )1, (unsigned long )(W * H) * sizeof(unsigned char ));
#line 910
      RGB = (unsigned char *)__cil_tmp142;
#line 911
      beyond = RGB + W * H;
#line 912
      pix = beyond - W;
#line 913
      y___28 = (unsigned int )0;
#line 913
      x___27 = y___28;
      }
      {
#line 915
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 915
        if (! (y___28 < H)) {
#line 915
          goto while_break___8;
        }
        {
#line 917
        c = getc(IN);
        }
#line 919
        if (c) {
          {
#line 921
          c1 = getc(IN);
#line 923
          i___29 = 0;
          }
          {
#line 923
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 923
            if (! (pix < beyond && (i___29 < c && x___27 < W))) {
#line 923
              goto while_break___9;
            }
#line 924
            *pix = (unsigned char )c1;
#line 923
            __cil_tmp147 = pix;
#line 923
            pix ++;
#line 923
            __cil_tmp146 = x___27;
#line 923
            x___27 ++;
#line 923
            __cil_tmp145 = i___29;
#line 923
            i___29 ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        } else {
          {
#line 928
          c = getc(IN);
          }
#line 930
          if (c == 0) {
#line 932
            x___27 = (unsigned int )0;
#line 933
            y___28 ++;
#line 934
            pix = (RGB + x___27) + ((H - y___28) - 1U) * W;
          } else
#line 936
          if (c == 1) {
#line 937
            goto while_break___8;
          } else
#line 938
          if (c == 2) {
            {
#line 940
            c = getc(IN);
#line 941
            x___27 += (unsigned int )c;
#line 942
            c = getc(IN);
#line 943
            y___28 += (unsigned int )c;
#line 944
            pix = (RGB + ((H - y___28) - 1U) * W) + x___27;
            }
          } else {
#line 948
            i___29 = 0;
            {
#line 949
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 949
              if (! (pix < beyond && (i___29 < c && x___27 < W))) {
#line 949
                goto while_break___10;
              }
              {
#line 951
              c1 = getc(IN);
#line 952
              *pix = (unsigned char )c1;
              }
#line 949
              __cil_tmp154 = pix;
#line 949
              pix ++;
#line 949
              __cil_tmp153 = x___27;
#line 949
              x___27 ++;
#line 949
              __cil_tmp152 = i___29;
#line 949
              i___29 ++;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 954
            if (c & 1) {
              {
#line 955
              getc(IN);
              }
            }
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 960
      if (gray_scale) {
#line 962
        gray = (image->comps + 0)->data;
#line 963
        pix = RGB;
#line 964
        max = W * H;
        {
#line 966
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 966
          __cil_tmp155 = max;
#line 966
          max --;
#line 966
          if (! __cil_tmp155) {
#line 966
            goto while_break___11;
          }
#line 968
          __cil_tmp156 = pix;
#line 968
          pix ++;
#line 968
          uc = *__cil_tmp156;
#line 970
          __cil_tmp157 = gray;
#line 970
          gray ++;
#line 970
          *__cil_tmp157 = (int )*(table_R + uc);
        }
        while_break___11: /* CIL Label */ ;
        }
      } else {
#line 977
        red = (image->comps + 0)->data;
#line 978
        green = (image->comps + 1)->data;
#line 979
        blue = (image->comps + 2)->data;
#line 980
        pix = RGB;
#line 981
        max = W * H;
        {
#line 983
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 983
          __cil_tmp158 = max;
#line 983
          max --;
#line 983
          if (! __cil_tmp158) {
#line 983
            goto while_break___12;
          }
#line 985
          __cil_tmp159 = pix;
#line 985
          pix ++;
#line 985
          uc = *__cil_tmp159;
#line 987
          __cil_tmp160 = red;
#line 987
          red ++;
#line 987
          *__cil_tmp160 = (int )*(table_R + uc);
#line 988
          __cil_tmp161 = green;
#line 988
          green ++;
#line 988
          *__cil_tmp161 = (int )*(table_G + uc);
#line 989
          __cil_tmp162 = blue;
#line 989
          blue ++;
#line 989
          *__cil_tmp162 = (int )*(table_B + uc);
        }
        while_break___12: /* CIL Label */ ;
        }
      }
      {
#line 992
      free(RGB);
#line 993
      free(table_R);
#line 994
      free(table_G);
#line 995
      free(table_B);
      }
    } else {
      {
      {
#line 999
      fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
              (int )Info_h.biBitCount);
      }
      }
    }
  } else {
    {
    {
#line 999
    fprintf(stderr, "Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n",
            (int )Info_h.biBitCount);
    }
    }
  }
  {
#line 1003
  fclose(IN);
  }
#line 1004
  return (image);
}
}
#line 1007 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetobmp(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int pad ;
  FILE *fdest ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  FILE *__cil_tmp11 ;
  unsigned char rc ;
  unsigned char gc ;
  unsigned char bc ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  int r___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
#line 1010
  fdest = (FILE *)((void *)0);
#line 1013
  if ((image->comps + 0)->prec < 8) {
    {
#line 1014
    fprintf(stderr, "Unsupported precision: %d\n", (image->comps + 0)->prec);
    }
#line 1015
    return (1);
  }
#line 1017
  if (image->numcomps >= 3) {
#line 1017
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1017
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1017
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1017
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1017
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1017
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
                {
#line 1028
                fdest = fopen(outfile, "wb");
                }
#line 1029
                if (! fdest) {
                  {
#line 1030
                  fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
                  }
#line 1031
                  return (1);
                }
                {
#line 1034
                w = (image->comps + 0)->w;
#line 1035
                h = (image->comps + 0)->h;
#line 1037
                fprintf(fdest, "BM\343D\262U");
#line 1041
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) + 54)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 8)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 16)) & 255,
                        (int )((unsigned char )((((h * w) * 3 + (3 * h) * (w % 2)) + 54) >> 24)) & 255);
#line 1046
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1047
                fprintf(fdest, "%c%c%c%c\251", 54, (54 >> 8) & 255, (54 >> 16) & 255,
                        (54 >> 24) & 255);
#line 1051
                fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255,
                        (40 >> 24) & 255);
#line 1052
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)),
                        (int )((unsigned char )(w >> 8)) & 255, (int )((unsigned char )(w >> 16)) & 255,
                        (int )((unsigned char )(w >> 24)) & 255);
#line 1056
                fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)),
                        (int )((unsigned char )(h >> 8)) & 255, (int )((unsigned char )(h >> 16)) & 255,
                        (int )((unsigned char )(h >> 24)) & 255);
#line 1060
                fprintf(fdest, "%c%c\262U", 1, (1 >> 8) & 255);
#line 1061
                fprintf(fdest, "%c%c\262U", 24, (24 >> 8) & 255);
#line 1062
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1063
                fprintf(fdest, "%c%c%c%c\251", (int )((unsigned char )((3 * h) * w + (3 * h) * (w % 2))) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 8)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 16)) & 255,
                        (int )((unsigned char )(((h * w) * 3 + (3 * h) * (w % 2)) >> 24)) & 255);
#line 1067
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1068
                fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255,
                        (7834 >> 24) & 255);
#line 1069
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1070
                fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
                }
#line 1072
                if ((image->comps + 0)->prec > 8) {
                  {
#line 1073
                  adjustR = (image->comps + 0)->prec - 8;
#line 1074
                  printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n",
                         (image->comps + 0)->prec);
                  }
                } else {
#line 1077
                  adjustR = 0;
                }
#line 1078
                if ((image->comps + 1)->prec > 8) {
                  {
#line 1079
                  adjustG = (image->comps + 1)->prec - 8;
#line 1080
                  printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n",
                         (image->comps + 1)->prec);
                  }
                } else {
#line 1083
                  adjustG = 0;
                }
#line 1084
                if ((image->comps + 2)->prec > 8) {
                  {
#line 1085
                  adjustB = (image->comps + 2)->prec - 8;
#line 1086
                  printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n",
                         (image->comps + 2)->prec);
                  }
                } else {
#line 1089
                  adjustB = 0;
                }
#line 1091
                i = 0;
                {
#line 1091
                while (1) {
                  while_continue: /* CIL Label */ ;
#line 1091
                  if (! (i < w * h)) {
#line 1091
                    goto while_break;
                  }
#line 1095
                  r = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1096
                  if ((image->comps + 0)->sgnd) {
#line 1096
                    tmp = 1 << ((image->comps + 0)->prec - 1);
                  } else {
#line 1096
                    tmp = 0;
                  }
#line 1096
                  r += tmp;
#line 1097
                  r = (r >> adjustR) + (r >> (adjustR - 1)) % 2;
#line 1098
                  if (r > 255) {
#line 1098
                    r = 255;
                  } else
#line 1098
                  if (r < 0) {
#line 1098
                    r = 0;
                  }
#line 1099
                  rc = (unsigned char )r;
#line 1101
                  g = *((image->comps + 1)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1102
                  if ((image->comps + 1)->sgnd) {
#line 1102
                    tmp___0 = 1 << ((image->comps + 1)->prec - 1);
                  } else {
#line 1102
                    tmp___0 = 0;
                  }
#line 1102
                  g += tmp___0;
#line 1103
                  g = (g >> adjustG) + (g >> (adjustG - 1)) % 2;
#line 1104
                  if (g > 255) {
#line 1104
                    g = 255;
                  } else
#line 1104
                  if (g < 0) {
#line 1104
                    g = 0;
                  }
#line 1105
                  gc = (unsigned char )g;
#line 1107
                  b = *((image->comps + 2)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1108
                  if ((image->comps + 2)->sgnd) {
#line 1108
                    tmp___1 = 1 << ((image->comps + 2)->prec - 1);
                  } else {
#line 1108
                    tmp___1 = 0;
                  }
#line 1108
                  b += tmp___1;
#line 1109
                  b = (b >> adjustB) + (b >> (adjustB - 1)) % 2;
#line 1110
                  if (b > 255) {
#line 1110
                    b = 255;
                  } else
#line 1110
                  if (b < 0) {
#line 1110
                    b = 0;
                  }
                  {
#line 1111
                  bc = (unsigned char )b;
#line 1113
                  fprintf(fdest, "%c%c%c", (int )bc, (int )gc, (int )rc);
                  }
#line 1115
                  if ((i + 1) % w == 0) {
#line 1116
                    if ((3 * w) % 4) {
#line 1116
                      tmp___2 = 4 - (3 * w) % 4;
                    } else {
#line 1116
                      tmp___2 = 0;
                    }
#line 1116
                    pad = tmp___2;
                    {
#line 1116
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 1116
                      if (! (pad > 0)) {
#line 1116
                        goto while_break___0;
                      }
                      {
#line 1117
                      fprintf(fdest, "%c", 0);
                      }
#line 1116
                      __cil_tmp22 = pad;
#line 1116
                      pad --;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
                  }
#line 1091
                  i ++;
                }
                while_break: /* CIL Label */ ;
                }
                {
#line 1120
                fclose(fdest);
                }
              } else {
#line 1017
                goto _L;
              }
            } else {
#line 1017
              goto _L;
            }
          } else {
#line 1017
            goto _L;
          }
        } else {
#line 1017
          goto _L;
        }
      } else {
#line 1017
        goto _L;
      }
    } else {
#line 1017
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    _L___31: /* CIL Label */ 
    _L___32: /* CIL Label */ 
    _L___33: /* CIL Label */ 
    _L___34: /* CIL Label */ 
    _L___35: /* CIL Label */ 
    {
#line 1127
    fdest = fopen(outfile, "wb");
#line 1128
    w = (image->comps + 0)->w;
#line 1129
    h = (image->comps + 0)->h;
#line 1131
    fprintf(fdest, "BM\343D\262U");
#line 1135
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(((h * w + 54) + 1024) + h * (w % 2))) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 8)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((((h * w + 54) + 1024) + w * (w % 2)) >> 24)) & 255);
#line 1139
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1140
    fprintf(fdest, "%c%c%c%c\251", 54, (1078 >> 8) & 255, (1078 >> 16) & 255, (1078 >> 24) & 255);
#line 1146
    fprintf(fdest, "%c%c%c%c\251", 40, (40 >> 8) & 255, (40 >> 16) & 255, (40 >> 24) & 255);
#line 1147
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(w & 255)), (int )((unsigned char )(w >> 8)) & 255,
            (int )((unsigned char )(w >> 16)) & 255, (int )((unsigned char )(w >> 24)) & 255);
#line 1151
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h & 255)), (int )((unsigned char )(h >> 8)) & 255,
            (int )((unsigned char )(h >> 16)) & 255, (int )((unsigned char )(h >> 24)) & 255);
#line 1155
    fprintf(fdest, "%c%c\262U", 1, (1 >> 8) & 255);
#line 1156
    fprintf(fdest, "%c%c\262U", 8, (8 >> 8) & 255);
#line 1157
    fprintf(fdest, "%c%c%c%c\251", 0, 0, 0, 0);
#line 1158
    fprintf(fdest, "%c%c%c%c\230\001", (int )((unsigned char )(h * w + h * (w % 2))) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 8)) & 255, (int )((unsigned char )((h * w + h * (w % 2)) >> 16)) & 255,
            (int )((unsigned char )((h * w + h * (w % 2)) >> 24)) & 255);
#line 1162
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1163
    fprintf(fdest, "%c%c%c%c\251", 154, (7834 >> 8) & 255, (7834 >> 16) & 255, (7834 >> 24) & 255);
#line 1164
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
#line 1165
    fprintf(fdest, "%c%c%c%c\251", 0, (256 >> 8) & 255, (256 >> 16) & 255, (256 >> 24) & 255);
    }
#line 1167
    if ((image->comps + 0)->prec > 8) {
      {
#line 1168
      adjustR = (image->comps + 0)->prec - 8;
#line 1169
      printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", (image->comps + 0)->prec);
      }
    } else {
#line 1171
      adjustR = 0;
    }
#line 1173
    i = 0;
    {
#line 1173
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1173
      if (! (i < 256)) {
#line 1173
        goto while_break___1;
      }
      {
#line 1174
      fprintf(fdest, "%c%c%c%c\230\001", i, i, i, 0);
      }
#line 1173
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1177
    i = 0;
    {
#line 1177
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1177
      if (! (i < w * h)) {
#line 1177
        goto while_break___2;
      }
#line 1180
      r___0 = *((image->comps + 0)->data + ((w * h - (i / w + 1) * w) + i % w));
#line 1181
      if ((image->comps + 0)->sgnd) {
#line 1181
        tmp___3 = 1 << ((image->comps + 0)->prec - 1);
      } else {
#line 1181
        tmp___3 = 0;
      }
#line 1181
      r___0 += tmp___3;
#line 1182
      r___0 = (r___0 >> adjustR) + (r___0 >> (adjustR - 1)) % 2;
#line 1183
      if (r___0 > 255) {
#line 1183
        r___0 = 255;
      } else
#line 1183
      if (r___0 < 0) {
#line 1183
        r___0 = 0;
      }
      {
#line 1185
      fprintf(fdest, "%c", (int )((unsigned char )r___0));
      }
#line 1187
      if ((i + 1) % w == 0) {
#line 1188
        if (w % 4) {
#line 1188
          tmp___4 = 4 - w % 4;
        } else {
#line 1188
          tmp___4 = 0;
        }
#line 1188
        pad = tmp___4;
        {
#line 1188
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1188
          if (! (pad > 0)) {
#line 1188
            goto while_break___3;
          }
          {
#line 1189
          fprintf(fdest, "%c", 0);
          }
#line 1188
          __cil_tmp29 = pad;
#line 1188
          pad --;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1177
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1192
    fclose(fdest);
    }
  }
#line 1195
  return (0);
}
}
#line 1205 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned char readuchar(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1208
  __cil_tmp3 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1208
  if (! __cil_tmp3) {
    {
#line 1210
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1211
    return ((unsigned char )0);
  }
#line 1213
  return (c1);
}
}
#line 1216 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned short readushort(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1219
  __cil_tmp5 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1219
  if (! __cil_tmp5) {
    {
#line 1221
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1222
    return ((unsigned short )0);
  }
  {
#line 1224
  __cil_tmp6 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1224
  if (! __cil_tmp6) {
    {
#line 1226
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1227
    return ((unsigned short )0);
  }
#line 1229
  if (bigendian) {
#line 1230
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1232
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1235 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned int readuint(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1238
  __cil_tmp7 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1238
  if (! __cil_tmp7) {
    {
#line 1240
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1241
    return ((unsigned int )0);
  }
  {
#line 1243
  __cil_tmp8 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1243
  if (! __cil_tmp8) {
    {
#line 1245
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1246
    return ((unsigned int )0);
  }
  {
#line 1248
  __cil_tmp9 = fread(& c3, (unsigned long )1, (unsigned long )1, f);
  }
#line 1248
  if (! __cil_tmp9) {
    {
#line 1250
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1251
    return ((unsigned int )0);
  }
  {
#line 1253
  __cil_tmp10 = fread(& c4, (unsigned long )1, (unsigned long )1, f);
  }
#line 1253
  if (! __cil_tmp10) {
    {
#line 1255
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1256
    return ((unsigned int )0);
  }
#line 1258
  if (bigendian) {
#line 1259
    return ((unsigned int )(((((int )c1 << 24) + ((int )c2 << 16)) + ((int )c3 << 8)) + (int )c4));
  } else {
#line 1261
    return ((unsigned int )(((((int )c4 << 24) + ((int )c3 << 16)) + ((int )c2 << 8)) + (int )c1));
  }
}
}
#line 1264 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *pgxtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  FILE *f ;
  int w ;
  int h ;
  int prec ;
  int i ;
  int numcomps ;
  int max ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm ;
  opj_image_t *image ;
  int adjustS ;
  int ushift ;
  int dshift ;
  int force8 ;
  char endian1 ;
  char endian2 ;
  char sign ;
  char signtmp[32] ;
  char temp[32] ;
  int bigendian ;
  opj_image_comp_t *comp ;
  FILE *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  opj_image_t *__cil_tmp29 ;
  int v ;
  unsigned char __cil_tmp31 ;
  unsigned char __cil_tmp32 ;
  unsigned char __cil_tmp33 ;
  unsigned short __cil_tmp34 ;
  unsigned short __cil_tmp35 ;
  unsigned int __cil_tmp36 ;
  unsigned int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
  {
#line 1265
  f = (FILE *)((void *)0);
#line 1270
  image = (opj_image_t *)((void *)0);
#line 1278
  comp = (opj_image_comp_t *)((void *)0);
#line 1280
  numcomps = 1;
#line 1281
  color_space = (OPJ_COLOR_SPACE )2;
#line 1283
  memset(& cmptparm, 0, sizeof(opj_image_cmptparm_t ));
#line 1285
  max = 0;
#line 1287
  f = fopen(filename, "rb\342D\262U");
  }
#line 1288
  if (! f) {
    {
#line 1289
    fprintf(stderr, "Failed to open %s for reading !\n\230\001", filename);
    }
#line 1290
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1293
  fseek(f, (long )0, 0);
#line 1294
  __cil_tmp25 = fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d\345D\262U", (char *)temp,
                       & endian1, & endian2, (char *)signtmp, & prec, (char *)temp,
                       & w, (char *)temp, & h);
  }
#line 1294
  if (__cil_tmp25 != 9) {
    {
#line 1295
    fprintf(stderr, "ERROR: Failed to read the right number of element from the fscanf() function!\n");
    }
#line 1296
    return ((opj_image_t *)((void *)0));
  }
#line 1299
  i = 0;
#line 1300
  sign = (char )'+';
  {
#line 1301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1301
    if (! ((int )signtmp[i] != 0)) {
#line 1301
      goto while_break;
    }
#line 1302
    if ((int )signtmp[i] == 45) {
#line 1302
      sign = (char )'-';
    }
#line 1303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1306
  fgetc(f);
  }
#line 1307
  if ((int )endian1 == 77) {
#line 1307
    if ((int )endian2 == 76) {
#line 1308
      bigendian = 1;
    } else {
#line 1307
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1309
  if ((int )endian2 == 77) {
#line 1309
    if ((int )endian1 == 76) {
#line 1310
      bigendian = 0;
    } else {
      {
      {
#line 1312
      fprintf(stderr, "Bad pgx header, please check input file\n\220");
      }
      }
#line 1313
      return ((opj_image_t *)((void *)0));
    }
  } else {
    {
    {
#line 1312
    fprintf(stderr, "Bad pgx header, please check input file\n\220");
    }
    }
#line 1313
    return ((opj_image_t *)((void *)0));
  }
#line 1318
  cmptparm.x0 = parameters->image_offset_x0;
#line 1319
  cmptparm.y0 = parameters->image_offset_y0;
#line 1320
  if (! cmptparm.x0) {
#line 1320
    tmp = (w - 1) * parameters->subsampling_dx + 1;
  } else {
#line 1320
    tmp = (cmptparm.x0 + (w - 1) * parameters->subsampling_dx) + 1;
  }
#line 1320
  cmptparm.w = tmp;
#line 1321
  if (! cmptparm.y0) {
#line 1321
    tmp___0 = (h - 1) * parameters->subsampling_dy + 1;
  } else {
#line 1321
    tmp___0 = (cmptparm.y0 + (h - 1) * parameters->subsampling_dy) + 1;
  }
#line 1321
  cmptparm.h = tmp___0;
#line 1323
  if ((int )sign == 45) {
#line 1324
    cmptparm.sgnd = 1;
  } else {
#line 1326
    cmptparm.sgnd = 0;
  }
#line 1328
  if (prec < 8) {
#line 1330
    force8 = 1;
#line 1331
    ushift = 8 - prec;
#line 1331
    dshift = prec - ushift;
#line 1332
    if (cmptparm.sgnd) {
#line 1332
      adjustS = 1 << (prec - 1);
    } else {
#line 1332
      adjustS = 0;
    }
#line 1333
    cmptparm.sgnd = 0;
#line 1334
    prec = 8;
  } else {
#line 1336
    adjustS = 0;
#line 1336
    force8 = adjustS;
#line 1336
    dshift = force8;
#line 1336
    ushift = dshift;
  }
  {
#line 1338
  cmptparm.prec = prec;
#line 1339
  cmptparm.bpp = prec;
#line 1340
  cmptparm.dx = parameters->subsampling_dx;
#line 1341
  cmptparm.dy = parameters->subsampling_dy;
#line 1344
  image = opj_image_create(numcomps, & cmptparm, color_space);
  }
#line 1345
  if (! image) {
    {
#line 1346
    fclose(f);
    }
#line 1347
    return ((opj_image_t *)((void *)0));
  }
#line 1350
  image->x0 = cmptparm.x0;
#line 1351
  image->y0 = cmptparm.x0;
#line 1352
  image->x1 = cmptparm.w;
#line 1353
  image->y1 = cmptparm.h;
#line 1357
  comp = image->comps + 0;
#line 1359
  i = 0;
  {
#line 1359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1359
    if (! (i < w * h)) {
#line 1359
      goto while_break___0;
    }
#line 1361
    if (force8) {
      {
#line 1363
      __cil_tmp31 = readuchar(f);
#line 1363
      v = (int )__cil_tmp31 + adjustS;
#line 1364
      v = (v << ushift) + (v >> dshift);
#line 1365
      *(comp->data + i) = (int )((unsigned char )v);
      }
#line 1367
      if (v > max) {
#line 1367
        max = v;
      }
#line 1369
      goto while_continue___0;
    }
#line 1371
    if (comp->prec == 8) {
#line 1372
      if (! comp->sgnd) {
        {
#line 1373
        __cil_tmp32 = readuchar(f);
#line 1373
        v = (int )__cil_tmp32;
        }
      } else {
        {
#line 1375
        __cil_tmp33 = readuchar(f);
#line 1375
        v = (int )((char )__cil_tmp33);
        }
      }
    } else
#line 1377
    if (comp->prec <= 16) {
#line 1378
      if (! comp->sgnd) {
        {
#line 1379
        __cil_tmp34 = readushort(f, bigendian);
#line 1379
        v = (int )__cil_tmp34;
        }
      } else {
        {
#line 1381
        __cil_tmp35 = readushort(f, bigendian);
#line 1381
        v = (int )((short )__cil_tmp35);
        }
      }
    } else
#line 1384
    if (! comp->sgnd) {
      {
#line 1385
      __cil_tmp36 = readuint(f, bigendian);
#line 1385
      v = (int )__cil_tmp36;
      }
    } else {
      {
#line 1387
      __cil_tmp37 = readuint(f, bigendian);
#line 1387
      v = (int )__cil_tmp37;
      }
    }
#line 1390
    if (v > max) {
#line 1391
      max = v;
    }
#line 1392
    *(comp->data + i) = v;
#line 1359
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1394
  fclose(f);
#line 1395
  __cil_tmp39 = int_floorlog2___20(max);
#line 1395
  comp->bpp = __cil_tmp39 + 1;
  }
#line 1397
  return (image);
}
}
#line 1400 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetopgx(opj_image_t *image , char const   *outfile ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int compno ;
  FILE *fdest ;
  opj_image_comp_t *comp ;
  char bname[256] ;
  char *name ;
  int nbytes ;
  size_t res ;
  size_t olen ;
  unsigned long __cil_tmp15 ;
  size_t dotpos ;
  size_t total ;
  void *__cil_tmp18 ;
  FILE *__cil_tmp19 ;
  int tmp ;
  int v ;
  char byte ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
#line 1403
  fdest = (FILE *)((void *)0);
#line 1405
  compno = 0;
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1405
    if (! (compno < image->numcomps)) {
#line 1405
      goto while_break;
    }
    {
#line 1406
    comp = image->comps + compno;
#line 1408
    name = (char *)bname;
#line 1409
    nbytes = 0;
#line 1411
    __cil_tmp15 = strlen(outfile);
#line 1411
    olen = __cil_tmp15;
#line 1412
    dotpos = olen - 4UL;
#line 1413
    total = ((dotpos + 1UL) + 1UL) + 4UL;
    }
#line 1414
    if ((int )*(outfile + dotpos) != 46) {
      {
#line 1416
      fprintf(stderr, "ERROR -> Impossible happen.");
      }
#line 1417
      return (1);
    }
#line 1419
    if (total > 256UL) {
      {
#line 1420
      __cil_tmp18 = malloc(total + 1UL);
#line 1420
      name = (char *)__cil_tmp18;
      }
    }
    {
#line 1422
    strncpy(name, outfile, dotpos);
#line 1424
    sprintf(name + dotpos, "_%d.pgx", compno);
#line 1428
    fdest = fopen((char const   *)name, "wb\345D\262U");
    }
#line 1429
    if (! fdest) {
      {
#line 1430
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
      }
#line 1431
      return (1);
    }
#line 1434
    if (total > 256UL) {
      {
#line 1435
      free(name);
      }
    }
#line 1438
    w = (image->comps + compno)->w;
#line 1439
    h = (image->comps + compno)->h;
#line 1441
    if (comp->sgnd) {
#line 1441
      tmp = '-';
    } else {
#line 1441
      tmp = '+';
    }
    {
#line 1441
    fprintf(fdest, "PG ML %c %d %d %d\n", tmp, comp->prec, w, h);
    }
#line 1442
    if (comp->prec <= 8) {
#line 1443
      nbytes = 1;
    } else
#line 1444
    if (comp->prec <= 16) {
#line 1445
      nbytes = 2;
    } else {
#line 1447
      nbytes = 4;
    }
#line 1449
    i = 0;
    {
#line 1449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1449
      if (! (i < w * h)) {
#line 1449
        goto while_break___0;
      }
#line 1450
      v = *((image->comps + compno)->data + i);
#line 1451
      j = nbytes - 1;
      {
#line 1451
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1451
        if (! (j >= 0)) {
#line 1451
          goto while_break___1;
        }
        {
#line 1452
        byte = (char )(v >> j * 8);
#line 1453
        res = fwrite(& byte, (unsigned long )1, (unsigned long )1, fdest);
        }
#line 1454
        if (res < 1UL) {
          {
#line 1455
          fprintf(stderr, "failed to write 1 byte for %s\n", name);
          }
#line 1456
          return (1);
        }
#line 1451
        __cil_tmp24 = j;
#line 1451
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1449
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1460
    fclose(fdest);
    }
#line 1405
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1463
  return (0);
}
}
#line 1479 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 1481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1481
    if (! *s) {
#line 1481
      goto while_break;
    }
#line 1483
    if ((int )*s == 10) {
#line 1483
      return ((char *)((void *)0));
    } else
#line 1483
    if ((int )*s == 13) {
#line 1483
      return ((char *)((void *)0));
    }
    {
#line 1484
    __cil_tmp2 = __ctype_b_loc();
    }
#line 1484
    if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1484
      s ++;
#line 1484
      goto while_continue;
    }
#line 1485
    return (s);
  }
  while_break: /* CIL Label */ ;
  }
#line 1487
  return ((char *)((void *)0));
}
}
#line 1490 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_int(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1495
  *out_n = 0;
#line 1495
  s = start;
#line 1497
  s = skip_white(start);
  }
#line 1498
  if (s == (void *)0) {
#line 1498
    return ((char *)((void *)0));
  }
#line 1499
  start = s;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (! *s) {
#line 1501
      goto while_break;
    }
    {
#line 1503
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1503
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1503
      goto while_break;
    }
#line 1504
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1506
  c = *s;
#line 1506
  *s = (char )0;
#line 1506
  *out_n = atoi((char const   *)start);
#line 1506
  *s = c;
  }
#line 1507
  return (s);
}
}
#line 1510 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_idf(char *start , char out_idf[256] ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1515
  s = skip_white(start);
  }
#line 1516
  if (s == (void *)0) {
#line 1516
    return ((char *)((void *)0));
  }
#line 1517
  start = s;
  {
#line 1519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1519
    if (! *s) {
#line 1519
      goto while_break;
    }
    {
#line 1521
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1521
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    } else
#line 1521
    if ((int )*s == 95) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    }
#line 1522
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1524
  c = *s;
#line 1524
  *s = (char )0;
#line 1524
  strncpy(out_idf, (char const   *)start, (unsigned long )255);
#line 1524
  *s = c;
  }
#line 1525
  return (s);
}
}
#line 1528 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static void read_pnm_header(FILE *reader , struct pnm_header *ph ) 
{ 
  char *s ;
  int format ;
  int have_wh ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 1535
  __cil_tmp11 = fgets((char *)line, 250, reader);
  }
#line 1535
  if (__cil_tmp11 == (void *)0) {
    {
#line 1537
    fprintf(stderr, "\nWARNING: fgets return a NULL valueD\262U");
    }
#line 1538
    return;
  }
#line 1541
  if ((int )line[0] != 80) {
    {
#line 1543
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
    }
#line 1543
    return;
  }
  {
#line 1545
  format = atoi((char const   *)((char *)line + 1));
  }
#line 1546
  if (format < 1) {
    {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1549
    return;
  } else
#line 1546
  if (format > 7) {
    {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1549
    return;
  }
#line 1551
  ph->format = format;
#line 1552
  have_wh = 0;
#line 1552
  end = have_wh;
#line 1552
  ttype = end;
  {
#line 1554
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1554
    __cil_tmp13 = fgets((char *)line, 250, reader);
    }
#line 1554
    if (! __cil_tmp13) {
#line 1554
      goto while_break;
    }
#line 1556
    if ((int )*((char *)line) == 35) {
#line 1556
      goto while_continue;
    }
#line 1558
    s = (char *)line;
#line 1560
    if (format == 7) {
      {
#line 1562
      s = skip_idf(s, (char *)idf);
      }
#line 1564
      if (s == (void *)0) {
#line 1564
        return;
      } else
#line 1564
      if ((int )*s == 0) {
#line 1564
        return;
      }
      {
#line 1566
      __cil_tmp15 = strcmp((char const   *)((char *)idf), "ENDHDR");
      }
#line 1566
      if (__cil_tmp15 == 0) {
#line 1568
        end = 1;
#line 1568
        goto while_break;
      }
      {
#line 1570
      __cil_tmp16 = strcmp((char const   *)((char *)idf), "WIDTHU");
      }
#line 1570
      if (__cil_tmp16 == 0) {
        {
#line 1572
        s = skip_int(s, & ph->width);
        }
#line 1573
        if (s == (void *)0) {
#line 1573
          return;
        } else
#line 1573
        if ((int )*s == 0) {
#line 1573
          return;
        }
#line 1575
        goto while_continue;
      }
      {
#line 1577
      __cil_tmp18 = strcmp((char const   *)((char *)idf), "HEIGHT");
      }
#line 1577
      if (__cil_tmp18 == 0) {
        {
#line 1579
        s = skip_int(s, & ph->height);
        }
#line 1580
        if (s == (void *)0) {
#line 1580
          return;
        } else
#line 1580
        if ((int )*s == 0) {
#line 1580
          return;
        }
#line 1582
        goto while_continue;
      }
      {
#line 1584
      __cil_tmp20 = strcmp((char const   *)((char *)idf), "DEPTHU");
      }
#line 1584
      if (__cil_tmp20 == 0) {
        {
#line 1586
        s = skip_int(s, & ph->depth);
        }
#line 1587
        if (s == (void *)0) {
#line 1587
          return;
        } else
#line 1587
        if ((int )*s == 0) {
#line 1587
          return;
        }
#line 1589
        goto while_continue;
      }
      {
#line 1591
      __cil_tmp22 = strcmp((char const   *)((char *)idf), "MAXVAL");
      }
#line 1591
      if (__cil_tmp22 == 0) {
        {
#line 1593
        s = skip_int(s, & ph->maxval);
        }
#line 1594
        if (s == (void *)0) {
#line 1594
          return;
        } else
#line 1594
        if ((int )*s == 0) {
#line 1594
          return;
        }
#line 1596
        goto while_continue;
      }
      {
#line 1598
      __cil_tmp24 = strcmp((char const   *)((char *)idf), "TUPLTYPE\220");
      }
#line 1598
      if (__cil_tmp24 == 0) {
        {
#line 1600
        s = skip_idf(s, (char *)type);
        }
#line 1601
        if (s == (void *)0) {
#line 1601
          return;
        } else
#line 1601
        if ((int )*s == 0) {
#line 1601
          return;
        }
        {
#line 1603
        __cil_tmp26 = strcmp((char const   *)((char *)type), "BLACKANDWHITE");
        }
#line 1603
        if (__cil_tmp26 == 0) {
#line 1605
          ph->bw = (char )1;
#line 1605
          ttype = 1;
#line 1605
          goto while_continue;
        }
        {
#line 1607
        __cil_tmp27 = strcmp((char const   *)((char *)type), "GRAYSCALE\223");
        }
#line 1607
        if (__cil_tmp27 == 0) {
#line 1609
          ph->gray = (char )1;
#line 1609
          ttype = 1;
#line 1609
          goto while_continue;
        }
        {
#line 1611
        __cil_tmp28 = strcmp((char const   *)((char *)type), "GRAYSCALE_ALPHA");
        }
#line 1611
        if (__cil_tmp28 == 0) {
#line 1613
          ph->graya = (char )1;
#line 1613
          ttype = 1;
#line 1613
          goto while_continue;
        }
        {
#line 1615
        __cil_tmp29 = strcmp((char const   *)((char *)type), "RGB");
        }
#line 1615
        if (__cil_tmp29 == 0) {
#line 1617
          ph->rgb = (char )1;
#line 1617
          ttype = 1;
#line 1617
          goto while_continue;
        }
        {
#line 1619
        __cil_tmp30 = strcmp((char const   *)((char *)type), "RGB_ALPHA\001");
        }
#line 1619
        if (__cil_tmp30 == 0) {
#line 1621
          ph->rgba = (char )1;
#line 1621
          ttype = 1;
#line 1621
          goto while_continue;
        }
        {
#line 1623
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", (char *)type);
        }
#line 1624
        return;
      }
      {
#line 1626
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n\001", (char *)idf);
      }
#line 1627
      return;
    }
#line 1630
    if (! have_wh) {
      {
#line 1632
      s = skip_int(s, & ph->width);
#line 1634
      s = skip_int(s, & ph->height);
#line 1636
      have_wh = 1;
      }
#line 1638
      if (format == 1) {
#line 1638
        goto while_break;
      } else
#line 1638
      if (format == 4) {
#line 1638
        goto while_break;
      }
#line 1640
      goto while_continue;
    }
#line 1642
    if (format == 2) {
      _L: /* CIL Label */ 
      _L___36: /* CIL Label */ 
      _L___37: /* CIL Label */ 
      {
#line 1645
      s = skip_int(s, & ph->maxval);
      }
#line 1647
      if (ph->maxval > 65535) {
#line 1647
        return;
      }
    } else
#line 1642
    if (format == 3) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 5) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 6) {
#line 1642
      goto _L;
    }
#line 1649
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1651
  if (format == 2) {
    _L___38: /* CIL Label */ 
    _L___39: /* CIL Label */ 
#line 1653
    if (ph->maxval < 1) {
#line 1653
      return;
    } else
#line 1653
    if (ph->maxval > 65535) {
#line 1653
      return;
    }
  } else
#line 1651
  if (format == 3) {
#line 1651
    goto _L___38;
  } else
#line 1651
  if (format > 4) {
#line 1651
    goto _L___38;
  }
#line 1655
  if (ph->width < 1) {
#line 1655
    return;
  } else
#line 1655
  if (ph->height < 1) {
#line 1655
    return;
  }
#line 1657
  if (format == 7) {
#line 1659
    if (! end) {
      {
#line 1661
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1661
      return;
    }
#line 1663
    if (ph->depth < 1) {
#line 1663
      return;
    } else
#line 1663
    if (ph->depth > 4) {
#line 1663
      return;
    }
#line 1665
    if (ph->width) {
#line 1665
      if (ph->height) {
#line 1665
        if (ph->depth & ph->maxval) {
#line 1665
          if (ttype) {
#line 1666
            ph->ok = (char )1;
          }
        }
      }
    }
  } else
#line 1670
  if (format != 1) {
#line 1670
    if (format != 4) {
#line 1672
      if (ph->width) {
#line 1672
        if (ph->height) {
#line 1672
          if (ph->maxval) {
#line 1672
            ph->ok = (char )1;
          }
        }
      }
    } else {
#line 1670
      goto _L___40;
    }
  } else {
    _L___40: /* CIL Label */ 
#line 1676
    if (ph->width) {
#line 1676
      if (ph->height) {
#line 1676
        ph->ok = (char )1;
      }
    }
#line 1677
    ph->maxval = 255;
  }
  return;
}
}
#line 1682 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int has_prec(int val ) 
{ 


  {
#line 1684
  if (val < 2) {
#line 1684
    return (1);
  }
#line 1685
  if (val < 4) {
#line 1685
    return (2);
  }
#line 1686
  if (val < 8) {
#line 1686
    return (3);
  }
#line 1687
  if (val < 16) {
#line 1687
    return (4);
  }
#line 1688
  if (val < 32) {
#line 1688
    return (5);
  }
#line 1689
  if (val < 64) {
#line 1689
    return (6);
  }
#line 1690
  if (val < 128) {
#line 1690
    return (7);
  }
#line 1691
  if (val < 256) {
#line 1691
    return (8);
  }
#line 1692
  if (val < 512) {
#line 1692
    return (9);
  }
#line 1693
  if (val < 1024) {
#line 1693
    return (10);
  }
#line 1694
  if (val < 2048) {
#line 1694
    return (11);
  }
#line 1695
  if (val < 4096) {
#line 1695
    return (12);
  }
#line 1696
  if (val < 8192) {
#line 1696
    return (13);
  }
#line 1697
  if (val < 16384) {
#line 1697
    return (14);
  }
#line 1698
  if (val < 32768) {
#line 1698
    return (15);
  }
#line 1699
  return (16);
}
}
#line 1702 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *pnmtoimage(char const   *filename , opj_cparameters_t *parameters ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *fp ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  int prec ;
  int format ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t cmptparm[4] ;
  opj_image_t *image ;
  struct pnm_header header_info ;
  FILE *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  opj_image_t *__cil_tmp20 ;
  unsigned int index___41 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned char c0 ;
  unsigned char c1 ;
  unsigned char one ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned int index___42 ;
  int __cil_tmp33 ;
  int tmp ;
  int __cil_tmp35 ;
  int x ;
  int y ;
  int bit ;
  unsigned char uc ;
  int __cil_tmp40 ;
  int tmp___0 ;
  unsigned char uc___0 ;
  unsigned long __cil_tmp43 ;
  int tmp___1 ;

  {
  {
#line 1703
  subsampling_dx = parameters->subsampling_dx;
#line 1704
  subsampling_dy = parameters->subsampling_dy;
#line 1706
  fp = (FILE *)((void *)0);
#line 1710
  image = (opj_image_t *)((void *)0);
#line 1713
  fp = fopen(filename, "rb");
  }
#line 1713
  if (fp == (void *)0) {
    {
#line 1715
    fprintf(stderr, "pnmtoimage:Failed to open %s for reading!\n", filename);
    }
#line 1716
    return ((opj_image_t *)((void *)0));
  }
  {
#line 1718
  memset(& header_info, 0, sizeof(struct pnm_header ));
#line 1720
  read_pnm_header(fp, & header_info);
  }
#line 1722
  if (! header_info.ok) {
    {
#line 1722
    fclose(fp);
    }
#line 1722
    return ((opj_image_t *)((void *)0));
  }
#line 1724
  format = header_info.format;
  {
#line 1729
  if (format == 4) {
#line 1729
    goto case_4;
  }
#line 1729
  if (format == 1) {
#line 1729
    goto case_4;
  }
#line 1734
  if (format == 5) {
#line 1734
    goto case_5;
  }
#line 1734
  if (format == 2) {
#line 1734
    goto case_5;
  }
#line 1739
  if (format == 6) {
#line 1739
    goto case_6;
  }
#line 1739
  if (format == 3) {
#line 1739
    goto case_6;
  }
#line 1743
  if (format == 7) {
#line 1743
    goto case_7;
  }
#line 1747
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1730
  numcomps = 1;
#line 1731
  goto switch_break;
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1735
  numcomps = 1;
#line 1736
  goto switch_break;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1740
  numcomps = 3;
#line 1741
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1744
  numcomps = header_info.depth;
#line 1745
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1747
  fclose(fp);
  }
#line 1747
  return ((opj_image_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 1749
  if (numcomps < 3) {
#line 1750
    color_space = (OPJ_COLOR_SPACE )2;
  } else {
#line 1752
    color_space = (OPJ_COLOR_SPACE )1;
  }
  {
#line 1754
  prec = has_prec(header_info.maxval);
  }
#line 1756
  if (prec < 8) {
#line 1756
    prec = 8;
  }
  {
#line 1758
  w = header_info.width;
#line 1759
  h = header_info.height;
#line 1760
  subsampling_dx = parameters->subsampling_dx;
#line 1761
  subsampling_dy = parameters->subsampling_dy;
#line 1763
  memset(& cmptparm[0], 0, (unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 1765
  i = 0;
  }
  {
#line 1765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1765
    if (! (i < numcomps)) {
#line 1765
      goto while_break;
    }
#line 1767
    cmptparm[i].prec = prec;
#line 1768
    cmptparm[i].bpp = prec;
#line 1769
    cmptparm[i].sgnd = 0;
#line 1770
    cmptparm[i].dx = subsampling_dx;
#line 1771
    cmptparm[i].dy = subsampling_dy;
#line 1772
    cmptparm[i].w = w;
#line 1773
    cmptparm[i].h = h;
#line 1765
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1775
  image = opj_image_create(numcomps, & cmptparm[0], color_space);
  }
#line 1777
  if (! image) {
    {
#line 1777
    fclose(fp);
    }
#line 1777
    return ((opj_image_t *)((void *)0));
  }
#line 1780
  image->x0 = parameters->image_offset_x0;
#line 1781
  image->y0 = parameters->image_offset_y0;
#line 1782
  image->x1 = (parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1;
#line 1783
  image->y1 = (parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1;
#line 1785
  if (format == 2) {
    _L___45: /* CIL Label */ 
#line 1789
    i = 0;
    {
#line 1789
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1789
      if (! (i < w * h)) {
#line 1789
        goto while_break___0;
      }
#line 1791
      compno = 0;
      {
#line 1791
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1791
        if (! (compno < numcomps)) {
#line 1791
          goto while_break___1;
        }
        {
#line 1793
        index___41 = (unsigned int )0;
#line 1794
        __cil_tmp22 = fscanf(fp, "%u", & index___41);
        }
#line 1794
        if (__cil_tmp22 != 1) {
          {
#line 1795
          fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
          }
        }
#line 1797
        *((image->comps + compno)->data + i) = (int )((index___41 * 255U) / (unsigned int )header_info.maxval);
#line 1791
        compno ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1789
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 1785
  if (format == 3) {
#line 1785
    goto _L___45;
  } else
#line 1802
  if (format == 5) {
    _L: /* CIL Label */ 
    _L___44: /* CIL Label */ 
#line 1810
    one = (unsigned char )(prec < 9);
#line 1812
    i = 0;
    {
#line 1812
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1812
      if (! (i < w * h)) {
#line 1812
        goto while_break___2;
      }
#line 1814
      compno = 0;
      {
#line 1814
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1814
        if (! (compno < numcomps)) {
#line 1814
          goto while_break___3;
        }
        {
#line 1816
        __cil_tmp28 = fread(& c0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1816
        if (! __cil_tmp28) {
          {
#line 1817
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 1818
        if (one) {
#line 1820
          *((image->comps + compno)->data + i) = (int )c0;
        } else {
          {
#line 1824
          __cil_tmp29 = fread(& c1, (unsigned long )1, (unsigned long )1, fp);
          }
#line 1824
          if (! __cil_tmp29) {
            {
#line 1825
            fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
            }
          }
#line 1827
          *((image->comps + compno)->data + i) = ((int )c0 << 8) | (int )c1;
        }
#line 1814
        compno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1812
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 1802
  if (format == 6) {
#line 1802
    goto _L;
  } else
#line 1802
  if (format == 7) {
#line 1802
    if ((int )header_info.gray) {
#line 1802
      goto _L;
    } else
#line 1802
    if ((int )header_info.graya) {
#line 1802
      goto _L;
    } else
#line 1802
    if ((int )header_info.rgb) {
#line 1802
      goto _L;
    } else
#line 1802
    if ((int )header_info.rgba) {
#line 1802
      goto _L;
    } else {
#line 1802
      goto _L___43;
    }
  } else
  _L___43: /* CIL Label */ 
#line 1833
  if (format == 1) {
#line 1835
    i = 0;
    {
#line 1835
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1835
      if (! (i < w * h)) {
#line 1835
        goto while_break___4;
      }
      {
#line 1839
      __cil_tmp33 = fscanf(fp, "%u", & index___42);
      }
#line 1839
      if (__cil_tmp33 != 1) {
        {
#line 1840
        fprintf(stderr, "\nWARNING: fscanf return a number of element different from the expected.\n");
        }
      }
#line 1842
      if (index___42) {
#line 1842
        tmp = 0;
      } else {
#line 1842
        tmp = 255;
      }
#line 1842
      *((image->comps + 0)->data + i) = tmp;
#line 1835
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 1846
  if (format == 4) {
#line 1851
    i = 0;
#line 1852
    y = 0;
    {
#line 1852
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1852
      if (! (y < h)) {
#line 1852
        goto while_break___5;
      }
#line 1854
      bit = - 1;
#line 1854
      uc = (unsigned char )0;
#line 1856
      x = 0;
      {
#line 1856
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1856
        if (! (x < w)) {
#line 1856
          goto while_break___6;
        }
#line 1858
        if (bit == -1) {
          {
#line 1860
          bit = 7;
#line 1861
          __cil_tmp40 = getc(fp);
#line 1861
          uc = (unsigned char )__cil_tmp40;
          }
        }
#line 1863
        if (((int )uc >> bit) & 1) {
#line 1863
          tmp___0 = 0;
        } else {
#line 1863
          tmp___0 = 255;
        }
#line 1863
        *((image->comps + 0)->data + i) = tmp___0;
#line 1864
        bit --;
#line 1864
        i ++;
#line 1856
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1852
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 1869
  if (format == 7) {
#line 1869
    if ((int )header_info.bw) {
#line 1873
      i = 0;
      {
#line 1873
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1873
        if (! (i < w * h)) {
#line 1873
          goto while_break___7;
        }
        {
#line 1875
        __cil_tmp43 = fread(& uc___0, (unsigned long )1, (unsigned long )1, fp);
        }
#line 1875
        if (! __cil_tmp43) {
          {
#line 1876
          fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
          }
        }
#line 1877
        if ((int )uc___0 & 1) {
#line 1877
          tmp___1 = 0;
        } else {
#line 1877
          tmp___1 = 255;
        }
#line 1877
        *((image->comps + 0)->data + i) = tmp___1;
#line 1873
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  {
#line 1880
  fclose(fp);
  }
#line 1882
  return (image);
}
}
#line 1885 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetopnm(opj_image_t *image , char const   *outfile ) 
{ 
  int *red ;
  int *green ;
  int *blue ;
  int *alpha ;
  int wr ;
  int hr ;
  int max ;
  int i ;
  int compno ;
  int ncomp ;
  int adjustR ;
  int adjustG ;
  int adjustB ;
  int adjustA ;
  int fails ;
  int two ;
  int want_gray ;
  int has_alpha ;
  int triple ;
  int prec ;
  int v ;
  FILE *fdest ;
  char const   *tmp ;
  char *destname ;
  FILE *__cil_tmp27 ;
  char const   *tt ;
  char const   *tmp___46 ;
  char const   *__cil_tmp30 ;
  int tmp___47 ;
  char const   *__cil_tmp32 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int *__cil_tmp36 ;
  int *__cil_tmp37 ;
  int *__cil_tmp38 ;
  int *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  void *__cil_tmp41 ;
  FILE *__cil_tmp42 ;
  char const   *__cil_tmp43 ;
  int tmp___51 ;
  int *__cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;

  {
#line 1893
  fdest = (FILE *)((void *)0);
#line 1894
  tmp = outfile;
#line 1896
  alpha = (int *)((void *)0);
#line 1897
  prec = (image->comps + 0)->prec;
#line 1897
  if (prec > 16) {
    {
#line 1899
    fprintf(stderr, "%s:%d:imagetopnm\n\tprecision %d is larger than 16\n\t: refused.\n",
            "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c", 1900,
            prec);
    }
#line 1901
    return (1);
  }
#line 1903
  has_alpha = 0;
#line 1903
  two = has_alpha;
#line 1903
  fails = 1;
#line 1904
  ncomp = image->numcomps;
  {
#line 1906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1906
    if (! *tmp) {
#line 1906
      goto while_break;
    }
#line 1906
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1906
  tmp -= 2;
#line 1907
  want_gray = (int )*tmp == 103 || (int )*tmp == 71;
#line 1908
  ncomp = image->numcomps;
#line 1910
  if (want_gray) {
#line 1910
    ncomp = 1;
  }
#line 1912
  if (ncomp == 2) {
    _L: /* CIL Label */ 
    {
#line 1922
    fdest = fopen(outfile, "wb\346D\262U");
    }
#line 1924
    if (! fdest) {
      {
#line 1926
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
      }
#line 1927
      return (fails);
    }
#line 1929
    two = prec > 8;
#line 1930
    triple = ncomp > 2;
#line 1931
    wr = (image->comps + 0)->w;
#line 1931
    hr = (image->comps + 0)->h;
#line 1932
    max = (1 << prec) - 1;
#line 1932
    has_alpha = ncomp == 4 || ncomp == 2;
#line 1934
    red = (image->comps + 0)->data;
#line 1936
    if (triple) {
#line 1938
      green = (image->comps + 1)->data;
#line 1939
      blue = (image->comps + 2)->data;
    } else {
#line 1941
      blue = (int *)((void *)0);
#line 1941
      green = blue;
    }
#line 1943
    if (has_alpha) {
#line 1945
      if (triple) {
#line 1945
        tmp___46 = "RGB_ALPHA";
      } else {
#line 1945
        tmp___46 = "GRAYSCALE_ALPHA";
      }
      {
#line 1945
      tt = tmp___46;
#line 1947
      __cil_tmp30 = opj_version();
#line 1947
      fprintf(fdest, "P7\n# OpenJPEG-%s\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
              __cil_tmp30, wr, hr, ncomp, max, tt);
#line 1950
      alpha = (image->comps + (ncomp - 1))->data;
      }
#line 1951
      if ((image->comps + (ncomp - 1))->sgnd) {
#line 1951
        tmp___47 = 1 << ((image->comps + (ncomp - 1))->prec - 1);
      } else {
#line 1951
        tmp___47 = 0;
      }
#line 1951
      adjustA = tmp___47;
    } else {
      {
#line 1956
      __cil_tmp32 = opj_version();
#line 1956
      fprintf(fdest, "P6\n# OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp32, wr, hr, max);
#line 1958
      adjustA = 0;
      }
    }
#line 1960
    if ((image->comps + 0)->sgnd) {
#line 1960
      tmp___48 = 1 << ((image->comps + 0)->prec - 1);
    } else {
#line 1960
      tmp___48 = 0;
    }
#line 1960
    adjustR = tmp___48;
#line 1962
    if (triple) {
#line 1964
      if ((image->comps + 1)->sgnd) {
#line 1964
        tmp___49 = 1 << ((image->comps + 1)->prec - 1);
      } else {
#line 1964
        tmp___49 = 0;
      }
#line 1964
      adjustG = tmp___49;
#line 1965
      if ((image->comps + 2)->sgnd) {
#line 1965
        tmp___50 = 1 << ((image->comps + 2)->prec - 1);
      } else {
#line 1965
        tmp___50 = 0;
      }
#line 1965
      adjustB = tmp___50;
    } else {
#line 1967
      adjustB = 0;
#line 1967
      adjustG = adjustB;
    }
#line 1969
    i = 0;
    {
#line 1969
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1969
      if (! (i < wr * hr)) {
#line 1969
        goto while_break___0;
      }
#line 1971
      if (two) {
        {
#line 1973
        v = *red + adjustR;
#line 1973
        red ++;
#line 1975
        fprintf(fdest, "%c%c\262U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 1977
        if (triple) {
          {
#line 1979
          v = *green + adjustG;
#line 1979
          green ++;
#line 1981
          fprintf(fdest, "%c%c\262U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
#line 1983
          v = *blue + adjustB;
#line 1983
          blue ++;
#line 1985
          fprintf(fdest, "%c%c\262U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 1989
        if (has_alpha) {
          {
#line 1991
          v = *alpha + adjustA;
#line 1991
          alpha ++;
#line 1993
          fprintf(fdest, "%c%c\262U", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 1995
        goto while_continue___0;
      }
      {
#line 2001
      __cil_tmp36 = red;
#line 2001
      red ++;
#line 2001
      fprintf(fdest, "%c", (int )((unsigned char )*__cil_tmp36));
      }
#line 2002
      if (triple) {
#line 2003
        __cil_tmp37 = green;
#line 2003
        green ++;
        {
#line 2003
        __cil_tmp38 = blue;
#line 2003
        blue ++;
#line 2003
        fprintf(fdest, "%c%c\262U", (int )((unsigned char )*__cil_tmp37), (int )((unsigned char )*__cil_tmp38));
        }
      }
#line 2005
      if (has_alpha) {
        {
#line 2006
        __cil_tmp39 = alpha;
#line 2006
        alpha ++;
#line 2006
        fprintf(fdest, "%c\346D\262U", (int )((unsigned char )*__cil_tmp39));
        }
      }
#line 1969
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2010
    fclose(fdest);
    }
#line 2010
    return (0);
  } else
#line 1912
  if (ncomp > 2) {
#line 1912
    if ((image->comps + 0)->dx == (image->comps + 1)->dx) {
#line 1912
      if ((image->comps + 1)->dx == (image->comps + 2)->dx) {
#line 1912
        if ((image->comps + 0)->dy == (image->comps + 1)->dy) {
#line 1912
          if ((image->comps + 1)->dy == (image->comps + 2)->dy) {
#line 1912
            if ((image->comps + 0)->prec == (image->comps + 1)->prec) {
#line 1912
              if ((image->comps + 1)->prec == (image->comps + 2)->prec) {
#line 1912
                goto _L;
              }
            }
          }
        }
      }
    }
  }
#line 2015
  if (image->numcomps > ncomp) {
    {
#line 2017
    fprintf(stderr, "WARNING -> [PGM file] Only the first component\n");
#line 2018
    fprintf(stderr, "           is written to the file\n");
    }
  }
  {
#line 2020
  __cil_tmp40 = strlen(outfile);
#line 2020
  __cil_tmp41 = malloc(__cil_tmp40 + 8UL);
#line 2020
  destname = (char *)__cil_tmp41;
#line 2022
  compno = 0;
  }
  {
#line 2022
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2022
    if (! (compno < ncomp)) {
#line 2022
      goto while_break___1;
    }
#line 2024
    if (ncomp > 1) {
      {
#line 2025
      sprintf(destname, "%d.%s", compno, outfile);
      }
    } else {
      {
#line 2027
      sprintf(destname, "%s", outfile);
      }
    }
    {
#line 2029
    fdest = fopen((char const   *)destname, "wb");
    }
#line 2030
    if (! fdest) {
      {
#line 2032
      fprintf(stderr, "ERROR -> failed to open %s for writing\n", destname);
#line 2033
      free(destname);
      }
#line 2034
      return (1);
    }
    {
#line 2036
    wr = (image->comps + compno)->w;
#line 2036
    hr = (image->comps + compno)->h;
#line 2037
    prec = (image->comps + compno)->prec;
#line 2038
    max = (1 << prec) - 1;
#line 2040
    __cil_tmp43 = opj_version();
#line 2040
    fprintf(fdest, "P5\n#OpenJPEG-%s\n%d %d\n%d\n", __cil_tmp43, wr, hr, max);
#line 2043
    red = (image->comps + compno)->data;
    }
#line 2044
    if ((image->comps + compno)->sgnd) {
#line 2044
      tmp___51 = 1 << ((image->comps + compno)->prec - 1);
    } else {
#line 2044
      tmp___51 = 0;
    }
#line 2044
    adjustR = tmp___51;
#line 2047
    if (prec > 8) {
#line 2049
      i = 0;
      {
#line 2049
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2049
        if (! (i < wr * hr)) {
#line 2049
          goto while_break___2;
        }
        {
#line 2051
        v = *red + adjustR;
#line 2051
        red ++;
#line 2053
        fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
        }
#line 2055
        if (has_alpha) {
          {
#line 2057
          __cil_tmp45 = alpha;
#line 2057
          alpha ++;
#line 2057
          v = *__cil_tmp45;
#line 2059
          fprintf(fdest, "%c%c", (int )((unsigned char )(v >> 8)), (int )((unsigned char )v));
          }
        }
#line 2049
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 2065
      i = 0;
      {
#line 2065
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2065
        if (! (i < wr * hr)) {
#line 2065
          goto while_break___3;
        }
        {
#line 2067
        fprintf(fdest, "%c\347D\262U", (int )((unsigned char )(*red + adjustR)));
#line 2067
        red ++;
        }
#line 2065
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 2070
    fclose(fdest);
    }
#line 2022
    compno ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2072
  free(destname);
  }
#line 2074
  return (0);
}
}
#line 2792 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
opj_image_t *rawtoimage(char const   *filename , opj_cparameters_t *parameters , raw_cparameters_t *raw_cp ) 
{ 
  int subsampling_dx ;
  int subsampling_dy ;
  FILE *f ;
  int i ;
  int compno ;
  int numcomps ;
  int w ;
  int h ;
  OPJ_COLOR_SPACE color_space ;
  opj_image_cmptparm_t *cmptparm ;
  opj_image_t *image ;
  unsigned short ch ;
  FILE *__cil_tmp16 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  opj_image_t *__cil_tmp19 ;
  unsigned char value ;
  unsigned long __cil_tmp21 ;
  int tmp ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  unsigned short value___0 ;
  unsigned char temp ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int tmp___0 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;

  {
#line 2793
  subsampling_dx = parameters->subsampling_dx;
#line 2794
  subsampling_dy = parameters->subsampling_dy;
#line 2796
  f = (FILE *)((void *)0);
#line 2800
  image = (opj_image_t *)((void *)0);
#line 2803
  if (! (((raw_cp->rawWidth & raw_cp->rawHeight) & raw_cp->rawComp) & raw_cp->rawBitDepth) == 0) {
    {
#line 2805
    fprintf(stderr, "\nError: invalid raw image parameters\nU");
#line 2806
    fprintf(stderr, "Please use the Format option -F:\n\220\346D\262U");
#line 2807
    fprintf(stderr, "-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n\220");
#line 2808
    fprintf(stderr, "Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
#line 2809
    fprintf(stderr, "Aborting\n");
    }
#line 2810
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2813
  f = fopen(filename, "rb");
  }
#line 2814
  if (! f) {
    {
#line 2815
    fprintf(stderr, "Failed to open %s for reading !!\n\316\347D\262U", filename);
#line 2816
    fprintf(stderr, "Aborting\n\315\347D\262U");
    }
#line 2817
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2819
  numcomps = raw_cp->rawComp;
#line 2820
  color_space = (OPJ_COLOR_SPACE )1;
#line 2821
  w = raw_cp->rawWidth;
#line 2822
  h = raw_cp->rawHeight;
#line 2823
  __cil_tmp17 = malloc((unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 2823
  cmptparm = (opj_image_cmptparm_t *)__cil_tmp17;
#line 2826
  memset(cmptparm + 0, 0, (unsigned long )numcomps * sizeof(opj_image_cmptparm_t ));
#line 2827
  i = 0;
  }
  {
#line 2827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2827
    if (! (i < numcomps)) {
#line 2827
      goto while_break;
    }
#line 2828
    (cmptparm + i)->prec = raw_cp->rawBitDepth;
#line 2829
    (cmptparm + i)->bpp = raw_cp->rawBitDepth;
#line 2830
    (cmptparm + i)->sgnd = raw_cp->rawSigned;
#line 2831
    (cmptparm + i)->dx = subsampling_dx;
#line 2832
    (cmptparm + i)->dy = subsampling_dy;
#line 2833
    (cmptparm + i)->w = w;
#line 2834
    (cmptparm + i)->h = h;
#line 2827
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2837
  image = opj_image_create(numcomps, cmptparm + 0, color_space);
  }
#line 2838
  if (! image) {
    {
#line 2839
    fclose(f);
    }
#line 2840
    return ((opj_image_t *)((void *)0));
  }
#line 2843
  image->x0 = parameters->image_offset_x0;
#line 2844
  image->y0 = parameters->image_offset_y0;
#line 2845
  image->x1 = (parameters->image_offset_x0 + (w - 1) * subsampling_dx) + 1;
#line 2846
  image->y1 = (parameters->image_offset_y0 + (h - 1) * subsampling_dy) + 1;
#line 2848
  if (raw_cp->rawBitDepth <= 8) {
#line 2850
    value = (unsigned char )0;
#line 2851
    compno = 0;
    {
#line 2851
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2851
      if (! (compno < numcomps)) {
#line 2851
        goto while_break___0;
      }
#line 2852
      i = 0;
      {
#line 2852
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2852
        if (! (i < w * h)) {
#line 2852
          goto while_break___1;
        }
        {
#line 2853
        __cil_tmp21 = fread(& value, (unsigned long )1, (unsigned long )1, f);
        }
#line 2853
        if (! __cil_tmp21) {
          {
#line 2854
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2855
          return ((opj_image_t *)((void *)0));
        }
#line 2857
        if (raw_cp->rawSigned) {
#line 2857
          tmp = (int )((char )value);
        } else {
#line 2857
          tmp = (int )value;
        }
#line 2857
        *((image->comps + compno)->data + i) = tmp;
#line 2852
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2851
      compno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 2861
  if (raw_cp->rawBitDepth <= 16) {
#line 2864
    compno = 0;
    {
#line 2864
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2864
      if (! (compno < numcomps)) {
#line 2864
        goto while_break___2;
      }
#line 2865
      i = 0;
      {
#line 2865
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2865
        if (! (i < w * h)) {
#line 2865
          goto while_break___3;
        }
        {
#line 2867
        __cil_tmp27 = fread(& temp, (unsigned long )1, (unsigned long )1, f);
        }
#line 2867
        if (! __cil_tmp27) {
          {
#line 2868
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2869
          return ((opj_image_t *)((void *)0));
        }
        {
#line 2871
        value___0 = (unsigned short )((int )temp << 8);
#line 2872
        __cil_tmp28 = fread(& temp, (unsigned long )1, (unsigned long )1, f);
        }
#line 2872
        if (! __cil_tmp28) {
          {
#line 2873
          fprintf(stderr, "Error reading raw file. End of file probably reached.\n");
          }
#line 2874
          return ((opj_image_t *)((void *)0));
        }
#line 2876
        value___0 += (int )temp;
#line 2877
        if (raw_cp->rawSigned) {
#line 2877
          tmp___0 = (int )((short )value___0);
        } else {
#line 2877
          tmp___0 = (int )value___0;
        }
#line 2877
        *((image->comps + compno)->data + i) = tmp___0;
#line 2865
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2864
      compno ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 2882
    fprintf(stderr, "OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\n");
    }
#line 2883
    return ((opj_image_t *)((void *)0));
  }
  {
#line 2886
  __cil_tmp32 = fread(& ch, (unsigned long )1, (unsigned long )1, f);
  }
#line 2886
  if (__cil_tmp32) {
    {
#line 2887
    fprintf(stderr, "Warning. End of raw file not reached... processing anyway\n");
    }
  }
  {
#line 2889
  fclose(f);
  }
#line 2891
  return (image);
}
}
#line 2894 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
int imagetoraw(opj_image_t *image , char const   *outfile ) 
{ 
  FILE *rawFile ;
  size_t res ;
  int compno ;
  int w ;
  int h ;
  int line ;
  int row ;
  int *ptr ;
  FILE *__cil_tmp11 ;
  char const   *tmp ;
  signed char curr ;
  int mask ;
  unsigned long __cil_tmp15 ;
  int *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned char curr___0 ;
  int mask___0 ;
  unsigned long __cil_tmp21 ;
  int *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  short curr___1 ;
  int mask___1 ;
  unsigned char temp ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int *__cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned short curr___2 ;
  int mask___2 ;
  unsigned char temp___0 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;

  {
#line 2896
  rawFile = (FILE *)((void *)0);
#line 2903
  if ((image->numcomps * image->x1) * image->y1 == 0) {
    {
#line 2905
    fprintf(stderr, "\nError: invalid raw image parameters\n");
    }
#line 2906
    return (1);
  }
  {
#line 2909
  rawFile = fopen(outfile, "wb\350D\262U");
  }
#line 2910
  if (! rawFile) {
    {
#line 2911
    fprintf(stderr, "Failed to open %s for writing !!\nu\347D\262U", outfile);
    }
#line 2912
    return (1);
  }
  {
#line 2915
  fprintf(stdout, "Raw image characteristics: %d components\n", image->numcomps);
#line 2917
  compno = 0;
  }
  {
#line 2917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2917
    if (! (compno < image->numcomps)) {
#line 2917
      goto while_break;
    }
#line 2919
    if ((image->comps + compno)->sgnd == 1) {
#line 2919
      tmp = "signed";
    } else {
#line 2919
      tmp = "unsigned\220";
    }
    {
#line 2919
    fprintf(stdout, "Component %d characteristics: %dx%dx%d %s\n", compno, (image->comps + compno)->w,
            (image->comps + compno)->h, (image->comps + compno)->prec, tmp);
#line 2922
    w = (image->comps + compno)->w;
#line 2923
    h = (image->comps + compno)->h;
    }
#line 2925
    if ((image->comps + compno)->prec <= 8) {
#line 2927
      if ((image->comps + compno)->sgnd == 1) {
#line 2930
        mask = (1 << (image->comps + compno)->prec) - 1;
#line 2931
        ptr = (image->comps + compno)->data;
#line 2932
        line = 0;
        {
#line 2932
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2932
          if (! (line < h)) {
#line 2932
            goto while_break___0;
          }
#line 2933
          row = 0;
          {
#line 2933
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2933
            if (! (row < w)) {
#line 2933
              goto while_break___1;
            }
            {
#line 2934
            curr = (signed char )(*ptr & mask);
#line 2935
            res = fwrite(& curr, sizeof(signed char ), (unsigned long )1, rawFile);
            }
#line 2936
            if (res < 1UL) {
              {
#line 2937
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2938
              return (1);
            }
#line 2940
            ptr ++;
#line 2933
            row ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2932
          line ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 2944
      if ((image->comps + compno)->sgnd == 0) {
#line 2947
        mask___0 = (1 << (image->comps + compno)->prec) - 1;
#line 2948
        ptr = (image->comps + compno)->data;
#line 2949
        line = 0;
        {
#line 2949
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2949
          if (! (line < h)) {
#line 2949
            goto while_break___2;
          }
#line 2950
          row = 0;
          {
#line 2950
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2950
            if (! (row < w)) {
#line 2950
              goto while_break___3;
            }
            {
#line 2951
            curr___0 = (unsigned char )(*ptr & mask___0);
#line 2952
            res = fwrite(& curr___0, sizeof(unsigned char ), (unsigned long )1, rawFile);
            }
#line 2953
            if (res < 1UL) {
              {
#line 2954
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2955
              return (1);
            }
#line 2957
            ptr ++;
#line 2950
            row ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2949
          line ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else
#line 2962
    if ((image->comps + compno)->prec <= 16) {
#line 2964
      if ((image->comps + compno)->sgnd == 1) {
#line 2967
        mask___1 = (1 << (image->comps + compno)->prec) - 1;
#line 2968
        ptr = (image->comps + compno)->data;
#line 2969
        line = 0;
        {
#line 2969
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2969
          if (! (line < h)) {
#line 2969
            goto while_break___4;
          }
#line 2970
          row = 0;
          {
#line 2970
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 2970
            if (! (row < w)) {
#line 2970
              goto while_break___5;
            }
            {
#line 2972
            curr___1 = (short )(*ptr & mask___1);
#line 2973
            temp = (unsigned char )((int )curr___1 >> 8);
#line 2974
            res = fwrite(& temp, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 2975
            if (res < 1UL) {
              {
#line 2976
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2977
              return (1);
            }
            {
#line 2979
            temp = (unsigned char )curr___1;
#line 2980
            res = fwrite(& temp, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 2981
            if (res < 1UL) {
              {
#line 2982
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 2983
              return (1);
            }
#line 2985
            ptr ++;
#line 2970
            row ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 2969
          line ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else
#line 2989
      if ((image->comps + compno)->sgnd == 0) {
#line 2992
        mask___2 = (1 << (image->comps + compno)->prec) - 1;
#line 2993
        ptr = (image->comps + compno)->data;
#line 2994
        line = 0;
        {
#line 2994
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2994
          if (! (line < h)) {
#line 2994
            goto while_break___6;
          }
#line 2995
          row = 0;
          {
#line 2995
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2995
            if (! (row < w)) {
#line 2995
              goto while_break___7;
            }
            {
#line 2997
            curr___2 = (unsigned short )(*ptr & mask___2);
#line 2998
            temp___0 = (unsigned char )((int )curr___2 >> 8);
#line 2999
            res = fwrite(& temp___0, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 3000
            if (res < 1UL) {
              {
#line 3001
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 3002
              return (1);
            }
            {
#line 3004
            temp___0 = (unsigned char )curr___2;
#line 3005
            res = fwrite(& temp___0, (unsigned long )1, (unsigned long )1, rawFile);
            }
#line 3006
            if (res < 1UL) {
              {
#line 3007
              fprintf(stderr, "failed to write 1 byte for %s\n", outfile);
              }
#line 3008
              return (1);
            }
#line 3010
            ptr ++;
#line 2995
            row ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 2994
          line ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    } else
#line 3015
    if ((image->comps + compno)->prec <= 32) {
      {
#line 3017
      fprintf(stderr, "More than 16 bits per component no handled yet\n");
      }
#line 3018
      return (1);
    } else {
      {
#line 3022
      fprintf(stderr, "Error: invalid precision: %d\nU", (image->comps + compno)->prec);
      }
#line 3023
      return (1);
    }
#line 2917
    compno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3026
  fclose(rawFile);
  }
#line 3027
  return (0);
}
}
#line 45 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
int opj_opterr  =    1;
#line 46 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
int opj_optind  =    1;
#line 53 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
static char EMSG[1]  = {      "\250"};
#line 56 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
void reset_options_reading(void) 
{ 


  {
#line 57
  opj_opterr = 1;
#line 58
  opj_optind = 1;
  return;
}
}
#line 65 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
int opj_getopt(int nargc , char * const  *nargv , char const   *ostr ) 
{ 
  static char *place ;
  char *oli ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 67
  place = (char *)EMSG;
#line 68
  oli = (char *)((void *)0);
#line 70
  if (opj_optreset) {
    _L: /* CIL Label */ 
#line 71
    opj_optreset = 0;
#line 72
    place = *(nargv + opj_optind);
#line 72
    if (opj_optind >= nargc) {
#line 73
      place = (char *)EMSG;
#line 74
      return (- 1);
    } else
#line 72
    if ((int )*place != 45) {
#line 73
      place = (char *)EMSG;
#line 74
      return (- 1);
    }
#line 76
    place ++;
#line 76
    if ((int )*(place + 1)) {
#line 76
      if ((int )*place == 45) {
#line 77
        opj_optind ++;
#line 78
        place = (char *)EMSG;
#line 79
        return (- 1);
      }
    }
  } else
#line 70
  if (! *place) {
#line 70
    goto _L;
  }
  {
#line 82
  oli = strchr(ostr, opj_optopt);
  }
#line 82
  __cil_tmp6 = place;
#line 82
  place ++;
#line 82
  opj_optopt = (int )*__cil_tmp6;
#line 82
  if (! oli) {
    _L___52: /* CIL Label */ 
#line 88
    if (opj_optopt == 45) {
#line 89
      return (- 1);
    }
#line 90
    if (! *place) {
#line 91
      opj_optind ++;
    }
#line 92
    if (opj_opterr) {
#line 92
      if ((int )*ostr != 58) {
        {
#line 93
        fprintf(stderr, "%s: illegal option -- %c\n\331\364D\262U", *(nargv + 0),
                opj_optopt);
        }
#line 95
        return ((int )'?');
      }
    }
  } else
#line 82
  if (opj_optopt == 58) {
#line 82
    goto _L___52;
  }
#line 98
  oli ++;
#line 98
  if ((int )*oli != 58) {
#line 99
    opj_optarg = (char *)((void *)0);
#line 100
    if (! *place) {
#line 101
      opj_optind ++;
    }
  } else {
#line 103
    if (*place) {
#line 104
      opj_optarg = place;
    } else {
#line 105
      opj_optind ++;
#line 105
      if (nargc <= opj_optind) {
#line 106
        place = (char *)EMSG;
#line 107
        if ((int )*ostr == 58) {
#line 108
          return ((int )':');
        }
#line 109
        if (opj_opterr) {
          {
#line 110
          fprintf(stderr, "%s: option requires an argument -- %c\n", *(nargv + 0),
                  opj_optopt);
          }
#line 113
          return ((int )'?');
        }
      } else {
#line 116
        opj_optarg = *(nargv + opj_optind);
      }
    }
#line 117
    place = (char *)EMSG;
#line 118
    opj_optind ++;
  }
#line 120
  return (opj_optopt);
}
}
#line 124 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
int opj_getopt_long(int argc , char * const  argv[] , char const   *optstring , opj_option_t *longopts ,
                    int totlen ) 
{ 
  static int lastidx ;
  static int lastofs ;
  char *tmp ;
  int i ;
  int len ;
  char param ;
  char *arg ;
  opj_option_t *o ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  opj_option_t *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 129
  param = (char )1;
  again: 
#line 132
  if (! argv[opj_optind]) {
#line 133
    return (- 1);
  } else
#line 132
  if (opj_optind >= argc) {
#line 133
    return (- 1);
  } else
#line 132
  if ((int )*(argv[opj_optind]) != 45) {
#line 133
    return (- 1);
  }
#line 135
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 135
    if ((int )*(argv[opj_optind] + 1) == 0) {
#line 136
      if (opj_optind >= argc - 1) {
#line 137
        param = (char )0;
      } else
#line 140
      if ((int )*(argv[opj_optind + 1] + 0) == 45) {
#line 141
        param = (char )0;
      } else {
#line 144
        param = (char )2;
      }
    }
  }
#line 149
  if ((int )param == 0) {
#line 150
    opj_optind ++;
#line 151
    return ((int )'?');
  }
#line 154
  if ((int )*(argv[opj_optind] + 0) == 45) {
#line 155
    arg = argv[opj_optind] + 1;
#line 157
    o = longopts;
#line 158
    len = (int )sizeof(*(longopts + 0));
#line 160
    if ((int )param > 1) {
#line 161
      arg = argv[opj_optind + 1];
#line 162
      opj_optind ++;
    } else {
#line 165
      arg = argv[opj_optind] + 1;
    }
    {
#line 167
    __cil_tmp15 = strlen((char const   *)arg);
    }
#line 167
    if (__cil_tmp15 > 1UL) {
#line 168
      i = 0;
      {
#line 168
      while (1) {
        while_continue: /* CIL Label */ ;
#line 168
        if (! (i < totlen)) {
#line 168
          goto while_break;
        }
        {
#line 169
        __cil_tmp16 = strcmp(o->name, (char const   *)arg);
        }
#line 169
        if (! __cil_tmp16) {
#line 170
          if (o->has_arg == 0) {
#line 171
            if (argv[opj_optind + 1]) {
#line 171
              if (! ((int )*(argv[opj_optind + 1] + 0) == 45)) {
                {
#line 172
                fprintf(stderr, "%s: option does not require an argument. Ignoring %s\n",
                        arg, argv[opj_optind + 1]);
#line 173
                opj_optind ++;
                }
              }
            }
          } else {
#line 176
            opj_optarg = argv[opj_optind + 1];
#line 177
            if (opj_optarg) {
#line 178
              if ((int )*(opj_optarg + 0) == 45) {
#line 179
                if (opj_opterr) {
                  {
#line 180
                  fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                  }
#line 181
                  return ((int )'?');
                }
              }
            }
#line 185
            if (! opj_optarg) {
#line 185
              if (o->has_arg == 1) {
#line 186
                if (opj_opterr) {
                  {
#line 187
                  fprintf(stderr, "%s: option requires an argument \n", arg);
                  }
#line 188
                  return ((int )'?');
                }
              }
            }
#line 191
            opj_optind ++;
          }
#line 193
          opj_optind ++;
#line 194
          if (o->flag) {
#line 195
            *(o->flag) = o->val;
          } else {
#line 197
            return (o->val);
          }
#line 198
          return (0);
        }
#line 168
        __cil_tmp17 = o;
#line 168
        o ++;
#line 168
        i += len;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 201
      fprintf(stderr, "Invalid option %s\n", arg);
#line 202
      opj_optind ++;
      }
#line 203
      return ((int )'?');
    } else {
#line 205
      if ((int )*optstring == 58) {
#line 205
        return (':');
      }
#line 206
      if (lastidx != opj_optind) {
#line 207
        lastidx = opj_optind;
#line 207
        lastofs = 0;
      }
      {
#line 209
      opj_optopt = (int )*(argv[opj_optind] + (lastofs + 1));
#line 210
      tmp = strchr(optstring, opj_optopt);
      }
#line 210
      if (tmp) {
#line 211
        if ((int )*tmp == 0) {
#line 212
          opj_optind ++;
#line 213
          goto again;
        }
#line 215
        if ((int )*(tmp + 1) == 58) {
#line 216
          if ((int )*(tmp + 2) == 58) {
            _L: /* CIL Label */ 
#line 217
            opj_optarg = (argv[opj_optind] + lastofs) + 2;
#line 217
            if (! *opj_optarg) {
#line 217
              opj_optarg = (char *)0;
            }
#line 218
            goto found;
          } else
#line 216
          if ((int )*(argv[opj_optind] + (lastofs + 2))) {
#line 216
            goto _L;
          }
#line 220
          opj_optarg = argv[opj_optind + 1];
#line 221
          if (opj_optarg) {
#line 222
            if ((int )*(opj_optarg + 0) == 45) {
#line 223
              if (opj_opterr) {
                {
#line 224
                fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
                }
#line 225
                return ((int )'?');
              }
            }
          }
#line 229
          if (! opj_optarg) {
#line 230
            if (opj_opterr) {
              {
#line 231
              fprintf(stderr, "%s: option requires an argument\n\230\001", arg);
              }
#line 232
              return ((int )'?');
            }
          }
#line 235
          opj_optind ++;
        } else {
#line 237
          lastofs ++;
#line 238
          return (opj_optopt);
        }
        found: 
#line 241
        opj_optind ++;
#line 242
        return (opj_optopt);
      } else {
        {
#line 244
        fprintf(stderr, "Invalid option %s\n", arg);
#line 245
        opj_optind ++;
        }
#line 246
        return ((int )'?');
      }
    }
  }
  {
#line 251
  fprintf(stderr, "Invalid option\n");
#line 252
  opj_optind ++;
  }
#line 253
  return ((int )'?');

}
}
#line 62 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc_to_rgb(int offset , int upb , int y , int cb , int cr , int *out_r ,
                        int *out_g , int *out_b ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 67
  cb -= offset;
#line 67
  cr -= offset;
#line 68
  r = y + (int )(1.402 * (double )((float )cr));
#line 69
  if (r < 0) {
#line 69
    r = 0;
  } else
#line 69
  if (r > upb) {
#line 69
    r = upb;
  }
#line 69
  *out_r = r;
#line 71
  g = y - (int )(0.344 * (double )((float )cb) + 0.714 * (double )((float )cr));
#line 72
  if (g < 0) {
#line 72
    g = 0;
  } else
#line 72
  if (g > upb) {
#line 72
    g = upb;
  }
#line 72
  *out_g = g;
#line 74
  b = y + (int )(1.77200000001 * (double )((float )cb));
#line 75
  if (b < 0) {
#line 75
    b = 0;
  } else
#line 75
  if (b > upb) {
#line 75
    b = upb;
  }
#line 75
  *out_b = b;
  return;
}
}
#line 78 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc444_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int i ;
  int offset ;
  int upb ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 84
  i = (img->comps + 0)->prec;
#line 85
  offset = 1 << (i - 1);
#line 85
  upb = (1 << i) - 1;
#line 87
  maxw = (img->comps + 0)->w;
#line 87
  maxh = (img->comps + 0)->h;
#line 88
  max = maxw * maxh;
#line 90
  y = (int const   *)(img->comps + 0)->data;
#line 91
  cb = (int const   *)(img->comps + 1)->data;
#line 92
  cr = (int const   *)(img->comps + 2)->data;
#line 94
  __cil_tmp17 = malloc(sizeof(int ) * (unsigned long )max);
#line 94
  r = (int *)__cil_tmp17;
#line 94
  d0 = r;
#line 95
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 95
  g = (int *)__cil_tmp18;
#line 95
  d1 = g;
#line 96
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 96
  b = (int *)__cil_tmp19;
#line 96
  d2 = b;
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < max)) {
#line 98
      goto while_break;
    }
    {
#line 100
    sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 102
    y ++;
#line 102
    cb ++;
#line 102
    cr ++;
#line 102
    r ++;
#line 102
    g ++;
#line 102
    b ++;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  free((img->comps + 0)->data);
#line 104
  (img->comps + 0)->data = d0;
#line 105
  free((img->comps + 1)->data);
#line 105
  (img->comps + 1)->data = d1;
#line 106
  free((img->comps + 2)->data);
#line 106
  (img->comps + 2)->data = d2;
  }
  return;
}
}
#line 110 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc422_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 117
  i = (img->comps + 0)->prec;
#line 118
  offset = 1 << (i - 1);
#line 118
  upb = (1 << i) - 1;
#line 120
  maxw = (img->comps + 0)->w;
#line 120
  maxh = (img->comps + 0)->h;
#line 121
  max = maxw * maxh;
#line 123
  y = (int const   *)(img->comps + 0)->data;
#line 124
  cb = (int const   *)(img->comps + 1)->data;
#line 125
  cr = (int const   *)(img->comps + 2)->data;
#line 127
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 127
  r = (int *)__cil_tmp18;
#line 127
  d0 = r;
#line 128
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 128
  g = (int *)__cil_tmp19;
#line 128
  d1 = g;
#line 129
  __cil_tmp20 = malloc(sizeof(int ) * (unsigned long )max);
#line 129
  b = (int *)__cil_tmp20;
#line 129
  d2 = b;
#line 131
  i = 0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < maxh)) {
#line 131
      goto while_break;
    }
#line 133
    j = 0;
    {
#line 133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 133
      if (! (j < maxw)) {
#line 133
        goto while_break___0;
      }
      {
#line 135
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 137
      y ++;
#line 137
      r ++;
#line 137
      g ++;
#line 137
      b ++;
#line 139
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 141
      y ++;
#line 141
      r ++;
#line 141
      g ++;
#line 141
      b ++;
#line 141
      cb ++;
#line 141
      cr ++;
      }
#line 133
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((img->comps + 0)->data);
#line 144
  (img->comps + 0)->data = d0;
#line 145
  free((img->comps + 1)->data);
#line 145
  (img->comps + 1)->data = d1;
#line 146
  free((img->comps + 2)->data);
#line 146
  (img->comps + 2)->data = d2;
#line 148
  (img->comps + 1)->w = maxw;
#line 148
  (img->comps + 1)->h = maxh;
#line 149
  (img->comps + 2)->w = maxw;
#line 149
  (img->comps + 2)->h = maxh;
#line 150
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 151
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 152
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 153
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
#line 157 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc420_to_rgb(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int *nr ;
  int *ng ;
  int *nb ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int const   *ny ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
  {
#line 164
  i = (img->comps + 0)->prec;
#line 165
  offset = 1 << (i - 1);
#line 165
  upb = (1 << i) - 1;
#line 167
  maxw = (img->comps + 0)->w;
#line 167
  maxh = (img->comps + 0)->h;
#line 168
  max = maxw * maxh;
#line 170
  y = (int const   *)(img->comps + 0)->data;
#line 171
  cb = (int const   *)(img->comps + 1)->data;
#line 172
  cr = (int const   *)(img->comps + 2)->data;
#line 174
  __cil_tmp22 = malloc(sizeof(int ) * (unsigned long )max);
#line 174
  r = (int *)__cil_tmp22;
#line 174
  d0 = r;
#line 175
  __cil_tmp23 = malloc(sizeof(int ) * (unsigned long )max);
#line 175
  g = (int *)__cil_tmp23;
#line 175
  d1 = g;
#line 176
  __cil_tmp24 = malloc(sizeof(int ) * (unsigned long )max);
#line 176
  b = (int *)__cil_tmp24;
#line 176
  d2 = b;
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < maxh)) {
#line 178
      goto while_break;
    }
#line 180
    ny = y + maxw;
#line 181
    nr = r + maxw;
#line 181
    ng = g + maxw;
#line 181
    nb = b + maxw;
#line 183
    j = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      if (! (j < maxw)) {
#line 183
        goto while_break___0;
      }
      {
#line 185
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 187
      y ++;
#line 187
      r ++;
#line 187
      g ++;
#line 187
      b ++;
#line 189
      sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
#line 191
      y ++;
#line 191
      r ++;
#line 191
      g ++;
#line 191
      b ++;
#line 193
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 195
      ny ++;
#line 195
      nr ++;
#line 195
      ng ++;
#line 195
      nb ++;
#line 197
      sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 199
      ny ++;
#line 199
      nr ++;
#line 199
      ng ++;
#line 199
      nb ++;
#line 199
      cb ++;
#line 199
      cr ++;
      }
#line 183
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 201
    y += maxw;
#line 201
    r += maxw;
#line 201
    g += maxw;
#line 201
    b += maxw;
#line 178
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  free((img->comps + 0)->data);
#line 203
  (img->comps + 0)->data = d0;
#line 204
  free((img->comps + 1)->data);
#line 204
  (img->comps + 1)->data = d1;
#line 205
  free((img->comps + 2)->data);
#line 205
  (img->comps + 2)->data = d2;
#line 207
  (img->comps + 1)->w = maxw;
#line 207
  (img->comps + 1)->h = maxh;
#line 208
  (img->comps + 2)->w = maxw;
#line 208
  (img->comps + 2)->h = maxh;
#line 209
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 210
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 211
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 212
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
#line 216 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
void color_sycc_to_rgb(opj_image_t *img ) 
{ 


  {
#line 218
  if (img->numcomps < 3) {
#line 220
    img->color_space = (OPJ_COLOR_SPACE )2;
#line 221
    return;
  }
#line 224
  if ((img->comps + 0)->dx == 1) {
#line 224
    if ((img->comps + 1)->dx == 2) {
#line 224
      if ((img->comps + 2)->dx == 2) {
#line 224
        if ((img->comps + 0)->dy == 1) {
#line 224
          if ((img->comps + 1)->dy == 2) {
#line 224
            if ((img->comps + 2)->dy == 2) {
              {
#line 231
              sycc420_to_rgb(img);
              }
            } else {
#line 224
              goto _L___57;
            }
          } else {
#line 224
            goto _L___57;
          }
        } else {
#line 224
          goto _L___57;
        }
      } else {
#line 224
        goto _L___57;
      }
    } else {
#line 224
      goto _L___57;
    }
  } else
  _L___57: /* CIL Label */ 
  _L___58: /* CIL Label */ 
  _L___59: /* CIL Label */ 
  _L___60: /* CIL Label */ 
  _L___61: /* CIL Label */ 
#line 234
  if ((img->comps + 0)->dx == 1) {
#line 234
    if ((img->comps + 1)->dx == 2) {
#line 234
      if ((img->comps + 2)->dx == 2) {
#line 234
        if ((img->comps + 0)->dy == 1) {
#line 234
          if ((img->comps + 1)->dy == 1) {
#line 234
            if ((img->comps + 2)->dy == 1) {
              {
#line 241
              sycc422_to_rgb(img);
              }
            } else {
#line 234
              goto _L;
            }
          } else {
#line 234
            goto _L;
          }
        } else {
#line 234
          goto _L;
        }
      } else {
#line 234
        goto _L;
      }
    } else {
#line 234
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___53: /* CIL Label */ 
  _L___54: /* CIL Label */ 
  _L___55: /* CIL Label */ 
  _L___56: /* CIL Label */ 
#line 244
  if ((img->comps + 0)->dx == 1) {
#line 244
    if ((img->comps + 1)->dx == 1) {
#line 244
      if ((img->comps + 2)->dx == 1) {
#line 244
        if ((img->comps + 0)->dy == 1) {
#line 244
          if ((img->comps + 1)->dy == 1) {
#line 244
            if ((img->comps + 2)->dy == 1) {
              {
#line 251
              sycc444_to_rgb(img);
              }
            } else {
              {
              {
              {
              {
              {
              {
#line 255
              fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
                      256);
              }
              }
              }
              }
              }
              }
#line 257
              return;
            }
          } else {
            {
            {
            {
            {
            {
            {
#line 255
            fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
                    256);
            }
            }
            }
            }
            }
            }
#line 257
            return;
          }
        } else {
          {
          {
          {
          {
          {
          {
#line 255
          fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
                  256);
          }
          }
          }
          }
          }
          }
#line 257
          return;
        }
      } else {
        {
        {
        {
        {
        {
        {
#line 255
        fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
                256);
        }
        }
        }
        }
        }
        }
#line 257
        return;
      }
    } else {
      {
      {
      {
      {
      {
      {
#line 255
      fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
              256);
      }
      }
      }
      }
      }
      }
#line 257
      return;
    }
  } else {
    {
    {
    {
    {
    {
    {
#line 255
    fprintf(stderr, "%s:%d:color_sycc_to_rgb\n\tCAN NOT CONVERT\n", "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c",
            256);
    }
    }
    }
    }
    }
    }
#line 257
    return;
  }
#line 259
  img->color_space = (OPJ_COLOR_SPACE )1;
  return;
}
}
#line 53 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/opj_getopt.c"
static char EMSG___0[1]  = {      "\250"};
#line 56 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int int_floorlog2___21(int a ) 
{ 
  int l ;
  int __cil_tmp3 ;

  {
#line 58
  l = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (a > 1)) {
#line 58
      goto while_break;
    }
#line 59
    a >>= 1;
#line 58
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (l);
}
}
#line 95 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned short get_ushort___0(unsigned short val ) 
{ 


  {
#line 100
  return (val);
}
}
#line 107 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int tga_readheader___0(FILE *fp , unsigned int *bits_per_pixel , unsigned int *width ,
                              unsigned int *height , int *flip_image ) 
{ 
  int palette_size ;
  unsigned char *tga ;
  unsigned char id_len ;
  unsigned char cmap_type ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned short cmap_index ;
  unsigned short cmap_len ;
  unsigned short cmap_entry_size ;
  unsigned short x_origin ;
  unsigned short y_origin ;
  unsigned short image_w ;
  unsigned short image_h ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned short __cil_tmp22 ;
  unsigned short __cil_tmp23 ;
  unsigned short __cil_tmp24 ;
  unsigned short __cil_tmp25 ;
  unsigned short __cil_tmp26 ;
  unsigned short __cil_tmp27 ;
  unsigned char *id ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;

  {
#line 117
  if (! bits_per_pixel) {
#line 118
    return (0);
  } else
#line 117
  if (! width) {
#line 118
    return (0);
  } else
#line 117
  if (! height) {
#line 118
    return (0);
  } else
#line 117
  if (! flip_image) {
#line 118
    return (0);
  }
  {
#line 119
  __cil_tmp20 = malloc((unsigned long )18);
#line 119
  tga = (unsigned char *)__cil_tmp20;
#line 121
  __cil_tmp21 = fread(tga, (unsigned long )18, (unsigned long )1, fp);
  }
#line 121
  if (__cil_tmp21 != 1UL) {
    {
#line 123
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 124
    return (0);
  }
  {
#line 126
  id_len = (unsigned char )*(tga + 0);
#line 127
  cmap_type = (unsigned char )*(tga + 1);
#line 128
  image_type = (unsigned char )*(tga + 2);
#line 129
  cmap_index = get_ushort___0(*((unsigned short *)(tga + 3)));
#line 130
  cmap_len = get_ushort___0(*((unsigned short *)(tga + 5)));
#line 131
  cmap_entry_size = (unsigned short )((unsigned char )*(tga + 7));
#line 134
  x_origin = get_ushort___0(*((unsigned short *)(tga + 8)));
#line 135
  y_origin = get_ushort___0(*((unsigned short *)(tga + 10)));
#line 136
  image_w = get_ushort___0(*((unsigned short *)(tga + 12)));
#line 137
  image_h = get_ushort___0(*((unsigned short *)(tga + 14)));
#line 138
  pixel_depth = (unsigned char )*(tga + 16);
#line 139
  image_desc = (unsigned char )*(tga + 17);
#line 141
  free(tga);
#line 143
  *bits_per_pixel = (unsigned int )pixel_depth;
#line 144
  *width = (unsigned int )image_w;
#line 145
  *height = (unsigned int )image_h;
  }
#line 148
  if (id_len) {
    {
#line 150
    __cil_tmp29 = malloc((unsigned long )id_len);
#line 150
    id = (unsigned char *)__cil_tmp29;
#line 151
    __cil_tmp30 = fread(id, (unsigned long )id_len, (unsigned long )1, fp);
    }
#line 151
    if (! __cil_tmp30) {
      {
#line 153
      fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
#line 154
      free(id);
      }
#line 155
      return (0);
    }
    {
#line 157
    free(id);
    }
  }
#line 163
  if ((int )image_type > 8) {
    {
#line 165
    fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
    }
#line 166
    return (0);
  }
#line 169
  *flip_image = ! ((int )image_desc & 32);
#line 172
  palette_size = (int )cmap_len * ((int )cmap_entry_size / 8);
#line 174
  if (palette_size > 0) {
    {
#line 176
    fprintf(stderr, "File contains a palette - not yet supported.");
#line 177
    fseek(fp, (long )palette_size, 1);
    }
  }
#line 179
  return (1);
}
}
#line 192 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int tga_writeheader___0(FILE *fp , int bits_per_pixel , int width , int height ,
                               opj_bool flip_image ) 
{ 
  unsigned short image_w ;
  unsigned short image_h ;
  unsigned short us0 ;
  unsigned char uc0 ;
  unsigned char image_type ;
  unsigned char pixel_depth ;
  unsigned char image_desc ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;

  {
#line 199
  if (! bits_per_pixel) {
#line 200
    return (0);
  } else
#line 199
  if (! width) {
#line 200
    return (0);
  } else
#line 199
  if (! height) {
#line 200
    return (0);
  }
#line 202
  pixel_depth = (unsigned char )0;
#line 204
  if (bits_per_pixel < 256) {
#line 205
    pixel_depth = (unsigned char )bits_per_pixel;
  } else {
    {
#line 207
    fprintf(stderr, "ERROR: Wrong bits per pixel inside tga_headerU");
    }
#line 208
    return (0);
  }
  {
#line 210
  uc0 = (unsigned char )0;
#line 212
  __cil_tmp13 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 212
  if (__cil_tmp13 != 1UL) {
#line 212
    goto fails;
  }
  {
#line 213
  __cil_tmp14 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 213
  if (__cil_tmp14 != 1UL) {
#line 213
    goto fails;
  }
  {
#line 215
  image_type = (unsigned char )2;
#line 216
  __cil_tmp15 = fwrite(& image_type, (unsigned long )1, (unsigned long )1, fp);
  }
#line 216
  if (__cil_tmp15 != 1UL) {
#line 216
    goto fails;
  }
  {
#line 218
  us0 = (unsigned short )0;
#line 219
  __cil_tmp16 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 219
  if (__cil_tmp16 != 1UL) {
#line 219
    goto fails;
  }
  {
#line 220
  __cil_tmp17 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 220
  if (__cil_tmp17 != 1UL) {
#line 220
    goto fails;
  }
  {
#line 221
  __cil_tmp18 = fwrite(& uc0, (unsigned long )1, (unsigned long )1, fp);
  }
#line 221
  if (__cil_tmp18 != 1UL) {
#line 221
    goto fails;
  }
  {
#line 223
  __cil_tmp19 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 223
  if (__cil_tmp19 != 1UL) {
#line 223
    goto fails;
  }
  {
#line 224
  __cil_tmp20 = fwrite(& us0, (unsigned long )2, (unsigned long )1, fp);
  }
#line 224
  if (__cil_tmp20 != 1UL) {
#line 224
    goto fails;
  }
  {
#line 226
  image_w = (unsigned short )width;
#line 227
  image_h = (unsigned short )height;
#line 230
  __cil_tmp21 = fwrite(& image_w, (unsigned long )2, (unsigned long )1, fp);
  }
#line 230
  if (__cil_tmp21 != 1UL) {
#line 230
    goto fails;
  }
  {
#line 231
  __cil_tmp22 = fwrite(& image_h, (unsigned long )2, (unsigned long )1, fp);
  }
#line 231
  if (__cil_tmp22 != 1UL) {
#line 231
    goto fails;
  }
  {
#line 239
  __cil_tmp23 = fwrite(& pixel_depth, (unsigned long )1, (unsigned long )1, fp);
  }
#line 239
  if (__cil_tmp23 != 1UL) {
#line 239
    goto fails;
  }
#line 241
  image_desc = (unsigned char )8;
#line 243
  if (flip_image) {
#line 244
    image_desc |= 32;
  }
  {
#line 245
  __cil_tmp24 = fwrite(& image_desc, (unsigned long )1, (unsigned long )1, fp);
  }
#line 245
  if (__cil_tmp24 != 1UL) {
#line 245
    goto fails;
  }
#line 247
  return (1);
  fails: 
  {
#line 250
  fputs("\nwrite_tgaheader: write ERROR\n", stderr);
  }
#line 251
  return (0);
}
}
#line 1205 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned char readuchar___0(FILE *f ) 
{ 
  unsigned char c1 ;
  unsigned long __cil_tmp3 ;

  {
  {
#line 1208
  __cil_tmp3 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1208
  if (! __cil_tmp3) {
    {
#line 1210
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1211
    return ((unsigned char )0);
  }
#line 1213
  return (c1);
}
}
#line 1216 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned short readushort___0(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 1219
  __cil_tmp5 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1219
  if (! __cil_tmp5) {
    {
#line 1221
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1222
    return ((unsigned short )0);
  }
  {
#line 1224
  __cil_tmp6 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1224
  if (! __cil_tmp6) {
    {
#line 1226
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1227
    return ((unsigned short )0);
  }
#line 1229
  if (bigendian) {
#line 1230
    return ((unsigned short )(((int )c1 << 8) + (int )c2));
  } else {
#line 1232
    return ((unsigned short )(((int )c2 << 8) + (int )c1));
  }
}
}
#line 1235 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static unsigned int readuint___0(FILE *f , int bigendian ) 
{ 
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;

  {
  {
#line 1238
  __cil_tmp7 = fread(& c1, (unsigned long )1, (unsigned long )1, f);
  }
#line 1238
  if (! __cil_tmp7) {
    {
#line 1240
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1241
    return ((unsigned int )0);
  }
  {
#line 1243
  __cil_tmp8 = fread(& c2, (unsigned long )1, (unsigned long )1, f);
  }
#line 1243
  if (! __cil_tmp8) {
    {
#line 1245
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1246
    return ((unsigned int )0);
  }
  {
#line 1248
  __cil_tmp9 = fread(& c3, (unsigned long )1, (unsigned long )1, f);
  }
#line 1248
  if (! __cil_tmp9) {
    {
#line 1250
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1251
    return ((unsigned int )0);
  }
  {
#line 1253
  __cil_tmp10 = fread(& c4, (unsigned long )1, (unsigned long )1, f);
  }
#line 1253
  if (! __cil_tmp10) {
    {
#line 1255
    fprintf(stderr, "\nError: fread return a number of element different from the expected.\n");
    }
#line 1256
    return ((unsigned int )0);
  }
#line 1258
  if (bigendian) {
#line 1259
    return ((unsigned int )(((((int )c1 << 24) + ((int )c2 << 16)) + ((int )c3 << 8)) + (int )c4));
  } else {
#line 1261
    return ((unsigned int )(((((int )c4 << 24) + ((int )c3 << 16)) + ((int )c2 << 8)) + (int )c1));
  }
}
}
#line 1479 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_white___0(char *s ) 
{ 
  unsigned short const   **__cil_tmp2 ;

  {
  {
#line 1481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1481
    if (! *s) {
#line 1481
      goto while_break;
    }
#line 1483
    if ((int )*s == 10) {
#line 1483
      return ((char *)((void *)0));
    } else
#line 1483
    if ((int )*s == 13) {
#line 1483
      return ((char *)((void *)0));
    }
    {
#line 1484
    __cil_tmp2 = __ctype_b_loc();
    }
#line 1484
    if ((int )*(*__cil_tmp2 + (int )*s) & 8192) {
#line 1484
      s ++;
#line 1484
      goto while_continue;
    }
#line 1485
    return (s);
  }
  while_break: /* CIL Label */ ;
  }
#line 1487
  return ((char *)((void *)0));
}
}
#line 1490 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_int___0(char *start , int *out_n ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1495
  *out_n = 0;
#line 1495
  s = start;
#line 1497
  s = skip_white___0(start);
  }
#line 1498
  if (s == (void *)0) {
#line 1498
    return ((char *)((void *)0));
  }
#line 1499
  start = s;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (! *s) {
#line 1501
      goto while_break;
    }
    {
#line 1503
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1503
    if (! ((int )*(*__cil_tmp6 + (int )*s) & 2048)) {
#line 1503
      goto while_break;
    }
#line 1504
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1506
  c = *s;
#line 1506
  *s = (char )0;
#line 1506
  *out_n = atoi((char const   *)start);
#line 1506
  *s = c;
  }
#line 1507
  return (s);
}
}
#line 1510 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static char *skip_idf___0(char *start , char out_idf[256] ) 
{ 
  char *s ;
  char c ;
  char *__cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;

  {
  {
#line 1515
  s = skip_white___0(start);
  }
#line 1516
  if (s == (void *)0) {
#line 1516
    return ((char *)((void *)0));
  }
#line 1517
  start = s;
  {
#line 1519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1519
    if (! *s) {
#line 1519
      goto while_break;
    }
    {
#line 1521
    __cil_tmp6 = __ctype_b_loc();
    }
#line 1521
    if ((int )*(*__cil_tmp6 + (int )*s) & 1024) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    } else
#line 1521
    if ((int )*s == 95) {
#line 1521
      s ++;
#line 1521
      goto while_continue;
    }
#line 1522
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1524
  c = *s;
#line 1524
  *s = (char )0;
#line 1524
  strncpy(out_idf, (char const   *)start, (unsigned long )255);
#line 1524
  *s = c;
  }
#line 1525
  return (s);
}
}
#line 1528 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static void read_pnm_header___0(FILE *reader , struct pnm_header *ph ) 
{ 
  char *s ;
  int format ;
  int have_wh ;
  int end ;
  int ttype ;
  char idf[256] ;
  char type[256] ;
  char line[256] ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 1535
  __cil_tmp11 = fgets((char *)line, 250, reader);
  }
#line 1535
  if (__cil_tmp11 == (void *)0) {
    {
#line 1537
    fprintf(stderr, "\nWARNING: fgets return a NULL valueE\262U");
    }
#line 1538
    return;
  }
#line 1541
  if ((int )line[0] != 80) {
    {
#line 1543
    fprintf(stderr, "read_pnm_header:PNM:magic P missing\n");
    }
#line 1543
    return;
  }
  {
#line 1545
  format = atoi((char const   *)((char *)line + 1));
  }
#line 1546
  if (format < 1) {
    {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1549
    return;
  } else
#line 1546
  if (format > 7) {
    {
    {
#line 1548
    fprintf(stderr, "read_pnm_header:magic format %d invalid\n\230\001", format);
    }
    }
#line 1549
    return;
  }
#line 1551
  ph->format = format;
#line 1552
  have_wh = 0;
#line 1552
  end = have_wh;
#line 1552
  ttype = end;
  {
#line 1554
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1554
    __cil_tmp13 = fgets((char *)line, 250, reader);
    }
#line 1554
    if (! __cil_tmp13) {
#line 1554
      goto while_break;
    }
#line 1556
    if ((int )*((char *)line) == 35) {
#line 1556
      goto while_continue;
    }
#line 1558
    s = (char *)line;
#line 1560
    if (format == 7) {
      {
#line 1562
      s = skip_idf___0(s, (char *)idf);
      }
#line 1564
      if (s == (void *)0) {
#line 1564
        return;
      } else
#line 1564
      if ((int )*s == 0) {
#line 1564
        return;
      }
      {
#line 1566
      __cil_tmp15 = strcmp((char const   *)((char *)idf), "ENDHDR");
      }
#line 1566
      if (__cil_tmp15 == 0) {
#line 1568
        end = 1;
#line 1568
        goto while_break;
      }
      {
#line 1570
      __cil_tmp16 = strcmp((char const   *)((char *)idf), "WIDTHU");
      }
#line 1570
      if (__cil_tmp16 == 0) {
        {
#line 1572
        s = skip_int___0(s, & ph->width);
        }
#line 1573
        if (s == (void *)0) {
#line 1573
          return;
        } else
#line 1573
        if ((int )*s == 0) {
#line 1573
          return;
        }
#line 1575
        goto while_continue;
      }
      {
#line 1577
      __cil_tmp18 = strcmp((char const   *)((char *)idf), "HEIGHT");
      }
#line 1577
      if (__cil_tmp18 == 0) {
        {
#line 1579
        s = skip_int___0(s, & ph->height);
        }
#line 1580
        if (s == (void *)0) {
#line 1580
          return;
        } else
#line 1580
        if ((int )*s == 0) {
#line 1580
          return;
        }
#line 1582
        goto while_continue;
      }
      {
#line 1584
      __cil_tmp20 = strcmp((char const   *)((char *)idf), "DEPTHU");
      }
#line 1584
      if (__cil_tmp20 == 0) {
        {
#line 1586
        s = skip_int___0(s, & ph->depth);
        }
#line 1587
        if (s == (void *)0) {
#line 1587
          return;
        } else
#line 1587
        if ((int )*s == 0) {
#line 1587
          return;
        }
#line 1589
        goto while_continue;
      }
      {
#line 1591
      __cil_tmp22 = strcmp((char const   *)((char *)idf), "MAXVAL");
      }
#line 1591
      if (__cil_tmp22 == 0) {
        {
#line 1593
        s = skip_int___0(s, & ph->maxval);
        }
#line 1594
        if (s == (void *)0) {
#line 1594
          return;
        } else
#line 1594
        if ((int )*s == 0) {
#line 1594
          return;
        }
#line 1596
        goto while_continue;
      }
      {
#line 1598
      __cil_tmp24 = strcmp((char const   *)((char *)idf), "TUPLTYPE\220");
      }
#line 1598
      if (__cil_tmp24 == 0) {
        {
#line 1600
        s = skip_idf___0(s, (char *)type);
        }
#line 1601
        if (s == (void *)0) {
#line 1601
          return;
        } else
#line 1601
        if ((int )*s == 0) {
#line 1601
          return;
        }
        {
#line 1603
        __cil_tmp26 = strcmp((char const   *)((char *)type), "BLACKANDWHITE");
        }
#line 1603
        if (__cil_tmp26 == 0) {
#line 1605
          ph->bw = (char )1;
#line 1605
          ttype = 1;
#line 1605
          goto while_continue;
        }
        {
#line 1607
        __cil_tmp27 = strcmp((char const   *)((char *)type), "GRAYSCALE\223");
        }
#line 1607
        if (__cil_tmp27 == 0) {
#line 1609
          ph->gray = (char )1;
#line 1609
          ttype = 1;
#line 1609
          goto while_continue;
        }
        {
#line 1611
        __cil_tmp28 = strcmp((char const   *)((char *)type), "GRAYSCALE_ALPHA");
        }
#line 1611
        if (__cil_tmp28 == 0) {
#line 1613
          ph->graya = (char )1;
#line 1613
          ttype = 1;
#line 1613
          goto while_continue;
        }
        {
#line 1615
        __cil_tmp29 = strcmp((char const   *)((char *)type), "RGB");
        }
#line 1615
        if (__cil_tmp29 == 0) {
#line 1617
          ph->rgb = (char )1;
#line 1617
          ttype = 1;
#line 1617
          goto while_continue;
        }
        {
#line 1619
        __cil_tmp30 = strcmp((char const   *)((char *)type), "RGB_ALPHA\001");
        }
#line 1619
        if (__cil_tmp30 == 0) {
#line 1621
          ph->rgba = (char )1;
#line 1621
          ttype = 1;
#line 1621
          goto while_continue;
        }
        {
#line 1623
        fprintf(stderr, "read_pnm_header:unknown P7 TUPLTYPE %s\n", (char *)type);
        }
#line 1624
        return;
      }
      {
#line 1626
      fprintf(stderr, "read_pnm_header:unknown P7 idf %s\n\001", (char *)idf);
      }
#line 1627
      return;
    }
#line 1630
    if (! have_wh) {
      {
#line 1632
      s = skip_int___0(s, & ph->width);
#line 1634
      s = skip_int___0(s, & ph->height);
#line 1636
      have_wh = 1;
      }
#line 1638
      if (format == 1) {
#line 1638
        goto while_break;
      } else
#line 1638
      if (format == 4) {
#line 1638
        goto while_break;
      }
#line 1640
      goto while_continue;
    }
#line 1642
    if (format == 2) {
      _L: /* CIL Label */ 
      _L___83: /* CIL Label */ 
      _L___84: /* CIL Label */ 
      {
#line 1645
      s = skip_int___0(s, & ph->maxval);
      }
#line 1647
      if (ph->maxval > 65535) {
#line 1647
        return;
      }
    } else
#line 1642
    if (format == 3) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 5) {
#line 1642
      goto _L;
    } else
#line 1642
    if (format == 6) {
#line 1642
      goto _L;
    }
#line 1649
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1651
  if (format == 2) {
    _L___85: /* CIL Label */ 
    _L___86: /* CIL Label */ 
#line 1653
    if (ph->maxval < 1) {
#line 1653
      return;
    } else
#line 1653
    if (ph->maxval > 65535) {
#line 1653
      return;
    }
  } else
#line 1651
  if (format == 3) {
#line 1651
    goto _L___85;
  } else
#line 1651
  if (format > 4) {
#line 1651
    goto _L___85;
  }
#line 1655
  if (ph->width < 1) {
#line 1655
    return;
  } else
#line 1655
  if (ph->height < 1) {
#line 1655
    return;
  }
#line 1657
  if (format == 7) {
#line 1659
    if (! end) {
      {
#line 1661
      fprintf(stderr, "read_pnm_header:P7 without ENDHDR\n");
      }
#line 1661
      return;
    }
#line 1663
    if (ph->depth < 1) {
#line 1663
      return;
    } else
#line 1663
    if (ph->depth > 4) {
#line 1663
      return;
    }
#line 1665
    if (ph->width) {
#line 1665
      if (ph->height) {
#line 1665
        if (ph->depth & ph->maxval) {
#line 1665
          if (ttype) {
#line 1666
            ph->ok = (char )1;
          }
        }
      }
    }
  } else
#line 1670
  if (format != 1) {
#line 1670
    if (format != 4) {
#line 1672
      if (ph->width) {
#line 1672
        if (ph->height) {
#line 1672
          if (ph->maxval) {
#line 1672
            ph->ok = (char )1;
          }
        }
      }
    } else {
#line 1670
      goto _L___87;
    }
  } else {
    _L___87: /* CIL Label */ 
#line 1676
    if (ph->width) {
#line 1676
      if (ph->height) {
#line 1676
        ph->ok = (char )1;
      }
    }
#line 1677
    ph->maxval = 255;
  }
  return;
}
}
#line 1682 "/doner/openjpeg/openjpeg-c02f145/applications/codec/convert.c"
static int has_prec___0(int val ) 
{ 


  {
#line 1684
  if (val < 2) {
#line 1684
    return (1);
  }
#line 1685
  if (val < 4) {
#line 1685
    return (2);
  }
#line 1686
  if (val < 8) {
#line 1686
    return (3);
  }
#line 1687
  if (val < 16) {
#line 1687
    return (4);
  }
#line 1688
  if (val < 32) {
#line 1688
    return (5);
  }
#line 1689
  if (val < 64) {
#line 1689
    return (6);
  }
#line 1690
  if (val < 128) {
#line 1690
    return (7);
  }
#line 1691
  if (val < 256) {
#line 1691
    return (8);
  }
#line 1692
  if (val < 512) {
#line 1692
    return (9);
  }
#line 1693
  if (val < 1024) {
#line 1693
    return (10);
  }
#line 1694
  if (val < 2048) {
#line 1694
    return (11);
  }
#line 1695
  if (val < 4096) {
#line 1695
    return (12);
  }
#line 1696
  if (val < 8192) {
#line 1696
    return (13);
  }
#line 1697
  if (val < 16384) {
#line 1697
    return (14);
  }
#line 1698
  if (val < 32768) {
#line 1698
    return (15);
  }
#line 1699
  return (16);
}
}
#line 62 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc_to_rgb___0(int offset , int upb , int y , int cb , int cr , int *out_r ,
                            int *out_g , int *out_b ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 67
  cb -= offset;
#line 67
  cr -= offset;
#line 68
  r = y + (int )(1.402 * (double )((float )cr));
#line 69
  if (r < 0) {
#line 69
    r = 0;
  } else
#line 69
  if (r > upb) {
#line 69
    r = upb;
  }
#line 69
  *out_r = r;
#line 71
  g = y - (int )(0.344 * (double )((float )cb) + 0.714 * (double )((float )cr));
#line 72
  if (g < 0) {
#line 72
    g = 0;
  } else
#line 72
  if (g > upb) {
#line 72
    g = upb;
  }
#line 72
  *out_g = g;
#line 74
  b = y + (int )(1.77200000001 * (double )((float )cb));
#line 75
  if (b < 0) {
#line 75
    b = 0;
  } else
#line 75
  if (b > upb) {
#line 75
    b = upb;
  }
#line 75
  *out_b = b;
  return;
}
}
#line 78 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc444_to_rgb___0(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int i ;
  int offset ;
  int upb ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
  {
#line 84
  i = (img->comps + 0)->prec;
#line 85
  offset = 1 << (i - 1);
#line 85
  upb = (1 << i) - 1;
#line 87
  maxw = (img->comps + 0)->w;
#line 87
  maxh = (img->comps + 0)->h;
#line 88
  max = maxw * maxh;
#line 90
  y = (int const   *)(img->comps + 0)->data;
#line 91
  cb = (int const   *)(img->comps + 1)->data;
#line 92
  cr = (int const   *)(img->comps + 2)->data;
#line 94
  __cil_tmp17 = malloc(sizeof(int ) * (unsigned long )max);
#line 94
  r = (int *)__cil_tmp17;
#line 94
  d0 = r;
#line 95
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 95
  g = (int *)__cil_tmp18;
#line 95
  d1 = g;
#line 96
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 96
  b = (int *)__cil_tmp19;
#line 96
  d2 = b;
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < max)) {
#line 98
      goto while_break;
    }
    {
#line 100
    sycc_to_rgb___0(offset, upb, *y, *cb, *cr, r, g, b);
#line 102
    y ++;
#line 102
    cb ++;
#line 102
    cr ++;
#line 102
    r ++;
#line 102
    g ++;
#line 102
    b ++;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  free((img->comps + 0)->data);
#line 104
  (img->comps + 0)->data = d0;
#line 105
  free((img->comps + 1)->data);
#line 105
  (img->comps + 1)->data = d1;
#line 106
  free((img->comps + 2)->data);
#line 106
  (img->comps + 2)->data = d2;
  }
  return;
}
}
#line 110 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc422_to_rgb___0(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 117
  i = (img->comps + 0)->prec;
#line 118
  offset = 1 << (i - 1);
#line 118
  upb = (1 << i) - 1;
#line 120
  maxw = (img->comps + 0)->w;
#line 120
  maxh = (img->comps + 0)->h;
#line 121
  max = maxw * maxh;
#line 123
  y = (int const   *)(img->comps + 0)->data;
#line 124
  cb = (int const   *)(img->comps + 1)->data;
#line 125
  cr = (int const   *)(img->comps + 2)->data;
#line 127
  __cil_tmp18 = malloc(sizeof(int ) * (unsigned long )max);
#line 127
  r = (int *)__cil_tmp18;
#line 127
  d0 = r;
#line 128
  __cil_tmp19 = malloc(sizeof(int ) * (unsigned long )max);
#line 128
  g = (int *)__cil_tmp19;
#line 128
  d1 = g;
#line 129
  __cil_tmp20 = malloc(sizeof(int ) * (unsigned long )max);
#line 129
  b = (int *)__cil_tmp20;
#line 129
  d2 = b;
#line 131
  i = 0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < maxh)) {
#line 131
      goto while_break;
    }
#line 133
    j = 0;
    {
#line 133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 133
      if (! (j < maxw)) {
#line 133
        goto while_break___0;
      }
      {
#line 135
      sycc_to_rgb___0(offset, upb, *y, *cb, *cr, r, g, b);
#line 137
      y ++;
#line 137
      r ++;
#line 137
      g ++;
#line 137
      b ++;
#line 139
      sycc_to_rgb___0(offset, upb, *y, *cb, *cr, r, g, b);
#line 141
      y ++;
#line 141
      r ++;
#line 141
      g ++;
#line 141
      b ++;
#line 141
      cb ++;
#line 141
      cr ++;
      }
#line 133
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  free((img->comps + 0)->data);
#line 144
  (img->comps + 0)->data = d0;
#line 145
  free((img->comps + 1)->data);
#line 145
  (img->comps + 1)->data = d1;
#line 146
  free((img->comps + 2)->data);
#line 146
  (img->comps + 2)->data = d2;
#line 148
  (img->comps + 1)->w = maxw;
#line 148
  (img->comps + 1)->h = maxh;
#line 149
  (img->comps + 2)->w = maxw;
#line 149
  (img->comps + 2)->h = maxh;
#line 150
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 151
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 152
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 153
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
#line 157 "/doner/openjpeg/openjpeg-c02f145/applications/codec/../common/color.c"
static void sycc420_to_rgb___0(opj_image_t *img ) 
{ 
  int *d0 ;
  int *d1 ;
  int *d2 ;
  int *r ;
  int *g ;
  int *b ;
  int *nr ;
  int *ng ;
  int *nb ;
  int const   *y ;
  int const   *cb ;
  int const   *cr ;
  int const   *ny ;
  int maxw ;
  int maxh ;
  int max ;
  int offset ;
  int upb ;
  int i ;
  int j ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;

  {
  {
#line 164
  i = (img->comps + 0)->prec;
#line 165
  offset = 1 << (i - 1);
#line 165
  upb = (1 << i) - 1;
#line 167
  maxw = (img->comps + 0)->w;
#line 167
  maxh = (img->comps + 0)->h;
#line 168
  max = maxw * maxh;
#line 170
  y = (int const   *)(img->comps + 0)->data;
#line 171
  cb = (int const   *)(img->comps + 1)->data;
#line 172
  cr = (int const   *)(img->comps + 2)->data;
#line 174
  __cil_tmp22 = malloc(sizeof(int ) * (unsigned long )max);
#line 174
  r = (int *)__cil_tmp22;
#line 174
  d0 = r;
#line 175
  __cil_tmp23 = malloc(sizeof(int ) * (unsigned long )max);
#line 175
  g = (int *)__cil_tmp23;
#line 175
  d1 = g;
#line 176
  __cil_tmp24 = malloc(sizeof(int ) * (unsigned long )max);
#line 176
  b = (int *)__cil_tmp24;
#line 176
  d2 = b;
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < maxh)) {
#line 178
      goto while_break;
    }
#line 180
    ny = y + maxw;
#line 181
    nr = r + maxw;
#line 181
    ng = g + maxw;
#line 181
    nb = b + maxw;
#line 183
    j = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      if (! (j < maxw)) {
#line 183
        goto while_break___0;
      }
      {
#line 185
      sycc_to_rgb___0(offset, upb, *y, *cb, *cr, r, g, b);
#line 187
      y ++;
#line 187
      r ++;
#line 187
      g ++;
#line 187
      b ++;
#line 189
      sycc_to_rgb___0(offset, upb, *y, *cb, *cr, r, g, b);
#line 191
      y ++;
#line 191
      r ++;
#line 191
      g ++;
#line 191
      b ++;
#line 193
      sycc_to_rgb___0(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 195
      ny ++;
#line 195
      nr ++;
#line 195
      ng ++;
#line 195
      nb ++;
#line 197
      sycc_to_rgb___0(offset, upb, *ny, *cb, *cr, nr, ng, nb);
#line 199
      ny ++;
#line 199
      nr ++;
#line 199
      ng ++;
#line 199
      nb ++;
#line 199
      cb ++;
#line 199
      cr ++;
      }
#line 183
      j += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 201
    y += maxw;
#line 201
    r += maxw;
#line 201
    g += maxw;
#line 201
    b += maxw;
#line 178
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  free((img->comps + 0)->data);
#line 203
  (img->comps + 0)->data = d0;
#line 204
  free((img->comps + 1)->data);
#line 204
  (img->comps + 1)->data = d1;
#line 205
  free((img->comps + 2)->data);
#line 205
  (img->comps + 2)->data = d2;
#line 207
  (img->comps + 1)->w = maxw;
#line 207
  (img->comps + 1)->h = maxh;
#line 208
  (img->comps + 2)->w = maxw;
#line 208
  (img->comps + 2)->h = maxh;
#line 209
  (img->comps + 1)->dx = (img->comps + 0)->dx;
#line 210
  (img->comps + 2)->dx = (img->comps + 0)->dx;
#line 211
  (img->comps + 1)->dy = (img->comps + 0)->dy;
#line 212
  (img->comps + 2)->dy = (img->comps + 0)->dy;
  }
  return;
}
}
