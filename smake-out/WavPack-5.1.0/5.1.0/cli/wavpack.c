/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 171 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 206 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 209 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 214 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 40 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __dev_t dev_t;
#line 45 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __gid_t gid_t;
#line 51 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __mode_t mode_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __nlink_t nlink_t;
#line 78 "/usr/include/x86_64-linux-gnu/sys/stat.h"
typedef __uid_t uid_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef unsigned long size_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_1 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_1 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_2 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_2 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_4 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_3 {
   unsigned long long __wseq ;
   struct __anonstruct_4 __wseq32 ;
};
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_6 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
union __anonunion_5 {
   unsigned long long __g1_start ;
   struct __anonstruct_6 __g1_start32 ;
};
#line 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   union __anonunion_3  ;
   unsigned long long __wseq ;
   struct __anonstruct_4 __wseq32 ;
   union __anonunion_5  ;
   unsigned long long __g1_start ;
   struct __anonstruct_6 __g1_start32 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_7 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_7 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_8 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_8 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_9 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_9 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_10 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_10 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_barrierattr_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_17 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_18 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_19 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_20 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_23 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_22 {
   struct __anonstruct_23 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_21 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_22 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_24 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_25 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_16 {
   int _pad[28] ;
   struct __anonstruct_17 _kill ;
   struct __anonstruct_18 _timer ;
   struct __anonstruct_19 _rt ;
   struct __anonstruct_20 _sigchld ;
   struct __anonstruct_21 _sigfault ;
   struct __anonstruct_24 _sigpoll ;
   struct __anonstruct_25 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_15 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_16 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_15 siginfo_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__26 {
    SI_ASYNCNL = -60,
    SI_DETHREAD = -7,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
#line 71
enum __anonenum__27 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
    ILL_BADIADDR = 9
} ;
#line 94
enum __anonenum__28 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
    FPE_FLTUNK = 14,
    FPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum__29 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2,
    SEGV_BNDERR = 3,
    SEGV_PKUERR = 4,
    SEGV_ACCADI = 5,
    SEGV_ADIDERR = 6,
    SEGV_ADIPERR = 7
} ;
#line 138
enum __anonenum__30 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5
} ;
#line 172
enum __anonenum__31 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
#line 189
enum __anonenum__32 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct __anonstruct_34 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union __anonunion_33 {
   int _pad[12] ;
   __pid_t _tid ;
   struct __anonstruct_34 _sigev_thread ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion_33 _sigev_un ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__35 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 190 "/usr/include/signal.h"
typedef __sighandler_t sig_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_36 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_36 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 167 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
union __anonunion_37 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion_37  ;
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
   __uint64_t __reserved1[8] ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
struct __anonstruct_38 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
typedef struct __anonstruct_38 stack_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 108 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 130 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_39 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_39 mcontext_t;
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
#line 151 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__40 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 51 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__41 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum__42 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248
} ;
#line 533
enum __anonenum__43 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 82 "/usr/include/glob.h"
struct __anonstruct_44 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   void *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , void * ) ;
   int (*gl_stat)(char const   * , void * ) ;
};
#line 105 "/usr/include/glob.h"
typedef struct __anonstruct_44 glob_t;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 89
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 105 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 149 "/usr/include/math.h"
typedef float float_t;
#line 150 "/usr/include/math.h"
typedef double double_t;
#line 853
enum __anonenum__45 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h"
typedef int wchar_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
enum __anonenum__46 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h"
typedef enum __anonenum__46 idtype_t;
#line 58 "/usr/include/stdlib.h"
struct __anonstruct_47 {
   int quot ;
   int rem ;
};
#line 62 "/usr/include/stdlib.h"
typedef struct __anonstruct_47 div_t;
#line 66 "/usr/include/stdlib.h"
struct __anonstruct_48 {
   long quot ;
   long rem ;
};
#line 70 "/usr/include/stdlib.h"
typedef struct __anonstruct_48 ldiv_t;
#line 76 "/usr/include/stdlib.h"
struct __anonstruct_49 {
   long long quot ;
   long long rem ;
};
#line 80 "/usr/include/stdlib.h"
typedef struct __anonstruct_49 lldiv_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 490 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 808 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_51 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_50 {
   int __count ;
   union __anonunion_51 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_50 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__52 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 37 "../include/wavpack.h"
struct __anonstruct_53 {
   char ckID[4] ;
   uint32_t ckSize ;
   char formType[4] ;
};
#line 41 "../include/wavpack.h"
typedef struct __anonstruct_53 RiffChunkHeader;
#line 43 "../include/wavpack.h"
struct __anonstruct_54 {
   char ckID[4] ;
   uint32_t ckSize ;
};
#line 46 "../include/wavpack.h"
typedef struct __anonstruct_54 ChunkHeader;
#line 50 "../include/wavpack.h"
struct __anonstruct_55 {
   uint16_t FormatTag ;
   uint16_t NumChannels ;
   uint32_t SampleRate ;
   uint32_t BytesPerSecond ;
   uint16_t BlockAlign ;
   uint16_t BitsPerSample ;
   uint16_t cbSize ;
   uint16_t ValidBitsPerSample ;
   int32_t ChannelMask ;
   uint16_t SubFormat ;
   char GUID[14] ;
};
#line 58 "../include/wavpack.h"
typedef struct __anonstruct_55 WaveHeader;
#line 69 "../include/wavpack.h"
struct __anonstruct_56 {
   char ckID[4] ;
   uint32_t ckSize ;
   int16_t version ;
   unsigned char block_index_u8 ;
   unsigned char total_samples_u8 ;
   uint32_t total_samples ;
   uint32_t block_index ;
   uint32_t block_samples ;
   uint32_t flags ;
   uint32_t crc ;
};
#line 76 "../include/wavpack.h"
typedef struct __anonstruct_56 WavpackHeader;
#line 189 "../include/wavpack.h"
struct __anonstruct_57 {
   float bitrate ;
   float shaping_weight ;
   int bits_per_sample ;
   int bytes_per_sample ;
   int qmode ;
   int flags ;
   int xmode ;
   int num_channels ;
   int float_norm_exp ;
   int32_t block_samples ;
   int32_t extra_flags ;
   int32_t sample_rate ;
   int32_t channel_mask ;
   unsigned char md5_checksum[16] ;
   unsigned char md5_read ;
   int num_tag_strings ;
   char **tag_strings ;
};
#line 197 "../include/wavpack.h"
typedef struct __anonstruct_57 WavpackConfig;
#line 250 "../include/wavpack.h"
struct __anonstruct_58 {
   int32_t (*read_bytes)(void * , void * , int32_t  ) ;
   uint32_t (*get_pos)(void * ) ;
   int (*set_pos_abs)(void * , uint32_t  ) ;
   int (*set_pos_rel)(void * , int32_t  , int  ) ;
   int (*push_back_byte)(void * , int  ) ;
   uint32_t (*get_length)(void * ) ;
   int (*can_seek)(void * ) ;
   int32_t (*write_bytes)(void * , void * , int32_t  ) ;
};
#line 261 "../include/wavpack.h"
typedef struct __anonstruct_58 WavpackStreamReader;
#line 266 "../include/wavpack.h"
struct __anonstruct_59 {
   int32_t (*read_bytes)(void * , void * , int32_t  ) ;
   int32_t (*write_bytes)(void * , void * , int32_t  ) ;
   int64_t (*get_pos)(void * ) ;
   int (*set_pos_abs)(void * , int64_t  ) ;
   int (*set_pos_rel)(void * , int64_t  , int  ) ;
   int (*push_back_byte)(void * , int  ) ;
   int64_t (*get_length)(void * ) ;
   int (*can_seek)(void * ) ;
   int (*truncate_here)(void * ) ;
   int (*close)(void * ) ;
};
#line 277 "../include/wavpack.h"
typedef struct __anonstruct_59 WavpackStreamReader64;
#line 279 "../include/wavpack.h"
typedef int (*WavpackBlockOutput)(void * , void * , int32_t  );
#line 283 "../include/wavpack.h"
typedef void WavpackContext;
#line 5 "/doner/wavpack/wavpack-5.1.0/cli/md5.h"
typedef unsigned int uint32;
#line 10 "/doner/wavpack/wavpack-5.1.0/cli/md5.h"
struct MD5Context {
   uint32 buf[4] ;
   uint32 bits[2] ;
   unsigned char in[64] ;
};
#line 24 "/doner/wavpack/wavpack-5.1.0/cli/md5.h"
typedef struct MD5Context MD5_CTX;
#line 153 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
struct __anonstruct_60 {
   char *default_extension ;
   char *format_name ;
   int (*WriteHeader)(FILE * , WavpackContext * , int64_t  , int  ) ;
   int chunk_alignment ;
};
#line 177 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
struct sample_time_index {
   int value_is_time ;
   int value_is_relative ;
   int value_is_valid ;
   double value ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__80 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 26 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
struct __anonstruct_91 {
   char ckID[16] ;
   int64_t ckSize ;
   char formType[16] ;
};
#line 30 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
typedef struct __anonstruct_91 Wave64FileHeader;
#line 32 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
struct __anonstruct_92 {
   char ckID[16] ;
   int64_t ckSize ;
};
#line 35 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
typedef struct __anonstruct_92 Wave64ChunkHeader;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__95 {
    _PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0 = 20
} ;
#line 71
enum __anonenum__96 {
    _SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0 = 29,
    _SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0 = 53,
    _SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0 = 57,
    _SC_POLL___0 = 58,
    _SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0 = 133,
    _SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0 = 143,
    _SC_FIFO___0 = 144,
    _SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0 = 157,
    _SC_SIGNALS___0 = 158,
    _SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248
} ;
#line 533
enum __anonenum__97 {
    _CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0 = 1149
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__136 {
    SI_ASYNCNL___0 = -60,
    SI_DETHREAD___0 = -7,
    SI_TKILL___0 = -6,
    SI_SIGIO___0 = -5,
    SI_ASYNCIO___0 = -4,
    SI_MESGQ___0 = -3,
    SI_TIMER___0 = -2,
    SI_QUEUE___0 = -1,
    SI_USER___0 = 0,
    SI_KERNEL___0 = 128
} ;
#line 71
enum __anonenum__137 {
    ILL_ILLOPC___0 = 1,
    ILL_ILLOPN___0 = 2,
    ILL_ILLADR___0 = 3,
    ILL_ILLTRP___0 = 4,
    ILL_PRVOPC___0 = 5,
    ILL_PRVREG___0 = 6,
    ILL_COPROC___0 = 7,
    ILL_BADSTK___0 = 8,
    ILL_BADIADDR___0 = 9
} ;
#line 94
enum __anonenum__138 {
    FPE_INTDIV___0 = 1,
    FPE_INTOVF___0 = 2,
    FPE_FLTDIV___0 = 3,
    FPE_FLTOVF___0 = 4,
    FPE_FLTUND___0 = 5,
    FPE_FLTRES___0 = 6,
    FPE_FLTINV___0 = 7,
    FPE_FLTSUB___0 = 8,
    FPE_FLTUNK___0 = 14,
    FPE_CONDTRAP___0 = 15
} ;
#line 119
enum __anonenum__139 {
    SEGV_MAPERR___0 = 1,
    SEGV_ACCERR___0 = 2,
    SEGV_BNDERR___0 = 3,
    SEGV_PKUERR___0 = 4,
    SEGV_ACCADI___0 = 5,
    SEGV_ADIDERR___0 = 6,
    SEGV_ADIPERR___0 = 7
} ;
#line 138
enum __anonenum__140 {
    BUS_ADRALN___0 = 1,
    BUS_ADRERR___0 = 2,
    BUS_OBJERR___0 = 3,
    BUS_MCEERR_AR___0 = 4,
    BUS_MCEERR_AO___0 = 5
} ;
#line 172
enum __anonenum__141 {
    CLD_EXITED___0 = 1,
    CLD_KILLED___0 = 2,
    CLD_DUMPED___0 = 3,
    CLD_TRAPPED___0 = 4,
    CLD_STOPPED___0 = 5,
    CLD_CONTINUED___0 = 6
} ;
#line 189
enum __anonenum__142 {
    POLL_IN___0 = 1,
    POLL_OUT___0 = 2,
    POLL_MSG___0 = 3,
    POLL_ERR___0 = 4,
    POLL_PRI___0 = 5,
    POLL_HUP___0 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__145 {
    SIGEV_SIGNAL___0 = 0,
    SIGEV_NONE___0 = 1,
    SIGEV_THREAD___0 = 2,
    SIGEV_THREAD_ID___0 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__150 {
    SS_ONSTACK___0 = 1,
    SS_DISABLE___0 = 2
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__80___0 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83___0 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 27 "/doner/wavpack/wavpack-5.1.0/cli/riff.c"
struct __anonstruct_151 {
   char ckID[4] ;
   uint64_t chunkSize64 ;
};
#line 30 "/doner/wavpack/wavpack-5.1.0/cli/riff.c"
typedef struct __anonstruct_151 CS64Chunk;
#line 32 "/doner/wavpack/wavpack-5.1.0/cli/riff.c"
struct __anonstruct_152 {
   uint64_t riffSize64 ;
   uint64_t dataSize64 ;
   uint64_t sampleCount64 ;
   uint32_t tableLength ;
};
#line 35 "/doner/wavpack/wavpack-5.1.0/cli/riff.c"
typedef struct __anonstruct_152 DS64Chunk;
#line 37 "/doner/wavpack/wavpack-5.1.0/cli/riff.c"
struct __anonstruct_153 {
   char ckID[4] ;
   uint32_t ckSize ;
   char junk[28] ;
};
#line 41 "/doner/wavpack/wavpack-5.1.0/cli/riff.c"
typedef struct __anonstruct_153 JunkChunk;
#line 853 "/usr/include/math.h"
enum __anonenum__80___1 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83___1 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 36 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
struct __anonstruct_154 {
   char ckID[4] ;
   int64_t ckSize ;
};
#line 39 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
typedef struct __anonstruct_154 DSFChunkHeader;
#line 41 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
struct __anonstruct_155 {
   char ckID[4] ;
   int64_t ckSize ;
   int64_t fileSize ;
   int64_t metaOffset ;
};
#line 46 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
typedef struct __anonstruct_155 DSFFileChunk;
#line 48 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
struct __anonstruct_156 {
   char ckID[4] ;
   int64_t ckSize ;
   uint32_t formatVersion ;
   uint32_t formatID ;
   uint32_t chanType ;
   uint32_t numChannels ;
   uint32_t sampleRate ;
   uint32_t bitsPerSample ;
   int64_t sampleCount ;
   uint32_t blockSize ;
   uint32_t reserved ;
};
#line 55 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
typedef struct __anonstruct_156 DSFFormatChunk;
#line 853 "/usr/include/math.h"
enum __anonenum__80___2 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83___2 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 36 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
struct __anonstruct_154___0 {
   char ckID[4] ;
   int64_t ckDataSize ;
};
#line 39 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
typedef struct __anonstruct_154___0 DFFChunkHeader;
#line 41 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
struct __anonstruct_155___0 {
   char ckID[4] ;
   int64_t ckDataSize ;
   char formType[4] ;
};
#line 45 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
typedef struct __anonstruct_155___0 DFFFileHeader;
#line 47 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
struct __anonstruct_157 {
   char ckID[4] ;
   int64_t ckDataSize ;
   uint32_t version ;
};
#line 51 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
typedef struct __anonstruct_157 DFFVersionChunk;
#line 53 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
struct __anonstruct_158 {
   char ckID[4] ;
   int64_t ckDataSize ;
   uint32_t sampleRate ;
};
#line 57 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
typedef struct __anonstruct_158 DFFSampleRateChunk;
#line 59 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
struct __anonstruct_159 {
   char ckID[4] ;
   int64_t ckDataSize ;
   uint16_t numChannels ;
};
#line 63 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
typedef struct __anonstruct_159 DFFChannelsHeader;
#line 65 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
struct __anonstruct_160 {
   char ckID[4] ;
   int64_t ckDataSize ;
   char compressionType[4] ;
};
#line 69 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
typedef struct __anonstruct_160 DFFCompressionHeader;
#line 853 "/usr/include/math.h"
enum __anonenum__80___3 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83___3 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 35 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
struct __anonstruct_161 {
   char mFileType[4] ;
   uint16_t mFileVersion ;
   uint16_t mFileFlags ;
};
#line 40 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
typedef struct __anonstruct_161 CAFFileHeader;
#line 45 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
struct __anonstruct_155___1 {
   char mChunkType[4] ;
   int64_t mChunkSize ;
};
#line 49 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
typedef struct __anonstruct_155___1 CAFChunkHeader;
#line 54 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
struct __anonstruct_162 {
   double mSampleRate ;
   char mFormatID[4] ;
   uint32_t mFormatFlags ;
   uint32_t mBytesPerPacket ;
   uint32_t mFramesPerPacket ;
   uint32_t mChannelsPerFrame ;
   uint32_t mBitsPerChannel ;
};
#line 63 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
typedef struct __anonstruct_162 CAFAudioFormat;
#line 69 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
struct __anonstruct_163 {
   uint32_t mChannelLayoutTag ;
   uint32_t mChannelBitmap ;
   uint32_t mNumberChannelDescriptions ;
};
#line 74 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
typedef struct __anonstruct_163 CAFChannelLayout;
#line 78
enum __anonenum__164 {
    kCAFChannelLayoutTag_UseChannelDescriptions = 0,
    kCAFChannelLayoutTag_UseChannelBitmap = 65536
} ;
#line 83 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
struct __anonstruct_165 {
   uint32_t mChannelLabel ;
   uint32_t mChannelFlags ;
   float mCoordinates[3] ;
};
#line 88 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
typedef struct __anonstruct_165 CAFChannelDescription;
#line 95 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
struct __anonstruct_166 {
   uint32_t mChannelLayoutTag ;
   uint32_t mChannelBitmap ;
   char const   *mChannelReorder ;
   char const   *mChannelIdentities ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__192 {
    SI_ASYNCNL___1 = -60,
    SI_DETHREAD___1 = -7,
    SI_TKILL___1 = -6,
    SI_SIGIO___1 = -5,
    SI_ASYNCIO___1 = -4,
    SI_MESGQ___1 = -3,
    SI_TIMER___1 = -2,
    SI_QUEUE___1 = -1,
    SI_USER___1 = 0,
    SI_KERNEL___1 = 128
} ;
#line 71
enum __anonenum__193 {
    ILL_ILLOPC___1 = 1,
    ILL_ILLOPN___1 = 2,
    ILL_ILLADR___1 = 3,
    ILL_ILLTRP___1 = 4,
    ILL_PRVOPC___1 = 5,
    ILL_PRVREG___1 = 6,
    ILL_COPROC___1 = 7,
    ILL_BADSTK___1 = 8,
    ILL_BADIADDR___1 = 9
} ;
#line 94
enum __anonenum__194 {
    FPE_INTDIV___1 = 1,
    FPE_INTOVF___1 = 2,
    FPE_FLTDIV___1 = 3,
    FPE_FLTOVF___1 = 4,
    FPE_FLTUND___1 = 5,
    FPE_FLTRES___1 = 6,
    FPE_FLTINV___1 = 7,
    FPE_FLTSUB___1 = 8,
    FPE_FLTUNK___1 = 14,
    FPE_CONDTRAP___1 = 15
} ;
#line 119
enum __anonenum__195 {
    SEGV_MAPERR___1 = 1,
    SEGV_ACCERR___1 = 2,
    SEGV_BNDERR___1 = 3,
    SEGV_PKUERR___1 = 4,
    SEGV_ACCADI___1 = 5,
    SEGV_ADIDERR___1 = 6,
    SEGV_ADIPERR___1 = 7
} ;
#line 138
enum __anonenum__196 {
    BUS_ADRALN___1 = 1,
    BUS_ADRERR___1 = 2,
    BUS_OBJERR___1 = 3,
    BUS_MCEERR_AR___1 = 4,
    BUS_MCEERR_AO___1 = 5
} ;
#line 172
enum __anonenum__197 {
    CLD_EXITED___1 = 1,
    CLD_KILLED___1 = 2,
    CLD_DUMPED___1 = 3,
    CLD_TRAPPED___1 = 4,
    CLD_STOPPED___1 = 5,
    CLD_CONTINUED___1 = 6
} ;
#line 189
enum __anonenum__198 {
    POLL_IN___1 = 1,
    POLL_OUT___1 = 2,
    POLL_MSG___1 = 3,
    POLL_ERR___1 = 4,
    POLL_PRI___1 = 5,
    POLL_HUP___1 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__201 {
    SIGEV_SIGNAL___1 = 0,
    SIGEV_NONE___1 = 1,
    SIGEV_THREAD___1 = 2,
    SIGEV_THREAD_ID___1 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__206 {
    SS_ONSTACK___1 = 1,
    SS_DISABLE___1 = 2
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__211 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__214 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__222 {
    _PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1 = 20
} ;
#line 71
enum __anonenum__223 {
    _SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1 = 29,
    _SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1 = 53,
    _SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1 = 57,
    _SC_POLL___1 = 58,
    _SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1 = 133,
    _SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1 = 143,
    _SC_FIFO___1 = 144,
    _SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1 = 157,
    _SC_SIGNALS___1 = 158,
    _SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248
} ;
#line 533
enum __anonenum__224 {
    _CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1 = 1149
} ;
#line 147 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
struct tag_item {
   char *item ;
   char *value ;
   char *ext ;
   int vsize ;
   int binary ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__95___0 {
    _PC_LINK_MAX___2 = 0,
    _PC_MAX_CANON___2 = 1,
    _PC_MAX_INPUT___2 = 2,
    _PC_NAME_MAX___2 = 3,
    _PC_PATH_MAX___2 = 4,
    _PC_PIPE_BUF___2 = 5,
    _PC_CHOWN_RESTRICTED___2 = 6,
    _PC_NO_TRUNC___2 = 7,
    _PC_VDISABLE___2 = 8,
    _PC_SYNC_IO___2 = 9,
    _PC_ASYNC_IO___2 = 10,
    _PC_PRIO_IO___2 = 11,
    _PC_SOCK_MAXBUF___2 = 12,
    _PC_FILESIZEBITS___2 = 13,
    _PC_REC_INCR_XFER_SIZE___2 = 14,
    _PC_REC_MAX_XFER_SIZE___2 = 15,
    _PC_REC_MIN_XFER_SIZE___2 = 16,
    _PC_REC_XFER_ALIGN___2 = 17,
    _PC_ALLOC_SIZE_MIN___2 = 18,
    _PC_SYMLINK_MAX___2 = 19,
    _PC_2_SYMLINKS___2 = 20
} ;
#line 71
enum __anonenum__96___0 {
    _SC_ARG_MAX___2 = 0,
    _SC_CHILD_MAX___2 = 1,
    _SC_CLK_TCK___2 = 2,
    _SC_NGROUPS_MAX___2 = 3,
    _SC_OPEN_MAX___2 = 4,
    _SC_STREAM_MAX___2 = 5,
    _SC_TZNAME_MAX___2 = 6,
    _SC_JOB_CONTROL___2 = 7,
    _SC_SAVED_IDS___2 = 8,
    _SC_REALTIME_SIGNALS___2 = 9,
    _SC_PRIORITY_SCHEDULING___2 = 10,
    _SC_TIMERS___2 = 11,
    _SC_ASYNCHRONOUS_IO___2 = 12,
    _SC_PRIORITIZED_IO___2 = 13,
    _SC_SYNCHRONIZED_IO___2 = 14,
    _SC_FSYNC___2 = 15,
    _SC_MAPPED_FILES___2 = 16,
    _SC_MEMLOCK___2 = 17,
    _SC_MEMLOCK_RANGE___2 = 18,
    _SC_MEMORY_PROTECTION___2 = 19,
    _SC_MESSAGE_PASSING___2 = 20,
    _SC_SEMAPHORES___2 = 21,
    _SC_SHARED_MEMORY_OBJECTS___2 = 22,
    _SC_AIO_LISTIO_MAX___2 = 23,
    _SC_AIO_MAX___2 = 24,
    _SC_AIO_PRIO_DELTA_MAX___2 = 25,
    _SC_DELAYTIMER_MAX___2 = 26,
    _SC_MQ_OPEN_MAX___2 = 27,
    _SC_MQ_PRIO_MAX___2 = 28,
    _SC_VERSION___2 = 29,
    _SC_PAGESIZE___2 = 30,
    _SC_RTSIG_MAX___2 = 31,
    _SC_SEM_NSEMS_MAX___2 = 32,
    _SC_SEM_VALUE_MAX___2 = 33,
    _SC_SIGQUEUE_MAX___2 = 34,
    _SC_TIMER_MAX___2 = 35,
    _SC_BC_BASE_MAX___2 = 36,
    _SC_BC_DIM_MAX___2 = 37,
    _SC_BC_SCALE_MAX___2 = 38,
    _SC_BC_STRING_MAX___2 = 39,
    _SC_COLL_WEIGHTS_MAX___2 = 40,
    _SC_EQUIV_CLASS_MAX___2 = 41,
    _SC_EXPR_NEST_MAX___2 = 42,
    _SC_LINE_MAX___2 = 43,
    _SC_RE_DUP_MAX___2 = 44,
    _SC_CHARCLASS_NAME_MAX___2 = 45,
    _SC_2_VERSION___2 = 46,
    _SC_2_C_BIND___2 = 47,
    _SC_2_C_DEV___2 = 48,
    _SC_2_FORT_DEV___2 = 49,
    _SC_2_FORT_RUN___2 = 50,
    _SC_2_SW_DEV___2 = 51,
    _SC_2_LOCALEDEF___2 = 52,
    _SC_PII___2 = 53,
    _SC_PII_XTI___2 = 54,
    _SC_PII_SOCKET___2 = 55,
    _SC_PII_INTERNET___2 = 56,
    _SC_PII_OSI___2 = 57,
    _SC_POLL___2 = 58,
    _SC_SELECT___2 = 59,
    _SC_UIO_MAXIOV___2 = 60,
    _SC_IOV_MAX___2 = 60,
    _SC_PII_INTERNET_STREAM___2 = 61,
    _SC_PII_INTERNET_DGRAM___2 = 62,
    _SC_PII_OSI_COTS___2 = 63,
    _SC_PII_OSI_CLTS___2 = 64,
    _SC_PII_OSI_M___2 = 65,
    _SC_T_IOV_MAX___2 = 66,
    _SC_THREADS___2 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___2 = 68,
    _SC_GETGR_R_SIZE_MAX___2 = 69,
    _SC_GETPW_R_SIZE_MAX___2 = 70,
    _SC_LOGIN_NAME_MAX___2 = 71,
    _SC_TTY_NAME_MAX___2 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___2 = 73,
    _SC_THREAD_KEYS_MAX___2 = 74,
    _SC_THREAD_STACK_MIN___2 = 75,
    _SC_THREAD_THREADS_MAX___2 = 76,
    _SC_THREAD_ATTR_STACKADDR___2 = 77,
    _SC_THREAD_ATTR_STACKSIZE___2 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___2 = 79,
    _SC_THREAD_PRIO_INHERIT___2 = 80,
    _SC_THREAD_PRIO_PROTECT___2 = 81,
    _SC_THREAD_PROCESS_SHARED___2 = 82,
    _SC_NPROCESSORS_CONF___2 = 83,
    _SC_NPROCESSORS_ONLN___2 = 84,
    _SC_PHYS_PAGES___2 = 85,
    _SC_AVPHYS_PAGES___2 = 86,
    _SC_ATEXIT_MAX___2 = 87,
    _SC_PASS_MAX___2 = 88,
    _SC_XOPEN_VERSION___2 = 89,
    _SC_XOPEN_XCU_VERSION___2 = 90,
    _SC_XOPEN_UNIX___2 = 91,
    _SC_XOPEN_CRYPT___2 = 92,
    _SC_XOPEN_ENH_I18N___2 = 93,
    _SC_XOPEN_SHM___2 = 94,
    _SC_2_CHAR_TERM___2 = 95,
    _SC_2_C_VERSION___2 = 96,
    _SC_2_UPE___2 = 97,
    _SC_XOPEN_XPG2___2 = 98,
    _SC_XOPEN_XPG3___2 = 99,
    _SC_XOPEN_XPG4___2 = 100,
    _SC_CHAR_BIT___2 = 101,
    _SC_CHAR_MAX___2 = 102,
    _SC_CHAR_MIN___2 = 103,
    _SC_INT_MAX___2 = 104,
    _SC_INT_MIN___2 = 105,
    _SC_LONG_BIT___2 = 106,
    _SC_WORD_BIT___2 = 107,
    _SC_MB_LEN_MAX___2 = 108,
    _SC_NZERO___2 = 109,
    _SC_SSIZE_MAX___2 = 110,
    _SC_SCHAR_MAX___2 = 111,
    _SC_SCHAR_MIN___2 = 112,
    _SC_SHRT_MAX___2 = 113,
    _SC_SHRT_MIN___2 = 114,
    _SC_UCHAR_MAX___2 = 115,
    _SC_UINT_MAX___2 = 116,
    _SC_ULONG_MAX___2 = 117,
    _SC_USHRT_MAX___2 = 118,
    _SC_NL_ARGMAX___2 = 119,
    _SC_NL_LANGMAX___2 = 120,
    _SC_NL_MSGMAX___2 = 121,
    _SC_NL_NMAX___2 = 122,
    _SC_NL_SETMAX___2 = 123,
    _SC_NL_TEXTMAX___2 = 124,
    _SC_XBS5_ILP32_OFF32___2 = 125,
    _SC_XBS5_ILP32_OFFBIG___2 = 126,
    _SC_XBS5_LP64_OFF64___2 = 127,
    _SC_XBS5_LPBIG_OFFBIG___2 = 128,
    _SC_XOPEN_LEGACY___2 = 129,
    _SC_XOPEN_REALTIME___2 = 130,
    _SC_XOPEN_REALTIME_THREADS___2 = 131,
    _SC_ADVISORY_INFO___2 = 132,
    _SC_BARRIERS___2 = 133,
    _SC_BASE___2 = 134,
    _SC_C_LANG_SUPPORT___2 = 135,
    _SC_C_LANG_SUPPORT_R___2 = 136,
    _SC_CLOCK_SELECTION___2 = 137,
    _SC_CPUTIME___2 = 138,
    _SC_THREAD_CPUTIME___2 = 139,
    _SC_DEVICE_IO___2 = 140,
    _SC_DEVICE_SPECIFIC___2 = 141,
    _SC_DEVICE_SPECIFIC_R___2 = 142,
    _SC_FD_MGMT___2 = 143,
    _SC_FIFO___2 = 144,
    _SC_PIPE___2 = 145,
    _SC_FILE_ATTRIBUTES___2 = 146,
    _SC_FILE_LOCKING___2 = 147,
    _SC_FILE_SYSTEM___2 = 148,
    _SC_MONOTONIC_CLOCK___2 = 149,
    _SC_MULTI_PROCESS___2 = 150,
    _SC_SINGLE_PROCESS___2 = 151,
    _SC_NETWORKING___2 = 152,
    _SC_READER_WRITER_LOCKS___2 = 153,
    _SC_SPIN_LOCKS___2 = 154,
    _SC_REGEXP___2 = 155,
    _SC_REGEX_VERSION___2 = 156,
    _SC_SHELL___2 = 157,
    _SC_SIGNALS___2 = 158,
    _SC_SPAWN___2 = 159,
    _SC_SPORADIC_SERVER___2 = 160,
    _SC_THREAD_SPORADIC_SERVER___2 = 161,
    _SC_SYSTEM_DATABASE___2 = 162,
    _SC_SYSTEM_DATABASE_R___2 = 163,
    _SC_TIMEOUTS___2 = 164,
    _SC_TYPED_MEMORY_OBJECTS___2 = 165,
    _SC_USER_GROUPS___2 = 166,
    _SC_USER_GROUPS_R___2 = 167,
    _SC_2_PBS___2 = 168,
    _SC_2_PBS_ACCOUNTING___2 = 169,
    _SC_2_PBS_LOCATE___2 = 170,
    _SC_2_PBS_MESSAGE___2 = 171,
    _SC_2_PBS_TRACK___2 = 172,
    _SC_SYMLOOP_MAX___2 = 173,
    _SC_STREAMS___2 = 174,
    _SC_2_PBS_CHECKPOINT___2 = 175,
    _SC_V6_ILP32_OFF32___2 = 176,
    _SC_V6_ILP32_OFFBIG___2 = 177,
    _SC_V6_LP64_OFF64___2 = 178,
    _SC_V6_LPBIG_OFFBIG___2 = 179,
    _SC_HOST_NAME_MAX___2 = 180,
    _SC_TRACE___2 = 181,
    _SC_TRACE_EVENT_FILTER___2 = 182,
    _SC_TRACE_INHERIT___2 = 183,
    _SC_TRACE_LOG___2 = 184,
    _SC_LEVEL1_ICACHE_SIZE___2 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___2 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___2 = 187,
    _SC_LEVEL1_DCACHE_SIZE___2 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___2 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___2 = 190,
    _SC_LEVEL2_CACHE_SIZE___2 = 191,
    _SC_LEVEL2_CACHE_ASSOC___2 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___2 = 193,
    _SC_LEVEL3_CACHE_SIZE___2 = 194,
    _SC_LEVEL3_CACHE_ASSOC___2 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___2 = 196,
    _SC_LEVEL4_CACHE_SIZE___2 = 197,
    _SC_LEVEL4_CACHE_ASSOC___2 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___2 = 199,
    _SC_IPV6___2 = 235,
    _SC_RAW_SOCKETS___2 = 236,
    _SC_V7_ILP32_OFF32___2 = 237,
    _SC_V7_ILP32_OFFBIG___2 = 238,
    _SC_V7_LP64_OFF64___2 = 239,
    _SC_V7_LPBIG_OFFBIG___2 = 240,
    _SC_SS_REPL_MAX___2 = 241,
    _SC_TRACE_EVENT_NAME_MAX___2 = 242,
    _SC_TRACE_NAME_MAX___2 = 243,
    _SC_TRACE_SYS_MAX___2 = 244,
    _SC_TRACE_USER_EVENT_MAX___2 = 245,
    _SC_XOPEN_STREAMS___2 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___2 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___2 = 248
} ;
#line 533
enum __anonenum__97___0 {
    _CS_PATH___2 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___2 = 1,
    _CS_GNU_LIBC_VERSION___2 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___2 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___2 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___2 = 5,
    _CS_LFS_CFLAGS___2 = 1000,
    _CS_LFS_LDFLAGS___2 = 1001,
    _CS_LFS_LIBS___2 = 1002,
    _CS_LFS_LINTFLAGS___2 = 1003,
    _CS_LFS64_CFLAGS___2 = 1004,
    _CS_LFS64_LDFLAGS___2 = 1005,
    _CS_LFS64_LIBS___2 = 1006,
    _CS_LFS64_LINTFLAGS___2 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___2 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___2 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___2 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___2 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___2 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___2 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___2 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___2 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___2 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___2 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___2 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___2 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___2 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___2 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___2 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___2 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___2 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___2 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___2 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___2 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___2 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___2 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___2 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___2 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___2 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2 = 1147,
    _CS_V6_ENV___2 = 1148,
    _CS_V7_ENV___2 = 1149
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__136___0 {
    SI_ASYNCNL___2 = -60,
    SI_DETHREAD___2 = -7,
    SI_TKILL___2 = -6,
    SI_SIGIO___2 = -5,
    SI_ASYNCIO___2 = -4,
    SI_MESGQ___2 = -3,
    SI_TIMER___2 = -2,
    SI_QUEUE___2 = -1,
    SI_USER___2 = 0,
    SI_KERNEL___2 = 128
} ;
#line 71
enum __anonenum__137___0 {
    ILL_ILLOPC___2 = 1,
    ILL_ILLOPN___2 = 2,
    ILL_ILLADR___2 = 3,
    ILL_ILLTRP___2 = 4,
    ILL_PRVOPC___2 = 5,
    ILL_PRVREG___2 = 6,
    ILL_COPROC___2 = 7,
    ILL_BADSTK___2 = 8,
    ILL_BADIADDR___2 = 9
} ;
#line 94
enum __anonenum__138___0 {
    FPE_INTDIV___2 = 1,
    FPE_INTOVF___2 = 2,
    FPE_FLTDIV___2 = 3,
    FPE_FLTOVF___2 = 4,
    FPE_FLTUND___2 = 5,
    FPE_FLTRES___2 = 6,
    FPE_FLTINV___2 = 7,
    FPE_FLTSUB___2 = 8,
    FPE_FLTUNK___2 = 14,
    FPE_CONDTRAP___2 = 15
} ;
#line 119
enum __anonenum__139___0 {
    SEGV_MAPERR___2 = 1,
    SEGV_ACCERR___2 = 2,
    SEGV_BNDERR___2 = 3,
    SEGV_PKUERR___2 = 4,
    SEGV_ACCADI___2 = 5,
    SEGV_ADIDERR___2 = 6,
    SEGV_ADIPERR___2 = 7
} ;
#line 138
enum __anonenum__140___0 {
    BUS_ADRALN___2 = 1,
    BUS_ADRERR___2 = 2,
    BUS_OBJERR___2 = 3,
    BUS_MCEERR_AR___2 = 4,
    BUS_MCEERR_AO___2 = 5
} ;
#line 172
enum __anonenum__141___0 {
    CLD_EXITED___2 = 1,
    CLD_KILLED___2 = 2,
    CLD_DUMPED___2 = 3,
    CLD_TRAPPED___2 = 4,
    CLD_STOPPED___2 = 5,
    CLD_CONTINUED___2 = 6
} ;
#line 189
enum __anonenum__142___0 {
    POLL_IN___2 = 1,
    POLL_OUT___2 = 2,
    POLL_MSG___2 = 3,
    POLL_ERR___2 = 4,
    POLL_PRI___2 = 5,
    POLL_HUP___2 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__145___0 {
    SIGEV_SIGNAL___2 = 0,
    SIGEV_NONE___2 = 1,
    SIGEV_THREAD___2 = 2,
    SIGEV_THREAD_ID___2 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__150___0 {
    SS_ONSTACK___2 = 1,
    SS_DISABLE___2 = 2
} ;
#line 22 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
struct __anonstruct_253 {
   char *id3_item ;
   char *ape_item ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__26___0 {
    SI_ASYNCNL___3 = -60,
    SI_DETHREAD___3 = -7,
    SI_TKILL___3 = -6,
    SI_SIGIO___3 = -5,
    SI_ASYNCIO___3 = -4,
    SI_MESGQ___3 = -3,
    SI_TIMER___3 = -2,
    SI_QUEUE___3 = -1,
    SI_USER___3 = 0,
    SI_KERNEL___3 = 128
} ;
#line 71
enum __anonenum__27___0 {
    ILL_ILLOPC___3 = 1,
    ILL_ILLOPN___3 = 2,
    ILL_ILLADR___3 = 3,
    ILL_ILLTRP___3 = 4,
    ILL_PRVOPC___3 = 5,
    ILL_PRVREG___3 = 6,
    ILL_COPROC___3 = 7,
    ILL_BADSTK___3 = 8,
    ILL_BADIADDR___3 = 9
} ;
#line 94
enum __anonenum__28___0 {
    FPE_INTDIV___3 = 1,
    FPE_INTOVF___3 = 2,
    FPE_FLTDIV___3 = 3,
    FPE_FLTOVF___3 = 4,
    FPE_FLTUND___3 = 5,
    FPE_FLTRES___3 = 6,
    FPE_FLTINV___3 = 7,
    FPE_FLTSUB___3 = 8,
    FPE_FLTUNK___3 = 14,
    FPE_CONDTRAP___3 = 15
} ;
#line 119
enum __anonenum__29___0 {
    SEGV_MAPERR___3 = 1,
    SEGV_ACCERR___3 = 2,
    SEGV_BNDERR___3 = 3,
    SEGV_PKUERR___3 = 4,
    SEGV_ACCADI___3 = 5,
    SEGV_ADIDERR___3 = 6,
    SEGV_ADIPERR___3 = 7
} ;
#line 138
enum __anonenum__30___0 {
    BUS_ADRALN___3 = 1,
    BUS_ADRERR___3 = 2,
    BUS_OBJERR___3 = 3,
    BUS_MCEERR_AR___3 = 4,
    BUS_MCEERR_AO___3 = 5
} ;
#line 172
enum __anonenum__31___0 {
    CLD_EXITED___3 = 1,
    CLD_KILLED___3 = 2,
    CLD_DUMPED___3 = 3,
    CLD_TRAPPED___3 = 4,
    CLD_STOPPED___3 = 5,
    CLD_CONTINUED___3 = 6
} ;
#line 189
enum __anonenum__32___0 {
    POLL_IN___3 = 1,
    POLL_OUT___3 = 2,
    POLL_MSG___3 = 3,
    POLL_ERR___3 = 4,
    POLL_PRI___3 = 5,
    POLL_HUP___3 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__35___0 {
    SIGEV_SIGNAL___3 = 0,
    SIGEV_NONE___3 = 1,
    SIGEV_THREAD___3 = 2,
    SIGEV_THREAD_ID___3 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__40___0 {
    SS_ONSTACK___3 = 1,
    SS_DISABLE___3 = 2
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__254 {
    _PC_LINK_MAX___3 = 0,
    _PC_MAX_CANON___3 = 1,
    _PC_MAX_INPUT___3 = 2,
    _PC_NAME_MAX___3 = 3,
    _PC_PATH_MAX___3 = 4,
    _PC_PIPE_BUF___3 = 5,
    _PC_CHOWN_RESTRICTED___3 = 6,
    _PC_NO_TRUNC___3 = 7,
    _PC_VDISABLE___3 = 8,
    _PC_SYNC_IO___3 = 9,
    _PC_ASYNC_IO___3 = 10,
    _PC_PRIO_IO___3 = 11,
    _PC_SOCK_MAXBUF___3 = 12,
    _PC_FILESIZEBITS___3 = 13,
    _PC_REC_INCR_XFER_SIZE___3 = 14,
    _PC_REC_MAX_XFER_SIZE___3 = 15,
    _PC_REC_MIN_XFER_SIZE___3 = 16,
    _PC_REC_XFER_ALIGN___3 = 17,
    _PC_ALLOC_SIZE_MIN___3 = 18,
    _PC_SYMLINK_MAX___3 = 19,
    _PC_2_SYMLINKS___3 = 20
} ;
#line 71
enum __anonenum__255 {
    _SC_ARG_MAX___3 = 0,
    _SC_CHILD_MAX___3 = 1,
    _SC_CLK_TCK___3 = 2,
    _SC_NGROUPS_MAX___3 = 3,
    _SC_OPEN_MAX___3 = 4,
    _SC_STREAM_MAX___3 = 5,
    _SC_TZNAME_MAX___3 = 6,
    _SC_JOB_CONTROL___3 = 7,
    _SC_SAVED_IDS___3 = 8,
    _SC_REALTIME_SIGNALS___3 = 9,
    _SC_PRIORITY_SCHEDULING___3 = 10,
    _SC_TIMERS___3 = 11,
    _SC_ASYNCHRONOUS_IO___3 = 12,
    _SC_PRIORITIZED_IO___3 = 13,
    _SC_SYNCHRONIZED_IO___3 = 14,
    _SC_FSYNC___3 = 15,
    _SC_MAPPED_FILES___3 = 16,
    _SC_MEMLOCK___3 = 17,
    _SC_MEMLOCK_RANGE___3 = 18,
    _SC_MEMORY_PROTECTION___3 = 19,
    _SC_MESSAGE_PASSING___3 = 20,
    _SC_SEMAPHORES___3 = 21,
    _SC_SHARED_MEMORY_OBJECTS___3 = 22,
    _SC_AIO_LISTIO_MAX___3 = 23,
    _SC_AIO_MAX___3 = 24,
    _SC_AIO_PRIO_DELTA_MAX___3 = 25,
    _SC_DELAYTIMER_MAX___3 = 26,
    _SC_MQ_OPEN_MAX___3 = 27,
    _SC_MQ_PRIO_MAX___3 = 28,
    _SC_VERSION___3 = 29,
    _SC_PAGESIZE___3 = 30,
    _SC_RTSIG_MAX___3 = 31,
    _SC_SEM_NSEMS_MAX___3 = 32,
    _SC_SEM_VALUE_MAX___3 = 33,
    _SC_SIGQUEUE_MAX___3 = 34,
    _SC_TIMER_MAX___3 = 35,
    _SC_BC_BASE_MAX___3 = 36,
    _SC_BC_DIM_MAX___3 = 37,
    _SC_BC_SCALE_MAX___3 = 38,
    _SC_BC_STRING_MAX___3 = 39,
    _SC_COLL_WEIGHTS_MAX___3 = 40,
    _SC_EQUIV_CLASS_MAX___3 = 41,
    _SC_EXPR_NEST_MAX___3 = 42,
    _SC_LINE_MAX___3 = 43,
    _SC_RE_DUP_MAX___3 = 44,
    _SC_CHARCLASS_NAME_MAX___3 = 45,
    _SC_2_VERSION___3 = 46,
    _SC_2_C_BIND___3 = 47,
    _SC_2_C_DEV___3 = 48,
    _SC_2_FORT_DEV___3 = 49,
    _SC_2_FORT_RUN___3 = 50,
    _SC_2_SW_DEV___3 = 51,
    _SC_2_LOCALEDEF___3 = 52,
    _SC_PII___3 = 53,
    _SC_PII_XTI___3 = 54,
    _SC_PII_SOCKET___3 = 55,
    _SC_PII_INTERNET___3 = 56,
    _SC_PII_OSI___3 = 57,
    _SC_POLL___3 = 58,
    _SC_SELECT___3 = 59,
    _SC_UIO_MAXIOV___3 = 60,
    _SC_IOV_MAX___3 = 60,
    _SC_PII_INTERNET_STREAM___3 = 61,
    _SC_PII_INTERNET_DGRAM___3 = 62,
    _SC_PII_OSI_COTS___3 = 63,
    _SC_PII_OSI_CLTS___3 = 64,
    _SC_PII_OSI_M___3 = 65,
    _SC_T_IOV_MAX___3 = 66,
    _SC_THREADS___3 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___3 = 68,
    _SC_GETGR_R_SIZE_MAX___3 = 69,
    _SC_GETPW_R_SIZE_MAX___3 = 70,
    _SC_LOGIN_NAME_MAX___3 = 71,
    _SC_TTY_NAME_MAX___3 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___3 = 73,
    _SC_THREAD_KEYS_MAX___3 = 74,
    _SC_THREAD_STACK_MIN___3 = 75,
    _SC_THREAD_THREADS_MAX___3 = 76,
    _SC_THREAD_ATTR_STACKADDR___3 = 77,
    _SC_THREAD_ATTR_STACKSIZE___3 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___3 = 79,
    _SC_THREAD_PRIO_INHERIT___3 = 80,
    _SC_THREAD_PRIO_PROTECT___3 = 81,
    _SC_THREAD_PROCESS_SHARED___3 = 82,
    _SC_NPROCESSORS_CONF___3 = 83,
    _SC_NPROCESSORS_ONLN___3 = 84,
    _SC_PHYS_PAGES___3 = 85,
    _SC_AVPHYS_PAGES___3 = 86,
    _SC_ATEXIT_MAX___3 = 87,
    _SC_PASS_MAX___3 = 88,
    _SC_XOPEN_VERSION___3 = 89,
    _SC_XOPEN_XCU_VERSION___3 = 90,
    _SC_XOPEN_UNIX___3 = 91,
    _SC_XOPEN_CRYPT___3 = 92,
    _SC_XOPEN_ENH_I18N___3 = 93,
    _SC_XOPEN_SHM___3 = 94,
    _SC_2_CHAR_TERM___3 = 95,
    _SC_2_C_VERSION___3 = 96,
    _SC_2_UPE___3 = 97,
    _SC_XOPEN_XPG2___3 = 98,
    _SC_XOPEN_XPG3___3 = 99,
    _SC_XOPEN_XPG4___3 = 100,
    _SC_CHAR_BIT___3 = 101,
    _SC_CHAR_MAX___3 = 102,
    _SC_CHAR_MIN___3 = 103,
    _SC_INT_MAX___3 = 104,
    _SC_INT_MIN___3 = 105,
    _SC_LONG_BIT___3 = 106,
    _SC_WORD_BIT___3 = 107,
    _SC_MB_LEN_MAX___3 = 108,
    _SC_NZERO___3 = 109,
    _SC_SSIZE_MAX___3 = 110,
    _SC_SCHAR_MAX___3 = 111,
    _SC_SCHAR_MIN___3 = 112,
    _SC_SHRT_MAX___3 = 113,
    _SC_SHRT_MIN___3 = 114,
    _SC_UCHAR_MAX___3 = 115,
    _SC_UINT_MAX___3 = 116,
    _SC_ULONG_MAX___3 = 117,
    _SC_USHRT_MAX___3 = 118,
    _SC_NL_ARGMAX___3 = 119,
    _SC_NL_LANGMAX___3 = 120,
    _SC_NL_MSGMAX___3 = 121,
    _SC_NL_NMAX___3 = 122,
    _SC_NL_SETMAX___3 = 123,
    _SC_NL_TEXTMAX___3 = 124,
    _SC_XBS5_ILP32_OFF32___3 = 125,
    _SC_XBS5_ILP32_OFFBIG___3 = 126,
    _SC_XBS5_LP64_OFF64___3 = 127,
    _SC_XBS5_LPBIG_OFFBIG___3 = 128,
    _SC_XOPEN_LEGACY___3 = 129,
    _SC_XOPEN_REALTIME___3 = 130,
    _SC_XOPEN_REALTIME_THREADS___3 = 131,
    _SC_ADVISORY_INFO___3 = 132,
    _SC_BARRIERS___3 = 133,
    _SC_BASE___3 = 134,
    _SC_C_LANG_SUPPORT___3 = 135,
    _SC_C_LANG_SUPPORT_R___3 = 136,
    _SC_CLOCK_SELECTION___3 = 137,
    _SC_CPUTIME___3 = 138,
    _SC_THREAD_CPUTIME___3 = 139,
    _SC_DEVICE_IO___3 = 140,
    _SC_DEVICE_SPECIFIC___3 = 141,
    _SC_DEVICE_SPECIFIC_R___3 = 142,
    _SC_FD_MGMT___3 = 143,
    _SC_FIFO___3 = 144,
    _SC_PIPE___3 = 145,
    _SC_FILE_ATTRIBUTES___3 = 146,
    _SC_FILE_LOCKING___3 = 147,
    _SC_FILE_SYSTEM___3 = 148,
    _SC_MONOTONIC_CLOCK___3 = 149,
    _SC_MULTI_PROCESS___3 = 150,
    _SC_SINGLE_PROCESS___3 = 151,
    _SC_NETWORKING___3 = 152,
    _SC_READER_WRITER_LOCKS___3 = 153,
    _SC_SPIN_LOCKS___3 = 154,
    _SC_REGEXP___3 = 155,
    _SC_REGEX_VERSION___3 = 156,
    _SC_SHELL___3 = 157,
    _SC_SIGNALS___3 = 158,
    _SC_SPAWN___3 = 159,
    _SC_SPORADIC_SERVER___3 = 160,
    _SC_THREAD_SPORADIC_SERVER___3 = 161,
    _SC_SYSTEM_DATABASE___3 = 162,
    _SC_SYSTEM_DATABASE_R___3 = 163,
    _SC_TIMEOUTS___3 = 164,
    _SC_TYPED_MEMORY_OBJECTS___3 = 165,
    _SC_USER_GROUPS___3 = 166,
    _SC_USER_GROUPS_R___3 = 167,
    _SC_2_PBS___3 = 168,
    _SC_2_PBS_ACCOUNTING___3 = 169,
    _SC_2_PBS_LOCATE___3 = 170,
    _SC_2_PBS_MESSAGE___3 = 171,
    _SC_2_PBS_TRACK___3 = 172,
    _SC_SYMLOOP_MAX___3 = 173,
    _SC_STREAMS___3 = 174,
    _SC_2_PBS_CHECKPOINT___3 = 175,
    _SC_V6_ILP32_OFF32___3 = 176,
    _SC_V6_ILP32_OFFBIG___3 = 177,
    _SC_V6_LP64_OFF64___3 = 178,
    _SC_V6_LPBIG_OFFBIG___3 = 179,
    _SC_HOST_NAME_MAX___3 = 180,
    _SC_TRACE___3 = 181,
    _SC_TRACE_EVENT_FILTER___3 = 182,
    _SC_TRACE_INHERIT___3 = 183,
    _SC_TRACE_LOG___3 = 184,
    _SC_LEVEL1_ICACHE_SIZE___3 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___3 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___3 = 187,
    _SC_LEVEL1_DCACHE_SIZE___3 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___3 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___3 = 190,
    _SC_LEVEL2_CACHE_SIZE___3 = 191,
    _SC_LEVEL2_CACHE_ASSOC___3 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___3 = 193,
    _SC_LEVEL3_CACHE_SIZE___3 = 194,
    _SC_LEVEL3_CACHE_ASSOC___3 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___3 = 196,
    _SC_LEVEL4_CACHE_SIZE___3 = 197,
    _SC_LEVEL4_CACHE_ASSOC___3 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___3 = 199,
    _SC_IPV6___3 = 235,
    _SC_RAW_SOCKETS___3 = 236,
    _SC_V7_ILP32_OFF32___3 = 237,
    _SC_V7_ILP32_OFFBIG___3 = 238,
    _SC_V7_LP64_OFF64___3 = 239,
    _SC_V7_LPBIG_OFFBIG___3 = 240,
    _SC_SS_REPL_MAX___3 = 241,
    _SC_TRACE_EVENT_NAME_MAX___3 = 242,
    _SC_TRACE_NAME_MAX___3 = 243,
    _SC_TRACE_SYS_MAX___3 = 244,
    _SC_TRACE_USER_EVENT_MAX___3 = 245,
    _SC_XOPEN_STREAMS___3 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___3 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___3 = 248
} ;
#line 533
enum __anonenum__256 {
    _CS_PATH___3 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___3 = 1,
    _CS_GNU_LIBC_VERSION___3 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___3 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___3 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___3 = 5,
    _CS_LFS_CFLAGS___3 = 1000,
    _CS_LFS_LDFLAGS___3 = 1001,
    _CS_LFS_LIBS___3 = 1002,
    _CS_LFS_LINTFLAGS___3 = 1003,
    _CS_LFS64_CFLAGS___3 = 1004,
    _CS_LFS64_LDFLAGS___3 = 1005,
    _CS_LFS64_LIBS___3 = 1006,
    _CS_LFS64_LINTFLAGS___3 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___3 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___3 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___3 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___3 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___3 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___3 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___3 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___3 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___3 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___3 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___3 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___3 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___3 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___3 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___3 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___3 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___3 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___3 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___3 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___3 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___3 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___3 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___3 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___3 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___3 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3 = 1147,
    _CS_V6_ENV___3 = 1148,
    _CS_V7_ENV___3 = 1149
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__258 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 950 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
struct rg_freqinfo {
   uint32_t rate ;
   double BYule[11] ;
   double AYule[11] ;
   double BButter[3] ;
   double AButter[3] ;
};
#line 1322 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
struct chan_state {
   int delay[80] ;
   int index ;
   int num_channels ;
   int ratio ;
};
#line 1324 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
typedef struct chan_state ChanState;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__95___1 {
    _PC_LINK_MAX___4 = 0,
    _PC_MAX_CANON___4 = 1,
    _PC_MAX_INPUT___4 = 2,
    _PC_NAME_MAX___4 = 3,
    _PC_PATH_MAX___4 = 4,
    _PC_PIPE_BUF___4 = 5,
    _PC_CHOWN_RESTRICTED___4 = 6,
    _PC_NO_TRUNC___4 = 7,
    _PC_VDISABLE___4 = 8,
    _PC_SYNC_IO___4 = 9,
    _PC_ASYNC_IO___4 = 10,
    _PC_PRIO_IO___4 = 11,
    _PC_SOCK_MAXBUF___4 = 12,
    _PC_FILESIZEBITS___4 = 13,
    _PC_REC_INCR_XFER_SIZE___4 = 14,
    _PC_REC_MAX_XFER_SIZE___4 = 15,
    _PC_REC_MIN_XFER_SIZE___4 = 16,
    _PC_REC_XFER_ALIGN___4 = 17,
    _PC_ALLOC_SIZE_MIN___4 = 18,
    _PC_SYMLINK_MAX___4 = 19,
    _PC_2_SYMLINKS___4 = 20
} ;
#line 71
enum __anonenum__96___1 {
    _SC_ARG_MAX___4 = 0,
    _SC_CHILD_MAX___4 = 1,
    _SC_CLK_TCK___4 = 2,
    _SC_NGROUPS_MAX___4 = 3,
    _SC_OPEN_MAX___4 = 4,
    _SC_STREAM_MAX___4 = 5,
    _SC_TZNAME_MAX___4 = 6,
    _SC_JOB_CONTROL___4 = 7,
    _SC_SAVED_IDS___4 = 8,
    _SC_REALTIME_SIGNALS___4 = 9,
    _SC_PRIORITY_SCHEDULING___4 = 10,
    _SC_TIMERS___4 = 11,
    _SC_ASYNCHRONOUS_IO___4 = 12,
    _SC_PRIORITIZED_IO___4 = 13,
    _SC_SYNCHRONIZED_IO___4 = 14,
    _SC_FSYNC___4 = 15,
    _SC_MAPPED_FILES___4 = 16,
    _SC_MEMLOCK___4 = 17,
    _SC_MEMLOCK_RANGE___4 = 18,
    _SC_MEMORY_PROTECTION___4 = 19,
    _SC_MESSAGE_PASSING___4 = 20,
    _SC_SEMAPHORES___4 = 21,
    _SC_SHARED_MEMORY_OBJECTS___4 = 22,
    _SC_AIO_LISTIO_MAX___4 = 23,
    _SC_AIO_MAX___4 = 24,
    _SC_AIO_PRIO_DELTA_MAX___4 = 25,
    _SC_DELAYTIMER_MAX___4 = 26,
    _SC_MQ_OPEN_MAX___4 = 27,
    _SC_MQ_PRIO_MAX___4 = 28,
    _SC_VERSION___4 = 29,
    _SC_PAGESIZE___4 = 30,
    _SC_RTSIG_MAX___4 = 31,
    _SC_SEM_NSEMS_MAX___4 = 32,
    _SC_SEM_VALUE_MAX___4 = 33,
    _SC_SIGQUEUE_MAX___4 = 34,
    _SC_TIMER_MAX___4 = 35,
    _SC_BC_BASE_MAX___4 = 36,
    _SC_BC_DIM_MAX___4 = 37,
    _SC_BC_SCALE_MAX___4 = 38,
    _SC_BC_STRING_MAX___4 = 39,
    _SC_COLL_WEIGHTS_MAX___4 = 40,
    _SC_EQUIV_CLASS_MAX___4 = 41,
    _SC_EXPR_NEST_MAX___4 = 42,
    _SC_LINE_MAX___4 = 43,
    _SC_RE_DUP_MAX___4 = 44,
    _SC_CHARCLASS_NAME_MAX___4 = 45,
    _SC_2_VERSION___4 = 46,
    _SC_2_C_BIND___4 = 47,
    _SC_2_C_DEV___4 = 48,
    _SC_2_FORT_DEV___4 = 49,
    _SC_2_FORT_RUN___4 = 50,
    _SC_2_SW_DEV___4 = 51,
    _SC_2_LOCALEDEF___4 = 52,
    _SC_PII___4 = 53,
    _SC_PII_XTI___4 = 54,
    _SC_PII_SOCKET___4 = 55,
    _SC_PII_INTERNET___4 = 56,
    _SC_PII_OSI___4 = 57,
    _SC_POLL___4 = 58,
    _SC_SELECT___4 = 59,
    _SC_UIO_MAXIOV___4 = 60,
    _SC_IOV_MAX___4 = 60,
    _SC_PII_INTERNET_STREAM___4 = 61,
    _SC_PII_INTERNET_DGRAM___4 = 62,
    _SC_PII_OSI_COTS___4 = 63,
    _SC_PII_OSI_CLTS___4 = 64,
    _SC_PII_OSI_M___4 = 65,
    _SC_T_IOV_MAX___4 = 66,
    _SC_THREADS___4 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___4 = 68,
    _SC_GETGR_R_SIZE_MAX___4 = 69,
    _SC_GETPW_R_SIZE_MAX___4 = 70,
    _SC_LOGIN_NAME_MAX___4 = 71,
    _SC_TTY_NAME_MAX___4 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___4 = 73,
    _SC_THREAD_KEYS_MAX___4 = 74,
    _SC_THREAD_STACK_MIN___4 = 75,
    _SC_THREAD_THREADS_MAX___4 = 76,
    _SC_THREAD_ATTR_STACKADDR___4 = 77,
    _SC_THREAD_ATTR_STACKSIZE___4 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___4 = 79,
    _SC_THREAD_PRIO_INHERIT___4 = 80,
    _SC_THREAD_PRIO_PROTECT___4 = 81,
    _SC_THREAD_PROCESS_SHARED___4 = 82,
    _SC_NPROCESSORS_CONF___4 = 83,
    _SC_NPROCESSORS_ONLN___4 = 84,
    _SC_PHYS_PAGES___4 = 85,
    _SC_AVPHYS_PAGES___4 = 86,
    _SC_ATEXIT_MAX___4 = 87,
    _SC_PASS_MAX___4 = 88,
    _SC_XOPEN_VERSION___4 = 89,
    _SC_XOPEN_XCU_VERSION___4 = 90,
    _SC_XOPEN_UNIX___4 = 91,
    _SC_XOPEN_CRYPT___4 = 92,
    _SC_XOPEN_ENH_I18N___4 = 93,
    _SC_XOPEN_SHM___4 = 94,
    _SC_2_CHAR_TERM___4 = 95,
    _SC_2_C_VERSION___4 = 96,
    _SC_2_UPE___4 = 97,
    _SC_XOPEN_XPG2___4 = 98,
    _SC_XOPEN_XPG3___4 = 99,
    _SC_XOPEN_XPG4___4 = 100,
    _SC_CHAR_BIT___4 = 101,
    _SC_CHAR_MAX___4 = 102,
    _SC_CHAR_MIN___4 = 103,
    _SC_INT_MAX___4 = 104,
    _SC_INT_MIN___4 = 105,
    _SC_LONG_BIT___4 = 106,
    _SC_WORD_BIT___4 = 107,
    _SC_MB_LEN_MAX___4 = 108,
    _SC_NZERO___4 = 109,
    _SC_SSIZE_MAX___4 = 110,
    _SC_SCHAR_MAX___4 = 111,
    _SC_SCHAR_MIN___4 = 112,
    _SC_SHRT_MAX___4 = 113,
    _SC_SHRT_MIN___4 = 114,
    _SC_UCHAR_MAX___4 = 115,
    _SC_UINT_MAX___4 = 116,
    _SC_ULONG_MAX___4 = 117,
    _SC_USHRT_MAX___4 = 118,
    _SC_NL_ARGMAX___4 = 119,
    _SC_NL_LANGMAX___4 = 120,
    _SC_NL_MSGMAX___4 = 121,
    _SC_NL_NMAX___4 = 122,
    _SC_NL_SETMAX___4 = 123,
    _SC_NL_TEXTMAX___4 = 124,
    _SC_XBS5_ILP32_OFF32___4 = 125,
    _SC_XBS5_ILP32_OFFBIG___4 = 126,
    _SC_XBS5_LP64_OFF64___4 = 127,
    _SC_XBS5_LPBIG_OFFBIG___4 = 128,
    _SC_XOPEN_LEGACY___4 = 129,
    _SC_XOPEN_REALTIME___4 = 130,
    _SC_XOPEN_REALTIME_THREADS___4 = 131,
    _SC_ADVISORY_INFO___4 = 132,
    _SC_BARRIERS___4 = 133,
    _SC_BASE___4 = 134,
    _SC_C_LANG_SUPPORT___4 = 135,
    _SC_C_LANG_SUPPORT_R___4 = 136,
    _SC_CLOCK_SELECTION___4 = 137,
    _SC_CPUTIME___4 = 138,
    _SC_THREAD_CPUTIME___4 = 139,
    _SC_DEVICE_IO___4 = 140,
    _SC_DEVICE_SPECIFIC___4 = 141,
    _SC_DEVICE_SPECIFIC_R___4 = 142,
    _SC_FD_MGMT___4 = 143,
    _SC_FIFO___4 = 144,
    _SC_PIPE___4 = 145,
    _SC_FILE_ATTRIBUTES___4 = 146,
    _SC_FILE_LOCKING___4 = 147,
    _SC_FILE_SYSTEM___4 = 148,
    _SC_MONOTONIC_CLOCK___4 = 149,
    _SC_MULTI_PROCESS___4 = 150,
    _SC_SINGLE_PROCESS___4 = 151,
    _SC_NETWORKING___4 = 152,
    _SC_READER_WRITER_LOCKS___4 = 153,
    _SC_SPIN_LOCKS___4 = 154,
    _SC_REGEXP___4 = 155,
    _SC_REGEX_VERSION___4 = 156,
    _SC_SHELL___4 = 157,
    _SC_SIGNALS___4 = 158,
    _SC_SPAWN___4 = 159,
    _SC_SPORADIC_SERVER___4 = 160,
    _SC_THREAD_SPORADIC_SERVER___4 = 161,
    _SC_SYSTEM_DATABASE___4 = 162,
    _SC_SYSTEM_DATABASE_R___4 = 163,
    _SC_TIMEOUTS___4 = 164,
    _SC_TYPED_MEMORY_OBJECTS___4 = 165,
    _SC_USER_GROUPS___4 = 166,
    _SC_USER_GROUPS_R___4 = 167,
    _SC_2_PBS___4 = 168,
    _SC_2_PBS_ACCOUNTING___4 = 169,
    _SC_2_PBS_LOCATE___4 = 170,
    _SC_2_PBS_MESSAGE___4 = 171,
    _SC_2_PBS_TRACK___4 = 172,
    _SC_SYMLOOP_MAX___4 = 173,
    _SC_STREAMS___4 = 174,
    _SC_2_PBS_CHECKPOINT___4 = 175,
    _SC_V6_ILP32_OFF32___4 = 176,
    _SC_V6_ILP32_OFFBIG___4 = 177,
    _SC_V6_LP64_OFF64___4 = 178,
    _SC_V6_LPBIG_OFFBIG___4 = 179,
    _SC_HOST_NAME_MAX___4 = 180,
    _SC_TRACE___4 = 181,
    _SC_TRACE_EVENT_FILTER___4 = 182,
    _SC_TRACE_INHERIT___4 = 183,
    _SC_TRACE_LOG___4 = 184,
    _SC_LEVEL1_ICACHE_SIZE___4 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___4 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___4 = 187,
    _SC_LEVEL1_DCACHE_SIZE___4 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___4 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___4 = 190,
    _SC_LEVEL2_CACHE_SIZE___4 = 191,
    _SC_LEVEL2_CACHE_ASSOC___4 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___4 = 193,
    _SC_LEVEL3_CACHE_SIZE___4 = 194,
    _SC_LEVEL3_CACHE_ASSOC___4 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___4 = 196,
    _SC_LEVEL4_CACHE_SIZE___4 = 197,
    _SC_LEVEL4_CACHE_ASSOC___4 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___4 = 199,
    _SC_IPV6___4 = 235,
    _SC_RAW_SOCKETS___4 = 236,
    _SC_V7_ILP32_OFF32___4 = 237,
    _SC_V7_ILP32_OFFBIG___4 = 238,
    _SC_V7_LP64_OFF64___4 = 239,
    _SC_V7_LPBIG_OFFBIG___4 = 240,
    _SC_SS_REPL_MAX___4 = 241,
    _SC_TRACE_EVENT_NAME_MAX___4 = 242,
    _SC_TRACE_NAME_MAX___4 = 243,
    _SC_TRACE_SYS_MAX___4 = 244,
    _SC_TRACE_USER_EVENT_MAX___4 = 245,
    _SC_XOPEN_STREAMS___4 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___4 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___4 = 248
} ;
#line 533
enum __anonenum__97___1 {
    _CS_PATH___4 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___4 = 1,
    _CS_GNU_LIBC_VERSION___4 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___4 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___4 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___4 = 5,
    _CS_LFS_CFLAGS___4 = 1000,
    _CS_LFS_LDFLAGS___4 = 1001,
    _CS_LFS_LIBS___4 = 1002,
    _CS_LFS_LINTFLAGS___4 = 1003,
    _CS_LFS64_CFLAGS___4 = 1004,
    _CS_LFS64_LDFLAGS___4 = 1005,
    _CS_LFS64_LIBS___4 = 1006,
    _CS_LFS64_LINTFLAGS___4 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___4 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___4 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___4 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___4 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___4 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___4 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___4 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___4 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___4 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___4 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___4 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___4 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___4 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___4 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___4 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___4 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___4 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___4 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___4 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___4 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___4 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___4 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___4 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___4 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___4 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___4 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___4 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___4 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___4 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___4 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___4 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___4 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___4 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___4 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___4 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___4 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___4 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___4 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___4 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___4 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___4 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___4 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___4 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___4 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___4 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___4 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___4 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___4 = 1147,
    _CS_V6_ENV___4 = 1148,
    _CS_V7_ENV___4 = 1149
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__136___1 {
    SI_ASYNCNL___4 = -60,
    SI_DETHREAD___4 = -7,
    SI_TKILL___4 = -6,
    SI_SIGIO___4 = -5,
    SI_ASYNCIO___4 = -4,
    SI_MESGQ___4 = -3,
    SI_TIMER___4 = -2,
    SI_QUEUE___4 = -1,
    SI_USER___4 = 0,
    SI_KERNEL___4 = 128
} ;
#line 71
enum __anonenum__137___1 {
    ILL_ILLOPC___4 = 1,
    ILL_ILLOPN___4 = 2,
    ILL_ILLADR___4 = 3,
    ILL_ILLTRP___4 = 4,
    ILL_PRVOPC___4 = 5,
    ILL_PRVREG___4 = 6,
    ILL_COPROC___4 = 7,
    ILL_BADSTK___4 = 8,
    ILL_BADIADDR___4 = 9
} ;
#line 94
enum __anonenum__138___1 {
    FPE_INTDIV___4 = 1,
    FPE_INTOVF___4 = 2,
    FPE_FLTDIV___4 = 3,
    FPE_FLTOVF___4 = 4,
    FPE_FLTUND___4 = 5,
    FPE_FLTRES___4 = 6,
    FPE_FLTINV___4 = 7,
    FPE_FLTSUB___4 = 8,
    FPE_FLTUNK___4 = 14,
    FPE_CONDTRAP___4 = 15
} ;
#line 119
enum __anonenum__139___1 {
    SEGV_MAPERR___4 = 1,
    SEGV_ACCERR___4 = 2,
    SEGV_BNDERR___4 = 3,
    SEGV_PKUERR___4 = 4,
    SEGV_ACCADI___4 = 5,
    SEGV_ADIDERR___4 = 6,
    SEGV_ADIPERR___4 = 7
} ;
#line 138
enum __anonenum__140___1 {
    BUS_ADRALN___4 = 1,
    BUS_ADRERR___4 = 2,
    BUS_OBJERR___4 = 3,
    BUS_MCEERR_AR___4 = 4,
    BUS_MCEERR_AO___4 = 5
} ;
#line 172
enum __anonenum__141___1 {
    CLD_EXITED___4 = 1,
    CLD_KILLED___4 = 2,
    CLD_DUMPED___4 = 3,
    CLD_TRAPPED___4 = 4,
    CLD_STOPPED___4 = 5,
    CLD_CONTINUED___4 = 6
} ;
#line 189
enum __anonenum__142___1 {
    POLL_IN___4 = 1,
    POLL_OUT___4 = 2,
    POLL_MSG___4 = 3,
    POLL_ERR___4 = 4,
    POLL_PRI___4 = 5,
    POLL_HUP___4 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__145___1 {
    SIGEV_SIGNAL___4 = 0,
    SIGEV_NONE___4 = 1,
    SIGEV_THREAD___4 = 2,
    SIGEV_THREAD_ID___4 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__150___1 {
    SS_ONSTACK___4 = 1,
    SS_DISABLE___4 = 2
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__192___0 {
    SI_ASYNCNL___5 = -60,
    SI_DETHREAD___5 = -7,
    SI_TKILL___5 = -6,
    SI_SIGIO___5 = -5,
    SI_ASYNCIO___5 = -4,
    SI_MESGQ___5 = -3,
    SI_TIMER___5 = -2,
    SI_QUEUE___5 = -1,
    SI_USER___5 = 0,
    SI_KERNEL___5 = 128
} ;
#line 71
enum __anonenum__193___0 {
    ILL_ILLOPC___5 = 1,
    ILL_ILLOPN___5 = 2,
    ILL_ILLADR___5 = 3,
    ILL_ILLTRP___5 = 4,
    ILL_PRVOPC___5 = 5,
    ILL_PRVREG___5 = 6,
    ILL_COPROC___5 = 7,
    ILL_BADSTK___5 = 8,
    ILL_BADIADDR___5 = 9
} ;
#line 94
enum __anonenum__194___0 {
    FPE_INTDIV___5 = 1,
    FPE_INTOVF___5 = 2,
    FPE_FLTDIV___5 = 3,
    FPE_FLTOVF___5 = 4,
    FPE_FLTUND___5 = 5,
    FPE_FLTRES___5 = 6,
    FPE_FLTINV___5 = 7,
    FPE_FLTSUB___5 = 8,
    FPE_FLTUNK___5 = 14,
    FPE_CONDTRAP___5 = 15
} ;
#line 119
enum __anonenum__195___0 {
    SEGV_MAPERR___5 = 1,
    SEGV_ACCERR___5 = 2,
    SEGV_BNDERR___5 = 3,
    SEGV_PKUERR___5 = 4,
    SEGV_ACCADI___5 = 5,
    SEGV_ADIDERR___5 = 6,
    SEGV_ADIPERR___5 = 7
} ;
#line 138
enum __anonenum__196___0 {
    BUS_ADRALN___5 = 1,
    BUS_ADRERR___5 = 2,
    BUS_OBJERR___5 = 3,
    BUS_MCEERR_AR___5 = 4,
    BUS_MCEERR_AO___5 = 5
} ;
#line 172
enum __anonenum__197___0 {
    CLD_EXITED___5 = 1,
    CLD_KILLED___5 = 2,
    CLD_DUMPED___5 = 3,
    CLD_TRAPPED___5 = 4,
    CLD_STOPPED___5 = 5,
    CLD_CONTINUED___5 = 6
} ;
#line 189
enum __anonenum__198___0 {
    POLL_IN___5 = 1,
    POLL_OUT___5 = 2,
    POLL_MSG___5 = 3,
    POLL_ERR___5 = 4,
    POLL_PRI___5 = 5,
    POLL_HUP___5 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__201___0 {
    SIGEV_SIGNAL___5 = 0,
    SIGEV_NONE___5 = 1,
    SIGEV_THREAD___5 = 2,
    SIGEV_THREAD_ID___5 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__206___0 {
    SS_ONSTACK___5 = 1,
    SS_DISABLE___5 = 2
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__211___0 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__214___0 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__222___0 {
    _PC_LINK_MAX___5 = 0,
    _PC_MAX_CANON___5 = 1,
    _PC_MAX_INPUT___5 = 2,
    _PC_NAME_MAX___5 = 3,
    _PC_PATH_MAX___5 = 4,
    _PC_PIPE_BUF___5 = 5,
    _PC_CHOWN_RESTRICTED___5 = 6,
    _PC_NO_TRUNC___5 = 7,
    _PC_VDISABLE___5 = 8,
    _PC_SYNC_IO___5 = 9,
    _PC_ASYNC_IO___5 = 10,
    _PC_PRIO_IO___5 = 11,
    _PC_SOCK_MAXBUF___5 = 12,
    _PC_FILESIZEBITS___5 = 13,
    _PC_REC_INCR_XFER_SIZE___5 = 14,
    _PC_REC_MAX_XFER_SIZE___5 = 15,
    _PC_REC_MIN_XFER_SIZE___5 = 16,
    _PC_REC_XFER_ALIGN___5 = 17,
    _PC_ALLOC_SIZE_MIN___5 = 18,
    _PC_SYMLINK_MAX___5 = 19,
    _PC_2_SYMLINKS___5 = 20
} ;
#line 71
enum __anonenum__223___0 {
    _SC_ARG_MAX___5 = 0,
    _SC_CHILD_MAX___5 = 1,
    _SC_CLK_TCK___5 = 2,
    _SC_NGROUPS_MAX___5 = 3,
    _SC_OPEN_MAX___5 = 4,
    _SC_STREAM_MAX___5 = 5,
    _SC_TZNAME_MAX___5 = 6,
    _SC_JOB_CONTROL___5 = 7,
    _SC_SAVED_IDS___5 = 8,
    _SC_REALTIME_SIGNALS___5 = 9,
    _SC_PRIORITY_SCHEDULING___5 = 10,
    _SC_TIMERS___5 = 11,
    _SC_ASYNCHRONOUS_IO___5 = 12,
    _SC_PRIORITIZED_IO___5 = 13,
    _SC_SYNCHRONIZED_IO___5 = 14,
    _SC_FSYNC___5 = 15,
    _SC_MAPPED_FILES___5 = 16,
    _SC_MEMLOCK___5 = 17,
    _SC_MEMLOCK_RANGE___5 = 18,
    _SC_MEMORY_PROTECTION___5 = 19,
    _SC_MESSAGE_PASSING___5 = 20,
    _SC_SEMAPHORES___5 = 21,
    _SC_SHARED_MEMORY_OBJECTS___5 = 22,
    _SC_AIO_LISTIO_MAX___5 = 23,
    _SC_AIO_MAX___5 = 24,
    _SC_AIO_PRIO_DELTA_MAX___5 = 25,
    _SC_DELAYTIMER_MAX___5 = 26,
    _SC_MQ_OPEN_MAX___5 = 27,
    _SC_MQ_PRIO_MAX___5 = 28,
    _SC_VERSION___5 = 29,
    _SC_PAGESIZE___5 = 30,
    _SC_RTSIG_MAX___5 = 31,
    _SC_SEM_NSEMS_MAX___5 = 32,
    _SC_SEM_VALUE_MAX___5 = 33,
    _SC_SIGQUEUE_MAX___5 = 34,
    _SC_TIMER_MAX___5 = 35,
    _SC_BC_BASE_MAX___5 = 36,
    _SC_BC_DIM_MAX___5 = 37,
    _SC_BC_SCALE_MAX___5 = 38,
    _SC_BC_STRING_MAX___5 = 39,
    _SC_COLL_WEIGHTS_MAX___5 = 40,
    _SC_EQUIV_CLASS_MAX___5 = 41,
    _SC_EXPR_NEST_MAX___5 = 42,
    _SC_LINE_MAX___5 = 43,
    _SC_RE_DUP_MAX___5 = 44,
    _SC_CHARCLASS_NAME_MAX___5 = 45,
    _SC_2_VERSION___5 = 46,
    _SC_2_C_BIND___5 = 47,
    _SC_2_C_DEV___5 = 48,
    _SC_2_FORT_DEV___5 = 49,
    _SC_2_FORT_RUN___5 = 50,
    _SC_2_SW_DEV___5 = 51,
    _SC_2_LOCALEDEF___5 = 52,
    _SC_PII___5 = 53,
    _SC_PII_XTI___5 = 54,
    _SC_PII_SOCKET___5 = 55,
    _SC_PII_INTERNET___5 = 56,
    _SC_PII_OSI___5 = 57,
    _SC_POLL___5 = 58,
    _SC_SELECT___5 = 59,
    _SC_UIO_MAXIOV___5 = 60,
    _SC_IOV_MAX___5 = 60,
    _SC_PII_INTERNET_STREAM___5 = 61,
    _SC_PII_INTERNET_DGRAM___5 = 62,
    _SC_PII_OSI_COTS___5 = 63,
    _SC_PII_OSI_CLTS___5 = 64,
    _SC_PII_OSI_M___5 = 65,
    _SC_T_IOV_MAX___5 = 66,
    _SC_THREADS___5 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___5 = 68,
    _SC_GETGR_R_SIZE_MAX___5 = 69,
    _SC_GETPW_R_SIZE_MAX___5 = 70,
    _SC_LOGIN_NAME_MAX___5 = 71,
    _SC_TTY_NAME_MAX___5 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___5 = 73,
    _SC_THREAD_KEYS_MAX___5 = 74,
    _SC_THREAD_STACK_MIN___5 = 75,
    _SC_THREAD_THREADS_MAX___5 = 76,
    _SC_THREAD_ATTR_STACKADDR___5 = 77,
    _SC_THREAD_ATTR_STACKSIZE___5 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___5 = 79,
    _SC_THREAD_PRIO_INHERIT___5 = 80,
    _SC_THREAD_PRIO_PROTECT___5 = 81,
    _SC_THREAD_PROCESS_SHARED___5 = 82,
    _SC_NPROCESSORS_CONF___5 = 83,
    _SC_NPROCESSORS_ONLN___5 = 84,
    _SC_PHYS_PAGES___5 = 85,
    _SC_AVPHYS_PAGES___5 = 86,
    _SC_ATEXIT_MAX___5 = 87,
    _SC_PASS_MAX___5 = 88,
    _SC_XOPEN_VERSION___5 = 89,
    _SC_XOPEN_XCU_VERSION___5 = 90,
    _SC_XOPEN_UNIX___5 = 91,
    _SC_XOPEN_CRYPT___5 = 92,
    _SC_XOPEN_ENH_I18N___5 = 93,
    _SC_XOPEN_SHM___5 = 94,
    _SC_2_CHAR_TERM___5 = 95,
    _SC_2_C_VERSION___5 = 96,
    _SC_2_UPE___5 = 97,
    _SC_XOPEN_XPG2___5 = 98,
    _SC_XOPEN_XPG3___5 = 99,
    _SC_XOPEN_XPG4___5 = 100,
    _SC_CHAR_BIT___5 = 101,
    _SC_CHAR_MAX___5 = 102,
    _SC_CHAR_MIN___5 = 103,
    _SC_INT_MAX___5 = 104,
    _SC_INT_MIN___5 = 105,
    _SC_LONG_BIT___5 = 106,
    _SC_WORD_BIT___5 = 107,
    _SC_MB_LEN_MAX___5 = 108,
    _SC_NZERO___5 = 109,
    _SC_SSIZE_MAX___5 = 110,
    _SC_SCHAR_MAX___5 = 111,
    _SC_SCHAR_MIN___5 = 112,
    _SC_SHRT_MAX___5 = 113,
    _SC_SHRT_MIN___5 = 114,
    _SC_UCHAR_MAX___5 = 115,
    _SC_UINT_MAX___5 = 116,
    _SC_ULONG_MAX___5 = 117,
    _SC_USHRT_MAX___5 = 118,
    _SC_NL_ARGMAX___5 = 119,
    _SC_NL_LANGMAX___5 = 120,
    _SC_NL_MSGMAX___5 = 121,
    _SC_NL_NMAX___5 = 122,
    _SC_NL_SETMAX___5 = 123,
    _SC_NL_TEXTMAX___5 = 124,
    _SC_XBS5_ILP32_OFF32___5 = 125,
    _SC_XBS5_ILP32_OFFBIG___5 = 126,
    _SC_XBS5_LP64_OFF64___5 = 127,
    _SC_XBS5_LPBIG_OFFBIG___5 = 128,
    _SC_XOPEN_LEGACY___5 = 129,
    _SC_XOPEN_REALTIME___5 = 130,
    _SC_XOPEN_REALTIME_THREADS___5 = 131,
    _SC_ADVISORY_INFO___5 = 132,
    _SC_BARRIERS___5 = 133,
    _SC_BASE___5 = 134,
    _SC_C_LANG_SUPPORT___5 = 135,
    _SC_C_LANG_SUPPORT_R___5 = 136,
    _SC_CLOCK_SELECTION___5 = 137,
    _SC_CPUTIME___5 = 138,
    _SC_THREAD_CPUTIME___5 = 139,
    _SC_DEVICE_IO___5 = 140,
    _SC_DEVICE_SPECIFIC___5 = 141,
    _SC_DEVICE_SPECIFIC_R___5 = 142,
    _SC_FD_MGMT___5 = 143,
    _SC_FIFO___5 = 144,
    _SC_PIPE___5 = 145,
    _SC_FILE_ATTRIBUTES___5 = 146,
    _SC_FILE_LOCKING___5 = 147,
    _SC_FILE_SYSTEM___5 = 148,
    _SC_MONOTONIC_CLOCK___5 = 149,
    _SC_MULTI_PROCESS___5 = 150,
    _SC_SINGLE_PROCESS___5 = 151,
    _SC_NETWORKING___5 = 152,
    _SC_READER_WRITER_LOCKS___5 = 153,
    _SC_SPIN_LOCKS___5 = 154,
    _SC_REGEXP___5 = 155,
    _SC_REGEX_VERSION___5 = 156,
    _SC_SHELL___5 = 157,
    _SC_SIGNALS___5 = 158,
    _SC_SPAWN___5 = 159,
    _SC_SPORADIC_SERVER___5 = 160,
    _SC_THREAD_SPORADIC_SERVER___5 = 161,
    _SC_SYSTEM_DATABASE___5 = 162,
    _SC_SYSTEM_DATABASE_R___5 = 163,
    _SC_TIMEOUTS___5 = 164,
    _SC_TYPED_MEMORY_OBJECTS___5 = 165,
    _SC_USER_GROUPS___5 = 166,
    _SC_USER_GROUPS_R___5 = 167,
    _SC_2_PBS___5 = 168,
    _SC_2_PBS_ACCOUNTING___5 = 169,
    _SC_2_PBS_LOCATE___5 = 170,
    _SC_2_PBS_MESSAGE___5 = 171,
    _SC_2_PBS_TRACK___5 = 172,
    _SC_SYMLOOP_MAX___5 = 173,
    _SC_STREAMS___5 = 174,
    _SC_2_PBS_CHECKPOINT___5 = 175,
    _SC_V6_ILP32_OFF32___5 = 176,
    _SC_V6_ILP32_OFFBIG___5 = 177,
    _SC_V6_LP64_OFF64___5 = 178,
    _SC_V6_LPBIG_OFFBIG___5 = 179,
    _SC_HOST_NAME_MAX___5 = 180,
    _SC_TRACE___5 = 181,
    _SC_TRACE_EVENT_FILTER___5 = 182,
    _SC_TRACE_INHERIT___5 = 183,
    _SC_TRACE_LOG___5 = 184,
    _SC_LEVEL1_ICACHE_SIZE___5 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___5 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___5 = 187,
    _SC_LEVEL1_DCACHE_SIZE___5 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___5 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___5 = 190,
    _SC_LEVEL2_CACHE_SIZE___5 = 191,
    _SC_LEVEL2_CACHE_ASSOC___5 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___5 = 193,
    _SC_LEVEL3_CACHE_SIZE___5 = 194,
    _SC_LEVEL3_CACHE_ASSOC___5 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___5 = 196,
    _SC_LEVEL4_CACHE_SIZE___5 = 197,
    _SC_LEVEL4_CACHE_ASSOC___5 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___5 = 199,
    _SC_IPV6___5 = 235,
    _SC_RAW_SOCKETS___5 = 236,
    _SC_V7_ILP32_OFF32___5 = 237,
    _SC_V7_ILP32_OFFBIG___5 = 238,
    _SC_V7_LP64_OFF64___5 = 239,
    _SC_V7_LPBIG_OFFBIG___5 = 240,
    _SC_SS_REPL_MAX___5 = 241,
    _SC_TRACE_EVENT_NAME_MAX___5 = 242,
    _SC_TRACE_NAME_MAX___5 = 243,
    _SC_TRACE_SYS_MAX___5 = 244,
    _SC_TRACE_USER_EVENT_MAX___5 = 245,
    _SC_XOPEN_STREAMS___5 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___5 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___5 = 248
} ;
#line 533
enum __anonenum__224___0 {
    _CS_PATH___5 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___5 = 1,
    _CS_GNU_LIBC_VERSION___5 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___5 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___5 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___5 = 5,
    _CS_LFS_CFLAGS___5 = 1000,
    _CS_LFS_LDFLAGS___5 = 1001,
    _CS_LFS_LIBS___5 = 1002,
    _CS_LFS_LINTFLAGS___5 = 1003,
    _CS_LFS64_CFLAGS___5 = 1004,
    _CS_LFS64_LDFLAGS___5 = 1005,
    _CS_LFS64_LIBS___5 = 1006,
    _CS_LFS64_LINTFLAGS___5 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___5 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___5 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___5 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___5 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___5 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___5 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___5 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___5 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___5 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___5 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___5 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___5 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___5 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___5 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___5 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___5 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___5 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___5 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___5 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___5 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___5 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___5 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___5 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___5 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___5 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___5 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___5 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___5 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___5 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___5 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___5 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___5 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___5 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___5 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___5 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___5 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___5 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___5 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___5 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___5 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___5 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___5 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___5 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___5 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___5 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___5 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___5 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___5 = 1147,
    _CS_V6_ENV___5 = 1148,
    _CS_V7_ENV___5 = 1149
} ;
#line 230 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
struct __anonstruct_272 {
   unsigned char id ;
   char *fourcc ;
   char *default_extension ;
   int (*ParseHeader)(FILE * , char * , char * , WavpackContext * , WavpackConfig * ) ;
   int chunk_alignment ;
};
#line 1367 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
struct __anonstruct_273 {
   uint32_t bytes_written ;
   uint32_t first_block_size ;
   FILE *file ;
   int error ;
};
#line 1371 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
typedef struct __anonstruct_273 write_id;
#line 853 "/usr/include/math.h"
enum __anonenum__80___4 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83___4 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__95___2 {
    _PC_LINK_MAX___6 = 0,
    _PC_MAX_CANON___6 = 1,
    _PC_MAX_INPUT___6 = 2,
    _PC_NAME_MAX___6 = 3,
    _PC_PATH_MAX___6 = 4,
    _PC_PIPE_BUF___6 = 5,
    _PC_CHOWN_RESTRICTED___6 = 6,
    _PC_NO_TRUNC___6 = 7,
    _PC_VDISABLE___6 = 8,
    _PC_SYNC_IO___6 = 9,
    _PC_ASYNC_IO___6 = 10,
    _PC_PRIO_IO___6 = 11,
    _PC_SOCK_MAXBUF___6 = 12,
    _PC_FILESIZEBITS___6 = 13,
    _PC_REC_INCR_XFER_SIZE___6 = 14,
    _PC_REC_MAX_XFER_SIZE___6 = 15,
    _PC_REC_MIN_XFER_SIZE___6 = 16,
    _PC_REC_XFER_ALIGN___6 = 17,
    _PC_ALLOC_SIZE_MIN___6 = 18,
    _PC_SYMLINK_MAX___6 = 19,
    _PC_2_SYMLINKS___6 = 20
} ;
#line 71
enum __anonenum__96___2 {
    _SC_ARG_MAX___6 = 0,
    _SC_CHILD_MAX___6 = 1,
    _SC_CLK_TCK___6 = 2,
    _SC_NGROUPS_MAX___6 = 3,
    _SC_OPEN_MAX___6 = 4,
    _SC_STREAM_MAX___6 = 5,
    _SC_TZNAME_MAX___6 = 6,
    _SC_JOB_CONTROL___6 = 7,
    _SC_SAVED_IDS___6 = 8,
    _SC_REALTIME_SIGNALS___6 = 9,
    _SC_PRIORITY_SCHEDULING___6 = 10,
    _SC_TIMERS___6 = 11,
    _SC_ASYNCHRONOUS_IO___6 = 12,
    _SC_PRIORITIZED_IO___6 = 13,
    _SC_SYNCHRONIZED_IO___6 = 14,
    _SC_FSYNC___6 = 15,
    _SC_MAPPED_FILES___6 = 16,
    _SC_MEMLOCK___6 = 17,
    _SC_MEMLOCK_RANGE___6 = 18,
    _SC_MEMORY_PROTECTION___6 = 19,
    _SC_MESSAGE_PASSING___6 = 20,
    _SC_SEMAPHORES___6 = 21,
    _SC_SHARED_MEMORY_OBJECTS___6 = 22,
    _SC_AIO_LISTIO_MAX___6 = 23,
    _SC_AIO_MAX___6 = 24,
    _SC_AIO_PRIO_DELTA_MAX___6 = 25,
    _SC_DELAYTIMER_MAX___6 = 26,
    _SC_MQ_OPEN_MAX___6 = 27,
    _SC_MQ_PRIO_MAX___6 = 28,
    _SC_VERSION___6 = 29,
    _SC_PAGESIZE___6 = 30,
    _SC_RTSIG_MAX___6 = 31,
    _SC_SEM_NSEMS_MAX___6 = 32,
    _SC_SEM_VALUE_MAX___6 = 33,
    _SC_SIGQUEUE_MAX___6 = 34,
    _SC_TIMER_MAX___6 = 35,
    _SC_BC_BASE_MAX___6 = 36,
    _SC_BC_DIM_MAX___6 = 37,
    _SC_BC_SCALE_MAX___6 = 38,
    _SC_BC_STRING_MAX___6 = 39,
    _SC_COLL_WEIGHTS_MAX___6 = 40,
    _SC_EQUIV_CLASS_MAX___6 = 41,
    _SC_EXPR_NEST_MAX___6 = 42,
    _SC_LINE_MAX___6 = 43,
    _SC_RE_DUP_MAX___6 = 44,
    _SC_CHARCLASS_NAME_MAX___6 = 45,
    _SC_2_VERSION___6 = 46,
    _SC_2_C_BIND___6 = 47,
    _SC_2_C_DEV___6 = 48,
    _SC_2_FORT_DEV___6 = 49,
    _SC_2_FORT_RUN___6 = 50,
    _SC_2_SW_DEV___6 = 51,
    _SC_2_LOCALEDEF___6 = 52,
    _SC_PII___6 = 53,
    _SC_PII_XTI___6 = 54,
    _SC_PII_SOCKET___6 = 55,
    _SC_PII_INTERNET___6 = 56,
    _SC_PII_OSI___6 = 57,
    _SC_POLL___6 = 58,
    _SC_SELECT___6 = 59,
    _SC_UIO_MAXIOV___6 = 60,
    _SC_IOV_MAX___6 = 60,
    _SC_PII_INTERNET_STREAM___6 = 61,
    _SC_PII_INTERNET_DGRAM___6 = 62,
    _SC_PII_OSI_COTS___6 = 63,
    _SC_PII_OSI_CLTS___6 = 64,
    _SC_PII_OSI_M___6 = 65,
    _SC_T_IOV_MAX___6 = 66,
    _SC_THREADS___6 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___6 = 68,
    _SC_GETGR_R_SIZE_MAX___6 = 69,
    _SC_GETPW_R_SIZE_MAX___6 = 70,
    _SC_LOGIN_NAME_MAX___6 = 71,
    _SC_TTY_NAME_MAX___6 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___6 = 73,
    _SC_THREAD_KEYS_MAX___6 = 74,
    _SC_THREAD_STACK_MIN___6 = 75,
    _SC_THREAD_THREADS_MAX___6 = 76,
    _SC_THREAD_ATTR_STACKADDR___6 = 77,
    _SC_THREAD_ATTR_STACKSIZE___6 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___6 = 79,
    _SC_THREAD_PRIO_INHERIT___6 = 80,
    _SC_THREAD_PRIO_PROTECT___6 = 81,
    _SC_THREAD_PROCESS_SHARED___6 = 82,
    _SC_NPROCESSORS_CONF___6 = 83,
    _SC_NPROCESSORS_ONLN___6 = 84,
    _SC_PHYS_PAGES___6 = 85,
    _SC_AVPHYS_PAGES___6 = 86,
    _SC_ATEXIT_MAX___6 = 87,
    _SC_PASS_MAX___6 = 88,
    _SC_XOPEN_VERSION___6 = 89,
    _SC_XOPEN_XCU_VERSION___6 = 90,
    _SC_XOPEN_UNIX___6 = 91,
    _SC_XOPEN_CRYPT___6 = 92,
    _SC_XOPEN_ENH_I18N___6 = 93,
    _SC_XOPEN_SHM___6 = 94,
    _SC_2_CHAR_TERM___6 = 95,
    _SC_2_C_VERSION___6 = 96,
    _SC_2_UPE___6 = 97,
    _SC_XOPEN_XPG2___6 = 98,
    _SC_XOPEN_XPG3___6 = 99,
    _SC_XOPEN_XPG4___6 = 100,
    _SC_CHAR_BIT___6 = 101,
    _SC_CHAR_MAX___6 = 102,
    _SC_CHAR_MIN___6 = 103,
    _SC_INT_MAX___6 = 104,
    _SC_INT_MIN___6 = 105,
    _SC_LONG_BIT___6 = 106,
    _SC_WORD_BIT___6 = 107,
    _SC_MB_LEN_MAX___6 = 108,
    _SC_NZERO___6 = 109,
    _SC_SSIZE_MAX___6 = 110,
    _SC_SCHAR_MAX___6 = 111,
    _SC_SCHAR_MIN___6 = 112,
    _SC_SHRT_MAX___6 = 113,
    _SC_SHRT_MIN___6 = 114,
    _SC_UCHAR_MAX___6 = 115,
    _SC_UINT_MAX___6 = 116,
    _SC_ULONG_MAX___6 = 117,
    _SC_USHRT_MAX___6 = 118,
    _SC_NL_ARGMAX___6 = 119,
    _SC_NL_LANGMAX___6 = 120,
    _SC_NL_MSGMAX___6 = 121,
    _SC_NL_NMAX___6 = 122,
    _SC_NL_SETMAX___6 = 123,
    _SC_NL_TEXTMAX___6 = 124,
    _SC_XBS5_ILP32_OFF32___6 = 125,
    _SC_XBS5_ILP32_OFFBIG___6 = 126,
    _SC_XBS5_LP64_OFF64___6 = 127,
    _SC_XBS5_LPBIG_OFFBIG___6 = 128,
    _SC_XOPEN_LEGACY___6 = 129,
    _SC_XOPEN_REALTIME___6 = 130,
    _SC_XOPEN_REALTIME_THREADS___6 = 131,
    _SC_ADVISORY_INFO___6 = 132,
    _SC_BARRIERS___6 = 133,
    _SC_BASE___6 = 134,
    _SC_C_LANG_SUPPORT___6 = 135,
    _SC_C_LANG_SUPPORT_R___6 = 136,
    _SC_CLOCK_SELECTION___6 = 137,
    _SC_CPUTIME___6 = 138,
    _SC_THREAD_CPUTIME___6 = 139,
    _SC_DEVICE_IO___6 = 140,
    _SC_DEVICE_SPECIFIC___6 = 141,
    _SC_DEVICE_SPECIFIC_R___6 = 142,
    _SC_FD_MGMT___6 = 143,
    _SC_FIFO___6 = 144,
    _SC_PIPE___6 = 145,
    _SC_FILE_ATTRIBUTES___6 = 146,
    _SC_FILE_LOCKING___6 = 147,
    _SC_FILE_SYSTEM___6 = 148,
    _SC_MONOTONIC_CLOCK___6 = 149,
    _SC_MULTI_PROCESS___6 = 150,
    _SC_SINGLE_PROCESS___6 = 151,
    _SC_NETWORKING___6 = 152,
    _SC_READER_WRITER_LOCKS___6 = 153,
    _SC_SPIN_LOCKS___6 = 154,
    _SC_REGEXP___6 = 155,
    _SC_REGEX_VERSION___6 = 156,
    _SC_SHELL___6 = 157,
    _SC_SIGNALS___6 = 158,
    _SC_SPAWN___6 = 159,
    _SC_SPORADIC_SERVER___6 = 160,
    _SC_THREAD_SPORADIC_SERVER___6 = 161,
    _SC_SYSTEM_DATABASE___6 = 162,
    _SC_SYSTEM_DATABASE_R___6 = 163,
    _SC_TIMEOUTS___6 = 164,
    _SC_TYPED_MEMORY_OBJECTS___6 = 165,
    _SC_USER_GROUPS___6 = 166,
    _SC_USER_GROUPS_R___6 = 167,
    _SC_2_PBS___6 = 168,
    _SC_2_PBS_ACCOUNTING___6 = 169,
    _SC_2_PBS_LOCATE___6 = 170,
    _SC_2_PBS_MESSAGE___6 = 171,
    _SC_2_PBS_TRACK___6 = 172,
    _SC_SYMLOOP_MAX___6 = 173,
    _SC_STREAMS___6 = 174,
    _SC_2_PBS_CHECKPOINT___6 = 175,
    _SC_V6_ILP32_OFF32___6 = 176,
    _SC_V6_ILP32_OFFBIG___6 = 177,
    _SC_V6_LP64_OFF64___6 = 178,
    _SC_V6_LPBIG_OFFBIG___6 = 179,
    _SC_HOST_NAME_MAX___6 = 180,
    _SC_TRACE___6 = 181,
    _SC_TRACE_EVENT_FILTER___6 = 182,
    _SC_TRACE_INHERIT___6 = 183,
    _SC_TRACE_LOG___6 = 184,
    _SC_LEVEL1_ICACHE_SIZE___6 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___6 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___6 = 187,
    _SC_LEVEL1_DCACHE_SIZE___6 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___6 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___6 = 190,
    _SC_LEVEL2_CACHE_SIZE___6 = 191,
    _SC_LEVEL2_CACHE_ASSOC___6 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___6 = 193,
    _SC_LEVEL3_CACHE_SIZE___6 = 194,
    _SC_LEVEL3_CACHE_ASSOC___6 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___6 = 196,
    _SC_LEVEL4_CACHE_SIZE___6 = 197,
    _SC_LEVEL4_CACHE_ASSOC___6 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___6 = 199,
    _SC_IPV6___6 = 235,
    _SC_RAW_SOCKETS___6 = 236,
    _SC_V7_ILP32_OFF32___6 = 237,
    _SC_V7_ILP32_OFFBIG___6 = 238,
    _SC_V7_LP64_OFF64___6 = 239,
    _SC_V7_LPBIG_OFFBIG___6 = 240,
    _SC_SS_REPL_MAX___6 = 241,
    _SC_TRACE_EVENT_NAME_MAX___6 = 242,
    _SC_TRACE_NAME_MAX___6 = 243,
    _SC_TRACE_SYS_MAX___6 = 244,
    _SC_TRACE_USER_EVENT_MAX___6 = 245,
    _SC_XOPEN_STREAMS___6 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___6 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___6 = 248
} ;
#line 533
enum __anonenum__97___2 {
    _CS_PATH___6 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___6 = 1,
    _CS_GNU_LIBC_VERSION___6 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___6 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___6 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___6 = 5,
    _CS_LFS_CFLAGS___6 = 1000,
    _CS_LFS_LDFLAGS___6 = 1001,
    _CS_LFS_LIBS___6 = 1002,
    _CS_LFS_LINTFLAGS___6 = 1003,
    _CS_LFS64_CFLAGS___6 = 1004,
    _CS_LFS64_LDFLAGS___6 = 1005,
    _CS_LFS64_LIBS___6 = 1006,
    _CS_LFS64_LINTFLAGS___6 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___6 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___6 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___6 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___6 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___6 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___6 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___6 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___6 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___6 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___6 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___6 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___6 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___6 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___6 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___6 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___6 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___6 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___6 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___6 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___6 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___6 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___6 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___6 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___6 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___6 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___6 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___6 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___6 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___6 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___6 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___6 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___6 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___6 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___6 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___6 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___6 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___6 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___6 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___6 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___6 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___6 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___6 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___6 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___6 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___6 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___6 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___6 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___6 = 1147,
    _CS_V6_ENV___6 = 1148,
    _CS_V7_ENV___6 = 1149
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__136___2 {
    SI_ASYNCNL___6 = -60,
    SI_DETHREAD___6 = -7,
    SI_TKILL___6 = -6,
    SI_SIGIO___6 = -5,
    SI_ASYNCIO___6 = -4,
    SI_MESGQ___6 = -3,
    SI_TIMER___6 = -2,
    SI_QUEUE___6 = -1,
    SI_USER___6 = 0,
    SI_KERNEL___6 = 128
} ;
#line 71
enum __anonenum__137___2 {
    ILL_ILLOPC___6 = 1,
    ILL_ILLOPN___6 = 2,
    ILL_ILLADR___6 = 3,
    ILL_ILLTRP___6 = 4,
    ILL_PRVOPC___6 = 5,
    ILL_PRVREG___6 = 6,
    ILL_COPROC___6 = 7,
    ILL_BADSTK___6 = 8,
    ILL_BADIADDR___6 = 9
} ;
#line 94
enum __anonenum__138___2 {
    FPE_INTDIV___6 = 1,
    FPE_INTOVF___6 = 2,
    FPE_FLTDIV___6 = 3,
    FPE_FLTOVF___6 = 4,
    FPE_FLTUND___6 = 5,
    FPE_FLTRES___6 = 6,
    FPE_FLTINV___6 = 7,
    FPE_FLTSUB___6 = 8,
    FPE_FLTUNK___6 = 14,
    FPE_CONDTRAP___6 = 15
} ;
#line 119
enum __anonenum__139___2 {
    SEGV_MAPERR___6 = 1,
    SEGV_ACCERR___6 = 2,
    SEGV_BNDERR___6 = 3,
    SEGV_PKUERR___6 = 4,
    SEGV_ACCADI___6 = 5,
    SEGV_ADIDERR___6 = 6,
    SEGV_ADIPERR___6 = 7
} ;
#line 138
enum __anonenum__140___2 {
    BUS_ADRALN___6 = 1,
    BUS_ADRERR___6 = 2,
    BUS_OBJERR___6 = 3,
    BUS_MCEERR_AR___6 = 4,
    BUS_MCEERR_AO___6 = 5
} ;
#line 172
enum __anonenum__141___2 {
    CLD_EXITED___6 = 1,
    CLD_KILLED___6 = 2,
    CLD_DUMPED___6 = 3,
    CLD_TRAPPED___6 = 4,
    CLD_STOPPED___6 = 5,
    CLD_CONTINUED___6 = 6
} ;
#line 189
enum __anonenum__142___2 {
    POLL_IN___6 = 1,
    POLL_OUT___6 = 2,
    POLL_MSG___6 = 3,
    POLL_ERR___6 = 4,
    POLL_PRI___6 = 5,
    POLL_HUP___6 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__145___2 {
    SIGEV_SIGNAL___6 = 0,
    SIGEV_NONE___6 = 1,
    SIGEV_THREAD___6 = 2,
    SIGEV_THREAD_ID___6 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__150___2 {
    SS_ONSTACK___6 = 1,
    SS_DISABLE___6 = 2
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__80___5 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83___5 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
#line 22 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
struct __anonstruct_253___0 {
   char *id3_item ;
   char *ape_item ;
};
#line 853 "/usr/include/math.h"
enum __anonenum__80___6 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83___6 {
    _ISupper___9 = 256,
    _ISlower___9 = 512,
    _ISalpha___9 = 1024,
    _ISdigit___9 = 2048,
    _ISxdigit___9 = 4096,
    _ISspace___9 = 8192,
    _ISprint___9 = 16384,
    _ISgraph___9 = 32768,
    _ISblank___9 = 1,
    _IScntrl___9 = 2,
    _ISpunct___9 = 4,
    _ISalnum___9 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__80___7 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83___7 {
    _ISupper___10 = 256,
    _ISlower___10 = 512,
    _ISalpha___10 = 1024,
    _ISdigit___10 = 2048,
    _ISxdigit___10 = 4096,
    _ISspace___10 = 8192,
    _ISprint___10 = 16384,
    _ISgraph___10 = 32768,
    _ISblank___10 = 1,
    _IScntrl___10 = 2,
    _ISpunct___10 = 4,
    _ISalnum___10 = 8
} ;
#line 853 "/usr/include/math.h"
enum __anonenum__80___8 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__83___8 {
    _ISupper___11 = 256,
    _ISlower___11 = 512,
    _ISalpha___11 = 1024,
    _ISdigit___11 = 2048,
    _ISxdigit___11 = 4096,
    _ISspace___11 = 8192,
    _ISprint___11 = 16384,
    _ISgraph___11 = 32768,
    _ISblank___11 = 1,
    _IScntrl___11 = 2,
    _ISpunct___11 = 4,
    _ISalnum___11 = 8
} ;
#line 78 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
enum __anonenum__164___0 {
    kCAFChannelLayoutTag_UseChannelDescriptions___0 = 0,
    kCAFChannelLayoutTag_UseChannelBitmap___0 = 65536
} ;
#line 95 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
struct __anonstruct_166___0 {
   uint32_t mChannelLayoutTag ;
   uint32_t mChannelBitmap ;
   char const   *mChannelReorder ;
   char const   *mChannelIdentities ;
};
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 287
extern  __attribute__((__nothrow__)) int lchmod(char const   *__file , __mode_t __mode ) ;
#line 293
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 299
extern  __attribute__((__nothrow__)) int fchmodat(int __fd , char const   *__file ,
                                                  __mode_t __mode , int __flag ) ;
#line 308
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 317
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 324
extern  __attribute__((__nothrow__)) int mkdirat(int __fd , char const   *__path ,
                                                 __mode_t __mode ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 346
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 353
extern  __attribute__((__nothrow__)) int mkfifoat(int __fd , char const   *__path ,
                                                  __mode_t __mode ) ;
#line 360
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec __times[2] , int __flags ) ;
#line 368
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec __times[2] ) ;
#line 395
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 453
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 453 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int stat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 455
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 455
  return (__cil_tmp3);
}
}
#line 460
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 460 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int lstat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 462
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 462
  return (__cil_tmp3);
}
}
#line 467
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 467 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 469
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 469
  return (__cil_tmp3);
}
}
#line 474
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 474 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstatat(int __fd , char const   *__filename , struct stat *__statbuf ,
                            int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 477
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 477
  return (__cil_tmp5);
}
}
#line 483
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 483 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 485
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 485
  return (__cil_tmp4);
}
}
#line 491
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 491 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 494
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 494
  return (__cil_tmp5);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 113
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 77 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t __sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 88
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , __sighandler_t __handler ) ;
#line 112
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 119
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 123
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 127
extern  __attribute__((__nothrow__)) __sighandler_t ssignal(int __sig , __sighandler_t __handler ) ;
#line 129
extern  __attribute__((__nothrow__)) int gsignal(int __sig ) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t *__pinfo , char const   *__s ) ;
#line 170
extern  __attribute__((__nothrow__)) int sigblock(int __mask ) ;
#line 173
extern  __attribute__((__nothrow__)) int sigsetmask(int __mask ) ;
#line 176
extern  __attribute__((__nothrow__)) int siggetmask(void) ;
#line 196
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 199
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo ) ;
#line 205
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo ) ;
#line 208
extern  __attribute__((__nothrow__)) int sigismember(sigset_t *__set , int __signo ) ;
#line 229
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t *__set ,
                                                     sigset_t *__oset ) ;
#line 237
extern int sigsuspend(sigset_t *__set ) ;
#line 240
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 244
extern  __attribute__((__nothrow__)) int sigpending(sigset_t *__set ) ;
#line 252
extern int sigwait(sigset_t *__set , int *__sig ) ;
#line 261
extern int sigwaitinfo(sigset_t *__set , siginfo_t *__info ) ;
#line 269
extern int sigtimedwait(sigset_t *__set , siginfo_t *__info , struct timespec *__timeout ) ;
#line 276
extern  __attribute__((__nothrow__)) int sigqueue(__pid_t __pid , int __sig , union sigval __val ) ;
#line 286
extern char const   * const  _sys_siglist[65] ;
#line 287
extern char const   * const  sys_siglist[65] ;
#line 294
extern  __attribute__((__nothrow__)) int sigreturn(struct sigcontext *__scp ) ;
#line 314
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
#line 321
extern  __attribute__((__nothrow__)) int sigaltstack(stack_t *__ss , stack_t *__oss ) ;
#line 335
extern  __attribute__((__nothrow__)) int sigstack(struct sigstack *__ss , struct sigstack *__oss ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t *__newmask ,
                                                         __sigset_t *__oldmask ) ;
#line 36
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
#line 366 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
#line 368
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 125
extern  __attribute__((__nothrow__)) struct lconv *localeconv(void) ;
#line 141
extern  __attribute__((__nothrow__)) locale_t newlocale(int __category_mask , char const   *__locale ,
                                                        locale_t __base ) ;
#line 176
extern  __attribute__((__nothrow__)) locale_t duplocale(locale_t __dataset ) ;
#line 180
extern  __attribute__((__nothrow__)) void freelocale(locale_t __dataset ) ;
#line 187
extern  __attribute__((__nothrow__)) locale_t uselocale(locale_t __dataset ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char **__inbuf , size_t *__inbytesleft , char **__outbuf ,
                    size_t *__outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 304
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag ) ;
#line 334
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 376
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 384
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 417
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 452
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 469
extern int pause(void) ;
#line 473
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 478
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 483
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 491
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag ) ;
#line 497
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 501
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 531
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 543
extern char **__environ ;
#line 551
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 557
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 563
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  __argv[] ) ;
#line 568
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...) ;
#line 573
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 578
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 584
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...) ;
#line 598
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 603
extern void _exit(int __status ) ;
#line 612
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 616
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 619
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 637
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 639
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 646
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 660
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 671
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 689
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 700
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 705
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 710
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 722
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 727
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 764
extern  __attribute__((__nothrow__)) int vfork(void) ;
#line 770
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 774
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 779
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 784
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 789
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to ) ;
#line 795
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags ) ;
#line 802
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 815
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to ) ;
#line 819
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 825
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 829
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag ) ;
#line 834
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 838
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 841
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 848
extern char *getlogin(void) ;
#line 856
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 861
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 877 "/usr/include/unistd.h"
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 884
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len ) ;
#line 889
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 895
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 897
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len ) ;
#line 904
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 907
extern  __attribute__((__nothrow__)) int revoke(char const   *__file ) ;
#line 915
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale ) ;
#line 923
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 927
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 928
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 929
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 935
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 942
extern  __attribute__((__nothrow__)) int chroot(char const   *__path ) ;
#line 946
extern char *getpass(char const   *__prompt ) ;
#line 954
extern int fsync(int __fd ) ;
#line 967
extern long gethostid(void) ;
#line 970
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 976
extern  __attribute__((__nothrow__)) int getpagesize(void) ;
#line 981
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 991
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length ) ;
#line 1014
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 1035
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 1041
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1056
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1079
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1115
extern int fdatasync(int __fildes ) ;
#line 1124
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 1161
int getentropy(void *__buffer , size_t __length ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 25
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 27
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 34
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__buf, 0);
  }
#line 36
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 38
    __cil_tmp5 = __builtin_constant_p(__nbytes);
    }
#line 38
    if (! __cil_tmp5) {
      {
#line 39
      __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 39
      __cil_tmp7 = __read_chk(__fd, __buf, __nbytes, __cil_tmp6);
      }
#line 39
      return (__cil_tmp7);
    }
    {
#line 41
    __cil_tmp8 = __builtin_object_size(__buf, 0);
    }
#line 41
    if (__nbytes > __cil_tmp8) {
      {
#line 42
      __cil_tmp9 = __builtin_object_size(__buf, 0);
#line 42
      __cil_tmp10 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp9);
      }
#line 42
      return (__cil_tmp10);
    }
  }
  {
#line 44
  __cil_tmp11 = __read_alias(__fd, __buf, __nbytes);
  }
#line 44
  return (__cil_tmp11);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 139
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlink(char const   *__path , char *__buf , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 142
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 142
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 144
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 144
    if (! __cil_tmp5) {
      {
#line 145
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 145
      __cil_tmp7 = __readlink_chk(__path, __buf, __len, __cil_tmp6);
      }
#line 145
      return (__cil_tmp7);
    }
    {
#line 147
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 147
    if (__len > __cil_tmp8) {
      {
#line 148
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 148
      __cil_tmp10 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp9);
      }
#line 148
      return (__cil_tmp10);
    }
  }
  {
#line 150
  __cil_tmp11 = __readlink_alias(__path, __buf, __len);
  }
#line 150
  return (__cil_tmp11);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 173
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 173 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlinkat(int __fd , char const   *__path , char *__buf ,
                                   size_t __len ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 176
  __cil_tmp5 = __builtin_object_size(__buf, 1);
  }
#line 176
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 178
    __cil_tmp6 = __builtin_constant_p(__len);
    }
#line 178
    if (! __cil_tmp6) {
      {
#line 179
      __cil_tmp7 = __builtin_object_size(__buf, 1);
#line 179
      __cil_tmp8 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp7);
      }
#line 179
      return (__cil_tmp8);
    }
    {
#line 181
    __cil_tmp9 = __builtin_object_size(__buf, 1);
    }
#line 181
    if (__len > __cil_tmp9) {
      {
#line 182
      __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 182
      __cil_tmp11 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp10);
      }
#line 182
      return (__cil_tmp11);
    }
  }
  {
#line 185
  __cil_tmp12 = __readlinkat_alias(__fd, __path, __buf, __len);
  }
#line 185
  return (__cil_tmp12);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 193
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getcwd(char *__buf , size_t __size ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_object_size(__buf, 1);
  }
#line 202
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 204
    __cil_tmp4 = __builtin_constant_p(__size);
    }
#line 204
    if (! __cil_tmp4) {
      {
#line 205
      __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 205
      __cil_tmp6 = __getcwd_chk(__buf, __size, __cil_tmp5);
      }
#line 205
      return (__cil_tmp6);
    }
    {
#line 207
    __cil_tmp7 = __builtin_object_size(__buf, 1);
    }
#line 207
    if (__size > __cil_tmp7) {
      {
#line 208
      __cil_tmp8 = __builtin_object_size(__buf, 1);
#line 208
      __cil_tmp9 = __getcwd_chk_warn(__buf, __size, __cil_tmp8);
      }
#line 208
      return (__cil_tmp9);
    }
  }
  {
#line 210
  __cil_tmp10 = __getcwd_alias(__buf, __size);
  }
#line 210
  return (__cil_tmp10);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 221 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getwd(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 223
  __cil_tmp2 = __builtin_object_size(__buf, 1);
  }
#line 223
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 224
    __cil_tmp3 = __builtin_object_size(__buf, 1);
#line 224
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 224
    return (__cil_tmp4);
  }
  {
#line 225
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 225
  return (__cil_tmp5);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t confstr(int __name , char *__buf , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 242
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 242
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 244
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 244
    if (! __cil_tmp5) {
      {
#line 245
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 245
      __cil_tmp7 = __confstr_chk(__name, __buf, __len, __cil_tmp6);
      }
#line 245
      return (__cil_tmp7);
    }
    {
#line 247
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 247
    if (__cil_tmp8 < __len) {
      {
#line 248
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 248
      __cil_tmp10 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp9);
      }
#line 248
      return (__cil_tmp10);
    }
  }
  {
#line 250
  __cil_tmp11 = __confstr_alias(__name, __buf, __len);
  }
#line 250
  return (__cil_tmp11);
}
}
#line 254
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t __list[] ,
                                                         size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t __list[] ) ;
#line 258
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t __list[] ,
                                                              size_t __listlen ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getgroups(int __size , __gid_t __list[] ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_object_size(__list, 1);
  }
#line 267
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 269
    __cil_tmp4 = __builtin_constant_p(__size);
    }
#line 269
    if (! __cil_tmp4) {
      {
      {
#line 270
      __cil_tmp5 = __builtin_object_size(__list, 1);
      }
      {
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
      }
#line 270
      return (__cil_tmp6);
    } else
#line 269
    if (__size < 0) {
      {
      {
#line 270
      __cil_tmp5 = __builtin_object_size(__list, 1);
      }
      {
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
      }
#line 270
      return (__cil_tmp6);
    }
    {
#line 272
    __cil_tmp7 = __builtin_object_size(__list, 1);
    }
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > __cil_tmp7) {
      {
#line 273
      __cil_tmp8 = __builtin_object_size(__list, 1);
#line 273
      __cil_tmp9 = __getgroups_chk_warn(__size, __list, __cil_tmp8);
      }
#line 273
      return (__cil_tmp9);
    }
  }
  {
#line 275
  __cil_tmp10 = __getgroups_alias(__size, __list);
  }
#line 275
  return (__cil_tmp10);
}
}
#line 279
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 284
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 291 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 293
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 293
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 295
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 295
    if (! __cil_tmp5) {
      {
#line 296
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 296
      __cil_tmp7 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 296
      return (__cil_tmp7);
    }
    {
#line 298
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 298
    if (__buflen > __cil_tmp8) {
      {
#line 299
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 299
      __cil_tmp10 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 299
      return (__cil_tmp10);
    }
  }
  {
#line 301
  __cil_tmp11 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
#line 301
  return (__cil_tmp11);
}
}
#line 306
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 308
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 310
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 317
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 317 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getlogin_r(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 319
  __cil_tmp3 = __builtin_object_size(__buf, 1);
  }
#line 319
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 321
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 321
    if (! __cil_tmp4) {
      {
#line 322
      __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 322
      __cil_tmp6 = __getlogin_r_chk(__buf, __buflen, __cil_tmp5);
      }
#line 322
      return (__cil_tmp6);
    }
    {
#line 324
    __cil_tmp7 = __builtin_object_size(__buf, 1);
    }
#line 324
    if (__buflen > __cil_tmp7) {
      {
#line 325
      __cil_tmp8 = __builtin_object_size(__buf, 1);
#line 325
      __cil_tmp9 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 325
      return (__cil_tmp9);
    }
  }
  {
#line 327
  __cil_tmp10 = __getlogin_r_alias(__buf, __buflen);
  }
#line 327
  return (__cil_tmp10);
}
}
#line 333
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 337
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 344 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int gethostname(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_object_size(__buf, 1);
  }
#line 346
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 348
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 348
    if (! __cil_tmp4) {
      {
#line 349
      __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 349
      __cil_tmp6 = __gethostname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 349
      return (__cil_tmp6);
    }
    {
#line 351
    __cil_tmp7 = __builtin_object_size(__buf, 1);
    }
#line 351
    if (__buflen > __cil_tmp7) {
      {
#line 352
      __cil_tmp8 = __builtin_object_size(__buf, 1);
#line 352
      __cil_tmp9 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 352
      return (__cil_tmp9);
    }
  }
  {
#line 354
  __cil_tmp10 = __gethostname_alias(__buf, __buflen);
  }
#line 354
  return (__cil_tmp10);
}
}
#line 360
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 365
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getdomainname(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  __cil_tmp3 = __builtin_object_size(__buf, 1);
  }
#line 375
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 377
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 377
    if (! __cil_tmp4) {
      {
#line 378
      __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 378
      __cil_tmp6 = __getdomainname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 378
      return (__cil_tmp6);
    }
    {
#line 380
    __cil_tmp7 = __builtin_object_size(__buf, 1);
    }
#line 380
    if (__buflen > __cil_tmp7) {
      {
#line 381
      __cil_tmp8 = __builtin_object_size(__buf, 1);
#line 381
      __cil_tmp9 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 381
      return (__cil_tmp9);
    }
  }
  {
#line 383
  __cil_tmp10 = __getdomainname_alias(__buf, __buflen);
  }
#line 383
  return (__cil_tmp10);
}
}
#line 146 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int glob(char const   *__pattern , int __flags ,
                                              int (*__errfunc)(char const   * , int  ) ,
                                              glob_t *__pglob ) ;
#line 151
extern  __attribute__((__nothrow__)) void globfree(glob_t *__pglob ) ;
#line 66 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 75
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 83
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 123
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 129
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 136
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 141
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 145
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 217
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 218
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 219
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 228
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 229
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 230
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 235
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 249
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 185
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 185
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 189
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 189
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 196
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 196
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 201
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 217
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 217
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 218
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 219
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 228
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 229
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 230
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 235
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 249
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 256
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 259
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 272
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 276
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 290
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 294
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 298
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 307
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 326
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 332
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 335
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 335
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 400
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 400
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 182
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 185
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 185
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 189
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 189
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 196
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 196
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 201
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 201
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 211
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 217
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 217
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 218
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 219
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 228
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 229
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 230
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 235
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 249
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 249
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 256
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 256
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 261
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 276
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 276
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 280
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 290
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 290
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 294
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 294
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 298
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 307
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 307
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 314
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 314
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 316
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 320
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 322
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 326
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 332
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 335
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 335
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 400
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 25
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 30
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 36
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 42
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 773 "/usr/include/math.h"
extern int signgam ;
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 91
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 130
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 137
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 140
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 147
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 156
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 160
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 167
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 175
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 226
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 253
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 277
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 303
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 330
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 336
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 341
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 346
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 385
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 391
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 397
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 410
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 428
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 31
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 436 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 440
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 447
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 450
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 452
extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src ) ;
#line 457
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 460
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size(__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size(__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size(__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 148 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 168
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 192
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 214
extern int creat(char const   *__file , mode_t __mode ) ;
#line 260
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off_t __offset ,
                                                       __off_t __len , int __advise ) ;
#line 282
extern int posix_fallocate(int __fd , __off_t __offset , __off_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
  {
#line 46
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = __builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = __builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
  {
#line 122
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = __builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = __builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 101
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 123
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 126
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 180
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 192
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 205
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 385
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 388
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 401
extern  __attribute__((__nothrow__)) long random(void) ;
#line 404
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 410
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 415
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 434
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 437
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 440
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 445
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 453
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 455
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 459
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 467
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 468
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 471
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 472
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 476
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 477
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 481
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 482
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 484
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 501
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 503
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 508
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 511
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 517
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 520
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 526
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 529
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 532
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 550
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 559
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 574 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 580
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 591
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 595
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 603
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 617
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 629
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 647
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 653
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 657
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 664
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 675
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 688
extern int mkstemp(char *__template ) ;
#line 710
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 731
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 784
extern int system(char const   *__command ) ;
#line 800
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 820
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 830 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 840
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 841
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 844
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 854
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 858
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 872
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 878
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 884
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 890
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 893
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 896
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 902
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 905
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 909
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 922
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 925
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 929
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 936
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 946
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 957
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1003
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
    }
#line 42
    if (__cil_tmp4 < 4096UL) {
      {
#line 43
      __cil_tmp5 = __builtin_object_size(__resolved, 1);
#line 43
      __cil_tmp6 = __realpath_chk_warn(__name, __resolved, __cil_tmp5);
      }
#line 43
      return (__cil_tmp6);
    }
    {
#line 45
    __cil_tmp7 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp8 = __realpath_chk(__name, __resolved, __cil_tmp7);
    }
#line 45
    return (__cil_tmp8);
  }
  {
#line 48
  __cil_tmp9 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp9);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size(__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size(__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size(__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size(__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size(__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 139
extern FILE *stderr ;
#line 146
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 148
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 152
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 173
extern FILE *tmpfile(void) ;
#line 187
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 192
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 204
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 227
extern int fflush_unlocked(FILE *__stream ) ;
#line 246
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 252
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 279
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 292
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 298
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 304
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 308
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 326
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 334
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 341
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 347
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 349
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 354
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 391
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 397
extern int scanf(char const   *__format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 432
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 440
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 444
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 485
extern int fgetc(FILE *__stream ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 499
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 500
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 510
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 521
extern int fputc(int __c , FILE *__stream ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 553
extern int getw(FILE *__stream ) ;
#line 556
extern int putw(int __w , FILE *__stream ) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 646
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 652
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 675
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 707
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 731
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 775
extern void perror(char const   *__s ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
extern int sys_nerr ;
#line 27
extern char const   * const  sys_errlist[] ;
#line 786 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 791
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 812
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 844
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 28
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 34
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 36
  __cil_tmp4 = __builtin_va_arg_pack();
#line 36
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 46
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 49
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 49
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 49
  return (__cil_tmp5);
}
}
#line 55
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 58
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 67
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_va_arg_pack();
#line 67
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 67
  return (__cil_tmp6);
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 80
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 80
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 80
  return (__cil_tmp6);
}
}
#line 88
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 90
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 91
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 93
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 100
  __cil_tmp3 = __builtin_va_arg_pack();
#line 100
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 100
  return (__cil_tmp4);
}
}
#line 105
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_va_arg_pack();
#line 107
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 107
  return (__cil_tmp3);
}
}
#line 117
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 120
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 120
  return (__cil_tmp3);
}
}
#line 127
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 134
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 136
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 142
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 144
  __cil_tmp3 = __builtin_va_arg_pack();
#line 144
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 144
  return (__cil_tmp4);
}
}
#line 153
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 155
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 155
  return (__cil_tmp4);
}
}
#line 243
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 248
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 255
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 255 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 257
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 257
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 259
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 259
    if (! __cil_tmp5) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    } else
#line 259
    if (__n <= 0) {
      {
      {
#line 260
      __cil_tmp6 = __builtin_object_size(__s, 1);
      }
      {
#line 260
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 260
      return (__cil_tmp7);
    }
    {
#line 262
    __cil_tmp8 = __builtin_object_size(__s, 1);
    }
#line 262
    if ((size_t )__n > __cil_tmp8) {
      {
#line 263
      __cil_tmp9 = __builtin_object_size(__s, 1);
#line 263
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 263
      return (__cil_tmp10);
    }
  }
  {
#line 265
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 265
  return (__cil_tmp11);
}
}
#line 268
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 271
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 275
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 284
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 284 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 287
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 287
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 289
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 289
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 289
    if (! __cil_tmp6) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if (! __cil_tmp7) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    } else
#line 289
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 292
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 292
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 292
      return (__cil_tmp9);
    }
    {
#line 294
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 294
    if (__size * __n > __cil_tmp10) {
      {
#line 295
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 297
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 297
  return (__cil_tmp13);
}
}
#line 329
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 332
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 336
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 362
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 362
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 362
  if (__cil_tmp13) {
#line 362
    if (__cil_tmp14) {
#line 362
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 362
        if (__size * __n <= 8UL) {
#line 367
          __cnt = __size * __n;
#line 368
          __cptr = (char *)__ptr;
#line 369
          if (__cnt == 0UL) {
#line 370
            return ((size_t )0);
          }
          {
#line 372
          while (1) {
            while_continue: /* CIL Label */ ;
#line 372
            if (! (__cnt > 0UL)) {
#line 372
              goto while_break;
            }
            {
#line 374
            __cil_tmp18 = getc_unlocked(__stream);
#line 374
            __c = __cil_tmp18;
            }
#line 375
            if (__c == -1) {
#line 376
              goto while_break;
            }
#line 377
            __cil_tmp19 = __cptr;
#line 377
            __cptr ++;
#line 377
            *__cil_tmp19 = (char )__c;
#line 372
            __cnt --;
          }
          while_break: /* CIL Label */ ;
          }
#line 379
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 382
  __cil_tmp20 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp20);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 291 "../include/wavpack.h"
WavpackContext *WavpackOpenRawDecoder(void *main_data , int32_t main_size , void *corr_data ,
                                      int32_t corr_size , int16_t version , char *error ,
                                      int flags , int norm_offset ) ;
#line 296
WavpackContext *WavpackOpenFileInputEx64(WavpackStreamReader64 *reader , void *wv_id ,
                                         void *wvc_id , char *error , int flags ,
                                         int norm_offset ) ;
#line 297
WavpackContext *WavpackOpenFileInputEx(WavpackStreamReader *reader , void *wv_id ,
                                       void *wvc_id , char *error , int flags , int norm_offset ) ;
#line 298
WavpackContext *WavpackOpenFileInput(char const   *infilename , char *error , int flags ,
                                     int norm_offset ) ;
#line 319
int WavpackGetMode(WavpackContext *wpc ) ;
#line 336
int WavpackVerifySingleBlock(unsigned char *buffer , int verify_checksum ) ;
#line 337
int WavpackGetQualifyMode(WavpackContext *wpc ) ;
#line 338
char *WavpackGetErrorMessage(WavpackContext *wpc ) ;
#line 339
int WavpackGetVersion(WavpackContext *wpc ) ;
#line 340
char *WavpackGetFileExtension(WavpackContext *wpc ) ;
#line 341
unsigned char WavpackGetFileFormat(WavpackContext *wpc ) ;
#line 342
uint32_t WavpackUnpackSamples(WavpackContext *wpc , int32_t *buffer , uint32_t samples ) ;
#line 343
uint32_t WavpackGetNumSamples(WavpackContext *wpc ) ;
#line 344
int64_t WavpackGetNumSamples64(WavpackContext *wpc ) ;
#line 345
uint32_t WavpackGetNumSamplesInFrame(WavpackContext *wpc ) ;
#line 346
uint32_t WavpackGetSampleIndex(WavpackContext *wpc ) ;
#line 347
int64_t WavpackGetSampleIndex64(WavpackContext *wpc ) ;
#line 348
int WavpackGetNumErrors(WavpackContext *wpc ) ;
#line 349
int WavpackLossyBlocks(WavpackContext *wpc ) ;
#line 350
int WavpackSeekSample(WavpackContext *wpc , uint32_t sample ) ;
#line 351
int WavpackSeekSample64(WavpackContext *wpc , int64_t sample ) ;
#line 352
WavpackContext *WavpackCloseFile(WavpackContext *wpc ) ;
#line 353
uint32_t WavpackGetSampleRate(WavpackContext *wpc ) ;
#line 354
uint32_t WavpackGetNativeSampleRate(WavpackContext *wpc ) ;
#line 355
int WavpackGetBitsPerSample(WavpackContext *wpc ) ;
#line 356
int WavpackGetBytesPerSample(WavpackContext *wpc ) ;
#line 357
int WavpackGetNumChannels(WavpackContext *wpc ) ;
#line 358
int WavpackGetChannelMask(WavpackContext *wpc ) ;
#line 359
int WavpackGetReducedChannels(WavpackContext *wpc ) ;
#line 360
int WavpackGetFloatNormExp(WavpackContext *wpc ) ;
#line 361
int WavpackGetMD5Sum(WavpackContext *wpc , unsigned char data[16] ) ;
#line 362
void WavpackGetChannelIdentities(WavpackContext *wpc , unsigned char *identities ) ;
#line 363
uint32_t WavpackGetChannelLayout(WavpackContext *wpc , unsigned char *reorder ) ;
#line 364
uint32_t WavpackGetWrapperBytes(WavpackContext *wpc ) ;
#line 365
unsigned char *WavpackGetWrapperData(WavpackContext *wpc ) ;
#line 366
void WavpackFreeWrapper(WavpackContext *wpc ) ;
#line 367
void WavpackSeekTrailingWrapper(WavpackContext *wpc ) ;
#line 368
double WavpackGetProgress(WavpackContext *wpc ) ;
#line 369
uint32_t WavpackGetFileSize(WavpackContext *wpc ) ;
#line 370
int64_t WavpackGetFileSize64(WavpackContext *wpc ) ;
#line 371
double WavpackGetRatio(WavpackContext *wpc ) ;
#line 372
double WavpackGetAverageBitrate(WavpackContext *wpc , int count_wvc ) ;
#line 373
double WavpackGetInstantBitrate(WavpackContext *wpc ) ;
#line 374
int WavpackGetNumTagItems(WavpackContext *wpc ) ;
#line 375
int WavpackGetTagItem(WavpackContext *wpc , char const   *item , char *value , int size ) ;
#line 376
int WavpackGetTagItemIndexed(WavpackContext *wpc , int index , char *item , int size ) ;
#line 377
int WavpackGetNumBinaryTagItems(WavpackContext *wpc ) ;
#line 378
int WavpackGetBinaryTagItem(WavpackContext *wpc , char const   *item , char *value ,
                            int size ) ;
#line 379
int WavpackGetBinaryTagItemIndexed(WavpackContext *wpc , int index , char *item ,
                                   int size ) ;
#line 380
int WavpackAppendTagItem(WavpackContext *wpc , char const   *item , char const   *value ,
                         int vsize ) ;
#line 381
int WavpackAppendBinaryTagItem(WavpackContext *wpc , char const   *item , char const   *value ,
                               int vsize ) ;
#line 382
int WavpackDeleteTagItem(WavpackContext *wpc , char const   *item ) ;
#line 383
int WavpackWriteTag(WavpackContext *wpc ) ;
#line 385
WavpackContext *WavpackOpenFileOutput(WavpackBlockOutput blockout , void *wv_id ,
                                      void *wvc_id ) ;
#line 386
void WavpackSetFileInformation(WavpackContext *wpc , char *file_extension , unsigned char file_format ) ;
#line 394
int WavpackSetConfiguration(WavpackContext *wpc , WavpackConfig *config , uint32_t total_samples ) ;
#line 395
int WavpackSetConfiguration64(WavpackContext *wpc , WavpackConfig *config , int64_t total_samples ,
                              unsigned char const   *chan_ids ) ;
#line 396
int WavpackSetChannelLayout(WavpackContext *wpc , uint32_t layout_tag , unsigned char const   *reorder ) ;
#line 397
int WavpackAddWrapper(WavpackContext *wpc , void *data , uint32_t bcount ) ;
#line 398
int WavpackStoreMD5Sum(WavpackContext *wpc , unsigned char data[16] ) ;
#line 399
int WavpackPackInit(WavpackContext *wpc ) ;
#line 400
int WavpackPackSamples(WavpackContext *wpc , int32_t *sample_buffer , uint32_t sample_count ) ;
#line 401
int WavpackFlushSamples(WavpackContext *wpc ) ;
#line 402
void WavpackUpdateNumSamples(WavpackContext *wpc , void *first_block ) ;
#line 403
void *WavpackGetWrapperLocation(void *first_block , uint32_t *size ) ;
#line 404
double WavpackGetEncodedNoise(WavpackContext *wpc , double *peak ) ;
#line 406
void WavpackFloatNormalize(int32_t *values , int32_t num_values , int delta_exp ) ;
#line 408
void WavpackLittleEndianToNative(void *data , char *format ) ;
#line 409
void WavpackNativeToLittleEndian(void *data , char *format ) ;
#line 410
void WavpackBigEndianToNative(void *data , char *format ) ;
#line 411
void WavpackNativeToBigEndian(void *data , char *format ) ;
#line 413
uint32_t WavpackGetLibraryVersion(void) ;
#line 414
char const   *WavpackGetLibraryVersionString(void) ;
#line 39 "/doner/wavpack/wavpack-5.1.0/cli/utils.h"
int copy_timestamp(char const   *src_filename , char const   *dst_filename ) ;
#line 40
char *filespec_ext(char *filespec ) ;
#line 40
char *filespec_path(char *filespec ) ;
#line 41
char *filespec_name(char *filespec ) ;
#line 41
char *filespec_wild(char *filespec ) ;
#line 42
void error_line(char *error  , ...) ;
#line 43
void setup_break(void) ;
#line 43
void finish_line(void) ;
#line 44
int check_break(void) ;
#line 45
char yna(void) ;
#line 47
int DoReadFile(FILE *hFile , void *lpBuffer , uint32_t nNumberOfBytesToRead , uint32_t *lpNumberOfBytesRead ) ;
#line 48
int DoWriteFile(FILE *hFile , void *lpBuffer , uint32_t nNumberOfBytesToWrite , uint32_t *lpNumberOfBytesWritten ) ;
#line 49
int64_t DoGetFileSize(FILE *hFile ) ;
#line 50
int64_t DoGetFilePosition(FILE *hFile ) ;
#line 51
int DoSetFilePositionAbsolute(FILE *hFile , int64_t pos ) ;
#line 52
int DoSetFilePositionRelative(FILE *hFile , int64_t pos , int mode ) ;
#line 53
int DoUngetc(int c , FILE *hFile ) ;
#line 54
int DoCloseHandle(FILE *hFile ) ;
#line 55
int DoTruncateFile(FILE *hFile ) ;
#line 56
int DoDeleteFile(char *filename ) ;
#line 57
void DoSetConsoleTitle(char *text ) ;
#line 16 "/doner/wavpack/wavpack-5.1.0/cli/md5.h"
void MD5Init(struct MD5Context *ctx ) ;
#line 17
void MD5Update(struct MD5Context *ctx , unsigned char *buf , unsigned int len ) ;
#line 18
void MD5Final(unsigned char digest[16] , struct MD5Context *ctx ) ;
#line 19
void MD5Transform(uint32 buf[4] , uint32 in[16] ) ;
#line 63 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static char const   *sign_on  =    "\n WVUNPACK  Hybrid Lossless Audio Decompressor  %s Version %s\n Copyright (c) 1998 - 2017 David Bryant.  All Rights Reserved.\n\n";
#line 67 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static char const   *version_warning  =    "\n WARNING: WVUNPACK using libwavpack version %s, expected %s (see README)\n\n";
#line 70 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static char const   *usage  =    " Usage:   WVUNPACK [-options] infile[.wv]|- [...] [-o outfile[.ext]|outpath|-]\n\n          Multiple input files may be specified. Output format and extension\n          come from the source and by default the entire file is restored\n          (including the original headers and trailers). However, this can\n          be overridden to one of the supported formats listed below (which\n          also causes the original headers to be discarded).\n\n Formats: Microsoft RIFF:   \'wav\', force with -w or --wav, makes RF64 if > 4 GB\n          Sony Wave64:      \'w64\', force with --w64\n          Apple Core Audio: \'caf\', force with --caf-be or --caf-le\n          Raw PCM or DSD:   \'raw\', force with -r or --raw, little-endian\n          Philips DSDIFF:   \'dff\', force with --dsdiff or --dff\n          Sony DSF:         \'dsf\', force with --dsf\n\n Options: -b  = blindly decode all stream blocks & ignore length info\n          -c  = extract cuesheet only to stdout (no audio decode)\n               (note: equivalent to -x \"cuesheet\")\n          -cc = extract cuesheet file (.cue) in addition to audio file\n               (note: equivalent to -xx \"cuesheet=%a.cue\")\n          --caf-be = force output to big-endian Core Audio (extension .caf)\n          --caf-le = force output to little-endian Core Audio (extension .caf)\n          -d  = delete source file if successful (use with caution!)\n          --dff or --dsdiff = force output to Philips DSDIFF\n                (DSD audio only, extension .dff)\n          --dsf = force output to Sony DSF (DSD audio only, extension .dsf)\n          -f[n]  = file info to stdout in machine-parsable format\n                (optional \"n\" = 1-10 for specific item, otherwise all)\n          --help = this help display\n          -i  = ignore .wvc file (forces hybrid lossy decompression)\n          -m  = calculate and display MD5 signature; verify if lossless\n          -n  = no audio decoding (use with -xx to extract tags only)\n          --no-utf8-convert = leave tag items in UTF-8 on extract or display\n          -o FILENAME | PATH = specify output filename or path\n          -q  = quiet (keep console output to a minimum)\n          -r or --raw  = force raw audio decode (results in .raw extension)\n          -s  = display summary information only to stdout (no audio decode)\n          -ss = display super summary (including tags) to stdout (no decode)\n          --skip=[-][sample|hh:mm:ss.ss] = start decoding at specified sample/time\n              (specifying a \'-\' causes sample/time to be relative to end of file)\n          -t  = copy input file\'s time stamp to output file(s)\n          --until=[+|-][sample|hh:mm:ss.ss] = stop decoding at specified sample/time\n              (specifying a \'+\' causes sample/time to be relative to \'--skip\' point;\n               specifying a \'-\' causes sample/time to be relative to end of file)\n          -v  = verify source data only (no output file created)\n          --version = write the version to stdout\n          -w or --wav  = force output to Microsoft RIFF/RF64 (extension .wav)\n          --w64 = force output to Sony Wave64 format (extension .w64)\n          -x \"Field\" = extract specified tag field only to stdout (no audio decode)\n          -xx \"Field[=file]\" = extract specified tag field to file, optional\n              filename specification can inlude following replacement codes:\n                %a = audio output filename\n                %t = tag field name (note: comes from data for binary tags)\n                %e = extension from binary tag source file, or \'txt\' for text tag\n          -y  = yes to overwrite warning (use with caution!)\n          -z1 = set console title to indicate progress\n\n Web:     Visit www.wavpack.com for latest version and info\n";
#line 147
int WriteCaffHeader(FILE *outfile , WavpackContext *wpc , int64_t total_samples ,
                    int qmode ) ;
#line 148
int WriteWave64Header(FILE *outfile , WavpackContext *wpc , int64_t total_samples ,
                      int qmode ) ;
#line 149
int WriteRiffHeader(FILE *outfile , WavpackContext *wpc , int64_t total_samples ,
                    int qmode ) ;
#line 150
int WriteDsdiffHeader(FILE *outfile , WavpackContext *wpc , int64_t total_samples ,
                      int qmode ) ;
#line 151
int WriteDsfHeader(FILE *outfile , WavpackContext *wpc , int64_t total_samples , int qmode ) ;
#line 157 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static struct __anonstruct_60 file_formats[5]  = {      {"wav", "Microsoft RIFF", & WriteRiffHeader, 2}, 
        {"w64", "Sony Wave64", & WriteWave64Header, 8}, 
        {"caf", "Apple Core Audio\230", & WriteCaffHeader, 1}, 
        {"dff", "Philips DSDIFF", & WriteDsdiffHeader, 2}, 
        {"dsf", "Sony DSF\230", & WriteDsfHeader, 1}};
#line 170
int debug_logging_mode ;
#line 172
static int overwrite_all ;
#line 172
static int delete_source ;
#line 172
static int raw_decode ;
#line 172
static int no_utf8_convert ;
#line 172
static int no_audio_decode ;
#line 172
static int file_info ;
#line 173
static int summary ;
#line 173
static int ignore_wvc ;
#line 173
static int quiet_mode ;
#line 173
static int calc_md5 ;
#line 173
static int copy_time ;
#line 173
static int blind_decode ;
#line 173
static int decode_format ;
#line 173
static int format_specified ;
#line 173
static int caf_be ;
#line 173
static int set_console_title ;
#line 175
static int num_files ;
#line 175
static int file_index ;
#line 175
static int outbuf_k ;
#line 180
static struct sample_time_index skip ;
#line 180
static struct sample_time_index until ;
#line 182
static char *tag_extract_stdout ;
#line 183
static char **tag_extractions ;
#line 184
static int num_tag_extractions ;
#line 192
static void add_tag_extraction_to_list(char *spec ) ;
#line 193
static void parse_sample_time_index(struct sample_time_index *dst , char *src ) ;
#line 194
static int unpack_file(char *infilename , char *outfilename , int add_extension ) ;
#line 195
void display_progress(double file_progress ) ;
#line 213 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
int main(int argc , char **argv ) 
{ 
  int verify_only ;
  int error_count ;
  int add_extension ;
  int output_spec ;
  int c_count ;
  int x_count ;
  char outpath ;
  char **matches ;
  char *outfilename ;
  int result ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char **argv_t ;
  int argc_t ;
  char *long_option ;
  char *long_param ;
  char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  char const   *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  long __cil_tmp37 ;
  int __cil_tmp38 ;
  long __cil_tmp39 ;
  long __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  char const   *__cil_tmp49 ;
  int __cil_tmp50 ;
  char const   *__cil_tmp51 ;
  char const   *__cil_tmp52 ;
  char *infilename ;
  FILE *list ;
  FILE *__cil_tmp55 ;
  char *listbuff ;
  char *cp ;
  int listbytes ;
  int di ;
  int c ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int bytes_read ;
  void *__cil_tmp65 ;
  unsigned long __cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *fname ;
  void *__cil_tmp70 ;
  int ci ;
  char *__cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  void *__cil_tmp75 ;
  int __cil_tmp76 ;
  char listbuff___0[8192] ;
  char *lp ;
  FILE *list___0 ;
  FILE *__cil_tmp80 ;
  int c___0 ;
  unsigned long __cil_tmp82 ;
  char *__cil_tmp83 ;
  int ci___0 ;
  char *__cil_tmp85 ;
  int __cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  int __cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  void *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *tmp ;
  int __cil_tmp98 ;
  char *__cil_tmp99 ;
  int tmp___0 ;

  {
#line 219
  verify_only = 0;
#line 219
  error_count = 0;
#line 219
  add_extension = 0;
#line 219
  output_spec = 0;
#line 219
  c_count = 0;
#line 219
  x_count = 0;
#line 220
  matches = (char **)((void *)0);
  {
#line 220
  outfilename = (char *)((void *)0);
#line 237
  __cil_tmp13 = filespec_name(*argv);
  }
#line 237
  if (__cil_tmp13) {
    {
#line 238
    __cil_tmp16 = filespec_name(*argv);
#line 238
    __cil_tmp17 = strstr((char const   *)__cil_tmp16, "DEBUG");
    }
    {
#line 238
    __cil_tmp14 = filespec_name(*argv);
#line 238
    __cil_tmp15 = strstr((char const   *)__cil_tmp14, "ebug");
    }
#line 238
    if (__cil_tmp15) {
      _L: /* CIL Label */ 
#line 239
      argv_t = argv;
#line 240
      argc_t = argc;
#line 242
      debug_logging_mode = 1;
      {
#line 244
      while (1) {
        while_continue: /* CIL Label */ ;
#line 244
        argc_t --;
#line 244
        if (! argc_t) {
#line 244
          goto while_break;
        }
        {
#line 245
        argv_t ++;
#line 245
        error_line("arg %d: %s", argc - argc_t, *argv_t);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 238
    if (__cil_tmp17) {
#line 238
      goto _L;
    }
  }
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 255
    argc --;
#line 255
    if (! argc) {
#line 255
      goto while_break___0;
    }
#line 256
    argv ++;
#line 256
    if ((int )*(*argv) == 45) {
#line 256
      if ((int )*(*argv + 1) == 45) {
#line 256
        if ((int )*(*argv + 2)) {
#line 257
          long_option = *argv + 2;
#line 257
          long_param = long_option;
          {
#line 259
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 259
            if (! *long_param) {
#line 259
              goto while_break___1;
            }
#line 260
            __cil_tmp22 = long_param;
#line 260
            long_param ++;
#line 260
            if ((int )*__cil_tmp22 == 61) {
#line 261
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 263
          __cil_tmp23 = strcmp((char const   *)long_option, "help");
          }
#line 263
          if (! __cil_tmp23) {
            {
#line 264
            printf("%s", usage);
            }
#line 265
            return (0);
          } else {
            {
#line 267
            __cil_tmp24 = strcmp((char const   *)long_option, "version");
            }
#line 267
            if (! __cil_tmp24) {
              {
#line 268
              printf("wvunpack %s\n", "5.1.0");
#line 269
              __cil_tmp25 = WavpackGetLibraryVersionString();
#line 269
              printf("libwavpack %s\n", __cil_tmp25);
              }
#line 270
              return (0);
            } else {
              {
#line 276
              __cil_tmp26 = strcmp((char const   *)long_option, "no-utf8-convert");
              }
#line 276
              if (! __cil_tmp26) {
#line 277
                no_utf8_convert = 1;
              } else {
                {
#line 278
                __cil_tmp27 = strncmp((char const   *)long_option, "skip", (unsigned long )4);
                }
#line 278
                if (! __cil_tmp27) {
                  {
#line 279
                  parse_sample_time_index(& skip, long_param);
                  }
#line 281
                  if (! skip.value_is_valid) {
                    {
#line 282
                    error_line("invalid --skip parameter!");
#line 283
                    error_count ++;
                    }
                  }
                } else {
                  {
#line 286
                  __cil_tmp28 = strncmp((char const   *)long_option, "until", (unsigned long )5);
                  }
#line 286
                  if (! __cil_tmp28) {
                    {
#line 287
                    parse_sample_time_index(& until, long_param);
                    }
#line 289
                    if (! until.value_is_valid) {
                      {
#line 290
                      error_line("invalid --until parameter!");
#line 291
                      error_count ++;
                      }
                    }
                  } else {
                    {
#line 294
                    __cil_tmp29 = strcmp((char const   *)long_option, "caf-be");
                    }
#line 294
                    if (! __cil_tmp29) {
#line 295
                      decode_format = 2;
#line 296
                      format_specified = 1;
#line 296
                      caf_be = format_specified;
                    } else {
                      {
#line 298
                      __cil_tmp30 = strcmp((char const   *)long_option, "caf-le");
                      }
#line 298
                      if (! __cil_tmp30) {
#line 299
                        decode_format = 2;
#line 300
                        format_specified = 1;
                      } else {
                        {
#line 302
                        __cil_tmp31 = strcmp((char const   *)long_option, "dsf");
                        }
#line 302
                        if (! __cil_tmp31) {
#line 303
                          decode_format = 4;
#line 304
                          format_specified = 1;
                        } else {
                          {
#line 306
                          __cil_tmp33 = strcmp((char const   *)long_option, "dff");
                          }
                          {
#line 306
                          __cil_tmp32 = strcmp((char const   *)long_option, "dsdiff");
                          }
#line 306
                          if (! __cil_tmp32) {
#line 307
                            decode_format = 3;
#line 308
                            format_specified = 1;
                          } else
#line 306
                          if (! __cil_tmp33) {
#line 307
                            decode_format = 3;
#line 308
                            format_specified = 1;
                          } else {
                            {
#line 310
                            __cil_tmp34 = strcmp((char const   *)long_option, "w64");
                            }
#line 310
                            if (! __cil_tmp34) {
#line 311
                              decode_format = 1;
#line 312
                              format_specified = 1;
                            } else {
                              {
#line 314
                              __cil_tmp35 = strcmp((char const   *)long_option, "wav");
                              }
#line 314
                              if (! __cil_tmp35) {
#line 315
                                decode_format = 0;
#line 316
                                format_specified = 1;
                              } else {
                                {
#line 318
                                __cil_tmp36 = strcmp((char const   *)long_option,
                                                     "raw");
                                }
#line 318
                                if (! __cil_tmp36) {
#line 319
                                  raw_decode = 1;
                                } else {
                                  {
#line 321
                                  error_line("unknown option: %s !", long_option);
#line 322
                                  error_count ++;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
#line 256
          goto _L___1;
        }
      } else {
#line 256
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    _L___2: /* CIL Label */ 
#line 328
    if ((int )*(*argv) == 45) {
#line 328
      if ((int )*(*argv + 1)) {
        {
#line 330
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 330
          (*argv) ++;
#line 330
          if (! *(*argv)) {
#line 330
            goto while_break___2;
          }
          {
#line 332
          if ((int )*(*argv) == 'y') {
#line 332
            goto case_121;
          }
#line 332
          if ((int )*(*argv) == 'Y') {
#line 332
            goto case_121;
          }
#line 336
          if ((int )*(*argv) == 'c') {
#line 336
            goto case_99;
          }
#line 336
          if ((int )*(*argv) == 'C') {
#line 336
            goto case_99;
          }
#line 344
          if ((int )*(*argv) == 'd') {
#line 344
            goto case_100;
          }
#line 344
          if ((int )*(*argv) == 'D') {
#line 344
            goto case_100;
          }
#line 361
          if ((int )*(*argv) == 'o') {
#line 361
            goto case_111;
          }
#line 361
          if ((int )*(*argv) == 'O') {
#line 361
            goto case_111;
          }
#line 365
          if ((int )*(*argv) == 't') {
#line 365
            goto case_116;
          }
#line 365
          if ((int )*(*argv) == 'T') {
#line 365
            goto case_116;
          }
#line 369
          if ((int )*(*argv) == 'v') {
#line 369
            goto case_118;
          }
#line 369
          if ((int )*(*argv) == 'V') {
#line 369
            goto case_118;
          }
#line 373
          if ((int )*(*argv) == 'f') {
#line 373
            goto case_102;
          }
#line 373
          if ((int )*(*argv) == 'F') {
#line 373
            goto case_102;
          }
#line 388
          if ((int )*(*argv) == 's') {
#line 388
            goto case_115;
          }
#line 388
          if ((int )*(*argv) == 'S') {
#line 388
            goto case_115;
          }
#line 393
          if ((int )*(*argv) == 'k') {
#line 393
            goto case_107;
          }
#line 393
          if ((int )*(*argv) == 'K') {
#line 393
            goto case_107;
          }
#line 402
          if ((int )*(*argv) == 'm') {
#line 402
            goto case_109;
          }
#line 402
          if ((int )*(*argv) == 'M') {
#line 402
            goto case_109;
          }
#line 406
          if ((int )*(*argv) == 'b') {
#line 406
            goto case_98;
          }
#line 406
          if ((int )*(*argv) == 'B') {
#line 406
            goto case_98;
          }
#line 410
          if ((int )*(*argv) == 'n') {
#line 410
            goto case_110;
          }
#line 410
          if ((int )*(*argv) == 'N') {
#line 410
            goto case_110;
          }
#line 414
          if ((int )*(*argv) == 'r') {
#line 414
            goto case_114;
          }
#line 414
          if ((int )*(*argv) == 'R') {
#line 414
            goto case_114;
          }
#line 418
          if ((int )*(*argv) == 'w') {
#line 418
            goto case_119;
          }
#line 418
          if ((int )*(*argv) == 'W') {
#line 418
            goto case_119;
          }
#line 423
          if ((int )*(*argv) == 'q') {
#line 423
            goto case_113;
          }
#line 423
          if ((int )*(*argv) == 'Q') {
#line 423
            goto case_113;
          }
#line 427
          if ((int )*(*argv) == 'z') {
#line 427
            goto case_122;
          }
#line 427
          if ((int )*(*argv) == 'Z') {
#line 427
            goto case_122;
          }
#line 432
          if ((int )*(*argv) == 'x') {
#line 432
            goto case_120;
          }
#line 432
          if ((int )*(*argv) == 'X') {
#line 432
            goto case_120;
          }
#line 441
          if ((int )*(*argv) == 'i') {
#line 441
            goto case_105;
          }
#line 441
          if ((int )*(*argv) == 'I') {
#line 441
            goto case_105;
          }
#line 445
          goto switch_default;
          case_121: /* CIL Label */ 
          case_89: /* CIL Label */ 
#line 333
          overwrite_all = 1;
#line 334
          goto switch_break;
          case_99: /* CIL Label */ 
          case_67: /* CIL Label */ 
#line 337
          c_count ++;
#line 337
          if (c_count == 2) {
            {
#line 338
            add_tag_extraction_to_list("cuesheet=%a.cue");
#line 339
            c_count = 0;
            }
          }
#line 342
          goto switch_break;
          case_100: /* CIL Label */ 
          case_68: /* CIL Label */ 
#line 345
          delete_source = 1;
#line 346
          goto switch_break;
          case_111: /* CIL Label */ 
          case_79: /* CIL Label */ 
#line 362
          output_spec = 1;
#line 363
          goto switch_break;
          case_116: /* CIL Label */ 
          case_84: /* CIL Label */ 
#line 366
          copy_time = 1;
#line 367
          goto switch_break;
          case_118: /* CIL Label */ 
          case_86: /* CIL Label */ 
#line 370
          verify_only = 1;
#line 371
          goto switch_break;
          case_102: /* CIL Label */ 
          case_70: /* CIL Label */ 
          {
#line 374
          (*argv) ++;
#line 374
          __cil_tmp37 = strtol((char const   *)*argv, argv, 10);
#line 374
          file_info = (int )((char )__cil_tmp37);
          }
#line 376
          if (file_info < 0) {
            {
            {
#line 377
            error_line("-f option must be 1-10, or omit (or 0) for all!");
            }
#line 378
            error_count ++;
            }
          } else
#line 376
          if (file_info > 10) {
            {
            {
#line 377
            error_line("-f option must be 1-10, or omit (or 0) for all!");
            }
#line 378
            error_count ++;
            }
          } else {
#line 381
            no_audio_decode = 1;
#line 381
            quiet_mode = no_audio_decode;
#line 382
            file_info ++;
          }
#line 385
          (*argv) --;
#line 386
          goto switch_break;
          case_115: /* CIL Label */ 
          case_83: /* CIL Label */ 
#line 389
          no_audio_decode = 1;
#line 390
          summary ++;
#line 391
          goto switch_break;
          case_107: /* CIL Label */ 
          case_75: /* CIL Label */ 
          {
#line 394
          (*argv) ++;
#line 394
          __cil_tmp39 = strtol((char const   *)*argv, argv, 10);
#line 394
          outbuf_k = (int )__cil_tmp39;
          }
#line 396
          if (outbuf_k < 1) {
#line 397
            outbuf_k = 0;
          } else
#line 396
          if (outbuf_k > 16384) {
#line 397
            outbuf_k = 0;
          }
#line 399
          (*argv) --;
#line 400
          goto switch_break;
          case_109: /* CIL Label */ 
          case_77: /* CIL Label */ 
#line 403
          calc_md5 = 1;
#line 404
          goto switch_break;
          case_98: /* CIL Label */ 
          case_66: /* CIL Label */ 
#line 407
          blind_decode = 1;
#line 408
          goto switch_break;
          case_110: /* CIL Label */ 
          case_78: /* CIL Label */ 
#line 411
          no_audio_decode = 1;
#line 412
          goto switch_break;
          case_114: /* CIL Label */ 
          case_82: /* CIL Label */ 
#line 415
          raw_decode = 1;
#line 416
          goto switch_break;
          case_119: /* CIL Label */ 
          case_87: /* CIL Label */ 
#line 419
          decode_format = 0;
#line 420
          format_specified = 1;
#line 421
          goto switch_break;
          case_113: /* CIL Label */ 
          case_81: /* CIL Label */ 
#line 424
          quiet_mode = 1;
#line 425
          goto switch_break;
          case_122: /* CIL Label */ 
          case_90: /* CIL Label */ 
          {
#line 428
          (*argv) ++;
#line 428
          __cil_tmp40 = strtol((char const   *)*argv, argv, 10);
#line 428
          set_console_title = (int )((char )__cil_tmp40);
          }
#line 429
          (*argv) --;
#line 430
          goto switch_break;
          case_120: /* CIL Label */ 
          case_88: /* CIL Label */ 
#line 433
          x_count ++;
#line 433
          if (x_count == 3) {
            {
#line 434
            error_line("illegal option: %s !", *argv);
#line 435
            error_count ++;
#line 436
            x_count = 0;
            }
          }
#line 439
          goto switch_break;
          case_105: /* CIL Label */ 
          case_73: /* CIL Label */ 
#line 442
          ignore_wvc = 1;
#line 443
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 446
          error_line("illegal option: %c !", (int )*(*argv));
          }
#line 447
          error_count ++;
          switch_break: /* CIL Label */ ;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 328
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 450
    if (x_count) {
#line 451
      if (x_count == 1) {
#line 452
        if (tag_extract_stdout) {
          {
#line 453
          error_line("can\'t extract more than 1 tag item to stdout at a time!");
#line 454
          error_count ++;
          }
        } else {
#line 457
          tag_extract_stdout = *argv;
#line 458
          no_audio_decode = 1;
        }
      } else
#line 461
      if (x_count == 2) {
        {
#line 462
        add_tag_extraction_to_list(*argv);
        }
      }
#line 464
      x_count = 0;
    } else
#line 487
    if (output_spec) {
      {
#line 488
      __cil_tmp41 = strlen((char const   *)*argv);
#line 488
      __cil_tmp42 = malloc(__cil_tmp41 + 4096UL);
#line 488
      outfilename = __cil_tmp42;
#line 489
      strcpy(outfilename, (char const   *)*argv);
#line 490
      output_spec = 0;
      }
    } else {
      {
#line 493
      matches = (char **)realloc(matches, (unsigned long )(num_files + 1) * sizeof(*matches));
#line 494
      __cil_tmp44 = strlen((char const   *)*argv);
#line 494
      __cil_tmp45 = malloc(__cil_tmp44 + 10UL);
#line 494
      *(matches + num_files) = __cil_tmp45;
#line 495
      strcpy(*(matches + num_files), (char const   *)*argv);
#line 497
      __cil_tmp46 = filespec_ext(*(matches + num_files));
      }
#line 497
      if (! __cil_tmp46) {
#line 497
        if ((int )*(*(matches + num_files)) != 45) {
#line 497
          if ((int )*(*(matches + num_files)) != 64) {
            {
#line 499
            strcat(*(matches + num_files), ".wv");
            }
          }
        }
      }
#line 501
      num_files ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 509
  if (output_spec) {
    {
#line 510
    error_line("no output filename or path specified with -o option!");
#line 511
    error_count ++;
    }
  }
#line 514
  if (delete_source) {
#line 514
    if (verify_only) {
      {
      {
      {
#line 515
      error_line("can\'t delete in verify mode or when --skip or --until are used!");
      }
      }
#line 516
      delete_source = 0;
      }
    } else
#line 514
    if (skip.value_is_valid) {
      {
      {
      {
#line 515
      error_line("can\'t delete in verify mode or when --skip or --until are used!");
      }
      }
#line 516
      delete_source = 0;
      }
    } else
#line 514
    if (until.value_is_valid) {
      {
      {
      {
#line 515
      error_line("can\'t delete in verify mode or when --skip or --until are used!");
      }
      }
#line 516
      delete_source = 0;
      }
    }
  }
#line 519
  if (raw_decode) {
#line 519
    if (format_specified) {
      {
#line 520
      error_line("-r (raw decode) and -w (wav header) modes are incompatible!");
#line 521
      error_count ++;
      }
    }
  }
#line 524
  if (outfilename) {
#line 524
    if (verify_only) {
      {
#line 525
      error_line("outfile specification and verify mode are incompatible!");
#line 526
      error_count ++;
      }
    }
  }
#line 529
  if (c_count == 1) {
#line 530
    if (tag_extract_stdout) {
      {
#line 531
      error_line("can\'t extract more than 1 tag item to stdout at a time!");
#line 532
      error_count ++;
      }
    } else {
#line 535
      tag_extract_stdout = "cuesheet\220";
#line 536
      no_audio_decode = 1;
    }
  }
#line 540
  if (tag_extract_stdout) {
    _L___3: /* CIL Label */ 
#line 540
    if (outfilename) {
      {
      {
      {
      {
      {
      {
#line 541
      error_line("can\'t display summary information or extract a tag to stdout and do anything else!");
      }
      }
      }
      }
      }
#line 542
      error_count ++;
      }
    } else
#line 540
    if (num_tag_extractions) {
      {
      {
      {
      {
      {
      {
#line 541
      error_line("can\'t display summary information or extract a tag to stdout and do anything else!");
      }
      }
      }
      }
      }
#line 542
      error_count ++;
      }
    } else
#line 540
    if (verify_only) {
      {
      {
      {
      {
      {
      {
#line 541
      error_line("can\'t display summary information or extract a tag to stdout and do anything else!");
      }
      }
      }
      }
      }
#line 542
      error_count ++;
      }
    } else
#line 540
    if (delete_source) {
      {
      {
      {
      {
      {
      {
#line 541
      error_line("can\'t display summary information or extract a tag to stdout and do anything else!");
      }
      }
      }
      }
      }
#line 542
      error_count ++;
      }
    } else
#line 540
    if (format_specified) {
      {
      {
      {
      {
      {
      {
#line 541
      error_line("can\'t display summary information or extract a tag to stdout and do anything else!");
      }
      }
      }
      }
      }
#line 542
      error_count ++;
      }
    } else
#line 540
    if (raw_decode) {
      {
      {
      {
      {
      {
      {
#line 541
      error_line("can\'t display summary information or extract a tag to stdout and do anything else!");
      }
      }
      }
      }
      }
#line 542
      error_count ++;
      }
    }
  } else
#line 540
  if (summary) {
#line 540
    goto _L___3;
  }
#line 545
  if (tag_extract_stdout) {
    _L___4: /* CIL Label */ 
#line 545
    if (outfilename) {
#line 545
      if ((int )*outfilename == 45) {
        {
#line 546
        error_line("can\'t extract tags when unpacking audio to stdout!");
#line 547
        error_count ++;
        }
      }
    }
  } else
#line 545
  if (num_tag_extractions) {
#line 545
    goto _L___4;
  }
  {
#line 550
  __cil_tmp49 = WavpackGetLibraryVersionString();
#line 550
  __cil_tmp50 = strcmp(__cil_tmp49, "5.1.0");
  }
#line 550
  if (__cil_tmp50) {
    {
#line 551
    __cil_tmp51 = WavpackGetLibraryVersionString();
#line 551
    fprintf(stderr, version_warning, __cil_tmp51, "5.1.0");
#line 552
    fflush(stderr);
    }
  } else
#line 554
  if (! quiet_mode) {
#line 554
    if (! error_count) {
      {
#line 555
      __cil_tmp52 = WavpackGetLibraryVersionString();
#line 555
      fprintf(stderr, sign_on, "Linux", __cil_tmp52);
#line 556
      fflush(stderr);
      }
    }
  }
#line 559
  if (! num_files) {
    {
#line 560
    printf("%s", usage);
    }
#line 561
    return (1);
  }
#line 564
  if (error_count) {
#line 565
    return (1);
  }
  {
#line 567
  setup_break();
#line 569
  file_index = 0;
  }
  {
#line 569
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 569
    if (! (file_index < num_files)) {
#line 569
      goto while_break___3;
    }
#line 570
    infilename = *(matches + file_index);
#line 577
    if ((int )*infilename == 64) {
      {
#line 578
      __cil_tmp55 = fopen((char const   *)(infilename + 1), "rb");
#line 578
      list = __cil_tmp55;
#line 579
      listbuff = (char *)((void *)0);
#line 580
      listbytes = 0;
#line 582
      di = file_index;
      }
      {
#line 582
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 582
        if (! (di < num_files - 1)) {
#line 582
          goto while_break___4;
        }
#line 583
        *(matches + di) = *(matches + (di + 1));
#line 582
        di ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 585
      __cil_tmp62 = file_index;
#line 585
      file_index --;
#line 586
      __cil_tmp63 = num_files;
#line 586
      num_files --;
#line 588
      if (list == (void *)0) {
        {
#line 589
        error_line("file %s not found!", infilename + 1);
#line 590
        free(infilename);
        }
#line 591
        return (1);
      }
      {
#line 594
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 597
        listbuff = (char *)realloc(listbuff, (unsigned long )(listbytes + 1024));
#line 598
        memset(listbuff + listbytes, 0, (unsigned long )1024);
#line 599
        __cil_tmp66 = fread(listbuff + listbytes, (unsigned long )1, (unsigned long )1024,
                            list);
#line 599
        bytes_read = (int )__cil_tmp66;
        }
#line 599
        listbytes += bytes_read;
#line 601
        if (bytes_read < 1024) {
#line 602
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 609
      cp = listbuff;
      {
#line 611
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 611
        __cil_tmp67 = cp;
#line 611
        cp ++;
#line 611
        c = (int )*__cil_tmp67;
#line 611
        if (! c) {
#line 611
          goto while_break___6;
        }
        {
#line 613
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 613
          if (! (c == 10 || c == 13)) {
#line 613
            goto while_break___7;
          }
#line 614
          __cil_tmp68 = cp;
#line 614
          cp ++;
#line 614
          c = (int )*__cil_tmp68;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 616
        if (c) {
          {
#line 617
          __cil_tmp70 = malloc((unsigned long )4096);
#line 617
          fname = __cil_tmp70;
#line 618
          ci = 0;
          }
          {
#line 620
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 621
            __cil_tmp73 = ci;
#line 621
            ci ++;
#line 621
            *(fname + __cil_tmp73) = (char )c;
#line 620
            if (! (((c != 10 && c != 13) && c) && ci < 4096)) {
#line 620
              goto while_break___8;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 624
          __cil_tmp74 = ci;
#line 624
          ci ++;
#line 624
          *(fname + __cil_tmp74) = (char )'\000';
#line 625
          num_files ++;
#line 625
          __cil_tmp75 = realloc(matches, (unsigned long )num_files * sizeof(*matches));
#line 625
          matches = __cil_tmp75;
#line 627
          di = num_files - 1;
          }
          {
#line 627
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 627
            if (! (di > file_index + 1)) {
#line 627
              goto while_break___9;
            }
#line 628
            *(matches + di) = *(matches + (di - 1));
#line 627
            __cil_tmp76 = di;
#line 627
            di --;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 630
          file_index ++;
#line 630
          *(matches + file_index) = fname;
        }
#line 633
        if (! c) {
#line 634
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 637
      fclose(list);
#line 638
      free(listbuff);
#line 639
      free(infilename);
      }
    }
#line 569
    file_index ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 686
  if (outfilename) {
#line 686
    if ((int )*(outfilename + 0) == 64) {
      {
#line 687
      lp = (char *)listbuff___0;
#line 688
      __cil_tmp80 = fopen((char const   *)(outfilename + 1), "rb");
#line 688
      list___0 = __cil_tmp80;
      }
#line 691
      if (list___0 == (void *)0) {
        {
#line 692
        error_line("file %s not found!", outfilename + 1);
#line 693
        free(outfilename);
        }
#line 694
        return (1);
      }
      {
#line 697
      memset((char *)listbuff___0, 0, sizeof(listbuff___0));
#line 698
      __cil_tmp82 = fread((char *)listbuff___0, (unsigned long )1, sizeof(listbuff___0) - 1UL,
                          list___0);
#line 698
      c___0 = (int )__cil_tmp82;
      }
      {
#line 704
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 704
        __cil_tmp83 = lp;
#line 704
        lp ++;
#line 704
        c___0 = (int )*__cil_tmp83;
#line 704
        if (! (c___0 == 10 || c___0 == 13)) {
#line 704
          goto while_break___10;
        }

      }
      while_break___10: /* CIL Label */ ;
      }
#line 706
      if (c___0) {
#line 707
        ci___0 = 0;
        {
#line 709
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 710
          __cil_tmp86 = ci___0;
#line 710
          ci___0 ++;
#line 710
          *(outfilename + __cil_tmp86) = (char )c___0;
#line 709
          if (! (((c___0 != 10 && c___0 != 13) && c___0) && ci___0 < 4096)) {
#line 709
            goto while_break___11;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
#line 713
        *(outfilename + ci___0) = (char )'\000';
      } else {
        {
#line 716
        error_line("output spec file is empty!");
#line 717
        free(outfilename);
#line 718
        fclose(list___0);
        }
#line 719
        return (1);
      }
      {
#line 722
      fclose(list___0);
      }
    }
  }
#line 727
  if (num_files) {
#line 728
    if (outfilename) {
#line 728
      if ((int )*outfilename != 45) {
        {
#line 729
        __cil_tmp87 = filespec_path(outfilename);
#line 729
        outpath = (char )(__cil_tmp87 != (void *)0);
        }
#line 731
        if (num_files > 1) {
#line 731
          if (! outpath) {
            {
#line 732
            error_line("%s is not a valid output path", outfilename);
#line 733
            free(outfilename);
            }
#line 734
            return (1);
          }
        }
      } else {
#line 738
        outpath = (char )0;
      }
    } else {
#line 738
      outpath = (char )0;
    }
    {
#line 740
    __cil_tmp88 = filespec_ext(outfilename);
#line 740
    add_extension = (! outfilename || (int )outpath) || ! __cil_tmp88;
#line 744
    file_index = 0;
    }
    {
#line 744
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 744
      if (! (file_index < num_files)) {
#line 744
        goto while_break___12;
      }
      {
#line 745
      __cil_tmp89 = check_break();
      }
#line 745
      if (__cil_tmp89) {
#line 746
        goto while_break___12;
      }
#line 750
      if (outpath) {
        {
#line 751
        __cil_tmp90 = filespec_name(*(matches + file_index));
#line 751
        strcat(outfilename, (char const   *)__cil_tmp90);
#line 753
        __cil_tmp91 = filespec_ext(outfilename);
        }
#line 753
        if (__cil_tmp91) {
          {
#line 754
          __cil_tmp92 = filespec_ext(outfilename);
#line 754
          *__cil_tmp92 = (char )'\000';
          }
        }
      } else
#line 756
      if (! outfilename) {
        {
#line 757
        __cil_tmp93 = strlen((char const   *)*(matches + file_index));
#line 757
        __cil_tmp94 = malloc(__cil_tmp93 + 10UL);
#line 757
        outfilename = __cil_tmp94;
#line 758
        strcpy(outfilename, (char const   *)*(matches + file_index));
#line 760
        __cil_tmp95 = filespec_ext(outfilename);
        }
#line 760
        if (__cil_tmp95) {
          {
#line 761
          __cil_tmp96 = filespec_ext(outfilename);
#line 761
          *__cil_tmp96 = (char )'\000';
          }
        }
      }
#line 764
      if (num_files > 1) {
#line 764
        if (! quiet_mode) {
          {
#line 765
          fprintf(stderr, "\n%s:\n", *(matches + file_index));
#line 766
          fflush(stderr);
          }
        }
      }
#line 769
      if (verify_only) {
#line 769
        tmp = (char *)((void *)0);
      } else {
#line 769
        tmp = outfilename;
      }
      {
#line 769
      __cil_tmp98 = unpack_file(*(matches + file_index), tmp, add_extension);
#line 769
      result = __cil_tmp98;
      }
#line 771
      if (result != 0) {
#line 772
        error_count ++;
      }
#line 774
      if (result == 2) {
#line 775
        goto while_break___12;
      }
#line 779
      if (outpath) {
        {
#line 780
        __cil_tmp99 = filespec_name(outfilename);
#line 780
        *__cil_tmp99 = (char )'\000';
        }
      } else
#line 781
      if ((int )*outfilename != 45) {
        {
#line 782
        free(outfilename);
#line 783
        outfilename = (char *)((void *)0);
        }
      }
      {
#line 786
      free(*(matches + file_index));
      }
#line 744
      file_index ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 789
    if (num_files > 1) {
#line 790
      if (error_count) {
        {
#line 791
        fprintf(stderr, "\n **** warning: errors occurred in %d of %d files! ****\n\230\001",
                error_count, num_files);
#line 792
        fflush(stderr);
        }
      } else
#line 794
      if (! quiet_mode) {
        {
#line 795
        fprintf(stderr, "\n **** %d files successfully processed ****\n", num_files);
#line 796
        fflush(stderr);
        }
      }
    }
    {
#line 800
    free(matches);
    }
  } else {
    {
#line 803
    error_line("nothing to do!");
#line 804
    error_count ++;
    }
  }
#line 807
  if (outfilename) {
    {
#line 808
    free(outfilename);
    }
  }
#line 810
  if (set_console_title) {
    {
#line 811
    DoSetConsoleTitle("WvUnpack Completed");
    }
  }
#line 813
  if (error_count) {
#line 813
    tmp___0 = 1;
  } else {
#line 813
    tmp___0 = 0;
  }
#line 813
  return (tmp___0);
}
}
#line 863 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void parse_sample_time_index(struct sample_time_index *dst , char *src ) 
{ 
  int colons ;
  double temp ;
  char *__cil_tmp5 ;
  int tmp ;
  char *__cil_tmp7 ;
  unsigned short const   **__cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;

  {
  {
#line 865
  colons = 0;
#line 868
  memset(dst, 0, sizeof(*dst));
  }
#line 870
  if ((int )*src == 43) {
    _L: /* CIL Label */ 
#line 871
    __cil_tmp5 = src;
#line 871
    src ++;
#line 871
    if ((int )*__cil_tmp5 == 43) {
#line 871
      tmp = 1;
    } else {
#line 871
      tmp = - 1;
    }
#line 871
    dst->value_is_relative = tmp;
  } else
#line 870
  if ((int )*src == 45) {
#line 870
    goto _L;
  }
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if (! *src) {
#line 873
      goto while_break;
    }
#line 874
    if ((int )*src == 58) {
#line 875
      colons ++;
#line 875
      if (colons == 3) {
#line 876
        return;
      }
#line 878
      src ++;
#line 879
      dst->value_is_time = 1;
#line 880
      dst->value *= 60.;
#line 881
      goto while_continue;
    } else {
      {
#line 883
      __cil_tmp8 = __ctype_b_loc();
      }
#line 883
      if ((int )*src == 46) {
        _L___6: /* CIL Label */ 
        {
#line 884
        temp = strtod((char const   *)src, & src);
#line 886
        __cil_tmp10 = floor(temp);
        }
#line 886
        if (temp < 0.) {
#line 888
          return;
        } else
#line 886
        if (dst->value_is_time) {
#line 886
          if (temp >= 60.) {
#line 888
            return;
          } else {
#line 886
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 886
        if (! dst->value_is_time) {
#line 886
          if (temp != __cil_tmp10) {
#line 888
            return;
          }
        }
#line 890
        dst->value += temp;
      } else
#line 883
      if ((int )*(*__cil_tmp8 + (int )*src) & 2048) {
#line 883
        goto _L___6;
      } else {
#line 893
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 895
  dst->value_is_valid = 1;
  return;
}
}
#line 905 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static FILE *open_output_file(char *filename , char **tempfilename ) 
{ 
  FILE *retval ;
  FILE *testfile ;
  char dummy ;
  FILE *__cil_tmp6 ;
  size_t res ;
  unsigned long __cil_tmp8 ;
  int count ;
  unsigned long __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *tmp ;
  char __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  FILE *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  char *tmp___0 ;
  FILE *__cil_tmp26 ;
  char *tmp___1 ;

  {
#line 910
  *tempfilename = (char *)((void *)0);
#line 912
  if ((int )*filename == 45) {
#line 919
    return (stdout);
  }
  {
#line 922
  testfile = fopen((char const   *)filename, "rb\026>dU");
  }
#line 924
  if (testfile) {
    {
#line 925
    __cil_tmp8 = fread(& dummy, (unsigned long )1, (unsigned long )1, testfile);
#line 925
    res = __cil_tmp8;
#line 927
    fclose(testfile);
    }
#line 929
    if (res == 1UL) {
#line 930
      count = 0;
#line 932
      if (! overwrite_all) {
        {
#line 933
        __cil_tmp10 = strlen((char const   *)filename);
        }
#line 933
        if (__cil_tmp10 > 30UL) {
          {
#line 933
          __cil_tmp11 = filespec_name(filename);
#line 933
          tmp = __cil_tmp11;
          }
        } else {
#line 933
          tmp = filename;
        }
        {
#line 933
        fprintf(stderr, "overwrite %s (yes/no/all)? ", tmp);
#line 934
        fflush(stderr);
        }
#line 936
        if (set_console_title) {
          {
#line 937
          DoSetConsoleTitle("overwrite?\026>dU");
          }
        }
        {
#line 939
        __cil_tmp13 = yna();
        }
        {
#line 940
        if ((int )__cil_tmp13 == 'n') {
#line 940
          goto case_110;
        }
#line 943
        if ((int )__cil_tmp13 == 'a') {
#line 943
          goto case_97;
        }
#line 939
        goto switch_break;
        case_110: /* CIL Label */ 
#line 941
        return ((FILE *)((void *)0));
        case_97: /* CIL Label */ 
#line 944
        overwrite_all = 1;
        switch_break: /* CIL Label */ ;
        }
      }
      {
#line 948
      __cil_tmp14 = strlen((char const   *)filename);
#line 948
      __cil_tmp15 = malloc(__cil_tmp14 + 16UL);
#line 948
      *tempfilename = __cil_tmp15;
      }
      {
#line 950
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 951
        strcpy(*tempfilename, (char const   *)filename);
#line 953
        __cil_tmp16 = filespec_ext(*tempfilename);
        }
#line 953
        if (__cil_tmp16) {
#line 954
          __cil_tmp17 = count;
#line 954
          count ++;
#line 954
          if (__cil_tmp17) {
            {
#line 955
            __cil_tmp18 = filespec_ext(*tempfilename);
#line 955
            sprintf(__cil_tmp18, ".tmp%d", count - 1);
            }
          } else {
            {
#line 957
            __cil_tmp19 = filespec_ext(*tempfilename);
#line 957
            strcpy(__cil_tmp19, ".tmp");
            }
          }
          {
#line 959
          __cil_tmp20 = filespec_ext(filename);
#line 959
          strcat(*tempfilename, (char const   *)__cil_tmp20);
          }
        } else {
#line 962
          __cil_tmp21 = count;
#line 962
          count ++;
#line 962
          if (__cil_tmp21) {
            {
#line 963
            __cil_tmp22 = strlen((char const   *)*tempfilename);
#line 963
            sprintf(*tempfilename + __cil_tmp22, ".tmp%d", count - 1);
            }
          } else {
            {
#line 965
            strcat(*tempfilename, ".tmp");
            }
          }
        }
        {
#line 968
        testfile = fopen((char const   *)*tempfilename, "rb");
        }
#line 970
        if (! testfile) {
#line 971
          goto while_break;
        }
        {
#line 973
        res = fread(& dummy, (unsigned long )1, (unsigned long )1, testfile);
#line 974
        fclose(testfile);
        }
#line 976
        if (res != 1UL) {
#line 977
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 982
  if (*tempfilename) {
#line 982
    tmp___0 = *tempfilename;
  } else {
#line 982
    tmp___0 = filename;
  }
  {
#line 982
  __cil_tmp26 = fopen((char const   *)tmp___0, "w+b=dU");
#line 982
  retval = __cil_tmp26;
  }
#line 984
  if (retval == (void *)0) {
#line 985
    if (*tempfilename) {
#line 985
      tmp___1 = *tempfilename;
    } else {
#line 985
      tmp___1 = filename;
    }
    {
#line 985
    error_line("can\'t create file %s!", tmp___1);
    }
  }
#line 987
  return (retval);
}
}
#line 998
static int unpack_audio(WavpackContext *wpc , FILE *outfile , int qmode , unsigned char *md5_digest ,
                        int64_t *sample_count ) ;
#line 999
static int unpack_dsd_audio(WavpackContext *wpc , FILE *outfile , int qmode , unsigned char *md5_digest ,
                            int64_t *sample_count ) ;
#line 1000
static int do_tag_extractions(WavpackContext *wpc , char *outfilename ) ;
#line 1001
static void *store_samples(void *dst , int32_t *src , int qmode , int bps , int count ) ;
#line 1002
static void dump_summary(WavpackContext *wpc , char *name , FILE *dst ) ;
#line 1003
static int dump_tag_item_to_file(WavpackContext *wpc , char const   *tag_item , FILE *dst ,
                                 char *fname ) ;
#line 1004
static void dump_file_info(WavpackContext *wpc , char *name , FILE *dst , int parameter ) ;
#line 1005
static void unreorder_channels(int32_t *data , unsigned char *order , int num_chans ,
                               int num_samples ) ;
#line 1007 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static int unpack_file(char *infilename , char *outfilename , int add_extension ) 
{ 
  int64_t skip_sample_index ;
  int64_t until_samples_total ;
  int64_t total_unpacked_samples ;
  int result ;
  int md5_diff ;
  int created_riff_header ;
  int input_qmode ;
  int output_qmode ;
  int input_format ;
  int output_format ;
  int open_flags ;
  int padding_bytes ;
  int num_channels ;
  int wvc_mode ;
  unsigned char md5_unpacked[16] ;
  char *outfilename_temp ;
  char *extension ;
  WavpackContext *wpc ;
  uint32_t bcount ;
  char error[80] ;
  FILE *outfile ;
  double dtime ;
  struct timeval time1 ;
  struct timeval time2 ;
  struct timezone timez ;
  WavpackContext *__cil_tmp29 ;
  char *__cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  unsigned char __cil_tmp34 ;
  int tmp ;
  int tmp___0 ;
  uint32_t __cil_tmp37 ;
  uint32_t __cil_tmp38 ;
  int64_t __cil_tmp39 ;
  int64_t __cil_tmp40 ;
  int64_t __cil_tmp41 ;
  int __cil_tmp42 ;
  int64_t __cil_tmp43 ;
  int64_t __cil_tmp44 ;
  double until_sample_index ;
  uint32_t __cil_tmp46 ;
  double tmp___1 ;
  int64_t __cil_tmp48 ;
  int64_t __cil_tmp49 ;
  int64_t __cil_tmp50 ;
  int64_t __cil_tmp51 ;
  int64_t __cil_tmp52 ;
  int64_t __cil_tmp53 ;
  int __cil_tmp54 ;
  char *__cil_tmp55 ;
  int __cil_tmp56 ;
  FILE *__cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  char *__cil_tmp59 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned long __cil_tmp63 ;
  char *__cil_tmp64 ;
  char *tmp___5 ;
  unsigned long __cil_tmp66 ;
  char *__cil_tmp67 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int __cil_tmp71 ;
  uint32_t __cil_tmp72 ;
  unsigned char *__cil_tmp73 ;
  uint32_t __cil_tmp74 ;
  int __cil_tmp75 ;
  uint32_t __cil_tmp76 ;
  int64_t __cil_tmp77 ;
  int __cil_tmp78 ;
  unsigned char *tmp___9 ;
  int __cil_tmp80 ;
  unsigned char *tmp___10 ;
  int __cil_tmp82 ;
  int64_t data_chunk_bytes ;
  int __cil_tmp84 ;
  int alignment ;
  int bytes_over ;
  int pcount ;
  int tmp___11 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  char md5_string1[33] ;
  char md5_string2[33] ;
  unsigned char md5_original[16] ;
  int i ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  uint32_t __cil_tmp98 ;
  unsigned char *wrapper_data ;
  unsigned char *__cil_tmp100 ;
  int wrapper_bytes ;
  uint32_t __cil_tmp102 ;
  int __cil_tmp103 ;
  int __cil_tmp104 ;
  unsigned char *__cil_tmp105 ;
  int __cil_tmp106 ;
  int64_t __cil_tmp107 ;
  int64_t __cil_tmp108 ;
  int64_t tmp___12 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int64_t outfile_length ;
  int64_t __cil_tmp113 ;
  int __cil_tmp114 ;
  unsigned long __cil_tmp115 ;
  char *__cil_tmp116 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;
  int64_t __cil_tmp121 ;
  int64_t __cil_tmp122 ;
  int64_t __cil_tmp123 ;
  int64_t __cil_tmp124 ;
  int64_t __cil_tmp125 ;
  int __cil_tmp126 ;
  int __cil_tmp127 ;
  int __cil_tmp128 ;
  char *file ;
  char *fext ;
  char *oper ;
  char *cmode ;
  char cratio[16] ;
  unsigned long __cil_tmp134 ;
  char *__cil_tmp135 ;
  char *tmp___15 ;
  unsigned long __cil_tmp137 ;
  char *__cil_tmp138 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  int __cil_tmp143 ;
  double __cil_tmp144 ;
  double __cil_tmp145 ;
  double __cil_tmp146 ;
  double __cil_tmp147 ;
  int res ;
  int __cil_tmp149 ;
  char const   *tmp___20 ;
  char in2filename[4096] ;
  int __cil_tmp152 ;
  char const   *tmp___21 ;

  {
#line 1009
  skip_sample_index = (int64_t )0;
#line 1009
  until_samples_total = (int64_t )0;
#line 1009
  total_unpacked_samples = (int64_t )0;
#line 1010
  result = 0;
#line 1010
  md5_diff = 0;
#line 1010
  created_riff_header = 0;
#line 1011
  output_qmode = 0;
#line 1011
  output_format = 0;
#line 1012
  open_flags = 0;
#line 1012
  padding_bytes = 0;
#line 1014
  outfilename_temp = (char *)((void *)0);
#line 1015
  extension = (char *)((void *)0);
#line 1035
  if (outfilename) {
#line 1035
    if (! raw_decode) {
#line 1035
      if (! blind_decode) {
#line 1035
        if (! format_specified) {
#line 1035
          if (! skip.value_is_valid) {
#line 1035
            if (! until.value_is_valid) {
#line 1037
              open_flags |= 4;
            } else {
#line 1035
              goto _L;
            }
          } else {
#line 1035
            goto _L;
          }
        } else {
#line 1035
          goto _L;
        }
      } else {
#line 1035
        goto _L;
      }
    } else {
#line 1035
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___7: /* CIL Label */ 
  _L___8: /* CIL Label */ 
  _L___9: /* CIL Label */ 
  _L___10: /* CIL Label */ 
#line 1035
  if (summary > 1) {
#line 1037
    open_flags |= 4;
  }
#line 1039
  if (blind_decode) {
#line 1040
    open_flags |= 2080;
  }
#line 1042
  if (! ignore_wvc) {
#line 1043
    open_flags |= 1;
  }
#line 1045
  if (tag_extract_stdout) {
#line 1046
    open_flags |= 2;
  } else
#line 1045
  if (summary > 1) {
#line 1046
    open_flags |= 2;
  } else
#line 1045
  if (num_tag_extractions) {
#line 1046
    open_flags |= 2;
  }
#line 1048
  if (format_specified) {
#line 1048
    if (decode_format != 3) {
#line 1048
      if (decode_format != 4) {
#line 1049
        open_flags |= 1536;
      } else {
#line 1051
        open_flags |= 1280;
      }
    } else {
#line 1051
      open_flags |= 1280;
    }
  } else {
#line 1051
    open_flags |= 1280;
  }
  {
#line 1053
  wpc = WavpackOpenFileInput((char const   *)infilename, (char *)error, open_flags,
                             0);
  }
#line 1055
  if (! wpc) {
    {
#line 1056
    error_line((char *)error);
    }
#line 1057
    return (1);
  }
#line 1060
  if (add_extension) {
#line 1061
    if (raw_decode) {
#line 1062
      extension = "raw";
    } else
#line 1063
    if (format_specified) {
#line 1064
      extension = file_formats[decode_format].default_extension;
    } else {
      {
#line 1066
      extension = WavpackGetFileExtension(wpc);
      }
    }
  }
  {
#line 1069
  __cil_tmp31 = WavpackGetMode(wpc);
#line 1069
  wvc_mode = __cil_tmp31 & 1;
#line 1070
  num_channels = WavpackGetNumChannels(wpc);
#line 1071
  input_qmode = WavpackGetQualifyMode(wpc);
#line 1072
  __cil_tmp34 = WavpackGetFileFormat(wpc);
#line 1072
  input_format = (int )__cil_tmp34;
  }
#line 1081
  if (raw_decode) {
#line 1082
    if (input_qmode & 48) {
#line 1082
      tmp = 32;
    } else {
#line 1082
      tmp = 0;
    }
#line 1082
    output_qmode = tmp;
  } else
#line 1084
  if (format_specified) {
    {
#line 1086
    if (decode_format == 2) {
#line 1086
      goto case_2;
    }
#line 1092
    if (decode_format == 1) {
#line 1092
      goto case_1;
    }
#line 1092
    if (decode_format == 0) {
#line 1092
      goto case_1;
    }
#line 1098
    if (decode_format == 4) {
#line 1098
      goto case_4;
    }
#line 1098
    if (decode_format == 3) {
#line 1098
      goto case_4;
    }
#line 1085
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1087
    if (caf_be) {
#line 1087
      tmp___0 = 1;
    } else {
#line 1087
      tmp___0 = 0;
    }
#line 1087
    output_qmode = (2 | tmp___0) | (input_qmode & 8);
#line 1088
    output_format = decode_format;
#line 1089
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1093
    output_format = decode_format;
#line 1094
    output_qmode = 0;
#line 1095
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 1099
    if (! (input_qmode & 48)) {
      {
#line 1100
      error_line("can\'t export PCM source to DSD file!dU");
#line 1101
      WavpackCloseFile(wpc);
      }
#line 1102
      return (1);
    }
#line 1105
    if (decode_format == 4) {
#line 1106
      output_qmode = 80;
    } else {
#line 1108
      output_qmode = 32;
    }
#line 1110
    output_format = decode_format;
#line 1111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 1114
  if ((unsigned long )input_format < sizeof(file_formats) / sizeof(file_formats[0])) {
#line 1115
    output_format = input_format;
#line 1116
    output_qmode = input_qmode;
  } else {
    {
#line 1118
    __cil_tmp37 = WavpackGetWrapperBytes(wpc);
    }
#line 1118
    if (! __cil_tmp37) {
      _L___11: /* CIL Label */ 
      _L___12: /* CIL Label */ 
#line 1121
      if (input_qmode & 48) {
#line 1122
        output_format = 3;
#line 1123
        output_qmode = 32;
      } else {
#line 1126
        output_format = 0;
#line 1127
        output_qmode = 0;
      }
#line 1130
      extension = file_formats[output_format].default_extension;
    } else
#line 1118
    if (skip.value_is_valid) {
#line 1118
      goto _L___11;
    } else
#line 1118
    if (until.value_is_valid) {
#line 1118
      goto _L___11;
    } else {
#line 1133
      output_qmode = input_qmode;
    }
  }
#line 1135
  if (skip.value_is_valid) {
#line 1136
    if (skip.value_is_time) {
      {
#line 1137
      __cil_tmp38 = WavpackGetSampleRate(wpc);
#line 1137
      skip_sample_index = (int64_t )(skip.value * (double )__cil_tmp38);
      }
    } else {
#line 1139
      skip_sample_index = (int64_t )skip.value;
    }
#line 1141
    if (skip.value_is_relative == -1) {
      {
#line 1142
      __cil_tmp39 = WavpackGetNumSamples64(wpc);
      }
#line 1142
      if (__cil_tmp39 == -1L) {
        {
#line 1143
        error_line("can\'t use negative relative --skip command with files of unknown length!\220");
#line 1144
        WavpackCloseFile(wpc);
        }
#line 1145
        return (1);
      }
      {
#line 1148
      __cil_tmp40 = WavpackGetNumSamples64(wpc);
      }
#line 1148
      if (skip_sample_index < __cil_tmp40) {
        {
#line 1149
        __cil_tmp41 = WavpackGetNumSamples64(wpc);
#line 1149
        skip_sample_index = __cil_tmp41 - skip_sample_index;
        }
      } else {
#line 1151
        skip_sample_index = (int64_t )0;
      }
    }
    {
#line 1154
    __cil_tmp42 = WavpackSeekSample64(wpc, skip_sample_index);
    }
#line 1154
    if (skip_sample_index) {
#line 1154
      if (! __cil_tmp42) {
        {
#line 1155
        error_line("can\'t seek to specified --skip point!U");
#line 1156
        WavpackCloseFile(wpc);
        }
#line 1157
        return (1);
      }
    }
    {
#line 1160
    __cil_tmp43 = WavpackGetNumSamples64(wpc);
    }
#line 1160
    if (__cil_tmp43 != -1L) {
      {
#line 1161
      __cil_tmp44 = WavpackGetNumSamples64(wpc);
#line 1161
      until_samples_total = __cil_tmp44 - skip_sample_index;
      }
    }
  }
#line 1164
  if (until.value_is_valid) {
#line 1165
    if (until.value_is_time) {
      {
#line 1165
      __cil_tmp46 = WavpackGetSampleRate(wpc);
#line 1165
      tmp___1 = until.value * (double )__cil_tmp46;
      }
    } else {
#line 1165
      tmp___1 = until.value;
    }
#line 1165
    until_sample_index = tmp___1;
#line 1167
    if (until.value_is_relative == -1) {
      {
#line 1168
      __cil_tmp48 = WavpackGetNumSamples64(wpc);
      }
#line 1168
      if (__cil_tmp48 == -1L) {
        {
#line 1169
        error_line("can\'t use negative relative --until command with files of unknown length!");
#line 1170
        WavpackCloseFile(wpc);
        }
#line 1171
        return (1);
      }
      {
#line 1174
      __cil_tmp49 = WavpackGetNumSamples64(wpc);
      }
#line 1174
      if (until_sample_index + (double )skip_sample_index < (double )__cil_tmp49) {
        {
#line 1175
        __cil_tmp50 = WavpackGetNumSamples64(wpc);
#line 1175
        until_samples_total = (int64_t )(((double )__cil_tmp50 - until_sample_index) - (double )skip_sample_index);
        }
      } else {
#line 1177
        until_samples_total = (int64_t )0;
      }
    } else {
#line 1180
      if (until.value_is_relative == 1) {
#line 1181
        until_samples_total = (int64_t )until_sample_index;
      } else
#line 1182
      if (until_sample_index > (double )skip_sample_index) {
#line 1183
        until_samples_total = (int64_t )(until_sample_index - (double )skip_sample_index);
      } else {
#line 1185
        until_samples_total = (int64_t )0;
      }
      {
#line 1187
      __cil_tmp52 = WavpackGetNumSamples64(wpc);
      }
      {
#line 1187
      __cil_tmp51 = WavpackGetNumSamples64(wpc);
      }
#line 1187
      if (__cil_tmp51 != -1L) {
#line 1187
        if (skip_sample_index + until_samples_total > __cil_tmp52) {
          {
#line 1189
          __cil_tmp53 = WavpackGetNumSamples64(wpc);
#line 1189
          until_samples_total = __cil_tmp53 - skip_sample_index;
          }
        }
      }
    }
#line 1192
    if (! until_samples_total) {
      {
#line 1193
      error_line("--until command results in no samples to decode!\220");
#line 1194
      WavpackCloseFile(wpc);
      }
#line 1195
      return (1);
    }
  }
#line 1199
  if (file_info) {
    {
#line 1200
    dump_file_info(wpc, infilename, stdout, file_info - 1);
    }
  } else
#line 1201
  if (summary) {
    {
#line 1202
    dump_summary(wpc, infilename, stdout);
    }
  } else
#line 1203
  if (tag_extract_stdout) {
    {
#line 1204
    __cil_tmp54 = dump_tag_item_to_file(wpc, (char const   *)tag_extract_stdout, stdout,
                                        (char *)((void *)0));
    }
#line 1204
    if (! __cil_tmp54) {
      {
#line 1205
      error_line("tag \"%s\" not found!", tag_extract_stdout);
#line 1206
      WavpackCloseFile(wpc);
      }
#line 1207
      return (1);
    }
  } else {
    {
#line 1210
    __cil_tmp55 = filespec_name(outfilename);
    }
#line 1210
    if (outfilename) {
#line 1210
      if (num_tag_extractions) {
#line 1210
        if ((int )*outfilename != 45) {
#line 1210
          if (__cil_tmp55) {
            {
#line 1211
            result = do_tag_extractions(wpc, outfilename);
            }
#line 1213
            if (result != 0) {
              {
#line 1214
              WavpackCloseFile(wpc);
              }
#line 1215
              return (result);
            }
          }
        }
      }
    }
  }
#line 1219
  if (no_audio_decode) {
    {
#line 1220
    WavpackCloseFile(wpc);
    }
#line 1221
    return (0);
  }
#line 1224
  if (outfilename) {
#line 1225
    if ((int )*outfilename != 45) {
#line 1225
      if (add_extension) {
        {
#line 1226
        strcat(outfilename, ".");
#line 1227
        strcat(outfilename, (char const   *)extension);
        }
      }
    }
    {
#line 1230
    outfile = open_output_file(outfilename, & outfilename_temp);
    }
#line 1230
    if (outfile == (void *)0) {
      {
#line 1231
      WavpackCloseFile(wpc);
      }
#line 1232
      return (1);
    } else
#line 1234
    if ((int )*outfilename == 45) {
#line 1235
      if (! quiet_mode) {
#line 1236
        if ((int )*infilename == 45) {
#line 1236
          tmp___3 = "stdinU";
        } else {
          {
#line 1236
          __cil_tmp58 = strlen((char const   *)infilename);
          }
#line 1236
          if (__cil_tmp58 > 30UL) {
            {
#line 1236
            __cil_tmp59 = filespec_name(infilename);
#line 1236
            tmp___2 = __cil_tmp59;
            }
          } else {
#line 1236
            tmp___2 = infilename;
          }
#line 1236
          tmp___3 = (char const   *)tmp___2;
        }
#line 1236
        if (wvc_mode) {
#line 1236
          tmp___4 = " (+.wvc)\323\001 >\001";
        } else {
#line 1236
          tmp___4 = "\220";
        }
        {
#line 1236
        fprintf(stderr, "unpacking %s%s to stdout,\366\025>dU", (int )tmp___3, tmp___4);
#line 1238
        fflush(stderr);
        }
      }
    } else
#line 1241
    if (! quiet_mode) {
      {
#line 1242
      __cil_tmp63 = strlen((char const   *)outfilename);
      }
#line 1242
      if (__cil_tmp63 > 30UL) {
        {
#line 1242
        __cil_tmp64 = filespec_name(outfilename);
#line 1242
        tmp___5 = __cil_tmp64;
        }
      } else {
#line 1242
        tmp___5 = outfilename;
      }
      {
#line 1242
      fprintf(stderr, "restoring %s,", tmp___5);
#line 1243
      fflush(stderr);
      }
    }
  } else {
#line 1247
    outfile = (FILE *)((void *)0);
#line 1249
    if (! quiet_mode) {
#line 1250
      if ((int )*infilename == 45) {
#line 1250
        tmp___7 = "stdin";
      } else {
        {
#line 1250
        __cil_tmp66 = strlen((char const   *)infilename);
        }
#line 1250
        if (__cil_tmp66 > 30UL) {
          {
#line 1250
          __cil_tmp67 = filespec_name(infilename);
#line 1250
          tmp___6 = __cil_tmp67;
          }
        } else {
#line 1250
          tmp___6 = infilename;
        }
#line 1250
        tmp___7 = (char const   *)tmp___6;
      }
#line 1250
      if (wvc_mode) {
#line 1250
        tmp___8 = " (+.wvc)\323\001 >\001";
      } else {
#line 1250
        tmp___8 = "\220";
      }
      {
#line 1250
      fprintf(stderr, "verifying %s%s,", (int )tmp___7, tmp___8);
#line 1252
      fflush(stderr);
      }
    }
  }
  {
#line 1259
  gettimeofday(& time1, & timez);
  }
#line 1262
  if (outfile) {
#line 1262
    if (! raw_decode) {
#line 1263
      if (until_samples_total) {
        {
#line 1264
        __cil_tmp71 = (*(file_formats[output_format].WriteHeader))(outfile, wpc, until_samples_total,
                                                                   output_qmode);
        }
#line 1264
        if (! __cil_tmp71) {
          {
#line 1265
          DoTruncateFile(outfile);
#line 1266
          result = 2;
          }
        } else {
#line 1269
          created_riff_header = 1;
        }
      } else {
        {
#line 1271
        __cil_tmp72 = WavpackGetWrapperBytes(wpc);
        }
#line 1271
        if (__cil_tmp72) {
          {
#line 1272
          __cil_tmp76 = WavpackGetWrapperBytes(wpc);
          }
          {
#line 1272
          __cil_tmp73 = WavpackGetWrapperData(wpc);
          }
          {
#line 1272
          __cil_tmp74 = WavpackGetWrapperBytes(wpc);
#line 1272
          __cil_tmp75 = DoWriteFile(outfile, __cil_tmp73, __cil_tmp74, & bcount);
          }
#line 1272
          if (! __cil_tmp75) {
            {
            {
#line 1274
            error_line("can\'t write .WAV data, disk probably full!\025>dU");
            }
            {
#line 1275
            DoTruncateFile(outfile);
            }
#line 1276
            result = 2;
            }
          } else
#line 1272
          if (bcount != __cil_tmp76) {
            {
            {
#line 1274
            error_line("can\'t write .WAV data, disk probably full!\025>dU");
            }
            {
#line 1275
            DoTruncateFile(outfile);
            }
#line 1276
            result = 2;
            }
          }
          {
#line 1279
          WavpackFreeWrapper(wpc);
          }
        } else {
          {
#line 1281
          __cil_tmp77 = WavpackGetNumSamples64(wpc);
#line 1281
          __cil_tmp78 = (*(file_formats[output_format].WriteHeader))(outfile, wpc,
                                                                     __cil_tmp77,
                                                                     output_qmode);
          }
#line 1281
          if (! __cil_tmp78) {
            {
#line 1282
            DoTruncateFile(outfile);
#line 1283
            result = 2;
            }
          } else {
#line 1286
            created_riff_header = 1;
          }
        }
      }
    }
  }
#line 1289
  total_unpacked_samples = until_samples_total;
#line 1291
  if (output_qmode & 48) {
#line 1292
    if (calc_md5) {
#line 1292
      tmp___9 = (unsigned char *)md5_unpacked;
    } else {
#line 1292
      tmp___9 = (unsigned char *)((void *)0);
    }
    {
#line 1292
    __cil_tmp80 = unpack_dsd_audio(wpc, outfile, output_qmode, tmp___9, & total_unpacked_samples);
#line 1292
    result = __cil_tmp80;
    }
  } else {
#line 1294
    if (calc_md5) {
#line 1294
      tmp___10 = (unsigned char *)md5_unpacked;
    } else {
#line 1294
      tmp___10 = (unsigned char *)((void *)0);
    }
    {
#line 1294
    __cil_tmp82 = unpack_audio(wpc, outfile, output_qmode, tmp___10, & total_unpacked_samples);
#line 1294
    result = __cil_tmp82;
    }
  }
#line 1298
  if (outfile) {
#line 1298
    if (result == 0) {
#line 1298
      if (! raw_decode) {
#line 1298
        if (file_formats[output_format].chunk_alignment != 1) {
          {
#line 1299
          __cil_tmp84 = WavpackGetBytesPerSample(wpc);
#line 1299
          data_chunk_bytes = (total_unpacked_samples * (long )num_channels) * (long )__cil_tmp84;
#line 1300
          alignment = file_formats[output_format].chunk_alignment;
#line 1301
          bytes_over = (int )(data_chunk_bytes % (long )alignment);
          }
#line 1302
          if (bytes_over) {
#line 1302
            tmp___11 = alignment - bytes_over;
          } else {
#line 1302
            tmp___11 = 0;
          }
#line 1302
          pcount = tmp___11;
#line 1304
          padding_bytes = pcount;
          {
#line 1306
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1306
            __cil_tmp89 = pcount;
#line 1306
            pcount --;
#line 1306
            if (! __cil_tmp89) {
#line 1306
              goto while_break;
            }
            {
#line 1307
            __cil_tmp90 = DoWriteFile(outfile, "\251", (uint32_t )1, & bcount);
            }
#line 1307
            if (! __cil_tmp90) {
              {
              {
#line 1308
              error_line("can\'t write .WAV data, disk probably full!\027>dU");
              }
              {
#line 1309
              DoTruncateFile(outfile);
              }
#line 1310
              result = 2;
              }
            } else
#line 1307
            if (bcount != 1U) {
              {
              {
#line 1308
              error_line("can\'t write .WAV data, disk probably full!\027>dU");
              }
              {
#line 1309
              DoTruncateFile(outfile);
              }
#line 1310
              result = 2;
              }
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 1314
  __cil_tmp91 = check_break();
  }
#line 1314
  if (! __cil_tmp91) {
#line 1314
    if (calc_md5) {
      {
#line 1315
      md5_string1 = "00000000000000000000000000000000\f";
#line 1316
      md5_string2 = "00000000000000000000000000000000\f";
#line 1320
      __cil_tmp96 = WavpackGetMD5Sum(wpc, (unsigned char *)md5_original);
      }
#line 1320
      if (__cil_tmp96) {
#line 1322
        i = 0;
        {
#line 1322
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1322
          if (! (i < 16)) {
#line 1322
            goto while_break___0;
          }
          {
#line 1323
          sprintf((char *)md5_string1 + i * 2, "%02x", (int )md5_original[i]);
          }
#line 1322
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1325
        error_line("original md5:  %s\267\027>dU", (char *)md5_string1);
#line 1327
        __cil_tmp97 = memcmp((unsigned char *)md5_unpacked, (unsigned char *)md5_original,
                             (unsigned long )16);
        }
#line 1327
        if (__cil_tmp97) {
#line 1328
          md5_diff = 1;
        }
      }
#line 1331
      i = 0;
      {
#line 1331
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1331
        if (! (i < 16)) {
#line 1331
          goto while_break___1;
        }
        {
#line 1332
        sprintf((char *)md5_string2 + i * 2, "%02xdU", (int )md5_unpacked[i]);
        }
#line 1331
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1334
      error_line("unpacked md5:  %s", (char *)md5_string2);
      }
    }
  }
  {
#line 1340
  __cil_tmp98 = WavpackGetWrapperBytes(wpc);
  }
#line 1340
  if (outfile) {
#line 1340
    if (result == 0) {
#line 1340
      if (! created_riff_header) {
#line 1340
        if (__cil_tmp98) {
          {
#line 1341
          __cil_tmp100 = WavpackGetWrapperData(wpc);
#line 1341
          wrapper_data = __cil_tmp100;
#line 1342
          __cil_tmp102 = WavpackGetWrapperBytes(wpc);
#line 1342
          wrapper_bytes = (int )__cil_tmp102;
          }
          {
#line 1348
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1348
            __cil_tmp103 = padding_bytes;
#line 1348
            padding_bytes --;
#line 1348
            if (! ((__cil_tmp103 && wrapper_bytes) && ! *wrapper_data)) {
#line 1348
              goto while_break___2;
            }
#line 1349
            __cil_tmp104 = wrapper_bytes;
#line 1349
            wrapper_bytes --;
#line 1350
            wrapper_data ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1353
          __cil_tmp106 = DoWriteFile(outfile, wrapper_data, (uint32_t )wrapper_bytes,
                                     & bcount);
          }
#line 1353
          if (! __cil_tmp106) {
            {
            {
#line 1354
            error_line("can\'t write .WAV data, disk probably full!\027>dU");
            }
            {
#line 1355
            DoTruncateFile(outfile);
            }
#line 1356
            result = 2;
            }
          } else
#line 1353
          if (bcount != (unsigned int )wrapper_bytes) {
            {
            {
#line 1354
            error_line("can\'t write .WAV data, disk probably full!\027>dU");
            }
            {
#line 1355
            DoTruncateFile(outfile);
            }
#line 1356
            result = 2;
            }
          }
          {
#line 1359
          WavpackFreeWrapper(wpc);
          }
        }
      }
    }
  }
#line 1362
  if (until_samples_total) {
#line 1362
    tmp___12 = until_samples_total;
  } else {
    {
#line 1362
    __cil_tmp108 = WavpackGetNumSamples64(wpc);
#line 1362
    tmp___12 = __cil_tmp108;
    }
  }
  {
#line 1362
  __cil_tmp107 = WavpackGetNumSamples64(wpc);
  }
#line 1362
  if (outfile) {
#line 1362
    if (result == 0) {
#line 1362
      if (created_riff_header) {
#line 1362
        if (__cil_tmp107 == -1L) {
          _L___13: /* CIL Label */ 
          {
#line 1365
          __cil_tmp110 = DoSetFilePositionAbsolute(outfile, (int64_t )0);
          }
#line 1365
          if ((int )*outfilename == 45) {
            {
            {
#line 1366
            error_line("can\'t update file header with actual size");
            }
            }
          } else
#line 1365
          if (__cil_tmp110) {
            {
            {
#line 1366
            error_line("can\'t update file header with actual size");
            }
            }
          } else {
            {
#line 1367
            __cil_tmp111 = (*(file_formats[output_format].WriteHeader))(outfile, wpc,
                                                                        total_unpacked_samples,
                                                                        output_qmode);
            }
#line 1367
            if (! __cil_tmp111) {
              {
#line 1368
              DoTruncateFile(outfile);
#line 1369
              result = 2;
              }
            }
          }
        } else
#line 1362
        if (tmp___12 != total_unpacked_samples) {
#line 1362
          goto _L___13;
        }
      }
    }
  }
#line 1376
  if (outfile) {
    {
#line 1377
    fflush(outfile);
    }
#line 1379
    if ((int )*outfilename != 45) {
      {
#line 1380
      __cil_tmp113 = DoGetFileSize(outfile);
#line 1380
      outfile_length = __cil_tmp113;
#line 1382
      __cil_tmp114 = DoCloseHandle(outfile);
      }
#line 1382
      if (! __cil_tmp114) {
        {
#line 1383
        __cil_tmp115 = strlen((char const   *)outfilename);
        }
#line 1383
        if (__cil_tmp115 > 30UL) {
          {
#line 1383
          __cil_tmp116 = filespec_name(outfilename);
#line 1383
          tmp___13 = __cil_tmp116;
          }
        } else {
#line 1383
          tmp___13 = outfilename;
        }
        {
#line 1383
        error_line("can\'t close file %s!", tmp___13);
#line 1384
        result = 1;
        }
      }
#line 1387
      if (! outfile_length) {
#line 1388
        if (outfilename_temp) {
#line 1388
          tmp___14 = outfilename_temp;
        } else {
#line 1388
          tmp___14 = outfilename;
        }
        {
#line 1388
        DoDeleteFile(tmp___14);
        }
      }
    }
  }
  {
#line 1407
  __cil_tmp119 = rename((char const   *)outfilename_temp, (char const   *)outfilename);
  }
#line 1407
  if (outfilename) {
#line 1407
    if (result == 0) {
#line 1407
      if (outfilename_temp) {
#line 1407
        if (__cil_tmp119) {
          {
#line 1408
          error_line("can not rename temp file %s to %s!", outfilename_temp, outfilename);
#line 1409
          result = 1;
          }
        }
      }
    }
  }
#line 1413
  if (outfilename) {
#line 1413
    if (outfilename_temp) {
      {
#line 1413
      free(outfilename_temp);
      }
    }
  }
  {
#line 1415
  __cil_tmp120 = copy_timestamp((char const   *)infilename, (char const   *)outfilename);
  }
#line 1415
  if (outfilename) {
#line 1415
    if (result == 0) {
#line 1415
      if (copy_time) {
#line 1415
        if (! __cil_tmp120) {
          {
#line 1417
          error_line("failure copying time stamp!");
          }
        }
      }
    }
  }
#line 1419
  if (result == 0) {
    {
#line 1420
    __cil_tmp121 = WavpackGetNumSamples64(wpc);
    }
#line 1420
    if (! until_samples_total) {
#line 1420
      if (__cil_tmp121 != -1L) {
        {
#line 1421
        __cil_tmp122 = WavpackGetNumSamples64(wpc);
        }
#line 1421
        if (total_unpacked_samples < __cil_tmp122) {
          {
#line 1422
          __cil_tmp123 = WavpackGetNumSamples64(wpc);
#line 1422
          error_line("file is missing %llu samples!U", __cil_tmp123 - total_unpacked_samples);
#line 1424
          result = 1;
          }
        } else {
          {
#line 1426
          __cil_tmp124 = WavpackGetNumSamples64(wpc);
          }
#line 1426
          if (total_unpacked_samples > __cil_tmp124) {
            {
#line 1427
            __cil_tmp125 = WavpackGetNumSamples64(wpc);
#line 1427
            error_line("file has %llu extra samples!dU", total_unpacked_samples - __cil_tmp125);
#line 1429
            result = 1;
            }
          }
        }
      }
    }
    {
#line 1433
    __cil_tmp126 = WavpackGetNumErrors(wpc);
    }
#line 1433
    if (__cil_tmp126) {
      {
#line 1434
      __cil_tmp127 = WavpackGetNumErrors(wpc);
#line 1434
      error_line("missing data or crc errors detected in %d block(s)!>dU", __cil_tmp127);
#line 1435
      result = 1;
      }
    }
  }
  {
#line 1439
  __cil_tmp128 = WavpackGetMode(wpc);
  }
#line 1439
  if (result == 0) {
#line 1439
    if (md5_diff) {
#line 1439
      if (__cil_tmp128 & 2) {
#line 1439
        if (! until_samples_total) {
#line 1439
          if (input_qmode == output_qmode) {
            {
#line 1440
            error_line("MD5 signatures should match, but do not!\220");
#line 1441
            result = 1;
            }
          }
        }
      }
    }
  }
  {
#line 1452
  gettimeofday(& time2, & timez);
#line 1453
  dtime = (double )time2.tv_sec + (double )time2.tv_usec / 1000000.;
#line 1454
  dtime -= (double )time1.tv_sec + (double )time1.tv_usec / 1000000.;
  }
#line 1457
  if (result == 0) {
#line 1457
    if (! quiet_mode) {
#line 1458
      cratio = "\005";
#line 1460
      if (outfilename) {
#line 1460
        if ((int )*outfilename != 45) {
          {
#line 1461
          __cil_tmp134 = strlen((char const   *)outfilename);
          }
#line 1461
          if (__cil_tmp134 > 30UL) {
            {
#line 1461
            __cil_tmp135 = filespec_name(outfilename);
#line 1461
            tmp___15 = __cil_tmp135;
            }
          } else {
#line 1461
            tmp___15 = outfilename;
          }
#line 1461
          file = tmp___15;
#line 1462
          fext = "\220";
#line 1463
          oper = "restored\220";
        } else {
#line 1460
          goto _L___14;
        }
      } else {
        _L___14: /* CIL Label */ 
#line 1466
        if ((int )*infilename == 45) {
#line 1466
          tmp___17 = "stdin";
        } else {
          {
#line 1466
          __cil_tmp137 = strlen((char const   *)infilename);
          }
#line 1466
          if (__cil_tmp137 > 30UL) {
            {
#line 1466
            __cil_tmp138 = filespec_name(infilename);
#line 1466
            tmp___16 = __cil_tmp138;
            }
          } else {
#line 1466
            tmp___16 = infilename;
          }
#line 1466
          tmp___17 = (char const   *)tmp___16;
        }
#line 1466
        file = (int )tmp___17;
#line 1467
        if (wvc_mode) {
#line 1467
          tmp___18 = " (+.wvc)\323\001 ";
        } else {
#line 1467
          tmp___18 = "\220";
        }
#line 1467
        fext = tmp___18;
#line 1468
        if (outfilename) {
#line 1468
          tmp___19 = "unpacked\323\001 >\001";
        } else {
#line 1468
          tmp___19 = "verified\220";
        }
#line 1468
        oper = tmp___19;
      }
      {
#line 1471
      __cil_tmp143 = WavpackGetMode(wpc);
      }
#line 1471
      if (__cil_tmp143 & 2) {
        {
#line 1472
        cmode = "lossless\220";
#line 1474
        __cil_tmp144 = WavpackGetRatio(wpc);
        }
#line 1474
        if (__cil_tmp144 != 0.) {
          {
#line 1475
          __cil_tmp145 = WavpackGetRatio(wpc);
#line 1475
          sprintf((char *)cratio, ", %.2f%%\240", 100. - __cil_tmp145 * 100.);
          }
        }
      } else {
        {
#line 1478
        cmode = "lossy";
#line 1480
        __cil_tmp146 = WavpackGetAverageBitrate(wpc, 1);
        }
#line 1480
        if (__cil_tmp146 != 0.) {
          {
#line 1481
          __cil_tmp147 = WavpackGetAverageBitrate(wpc, 1);
#line 1481
          sprintf((char *)cratio, ", %d kbps\233\025>dU", (int )(__cil_tmp147 / 1000.));
          }
        }
      }
      {
#line 1484
      error_line("%s %s%s in %.2f secs (%s%s)", oper, file, fext, dtime, cmode, (char *)cratio);
      }
    }
  }
  {
#line 1487
  WavpackCloseFile(wpc);
  }
#line 1489
  if (result == 0) {
#line 1489
    if (delete_source) {
      {
#line 1490
      __cil_tmp149 = DoDeleteFile(infilename);
#line 1490
      res = __cil_tmp149;
      }
#line 1492
      if (! quiet_mode) {
        _L___15: /* CIL Label */ 
#line 1493
        if (res) {
#line 1493
          tmp___20 = "deleted";
        } else {
#line 1493
          tmp___20 = "can\'t delete";
        }
        {
#line 1493
        error_line("%s source file %s", tmp___20, infilename);
        }
      } else
#line 1492
      if (! res) {
#line 1492
        goto _L___15;
      }
#line 1496
      if (wvc_mode) {
        {
#line 1499
        strcpy((char *)in2filename, (char const   *)infilename);
#line 1500
        strcat((char *)in2filename, "c");
#line 1501
        res = DoDeleteFile((char *)in2filename);
        }
#line 1503
        if (! quiet_mode) {
          _L___16: /* CIL Label */ 
#line 1504
          if (res) {
#line 1504
            tmp___21 = "deleted";
          } else {
#line 1504
            tmp___21 = "can\'t deletedU";
          }
          {
#line 1504
          error_line("%s source file %s/\030>dU", tmp___21, (char *)in2filename);
          }
        } else
#line 1503
        if (! res) {
#line 1503
          goto _L___16;
        }
      }
    }
  }
#line 1509
  return (result);
}
}
#line 1514 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static int unpack_audio(WavpackContext *wpc , FILE *outfile , int qmode , unsigned char *md5_digest ,
                        int64_t *sample_count ) 
{ 
  unsigned char *output_buffer ;
  unsigned char *output_pointer ;
  unsigned char *new_channel_order ;
  int bps ;
  int __cil_tmp10 ;
  int num_channels ;
  int __cil_tmp12 ;
  int64_t until_samples_total ;
  int64_t total_unpacked_samples ;
  int bytes_per_sample ;
  int result ;
  uint32_t output_buffer_size ;
  uint32_t bcount ;
  double progress ;
  int32_t *temp_buffer ;
  MD5_CTX md5_context ;
  void *__cil_tmp22 ;
  int layout ;
  uint32_t __cil_tmp24 ;
  int i ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  uint32_t samples_to_unpack ;
  uint32_t samples_unpacked ;
  uint32_t __cil_tmp30 ;
  void *__cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  double __cil_tmp34 ;
  double __cil_tmp35 ;
  double __cil_tmp36 ;
  int nobs ;
  double __cil_tmp38 ;
  double __cil_tmp39 ;
  char const   *tmp ;

  {
#line 1516
  output_buffer = (unsigned char *)((void *)0);
#line 1516
  output_pointer = (unsigned char *)((void *)0);
  {
#line 1516
  new_channel_order = (unsigned char *)((void *)0);
#line 1517
  __cil_tmp10 = WavpackGetBytesPerSample(wpc);
#line 1517
  bps = __cil_tmp10;
  }
  {
#line 1517
  __cil_tmp12 = WavpackGetNumChannels(wpc);
#line 1517
  num_channels = __cil_tmp12;
#line 1518
  until_samples_total = *sample_count;
  }
#line 1518
  total_unpacked_samples = (int64_t )0;
#line 1519
  bytes_per_sample = bps * num_channels;
#line 1519
  result = 0;
#line 1520
  output_buffer_size = (uint32_t )0;
#line 1521
  progress = - 1.;
#line 1525
  if (md5_digest) {
    {
#line 1526
    MD5Init(& md5_context);
    }
  }
#line 1528
  if (outfile) {
#line 1529
    if (outbuf_k) {
#line 1530
      output_buffer_size = (uint32_t )(outbuf_k * 1024);
    } else {
#line 1532
      output_buffer_size = (uint32_t )262144;
    }
    {
#line 1534
    output_pointer = (unsigned char *)malloc((unsigned long )output_buffer_size);
    }
#line 1536
    if (! output_buffer) {
      {
#line 1537
      error_line("can\'t allocate buffer for decoding!");
#line 1538
      WavpackCloseFile(wpc);
      }
#line 1539
      return (2);
    }
  }
#line 1543
  if (qmode & 8) {
    {
#line 1544
    __cil_tmp24 = WavpackGetChannelLayout(wpc, (unsigned char *)((void *)0));
#line 1544
    layout = (int )__cil_tmp24;
    }
#line 1546
    if ((layout & 255) <= num_channels) {
      {
#line 1547
      new_channel_order = (unsigned char *)malloc((unsigned long )num_channels);
#line 1549
      i = 0;
      }
      {
#line 1549
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1549
        if (! (i < num_channels)) {
#line 1549
          goto while_break;
        }
#line 1550
        *(new_channel_order + i) = (unsigned char )i;
#line 1549
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1552
      WavpackGetChannelLayout(wpc, new_channel_order);
      }
    }
  }
  {
#line 1556
  temp_buffer = (int32_t *)malloc((unsigned long )(4096L * (long )num_channels) * sizeof(*(temp_buffer + 0)));
  }
  {
#line 1558
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1558
    if (! (result == 0)) {
#line 1558
      goto while_break___0;
    }
#line 1561
    if (output_buffer) {
#line 1562
      samples_to_unpack = (output_buffer_size - (uint32_t )(output_pointer - output_buffer)) / (unsigned int )bytes_per_sample;
#line 1564
      if ((long )samples_to_unpack > 4096L) {
#line 1565
        samples_to_unpack = (uint32_t )4096L;
      }
    } else {
#line 1568
      samples_to_unpack = (uint32_t )4096L;
    }
#line 1570
    if (until_samples_total) {
#line 1570
      if ((long )samples_to_unpack > until_samples_total - total_unpacked_samples) {
#line 1571
        samples_to_unpack = (uint32_t )(until_samples_total - total_unpacked_samples);
      }
    }
    {
#line 1573
    samples_unpacked = WavpackUnpackSamples(wpc, temp_buffer, samples_to_unpack);
#line 1574
    total_unpacked_samples += (long )samples_unpacked;
    }
#line 1576
    if (new_channel_order) {
      {
#line 1577
      unreorder_channels(temp_buffer, new_channel_order, num_channels, (int )samples_unpacked);
      }
    }
#line 1579
    if (output_buffer) {
#line 1580
      if (samples_unpacked) {
        {
#line 1581
        output_pointer = (unsigned char *)store_samples(output_pointer, temp_buffer,
                                                        qmode, bps, (int )(samples_unpacked * (unsigned int )num_channels));
        }
      }
#line 1583
      if ((output_pointer - output_buffer) - (long )output_buffer_size < (long )((uint32_t )bytes_per_sample)) {
        _L: /* CIL Label */ 
        {
#line 1584
        __cil_tmp32 = DoWriteFile(outfile, output_buffer, (uint32_t )(output_pointer - output_buffer),
                                  & bcount);
        }
#line 1584
        if (output_pointer - output_buffer != (long )bcount) {
          {
          {
#line 1586
          error_line("can\'t write .WAV data, disk probably full!\377\377");
          }
          {
#line 1587
          DoTruncateFile(outfile);
          }
#line 1588
          result = 2;
          }
#line 1589
          goto while_break___0;
        } else
#line 1584
        if (! __cil_tmp32) {
          {
          {
#line 1586
          error_line("can\'t write .WAV data, disk probably full!\377\377");
          }
          {
#line 1587
          DoTruncateFile(outfile);
          }
#line 1588
          result = 2;
          }
#line 1589
          goto while_break___0;
        }
#line 1592
        output_pointer = output_buffer;
      } else
#line 1583
      if (! samples_unpacked) {
#line 1583
        goto _L;
      }
    }
#line 1596
    if (md5_digest) {
#line 1596
      if (samples_unpacked) {
        {
#line 1597
        store_samples(temp_buffer, temp_buffer, qmode, bps, (int )(samples_unpacked * (unsigned int )num_channels));
#line 1598
        MD5Update(& md5_context, (unsigned char *)temp_buffer, ((unsigned int )bps * samples_unpacked) * (unsigned int )num_channels);
        }
      }
    }
#line 1601
    if (! samples_unpacked) {
#line 1602
      goto while_break___0;
    }
    {
#line 1604
    __cil_tmp33 = check_break();
    }
#line 1604
    if (__cil_tmp33) {
      {
#line 1608
      fprintf(stderr, "\n\205\030>dU");
#line 1610
      fflush(stderr);
#line 1611
      DoTruncateFile(outfile);
#line 1612
      result = 1;
      }
#line 1613
      goto while_break___0;
    }
    {
#line 1616
    __cil_tmp35 = WavpackGetProgress(wpc);
#line 1616
    __cil_tmp36 = floor(__cil_tmp35 * 100. + 0.5);
    }
    {
#line 1616
    __cil_tmp34 = WavpackGetProgress(wpc);
    }
#line 1616
    if (__cil_tmp34 != - 1.) {
#line 1616
      if (progress != __cil_tmp36) {
        {
#line 1618
        nobs = progress == - 1.;
#line 1620
        progress = WavpackGetProgress(wpc);
#line 1621
        display_progress(progress);
#line 1622
        progress = floor(progress * 100. + 0.5);
        }
#line 1624
        if (! quiet_mode) {
#line 1625
          if (nobs) {
#line 1625
            tmp = " ";
          } else {
#line 1625
            tmp = "\b\b\b\b\b\b\b\b\b\b\b\b";
          }
          {
#line 1625
          fprintf(stderr, "%s%3d%% done...", tmp, (int )progress);
#line 1627
          fflush(stderr);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1632
  if (new_channel_order) {
    {
#line 1633
    free(new_channel_order);
    }
  }
#line 1635
  if (md5_digest) {
    {
#line 1636
    MD5Final(md5_digest, & md5_context);
    }
  }
  {
#line 1638
  free(temp_buffer);
  }
#line 1640
  if (output_buffer) {
    {
#line 1641
    free(output_buffer);
    }
  }
#line 1643
  *sample_count = total_unpacked_samples;
#line 1644
  return (result);
}
}
#line 1647 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static unsigned char const   bit_reverse_table[256]  = 
#line 1647
  {      (unsigned char )0,      (unsigned char )128,      (unsigned char )64,      (unsigned char )192, 
        (unsigned char )32,      (unsigned char )160,      (unsigned char )96,      (unsigned char )224, 
        (unsigned char )16,      (unsigned char )144,      (unsigned char )80,      (unsigned char )208, 
        (unsigned char )48,      (unsigned char )176,      (unsigned char )112,      (unsigned char )240, 
        (unsigned char )8,      (unsigned char )136,      (unsigned char )72,      (unsigned char )200, 
        (unsigned char )40,      (unsigned char )168,      (unsigned char )104,      (unsigned char )232, 
        (unsigned char )24,      (unsigned char )152,      (unsigned char )88,      (unsigned char )216, 
        (unsigned char )56,      (unsigned char )184,      (unsigned char )120,      (unsigned char )248, 
        (unsigned char )4,      (unsigned char )132,      (unsigned char )68,      (unsigned char )196, 
        (unsigned char )36,      (unsigned char )164,      (unsigned char )100,      (unsigned char )228, 
        (unsigned char )20,      (unsigned char )148,      (unsigned char )84,      (unsigned char )212, 
        (unsigned char )52,      (unsigned char )180,      (unsigned char )116,      (unsigned char )244, 
        (unsigned char )12,      (unsigned char )140,      (unsigned char )76,      (unsigned char )204, 
        (unsigned char )44,      (unsigned char )172,      (unsigned char )108,      (unsigned char )236, 
        (unsigned char )28,      (unsigned char )156,      (unsigned char )92,      (unsigned char )220, 
        (unsigned char )60,      (unsigned char )188,      (unsigned char )124,      (unsigned char )252, 
        (unsigned char )2,      (unsigned char )130,      (unsigned char )66,      (unsigned char )194, 
        (unsigned char )34,      (unsigned char )162,      (unsigned char )98,      (unsigned char )226, 
        (unsigned char )18,      (unsigned char )146,      (unsigned char )82,      (unsigned char )210, 
        (unsigned char )50,      (unsigned char )178,      (unsigned char )114,      (unsigned char )242, 
        (unsigned char )10,      (unsigned char )138,      (unsigned char )74,      (unsigned char )202, 
        (unsigned char )42,      (unsigned char )170,      (unsigned char )106,      (unsigned char )234, 
        (unsigned char )26,      (unsigned char )154,      (unsigned char )90,      (unsigned char )218, 
        (unsigned char )58,      (unsigned char )186,      (unsigned char )122,      (unsigned char )250, 
        (unsigned char )6,      (unsigned char )134,      (unsigned char )70,      (unsigned char )198, 
        (unsigned char )38,      (unsigned char )166,      (unsigned char )102,      (unsigned char )230, 
        (unsigned char )22,      (unsigned char )150,      (unsigned char )86,      (unsigned char )214, 
        (unsigned char )54,      (unsigned char )182,      (unsigned char )118,      (unsigned char )246, 
        (unsigned char )14,      (unsigned char )142,      (unsigned char )78,      (unsigned char )206, 
        (unsigned char )46,      (unsigned char )174,      (unsigned char )110,      (unsigned char )238, 
        (unsigned char )30,      (unsigned char )158,      (unsigned char )94,      (unsigned char )222, 
        (unsigned char )62,      (unsigned char )190,      (unsigned char )126,      (unsigned char )254, 
        (unsigned char )1,      (unsigned char )129,      (unsigned char )65,      (unsigned char )193, 
        (unsigned char )33,      (unsigned char )161,      (unsigned char )97,      (unsigned char )225, 
        (unsigned char )17,      (unsigned char )145,      (unsigned char )81,      (unsigned char )209, 
        (unsigned char )49,      (unsigned char )177,      (unsigned char )113,      (unsigned char )241, 
        (unsigned char )9,      (unsigned char )137,      (unsigned char )73,      (unsigned char )201, 
        (unsigned char )41,      (unsigned char )169,      (unsigned char )105,      (unsigned char )233, 
        (unsigned char )25,      (unsigned char )153,      (unsigned char )89,      (unsigned char )217, 
        (unsigned char )57,      (unsigned char )185,      (unsigned char )121,      (unsigned char )249, 
        (unsigned char )5,      (unsigned char )133,      (unsigned char )69,      (unsigned char )197, 
        (unsigned char )37,      (unsigned char )165,      (unsigned char )101,      (unsigned char )229, 
        (unsigned char )21,      (unsigned char )149,      (unsigned char )85,      (unsigned char )213, 
        (unsigned char )53,      (unsigned char )181,      (unsigned char )117,      (unsigned char )245, 
        (unsigned char )13,      (unsigned char )141,      (unsigned char )77,      (unsigned char )205, 
        (unsigned char )45,      (unsigned char )173,      (unsigned char )109,      (unsigned char )237, 
        (unsigned char )29,      (unsigned char )157,      (unsigned char )93,      (unsigned char )221, 
        (unsigned char )61,      (unsigned char )189,      (unsigned char )125,      (unsigned char )253, 
        (unsigned char )3,      (unsigned char )131,      (unsigned char )67,      (unsigned char )195, 
        (unsigned char )35,      (unsigned char )163,      (unsigned char )99,      (unsigned char )227, 
        (unsigned char )19,      (unsigned char )147,      (unsigned char )83,      (unsigned char )211, 
        (unsigned char )51,      (unsigned char )179,      (unsigned char )115,      (unsigned char )243, 
        (unsigned char )11,      (unsigned char )139,      (unsigned char )75,      (unsigned char )203, 
        (unsigned char )43,      (unsigned char )171,      (unsigned char )107,      (unsigned char )235, 
        (unsigned char )27,      (unsigned char )155,      (unsigned char )91,      (unsigned char )219, 
        (unsigned char )59,      (unsigned char )187,      (unsigned char )123,      (unsigned char )251, 
        (unsigned char )7,      (unsigned char )135,      (unsigned char )71,      (unsigned char )199, 
        (unsigned char )39,      (unsigned char )167,      (unsigned char )103,      (unsigned char )231, 
        (unsigned char )23,      (unsigned char )151,      (unsigned char )87,      (unsigned char )215, 
        (unsigned char )55,      (unsigned char )183,      (unsigned char )119,      (unsigned char )247, 
        (unsigned char )15,      (unsigned char )143,      (unsigned char )79,      (unsigned char )207, 
        (unsigned char )47,      (unsigned char )175,      (unsigned char )111,      (unsigned char )239, 
        (unsigned char )31,      (unsigned char )159,      (unsigned char )95,      (unsigned char )223, 
        (unsigned char )63,      (unsigned char )191,      (unsigned char )127,      (unsigned char )255};
#line 1668 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static int unpack_dsd_audio(WavpackContext *wpc , FILE *outfile , int qmode , unsigned char *md5_digest ,
                            int64_t *sample_count ) 
{ 
  unsigned char *output_buffer ;
  unsigned char *new_channel_order ;
  int num_channels ;
  int __cil_tmp9 ;
  int result ;
  int64_t until_samples_total ;
  int64_t total_unpacked_samples ;
  uint32_t output_buffer_size ;
  uint32_t bcount ;
  double progress ;
  int32_t *temp_buffer ;
  MD5_CTX md5_context ;
  void *__cil_tmp18 ;
  int layout ;
  uint32_t __cil_tmp20 ;
  int i ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  uint32_t samples_to_unpack ;
  uint32_t samples_unpacked ;
  uint32_t __cil_tmp26 ;
  unsigned char *dptr ;
  int32_t *sptr ;
  int cc ;
  int __cil_tmp30 ;
  uint32_t si ;
  unsigned char *__cil_tmp32 ;
  int tmp ;
  unsigned char *__cil_tmp34 ;
  uint32_t __cil_tmp35 ;
  int scount ;
  int __cil_tmp37 ;
  unsigned char *__cil_tmp38 ;
  int32_t *__cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  double __cil_tmp42 ;
  double __cil_tmp43 ;
  double __cil_tmp44 ;
  int nobs ;
  double __cil_tmp46 ;
  double __cil_tmp47 ;
  char const   *tmp___0 ;

  {
#line 1670
  output_buffer = (unsigned char *)((void *)0);
  {
#line 1670
  new_channel_order = (unsigned char *)((void *)0);
#line 1671
  __cil_tmp9 = WavpackGetNumChannels(wpc);
#line 1671
  num_channels = __cil_tmp9;
  }
#line 1671
  result = 0;
#line 1672
  until_samples_total = *sample_count;
#line 1672
  total_unpacked_samples = (int64_t )0;
#line 1673
  output_buffer_size = (uint32_t )0;
#line 1674
  progress = - 1.;
#line 1678
  if (md5_digest) {
    {
#line 1679
    MD5Init(& md5_context);
    }
  }
  {
#line 1681
  output_buffer_size = (uint32_t )(4096 * num_channels);
#line 1682
  output_buffer = (unsigned char *)malloc((unsigned long )output_buffer_size);
  }
#line 1684
  if (! output_buffer) {
    {
#line 1685
    error_line("can\'t allocate buffer for decoding!>dU");
#line 1686
    WavpackCloseFile(wpc);
    }
#line 1687
    return (2);
  }
#line 1690
  if (qmode & 8) {
    {
#line 1691
    __cil_tmp20 = WavpackGetChannelLayout(wpc, (unsigned char *)((void *)0));
#line 1691
    layout = (int )__cil_tmp20;
    }
#line 1693
    if ((layout & 255) <= num_channels) {
      {
#line 1694
      new_channel_order = (unsigned char *)malloc((unsigned long )num_channels);
#line 1696
      i = 0;
      }
      {
#line 1696
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1696
        if (! (i < num_channels)) {
#line 1696
          goto while_break;
        }
#line 1697
        *(new_channel_order + i) = (unsigned char )i;
#line 1696
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1699
      WavpackGetChannelLayout(wpc, new_channel_order);
      }
    }
  }
  {
#line 1703
  temp_buffer = (int32_t *)malloc((unsigned long )(4096 * num_channels) * sizeof(*(temp_buffer + 0)));
  }
  {
#line 1705
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1705
    if (! (result == 0)) {
#line 1705
      goto while_break___0;
    }
#line 1706
    samples_to_unpack = (uint32_t )4096;
#line 1708
    if (until_samples_total) {
#line 1708
      if ((long )samples_to_unpack > until_samples_total - total_unpacked_samples) {
#line 1709
        samples_to_unpack = (uint32_t )(until_samples_total - total_unpacked_samples);
      }
    }
    {
#line 1711
    samples_unpacked = WavpackUnpackSamples(wpc, temp_buffer, samples_to_unpack);
#line 1712
    total_unpacked_samples += (long )samples_unpacked;
    }
#line 1714
    if (new_channel_order) {
      {
#line 1715
      unreorder_channels(temp_buffer, new_channel_order, num_channels, (int )samples_unpacked);
      }
    }
#line 1717
    if (samples_unpacked) {
#line 1718
      dptr = output_buffer;
#line 1719
      sptr = temp_buffer;
#line 1721
      if (qmode & 64) {
#line 1722
        cc = num_channels;
        {
#line 1724
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1724
          __cil_tmp30 = cc;
#line 1724
          cc --;
#line 1724
          if (! __cil_tmp30) {
#line 1724
            goto while_break___1;
          }
#line 1727
          si = (uint32_t )0;
          {
#line 1727
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1727
            if (! (si < 4096U)) {
#line 1727
              goto while_break___2;
            }
#line 1728
            if (si < samples_unpacked) {
#line 1729
              if (qmode & 16) {
#line 1729
                tmp = (int )bit_reverse_table[*sptr & 255];
              } else {
#line 1729
                tmp = *sptr;
              }
#line 1729
              __cil_tmp32 = dptr;
#line 1729
              dptr ++;
#line 1729
              *__cil_tmp32 = (unsigned char )tmp;
            } else {
#line 1731
              __cil_tmp34 = dptr;
#line 1731
              dptr ++;
#line 1731
              *__cil_tmp34 = (unsigned char )0;
            }
#line 1727
            sptr += num_channels;
#line 1727
            __cil_tmp35 = si;
#line 1727
            si ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1733
          sptr -= 4096 * num_channels - 1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1736
        samples_unpacked = (uint32_t )4096;
      } else {
#line 1739
        scount = (int )(samples_unpacked * (unsigned int )num_channels);
        {
#line 1741
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1741
          __cil_tmp37 = scount;
#line 1741
          scount --;
#line 1741
          if (! __cil_tmp37) {
#line 1741
            goto while_break___3;
          }
#line 1742
          __cil_tmp39 = sptr;
#line 1742
          sptr ++;
#line 1742
          __cil_tmp38 = dptr;
#line 1742
          dptr ++;
#line 1742
          *__cil_tmp38 = (unsigned char )*__cil_tmp39;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1745
      if (md5_digest) {
        {
#line 1746
        MD5Update(& md5_context, output_buffer, samples_unpacked * (unsigned int )num_channels);
        }
      }
      {
#line 1748
      __cil_tmp40 = DoWriteFile(outfile, output_buffer, samples_unpacked * (unsigned int )num_channels,
                                & bcount);
      }
#line 1748
      if (outfile) {
#line 1748
        if (! __cil_tmp40) {
          {
          {
#line 1750
          error_line("can\'t write .WAV data, disk probably full!");
          }
          {
#line 1751
          DoTruncateFile(outfile);
          }
#line 1752
          result = 2;
          }
#line 1753
          goto while_break___0;
        } else
#line 1748
        if (bcount != samples_unpacked * (unsigned int )num_channels) {
          {
          {
#line 1750
          error_line("can\'t write .WAV data, disk probably full!");
          }
          {
#line 1751
          DoTruncateFile(outfile);
          }
#line 1752
          result = 2;
          }
#line 1753
          goto while_break___0;
        }
      }
    } else {
#line 1757
      goto while_break___0;
    }
    {
#line 1759
    __cil_tmp41 = check_break();
    }
#line 1759
    if (__cil_tmp41) {
      {
#line 1763
      fprintf(stderr, "\n(\031>dU");
#line 1765
      fflush(stderr);
#line 1766
      DoTruncateFile(outfile);
#line 1767
      result = 1;
      }
#line 1768
      goto while_break___0;
    }
    {
#line 1771
    __cil_tmp43 = WavpackGetProgress(wpc);
#line 1771
    __cil_tmp44 = floor(__cil_tmp43 * 100. + 0.5);
    }
    {
#line 1771
    __cil_tmp42 = WavpackGetProgress(wpc);
    }
#line 1771
    if (__cil_tmp42 != - 1.) {
#line 1771
      if (progress != __cil_tmp44) {
        {
#line 1773
        nobs = progress == - 1.;
#line 1775
        progress = WavpackGetProgress(wpc);
#line 1776
        display_progress(progress);
#line 1777
        progress = floor(progress * 100. + 0.5);
        }
#line 1779
        if (! quiet_mode) {
#line 1780
          if (nobs) {
#line 1780
            tmp___0 = " \234\027>dU";
          } else {
#line 1780
            tmp___0 = "\b\b\b\b\b\b\b\b\b\b\b\bdU";
          }
          {
#line 1780
          fprintf(stderr, "%s%3d%% done...", tmp___0, (int )progress);
#line 1782
          fflush(stderr);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1787
  if (new_channel_order) {
    {
#line 1788
    free(new_channel_order);
    }
  }
#line 1790
  if (md5_digest) {
    {
#line 1791
    MD5Final(md5_digest, & md5_context);
    }
  }
  {
#line 1793
  free(temp_buffer);
  }
#line 1795
  if (output_buffer) {
    {
#line 1796
    free(output_buffer);
    }
  }
#line 1798
  *sample_count = total_unpacked_samples;
#line 1799
  return (result);
}
}
#line 1802 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void add_tag_extraction_to_list(char *spec ) 
{ 
  void *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 1804
  tag_extractions = (char **)realloc(tag_extractions, (unsigned long )(num_tag_extractions + 1) * sizeof(*tag_extractions));
#line 1805
  __cil_tmp3 = strlen((char const   *)spec);
#line 1805
  __cil_tmp4 = malloc(__cil_tmp3 + 10UL);
#line 1805
  *(tag_extractions + num_tag_extractions) = __cil_tmp4;
#line 1806
  strcpy(*(tag_extractions + num_tag_extractions), (char const   *)spec);
#line 1807
  num_tag_extractions ++;
  }
  return;
}
}
#line 1810 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static int do_tag_extractions(WavpackContext *wpc , char *outfilename ) 
{ 
  int result ;
  int i ;
  FILE *outfile ;
  char *extraction_spec ;
  char *__cil_tmp7 ;
  char *output_spec ;
  char *__cil_tmp9 ;
  char tag_filename[256] ;
  unsigned long __cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;
  int max_length ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  char *full_filename ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  char *dst ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  FILE *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  char *__cil_tmp41 ;
  char *tmp ;
  char __cil_tmp43 ;
  FILE *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  char *__cil_tmp46 ;
  char *tmp___0 ;
  int __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  char *__cil_tmp50 ;
  char *tmp___1 ;
  unsigned long __cil_tmp52 ;
  char *__cil_tmp53 ;
  char *tmp___2 ;

  {
#line 1812
  result = 0;
#line 1815
  i = 0;
  {
#line 1815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1815
    if (! (result == 0 && i < num_tag_extractions)) {
#line 1815
      goto while_break;
    }
    {
#line 1816
    __cil_tmp7 = strdup((char const   *)*(tag_extractions + i));
#line 1816
    extraction_spec = __cil_tmp7;
#line 1817
    __cil_tmp9 = strchr((char const   *)extraction_spec, '=');
#line 1817
    output_spec = __cil_tmp9;
#line 1820
    __cil_tmp11 = strlen((char const   *)output_spec);
    }
#line 1820
    if (output_spec) {
#line 1820
      if (output_spec > extraction_spec) {
#line 1820
        if (__cil_tmp11 > 1UL) {
#line 1821
          __cil_tmp12 = output_spec;
#line 1821
          output_spec ++;
#line 1821
          *__cil_tmp12 = (char )0;
        }
      }
    }
    {
#line 1823
    __cil_tmp13 = dump_tag_item_to_file(wpc, (char const   *)extraction_spec, (FILE *)((void *)0),
                                        (char *)tag_filename);
    }
#line 1823
    if (__cil_tmp13) {
      {
#line 1824
      __cil_tmp16 = strlen((char const   *)((char *)tag_filename));
      }
      {
#line 1824
      __cil_tmp15 = strlen((char const   *)outfilename);
#line 1824
      max_length = ((int )__cil_tmp15 + (int )__cil_tmp16) + 10;
      }
#line 1827
      if (output_spec) {
        {
#line 1828
        __cil_tmp18 = strlen((char const   *)output_spec);
        }
#line 1828
        max_length += (int )__cil_tmp18 + 256;
      }
      {
#line 1830
      full_filename = (char *)malloc((unsigned long )(max_length * 2 + 1));
#line 1831
      strcpy(full_filename, (char const   *)outfilename);
      }
#line 1833
      if (output_spec) {
        {
#line 1834
        __cil_tmp21 = filespec_name(full_filename);
#line 1834
        dst = __cil_tmp21;
        }
        {
#line 1836
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1836
          if (! (dst - full_filename < (long )max_length && (int )*output_spec)) {
#line 1836
            goto while_break___0;
          }
#line 1837
          if ((int )*output_spec == 37) {
#line 1838
            output_spec ++;
            {
#line 1839
            if ((int )*output_spec == 'a') {
#line 1839
              goto case_97;
            }
#line 1850
            if ((int )*output_spec == 't') {
#line 1850
              goto case_116;
            }
#line 1861
            if ((int )*output_spec == 'e') {
#line 1861
              goto case_101;
            }
#line 1870
            goto switch_default;
            case_97: /* CIL Label */ 
            {
#line 1840
            __cil_tmp22 = filespec_name(outfilename);
#line 1840
            strcpy(dst, (char const   *)__cil_tmp22);
            }
            {
#line 1842
            __cil_tmp23 = filespec_ext(dst);
            }
#line 1842
            if (__cil_tmp23) {
              {
#line 1843
              dst = filespec_ext(dst);
              }
            } else {
              {
#line 1845
              __cil_tmp25 = strlen((char const   *)dst);
              }
#line 1845
              dst += __cil_tmp25;
            }
#line 1847
            output_spec ++;
#line 1848
            goto switch_break;
            case_116: /* CIL Label */ 
            {
#line 1851
            strcpy(dst, (char const   *)((char *)tag_filename));
            }
            {
#line 1853
            __cil_tmp27 = filespec_ext(dst);
            }
#line 1853
            if (__cil_tmp27) {
              {
#line 1854
              dst = filespec_ext(dst);
              }
            } else {
              {
#line 1856
              __cil_tmp29 = strlen((char const   *)dst);
              }
#line 1856
              dst += __cil_tmp29;
            }
#line 1858
            output_spec ++;
#line 1859
            goto switch_break;
            case_101: /* CIL Label */ 
            {
#line 1862
            __cil_tmp31 = filespec_ext((char *)tag_filename);
            }
#line 1862
            if (__cil_tmp31) {
              {
#line 1863
              __cil_tmp32 = filespec_ext((char *)tag_filename);
#line 1863
              strcpy(dst, (char const   *)(__cil_tmp32 + 1));
#line 1864
              __cil_tmp33 = strlen((char const   *)dst);
              }
#line 1864
              dst += __cil_tmp33;
            }
#line 1867
            output_spec ++;
#line 1868
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 1871
            __cil_tmp35 = dst;
#line 1871
            dst ++;
#line 1871
            *__cil_tmp35 = (char )'%';
            switch_break: /* CIL Label */ ;
            }
          } else {
#line 1875
            __cil_tmp37 = output_spec;
#line 1875
            output_spec ++;
#line 1875
            __cil_tmp36 = dst;
#line 1875
            dst ++;
#line 1875
            *__cil_tmp36 = *__cil_tmp37;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1878
        *dst = (char )0;
      } else {
        {
#line 1881
        __cil_tmp38 = filespec_name(full_filename);
#line 1881
        strcpy(__cil_tmp38, (char const   *)((char *)tag_filename));
        }
      }
      {
#line 1883
      outfile = fopen((char const   *)full_filename, "r(\031>dU");
      }
#line 1883
      if (outfile != (void *)0) {
#line 1883
        if (! overwrite_all) {
          {
#line 1884
          DoCloseHandle(outfile);
#line 1885
          __cil_tmp40 = strlen((char const   *)full_filename);
          }
#line 1885
          if (__cil_tmp40 > 30UL) {
            {
#line 1885
            __cil_tmp41 = filespec_name(full_filename);
#line 1885
            tmp = __cil_tmp41;
            }
          } else {
#line 1885
            tmp = full_filename;
          }
          {
#line 1885
          fprintf(stderr, "overwrite %s (yes/no/all)? >dU", tmp);
#line 1886
          fflush(stderr);
          }
#line 1888
          if (set_console_title) {
            {
#line 1889
            DoSetConsoleTitle("overwrite?");
            }
          }
          {
#line 1891
          __cil_tmp43 = yna();
          }
          {
#line 1893
          if ((int )__cil_tmp43 == 'n') {
#line 1893
            goto case_110;
          }
#line 1897
          if ((int )__cil_tmp43 == 'a') {
#line 1897
            goto case_97___0;
          }
#line 1891
          goto switch_break___0;
          case_110: /* CIL Label */ 
#line 1894
          *full_filename = (char )0;
#line 1895
          goto switch_break___0;
          case_97___0: /* CIL Label */ 
#line 1898
          overwrite_all = 1;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
#line 1904
      if (*full_filename) {
        {
#line 1905
        outfile = fopen((char const   *)full_filename, "w");
        }
#line 1905
        if (outfile == (void *)0) {
          {
#line 1906
          __cil_tmp45 = strlen((char const   *)full_filename);
          }
#line 1906
          if (__cil_tmp45 > 30UL) {
            {
#line 1906
            __cil_tmp46 = filespec_name(full_filename);
#line 1906
            tmp___0 = __cil_tmp46;
            }
          } else {
#line 1906
            tmp___0 = full_filename;
          }
          {
#line 1906
          error_line("can\'t create file %s!U", tmp___0);
#line 1907
          result = 1;
          }
        } else {
          {
#line 1910
          dump_tag_item_to_file(wpc, (char const   *)extraction_spec, outfile, (char *)((void *)0));
#line 1912
          __cil_tmp48 = DoCloseHandle(outfile);
          }
#line 1912
          if (! __cil_tmp48) {
            {
#line 1913
            __cil_tmp49 = strlen((char const   *)full_filename);
            }
#line 1913
            if (__cil_tmp49 > 30UL) {
              {
#line 1913
              __cil_tmp50 = filespec_name(full_filename);
#line 1913
              tmp___1 = __cil_tmp50;
              }
            } else {
#line 1913
              tmp___1 = full_filename;
            }
            {
#line 1913
            error_line("can\'t close file %s!dU", tmp___1);
#line 1914
            result = 1;
            }
          } else
#line 1916
          if (! quiet_mode) {
            {
#line 1917
            __cil_tmp52 = strlen((char const   *)full_filename);
            }
#line 1917
            if (__cil_tmp52 > 30UL) {
              {
#line 1917
              __cil_tmp53 = filespec_name(full_filename);
#line 1917
              tmp___2 = __cil_tmp53;
              }
            } else {
#line 1917
              tmp___2 = full_filename;
            }
            {
#line 1917
            error_line("extracted tag \"%s\" to file %sU", extraction_spec, tmp___2);
            }
          }
        }
      }
      {
#line 1921
      free(full_filename);
      }
    }
    {
#line 1924
    free(extraction_spec);
    }
#line 1815
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1927
  return (result);
}
}
#line 1936
static void *store_little_endian_unsigned_samples(void *dst , int32_t *src , int bps ,
                                                  int count ) ;
#line 1937
static void *store_little_endian_signed_samples(void *dst , int32_t *src , int bps ,
                                                int count ) ;
#line 1938
static void *store_big_endian_unsigned_samples(void *dst , int32_t *src , int bps ,
                                               int count ) ;
#line 1939
static void *store_big_endian_signed_samples(void *dst , int32_t *src , int bps ,
                                             int count ) ;
#line 1941 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void *store_samples(void *dst , int32_t *src , int qmode , int bps , int count ) 
{ 
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 1943
  if (qmode & 1) {
#line 1944
    if (qmode & 4) {
      {
      {
#line 1945
      __cil_tmp6 = store_big_endian_unsigned_samples(dst, src, bps, count);
      }
      }
#line 1945
      return (__cil_tmp6);
    } else
#line 1944
    if (bps == 1) {
#line 1944
      if (! (qmode & 2)) {
        {
        {
#line 1945
        __cil_tmp6 = store_big_endian_unsigned_samples(dst, src, bps, count);
        }
        }
#line 1945
        return (__cil_tmp6);
      } else {
        {
        {
#line 1947
        __cil_tmp7 = store_big_endian_signed_samples(dst, src, bps, count);
        }
        }
#line 1947
        return (__cil_tmp7);
      }
    } else {
      {
      {
#line 1947
      __cil_tmp7 = store_big_endian_signed_samples(dst, src, bps, count);
      }
      }
#line 1947
      return (__cil_tmp7);
    }
  } else
#line 1949
  if (qmode & 4) {
    {
    {
#line 1950
    __cil_tmp8 = store_little_endian_unsigned_samples(dst, src, bps, count);
    }
    }
#line 1950
    return (__cil_tmp8);
  } else
#line 1949
  if (bps == 1) {
#line 1949
    if (! (qmode & 2)) {
      {
      {
#line 1950
      __cil_tmp8 = store_little_endian_unsigned_samples(dst, src, bps, count);
      }
      }
#line 1950
      return (__cil_tmp8);
    } else {
      {
      {
#line 1952
      __cil_tmp9 = store_little_endian_signed_samples(dst, src, bps, count);
      }
      }
#line 1952
      return (__cil_tmp9);
    }
  } else {
    {
    {
#line 1952
    __cil_tmp9 = store_little_endian_signed_samples(dst, src, bps, count);
    }
    }
#line 1952
    return (__cil_tmp9);
  }
}
}
#line 1955 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void *store_little_endian_unsigned_samples(void *dst , int32_t *src , int bps ,
                                                  int count ) 
{ 
  unsigned char *dptr ;
  int32_t temp ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int32_t *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int32_t *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int32_t *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;

  {
#line 1957
  dptr = dst;
  {
#line 1962
  if (bps == 1) {
#line 1962
    goto case_1;
  }
#line 1968
  if (bps == 2) {
#line 1968
    goto case_2;
  }
#line 1976
  if (bps == 3) {
#line 1976
    goto case_3;
  }
#line 1985
  if (bps == 4) {
#line 1985
    goto case_4;
  }
#line 1960
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1963
    __cil_tmp7 = count;
#line 1963
    count --;
#line 1963
    if (! __cil_tmp7) {
#line 1963
      goto while_break;
    }
#line 1964
    __cil_tmp9 = src;
#line 1964
    src ++;
#line 1964
    __cil_tmp8 = dptr;
#line 1964
    dptr ++;
#line 1964
    *__cil_tmp8 = (unsigned char )(*__cil_tmp9 + 128);
  }
  while_break: /* CIL Label */ ;
  }
#line 1966
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1969
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1969
    __cil_tmp10 = count;
#line 1969
    count --;
#line 1969
    if (! __cil_tmp10) {
#line 1969
      goto while_break___0;
    }
#line 1970
    __cil_tmp12 = src;
#line 1970
    src ++;
#line 1970
    temp = *__cil_tmp12 + 32768;
#line 1970
    __cil_tmp11 = dptr;
#line 1970
    dptr ++;
#line 1970
    *__cil_tmp11 = (unsigned char )temp;
#line 1971
    __cil_tmp13 = dptr;
#line 1971
    dptr ++;
#line 1971
    *__cil_tmp13 = (unsigned char )(temp >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1974
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1977
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1977
    __cil_tmp14 = count;
#line 1977
    count --;
#line 1977
    if (! __cil_tmp14) {
#line 1977
      goto while_break___1;
    }
#line 1978
    __cil_tmp16 = src;
#line 1978
    src ++;
#line 1978
    temp = *__cil_tmp16 + 8388608;
#line 1978
    __cil_tmp15 = dptr;
#line 1978
    dptr ++;
#line 1978
    *__cil_tmp15 = (unsigned char )temp;
#line 1979
    __cil_tmp17 = dptr;
#line 1979
    dptr ++;
#line 1979
    *__cil_tmp17 = (unsigned char )(temp >> 8);
#line 1980
    __cil_tmp18 = dptr;
#line 1980
    dptr ++;
#line 1980
    *__cil_tmp18 = (unsigned char )(temp >> 16);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1983
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1986
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1986
    __cil_tmp19 = count;
#line 1986
    count --;
#line 1986
    if (! __cil_tmp19) {
#line 1986
      goto while_break___2;
    }
#line 1987
    __cil_tmp21 = src;
#line 1987
    src ++;
#line 1987
    temp = (int32_t )((unsigned int )*__cil_tmp21 + 2147483648U);
#line 1987
    __cil_tmp20 = dptr;
#line 1987
    dptr ++;
#line 1987
    *__cil_tmp20 = (unsigned char )temp;
#line 1988
    __cil_tmp22 = dptr;
#line 1988
    dptr ++;
#line 1988
    *__cil_tmp22 = (unsigned char )(temp >> 8);
#line 1989
    __cil_tmp23 = dptr;
#line 1989
    dptr ++;
#line 1989
    *__cil_tmp23 = (unsigned char )(temp >> 16);
#line 1990
    __cil_tmp24 = dptr;
#line 1990
    dptr ++;
#line 1990
    *__cil_tmp24 = (unsigned char )(temp >> 24);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1993
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1996
  return (dptr);
}
}
#line 1999 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void *store_little_endian_signed_samples(void *dst , int32_t *src , int bps ,
                                                int count ) 
{ 
  unsigned char *dptr ;
  int32_t temp ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int32_t *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int32_t *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int32_t *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;

  {
#line 2001
  dptr = dst;
  {
#line 2006
  if (bps == 1) {
#line 2006
    goto case_1;
  }
#line 2012
  if (bps == 2) {
#line 2012
    goto case_2;
  }
#line 2020
  if (bps == 3) {
#line 2020
    goto case_3;
  }
#line 2029
  if (bps == 4) {
#line 2029
    goto case_4;
  }
#line 2004
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2007
    __cil_tmp7 = count;
#line 2007
    count --;
#line 2007
    if (! __cil_tmp7) {
#line 2007
      goto while_break;
    }
#line 2008
    __cil_tmp9 = src;
#line 2008
    src ++;
#line 2008
    __cil_tmp8 = dptr;
#line 2008
    dptr ++;
#line 2008
    *__cil_tmp8 = (unsigned char )*__cil_tmp9;
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2013
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2013
    __cil_tmp10 = count;
#line 2013
    count --;
#line 2013
    if (! __cil_tmp10) {
#line 2013
      goto while_break___0;
    }
#line 2014
    __cil_tmp12 = src;
#line 2014
    src ++;
#line 2014
    temp = *__cil_tmp12;
#line 2014
    __cil_tmp11 = dptr;
#line 2014
    dptr ++;
#line 2014
    *__cil_tmp11 = (unsigned char )temp;
#line 2015
    __cil_tmp13 = dptr;
#line 2015
    dptr ++;
#line 2015
    *__cil_tmp13 = (unsigned char )(temp >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2018
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2021
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2021
    __cil_tmp14 = count;
#line 2021
    count --;
#line 2021
    if (! __cil_tmp14) {
#line 2021
      goto while_break___1;
    }
#line 2022
    __cil_tmp16 = src;
#line 2022
    src ++;
#line 2022
    temp = *__cil_tmp16;
#line 2022
    __cil_tmp15 = dptr;
#line 2022
    dptr ++;
#line 2022
    *__cil_tmp15 = (unsigned char )temp;
#line 2023
    __cil_tmp17 = dptr;
#line 2023
    dptr ++;
#line 2023
    *__cil_tmp17 = (unsigned char )(temp >> 8);
#line 2024
    __cil_tmp18 = dptr;
#line 2024
    dptr ++;
#line 2024
    *__cil_tmp18 = (unsigned char )(temp >> 16);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2027
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2030
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2030
    __cil_tmp19 = count;
#line 2030
    count --;
#line 2030
    if (! __cil_tmp19) {
#line 2030
      goto while_break___2;
    }
#line 2031
    __cil_tmp21 = src;
#line 2031
    src ++;
#line 2031
    temp = *__cil_tmp21;
#line 2031
    __cil_tmp20 = dptr;
#line 2031
    dptr ++;
#line 2031
    *__cil_tmp20 = (unsigned char )temp;
#line 2032
    __cil_tmp22 = dptr;
#line 2032
    dptr ++;
#line 2032
    *__cil_tmp22 = (unsigned char )(temp >> 8);
#line 2033
    __cil_tmp23 = dptr;
#line 2033
    dptr ++;
#line 2033
    *__cil_tmp23 = (unsigned char )(temp >> 16);
#line 2034
    __cil_tmp24 = dptr;
#line 2034
    dptr ++;
#line 2034
    *__cil_tmp24 = (unsigned char )(temp >> 24);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2037
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2040
  return (dptr);
}
}
#line 2043 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void *store_big_endian_unsigned_samples(void *dst , int32_t *src , int bps ,
                                               int count ) 
{ 
  unsigned char *dptr ;
  int32_t temp ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int32_t *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int32_t *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int32_t *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;

  {
#line 2045
  dptr = dst;
  {
#line 2050
  if (bps == 1) {
#line 2050
    goto case_1;
  }
#line 2056
  if (bps == 2) {
#line 2056
    goto case_2;
  }
#line 2064
  if (bps == 3) {
#line 2064
    goto case_3;
  }
#line 2073
  if (bps == 4) {
#line 2073
    goto case_4;
  }
#line 2048
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2051
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2051
    __cil_tmp7 = count;
#line 2051
    count --;
#line 2051
    if (! __cil_tmp7) {
#line 2051
      goto while_break;
    }
#line 2052
    __cil_tmp9 = src;
#line 2052
    src ++;
#line 2052
    __cil_tmp8 = dptr;
#line 2052
    dptr ++;
#line 2052
    *__cil_tmp8 = (unsigned char )(*__cil_tmp9 + 128);
  }
  while_break: /* CIL Label */ ;
  }
#line 2054
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2057
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2057
    __cil_tmp10 = count;
#line 2057
    count --;
#line 2057
    if (! __cil_tmp10) {
#line 2057
      goto while_break___0;
    }
#line 2058
    __cil_tmp12 = src;
#line 2058
    src ++;
#line 2058
    temp = *__cil_tmp12 + 32768;
#line 2058
    __cil_tmp11 = dptr;
#line 2058
    dptr ++;
#line 2058
    *__cil_tmp11 = (unsigned char )(temp >> 8);
#line 2059
    __cil_tmp13 = dptr;
#line 2059
    dptr ++;
#line 2059
    *__cil_tmp13 = (unsigned char )temp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2062
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2065
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2065
    __cil_tmp14 = count;
#line 2065
    count --;
#line 2065
    if (! __cil_tmp14) {
#line 2065
      goto while_break___1;
    }
#line 2066
    __cil_tmp16 = src;
#line 2066
    src ++;
#line 2066
    temp = *__cil_tmp16 + 8388608;
#line 2066
    __cil_tmp15 = dptr;
#line 2066
    dptr ++;
#line 2066
    *__cil_tmp15 = (unsigned char )(temp >> 16);
#line 2067
    __cil_tmp17 = dptr;
#line 2067
    dptr ++;
#line 2067
    *__cil_tmp17 = (unsigned char )(temp >> 8);
#line 2068
    __cil_tmp18 = dptr;
#line 2068
    dptr ++;
#line 2068
    *__cil_tmp18 = (unsigned char )temp;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2071
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2074
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2074
    __cil_tmp19 = count;
#line 2074
    count --;
#line 2074
    if (! __cil_tmp19) {
#line 2074
      goto while_break___2;
    }
#line 2075
    __cil_tmp21 = src;
#line 2075
    src ++;
#line 2075
    temp = (int32_t )((unsigned int )*__cil_tmp21 + 2147483648U);
#line 2075
    __cil_tmp20 = dptr;
#line 2075
    dptr ++;
#line 2075
    *__cil_tmp20 = (unsigned char )(temp >> 24);
#line 2076
    __cil_tmp22 = dptr;
#line 2076
    dptr ++;
#line 2076
    *__cil_tmp22 = (unsigned char )(temp >> 16);
#line 2077
    __cil_tmp23 = dptr;
#line 2077
    dptr ++;
#line 2077
    *__cil_tmp23 = (unsigned char )(temp >> 8);
#line 2078
    __cil_tmp24 = dptr;
#line 2078
    dptr ++;
#line 2078
    *__cil_tmp24 = (unsigned char )temp;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2081
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2084
  return (dptr);
}
}
#line 2087 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void *store_big_endian_signed_samples(void *dst , int32_t *src , int bps ,
                                             int count ) 
{ 
  unsigned char *dptr ;
  int32_t temp ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int32_t *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int32_t *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int32_t *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;

  {
#line 2089
  dptr = dst;
  {
#line 2094
  if (bps == 1) {
#line 2094
    goto case_1;
  }
#line 2100
  if (bps == 2) {
#line 2100
    goto case_2;
  }
#line 2108
  if (bps == 3) {
#line 2108
    goto case_3;
  }
#line 2117
  if (bps == 4) {
#line 2117
    goto case_4;
  }
#line 2092
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2095
    __cil_tmp7 = count;
#line 2095
    count --;
#line 2095
    if (! __cil_tmp7) {
#line 2095
      goto while_break;
    }
#line 2096
    __cil_tmp9 = src;
#line 2096
    src ++;
#line 2096
    __cil_tmp8 = dptr;
#line 2096
    dptr ++;
#line 2096
    *__cil_tmp8 = (unsigned char )*__cil_tmp9;
  }
  while_break: /* CIL Label */ ;
  }
#line 2098
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2101
    __cil_tmp10 = count;
#line 2101
    count --;
#line 2101
    if (! __cil_tmp10) {
#line 2101
      goto while_break___0;
    }
#line 2102
    __cil_tmp12 = src;
#line 2102
    src ++;
#line 2102
    temp = *__cil_tmp12;
#line 2102
    __cil_tmp11 = dptr;
#line 2102
    dptr ++;
#line 2102
    *__cil_tmp11 = (unsigned char )(temp >> 8);
#line 2103
    __cil_tmp13 = dptr;
#line 2103
    dptr ++;
#line 2103
    *__cil_tmp13 = (unsigned char )temp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2106
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2109
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2109
    __cil_tmp14 = count;
#line 2109
    count --;
#line 2109
    if (! __cil_tmp14) {
#line 2109
      goto while_break___1;
    }
#line 2110
    __cil_tmp16 = src;
#line 2110
    src ++;
#line 2110
    temp = *__cil_tmp16;
#line 2110
    __cil_tmp15 = dptr;
#line 2110
    dptr ++;
#line 2110
    *__cil_tmp15 = (unsigned char )(temp >> 16);
#line 2111
    __cil_tmp17 = dptr;
#line 2111
    dptr ++;
#line 2111
    *__cil_tmp17 = (unsigned char )(temp >> 8);
#line 2112
    __cil_tmp18 = dptr;
#line 2112
    dptr ++;
#line 2112
    *__cil_tmp18 = (unsigned char )temp;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2115
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2118
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2118
    __cil_tmp19 = count;
#line 2118
    count --;
#line 2118
    if (! __cil_tmp19) {
#line 2118
      goto while_break___2;
    }
#line 2119
    __cil_tmp21 = src;
#line 2119
    src ++;
#line 2119
    temp = *__cil_tmp21;
#line 2119
    __cil_tmp20 = dptr;
#line 2119
    dptr ++;
#line 2119
    *__cil_tmp20 = (unsigned char )(temp >> 24);
#line 2120
    __cil_tmp22 = dptr;
#line 2120
    dptr ++;
#line 2120
    *__cil_tmp22 = (unsigned char )(temp >> 16);
#line 2121
    __cil_tmp23 = dptr;
#line 2121
    dptr ++;
#line 2121
    *__cil_tmp23 = (unsigned char )(temp >> 8);
#line 2122
    __cil_tmp24 = dptr;
#line 2122
    dptr ++;
#line 2122
    *__cil_tmp24 = (unsigned char )temp;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2128
  return (dptr);
}
}
#line 2131 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void unreorder_channels(int32_t *data , unsigned char *order , int num_chans ,
                               int num_samples ) 
{ 
  int32_t reorder_buffer[16] ;
  int32_t *temp ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  int chan ;

  {
#line 2133
  temp = (int32_t *)reorder_buffer;
#line 2135
  if (num_chans > 16) {
    {
#line 2136
    temp = (int32_t *)malloc((unsigned long )num_chans * sizeof(*data));
    }
  }
  {
#line 2138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2138
    __cil_tmp8 = num_samples;
#line 2138
    num_samples --;
#line 2138
    if (! __cil_tmp8) {
#line 2138
      goto while_break;
    }
#line 2141
    chan = 0;
    {
#line 2141
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2141
      if (! (chan < num_chans)) {
#line 2141
        goto while_break___0;
      }
#line 2142
      *(temp + chan) = *(data + *(order + chan));
#line 2141
      chan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2144
    memcpy(data, temp, (unsigned long )num_chans * sizeof(*data));
#line 2145
    data += num_chans;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2148
  if (num_chans > 16) {
    {
#line 2149
    free(temp);
    }
  }
  return;
}
}
#line 2152
static void dump_UTF8_string(char *string , FILE *dst ) ;
#line 2153
static void UTF8ToAnsi(char *string , int len ) ;
#line 2154 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static char const   *speakers[18]  = 
#line 2154
  {      "FL",      "FR",      "FC",      "LFE", 
        "BL",      "BR",      "FLC",      "FRC>dU", 
        "BC\032>dU",      "SL\032>dU",      "SR",      "TC\032>dU", 
        "TFL>dU",      "TFC>dU",      "TFR",      "TBL>dU", 
        "TBC>dU",      "TBR"};
#line 2159 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void dump_summary(WavpackContext *wpc , char *name , FILE *dst ) 
{ 
  uint32_t channel_mask ;
  int __cil_tmp5 ;
  int num_channels ;
  int __cil_tmp7 ;
  unsigned char md5_sum[16] ;
  char modes[80] ;
  int __cil_tmp10 ;
  char const   *tmp ;
  int64_t __cil_tmp12 ;
  int __cil_tmp13 ;
  uint32_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char const   *tmp___0 ;
  uint32_t __cil_tmp18 ;
  int cc ;
  int si ;
  uint32_t cm ;
  char const   *tmp___1 ;
  int __cil_tmp23 ;
  int64_t __cil_tmp24 ;
  double seconds ;
  int64_t __cil_tmp26 ;
  uint32_t __cil_tmp27 ;
  int minutes ;
  double __cil_tmp29 ;
  int hours ;
  double __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  char const   *tmp___2 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  char xmode[3] ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  double __cil_tmp44 ;
  double __cil_tmp45 ;
  double __cil_tmp46 ;
  int __cil_tmp47 ;
  double __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  char md5_string[33] ;
  int i ;
  uint32_t header_bytes ;
  uint32_t __cil_tmp55 ;
  uint32_t trailer_bytes ;
  uint32_t i___0 ;
  unsigned char *header_data ;
  unsigned char *__cil_tmp59 ;
  char header_name[5] ;
  uint32_t __cil_tmp61 ;
  unsigned char __cil_tmp62 ;
  unsigned char __cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  unsigned char *trailer_data ;
  unsigned char *__cil_tmp67 ;
  char trailer_name[5] ;
  int __cil_tmp69 ;
  int ape_tag ;
  int __cil_tmp71 ;
  int num_binary_items ;
  int __cil_tmp73 ;
  int num_items ;
  int __cil_tmp75 ;
  int i___1 ;
  char *spaces ;
  char const   *tmp___3 ;
  int item_len ;
  int value_len ;
  int j ;
  char *item ;
  char *value ;
  int __cil_tmp84 ;
  void *__cil_tmp85 ;
  int __cil_tmp86 ;
  void *__cil_tmp87 ;
  unsigned long __cil_tmp88 ;
  unsigned long __cil_tmp89 ;
  unsigned long __cil_tmp90 ;
  char *tmp___4 ;
  char *__cil_tmp92 ;
  int item_len___0 ;
  int value_len___0 ;
  char *item___0 ;
  char fname[256] ;
  int __cil_tmp97 ;
  void *__cil_tmp98 ;
  int __cil_tmp99 ;
  unsigned long __cil_tmp100 ;
  unsigned long __cil_tmp101 ;
  unsigned long __cil_tmp102 ;
  char *tmp___5 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;

  {
  {
#line 2161
  __cil_tmp5 = WavpackGetChannelMask(wpc);
#line 2161
  channel_mask = (uint32_t )__cil_tmp5;
#line 2162
  __cil_tmp7 = WavpackGetNumChannels(wpc);
#line 2162
  num_channels = __cil_tmp7;
#line 2166
  fprintf(dst, "\n\020\032>dU");
  }
#line 2168
  if (name) {
#line 2168
    if ((int )*name != 45) {
      {
#line 2169
      __cil_tmp10 = WavpackGetMode(wpc);
      }
#line 2169
      if (__cil_tmp10 & 1) {
#line 2169
        tmp = " (+wvc)";
      } else {
#line 2169
        tmp = "\220";
      }
      {
#line 2169
      fprintf(dst, "file name:         %s%s\n\230\001", name, tmp);
#line 2170
      __cil_tmp12 = WavpackGetFileSize64(wpc);
#line 2170
      fprintf(dst, "file size:         %lld bytes\n", (long long )__cil_tmp12);
      }
    }
  }
  {
#line 2173
  __cil_tmp13 = WavpackGetQualifyMode(wpc);
  }
#line 2173
  if (__cil_tmp13 & 48) {
    {
#line 2174
    __cil_tmp14 = WavpackGetNativeSampleRate(wpc);
#line 2174
    fprintf(dst, "source:            1-bit DSD at %u Hz\n", __cil_tmp14);
    }
  } else {
    {
#line 2176
    __cil_tmp15 = WavpackGetBitsPerSample(wpc);
    }
    {
#line 2176
    __cil_tmp16 = WavpackGetMode(wpc);
    }
#line 2176
    if (__cil_tmp16 & 8) {
#line 2176
      tmp___0 = "floats";
    } else {
#line 2176
      tmp___0 = "ints";
    }
    {
#line 2176
    __cil_tmp18 = WavpackGetSampleRate(wpc);
#line 2176
    fprintf(dst, "source:            %d-bit %s at %u Hz\n", __cil_tmp15, tmp___0,
            __cil_tmp18);
    }
  }
#line 2180
  if (! channel_mask) {
    {
#line 2181
    strcpy((char *)modes, "unassigned speakers");
    }
  } else
#line 2182
  if (num_channels == 1) {
#line 2182
    if (channel_mask == 4U) {
      {
#line 2183
      strcpy((char *)modes, "mono");
      }
    } else {
#line 2182
      goto _L___20;
    }
  } else
  _L___20: /* CIL Label */ 
#line 2184
  if (num_channels == 2) {
#line 2184
    if (channel_mask == 3U) {
      {
#line 2185
      strcpy((char *)modes, "stereo");
      }
    } else {
#line 2184
      goto _L___19;
    }
  } else
  _L___19: /* CIL Label */ 
#line 2186
  if (num_channels == 4) {
#line 2186
    if (channel_mask == 51U) {
      {
#line 2187
      strcpy((char *)modes, "quad");
      }
    } else {
#line 2186
      goto _L___18;
    }
  } else
  _L___18: /* CIL Label */ 
#line 2188
  if (num_channels == 6) {
#line 2188
    if (channel_mask == 63U) {
      {
#line 2189
      strcpy((char *)modes, "5.1 surround");
      }
    } else {
#line 2188
      goto _L___17;
    }
  } else
  _L___17: /* CIL Label */ 
#line 2190
  if (num_channels == 8) {
#line 2190
    if (channel_mask == 1610612799U) {
      {
#line 2191
      strcpy((char *)modes, "5.1 + stereo");
      }
    } else {
#line 2190
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2193
    cc = num_channels;
#line 2193
    si = 0;
#line 2194
    cm = channel_mask;
#line 2196
    modes[0] = (char )0;
    {
#line 2198
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2198
      if (! (cc && cm)) {
#line 2198
        goto while_break;
      }
#line 2199
      if (cm & 1U) {
#line 2200
        if (si < 18) {
#line 2200
          tmp___1 = speakers[si];
        } else {
#line 2200
          tmp___1 = "--";
        }
        {
#line 2200
        strcat((char *)modes, tmp___1);
#line 2201
        cc --;
        }
#line 2201
        if (cc) {
          {
#line 2202
          strcat((char *)modes, ",");
          }
        }
      }
#line 2204
      cm >>= 1;
#line 2205
      si ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2208
    if (cc) {
      {
#line 2209
      strcat((char *)modes, "...");
      }
    }
  }
  {
#line 2212
  fprintf(dst, "channels:          %d (%s)\n", num_channels, (char *)modes);
#line 2214
  __cil_tmp24 = WavpackGetNumSamples64(wpc);
  }
#line 2214
  if (__cil_tmp24 != -1L) {
    {
#line 2215
    __cil_tmp27 = WavpackGetSampleRate(wpc);
    }
    {
#line 2215
    __cil_tmp26 = WavpackGetNumSamples64(wpc);
#line 2215
    seconds = (double )__cil_tmp26 / (double )__cil_tmp27;
#line 2216
    __cil_tmp29 = floor(seconds / 60.);
#line 2216
    minutes = (int )__cil_tmp29;
#line 2217
    __cil_tmp31 = floor(seconds / 3600.);
#line 2217
    hours = (int )__cil_tmp31;
#line 2219
    seconds -= (double )minutes * 60.;
#line 2220
    minutes -= (int )((double )hours * 60.);
#line 2222
    fprintf(dst, "duration:          %d:%02d:%05.2f\n", hours, minutes, seconds);
    }
  }
  {
#line 2225
  modes[0] = (char )0;
#line 2227
  __cil_tmp32 = WavpackGetMode(wpc);
  }
#line 2227
  if (__cil_tmp32 & 4) {
    {
#line 2228
    strcat((char *)modes, "hybrid ");
    }
  }
  {
#line 2230
  __cil_tmp33 = WavpackGetMode(wpc);
  }
#line 2230
  if (__cil_tmp33 & 2) {
#line 2230
    tmp___2 = "lossless\323\001 ";
  } else {
#line 2230
    tmp___2 = "lossy";
  }
  {
#line 2230
  strcat((char *)modes, tmp___2);
#line 2232
  __cil_tmp35 = WavpackGetMode(wpc);
  }
#line 2232
  if (__cil_tmp35 & 64) {
    {
#line 2233
    strcat((char *)modes, ", fast");
    }
  } else {
    {
#line 2234
    __cil_tmp36 = WavpackGetMode(wpc);
    }
#line 2234
    if (__cil_tmp36 & 1024) {
      {
#line 2235
      strcat((char *)modes, ", very high");
      }
    } else {
      {
#line 2236
      __cil_tmp37 = WavpackGetMode(wpc);
      }
#line 2236
      if (__cil_tmp37 & 32) {
        {
#line 2237
        strcat((char *)modes, ", high");
        }
      }
    }
  }
  {
#line 2239
  __cil_tmp38 = WavpackGetMode(wpc);
  }
#line 2239
  if (__cil_tmp38 & 128) {
    {
#line 2240
    strcat((char *)modes, ", extra");
#line 2242
    __cil_tmp39 = WavpackGetMode(wpc);
    }
#line 2242
    if (__cil_tmp39 & 28672) {
      {
#line 2243
      xmode = "-0";
#line 2245
      __cil_tmp41 = WavpackGetMode(wpc);
#line 2245
      xmode[1] = (char )(((__cil_tmp41 & 28672) >> 12) + 48);
#line 2246
      strcat((char *)modes, (char const   *)((char *)xmode));
      }
    }
  }
  {
#line 2250
  __cil_tmp42 = WavpackGetMode(wpc);
  }
#line 2250
  if (__cil_tmp42 & 512) {
    {
#line 2251
    strcat((char *)modes, ", sfx");
    }
  }
  {
#line 2253
  __cil_tmp43 = WavpackGetMode(wpc);
  }
#line 2253
  if (__cil_tmp43 & 32768) {
    {
#line 2254
    strcat((char *)modes, ", dns");
    }
  }
  {
#line 2256
  fprintf(dst, "modalities:        %s\n", (char *)modes);
#line 2258
  __cil_tmp44 = WavpackGetRatio(wpc);
  }
#line 2258
  if (__cil_tmp44 != 0.) {
    {
#line 2259
    __cil_tmp45 = WavpackGetRatio(wpc);
#line 2259
    fprintf(dst, "compression:       %.2f%%\n", 100. - (double )100 * __cil_tmp45);
#line 2260
    __cil_tmp46 = WavpackGetAverageBitrate(wpc, 1);
#line 2260
    fprintf(dst, "ave bitrate:       %d kbps\n", (int )((__cil_tmp46 + 500.) / 1000.));
#line 2262
    __cil_tmp47 = WavpackGetMode(wpc);
    }
#line 2262
    if (__cil_tmp47 & 1) {
      {
#line 2263
      __cil_tmp48 = WavpackGetAverageBitrate(wpc, 0);
#line 2263
      fprintf(dst, "ave lossy bitrate: %d kbps\n", (int )((__cil_tmp48 + 500.) / 1000.));
      }
    }
  }
  {
#line 2266
  __cil_tmp49 = WavpackGetVersion(wpc);
  }
#line 2266
  if (__cil_tmp49) {
    {
#line 2267
    __cil_tmp50 = WavpackGetVersion(wpc);
#line 2267
    fprintf(dst, "encoder version:   %d\n", __cil_tmp50);
    }
  }
  {
#line 2269
  __cil_tmp51 = WavpackGetMD5Sum(wpc, (unsigned char *)md5_sum);
  }
#line 2269
  if (__cil_tmp51) {
#line 2270
    md5_string = "00000000000000000000000000000000\f";
#line 2273
    i = 0;
    {
#line 2273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2273
      if (! (i < 16)) {
#line 2273
        goto while_break___0;
      }
      {
#line 2274
      sprintf((char *)md5_string + i * 2, "%02x", (int )md5_sum[i]);
      }
#line 2273
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2276
    fprintf(dst, "original md5:      %s\n", (char *)md5_string);
    }
  }
#line 2279
  if (summary > 1) {
    {
#line 2280
    __cil_tmp55 = WavpackGetWrapperBytes(wpc);
#line 2280
    header_bytes = __cil_tmp55;
#line 2281
    __cil_tmp59 = WavpackGetWrapperData(wpc);
#line 2281
    header_data = __cil_tmp59;
#line 2284
    strcpy((char *)header_name, "????");
#line 2286
    i___0 = (uint32_t )0;
    }
    {
#line 2286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2286
      if (! (i___0 < 4U && i___0 < header_bytes)) {
#line 2286
        goto while_break___1;
      }
#line 2287
      if ((int )*(header_data + i___0) >= 32) {
#line 2287
        if ((int )*(header_data + i___0) <= 127) {
#line 2288
          header_name[i___0] = (char )*(header_data + i___0);
        }
      }
#line 2286
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2290
    WavpackFreeWrapper(wpc);
#line 2291
    WavpackSeekTrailingWrapper(wpc);
#line 2292
    trailer_bytes = WavpackGetWrapperBytes(wpc);
#line 2294
    __cil_tmp62 = WavpackGetFileFormat(wpc);
    }
#line 2294
    if ((unsigned long )__cil_tmp62 < sizeof(file_formats) / sizeof(file_formats[0])) {
      {
#line 2295
      __cil_tmp64 = WavpackGetFileExtension(wpc);
#line 2295
      fprintf(dst, "source format:     %s with \'%s\' extension\n", file_formats[__cil_tmp63].format_name,
              __cil_tmp64);
      }
    } else {
      {
#line 2298
      __cil_tmp65 = WavpackGetFileExtension(wpc);
#line 2298
      fprintf(dst, "source format:     \'%s\' file\n", __cil_tmp65);
      }
    }
#line 2300
    if (header_bytes) {
#line 2300
      if (trailer_bytes) {
        {
#line 2301
        __cil_tmp67 = WavpackGetWrapperData(wpc);
#line 2301
        trailer_data = __cil_tmp67;
#line 2304
        strcpy((char *)trailer_name, "????");
#line 2306
        i___0 = (uint32_t )0;
        }
        {
#line 2306
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2306
          if (! (i___0 < 4U && i___0 < trailer_bytes)) {
#line 2306
            goto while_break___2;
          }
#line 2307
          if ((int )*(trailer_data + i___0) >= 32) {
#line 2307
            if ((int )*(trailer_data + i___0) <= 127) {
#line 2308
              trailer_name[i___0] = (char )*(trailer_data + i___0);
            }
          }
#line 2306
          i___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2310
        fprintf(dst, "file wrapper:      %d + %d bytes (%s, %s)\n", header_bytes,
                trailer_bytes, (char *)header_name, (char *)trailer_name);
        }
      } else {
#line 2300
        goto _L___21;
      }
    } else
    _L___21: /* CIL Label */ 
#line 2313
    if (header_bytes) {
      {
#line 2314
      fprintf(dst, "file wrapper:      %d byte %s header\n", header_bytes, (char *)header_name);
      }
    } else
#line 2316
    if (trailer_bytes) {
      {
#line 2317
      fprintf(dst, "file wrapper:      %d byte trailer only\n\230\001", trailer_bytes);
      }
    } else {
      {
#line 2320
      fprintf(dst, "file wrapper:      none stored\n");
      }
    }
  }
  {
#line 2323
  __cil_tmp69 = WavpackGetMode(wpc);
  }
#line 2323
  if (__cil_tmp69 & 16) {
    {
#line 2324
    __cil_tmp71 = WavpackGetMode(wpc);
#line 2324
    ape_tag = __cil_tmp71 & 256;
#line 2325
    __cil_tmp73 = WavpackGetNumBinaryTagItems(wpc);
#line 2325
    num_binary_items = __cil_tmp73;
#line 2326
    __cil_tmp75 = WavpackGetNumTagItems(wpc);
#line 2326
    num_items = __cil_tmp75;
#line 2327
    spaces = "                  ";
    }
#line 2329
    if (ape_tag) {
#line 2329
      tmp___3 = "APEv2";
    } else {
#line 2329
      tmp___3 = "ID3v1";
    }
    {
#line 2329
    fprintf(dst, "\n%s tag items:   %d\n", tmp___3, num_items + num_binary_items);
#line 2331
    i___1 = 0;
    }
    {
#line 2331
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2331
      if (! (i___1 < num_items)) {
#line 2331
        goto while_break___3;
      }
      {
#line 2335
      item_len = WavpackGetTagItemIndexed(wpc, i___1, (char *)((void *)0), 0);
#line 2336
      item = (char *)malloc((unsigned long )(item_len + 1));
#line 2337
      WavpackGetTagItemIndexed(wpc, i___1, item, item_len + 1);
#line 2338
      value_len = WavpackGetTagItem(wpc, (char const   *)item, (char *)((void *)0),
                                    0);
#line 2339
      value = (char *)malloc((unsigned long )(value_len * 2 + 1));
#line 2340
      WavpackGetTagItem(wpc, (char const   *)item, value, value_len + 1);
#line 2342
      __cil_tmp89 = strlen((char const   *)spaces);
      }
      {
#line 2342
      __cil_tmp88 = strlen((char const   *)item);
      }
#line 2342
      if (__cil_tmp88 < __cil_tmp89) {
        {
#line 2342
        __cil_tmp90 = strlen((char const   *)item);
#line 2342
        tmp___4 = spaces + __cil_tmp90;
        }
      } else {
#line 2342
        tmp___4 = (char *)" ";
      }
      {
#line 2342
      fprintf(dst, "%s:%s", item, (int )tmp___4);
      }
#line 2344
      if (ape_tag) {
#line 2345
        j = 0;
        {
#line 2345
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2345
          if (! (j < value_len)) {
#line 2345
            goto while_break___4;
          }
#line 2346
          if (! *(value + j)) {
#line 2347
            *(value + j) = (char )'\\';
          }
#line 2345
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 2349
        __cil_tmp92 = strchr((char const   *)value, '\n');
        }
#line 2349
        if (__cil_tmp92) {
          {
#line 2350
          fprintf(dst, "%d-byte multi-line text string\n", value_len);
          }
        } else {
          {
#line 2352
          dump_UTF8_string(value, dst);
#line 2353
          fprintf(dst, "\n");
          }
        }
      } else {
        {
#line 2357
        fprintf(dst, "%s\n", value);
        }
      }
      {
#line 2359
      free(value);
#line 2360
      free(item);
      }
#line 2331
      i___1 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2363
    i___1 = 0;
    {
#line 2363
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2363
      if (! (i___1 < num_binary_items)) {
#line 2363
        goto while_break___5;
      }
      {
#line 2367
      item_len___0 = WavpackGetBinaryTagItemIndexed(wpc, i___1, (char *)((void *)0),
                                                    0);
#line 2368
      item___0 = (char *)malloc((unsigned long )(item_len___0 + 1));
#line 2369
      WavpackGetBinaryTagItemIndexed(wpc, i___1, item___0, item_len___0 + 1);
#line 2370
      value_len___0 = dump_tag_item_to_file(wpc, (char const   *)item___0, (FILE *)((void *)0),
                                            (char *)fname);
#line 2371
      __cil_tmp101 = strlen((char const   *)spaces);
      }
      {
#line 2371
      __cil_tmp100 = strlen((char const   *)item___0);
      }
#line 2371
      if (__cil_tmp100 < __cil_tmp101) {
        {
#line 2371
        __cil_tmp102 = strlen((char const   *)item___0);
#line 2371
        tmp___5 = spaces + __cil_tmp102;
        }
      } else {
#line 2371
        tmp___5 = (char *)" ";
      }
      {
#line 2371
      fprintf(dst, "%s:%s", item___0, (int )tmp___5);
#line 2373
      __cil_tmp104 = filespec_ext((char *)fname);
      }
#line 2373
      if (__cil_tmp104) {
        {
#line 2374
        __cil_tmp105 = filespec_ext((char *)fname);
#line 2374
        fprintf(dst, "%d-byte binary item (%s)\n", value_len___0, __cil_tmp105 + 1);
        }
      } else {
        {
#line 2376
        fprintf(dst, "%d-byte binary item\n", value_len___0);
        }
      }
      {
#line 2408
      free(item___0);
      }
#line 2363
      i___1 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 2431
static void dump_file_item(WavpackContext *wpc , char *str , int item_id ) ;
#line 2433 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void dump_file_info(WavpackContext *wpc , char *name , FILE *dst , int parameter ) 
{ 
  char str[80] ;
  int item_id ;

  {
#line 2438
  str[0] = (char )0;
#line 2440
  if (parameter == 0) {
#line 2441
    item_id = 1;
    {
#line 2441
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2441
      if (! (item_id <= 9)) {
#line 2441
        goto while_break;
      }
      {
#line 2442
      dump_file_item(wpc, (char *)str, item_id);
#line 2443
      strcat((char *)str, ";");
      }
#line 2441
      item_id ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2446
    if (name) {
#line 2446
      if ((int )*name != 45) {
        {
#line 2447
        fprintf(dst, "%s%s\n", (char *)str, name);
        }
      } else {
        {
        {
#line 2449
        fprintf(dst, "%s\n", (char *)str);
        }
        }
      }
    } else {
      {
      {
#line 2449
      fprintf(dst, "%s\n", (char *)str);
      }
      }
    }
  } else
#line 2451
  if (parameter < 10) {
    {
#line 2452
    dump_file_item(wpc, (char *)str, parameter);
#line 2453
    fprintf(dst, "%s\n", (char *)str);
    }
  } else
#line 2455
  if (name) {
#line 2455
    if (parameter == 10) {
#line 2455
      if ((int )*name != 45) {
        {
#line 2456
        fprintf(dst, "%s\n", name);
        }
      } else {
        {
        {
        {
#line 2458
        fprintf(dst, "\n");
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 2458
      fprintf(dst, "\n");
      }
      }
      }
    }
  } else {
    {
    {
    {
#line 2458
    fprintf(dst, "\n");
    }
    }
    }
  }
  return;
}
}
#line 2461 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void dump_file_item(WavpackContext *wpc , char *str , int item_id ) 
{ 
  unsigned char md5_sum[16] ;
  unsigned long __cil_tmp5 ;
  uint32_t __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  char const   *tmp___0 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int64_t __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  int64_t __cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp___1 ;
  int __cil_tmp23 ;
  char md5_string[33] ;
  int i ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  int __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 2466
  if (item_id == 1) {
#line 2466
    goto case_1;
  }
#line 2470
  if (item_id == 2) {
#line 2470
    goto case_2;
  }
#line 2474
  if (item_id == 3) {
#line 2474
    goto case_3;
  }
#line 2478
  if (item_id == 4) {
#line 2478
    goto case_4;
  }
#line 2482
  if (item_id == 5) {
#line 2482
    goto case_5;
  }
#line 2486
  if (item_id == 6) {
#line 2486
    goto case_6;
  }
#line 2493
  if (item_id == 7) {
#line 2493
    goto case_7;
  }
#line 2506
  if (item_id == 8) {
#line 2506
    goto case_8;
  }
#line 2510
  if (item_id == 9) {
#line 2510
    goto case_9;
  }
#line 2514
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2467
  __cil_tmp5 = strlen((char const   *)str);
  }
  {
#line 2467
  __cil_tmp6 = WavpackGetNativeSampleRate(wpc);
#line 2467
  sprintf(str + __cil_tmp5, "%d", __cil_tmp6);
  }
#line 2468
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2471
  __cil_tmp7 = strlen((char const   *)str);
  }
  {
#line 2471
  __cil_tmp8 = WavpackGetQualifyMode(wpc);
  }
#line 2471
  if (__cil_tmp8 & 48) {
#line 2471
    tmp = 1;
  } else {
    {
#line 2471
    __cil_tmp9 = WavpackGetBitsPerSample(wpc);
#line 2471
    tmp = __cil_tmp9;
    }
  }
  {
#line 2471
  sprintf(str + __cil_tmp7, "%d", tmp);
  }
#line 2472
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2475
  __cil_tmp11 = strlen((char const   *)str);
  }
  {
#line 2475
  __cil_tmp12 = WavpackGetMode(wpc);
  }
#line 2475
  if (__cil_tmp12 & 8) {
#line 2475
    tmp___0 = "float";
  } else {
#line 2475
    tmp___0 = "int";
  }
  {
#line 2475
  sprintf(str + __cil_tmp11, "%s", tmp___0);
  }
#line 2476
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2479
  __cil_tmp14 = strlen((char const   *)str);
  }
  {
#line 2479
  __cil_tmp15 = WavpackGetNumChannels(wpc);
#line 2479
  sprintf(str + __cil_tmp14, "%d", __cil_tmp15);
  }
#line 2480
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2483
  __cil_tmp16 = strlen((char const   *)str);
  }
  {
#line 2483
  __cil_tmp17 = WavpackGetChannelMask(wpc);
#line 2483
  sprintf(str + __cil_tmp16, "0x%x", __cil_tmp17);
  }
#line 2484
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 2487
  __cil_tmp18 = WavpackGetNumSamples64(wpc);
  }
#line 2487
  if (__cil_tmp18 != -1L) {
    {
#line 2488
    __cil_tmp19 = strlen((char const   *)str);
    }
    {
#line 2488
    __cil_tmp21 = WavpackGetQualifyMode(wpc);
    }
#line 2488
    if (__cil_tmp21 & 48) {
#line 2488
      tmp___1 = 8;
    } else {
#line 2488
      tmp___1 = 1;
    }
    {
#line 2488
    __cil_tmp20 = WavpackGetNumSamples64(wpc);
#line 2488
    sprintf(str + __cil_tmp19, "%lld", (long long )__cil_tmp20 * (long long )tmp___1);
    }
  }
#line 2491
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2494
  __cil_tmp23 = WavpackGetMD5Sum(wpc, (unsigned char *)md5_sum);
  }
#line 2494
  if (__cil_tmp23) {
#line 2495
    md5_string = "00000000000000000000000000000000\f";
#line 2498
    i = 0;
    {
#line 2498
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2498
      if (! (i < 16)) {
#line 2498
        goto while_break;
      }
      {
#line 2499
      sprintf((char *)md5_string + i * 2, "%02x", (int )md5_sum[i]);
      }
#line 2498
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2501
    __cil_tmp26 = strlen((char const   *)str);
#line 2501
    sprintf(str + __cil_tmp26, "%s", (char *)md5_string);
    }
  }
#line 2504
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 2507
  __cil_tmp27 = strlen((char const   *)str);
  }
  {
#line 2507
  __cil_tmp28 = WavpackGetVersion(wpc);
#line 2507
  sprintf(str + __cil_tmp27, "%d", __cil_tmp28);
  }
#line 2508
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 2511
  __cil_tmp29 = strlen((char const   *)str);
  }
  {
#line 2511
  __cil_tmp30 = WavpackGetMode(wpc);
#line 2511
  sprintf(str + __cil_tmp29, "0x%x", __cil_tmp30);
  }
#line 2512
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2515
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2529 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static int dump_tag_item_to_file(WavpackContext *wpc , char const   *tag_item , FILE *dst ,
                                 char *fname ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int value_len ;
  int __cil_tmp8 ;
  char *value ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;
  int value_len___0 ;
  int __cil_tmp13 ;
  int res ;
  int i ;
  uint32_t bcount ;
  char *value___0 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 2531
  __cil_tmp5 = WavpackGetMode(wpc);
  }
#line 2531
  if (__cil_tmp5 & 16) {
    {
#line 2532
    __cil_tmp6 = WavpackGetTagItem(wpc, tag_item, (char *)((void *)0), 0);
    }
#line 2532
    if (__cil_tmp6) {
      {
#line 2533
      __cil_tmp8 = WavpackGetTagItem(wpc, tag_item, (char *)((void *)0), 0);
#line 2533
      value_len = __cil_tmp8;
      }
#line 2536
      if (fname) {
        {
#line 2537
        strcpy(fname, tag_item);
#line 2538
        strcat(fname, ".txt");
        }
      }
#line 2541
      if (! dst) {
#line 2542
        return (value_len);
      } else
#line 2541
      if (! value_len) {
#line 2542
        return (value_len);
      }
      {
#line 2550
      value = (char *)malloc((unsigned long )(value_len * 2 + 1));
#line 2551
      WavpackGetTagItem(wpc, tag_item, value, value_len + 1);
#line 2552
      dump_UTF8_string(value, dst);
#line 2553
      free(value);
      }
#line 2554
      return (value_len);
    } else {
      {
#line 2556
      __cil_tmp11 = WavpackGetBinaryTagItem(wpc, tag_item, (char *)((void *)0), 0);
      }
#line 2556
      if (__cil_tmp11) {
        {
#line 2557
        __cil_tmp13 = WavpackGetBinaryTagItem(wpc, tag_item, (char *)((void *)0),
                                              0);
#line 2557
        value_len___0 = __cil_tmp13;
        }
        {
#line 2557
        res = 0;
#line 2558
        bcount = (uint32_t )0;
#line 2561
        value___0 = (char *)malloc((unsigned long )value_len___0);
#line 2562
        WavpackGetBinaryTagItem(wpc, tag_item, value___0, value_len___0);
#line 2564
        i = 0;
        }
        {
#line 2564
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2564
          if (! (i < value_len___0)) {
#line 2564
            goto while_break;
          }
#line 2565
          if (! *(value___0 + i)) {
#line 2567
            if (dst) {
              {
#line 2574
              res = DoWriteFile(dst, ((unsigned char *)value___0 + i) + 1, (uint32_t )((value_len___0 - i) - 1),
                                & bcount);
              }
            }
#line 2577
            if (fname) {
#line 2578
              if (i < 256) {
                {
#line 2579
                strcpy(fname, (char const   *)value___0);
                }
              } else {
                {
#line 2581
                strcpy(fname, tag_item);
#line 2582
                strcat(fname, ".bin");
                }
              }
            }
#line 2586
            goto while_break;
          }
#line 2564
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 2589
        free(value___0);
        }
#line 2591
        if (i == value_len___0) {
#line 2592
          return (0);
        }
#line 2594
        if (dst) {
#line 2594
          if (! res) {
#line 2595
            return (0);
          } else
#line 2594
          if (bcount != (unsigned int )((value_len___0 - i) - 1)) {
#line 2595
            return (0);
          }
        }
#line 2597
        return ((value_len___0 - i) - 1);
      } else {
#line 2600
        return (0);
      }
    }
  } else {
#line 2603
    return (0);
  }
}
}
#line 2612 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void dump_UTF8_string(char *string , FILE *dst ) 
{ 
  char *p ;
  char *temp ;
  int len ;
  char *__cil_tmp6 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2614
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2614
    if (! *string) {
#line 2614
      goto while_break;
    }
#line 2615
    p = string;
#line 2616
    len = 0;
    {
#line 2618
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2618
      if (! *p) {
#line 2618
        goto while_break___0;
      }
#line 2619
      if ((int )*p != 13) {
#line 2620
        len ++;
      }
#line 2622
      __cil_tmp6 = p;
#line 2622
      p ++;
#line 2622
      if ((int )*__cil_tmp6 == 10) {
#line 2623
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2626
    if (! len) {
#line 2627
      return;
    }
    {
#line 2629
    p = (char *)malloc((unsigned long )(len * 2 + 1));
    }
    {
#line 2631
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2631
      if (! *string) {
#line 2631
        goto while_break___1;
      }
#line 2632
      if ((int )*string != 13) {
#line 2633
        __cil_tmp8 = p;
#line 2633
        p ++;
#line 2633
        *__cil_tmp8 = *string;
      }
#line 2635
      __cil_tmp9 = string;
#line 2635
      string ++;
#line 2635
      if ((int )*__cil_tmp9 == 10) {
#line 2636
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2639
    *p = (char )0;
#line 2644
    if (! no_utf8_convert) {
      {
#line 2646
      UTF8ToAnsi(temp, len * 2);
      }
    }
    {
#line 2648
    fputs((char const   *)temp, dst);
#line 2649
    free(temp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2772 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
static void UTF8ToAnsi(char *string , int len ) 
{ 
  int max_chars ;
  unsigned long __cil_tmp4 ;
  char *temp ;
  void *__cil_tmp6 ;
  char *outp ;
  char *inp ;
  size_t insize ;
  size_t outsize ;
  int err ;
  char *old_locale ;
  iconv_t converter ;
  char *__cil_tmp14 ;
  iconv_t __cil_tmp15 ;
  size_t __cil_tmp16 ;

  {
  {
#line 2774
  __cil_tmp4 = strlen((char const   *)string);
#line 2774
  max_chars = (int )__cil_tmp4;
#line 2791
  __cil_tmp6 = malloc((unsigned long )len);
#line 2791
  temp = __cil_tmp6;
#line 2792
  outp = temp;
#line 2793
  inp = string;
#line 2794
  insize = (size_t )max_chars;
#line 2795
  outsize = (size_t )(len - 1);
#line 2796
  err = 0;
#line 2800
  memset(temp, 0, (unsigned long )len);
#line 2801
  old_locale = setlocale(0, "");
#line 2802
  converter = iconv_open("\323\001 ", "UTF-8");
  }
#line 2804
  if (converter != (iconv_t )-1) {
    {
#line 2805
    __cil_tmp16 = iconv(converter, & inp, & insize, & outp, & outsize);
#line 2805
    err = (int )__cil_tmp16;
#line 2806
    iconv_close(converter);
    }
  } else {
#line 2809
    err = - 1;
  }
  {
#line 2811
  setlocale(0, (char const   *)old_locale);
  }
#line 2813
  if (err == -1) {
    {
#line 2814
    free(temp);
    }
#line 2815
    return;
  }
  {
#line 2818
  memmove(string, temp, (unsigned long )len);
#line 2820
  free(temp);
  }
  return;
}
}
#line 2830 "/doner/wavpack/wavpack-5.1.0/cli/wvunpack.c"
void display_progress(double file_progress ) 
{ 
  char title[40] ;

  {
#line 2834
  if (set_console_title) {
    {
#line 2835
    file_progress = ((double )file_index + file_progress) / (double )num_files;
#line 2836
    sprintf((char *)title, "%d%% (WvUnpack)", (int )(file_progress * 100. + 0.5));
#line 2837
    DoSetConsoleTitle((char *)title);
    }
  }
  return;
}
}
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size(__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 39 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
static unsigned char const   riff_guid[16]  = 
#line 39 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
  {      (unsigned char )'r',      (unsigned char )'i',      (unsigned char )'f',      (unsigned char )'f', 
        (unsigned char )46,      (unsigned char )145,      (unsigned char )207,      (unsigned char )17, 
        (unsigned char )165,      (unsigned char )214,      (unsigned char )40,      (unsigned char )219, 
        (unsigned char )4,      (unsigned char )193,      (unsigned char )0,      (unsigned char )0};
#line 40 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
static unsigned char const   wave_guid[16]  = 
#line 40
  {      (unsigned char )'w',      (unsigned char )'a',      (unsigned char )'v',      (unsigned char )'e', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 41 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
static unsigned char const   fmt_guid[16]  = 
#line 41
  {      (unsigned char )'f',      (unsigned char )'m',      (unsigned char )'t',      (unsigned char )' ', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 42 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
static unsigned char const   data_guid[16]  = 
#line 42
  {      (unsigned char )'d',      (unsigned char )'a',      (unsigned char )'t',      (unsigned char )'a', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 50 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
int ParseWave64HeaderConfig(FILE *infile , char *infilename , char *fourcc , WavpackContext *wpc ,
                            WavpackConfig *config ) 
{ 
  int64_t total_samples ;
  int64_t infilesize ;
  Wave64ChunkHeader chunk_header ;
  Wave64FileHeader filehdr ;
  WaveHeader WaveHeader ;
  uint32_t bcount ;
  int64_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *__cil_tmp20 ;
  int __cil_tmp21 ;
  int supported ;
  int format ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  char *__cil_tmp26 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp29 ;
  int64_t __cil_tmp30 ;
  int64_t __cil_tmp31 ;
  int bytes_to_copy ;
  char *buff ;
  void *__cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  char *__cil_tmp37 ;
  int __cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 52
  total_samples = (int64_t )0;
#line 58
  infilesize = DoGetFileSize(infile);
#line 59
  memcpy(& filehdr, fourcc, (unsigned long )4);
#line 61
  __cil_tmp15 = memcmp((char *)filehdr.formType, (unsigned char const   *)wave_guid,
                       sizeof(wave_guid));
  }
  {
#line 61
  __cil_tmp14 = memcmp((char *)filehdr.ckID, (unsigned char const   *)riff_guid, sizeof(riff_guid));
  }
  {
#line 61
  __cil_tmp13 = DoReadFile(infile, (char *)(& filehdr) + 4, (uint32_t )(sizeof(Wave64FileHeader ) - 4UL),
                           & bcount);
  }
#line 61
  if (! __cil_tmp13) {
    {
    {
    {
    {
#line 64
    error_line("%s is not a valid .W64 file!", infilename);
    }
    }
    }
    }
#line 65
    return (1);
  } else
#line 61
  if ((unsigned long )bcount != sizeof(Wave64FileHeader ) - 4UL) {
    {
    {
    {
    {
#line 64
    error_line("%s is not a valid .W64 file!", infilename);
    }
    }
    }
    }
#line 65
    return (1);
  } else
#line 61
  if (__cil_tmp14) {
    {
    {
    {
    {
#line 64
    error_line("%s is not a valid .W64 file!", infilename);
    }
    }
    }
    }
#line 65
    return (1);
  } else
#line 61
  if (__cil_tmp15) {
    {
    {
    {
    {
#line 64
    error_line("%s is not a valid .W64 file!", infilename);
    }
    }
    }
    }
#line 65
    return (1);
  } else {
    {
#line 67
    __cil_tmp16 = WavpackAddWrapper(wpc, & filehdr, (uint32_t )sizeof(filehdr));
    }
#line 67
    if (! (config->qmode & 512)) {
#line 67
      if (! __cil_tmp16) {
        {
#line 69
        __cil_tmp17 = WavpackGetErrorMessage(wpc);
#line 69
        error_line("%s", __cil_tmp17);
        }
#line 70
        return (1);
      }
    }
  }
  {
#line 74
  WavpackLittleEndianToNative(& filehdr, "88D");
  }
#line 76
  if (infilesize) {
#line 76
    if (! (config->qmode & 2048)) {
#line 76
      if (filehdr.ckSize) {
#line 76
        if (filehdr.ckSize + 1L) {
#line 76
          if (filehdr.ckSize != infilesize) {
            {
#line 78
            error_line("%s is not a valid .W64 file!", infilename);
            }
#line 79
            return (1);
          }
        }
      }
    }
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    __cil_tmp18 = DoReadFile(infile, & chunk_header, (uint32_t )sizeof(Wave64ChunkHeader ),
                             & bcount);
    }
#line 87
    if (! __cil_tmp18) {
      {
      {
#line 89
      error_line("%s is not a valid .W64 file!", infilename);
      }
      }
#line 90
      return (1);
    } else
#line 87
    if ((unsigned long )bcount != sizeof(Wave64ChunkHeader )) {
      {
      {
#line 89
      error_line("%s is not a valid .W64 file!", infilename);
      }
      }
#line 90
      return (1);
    } else {
      {
#line 92
      __cil_tmp19 = WavpackAddWrapper(wpc, & chunk_header, (uint32_t )sizeof(Wave64ChunkHeader ));
      }
#line 92
      if (! (config->qmode & 512)) {
#line 92
        if (! __cil_tmp19) {
          {
#line 94
          __cil_tmp20 = WavpackGetErrorMessage(wpc);
#line 94
          error_line("%s", __cil_tmp20);
          }
#line 95
          return (1);
        }
      }
    }
    {
#line 98
    WavpackLittleEndianToNative(& chunk_header, "88D");
#line 99
    chunk_header.ckSize -= sizeof(chunk_header);
#line 104
    __cil_tmp21 = memcmp((char *)chunk_header.ckID, (unsigned char const   *)fmt_guid,
                         sizeof(fmt_guid));
    }
#line 104
    if (! __cil_tmp21) {
      {
#line 105
      supported = 1;
#line 107
      chunk_header.ckSize = (chunk_header.ckSize + 7L) & -8L;
#line 109
      __cil_tmp24 = DoReadFile(infile, & WaveHeader, (uint32_t )chunk_header.ckSize,
                               & bcount);
      }
#line 109
      if (chunk_header.ckSize < 16L) {
        {
        {
        {
        {
#line 112
        error_line("%s is not a valid .W64 file!", infilename);
        }
        }
        }
        }
#line 113
        return (1);
      } else
#line 109
      if ((unsigned long )chunk_header.ckSize > sizeof(WaveHeader)) {
        {
        {
        {
        {
#line 112
        error_line("%s is not a valid .W64 file!", infilename);
        }
        }
        }
        }
#line 113
        return (1);
      } else
#line 109
      if (! __cil_tmp24) {
        {
        {
        {
        {
#line 112
        error_line("%s is not a valid .W64 file!", infilename);
        }
        }
        }
        }
#line 113
        return (1);
      } else
#line 109
      if ((long )bcount != chunk_header.ckSize) {
        {
        {
        {
        {
#line 112
        error_line("%s is not a valid .W64 file!", infilename);
        }
        }
        }
        }
#line 113
        return (1);
      } else {
        {
#line 115
        __cil_tmp25 = WavpackAddWrapper(wpc, & WaveHeader, (uint32_t )chunk_header.ckSize);
        }
#line 115
        if (! (config->qmode & 512)) {
#line 115
          if (! __cil_tmp25) {
            {
#line 117
            __cil_tmp26 = WavpackGetErrorMessage(wpc);
#line 117
            error_line("%s", __cil_tmp26);
            }
#line 118
            return (1);
          }
        }
      }
      {
#line 121
      WavpackLittleEndianToNative(& WaveHeader, "SSLLSSSSLS");
      }
#line 123
      if (debug_logging_mode) {
        {
#line 124
        error_line("format tag size = %d", chunk_header.ckSize);
#line 125
        error_line("FormatTag = %x, NumChannels = %d, BitsPerSample = %d", (int )WaveHeader.FormatTag,
                   (int )WaveHeader.NumChannels, (int )WaveHeader.BitsPerSample);
#line 127
        error_line("BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d", (int )WaveHeader.BlockAlign,
                   WaveHeader.SampleRate, WaveHeader.BytesPerSecond);
        }
#line 130
        if (chunk_header.ckSize > 16L) {
          {
#line 131
          error_line("cbSize = %d, ValidBitsPerSample = %d", (int )WaveHeader.cbSize,
                     (int )WaveHeader.ValidBitsPerSample);
          }
        }
#line 134
        if (chunk_header.ckSize > 20L) {
          {
#line 135
          error_line("ChannelMask = %x, SubFormat = %d\230\001", WaveHeader.ChannelMask,
                     (int )WaveHeader.SubFormat);
          }
        }
      }
#line 139
      if (chunk_header.ckSize > 16L) {
#line 139
        if ((int )WaveHeader.cbSize == 2) {
#line 140
          config->qmode |= 256;
        }
      }
#line 142
      if ((int )WaveHeader.FormatTag == 65534 && chunk_header.ckSize == 40L) {
#line 142
        tmp = (int )WaveHeader.SubFormat;
      } else {
#line 142
        tmp = (int )WaveHeader.FormatTag;
      }
#line 142
      format = tmp;
#line 145
      if (chunk_header.ckSize == 40L && (int )WaveHeader.ValidBitsPerSample) {
#line 145
        tmp___0 = (int )WaveHeader.ValidBitsPerSample;
      } else {
#line 145
        tmp___0 = (int )WaveHeader.BitsPerSample;
      }
#line 145
      config->bits_per_sample = tmp___0;
#line 148
      if (format != 1) {
#line 148
        if (format != 3) {
#line 149
          supported = 0;
        }
      }
#line 151
      if (format == 3) {
#line 151
        if (config->bits_per_sample != 32) {
#line 152
          supported = 0;
        }
      }
#line 154
      if (! WaveHeader.NumChannels) {
#line 158
        supported = 0;
      } else
#line 154
      if ((int )WaveHeader.NumChannels > 256) {
#line 158
        supported = 0;
      } else
#line 154
      if ((int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8) {
#line 158
        supported = 0;
      } else
#line 154
      if ((int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels > 4) {
#line 158
        supported = 0;
      } else
#line 154
      if ((int )WaveHeader.BlockAlign % (int )WaveHeader.NumChannels) {
#line 158
        supported = 0;
      }
#line 160
      if (config->bits_per_sample < 1) {
#line 161
        supported = 0;
      } else
#line 160
      if (config->bits_per_sample > 32) {
#line 161
        supported = 0;
      }
#line 163
      if (! supported) {
        {
#line 164
        error_line("%s is an unsupported .W64 format!", infilename);
        }
#line 165
        return (1);
      }
#line 168
      if (chunk_header.ckSize < 40L) {
#line 169
        if (! config->channel_mask) {
#line 169
          if (! (config->qmode & 1024)) {
#line 170
            if ((int )WaveHeader.NumChannels <= 2) {
#line 171
              config->channel_mask = 5 - (int )WaveHeader.NumChannels;
            } else
#line 172
            if ((int )WaveHeader.NumChannels <= 18) {
#line 173
              config->channel_mask = (1 << (int )WaveHeader.NumChannels) - 1;
            } else {
#line 175
              config->channel_mask = 262143;
            }
          }
        }
      } else
#line 178
      if (WaveHeader.ChannelMask) {
#line 178
        if (config->channel_mask) {
          {
          {
#line 179
          error_line("this W64 file already has channel order information!");
          }
          }
#line 180
          return (1);
        } else
#line 178
        if (config->qmode & 1024) {
          {
          {
#line 179
          error_line("this W64 file already has channel order information!");
          }
          }
#line 180
          return (1);
        } else {
#line 178
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 182
      if (WaveHeader.ChannelMask) {
#line 183
        config->channel_mask = WaveHeader.ChannelMask;
      }
#line 185
      if (format == 3) {
#line 186
        config->float_norm_exp = 127;
      } else
#line 187
      if (config->qmode & 256) {
#line 187
        if ((int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels == 4) {
#line 189
          if ((int )WaveHeader.BitsPerSample == 24) {
#line 190
            config->float_norm_exp = 150;
          } else
#line 191
          if ((int )WaveHeader.BitsPerSample == 32) {
#line 192
            config->float_norm_exp = 142;
          }
        }
      }
#line 195
      if (debug_logging_mode) {
#line 196
        if (config->float_norm_exp == 127) {
          {
#line 197
          error_line("data format: normalized 32-bit floating point");
          }
        } else {
          {
#line 199
          error_line("data format: %d-bit integers stored in %d byte(s)", config->bits_per_sample,
                     (int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels);
          }
        }
      }
    } else {
      {
#line 203
      __cil_tmp29 = memcmp((char *)chunk_header.ckID, (unsigned char const   *)data_guid,
                           sizeof(data_guid));
      }
#line 203
      if (! __cil_tmp29) {
#line 205
        if (! WaveHeader.NumChannels) {
          {
#line 206
          error_line("%s is not a valid .W64 file!", infilename);
          }
#line 207
          return (1);
        }
#line 210
        if (config->qmode & 2048) {
          _L___22: /* CIL Label */ 
          {
#line 211
          config->qmode |= 2048;
#line 213
          __cil_tmp30 = DoGetFilePosition(infile);
          }
#line 213
          if (infilesize) {
#line 213
            if (__cil_tmp30 != -1L) {
              {
#line 214
              __cil_tmp31 = DoGetFilePosition(infile);
#line 214
              total_samples = (infilesize - __cil_tmp31) / (long )WaveHeader.BlockAlign;
              }
            } else {
#line 216
              total_samples = (int64_t )(- 1);
            }
          } else {
#line 216
            total_samples = (int64_t )(- 1);
          }
        } else
#line 210
        if (chunk_header.ckSize <= 0L) {
#line 210
          goto _L___22;
        } else {
#line 219
          if (infilesize) {
#line 219
            if (infilesize - chunk_header.ckSize > 16777216L) {
              {
#line 220
              error_line("this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!");
              }
#line 221
              return (1);
            }
          }
#line 224
          total_samples = chunk_header.ckSize / (long )WaveHeader.BlockAlign;
#line 226
          if (! total_samples) {
            {
#line 227
            error_line("this .W64 file has no audio samples, probably is corrupt!");
            }
#line 228
            return (1);
          }
#line 231
          if ((long long )total_samples > (1LL << 40) - 257LL) {
            {
#line 232
            error_line("%s has too many samples for WavPack!", infilename);
            }
#line 233
            return (1);
          }
        }
#line 237
        config->bytes_per_sample = (int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels;
#line 238
        config->num_channels = (int )WaveHeader.NumChannels;
#line 239
        config->sample_rate = (int32_t )WaveHeader.SampleRate;
#line 240
        goto while_break;
      } else {
        {
#line 243
        bytes_to_copy = (int )((chunk_header.ckSize + 7L) & -8L);
#line 244
        __cil_tmp34 = malloc((unsigned long )bytes_to_copy);
#line 244
        buff = __cil_tmp34;
        }
#line 246
        if (debug_logging_mode) {
          {
#line 247
          error_line("extra unknown chunk \"%c%c%c%c\" of %d bytes", (int )chunk_header.ckID[0],
                     (int )chunk_header.ckID[1], (int )chunk_header.ckID[2], (int )chunk_header.ckID[3],
                     chunk_header.ckSize);
          }
        }
        {
#line 251
        __cil_tmp36 = WavpackAddWrapper(wpc, buff, (uint32_t )bytes_to_copy);
        }
        {
#line 251
        __cil_tmp35 = DoReadFile(infile, buff, (uint32_t )bytes_to_copy, & bcount);
        }
#line 251
        if (! __cil_tmp35) {
          {
          {
          {
#line 255
          __cil_tmp37 = WavpackGetErrorMessage(wpc);
          }
          }
          {
          {
#line 255
          error_line("%s", __cil_tmp37);
          }
          }
          {
          {
#line 256
          free(buff);
          }
          }
          }
#line 257
          return (1);
        } else
#line 251
        if (bcount != (unsigned int )bytes_to_copy) {
          {
          {
          {
#line 255
          __cil_tmp37 = WavpackGetErrorMessage(wpc);
          }
          }
          {
          {
#line 255
          error_line("%s", __cil_tmp37);
          }
          }
          {
          {
#line 256
          free(buff);
          }
          }
          }
#line 257
          return (1);
        } else
#line 251
        if (! (config->qmode & 512)) {
#line 251
          if (! __cil_tmp36) {
            {
            {
            {
#line 255
            __cil_tmp37 = WavpackGetErrorMessage(wpc);
            }
            }
            {
            {
#line 255
            error_line("%s", __cil_tmp37);
            }
            }
            {
            {
#line 256
            free(buff);
            }
            }
            }
#line 257
            return (1);
          }
        }
        {
#line 260
        free(buff);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  __cil_tmp38 = WavpackSetConfiguration64(wpc, config, total_samples, (unsigned char const   *)((void *)0));
  }
#line 264
  if (! __cil_tmp38) {
    {
#line 265
    __cil_tmp39 = WavpackGetErrorMessage(wpc);
#line 265
    error_line("%s: %s", infilename, __cil_tmp39);
    }
#line 266
    return (1);
  }
#line 269
  return (0);
}
}
#line 272 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
int WriteWave64Header(FILE *outfile , WavpackContext *wpc , int64_t total_samples ,
                      int qmode ) 
{ 
  Wave64ChunkHeader datahdr ;
  Wave64ChunkHeader fmthdr ;
  Wave64FileHeader filehdr ;
  WaveHeader wavhdr ;
  uint32_t bcount ;
  int64_t total_data_bytes ;
  int64_t total_file_bytes ;
  int num_channels ;
  int __cil_tmp13 ;
  int32_t channel_mask ;
  int __cil_tmp15 ;
  int32_t sample_rate ;
  uint32_t __cil_tmp17 ;
  int bytes_per_sample ;
  int __cil_tmp19 ;
  int bits_per_sample ;
  int __cil_tmp21 ;
  int format ;
  int __cil_tmp23 ;
  int tmp ;
  int wavhdrsize ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;

  {
  {
#line 280
  __cil_tmp13 = WavpackGetNumChannels(wpc);
#line 280
  num_channels = __cil_tmp13;
#line 281
  __cil_tmp15 = WavpackGetChannelMask(wpc);
#line 281
  channel_mask = __cil_tmp15;
#line 282
  __cil_tmp17 = WavpackGetSampleRate(wpc);
#line 282
  sample_rate = (int32_t )__cil_tmp17;
#line 283
  __cil_tmp19 = WavpackGetBytesPerSample(wpc);
#line 283
  bytes_per_sample = __cil_tmp19;
#line 284
  __cil_tmp21 = WavpackGetBitsPerSample(wpc);
#line 284
  bits_per_sample = __cil_tmp21;
#line 285
  __cil_tmp23 = WavpackGetFloatNormExp(wpc);
  }
#line 285
  if (__cil_tmp23) {
#line 285
    tmp = 3;
  } else {
#line 285
    tmp = 1;
  }
  {
#line 285
  format = tmp;
#line 286
  wavhdrsize = 16;
#line 288
  __cil_tmp26 = WavpackGetFloatNormExp(wpc);
  }
#line 288
  if (format == 3) {
#line 288
    if (__cil_tmp26 != 127) {
      {
#line 289
      error_line("can\'t create valid Wave64 header for non-normalized floating data!");
      }
#line 290
      return (0);
    }
  }
#line 293
  if (total_samples == -1L) {
#line 294
    total_samples = (int64_t )(2147479552 / (bytes_per_sample * num_channels));
  }
  {
#line 296
  total_data_bytes = (total_samples * (long )bytes_per_sample) * (long )num_channels;
#line 297
  memset(& wavhdr, 0, sizeof(wavhdr));
#line 299
  wavhdr.FormatTag = (uint16_t )format;
#line 300
  wavhdr.NumChannels = (uint16_t )num_channels;
#line 301
  wavhdr.SampleRate = (uint32_t )sample_rate;
#line 302
  wavhdr.BytesPerSecond = (uint32_t )((sample_rate * num_channels) * bytes_per_sample);
#line 303
  wavhdr.BlockAlign = (uint16_t )(bytes_per_sample * num_channels);
#line 304
  wavhdr.BitsPerSample = (uint16_t )bits_per_sample;
  }
#line 306
  if (num_channels > 2) {
    _L: /* CIL Label */ 
#line 307
    wavhdrsize = (int )sizeof(wavhdr);
#line 308
    wavhdr.cbSize = (uint16_t )22;
#line 309
    wavhdr.ValidBitsPerSample = (uint16_t )bits_per_sample;
#line 310
    wavhdr.SubFormat = (uint16_t )format;
#line 311
    wavhdr.ChannelMask = channel_mask;
#line 312
    wavhdr.FormatTag = (uint16_t )65534;
#line 313
    wavhdr.BitsPerSample = (uint16_t )(bytes_per_sample * 8);
#line 314
    wavhdr.GUID[4] = (char )16;
#line 315
    wavhdr.GUID[6] = (char )128;
#line 316
    wavhdr.GUID[9] = (char )170;
#line 317
    wavhdr.GUID[11] = (char )56;
#line 318
    wavhdr.GUID[12] = (char )155;
#line 319
    wavhdr.GUID[13] = (char )113;
  } else
#line 306
  if (channel_mask != 5 - num_channels) {
#line 306
    goto _L;
  }
  {
#line 322
  total_file_bytes = (int64_t )((((sizeof(filehdr) + sizeof(fmthdr)) + (unsigned long )wavhdrsize) + sizeof(datahdr)) + (unsigned long )((total_data_bytes + 7L) & -8L));
#line 324
  memcpy((char *)filehdr.ckID, (unsigned char const   *)riff_guid, sizeof(riff_guid));
#line 325
  memcpy((char *)filehdr.formType, (unsigned char const   *)wave_guid, sizeof(wave_guid));
#line 326
  filehdr.ckSize = total_file_bytes;
#line 328
  memcpy((char *)fmthdr.ckID, (unsigned char const   *)fmt_guid, sizeof(fmt_guid));
#line 329
  fmthdr.ckSize = (int64_t )(sizeof(fmthdr) + (unsigned long )wavhdrsize);
#line 331
  memcpy((char *)datahdr.ckID, (unsigned char const   *)data_guid, sizeof(data_guid));
#line 332
  datahdr.ckSize = (int64_t )((unsigned long )total_data_bytes + sizeof(datahdr));
#line 336
  WavpackNativeToLittleEndian(& filehdr, "88D");
#line 337
  WavpackNativeToLittleEndian(& fmthdr, "88D");
#line 338
  WavpackNativeToLittleEndian(& wavhdr, "SSLLSSSSLS");
#line 339
  WavpackNativeToLittleEndian(& datahdr, "88D>dU");
#line 341
  __cil_tmp30 = DoWriteFile(outfile, & datahdr, (uint32_t )sizeof(datahdr), & bcount);
  }
  {
#line 341
  __cil_tmp29 = DoWriteFile(outfile, & wavhdr, (uint32_t )wavhdrsize, & bcount);
  }
  {
#line 341
  __cil_tmp28 = DoWriteFile(outfile, & fmthdr, (uint32_t )sizeof(fmthdr), & bcount);
  }
  {
#line 341
  __cil_tmp27 = DoWriteFile(outfile, & filehdr, (uint32_t )sizeof(filehdr), & bcount);
  }
#line 341
  if (! __cil_tmp27) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 345
    error_line("can\'t write .W64 data, disk probably full!5>dU");
    }
    }
    }
    }
    }
    }
    }
    }
#line 346
    return (0);
  } else
#line 341
  if ((unsigned long )bcount != sizeof(filehdr)) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 345
    error_line("can\'t write .W64 data, disk probably full!5>dU");
    }
    }
    }
    }
    }
    }
    }
    }
#line 346
    return (0);
  } else
#line 341
  if (! __cil_tmp28) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 345
    error_line("can\'t write .W64 data, disk probably full!5>dU");
    }
    }
    }
    }
    }
    }
    }
    }
#line 346
    return (0);
  } else
#line 341
  if ((unsigned long )bcount != sizeof(fmthdr)) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 345
    error_line("can\'t write .W64 data, disk probably full!5>dU");
    }
    }
    }
    }
    }
    }
    }
    }
#line 346
    return (0);
  } else
#line 341
  if (! __cil_tmp29) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 345
    error_line("can\'t write .W64 data, disk probably full!5>dU");
    }
    }
    }
    }
    }
    }
    }
    }
#line 346
    return (0);
  } else
#line 341
  if (bcount != (unsigned int )wavhdrsize) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 345
    error_line("can\'t write .W64 data, disk probably full!5>dU");
    }
    }
    }
    }
    }
    }
    }
    }
#line 346
    return (0);
  } else
#line 341
  if (! __cil_tmp30) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 345
    error_line("can\'t write .W64 data, disk probably full!5>dU");
    }
    }
    }
    }
    }
    }
    }
    }
#line 346
    return (0);
  } else
#line 341
  if ((unsigned long )bcount != sizeof(datahdr)) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 345
    error_line("can\'t write .W64 data, disk probably full!5>dU");
    }
    }
    }
    }
    }
    }
    }
    }
#line 346
    return (0);
  }
#line 349
  return (1);
}
}
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 122
  __cil_tmp3 = __vprintf_chk(1, __fmt, __ap);
  }
#line 122
  return (__cil_tmp3);
}
}
#line 345
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 348
  __cil_tmp5 = __builtin_object_size(__ptr, 0);
  }
#line 348
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 350
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 350
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 350
    if (! __cil_tmp6) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if (! __cil_tmp7) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    } else
#line 350
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 353
      __cil_tmp8 = __builtin_object_size(__ptr, 0);
      }
      }
      {
      {
#line 353
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 353
      return (__cil_tmp9);
    }
    {
#line 356
    __cil_tmp10 = __builtin_object_size(__ptr, 0);
    }
#line 356
    if (__size * __n > __cil_tmp10) {
      {
#line 357
      __cil_tmp11 = __builtin_object_size(__ptr, 0);
#line 357
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 357
      return (__cil_tmp12);
    }
  }
  {
#line 382
  __cil_tmp13 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 382
  return (__cil_tmp13);
}
}
#line 85 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int copy_timestamp(char const   *src_filename , char const   *dst_filename ) 
{ 
  struct stat fileinfo ;
  struct timeval times[2] ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 90
  __cil_tmp6 = strcmp(dst_filename, "-");
  }
  {
#line 90
  __cil_tmp5 = strcmp(src_filename, "-");
  }
#line 90
  if (__cil_tmp5 == 0) {
#line 91
    return (1);
  } else
#line 90
  if (__cil_tmp6 == 0) {
#line 91
    return (1);
  }
  {
#line 93
  __cil_tmp7 = stat(src_filename, & fileinfo);
  }
#line 93
  if (__cil_tmp7) {
#line 94
    return (0);
  }
  {
#line 96
  times[0].tv_sec = fileinfo.st_atim.tv_sec;
#line 97
  times[0].tv_usec = (__suseconds_t )0;
#line 99
  times[1].tv_sec = fileinfo.st_mtim.tv_sec;
#line 100
  times[1].tv_usec = (__suseconds_t )0;
#line 102
  __cil_tmp8 = utimes(dst_filename, (struct timeval [2])((struct timeval *)times));
  }
#line 102
  if (__cil_tmp8) {
#line 103
    return (0);
  }
#line 105
  return (1);
}
}
#line 140 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
char *filespec_ext(char *filespec ) 
{ 
  char *cp ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 142
  __cil_tmp3 = strlen((char const   *)filespec);
#line 142
  cp = filespec + __cil_tmp3;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    cp --;
#line 144
    if (! (cp >= filespec)) {
#line 144
      goto while_break;
    }
#line 146
    if ((int )*cp == 47) {
#line 147
      return ((char *)((void *)0));
    }
#line 149
    if ((int )*cp == 46) {
      {
#line 150
      __cil_tmp5 = strlen((char const   *)(cp + 1));
      }
      {
#line 150
      __cil_tmp4 = strlen((char const   *)(cp + 1));
      }
#line 150
      if (__cil_tmp4) {
#line 150
        if (__cil_tmp5 <= 4UL) {
#line 151
          return (cp);
        } else {
#line 153
          return ((char *)((void *)0));
        }
      } else {
#line 153
        return ((char *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return ((char *)((void *)0));
}
}
#line 173 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
char *filespec_path(char *filespec ) 
{ 
  char *cp ;
  unsigned long __cil_tmp3 ;
  glob_t globs ;
  struct stat fstats ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 175
  __cil_tmp3 = strlen((char const   *)filespec);
#line 175
  cp = filespec + __cil_tmp3;
#line 179
  __cil_tmp6 = filespec_wild(filespec);
  }
#line 179
  if (cp == filespec) {
#line 180
    return ((char *)((void *)0));
  } else
#line 179
  if (__cil_tmp6) {
#line 180
    return ((char *)((void *)0));
  }
#line 182
  cp --;
#line 182
  if ((int )*cp == 47) {
#line 183
    return (filespec);
  }
#line 185
  if (cp == filespec) {
#line 185
    if ((int )*cp == 46) {
      {
#line 186
      __cil_tmp7 = strcat(filespec, "/\225K>dU");
      }
#line 186
      return (__cil_tmp7);
    }
  }
  {
#line 188
  __cil_tmp8 = glob((char const   *)filespec, (1 << 1) | (1 << 2), (int (*)(char const   * ,
                                                                            int  ))((void *)0),
                    & globs);
  }
#line 188
  if (__cil_tmp8 == 0) {
#line 188
    if (globs.gl_pathc > 0UL) {
      {
#line 192
      __cil_tmp9 = stat((char const   *)*(globs.gl_pathv + 0), & fstats);
      }
#line 192
      if (__cil_tmp9 == 0) {
#line 192
        if (fstats.st_mode & 16384U) {
          {
#line 193
          *(filespec + 0) = (char )'\000';
#line 194
          strcat(filespec, (char const   *)*(globs.gl_pathv + 0));
#line 195
          globfree(& globs);
          }
#line 196
          return (filespec);
        }
      }
    }
  }
  {
#line 199
  globfree(& globs);
  }
#line 201
  return ((char *)((void *)0));
}
}
#line 250 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
char *filespec_wild(char *filespec ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 252
  __cil_tmp2 = strpbrk((char const   *)filespec, "*?");
  }
#line 252
  return (__cil_tmp2);
}
}
#line 280 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
char *filespec_name(char *filespec ) 
{ 
  char *cp ;
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
  {
#line 282
  __cil_tmp3 = strlen((char const   *)filespec);
#line 282
  cp = filespec + __cil_tmp3;
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    cp --;
#line 284
    if (! (cp >= filespec)) {
#line 284
      goto while_break;
    }
#line 285
    if ((int )*cp == 47) {
#line 286
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  __cil_tmp4 = strlen((char const   *)(cp + 1));
  }
#line 288
  if (__cil_tmp4) {
#line 289
    return (cp + 1);
  } else {
#line 291
    return ((char *)((void *)0));
  }
}
}
#line 302
static int waiting_input ;
#line 304 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
char yna(void) 
{ 
  char choice ;
  int key ;
  int __cil_tmp3 ;

  {
#line 306
  choice = (char )0;
#line 309
  waiting_input = 1;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 315
    key = fgetc(stdin);
    }
#line 317
    if (key == 3) {
      {
#line 318
      fprintf(stderr, "^C\n");
#line 319
      exit(1);
      }
    } else
#line 321
    if (key == -1) {
      {
#line 322
      fprintf(stderr, "\r\nK>dU");
#line 323
      exit(1);
      }
    } else
#line 325
    if (key == 13) {
      _L: /* CIL Label */ 
#line 326
      if (choice) {
        {
#line 327
        fprintf(stderr, "\r\nK>dU");
#line 328
        fflush(stderr);
        }
#line 329
        goto while_break;
      } else {
        {
#line 332
        fprintf(stderr, "%c", 7);
#line 333
        fflush(stderr);
        }
      }
    } else
#line 325
    if (key == 10) {
#line 325
      goto _L;
    } else
#line 336
    if (key == 89) {
#line 341
      choice = (char )'y';
    } else
#line 336
    if (key == 121) {
#line 341
      choice = (char )'y';
    } else
#line 343
    if (key == 78) {
#line 348
      choice = (char )'n';
    } else
#line 343
    if (key == 110) {
#line 348
      choice = (char )'n';
    } else
#line 350
    if (key == 65) {
#line 355
      choice = (char )'a';
    } else
#line 350
    if (key == 97) {
#line 355
      choice = (char )'a';
    } else {
      {
#line 358
      fprintf(stderr, "%c", 7);
#line 359
      fflush(stderr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  waiting_input = 0;
#line 365
  return (choice);
}
}
#line 475 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
void error_line(char *error  , ...) 
{ 
  char error_msg[512] ;
  va_list argptr ;

  {
  {
#line 480
  error_msg[0] = (char )'\r';
#line 481
  __builtin_va_start((void *)argptr, error);
#line 482
  vsprintf((char *)error_msg + 1, (char const   *)error, (void *)argptr);
#line 483
  __builtin_va_end((void *)argptr);
#line 484
  fputs((char const   *)((char *)error_msg), stderr);
#line 485
  finish_line();
  }
  return;
}
}
#line 568 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
void finish_line(void) 
{ 


  {
  {
#line 570
  fprintf(stderr, "                                \n");
#line 571
  fflush(stderr);
  }
  return;
}
}
#line 580
static int break_flag ;
#line 582 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
static void int_handler(int s ) 
{ 


  {
#line 584
  break_flag = 1;
  return;
}
}
#line 587 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
void setup_break(void) 
{ 
  struct sigaction sigIntHandler ;

  {
  {
#line 591
  break_flag = 0;
#line 592
  sigIntHandler.__sigaction_handler.sa_handler = & int_handler;
#line 593
  sigemptyset(& sigIntHandler.sa_mask);
#line 594
  sigIntHandler.sa_flags = 0;
#line 595
  sigaction(2, & sigIntHandler, (struct sigaction *)((void *)0));
  }
  return;
}
}
#line 602 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int check_break(void) 
{ 


  {
#line 604
  return (break_flag);
}
}
#line 611 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int DoReadFile(FILE *hFile , void *lpBuffer , uint32_t nNumberOfBytesToRead , uint32_t *lpNumberOfBytesRead ) 
{ 
  uint32_t bcount ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 615
  *lpNumberOfBytesRead = (uint32_t )0;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! nNumberOfBytesToRead) {
#line 617
      goto while_break;
    }
    {
#line 618
    __cil_tmp6 = fread((unsigned char *)lpBuffer + *lpNumberOfBytesRead, (unsigned long )1,
                       (unsigned long )nNumberOfBytesToRead, hFile);
#line 618
    bcount = (uint32_t )__cil_tmp6;
    }
#line 620
    if (bcount) {
#line 621
      *lpNumberOfBytesRead += bcount;
#line 622
      nNumberOfBytesToRead -= bcount;
    } else {
#line 625
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 628
  __cil_tmp7 = ferror(hFile);
  }
#line 628
  return (! __cil_tmp7);
}
}
#line 631 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int DoWriteFile(FILE *hFile , void *lpBuffer , uint32_t nNumberOfBytesToWrite , uint32_t *lpNumberOfBytesWritten ) 
{ 
  uint32_t bcount ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 635
  *lpNumberOfBytesWritten = (uint32_t )0;
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! nNumberOfBytesToWrite) {
#line 637
      goto while_break;
    }
    {
#line 638
    __cil_tmp6 = fwrite((unsigned char *)lpBuffer + *lpNumberOfBytesWritten, (unsigned long )1,
                        (unsigned long )nNumberOfBytesToWrite, hFile);
#line 638
    bcount = (uint32_t )__cil_tmp6;
    }
#line 640
    if (bcount) {
#line 641
      *lpNumberOfBytesWritten += bcount;
#line 642
      nNumberOfBytesToWrite -= bcount;
    } else {
#line 645
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 648
  __cil_tmp7 = ferror(hFile);
  }
#line 648
  return (! __cil_tmp7);
}
}
#line 690 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int64_t DoGetFileSize(FILE *hFile ) 
{ 
  struct stat statbuf ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 694
  __cil_tmp3 = fileno(hFile);
#line 694
  __cil_tmp4 = fstat(__cil_tmp3, & statbuf);
  }
#line 694
  if (! hFile) {
#line 695
    return ((int64_t )0);
  } else
#line 694
  if (__cil_tmp4) {
#line 695
    return ((int64_t )0);
  } else
#line 694
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
#line 695
    return ((int64_t )0);
  }
#line 697
  return ((int64_t )statbuf.st_size);
}
}
#line 700 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int64_t DoGetFilePosition(FILE *hFile ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 702
  __cil_tmp2 = ftell(hFile);
  }
#line 702
  return (__cil_tmp2);
}
}
#line 705 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int DoSetFilePositionAbsolute(FILE *hFile , int64_t pos ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 707
  __cil_tmp3 = fseek(hFile, pos, 0);
  }
#line 707
  return (__cil_tmp3);
}
}
#line 710 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int DoSetFilePositionRelative(FILE *hFile , int64_t pos , int mode ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 712
  __cil_tmp4 = fseek(hFile, pos, mode);
  }
#line 712
  return (__cil_tmp4);
}
}
#line 720 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int DoUngetc(int c , FILE *hFile ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 722
  __cil_tmp3 = ungetc(c, hFile);
  }
#line 722
  return (__cil_tmp3);
}
}
#line 725 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int DoCloseHandle(FILE *hFile ) 
{ 
  int __cil_tmp2 ;
  int tmp ;

  {
#line 727
  if (hFile) {
    {
#line 727
    __cil_tmp2 = fclose(hFile);
#line 727
    tmp = ! __cil_tmp2;
    }
  } else {
#line 727
    tmp = 0;
  }
#line 727
  return (tmp);
}
}
#line 730 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int DoTruncateFile(FILE *hFile ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 732
  if (hFile) {
    {
#line 733
    fflush(hFile);
#line 737
    __cil_tmp2 = fileno(hFile);
#line 737
    __cil_tmp3 = ftruncate(__cil_tmp2, (__off_t )0);
    }
#line 737
    return (! __cil_tmp3);
  }
#line 741
  return (0);
}
}
#line 744 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
int DoDeleteFile(char *filename ) 
{ 
  int __cil_tmp2 ;
  int tmp ;

  {
#line 746
  if (filename) {
    {
#line 746
    __cil_tmp2 = remove((char const   *)filename);
#line 746
    tmp = ! __cil_tmp2;
    }
  } else {
#line 746
    tmp = 0;
  }
#line 746
  return (tmp);
}
}
#line 763 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
void DoSetConsoleTitle(char *text ) 
{ 


  {
  {
#line 765
  fprintf(stderr, "\033]0;%s\a", text);
#line 766
  fflush(stderr);
  }
  return;
}
}
#line 53 "/doner/wavpack/wavpack-5.1.0/cli/riff.c"
int ParseRiffHeaderConfig(FILE *infile , char *infilename , char *fourcc , WavpackContext *wpc ,
                          WavpackConfig *config ) 
{ 
  int is_rf64 ;
  int __cil_tmp7 ;
  int got_ds64 ;
  int64_t total_samples ;
  int64_t infilesize ;
  RiffChunkHeader riff_chunk_header ;
  ChunkHeader chunk_header ;
  WaveHeader WaveHeader ;
  DS64Chunk ds64_chunk ;
  uint32_t bcount ;
  int64_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  char *__cil_tmp27 ;
  uint32_t __cil_tmp28 ;
  CS64Chunk cs64_chunk ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  char *__cil_tmp32 ;
  int __cil_tmp33 ;
  int supported ;
  int format ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  char *__cil_tmp38 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp41 ;
  int64_t data_chunk_size ;
  uint64_t tmp___1 ;
  int64_t __cil_tmp44 ;
  int64_t __cil_tmp45 ;
  int bytes_to_copy ;
  char *buff ;
  void *__cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  char *__cil_tmp51 ;
  int __cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
#line 55
  __cil_tmp7 = strncmp((char const   *)fourcc, "RF64", (unsigned long )4);
#line 55
  is_rf64 = ! __cil_tmp7;
  }
  {
#line 55
  got_ds64 = 0;
#line 56
  total_samples = (int64_t )0;
#line 63
  memset(& WaveHeader, 0, sizeof(WaveHeader));
#line 64
  memset(& ds64_chunk, 0, sizeof(ds64_chunk));
#line 65
  infilesize = DoGetFileSize(infile);
  }
#line 67
  if (! is_rf64) {
#line 67
    if ((long long )infilesize >= 4294967296LL) {
#line 67
      if (! (config->qmode & 2048)) {
        {
#line 68
        error_line("can\'t handle .WAV files larger than 4 GB (non-standard)!");
        }
#line 69
        return (1);
      }
    }
  }
  {
#line 72
  memcpy(& riff_chunk_header, fourcc, (unsigned long )4);
#line 74
  __cil_tmp18 = strncmp((char const   *)((char *)riff_chunk_header.formType), "WAVE",
                        (unsigned long )4);
  }
  {
#line 74
  __cil_tmp17 = DoReadFile(infile, (char *)(& riff_chunk_header) + 4, (uint32_t )(sizeof(RiffChunkHeader ) - 4UL),
                           & bcount);
  }
#line 74
  if (! __cil_tmp17) {
    {
    {
    {
#line 76
    error_line("%s is not a valid .WAV file!", infilename);
    }
    }
    }
#line 77
    return (1);
  } else
#line 74
  if ((unsigned long )bcount != sizeof(RiffChunkHeader ) - 4UL) {
    {
    {
    {
#line 76
    error_line("%s is not a valid .WAV file!", infilename);
    }
    }
    }
#line 77
    return (1);
  } else
#line 74
  if (__cil_tmp18) {
    {
    {
    {
#line 76
    error_line("%s is not a valid .WAV file!", infilename);
    }
    }
    }
#line 77
    return (1);
  } else {
    {
#line 79
    __cil_tmp19 = WavpackAddWrapper(wpc, & riff_chunk_header, (uint32_t )sizeof(RiffChunkHeader ));
    }
#line 79
    if (! (config->qmode & 512)) {
#line 79
      if (! __cil_tmp19) {
        {
#line 81
        __cil_tmp20 = WavpackGetErrorMessage(wpc);
#line 81
        error_line("%s", __cil_tmp20);
        }
#line 82
        return (1);
      }
    }
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    __cil_tmp21 = DoReadFile(infile, & chunk_header, (uint32_t )sizeof(ChunkHeader ),
                             & bcount);
    }
#line 89
    if (! __cil_tmp21) {
      {
      {
#line 91
      error_line("%s is not a valid .WAV file!", infilename);
      }
      }
#line 92
      return (1);
    } else
#line 89
    if ((unsigned long )bcount != sizeof(ChunkHeader )) {
      {
      {
#line 91
      error_line("%s is not a valid .WAV file!", infilename);
      }
      }
#line 92
      return (1);
    } else {
      {
#line 94
      __cil_tmp22 = WavpackAddWrapper(wpc, & chunk_header, (uint32_t )sizeof(ChunkHeader ));
      }
#line 94
      if (! (config->qmode & 512)) {
#line 94
        if (! __cil_tmp22) {
          {
#line 96
          __cil_tmp23 = WavpackGetErrorMessage(wpc);
#line 96
          error_line("%s", __cil_tmp23);
          }
#line 97
          return (1);
        }
      }
    }
    {
#line 100
    WavpackLittleEndianToNative(& chunk_header, "4L");
#line 102
    __cil_tmp24 = strncmp((char const   *)((char *)chunk_header.ckID), "ds64", (unsigned long )4);
    }
#line 102
    if (! __cil_tmp24) {
      {
#line 103
      __cil_tmp25 = DoReadFile(infile, & ds64_chunk, chunk_header.ckSize, & bcount);
      }
#line 103
      if ((unsigned long )chunk_header.ckSize < sizeof(DS64Chunk )) {
        {
        {
        {
#line 106
        error_line("%s is not a valid .WAV file!", infilename);
        }
        }
        }
#line 107
        return (1);
      } else
#line 103
      if (! __cil_tmp25) {
        {
        {
        {
#line 106
        error_line("%s is not a valid .WAV file!", infilename);
        }
        }
        }
#line 107
        return (1);
      } else
#line 103
      if (bcount != chunk_header.ckSize) {
        {
        {
        {
#line 106
        error_line("%s is not a valid .WAV file!", infilename);
        }
        }
        }
#line 107
        return (1);
      } else {
        {
#line 109
        __cil_tmp26 = WavpackAddWrapper(wpc, & ds64_chunk, chunk_header.ckSize);
        }
#line 109
        if (! (config->qmode & 512)) {
#line 109
          if (! __cil_tmp26) {
            {
#line 111
            __cil_tmp27 = WavpackGetErrorMessage(wpc);
#line 111
            error_line("%s", __cil_tmp27);
            }
#line 112
            return (1);
          }
        }
      }
      {
#line 115
      got_ds64 = 1;
#line 116
      WavpackLittleEndianToNative(& ds64_chunk, "DDDL");
      }
#line 118
      if (debug_logging_mode) {
        {
#line 119
        error_line("DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d",
                   (long long )ds64_chunk.riffSize64, (long long )ds64_chunk.dataSize64,
                   (long long )ds64_chunk.sampleCount64, ds64_chunk.tableLength);
        }
      }
#line 123
      if ((unsigned long )ds64_chunk.tableLength * sizeof(CS64Chunk ) != (unsigned long )chunk_header.ckSize - sizeof(DS64Chunk )) {
        {
#line 124
        error_line("%s is not a valid .WAV file!", infilename);
        }
#line 125
        return (1);
      }
      {
#line 128
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 128
        __cil_tmp28 = ds64_chunk.tableLength;
#line 128
        (ds64_chunk.tableLength) --;
#line 128
        if (! __cil_tmp28) {
#line 128
          goto while_break___0;
        }
        {
#line 130
        __cil_tmp31 = WavpackAddWrapper(wpc, & cs64_chunk, (uint32_t )sizeof(CS64Chunk ));
        }
        {
#line 130
        __cil_tmp30 = DoReadFile(infile, & cs64_chunk, (uint32_t )sizeof(CS64Chunk ),
                                 & bcount);
        }
#line 130
        if (! __cil_tmp30) {
          {
          {
          {
#line 134
          __cil_tmp32 = WavpackGetErrorMessage(wpc);
          }
          }
          {
          {
#line 134
          error_line("%s", __cil_tmp32);
          }
          }
          }
#line 135
          return (1);
        } else
#line 130
        if ((unsigned long )bcount != sizeof(CS64Chunk )) {
          {
          {
          {
#line 134
          __cil_tmp32 = WavpackGetErrorMessage(wpc);
          }
          }
          {
          {
#line 134
          error_line("%s", __cil_tmp32);
          }
          }
          }
#line 135
          return (1);
        } else
#line 130
        if (! (config->qmode & 512)) {
#line 130
          if (! __cil_tmp31) {
            {
            {
            {
#line 134
            __cil_tmp32 = WavpackGetErrorMessage(wpc);
            }
            }
            {
            {
#line 134
            error_line("%s", __cil_tmp32);
            }
            }
            }
#line 135
            return (1);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 139
      __cil_tmp33 = strncmp((char const   *)((char *)chunk_header.ckID), "fmt ", (unsigned long )4);
      }
#line 139
      if (! __cil_tmp33) {
        {
#line 140
        supported = 1;
#line 142
        __cil_tmp36 = DoReadFile(infile, & WaveHeader, chunk_header.ckSize, & bcount);
        }
#line 142
        if (chunk_header.ckSize < 16U) {
          {
          {
          {
          {
#line 145
          error_line("%s is not a valid .WAV file!", infilename);
          }
          }
          }
          }
#line 146
          return (1);
        } else
#line 142
        if ((unsigned long )chunk_header.ckSize > sizeof(WaveHeader)) {
          {
          {
          {
          {
#line 145
          error_line("%s is not a valid .WAV file!", infilename);
          }
          }
          }
          }
#line 146
          return (1);
        } else
#line 142
        if (! __cil_tmp36) {
          {
          {
          {
          {
#line 145
          error_line("%s is not a valid .WAV file!", infilename);
          }
          }
          }
          }
#line 146
          return (1);
        } else
#line 142
        if (bcount != chunk_header.ckSize) {
          {
          {
          {
          {
#line 145
          error_line("%s is not a valid .WAV file!", infilename);
          }
          }
          }
          }
#line 146
          return (1);
        } else {
          {
#line 148
          __cil_tmp37 = WavpackAddWrapper(wpc, & WaveHeader, chunk_header.ckSize);
          }
#line 148
          if (! (config->qmode & 512)) {
#line 148
            if (! __cil_tmp37) {
              {
#line 150
              __cil_tmp38 = WavpackGetErrorMessage(wpc);
#line 150
              error_line("%s", __cil_tmp38);
              }
#line 151
              return (1);
            }
          }
        }
        {
#line 154
        WavpackLittleEndianToNative(& WaveHeader, "SSLLSSSSLS");
        }
#line 156
        if (debug_logging_mode) {
          {
#line 157
          error_line("format tag size = %d", chunk_header.ckSize);
#line 158
          error_line("FormatTag = %x, NumChannels = %d, BitsPerSample = %d", (int )WaveHeader.FormatTag,
                     (int )WaveHeader.NumChannels, (int )WaveHeader.BitsPerSample);
#line 160
          error_line("BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d", (int )WaveHeader.BlockAlign,
                     WaveHeader.SampleRate, WaveHeader.BytesPerSecond);
          }
#line 163
          if (chunk_header.ckSize > 16U) {
            {
#line 164
            error_line("cbSize = %d, ValidBitsPerSample = %d", (int )WaveHeader.cbSize,
                       (int )WaveHeader.ValidBitsPerSample);
            }
          }
#line 167
          if (chunk_header.ckSize > 20U) {
            {
#line 168
            error_line("ChannelMask = %x, SubFormat = %d\230\001", WaveHeader.ChannelMask,
                       (int )WaveHeader.SubFormat);
            }
          }
        }
#line 172
        if (chunk_header.ckSize > 16U) {
#line 172
          if ((int )WaveHeader.cbSize == 2) {
#line 173
            config->qmode |= 256;
          }
        }
#line 175
        if ((int )WaveHeader.FormatTag == 65534 && chunk_header.ckSize == 40U) {
#line 175
          tmp = (int )WaveHeader.SubFormat;
        } else {
#line 175
          tmp = (int )WaveHeader.FormatTag;
        }
#line 175
        format = tmp;
#line 178
        if (chunk_header.ckSize == 40U && (int )WaveHeader.ValidBitsPerSample) {
#line 178
          tmp___0 = (int )WaveHeader.ValidBitsPerSample;
        } else {
#line 178
          tmp___0 = (int )WaveHeader.BitsPerSample;
        }
#line 178
        config->bits_per_sample = tmp___0;
#line 181
        if (format != 1) {
#line 181
          if (format != 3) {
#line 182
            supported = 0;
          }
        }
#line 184
        if (format == 3) {
#line 184
          if (config->bits_per_sample != 32) {
#line 185
            supported = 0;
          }
        }
#line 187
        if (! WaveHeader.NumChannels) {
#line 191
          supported = 0;
        } else
#line 187
        if ((int )WaveHeader.NumChannels > 256) {
#line 191
          supported = 0;
        } else
#line 187
        if ((int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8) {
#line 191
          supported = 0;
        } else
#line 187
        if ((int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels > 4) {
#line 191
          supported = 0;
        } else
#line 187
        if ((int )WaveHeader.BlockAlign % (int )WaveHeader.NumChannels) {
#line 191
          supported = 0;
        }
#line 193
        if (config->bits_per_sample < 1) {
#line 194
          supported = 0;
        } else
#line 193
        if (config->bits_per_sample > 32) {
#line 194
          supported = 0;
        }
#line 196
        if (! supported) {
          {
#line 197
          error_line("%s is an unsupported .WAV format!", infilename);
          }
#line 198
          return (1);
        }
#line 201
        if (chunk_header.ckSize < 40U) {
#line 202
          if (! config->channel_mask) {
#line 202
            if (! (config->qmode & 1024)) {
#line 203
              if ((int )WaveHeader.NumChannels <= 2) {
#line 204
                config->channel_mask = 5 - (int )WaveHeader.NumChannels;
              } else
#line 205
              if ((int )WaveHeader.NumChannels <= 18) {
#line 206
                config->channel_mask = (1 << (int )WaveHeader.NumChannels) - 1;
              } else {
#line 208
                config->channel_mask = 262143;
              }
            }
          }
        } else
#line 211
        if (WaveHeader.ChannelMask) {
#line 211
          if (config->channel_mask) {
            {
            {
#line 212
            error_line("this WAV file already has channel order information!");
            }
            }
#line 213
            return (1);
          } else
#line 211
          if (config->qmode & 1024) {
            {
            {
#line 212
            error_line("this WAV file already has channel order information!");
            }
            }
#line 213
            return (1);
          } else {
#line 211
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 215
        if (WaveHeader.ChannelMask) {
#line 216
          config->channel_mask = WaveHeader.ChannelMask;
        }
#line 218
        if (format == 3) {
#line 219
          config->float_norm_exp = 127;
        } else
#line 220
        if (config->qmode & 256) {
#line 220
          if ((int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels == 4) {
#line 222
            if ((int )WaveHeader.BitsPerSample == 24) {
#line 223
              config->float_norm_exp = 150;
            } else
#line 224
            if ((int )WaveHeader.BitsPerSample == 32) {
#line 225
              config->float_norm_exp = 142;
            }
          }
        }
#line 228
        if (debug_logging_mode) {
#line 229
          if (config->float_norm_exp == 127) {
            {
#line 230
            error_line("data format: normalized 32-bit floating point");
            }
          } else
#line 231
          if (config->float_norm_exp) {
            {
#line 232
            error_line("data format: 32-bit floating point (Audition %d:%d float type 1)\230\001",
                       config->float_norm_exp - 126, 150 - config->float_norm_exp);
            }
          } else {
            {
#line 235
            error_line("data format: %d-bit integers stored in %d byte(s)", config->bits_per_sample,
                       (int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels);
            }
          }
        }
      } else {
        {
#line 239
        __cil_tmp41 = strncmp((char const   *)((char *)chunk_header.ckID), "data",
                              (unsigned long )4);
        }
#line 239
        if (! __cil_tmp41) {
#line 241
          if (got_ds64 && chunk_header.ckSize == 4294967295U) {
#line 241
            tmp___1 = ds64_chunk.dataSize64;
          } else {
#line 241
            tmp___1 = (unsigned long )chunk_header.ckSize;
          }
#line 241
          data_chunk_size = (int64_t )tmp___1;
#line 245
          if (! WaveHeader.NumChannels) {
            {
            {
#line 246
            error_line("%s is not a valid .WAV file!", infilename);
            }
            }
#line 247
            return (1);
          } else
#line 245
          if (is_rf64) {
#line 245
            if (! got_ds64) {
              {
              {
#line 246
              error_line("%s is not a valid .WAV file!", infilename);
              }
              }
#line 247
              return (1);
            }
          }
#line 250
          if (infilesize) {
#line 250
            if (! (config->qmode & 2048)) {
#line 250
              if (infilesize - data_chunk_size > 16777216L) {
                {
#line 251
                error_line("this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!");
                }
#line 252
                return (1);
              }
            }
          }
#line 255
          if (config->qmode & 2048) {
            {
#line 256
            __cil_tmp44 = DoGetFilePosition(infile);
            }
#line 256
            if (infilesize) {
#line 256
              if (__cil_tmp44 != -1L) {
                {
#line 257
                __cil_tmp45 = DoGetFilePosition(infile);
#line 257
                total_samples = (infilesize - __cil_tmp45) / (long )WaveHeader.BlockAlign;
                }
              } else {
#line 259
                total_samples = (int64_t )(- 1);
              }
            } else {
#line 259
              total_samples = (int64_t )(- 1);
            }
          } else {
#line 262
            total_samples = data_chunk_size / (long )WaveHeader.BlockAlign;
#line 264
            if (got_ds64) {
#line 264
              if ((unsigned long )total_samples != ds64_chunk.sampleCount64) {
                {
#line 265
                error_line("%s is not a valid .WAV file!", infilename);
                }
#line 266
                return (1);
              }
            }
#line 269
            if (! total_samples) {
              {
#line 270
              error_line("this .WAV file has no audio samples, probably is corrupt!");
              }
#line 271
              return (1);
            }
#line 274
            if ((long long )total_samples > (1LL << 40) - 257LL) {
              {
#line 275
              error_line("%s has too many samples for WavPack!", infilename);
              }
#line 276
              return (1);
            }
          }
#line 280
          config->bytes_per_sample = (int )WaveHeader.BlockAlign / (int )WaveHeader.NumChannels;
#line 281
          config->num_channels = (int )WaveHeader.NumChannels;
#line 282
          config->sample_rate = (int32_t )WaveHeader.SampleRate;
#line 283
          goto while_break;
        } else {
          {
#line 287
          bytes_to_copy = (int )((long )(chunk_header.ckSize + 1U) & -2L);
#line 288
          __cil_tmp48 = malloc((unsigned long )bytes_to_copy);
#line 288
          buff = __cil_tmp48;
          }
#line 290
          if (debug_logging_mode) {
            {
#line 291
            error_line("extra unknown chunk \"%c%c%c%c\" of %d bytes", (int )chunk_header.ckID[0],
                       (int )chunk_header.ckID[1], (int )chunk_header.ckID[2], (int )chunk_header.ckID[3],
                       chunk_header.ckSize);
            }
          }
          {
#line 295
          __cil_tmp50 = WavpackAddWrapper(wpc, buff, (uint32_t )bytes_to_copy);
          }
          {
#line 295
          __cil_tmp49 = DoReadFile(infile, buff, (uint32_t )bytes_to_copy, & bcount);
          }
#line 295
          if (! __cil_tmp49) {
            {
            {
            {
#line 299
            __cil_tmp51 = WavpackGetErrorMessage(wpc);
            }
            }
            {
            {
#line 299
            error_line("%s", __cil_tmp51);
            }
            }
            {
            {
#line 300
            free(buff);
            }
            }
            }
#line 301
            return (1);
          } else
#line 295
          if (bcount != (unsigned int )bytes_to_copy) {
            {
            {
            {
#line 299
            __cil_tmp51 = WavpackGetErrorMessage(wpc);
            }
            }
            {
            {
#line 299
            error_line("%s", __cil_tmp51);
            }
            }
            {
            {
#line 300
            free(buff);
            }
            }
            }
#line 301
            return (1);
          } else
#line 295
          if (! (config->qmode & 512)) {
#line 295
            if (! __cil_tmp50) {
              {
              {
              {
#line 299
              __cil_tmp51 = WavpackGetErrorMessage(wpc);
              }
              }
              {
              {
#line 299
              error_line("%s", __cil_tmp51);
              }
              }
              {
              {
#line 300
              free(buff);
              }
              }
              }
#line 301
              return (1);
            }
          }
          {
#line 304
          free(buff);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  __cil_tmp52 = WavpackSetConfiguration64(wpc, config, total_samples, (unsigned char const   *)((void *)0));
  }
#line 308
  if (! __cil_tmp52) {
    {
#line 309
    __cil_tmp53 = WavpackGetErrorMessage(wpc);
#line 309
    error_line("%s: %s", infilename, __cil_tmp53);
    }
#line 310
    return (1);
  }
#line 313
  return (0);
}
}
#line 316 "/doner/wavpack/wavpack-5.1.0/cli/riff.c"
int WriteRiffHeader(FILE *outfile , WavpackContext *wpc , int64_t total_samples ,
                    int qmode ) 
{ 
  int do_rf64 ;
  int write_junk ;
  ChunkHeader ds64hdr ;
  ChunkHeader datahdr ;
  ChunkHeader fmthdr ;
  RiffChunkHeader riffhdr ;
  DS64Chunk ds64_chunk ;
  JunkChunk junkchunk ;
  WaveHeader wavhdr ;
  uint32_t bcount ;
  int64_t total_data_bytes ;
  int64_t total_riff_bytes ;
  int num_channels ;
  int __cil_tmp18 ;
  int32_t channel_mask ;
  int __cil_tmp20 ;
  int32_t sample_rate ;
  uint32_t __cil_tmp22 ;
  int bytes_per_sample ;
  int __cil_tmp24 ;
  int bits_per_sample ;
  int __cil_tmp26 ;
  int format ;
  int __cil_tmp28 ;
  int tmp ;
  int wavhdrsize ;
  int __cil_tmp31 ;
  char const   *tmp___0 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;

  {
#line 318
  do_rf64 = 0;
  {
#line 318
  write_junk = 1;
#line 327
  __cil_tmp18 = WavpackGetNumChannels(wpc);
#line 327
  num_channels = __cil_tmp18;
#line 328
  __cil_tmp20 = WavpackGetChannelMask(wpc);
#line 328
  channel_mask = __cil_tmp20;
#line 329
  __cil_tmp22 = WavpackGetSampleRate(wpc);
#line 329
  sample_rate = (int32_t )__cil_tmp22;
#line 330
  __cil_tmp24 = WavpackGetBytesPerSample(wpc);
#line 330
  bytes_per_sample = __cil_tmp24;
#line 331
  __cil_tmp26 = WavpackGetBitsPerSample(wpc);
#line 331
  bits_per_sample = __cil_tmp26;
#line 332
  __cil_tmp28 = WavpackGetFloatNormExp(wpc);
  }
#line 332
  if (__cil_tmp28) {
#line 332
    tmp = 3;
  } else {
#line 332
    tmp = 1;
  }
  {
#line 332
  format = tmp;
#line 333
  wavhdrsize = 16;
#line 335
  __cil_tmp31 = WavpackGetFloatNormExp(wpc);
  }
#line 335
  if (format == 3) {
#line 335
    if (__cil_tmp31 != 127) {
      {
#line 336
      error_line("can\'t create valid RIFF wav header for non-normalized floating data!dU");
      }
#line 337
      return (0);
    }
  }
#line 340
  if (total_samples == -1L) {
#line 341
    total_samples = (int64_t )(2147479552 / (bytes_per_sample * num_channels));
  }
#line 343
  total_data_bytes = (total_samples * (long )bytes_per_sample) * (long )num_channels;
#line 345
  if (total_data_bytes > 4278190080L) {
#line 346
    if (debug_logging_mode) {
      {
#line 347
      error_line("total_data_bytes = %lld, so rf64\230\001", total_data_bytes);
      }
    }
#line 348
    write_junk = 0;
#line 349
    do_rf64 = 1;
  } else
#line 351
  if (debug_logging_mode) {
    {
#line 352
    error_line("total_data_bytes = %lld, so riff\230\001", total_data_bytes);
    }
  }
  {
#line 354
  memset(& wavhdr, 0, sizeof(wavhdr));
#line 356
  wavhdr.FormatTag = (uint16_t )format;
#line 357
  wavhdr.NumChannels = (uint16_t )num_channels;
#line 358
  wavhdr.SampleRate = (uint32_t )sample_rate;
#line 359
  wavhdr.BytesPerSecond = (uint32_t )((sample_rate * num_channels) * bytes_per_sample);
#line 360
  wavhdr.BlockAlign = (uint16_t )(bytes_per_sample * num_channels);
#line 361
  wavhdr.BitsPerSample = (uint16_t )bits_per_sample;
  }
#line 363
  if (num_channels > 2) {
    _L: /* CIL Label */ 
#line 364
    wavhdrsize = (int )sizeof(wavhdr);
#line 365
    wavhdr.cbSize = (uint16_t )22;
#line 366
    wavhdr.ValidBitsPerSample = (uint16_t )bits_per_sample;
#line 367
    wavhdr.SubFormat = (uint16_t )format;
#line 368
    wavhdr.ChannelMask = channel_mask;
#line 369
    wavhdr.FormatTag = (uint16_t )65534;
#line 370
    wavhdr.BitsPerSample = (uint16_t )(bytes_per_sample * 8);
#line 371
    wavhdr.GUID[4] = (char )16;
#line 372
    wavhdr.GUID[6] = (char )128;
#line 373
    wavhdr.GUID[9] = (char )170;
#line 374
    wavhdr.GUID[11] = (char )56;
#line 375
    wavhdr.GUID[12] = (char )155;
#line 376
    wavhdr.GUID[13] = (char )113;
  } else
#line 363
  if (channel_mask != 5 - num_channels) {
#line 363
    goto _L;
  }
#line 379
  if (do_rf64) {
#line 379
    tmp___0 = "RF64dU";
  } else {
#line 379
    tmp___0 = "RIFFdU";
  }
  {
#line 379
  strncpy((char *)riffhdr.ckID, tmp___0, sizeof(riffhdr.ckID));
#line 380
  strncpy((char *)riffhdr.formType, "WAVEdU", sizeof(riffhdr.formType));
#line 381
  total_riff_bytes = (int64_t )(((sizeof(riffhdr) + (unsigned long )wavhdrsize) + sizeof(datahdr)) + (unsigned long )((total_data_bytes + 1L) & -2L));
  }
#line 382
  if (do_rf64) {
#line 382
    total_riff_bytes += sizeof(ds64hdr) + sizeof(ds64_chunk);
  }
#line 383
  if (write_junk) {
#line 383
    total_riff_bytes += sizeof(junkchunk);
  }
  {
#line 384
  strncpy((char *)fmthdr.ckID, "fmt ", sizeof(fmthdr.ckID));
#line 385
  strncpy((char *)datahdr.ckID, "datadU", sizeof(datahdr.ckID));
#line 386
  fmthdr.ckSize = (uint32_t )wavhdrsize;
  }
#line 388
  if (write_junk) {
    {
#line 389
    memset(& junkchunk, 0, sizeof(junkchunk));
#line 390
    strncpy((char *)junkchunk.ckID, "junkdU", sizeof(junkchunk.ckID));
#line 391
    junkchunk.ckSize = (uint32_t )(sizeof(junkchunk) - 8UL);
#line 392
    WavpackNativeToLittleEndian(& junkchunk, "4L");
    }
  }
#line 395
  if (do_rf64) {
    {
#line 396
    strncpy((char *)ds64hdr.ckID, "ds64", sizeof(ds64hdr.ckID));
#line 397
    ds64hdr.ckSize = (uint32_t )sizeof(ds64_chunk);
#line 398
    memset(& ds64_chunk, 0, sizeof(ds64_chunk));
#line 399
    ds64_chunk.riffSize64 = (uint64_t )total_riff_bytes;
#line 400
    ds64_chunk.dataSize64 = (uint64_t )total_data_bytes;
#line 401
    ds64_chunk.sampleCount64 = (uint64_t )total_samples;
#line 402
    riffhdr.ckSize = (uint32_t )(- 1);
#line 403
    datahdr.ckSize = (uint32_t )(- 1);
#line 404
    WavpackNativeToLittleEndian(& ds64hdr, "4Lg>dU");
#line 405
    WavpackNativeToLittleEndian(& ds64_chunk, "DDDLdU");
    }
  } else {
#line 408
    riffhdr.ckSize = (uint32_t )total_riff_bytes;
#line 409
    datahdr.ckSize = (uint32_t )total_data_bytes;
  }
  {
#line 414
  WavpackNativeToLittleEndian(& riffhdr, "4Lh>dU");
#line 415
  WavpackNativeToLittleEndian(& fmthdr, "4L");
#line 416
  WavpackNativeToLittleEndian(& wavhdr, "SSLLSSSSLSh>dU");
#line 417
  WavpackNativeToLittleEndian(& datahdr, "4Lh>dU");
#line 419
  __cil_tmp39 = DoWriteFile(outfile, & datahdr, (uint32_t )sizeof(datahdr), & bcount);
  }
  {
#line 419
  __cil_tmp38 = DoWriteFile(outfile, & wavhdr, (uint32_t )wavhdrsize, & bcount);
  }
  {
#line 419
  __cil_tmp37 = DoWriteFile(outfile, & fmthdr, (uint32_t )sizeof(fmthdr), & bcount);
  }
  {
#line 419
  __cil_tmp36 = DoWriteFile(outfile, & junkchunk, (uint32_t )sizeof(junkchunk), & bcount);
  }
  {
#line 419
  __cil_tmp35 = DoWriteFile(outfile, & ds64_chunk, (uint32_t )sizeof(ds64_chunk),
                            & bcount);
  }
  {
#line 419
  __cil_tmp34 = DoWriteFile(outfile, & ds64hdr, (uint32_t )sizeof(ds64hdr), & bcount);
  }
  {
#line 419
  __cil_tmp33 = DoWriteFile(outfile, & riffhdr, (uint32_t )sizeof(riffhdr), & bcount);
  }
#line 419
  if (! __cil_tmp33) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 426
    error_line("can\'t write .WAV data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 427
    return (0);
  } else
#line 419
  if ((unsigned long )bcount != sizeof(riffhdr)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 426
    error_line("can\'t write .WAV data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 427
    return (0);
  } else
#line 419
  if (do_rf64) {
#line 419
    if (! __cil_tmp34) {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
#line 426
      error_line("can\'t write .WAV data, disk probably full!");
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
#line 427
      return (0);
    } else
#line 419
    if ((unsigned long )bcount != sizeof(ds64hdr)) {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
#line 426
      error_line("can\'t write .WAV data, disk probably full!");
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
#line 427
      return (0);
    } else {
#line 419
      goto _L___25;
    }
  } else
  _L___25: /* CIL Label */ 
#line 419
  if (do_rf64) {
#line 419
    if (! __cil_tmp35) {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
#line 426
      error_line("can\'t write .WAV data, disk probably full!");
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
#line 427
      return (0);
    } else
#line 419
    if ((unsigned long )bcount != sizeof(ds64_chunk)) {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
#line 426
      error_line("can\'t write .WAV data, disk probably full!");
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
#line 427
      return (0);
    } else {
#line 419
      goto _L___24;
    }
  } else
  _L___24: /* CIL Label */ 
#line 419
  if (write_junk) {
#line 419
    if (! __cil_tmp36) {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
#line 426
      error_line("can\'t write .WAV data, disk probably full!");
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
#line 427
      return (0);
    } else
#line 419
    if ((unsigned long )bcount != sizeof(junkchunk)) {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
      {
#line 426
      error_line("can\'t write .WAV data, disk probably full!");
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
#line 427
      return (0);
    } else {
#line 419
      goto _L___23;
    }
  } else
  _L___23: /* CIL Label */ 
#line 419
  if (! __cil_tmp37) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 426
    error_line("can\'t write .WAV data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 427
    return (0);
  } else
#line 419
  if ((unsigned long )bcount != sizeof(fmthdr)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 426
    error_line("can\'t write .WAV data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 427
    return (0);
  } else
#line 419
  if (! __cil_tmp38) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 426
    error_line("can\'t write .WAV data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 427
    return (0);
  } else
#line 419
  if (bcount != (unsigned int )wavhdrsize) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 426
    error_line("can\'t write .WAV data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 427
    return (0);
  } else
#line 419
  if (! __cil_tmp39) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 426
    error_line("can\'t write .WAV data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 427
    return (0);
  } else
#line 419
  if ((unsigned long )bcount != sizeof(datahdr)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 426
    error_line("can\'t write .WAV data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 427
    return (0);
  }
#line 430
  return (1);
}
}
#line 56 "/doner/wavpack/wavpack-5.1.0/cli/md5.c"
void MD5Init(struct MD5Context *ctx ) 
{ 


  {
#line 59
  ctx->buf[0] = (uint32 )1732584193;
#line 60
  ctx->buf[1] = 4023233417U;
#line 61
  ctx->buf[2] = 2562383102U;
#line 62
  ctx->buf[3] = (uint32 )271733878;
#line 64
  ctx->bits[0] = (uint32 )0;
#line 65
  ctx->bits[1] = (uint32 )0;
  return;
}
}
#line 72 "/doner/wavpack/wavpack-5.1.0/cli/md5.c"
void MD5Update(struct MD5Context *ctx , unsigned char *buf , unsigned int len ) 
{ 
  uint32 t ;
  uint32 __cil_tmp5 ;
  unsigned char *p ;

  {
#line 79
  t = ctx->bits[0];
#line 80
  ctx->bits[0] = t + ((uint32 )len << 3);
#line 80
  if (ctx->bits[0] < t) {
#line 81
    (ctx->bits[1]) ++;
  }
#line 82
  ctx->bits[1] += len >> 29;
#line 84
  t = (t >> 3) & 63U;
#line 88
  if (t) {
#line 89
    p = (unsigned char *)((unsigned char *)ctx->in) + t;
#line 91
    t = 64U - t;
#line 92
    if (len < t) {
      {
#line 93
      memcpy(p, buf, (unsigned long )len);
      }
#line 94
      return;
    }
    {
#line 96
    memcpy(p, buf, (unsigned long )t);
#line 98
    MD5Transform((uint32 *)ctx->buf, (uint32 *)((unsigned char *)ctx->in));
#line 99
    buf += t;
#line 100
    len -= t;
    }
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (len >= 64U)) {
#line 104
      goto while_break;
    }
    {
#line 105
    memcpy((unsigned char *)ctx->in, buf, (unsigned long )64);
#line 107
    MD5Transform((uint32 *)ctx->buf, (uint32 *)((unsigned char *)ctx->in));
#line 108
    buf += 64;
#line 109
    len -= (unsigned int )64;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  memcpy((unsigned char *)ctx->in, buf, (unsigned long )len);
  }
  return;
}
}
#line 121 "/doner/wavpack/wavpack-5.1.0/cli/md5.c"
void MD5Final(unsigned char digest[16] , struct MD5Context *ctx ) 
{ 
  uint32 *ptr32 ;
  unsigned int count ;
  unsigned char *p ;
  unsigned char *__cil_tmp6 ;

  {
#line 124
  ptr32 = (uint32 *)((unsigned char *)ctx->in);
#line 129
  count = (ctx->bits[0] >> 3) & 63U;
#line 133
  p = (unsigned char *)ctx->in + count;
#line 134
  __cil_tmp6 = p;
#line 134
  p ++;
#line 134
  *__cil_tmp6 = (unsigned char )128;
#line 137
  count = 63U - count;
#line 140
  if (count < 8U) {
    {
#line 142
    memset(p, 0, (unsigned long )count);
#line 144
    MD5Transform((uint32 *)ctx->buf, ptr32);
#line 147
    memset((unsigned char *)ctx->in, 0, (unsigned long )56);
    }
  } else {
    {
#line 150
    memset(p, 0, (unsigned long )(count - 8U));
    }
  }
  {
#line 155
  *(ptr32 + 14) = ctx->bits[0];
#line 156
  *(ptr32 + 15) = ctx->bits[1];
#line 158
  MD5Transform((uint32 *)ctx->buf, ptr32);
#line 160
  memcpy(digest, (uint32 *)ctx->buf, (unsigned long )16);
#line 161
  memset(ctx, 0, sizeof(*ctx));
  }
  return;
}
}
#line 182 "/doner/wavpack/wavpack-5.1.0/cli/md5.c"
void MD5Transform(uint32 buf[4] , uint32 in[16] ) 
{ 
  register uint32 a ;
  register uint32 b ;
  register uint32 c ;
  register uint32 d ;

  {
#line 187
  a = buf[0];
#line 188
  b = buf[1];
#line 189
  c = buf[2];
#line 190
  d = buf[3];
#line 192
  a += b;
#line 192
  a = (a << 7) | (a >> 25);
#line 192
  a += ((d ^ (b & (c ^ d))) + in[0]) + 3614090360U;
#line 193
  d += a;
#line 193
  d = (d << 12) | (d >> 20);
#line 193
  d += ((c ^ (a & (b ^ c))) + in[1]) + 3905402710U;
#line 194
  c += d;
#line 194
  c = (c << 17) | (c >> 15);
#line 194
  c += ((b ^ (d & (a ^ b))) + in[2]) + 606105819U;
#line 195
  b += c;
#line 195
  b = (b << 22) | (b >> 10);
#line 195
  b += ((a ^ (c & (d ^ a))) + in[3]) + 3250441966U;
#line 196
  a += b;
#line 196
  a = (a << 7) | (a >> 25);
#line 196
  a += ((d ^ (b & (c ^ d))) + in[4]) + 4118548399U;
#line 197
  d += a;
#line 197
  d = (d << 12) | (d >> 20);
#line 197
  d += ((c ^ (a & (b ^ c))) + in[5]) + 1200080426U;
#line 198
  c += d;
#line 198
  c = (c << 17) | (c >> 15);
#line 198
  c += ((b ^ (d & (a ^ b))) + in[6]) + 2821735955U;
#line 199
  b += c;
#line 199
  b = (b << 22) | (b >> 10);
#line 199
  b += ((a ^ (c & (d ^ a))) + in[7]) + 4249261313U;
#line 200
  a += b;
#line 200
  a = (a << 7) | (a >> 25);
#line 200
  a += ((d ^ (b & (c ^ d))) + in[8]) + 1770035416U;
#line 201
  d += a;
#line 201
  d = (d << 12) | (d >> 20);
#line 201
  d += ((c ^ (a & (b ^ c))) + in[9]) + 2336552879U;
#line 202
  c += d;
#line 202
  c = (c << 17) | (c >> 15);
#line 202
  c += ((b ^ (d & (a ^ b))) + in[10]) + 4294925233U;
#line 203
  b += c;
#line 203
  b = (b << 22) | (b >> 10);
#line 203
  b += ((a ^ (c & (d ^ a))) + in[11]) + 2304563134U;
#line 204
  a += b;
#line 204
  a = (a << 7) | (a >> 25);
#line 204
  a += ((d ^ (b & (c ^ d))) + in[12]) + 1804603682U;
#line 205
  d += a;
#line 205
  d = (d << 12) | (d >> 20);
#line 205
  d += ((c ^ (a & (b ^ c))) + in[13]) + 4254626195U;
#line 206
  c += d;
#line 206
  c = (c << 17) | (c >> 15);
#line 206
  c += ((b ^ (d & (a ^ b))) + in[14]) + 2792965006U;
#line 207
  b += c;
#line 207
  b = (b << 22) | (b >> 10);
#line 207
  b += ((a ^ (c & (d ^ a))) + in[15]) + 1236535329U;
#line 209
  a += b;
#line 209
  a = (a << 5) | (a >> 27);
#line 209
  a += ((c ^ (d & (b ^ c))) + in[1]) + 4129170786U;
#line 210
  d += a;
#line 210
  d = (d << 9) | (d >> 23);
#line 210
  d += ((b ^ (c & (a ^ b))) + in[6]) + 3225465664U;
#line 211
  c += d;
#line 211
  c = (c << 14) | (c >> 18);
#line 211
  c += ((a ^ (b & (d ^ a))) + in[11]) + 643717713U;
#line 212
  b += c;
#line 212
  b = (b << 20) | (b >> 12);
#line 212
  b += ((d ^ (a & (c ^ d))) + in[0]) + 3921069994U;
#line 213
  a += b;
#line 213
  a = (a << 5) | (a >> 27);
#line 213
  a += ((c ^ (d & (b ^ c))) + in[5]) + 3593408605U;
#line 214
  d += a;
#line 214
  d = (d << 9) | (d >> 23);
#line 214
  d += ((b ^ (c & (a ^ b))) + in[10]) + 38016083U;
#line 215
  c += d;
#line 215
  c = (c << 14) | (c >> 18);
#line 215
  c += ((a ^ (b & (d ^ a))) + in[15]) + 3634488961U;
#line 216
  b += c;
#line 216
  b = (b << 20) | (b >> 12);
#line 216
  b += ((d ^ (a & (c ^ d))) + in[4]) + 3889429448U;
#line 217
  a += b;
#line 217
  a = (a << 5) | (a >> 27);
#line 217
  a += ((c ^ (d & (b ^ c))) + in[9]) + 568446438U;
#line 218
  d += a;
#line 218
  d = (d << 9) | (d >> 23);
#line 218
  d += ((b ^ (c & (a ^ b))) + in[14]) + 3275163606U;
#line 219
  c += d;
#line 219
  c = (c << 14) | (c >> 18);
#line 219
  c += ((a ^ (b & (d ^ a))) + in[3]) + 4107603335U;
#line 220
  b += c;
#line 220
  b = (b << 20) | (b >> 12);
#line 220
  b += ((d ^ (a & (c ^ d))) + in[8]) + 1163531501U;
#line 221
  a += b;
#line 221
  a = (a << 5) | (a >> 27);
#line 221
  a += ((c ^ (d & (b ^ c))) + in[13]) + 2850285829U;
#line 222
  d += a;
#line 222
  d = (d << 9) | (d >> 23);
#line 222
  d += ((b ^ (c & (a ^ b))) + in[2]) + 4243563512U;
#line 223
  c += d;
#line 223
  c = (c << 14) | (c >> 18);
#line 223
  c += ((a ^ (b & (d ^ a))) + in[7]) + 1735328473U;
#line 224
  b += c;
#line 224
  b = (b << 20) | (b >> 12);
#line 224
  b += ((d ^ (a & (c ^ d))) + in[12]) + 2368359562U;
#line 226
  a += b;
#line 226
  a = (a << 4) | (a >> 28);
#line 226
  a += (((b ^ c) ^ d) + in[5]) + 4294588738U;
#line 227
  d += a;
#line 227
  d = (d << 11) | (d >> 21);
#line 227
  d += (((a ^ b) ^ c) + in[8]) + 2272392833U;
#line 228
  c += d;
#line 228
  c = (c << 16) | (c >> 16);
#line 228
  c += (((d ^ a) ^ b) + in[11]) + 1839030562U;
#line 229
  b += c;
#line 229
  b = (b << 23) | (b >> 9);
#line 229
  b += (((c ^ d) ^ a) + in[14]) + 4259657740U;
#line 230
  a += b;
#line 230
  a = (a << 4) | (a >> 28);
#line 230
  a += (((b ^ c) ^ d) + in[1]) + 2763975236U;
#line 231
  d += a;
#line 231
  d = (d << 11) | (d >> 21);
#line 231
  d += (((a ^ b) ^ c) + in[4]) + 1272893353U;
#line 232
  c += d;
#line 232
  c = (c << 16) | (c >> 16);
#line 232
  c += (((d ^ a) ^ b) + in[7]) + 4139469664U;
#line 233
  b += c;
#line 233
  b = (b << 23) | (b >> 9);
#line 233
  b += (((c ^ d) ^ a) + in[10]) + 3200236656U;
#line 234
  a += b;
#line 234
  a = (a << 4) | (a >> 28);
#line 234
  a += (((b ^ c) ^ d) + in[13]) + 681279174U;
#line 235
  d += a;
#line 235
  d = (d << 11) | (d >> 21);
#line 235
  d += (((a ^ b) ^ c) + in[0]) + 3936430074U;
#line 236
  c += d;
#line 236
  c = (c << 16) | (c >> 16);
#line 236
  c += (((d ^ a) ^ b) + in[3]) + 3572445317U;
#line 237
  b += c;
#line 237
  b = (b << 23) | (b >> 9);
#line 237
  b += (((c ^ d) ^ a) + in[6]) + 76029189U;
#line 238
  a += b;
#line 238
  a = (a << 4) | (a >> 28);
#line 238
  a += (((b ^ c) ^ d) + in[9]) + 3654602809U;
#line 239
  d += a;
#line 239
  d = (d << 11) | (d >> 21);
#line 239
  d += (((a ^ b) ^ c) + in[12]) + 3873151461U;
#line 240
  c += d;
#line 240
  c = (c << 16) | (c >> 16);
#line 240
  c += (((d ^ a) ^ b) + in[15]) + 530742520U;
#line 241
  b += c;
#line 241
  b = (b << 23) | (b >> 9);
#line 241
  b += (((c ^ d) ^ a) + in[2]) + 3299628645U;
#line 243
  a += b;
#line 243
  a = (a << 6) | (a >> 26);
#line 243
  a += ((c ^ (b | ~ d)) + in[0]) + 4096336452U;
#line 244
  d += a;
#line 244
  d = (d << 10) | (d >> 22);
#line 244
  d += ((b ^ (a | ~ c)) + in[7]) + 1126891415U;
#line 245
  c += d;
#line 245
  c = (c << 15) | (c >> 17);
#line 245
  c += ((a ^ (d | ~ b)) + in[14]) + 2878612391U;
#line 246
  b += c;
#line 246
  b = (b << 21) | (b >> 11);
#line 246
  b += ((d ^ (c | ~ a)) + in[5]) + 4237533241U;
#line 247
  a += b;
#line 247
  a = (a << 6) | (a >> 26);
#line 247
  a += ((c ^ (b | ~ d)) + in[12]) + 1700485571U;
#line 248
  d += a;
#line 248
  d = (d << 10) | (d >> 22);
#line 248
  d += ((b ^ (a | ~ c)) + in[3]) + 2399980690U;
#line 249
  c += d;
#line 249
  c = (c << 15) | (c >> 17);
#line 249
  c += ((a ^ (d | ~ b)) + in[10]) + 4293915773U;
#line 250
  b += c;
#line 250
  b = (b << 21) | (b >> 11);
#line 250
  b += ((d ^ (c | ~ a)) + in[1]) + 2240044497U;
#line 251
  a += b;
#line 251
  a = (a << 6) | (a >> 26);
#line 251
  a += ((c ^ (b | ~ d)) + in[8]) + 1873313359U;
#line 252
  d += a;
#line 252
  d = (d << 10) | (d >> 22);
#line 252
  d += ((b ^ (a | ~ c)) + in[15]) + 4264355552U;
#line 253
  c += d;
#line 253
  c = (c << 15) | (c >> 17);
#line 253
  c += ((a ^ (d | ~ b)) + in[6]) + 2734768916U;
#line 254
  b += c;
#line 254
  b = (b << 21) | (b >> 11);
#line 254
  b += ((d ^ (c | ~ a)) + in[13]) + 1309151649U;
#line 255
  a += b;
#line 255
  a = (a << 6) | (a >> 26);
#line 255
  a += ((c ^ (b | ~ d)) + in[4]) + 4149444226U;
#line 256
  d += a;
#line 256
  d = (d << 10) | (d >> 22);
#line 256
  d += ((b ^ (a | ~ c)) + in[11]) + 3174756917U;
#line 257
  c += d;
#line 257
  c = (c << 15) | (c >> 17);
#line 257
  c += ((a ^ (d | ~ b)) + in[2]) + 718787259U;
#line 258
  b += c;
#line 258
  b = (b << 21) | (b >> 11);
#line 258
  b += ((d ^ (c | ~ a)) + in[9]) + 3951481745U;
#line 260
  buf[0] += a;
#line 261
  buf[1] += b;
#line 262
  buf[2] += c;
#line 263
  buf[3] += d;
  return;
}
}
#line 65 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
static uint16_t channel_masks[7]  = {      (uint16_t )4,      (uint16_t )3,      (uint16_t )7,      (uint16_t )51, 
        (uint16_t )15,      (uint16_t )55,      (uint16_t )63};
#line 68 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
int ParseDsfHeaderConfig(FILE *infile , char *infilename , char *fourcc , WavpackContext *wpc ,
                         WavpackConfig *config ) 
{ 
  int64_t infilesize ;
  int64_t total_samples ;
  int64_t total_blocks ;
  int64_t leftover_samples ;
  DSFFileChunk file_chunk ;
  DSFFormatChunk format_chunk ;
  DSFChunkHeader chunk_header ;
  uint32_t bcount ;
  int64_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  int64_t __cil_tmp26 ;
  int __cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 77
  infilesize = DoGetFileSize(infile);
#line 78
  memcpy(& file_chunk, fourcc, (unsigned long )4);
#line 80
  __cil_tmp15 = DoReadFile(infile, (char *)(& file_chunk) + 4, (uint32_t )(sizeof(DSFFileChunk ) - 4UL),
                           & bcount);
  }
#line 80
  if (! __cil_tmp15) {
    {
    {
#line 82
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
#line 83
    return (1);
  } else
#line 80
  if ((unsigned long )bcount != sizeof(DSFFileChunk ) - 4UL) {
    {
    {
#line 82
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
#line 83
    return (1);
  } else {
    {
#line 85
    __cil_tmp16 = WavpackAddWrapper(wpc, & file_chunk, (uint32_t )sizeof(DSFFileChunk ));
    }
#line 85
    if (! (config->qmode & 512)) {
#line 85
      if (! __cil_tmp16) {
        {
#line 87
        __cil_tmp17 = WavpackGetErrorMessage(wpc);
#line 87
        error_line("%s", __cil_tmp17);
        }
#line 88
        return (1);
      }
    }
  }
  {
#line 92
  WavpackLittleEndianToNative(& file_chunk, "4DDD");
  }
#line 94
  if (debug_logging_mode) {
    {
#line 95
    error_line("file header lengths = %lld, %lld, %lld", file_chunk.ckSize, file_chunk.fileSize,
               file_chunk.metaOffset);
    }
  }
#line 97
  if (infilesize) {
#line 97
    if (! (config->qmode & 2048)) {
#line 97
      if (file_chunk.fileSize) {
#line 97
        if (file_chunk.fileSize + 1L) {
#line 97
          if (file_chunk.fileSize != infilesize) {
            {
#line 99
            error_line("%s is not a valid .DSF file (by total size)!", infilename);
            }
#line 100
            return (1);
          }
        }
      }
    }
  }
#line 104
  if (config->channel_mask) {
    {
    {
#line 105
    error_line("this DSF file already has channel order information!");
    }
    }
#line 106
    return (1);
  } else
#line 104
  if (config->qmode & 1024) {
    {
    {
#line 105
    error_line("this DSF file already has channel order information!");
    }
    }
#line 106
    return (1);
  }
  {
#line 109
  __cil_tmp19 = strncmp((char const   *)((char *)format_chunk.ckID), "fmt ", (unsigned long )4);
  }
  {
#line 109
  __cil_tmp18 = DoReadFile(infile, (char *)(& format_chunk), (uint32_t )sizeof(DSFFormatChunk ),
                           & bcount);
  }
#line 109
  if (! __cil_tmp18) {
    {
    {
    {
#line 111
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
#line 112
    return (1);
  } else
#line 109
  if ((unsigned long )bcount != sizeof(DSFFormatChunk )) {
    {
    {
    {
#line 111
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
#line 112
    return (1);
  } else
#line 109
  if (__cil_tmp19) {
    {
    {
    {
#line 111
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
#line 112
    return (1);
  } else {
    {
#line 114
    __cil_tmp20 = WavpackAddWrapper(wpc, & format_chunk, (uint32_t )sizeof(DSFFormatChunk ));
    }
#line 114
    if (! (config->qmode & 512)) {
#line 114
      if (! __cil_tmp20) {
        {
#line 116
        __cil_tmp21 = WavpackGetErrorMessage(wpc);
#line 116
        error_line("%s", __cil_tmp21);
        }
#line 117
        return (1);
      }
    }
  }
  {
#line 120
  WavpackLittleEndianToNative(& format_chunk, "4DLLLLLLDL4");
  }
#line 122
  if ((unsigned long )format_chunk.ckSize != sizeof(DSFFormatChunk )) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 126
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
    }
    }
    }
    }
    }
#line 127
    return (1);
  } else
#line 122
  if (format_chunk.formatVersion != 1U) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 126
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
    }
    }
    }
    }
    }
#line 127
    return (1);
  } else
#line 122
  if (format_chunk.formatID != 0U) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 126
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
    }
    }
    }
    }
    }
#line 127
    return (1);
  } else
#line 122
  if (format_chunk.blockSize != 4096U) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 126
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
    }
    }
    }
    }
    }
#line 127
    return (1);
  } else
#line 122
  if (format_chunk.reserved) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 126
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
    }
    }
    }
    }
    }
#line 127
    return (1);
  } else
#line 122
  if (format_chunk.bitsPerSample != 1U) {
#line 122
    if (format_chunk.bitsPerSample != 8U) {
      {
      {
      {
      {
      {
      {
      {
      {
#line 126
      error_line("%s is not a valid .DSF file!", infilename);
      }
      }
      }
      }
      }
      }
      }
      }
#line 127
      return (1);
    } else {
#line 122
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 122
  if (format_chunk.chanType < 1U) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 126
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
    }
    }
    }
    }
    }
#line 127
    return (1);
  } else
#line 122
  if ((unsigned long )format_chunk.chanType > sizeof(channel_masks) / sizeof(channel_masks[0])) {
    {
    {
    {
    {
    {
    {
    {
    {
#line 126
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
    }
    }
    }
    }
    }
#line 127
    return (1);
  }
#line 130
  if (debug_logging_mode) {
    {
#line 131
    error_line("sampling rate = %d Hz", format_chunk.sampleRate);
#line 132
    error_line("channel type = %d, channel count = %d", format_chunk.chanType, format_chunk.numChannels);
#line 133
    error_line("block size = %d, bits per sample = %d", format_chunk.blockSize, format_chunk.bitsPerSample);
#line 134
    error_line("sample count = %lld", format_chunk.sampleCount);
    }
  }
  {
#line 137
  __cil_tmp23 = strncmp((char const   *)((char *)chunk_header.ckID), "data", (unsigned long )4);
  }
  {
#line 137
  __cil_tmp22 = DoReadFile(infile, (char *)(& chunk_header), (uint32_t )sizeof(DSFChunkHeader ),
                           & bcount);
  }
#line 137
  if (! __cil_tmp22) {
    {
    {
    {
#line 139
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
#line 140
    return (1);
  } else
#line 137
  if ((unsigned long )bcount != sizeof(DSFChunkHeader )) {
    {
    {
    {
#line 139
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
#line 140
    return (1);
  } else
#line 137
  if (__cil_tmp23) {
    {
    {
    {
#line 139
    error_line("%s is not a valid .DSF file!", infilename);
    }
    }
    }
#line 140
    return (1);
  } else {
    {
#line 142
    __cil_tmp24 = WavpackAddWrapper(wpc, & chunk_header, (uint32_t )sizeof(DSFChunkHeader ));
    }
#line 142
    if (! (config->qmode & 512)) {
#line 142
      if (! __cil_tmp24) {
        {
#line 144
        __cil_tmp25 = WavpackGetErrorMessage(wpc);
#line 144
        error_line("%s", __cil_tmp25);
        }
#line 145
        return (1);
      }
    }
  }
  {
#line 148
  WavpackLittleEndianToNative(& chunk_header, "4D");
#line 150
  total_samples = format_chunk.sampleCount;
#line 151
  total_blocks = total_samples / (long )(format_chunk.blockSize * 8U);
#line 152
  leftover_samples = total_samples - (total_blocks * (long )format_chunk.blockSize) * 8L;
  }
#line 154
  if (leftover_samples) {
#line 155
    total_blocks ++;
  }
#line 157
  if (debug_logging_mode) {
    {
#line 158
    error_line("leftover samples = %lld, leftover bits = %d", leftover_samples, (int )(leftover_samples % 8L));
#line 159
    error_line("data chunk size (specified) = %lld", chunk_header.ckSize - 12L);
#line 160
    error_line("data chunk size (calculated) = %lld", (total_blocks * 4096L) * (long )format_chunk.numChannels);
    }
  }
#line 163
  if (total_samples & 7L) {
    {
#line 164
    error_line("warning: DSF file has partial-byte leftover samples!");
    }
  }
#line 166
  if (format_chunk.sampleRate & 7U) {
    {
#line 167
    error_line("warning: DSF file has non-integer bytes/second!");
    }
  }
#line 169
  config->bits_per_sample = 8;
#line 170
  config->bytes_per_sample = 1;
#line 171
  config->num_channels = (int )format_chunk.numChannels;
#line 172
  config->channel_mask = (int32_t )channel_masks[format_chunk.chanType - 1U];
#line 173
  config->sample_rate = (int32_t )(format_chunk.sampleRate / 8U);
#line 175
  if (format_chunk.bitsPerSample == 1U) {
#line 176
    config->qmode |= 80;
  } else {
#line 178
    config->qmode |= 96;
  }
  {
#line 180
  __cil_tmp27 = WavpackSetConfiguration64(wpc, config, (total_samples + 7L) / 8L,
                                          (unsigned char const   *)((void *)0));
  }
#line 180
  if (! __cil_tmp27) {
    {
#line 181
    __cil_tmp28 = WavpackGetErrorMessage(wpc);
#line 181
    error_line("%s: %s", infilename, __cil_tmp28);
    }
#line 182
    return (1);
  }
#line 185
  return (0);
}
}
#line 188 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
int WriteDsfHeader(FILE *outfile , WavpackContext *wpc , int64_t total_samples , int qmode ) 
{ 
  uint32_t chan_mask ;
  int __cil_tmp6 ;
  uint32_t chan_type ;
  int num_channels ;
  int __cil_tmp9 ;
  int64_t file_size ;
  int64_t total_blocks ;
  int64_t data_size ;
  DSFFileChunk file_chunk ;
  DSFFormatChunk format_chunk ;
  DSFChunkHeader chunk_header ;
  uint32_t bcount ;
  int i ;
  uint32_t __cil_tmp18 ;
  int tmp ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;

  {
  {
#line 190
  __cil_tmp6 = WavpackGetChannelMask(wpc);
#line 190
  chan_mask = (uint32_t )__cil_tmp6;
  }
  {
#line 190
  chan_type = (uint32_t )0;
#line 191
  __cil_tmp9 = WavpackGetNumChannels(wpc);
#line 191
  num_channels = __cil_tmp9;
  }
#line 199
  if (debug_logging_mode) {
    {
#line 200
    error_line("WriteDsfHeader (), total samples = %lld, qmode = 0x%02x\n\230\001",
               (long long )total_samples, qmode);
    }
  }
#line 203
  i = 0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! ((unsigned long )i < sizeof(channel_masks) / sizeof(channel_masks[0]))) {
#line 203
      goto while_break;
    }
#line 204
    if (chan_mask == (unsigned int )channel_masks[i]) {
#line 205
      chan_type = (uint32_t )(i + 1);
    }
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if (! chan_type) {
#line 210
    if (num_channels > 6) {
#line 211
      chan_type = (uint32_t )7;
    } else
#line 212
    if (num_channels > 4) {
#line 213
      chan_type = (uint32_t )(num_channels + 1);
    } else {
#line 215
      chan_type = (uint32_t )num_channels;
    }
  }
  {
#line 218
  total_blocks = ((total_samples + 4096L) - 1L) / 4096L;
#line 219
  data_size = (total_blocks * 4096L) * (long )num_channels;
#line 220
  file_size = (int64_t )((((unsigned long )data_size + sizeof(file_chunk)) + sizeof(format_chunk)) + sizeof(chunk_header));
#line 222
  memcpy((char *)file_chunk.ckID, "DSD ", (unsigned long )4);
#line 223
  file_chunk.ckSize = (int64_t )sizeof(file_chunk);
#line 224
  file_chunk.fileSize = file_size;
#line 225
  file_chunk.metaOffset = (int64_t )0;
#line 227
  memcpy((char *)format_chunk.ckID, "fmt ", (unsigned long )4);
#line 228
  format_chunk.ckSize = (int64_t )sizeof(format_chunk);
#line 229
  format_chunk.formatVersion = (uint32_t )1;
#line 230
  format_chunk.formatID = (uint32_t )0;
#line 231
  format_chunk.chanType = chan_type;
#line 232
  format_chunk.numChannels = (uint32_t )num_channels;
#line 233
  __cil_tmp18 = WavpackGetSampleRate(wpc);
#line 233
  format_chunk.sampleRate = __cil_tmp18 * 8U;
  }
#line 234
  if (qmode & 16) {
#line 234
    tmp = 1;
  } else {
#line 234
    tmp = 8;
  }
  {
#line 234
  format_chunk.bitsPerSample = (uint32_t )tmp;
#line 235
  format_chunk.sampleCount = total_samples * 8L;
#line 236
  format_chunk.blockSize = (uint32_t )4096;
#line 237
  format_chunk.reserved = (uint32_t )0;
#line 239
  memcpy((char *)chunk_header.ckID, "data", (unsigned long )4);
#line 240
  chunk_header.ckSize = data_size + 12L;
#line 244
  WavpackNativeToLittleEndian(& file_chunk, "4DDD");
#line 245
  WavpackNativeToLittleEndian(& format_chunk, "4DLLLLLLDL4");
#line 246
  WavpackNativeToLittleEndian(& chunk_header, "4D");
#line 248
  __cil_tmp22 = DoWriteFile(outfile, & chunk_header, (uint32_t )sizeof(chunk_header),
                            & bcount);
  }
  {
#line 248
  __cil_tmp21 = DoWriteFile(outfile, & format_chunk, (uint32_t )sizeof(format_chunk),
                            & bcount);
  }
  {
#line 248
  __cil_tmp20 = DoWriteFile(outfile, & file_chunk, (uint32_t )sizeof(file_chunk),
                            & bcount);
  }
#line 248
  if (! __cil_tmp20) {
    {
    {
    {
    {
    {
    {
#line 251
    error_line("can\'t write .DSF data, disk probably full!\216>dU");
    }
    }
    }
    }
    }
    }
#line 252
    return (0);
  } else
#line 248
  if ((unsigned long )bcount != sizeof(file_chunk)) {
    {
    {
    {
    {
    {
    {
#line 251
    error_line("can\'t write .DSF data, disk probably full!\216>dU");
    }
    }
    }
    }
    }
    }
#line 252
    return (0);
  } else
#line 248
  if (! __cil_tmp21) {
    {
    {
    {
    {
    {
    {
#line 251
    error_line("can\'t write .DSF data, disk probably full!\216>dU");
    }
    }
    }
    }
    }
    }
#line 252
    return (0);
  } else
#line 248
  if ((unsigned long )bcount != sizeof(format_chunk)) {
    {
    {
    {
    {
    {
    {
#line 251
    error_line("can\'t write .DSF data, disk probably full!\216>dU");
    }
    }
    }
    }
    }
    }
#line 252
    return (0);
  } else
#line 248
  if (! __cil_tmp22) {
    {
    {
    {
    {
    {
    {
#line 251
    error_line("can\'t write .DSF data, disk probably full!\216>dU");
    }
    }
    }
    }
    }
    }
#line 252
    return (0);
  } else
#line 248
  if ((unsigned long )bcount != sizeof(chunk_header)) {
    {
    {
    {
    {
    {
    {
#line 251
    error_line("can\'t write .DSF data, disk probably full!\216>dU");
    }
    }
    }
    }
    }
    }
#line 252
    return (0);
  }
#line 255
  return (1);
}
}
#line 80 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
int ParseDsdiffHeaderConfig(FILE *infile , char *infilename , char *fourcc , WavpackContext *wpc ,
                            WavpackConfig *config ) 
{ 
  int64_t infilesize ;
  int64_t total_samples ;
  DFFFileHeader dff_file_header ;
  DFFChunkHeader dff_chunk_header ;
  uint32_t bcount ;
  int64_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;
  int __cil_tmp19 ;
  uint32_t version ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *prop_chunk ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  char *__cil_tmp29 ;
  int __cil_tmp30 ;
  char *cptr ;
  char *eptr ;
  uint16_t numChannels ;
  uint16_t chansSpecified ;
  uint16_t chanMask ;
  uint32_t sampleRate ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  uint16_t __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int bytes_to_copy ;
  char *buff ;
  void *__cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  char *__cil_tmp56 ;
  int __cil_tmp57 ;
  char *__cil_tmp58 ;

  {
  {
#line 87
  infilesize = DoGetFileSize(infile);
#line 88
  memcpy(& dff_file_header, fourcc, (unsigned long )4);
#line 90
  __cil_tmp13 = strncmp((char const   *)((char *)dff_file_header.formType), "DSD ",
                        (unsigned long )4);
  }
  {
#line 90
  __cil_tmp12 = DoReadFile(infile, (char *)(& dff_file_header) + 4, (uint32_t )(sizeof(DFFFileHeader ) - 4UL),
                           & bcount);
  }
#line 90
  if (! __cil_tmp12) {
    {
    {
    {
#line 92
    error_line("%s is not a valid .DFF file!", infilename);
    }
    }
    }
#line 93
    return (1);
  } else
#line 90
  if ((unsigned long )bcount != sizeof(DFFFileHeader ) - 4UL) {
    {
    {
    {
#line 92
    error_line("%s is not a valid .DFF file!", infilename);
    }
    }
    }
#line 93
    return (1);
  } else
#line 90
  if (__cil_tmp13) {
    {
    {
    {
#line 92
    error_line("%s is not a valid .DFF file!", infilename);
    }
    }
    }
#line 93
    return (1);
  } else {
    {
#line 95
    __cil_tmp14 = WavpackAddWrapper(wpc, & dff_file_header, (uint32_t )sizeof(DFFFileHeader ));
    }
#line 95
    if (! (config->qmode & 512)) {
#line 95
      if (! __cil_tmp14) {
        {
#line 97
        __cil_tmp15 = WavpackGetErrorMessage(wpc);
#line 97
        error_line("%s", __cil_tmp15);
        }
#line 98
        return (1);
      }
    }
  }
  {
#line 102
  WavpackBigEndianToNative(& dff_file_header, "4D4");
  }
#line 104
  if (infilesize) {
#line 104
    if (! (config->qmode & 2048)) {
#line 104
      if (dff_file_header.ckDataSize) {
#line 104
        if (dff_file_header.ckDataSize + 1L) {
#line 104
          if (dff_file_header.ckDataSize + 12L != infilesize) {
            {
#line 106
            error_line("%s is not a valid .DFF file (by total size)!", infilename);
            }
#line 107
            return (1);
          }
        }
      }
    }
  }
#line 110
  if (debug_logging_mode) {
    {
#line 111
    error_line("file header indicated length = %lld", dff_file_header.ckDataSize);
    }
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    __cil_tmp16 = DoReadFile(infile, & dff_chunk_header, (uint32_t )sizeof(DFFChunkHeader ),
                             & bcount);
    }
#line 119
    if (! __cil_tmp16) {
      {
      {
#line 121
      error_line("%s is not a valid .DFF file!", infilename);
      }
      }
#line 122
      return (1);
    } else
#line 119
    if ((unsigned long )bcount != sizeof(DFFChunkHeader )) {
      {
      {
#line 121
      error_line("%s is not a valid .DFF file!", infilename);
      }
      }
#line 122
      return (1);
    } else {
      {
#line 124
      __cil_tmp17 = WavpackAddWrapper(wpc, & dff_chunk_header, (uint32_t )sizeof(DFFChunkHeader ));
      }
#line 124
      if (! (config->qmode & 512)) {
#line 124
        if (! __cil_tmp17) {
          {
#line 126
          __cil_tmp18 = WavpackGetErrorMessage(wpc);
#line 126
          error_line("%s", __cil_tmp18);
          }
#line 127
          return (1);
        }
      }
    }
    {
#line 130
    WavpackBigEndianToNative(& dff_chunk_header, "4D");
    }
#line 132
    if (debug_logging_mode) {
      {
#line 133
      error_line("chunk header indicated length = %lld", dff_chunk_header.ckDataSize);
      }
    }
    {
#line 135
    __cil_tmp19 = strncmp((char const   *)((char *)dff_chunk_header.ckID), "FVER",
                          (unsigned long )4);
    }
#line 135
    if (! __cil_tmp19) {
      {
#line 138
      __cil_tmp21 = DoReadFile(infile, & version, (uint32_t )sizeof(version), & bcount);
      }
#line 138
      if ((unsigned long )dff_chunk_header.ckDataSize != sizeof(version)) {
        {
        {
        {
#line 141
        error_line("%s is not a valid .DFF file!", infilename);
        }
        }
        }
#line 142
        return (1);
      } else
#line 138
      if (! __cil_tmp21) {
        {
        {
        {
#line 141
        error_line("%s is not a valid .DFF file!", infilename);
        }
        }
        }
#line 142
        return (1);
      } else
#line 138
      if ((unsigned long )bcount != sizeof(version)) {
        {
        {
        {
#line 141
        error_line("%s is not a valid .DFF file!", infilename);
        }
        }
        }
#line 142
        return (1);
      } else {
        {
#line 144
        __cil_tmp22 = WavpackAddWrapper(wpc, & version, (uint32_t )sizeof(version));
        }
#line 144
        if (! (config->qmode & 512)) {
#line 144
          if (! __cil_tmp22) {
            {
#line 146
            __cil_tmp23 = WavpackGetErrorMessage(wpc);
#line 146
            error_line("%s", __cil_tmp23);
            }
#line 147
            return (1);
          }
        }
      }
      {
#line 150
      WavpackBigEndianToNative(& version, "L");
      }
#line 152
      if (debug_logging_mode) {
        {
#line 153
        error_line("dsdiff file version = 0x%08x", version);
        }
      }
    } else {
      {
#line 155
      __cil_tmp24 = strncmp((char const   *)((char *)dff_chunk_header.ckID), "PROP",
                            (unsigned long )4);
      }
#line 155
      if (! __cil_tmp24) {
        {
#line 156
        __cil_tmp26 = malloc((size_t )dff_chunk_header.ckDataSize);
#line 156
        prop_chunk = __cil_tmp26;
#line 158
        __cil_tmp27 = DoReadFile(infile, prop_chunk, (uint32_t )dff_chunk_header.ckDataSize,
                                 & bcount);
        }
#line 158
        if (! __cil_tmp27) {
          {
          {
#line 160
          error_line("%s is not a valid .DFF file!", infilename);
          }
          {
#line 161
          free(prop_chunk);
          }
          }
#line 162
          return (1);
        } else
#line 158
        if ((long )bcount != dff_chunk_header.ckDataSize) {
          {
          {
#line 160
          error_line("%s is not a valid .DFF file!", infilename);
          }
          {
#line 161
          free(prop_chunk);
          }
          }
#line 162
          return (1);
        } else {
          {
#line 164
          __cil_tmp28 = WavpackAddWrapper(wpc, prop_chunk, (uint32_t )dff_chunk_header.ckDataSize);
          }
#line 164
          if (! (config->qmode & 512)) {
#line 164
            if (! __cil_tmp28) {
              {
#line 166
              __cil_tmp29 = WavpackGetErrorMessage(wpc);
#line 166
              error_line("%s", __cil_tmp29);
#line 167
              free(prop_chunk);
              }
#line 168
              return (1);
            }
          }
        }
        {
#line 171
        __cil_tmp30 = strncmp((char const   *)prop_chunk, "SND ", (unsigned long )4);
        }
#line 171
        if (! __cil_tmp30) {
#line 172
          cptr = prop_chunk + 4;
#line 172
          eptr = prop_chunk + dff_chunk_header.ckDataSize;
#line 173
          chanMask = (uint16_t )0;
          {
#line 176
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 176
            if (! ((unsigned long )(eptr - cptr) >= sizeof(dff_chunk_header))) {
#line 176
              goto while_break___0;
            }
            {
#line 177
            memcpy(& dff_chunk_header, cptr, sizeof(dff_chunk_header));
#line 178
            cptr += sizeof(dff_chunk_header);
#line 179
            WavpackBigEndianToNative(& dff_chunk_header, "4D");
            }
#line 181
            if (eptr - cptr >= dff_chunk_header.ckDataSize) {
              {
#line 182
              __cil_tmp37 = strncmp((char const   *)((char *)dff_chunk_header.ckID),
                                    "FS  ", (unsigned long )4);
              }
#line 182
              if (! __cil_tmp37) {
#line 182
                if (dff_chunk_header.ckDataSize == 4L) {
                  {
#line 183
                  memcpy(& sampleRate, cptr, sizeof(sampleRate));
#line 184
                  WavpackBigEndianToNative(& sampleRate, "L");
#line 185
                  cptr += dff_chunk_header.ckDataSize;
                  }
#line 187
                  if (debug_logging_mode) {
                    {
#line 188
                    error_line("got sample rate of %u Hz\230\001", sampleRate);
                    }
                  }
                } else {
#line 182
                  goto _L___27;
                }
              } else {
                _L___27: /* CIL Label */ 
                {
#line 190
                __cil_tmp38 = strncmp((char const   *)((char *)dff_chunk_header.ckID),
                                      "CHNL", (unsigned long )4);
                }
#line 190
                if (! __cil_tmp38) {
#line 190
                  if (dff_chunk_header.ckDataSize >= 2L) {
                    {
#line 191
                    memcpy(& numChannels, cptr, sizeof(numChannels));
#line 192
                    WavpackBigEndianToNative(& numChannels, "S");
#line 193
                    cptr += sizeof(numChannels);
#line 195
                    chansSpecified = (uint16_t )((int )((unsigned long )dff_chunk_header.ckDataSize - sizeof(numChannels)) / 4);
                    }
                    {
#line 197
                    while (1) {
                      while_continue___1: /* CIL Label */ ;
#line 197
                      __cil_tmp39 = chansSpecified;
#line 197
                      chansSpecified --;
#line 197
                      if (! __cil_tmp39) {
#line 197
                        goto while_break___1;
                      }
                      {
#line 198
                      __cil_tmp41 = strncmp((char const   *)cptr, "MLFT", (unsigned long )4);
                      }
                      {
#line 198
                      __cil_tmp40 = strncmp((char const   *)cptr, "SLFT", (unsigned long )4);
                      }
#line 198
                      if (! __cil_tmp40) {
#line 199
                        chanMask |= 1;
                      } else
#line 198
                      if (! __cil_tmp41) {
#line 199
                        chanMask |= 1;
                      } else {
                        {
#line 200
                        __cil_tmp43 = strncmp((char const   *)cptr, "MRGT", (unsigned long )4);
                        }
                        {
#line 200
                        __cil_tmp42 = strncmp((char const   *)cptr, "SRGT", (unsigned long )4);
                        }
#line 200
                        if (! __cil_tmp42) {
#line 201
                          chanMask |= 2;
                        } else
#line 200
                        if (! __cil_tmp43) {
#line 201
                          chanMask |= 2;
                        } else {
                          {
#line 202
                          __cil_tmp44 = strncmp((char const   *)cptr, "LS  ", (unsigned long )4);
                          }
#line 202
                          if (! __cil_tmp44) {
#line 203
                            chanMask |= 16;
                          } else {
                            {
#line 204
                            __cil_tmp45 = strncmp((char const   *)cptr, "RS  ", (unsigned long )4);
                            }
#line 204
                            if (! __cil_tmp45) {
#line 205
                              chanMask |= 32;
                            } else {
                              {
#line 206
                              __cil_tmp46 = strncmp((char const   *)cptr, "C   ",
                                                    (unsigned long )4);
                              }
#line 206
                              if (! __cil_tmp46) {
#line 207
                                chanMask |= 4;
                              } else {
                                {
#line 208
                                __cil_tmp47 = strncmp((char const   *)cptr, "LFE ",
                                                      (unsigned long )4);
                                }
#line 208
                                if (! __cil_tmp47) {
#line 209
                                  chanMask |= 8;
                                } else
#line 211
                                if (debug_logging_mode) {
                                  {
#line 212
                                  error_line("undefined channel ID %c%c%c%c", (int )*(cptr + 0),
                                             (int )*(cptr + 1), (int )*(cptr + 2),
                                             (int )*(cptr + 3));
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
#line 214
                      cptr += 4;
                    }
                    while_break___1: /* CIL Label */ ;
                    }
#line 217
                    if (debug_logging_mode) {
                      {
#line 218
                      error_line("%d channels, mask = 0x%08x", (int )numChannels,
                                 (int )chanMask);
                      }
                    }
                  } else {
#line 190
                    goto _L___26;
                  }
                } else {
                  _L___26: /* CIL Label */ 
                  {
#line 220
                  __cil_tmp48 = strncmp((char const   *)((char *)dff_chunk_header.ckID),
                                        "CMPR", (unsigned long )4);
                  }
#line 220
                  if (! __cil_tmp48) {
#line 220
                    if (dff_chunk_header.ckDataSize >= 4L) {
                      {
#line 221
                      __cil_tmp49 = strncmp((char const   *)cptr, "DSD ", (unsigned long )4);
                      }
#line 221
                      if (__cil_tmp49) {
                        {
#line 222
                        error_line("DSDIFF files must be uncompressed, not \"%c%c%c%c\"!",
                                   (int )*(cptr + 0), (int )*(cptr + 1), (int )*(cptr + 2),
                                   (int )*(cptr + 3));
#line 224
                        free(prop_chunk);
                        }
#line 225
                        return (1);
                      }
#line 228
                      cptr += dff_chunk_header.ckDataSize;
                    } else {
#line 220
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
#line 231
                    if (debug_logging_mode) {
                      {
#line 232
                      error_line("got PROP/SND chunk type \"%c%c%c%c\" of %d bytes",
                                 (int )dff_chunk_header.ckID[0], (int )dff_chunk_header.ckID[1],
                                 (int )dff_chunk_header.ckID[2], (int )dff_chunk_header.ckID[3],
                                 dff_chunk_header.ckDataSize);
                      }
                    }
#line 235
                    cptr += dff_chunk_header.ckDataSize;
                  }
                }
              }
            } else {
              {
#line 239
              error_line("%s is not a valid .DFF file!", infilename);
#line 240
              free(prop_chunk);
              }
#line 241
              return (1);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 245
          if ((int )chanMask) {
#line 245
            if (config->channel_mask) {
              {
              {
#line 246
              error_line("this DSDIFF file already has channel order information!");
              }
              {
#line 247
              free(prop_chunk);
              }
              }
#line 248
              return (1);
            } else
#line 245
            if (config->qmode & 1024) {
              {
              {
#line 246
              error_line("this DSDIFF file already has channel order information!");
              }
              {
#line 247
              free(prop_chunk);
              }
              }
#line 248
              return (1);
            } else {
#line 245
              goto _L___28;
            }
          } else
          _L___28: /* CIL Label */ 
#line 250
          if (chanMask) {
#line 251
            config->channel_mask = (int32_t )chanMask;
          }
#line 253
          config->bits_per_sample = 8;
#line 254
          config->bytes_per_sample = 1;
#line 255
          config->num_channels = (int )numChannels;
#line 256
          config->sample_rate = (int32_t )(sampleRate / 8U);
#line 257
          config->qmode |= 32;
        } else
#line 259
        if (debug_logging_mode) {
          {
#line 260
          error_line("got unknown PROP chunk type \"%c%c%c%c\" of %d bytes", (int )*(prop_chunk + 0),
                     (int )*(prop_chunk + 1), (int )*(prop_chunk + 2), (int )*(prop_chunk + 3),
                     dff_chunk_header.ckDataSize);
          }
        }
        {
#line 263
        free(prop_chunk);
        }
      } else {
        {
#line 265
        __cil_tmp50 = strncmp((char const   *)((char *)dff_chunk_header.ckID), "DSD ",
                              (unsigned long )4);
        }
#line 265
        if (! __cil_tmp50) {
#line 266
          total_samples = dff_chunk_header.ckDataSize / (long )config->num_channels;
#line 267
          goto while_break;
        } else {
          {
#line 271
          bytes_to_copy = (int )((dff_chunk_header.ckDataSize + 1L) & -2L);
#line 272
          __cil_tmp53 = malloc((unsigned long )bytes_to_copy);
#line 272
          buff = __cil_tmp53;
          }
#line 274
          if (debug_logging_mode) {
            {
#line 275
            error_line("extra unknown chunk \"%c%c%c%c\" of %d bytes", (int )dff_chunk_header.ckID[0],
                       (int )dff_chunk_header.ckID[1], (int )dff_chunk_header.ckID[2],
                       (int )dff_chunk_header.ckID[3], dff_chunk_header.ckDataSize);
            }
          }
          {
#line 279
          __cil_tmp55 = WavpackAddWrapper(wpc, buff, (uint32_t )bytes_to_copy);
          }
          {
#line 279
          __cil_tmp54 = DoReadFile(infile, buff, (uint32_t )bytes_to_copy, & bcount);
          }
#line 279
          if (! __cil_tmp54) {
            {
            {
            {
#line 283
            __cil_tmp56 = WavpackGetErrorMessage(wpc);
            }
            }
            {
            {
#line 283
            error_line("%s", __cil_tmp56);
            }
            }
            {
            {
#line 284
            free(buff);
            }
            }
            }
#line 285
            return (1);
          } else
#line 279
          if (bcount != (unsigned int )bytes_to_copy) {
            {
            {
            {
#line 283
            __cil_tmp56 = WavpackGetErrorMessage(wpc);
            }
            }
            {
            {
#line 283
            error_line("%s", __cil_tmp56);
            }
            }
            {
            {
#line 284
            free(buff);
            }
            }
            }
#line 285
            return (1);
          } else
#line 279
          if (! (config->qmode & 512)) {
#line 279
            if (! __cil_tmp55) {
              {
              {
              {
#line 283
              __cil_tmp56 = WavpackGetErrorMessage(wpc);
              }
              }
              {
              {
#line 283
              error_line("%s", __cil_tmp56);
              }
              }
              {
              {
#line 284
              free(buff);
              }
              }
              }
#line 285
              return (1);
            }
          }
          {
#line 288
          free(buff);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  if (debug_logging_mode) {
    {
#line 293
    error_line("setting configuration with %lld samples", total_samples);
    }
  }
  {
#line 295
  __cil_tmp57 = WavpackSetConfiguration64(wpc, config, total_samples, (unsigned char const   *)((void *)0));
  }
#line 295
  if (! __cil_tmp57) {
    {
#line 296
    __cil_tmp58 = WavpackGetErrorMessage(wpc);
#line 296
    error_line("%s: %s", infilename, __cil_tmp58);
    }
#line 297
    return (1);
  }
#line 300
  return (0);
}
}
#line 303 "/doner/wavpack/wavpack-5.1.0/cli/dsdiff.c"
int WriteDsdiffHeader(FILE *outfile , WavpackContext *wpc , int64_t total_samples ,
                      int qmode ) 
{ 
  uint32_t chan_mask ;
  int __cil_tmp6 ;
  int num_channels ;
  int __cil_tmp8 ;
  DFFFileHeader file_header ;
  DFFFileHeader prop_header ;
  DFFChunkHeader data_header ;
  DFFVersionChunk ver_chunk ;
  DFFSampleRateChunk fs_chunk ;
  DFFChannelsHeader chan_header ;
  DFFCompressionHeader cmpr_header ;
  char *cmpr_name ;
  char *chan_ids ;
  int64_t file_size ;
  int64_t prop_chunk_size ;
  int64_t data_size ;
  int cmpr_name_size ;
  int chan_ids_size ;
  uint32_t bcount ;
  unsigned long __cil_tmp24 ;
  void *__cil_tmp25 ;
  uint32_t scan_mask ;
  char *cptr ;
  int ci ;
  int uci ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int __cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;

  {
  {
#line 305
  __cil_tmp6 = WavpackGetChannelMask(wpc);
#line 305
  chan_mask = (uint32_t )__cil_tmp6;
#line 306
  __cil_tmp8 = WavpackGetNumChannels(wpc);
#line 306
  num_channels = __cil_tmp8;
#line 313
  cmpr_name = "\016not compressed";
  }
#line 318
  if (debug_logging_mode) {
    {
#line 319
    error_line("WriteDsdiffHeader (), total samples = %lld, qmode = 0x%02x\n>dU",
               (long long )total_samples, qmode);
    }
  }
  {
#line 322
  __cil_tmp24 = strlen((char const   *)cmpr_name);
#line 322
  cmpr_name_size = (int )((__cil_tmp24 + 1UL) & 0xfffffffffffffffeUL);
#line 323
  chan_ids_size = num_channels * 4;
#line 324
  chan_ids = (char *)malloc((unsigned long )chan_ids_size);
  }
#line 326
  if (chan_ids) {
#line 327
    scan_mask = (uint32_t )1;
#line 328
    cptr = chan_ids;
#line 329
    uci = 0;
#line 331
    ci = 0;
    {
#line 331
    while (1) {
      while_continue: /* CIL Label */ ;
#line 331
      if (! (ci < num_channels)) {
#line 331
        goto while_break;
      }
      {
#line 332
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 332
        if (! (scan_mask && ! (scan_mask & chan_mask))) {
#line 332
          goto while_break___0;
        }
#line 333
        scan_mask <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 335
      if (scan_mask & 1U) {
#line 336
        if (num_channels <= 2) {
#line 336
          tmp = "SLFTdU";
        } else {
#line 336
          tmp = "MLFTdU";
        }
        {
#line 336
        memcpy(cptr, tmp, (unsigned long )4);
        }
      } else
#line 337
      if (scan_mask & 2U) {
#line 338
        if (num_channels <= 2) {
#line 338
          tmp___0 = "SRGTdU";
        } else {
#line 338
          tmp___0 = "MRGTdU";
        }
        {
#line 338
        memcpy(cptr, tmp___0, (unsigned long )4);
        }
      } else
#line 339
      if (scan_mask & 4U) {
        {
#line 340
        memcpy(cptr, "C   dU", (unsigned long )4);
        }
      } else
#line 341
      if (scan_mask & 8U) {
        {
#line 342
        memcpy(cptr, "LFE ", (unsigned long )4);
        }
      } else
#line 343
      if (scan_mask & 16U) {
        {
#line 344
        memcpy(cptr, "LS  dU", (unsigned long )4);
        }
      } else
#line 345
      if (scan_mask & 32U) {
        {
#line 346
        memcpy(cptr, "RS  dU", (unsigned long )4);
        }
      } else {
#line 348
        *(cptr + 0) = (char )'C';
#line 349
        *(cptr + 1) = (char )(uci / 100 + 48);
#line 350
        *(cptr + 2) = (char )((uci % 100) / 10 + 48);
#line 351
        *(cptr + 3) = (char )(uci % 10 + 48);
#line 352
        uci ++;
      }
#line 355
      scan_mask <<= 1;
#line 356
      cptr += 4;
#line 331
      ci ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 360
    error_line("can\'t allocate memory!");
    }
#line 361
    return (0);
  }
  {
#line 364
  data_size = total_samples * (long )num_channels;
#line 365
  prop_chunk_size = (int64_t )(((((sizeof(prop_header) + sizeof(fs_chunk)) + sizeof(chan_header)) + (unsigned long )chan_ids_size) + sizeof(cmpr_header)) + (unsigned long )cmpr_name_size);
#line 366
  file_size = (int64_t )((((sizeof(file_header) + sizeof(ver_chunk)) + (unsigned long )prop_chunk_size) + sizeof(data_header)) + (unsigned long )((data_size + 1L) & -2L));
#line 368
  memcpy((char *)file_header.ckID, "FRM8dU", (unsigned long )4);
#line 369
  file_header.ckDataSize = file_size - 12L;
#line 370
  memcpy((char *)file_header.formType, "DSD ", (unsigned long )4);
#line 372
  memcpy((char *)prop_header.ckID, "PROP", (unsigned long )4);
#line 373
  prop_header.ckDataSize = prop_chunk_size - 12L;
#line 374
  memcpy((char *)prop_header.formType, "SND dU", (unsigned long )4);
#line 376
  memcpy((char *)ver_chunk.ckID, "FVER", (unsigned long )4);
#line 377
  ver_chunk.ckDataSize = (int64_t )(sizeof(ver_chunk) - 12UL);
#line 378
  ver_chunk.version = (uint32_t )17104896;
#line 380
  memcpy((char *)fs_chunk.ckID, "FS  dU", (unsigned long )4);
#line 381
  fs_chunk.ckDataSize = (int64_t )(sizeof(fs_chunk) - 12UL);
#line 382
  __cil_tmp33 = WavpackGetSampleRate(wpc);
#line 382
  fs_chunk.sampleRate = __cil_tmp33 * 8U;
#line 384
  memcpy((char *)chan_header.ckID, "CHNL", (unsigned long )4);
#line 385
  chan_header.ckDataSize = (int64_t )((sizeof(chan_header) + (unsigned long )chan_ids_size) - 12UL);
#line 386
  chan_header.numChannels = (uint16_t )num_channels;
#line 388
  memcpy((char *)cmpr_header.ckID, "CMPR", (unsigned long )4);
#line 389
  cmpr_header.ckDataSize = (int64_t )((sizeof(cmpr_header) + (unsigned long )cmpr_name_size) - 12UL);
#line 390
  memcpy((char *)cmpr_header.compressionType, "DSD dU", (unsigned long )4);
#line 392
  memcpy((char *)data_header.ckID, "DSD ", (unsigned long )4);
#line 393
  data_header.ckDataSize = data_size;
#line 395
  WavpackNativeToBigEndian(& file_header, "4D4>dU");
#line 396
  WavpackNativeToBigEndian(& ver_chunk, "4DL");
#line 397
  WavpackNativeToBigEndian(& prop_header, "4D4");
#line 398
  WavpackNativeToBigEndian(& fs_chunk, "4DL>dU");
#line 399
  WavpackNativeToBigEndian(& chan_header, "4DS");
#line 400
  WavpackNativeToBigEndian(& cmpr_header, "4D4");
#line 401
  WavpackNativeToBigEndian(& data_header, "4D\250>dU");
#line 403
  __cil_tmp42 = DoWriteFile(outfile, & data_header, (uint32_t )sizeof(data_header),
                            & bcount);
  }
  {
#line 403
  __cil_tmp41 = DoWriteFile(outfile, cmpr_name, (uint32_t )cmpr_name_size, & bcount);
  }
  {
#line 403
  __cil_tmp40 = DoWriteFile(outfile, & cmpr_header, (uint32_t )sizeof(cmpr_header),
                            & bcount);
  }
  {
#line 403
  __cil_tmp39 = DoWriteFile(outfile, chan_ids, (uint32_t )chan_ids_size, & bcount);
  }
  {
#line 403
  __cil_tmp38 = DoWriteFile(outfile, & chan_header, (uint32_t )sizeof(chan_header),
                            & bcount);
  }
  {
#line 403
  __cil_tmp37 = DoWriteFile(outfile, & fs_chunk, (uint32_t )sizeof(fs_chunk), & bcount);
  }
  {
#line 403
  __cil_tmp36 = DoWriteFile(outfile, & prop_header, (uint32_t )sizeof(prop_header),
                            & bcount);
  }
  {
#line 403
  __cil_tmp35 = DoWriteFile(outfile, & ver_chunk, (uint32_t )sizeof(ver_chunk), & bcount);
  }
  {
#line 403
  __cil_tmp34 = DoWriteFile(outfile, & file_header, (uint32_t )sizeof(file_header),
                            & bcount);
  }
#line 403
  if (! __cil_tmp34) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if ((unsigned long )bcount != sizeof(file_header)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (! __cil_tmp35) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if ((unsigned long )bcount != sizeof(ver_chunk)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (! __cil_tmp36) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if ((unsigned long )bcount != sizeof(prop_header)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (! __cil_tmp37) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if ((unsigned long )bcount != sizeof(fs_chunk)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (! __cil_tmp38) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if ((unsigned long )bcount != sizeof(chan_header)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (! __cil_tmp39) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (bcount != (unsigned int )chan_ids_size) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (! __cil_tmp40) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if ((unsigned long )bcount != sizeof(cmpr_header)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (! __cil_tmp41) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (bcount != (unsigned int )cmpr_name_size) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if (! __cil_tmp42) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  } else
#line 403
  if ((unsigned long )bcount != sizeof(data_header)) {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 412
    error_line("can\'t write .DSF data, disk probably full!");
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
    {
#line 413
    free(chan_ids);
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
#line 414
    return (0);
  }
  {
#line 417
  free(chan_ids);
  }
#line 418
  return (1);
}
}
#line 92 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
static char const   TMH_full[21]  = 
#line 92 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
  {      (char )1,      (char )2,      (char )3,      (char )13, 
        (char )9,      (char )10,      (char )5,      (char )6, 
        (char )12,      (char )14,      (char )15,      (char )16, 
        (char )17,      (char )9,      (char )4,      (char )18, 
        (char )7,      (char )8,      (char )19,      (char )20, 
        (char )21};
#line 93 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
static char const   TMH_std[16]  = 
#line 93
  {      (char )1,      (char )2,      (char )3,      (char )11, 
        (char )8,      (char )9,      (char )5,      (char )6, 
        (char )10,      (char )12,      (char )13,      (char )14, 
        (char )15,      (char )7,      (char )4,      (char )16};
#line 100 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
static struct __anonstruct_166 layouts[47]  = 
#line 100
  {      {(uint32_t )((100 << 16) | 1), (uint32_t )4, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((101 << 16) | 2),
      (uint32_t )3, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((102 << 16) | 2), (uint32_t )3, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((103 << 16) | 2),
      (uint32_t )0, (char const   *)((void *)0), "&\'"}, 
        {(uint32_t )((104 << 16) | 2), (uint32_t )0, (char const   *)((void *)0), "\314\315"}, 
        {(uint32_t )((105 << 16) | 2),
      (uint32_t )0, (char const   *)((void *)0), "\316\317"}, 
        {(uint32_t )((106 << 16) | 2), (uint32_t )3, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((107 << 16) | 4),
      (uint32_t )0, (char const   *)((void *)0), "\310\311\312\313"}, 
        {(uint32_t )((108 << 16) | 4), (uint32_t )51, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((109 << 16) | 5),
      (uint32_t )55, "12453", (char const   *)((void *)0)}, 
        {(uint32_t )((110 << 16) | 6), (uint32_t )311, "124536", (char const   *)((void *)0)}, 
        {(uint32_t )((111 << 16) | 8),
      (uint32_t )1847, "12453678\251", (char const   *)((void *)0)}, 
        {(uint32_t )((112 << 16) | 8), (uint32_t )184371, (char const   *)((void *)0),
      (char const   *)((void *)0)}, 
        {(uint32_t )((113 << 16) | 3), (uint32_t )7, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((114 << 16) | 3),
      (uint32_t )7, "312", (char const   *)((void *)0)}, 
        {(uint32_t )((115 << 16) | 4), (uint32_t )263, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((116 << 16) | 4),
      (uint32_t )263, "3124", (char const   *)((void *)0)}, 
        {(uint32_t )((117 << 16) | 5), (uint32_t )55, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((118 << 16) | 5),
      (uint32_t )55, "12453", (char const   *)((void *)0)}, 
        {(uint32_t )((119 << 16) | 5), (uint32_t )55, "13245", (char const   *)((void *)0)}, 
        {(uint32_t )((120 << 16) | 5),
      (uint32_t )55, "31245", (char const   *)((void *)0)}, 
        {(uint32_t )((121 << 16) | 6), (uint32_t )63, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((122 << 16) | 6),
      (uint32_t )63, "125634", (char const   *)((void *)0)}, 
        {(uint32_t )((123 << 16) | 6), (uint32_t )63, "132564", (char const   *)((void *)0)}, 
        {(uint32_t )((124 << 16) | 6),
      (uint32_t )63, "312564", (char const   *)((void *)0)}, 
        {(uint32_t )((125 << 16) | 7), (uint32_t )319, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((126 << 16) | 8),
      (uint32_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((127 << 16) | 8), (uint32_t )255, "37812564\251", (char const   *)((void *)0)}, 
        {(uint32_t )((128 << 16) | 8),
      (uint32_t )63, (char const   *)((void *)0), "!\""}, 
        {(uint32_t )((129 << 16) | 8), (uint32_t )255, "12563478\251", (char const   *)((void *)0)}, 
        {(uint32_t )((130 << 16) | 8),
      (uint32_t )63, (char const   *)((void *)0), "&\'"}, 
        {(uint32_t )((131 << 16) | 3), (uint32_t )259, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((132 << 16) | 4),
      (uint32_t )51, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((133 << 16) | 3), (uint32_t )11, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((134 << 16) | 4),
      (uint32_t )267, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((135 << 16) | 5), (uint32_t )59, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((136 << 16) | 4),
      (uint32_t )15, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((137 << 16) | 5), (uint32_t )271, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((138 << 16) | 5),
      (uint32_t )59, "12453", (char const   *)((void *)0)}, 
        {(uint32_t )((139 << 16) | 6), (uint32_t )311, "124536", (char const   *)((void *)0)}, 
        {(uint32_t )((140 << 16) | 7),
      (uint32_t )55, "1245367", "!\""}, 
        {(uint32_t )((141 << 16) | 6), (uint32_t )311, "312456", (char const   *)((void *)0)}, 
        {(uint32_t )((142 << 16) | 7),
      (uint32_t )319, "3125674", (char const   *)((void *)0)}, 
        {(uint32_t )((143 << 16) | 7), (uint32_t )55, "3124567", "!\""}, 
        {(uint32_t )((144 << 16) | 8), (uint32_t )311, "31245786\323\001 ", "!\""}, 
        {(uint32_t )((145 << 16) | 16), (uint32_t )30527, (char const   *)TMH_std, "#$,%\033"}, 
        {(uint32_t )((146 << 16) | 21),
      (uint32_t )30719, (char const   *)TMH_full, "#$,% "}};
#line 153 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
int ParseCaffHeaderConfig(FILE *infile , char *infilename , char *fourcc , WavpackContext *wpc ,
                          WavpackConfig *config ) 
{ 
  uint32_t chan_chunk ;
  uint32_t channel_layout ;
  uint32_t bcount ;
  unsigned char *channel_identities ;
  unsigned char *channel_reorder ;
  int64_t total_samples ;
  int64_t infilesize ;
  CAFFileHeader caf_file_header ;
  CAFChunkHeader caf_chunk_header ;
  CAFAudioFormat caf_audio_format ;
  int i ;
  int64_t __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  int supported ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  char *__cil_tmp28 ;
  char formatstr[5] ;
  int __cil_tmp30 ;
  double __cil_tmp31 ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int __cil_tmp35 ;
  CAFChannelLayout *caf_channel_layout ;
  void *__cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  char *__cil_tmp40 ;
  CAFChannelDescription *descriptions ;
  int num_descriptions ;
  int label ;
  int cindex ;
  int idents ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  int __cil_tmp48 ;
  uint32_t clabel ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  uint32_t tmp___2 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  char reorder_string[9] ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int __cil_tmp60 ;
  uint32_t mEditCount ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  char *__cil_tmp64 ;
  int64_t __cil_tmp65 ;
  int64_t __cil_tmp66 ;
  int bytes_to_copy ;
  char *buff ;
  void *__cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  char *__cil_tmp72 ;
  int __cil_tmp73 ;
  char *__cil_tmp74 ;
  int __cil_tmp75 ;

  {
#line 155
  chan_chunk = (uint32_t )0;
  {
#line 155
  channel_layout = (uint32_t )0;
#line 156
  channel_identities = (unsigned char *)((void *)0);
#line 157
  channel_reorder = (unsigned char *)((void *)0);
#line 158
  total_samples = (int64_t )0;
#line 164
  infilesize = DoGetFileSize(infile);
#line 165
  memcpy(& caf_file_header, fourcc, (unsigned long )4);
#line 167
  __cil_tmp18 = DoReadFile(infile, (char *)(& caf_file_header) + 4, (uint32_t )(sizeof(CAFFileHeader ) - 4UL),
                           & bcount);
  }
#line 167
  if (! __cil_tmp18) {
    {
    {
#line 169
    error_line("%s is not a valid .CAF file!", infilename);
    }
    }
#line 170
    return (1);
  } else
#line 167
  if ((unsigned long )bcount != sizeof(CAFFileHeader ) - 4UL) {
    {
    {
#line 169
    error_line("%s is not a valid .CAF file!", infilename);
    }
    }
#line 170
    return (1);
  } else {
    {
#line 172
    __cil_tmp19 = WavpackAddWrapper(wpc, & caf_file_header, (uint32_t )sizeof(CAFFileHeader ));
    }
#line 172
    if (! (config->qmode & 512)) {
#line 172
      if (! __cil_tmp19) {
        {
#line 174
        __cil_tmp20 = WavpackGetErrorMessage(wpc);
#line 174
        error_line("%s", __cil_tmp20);
        }
#line 175
        return (1);
      }
    }
  }
  {
#line 178
  WavpackBigEndianToNative(& caf_file_header, "4SS");
  }
#line 180
  if ((int )caf_file_header.mFileVersion != 1) {
    {
#line 181
    error_line("%s: can\'t handle version %d .CAF files!", infilename, (int )caf_file_header.mFileVersion);
    }
#line 182
    return (1);
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 189
    __cil_tmp21 = DoReadFile(infile, & caf_chunk_header, (uint32_t )sizeof(CAFChunkHeader ),
                             & bcount);
    }
#line 189
    if (! __cil_tmp21) {
      {
      {
#line 191
      error_line("%s is not a valid .CAF file!", infilename);
      }
      }
#line 192
      return (1);
    } else
#line 189
    if ((unsigned long )bcount != sizeof(CAFChunkHeader )) {
      {
      {
#line 191
      error_line("%s is not a valid .CAF file!", infilename);
      }
      }
#line 192
      return (1);
    } else {
      {
#line 194
      __cil_tmp22 = WavpackAddWrapper(wpc, & caf_chunk_header, (uint32_t )sizeof(CAFChunkHeader ));
      }
#line 194
      if (! (config->qmode & 512)) {
#line 194
        if (! __cil_tmp22) {
          {
#line 196
          __cil_tmp23 = WavpackGetErrorMessage(wpc);
#line 196
          error_line("%s", __cil_tmp23);
          }
#line 197
          return (1);
        }
      }
    }
    {
#line 200
    WavpackBigEndianToNative(& caf_chunk_header, "4D");
#line 205
    __cil_tmp24 = strncmp((char const   *)((char *)caf_chunk_header.mChunkType), "desc",
                          (unsigned long )4);
    }
#line 205
    if (! __cil_tmp24) {
      {
#line 206
      supported = 1;
#line 208
      __cil_tmp26 = DoReadFile(infile, & caf_audio_format, (uint32_t )caf_chunk_header.mChunkSize,
                               & bcount);
      }
#line 208
      if ((unsigned long )caf_chunk_header.mChunkSize != sizeof(CAFAudioFormat )) {
        {
        {
        {
#line 211
        error_line("%s is not a valid .CAF file!", infilename);
        }
        }
        }
#line 212
        return (1);
      } else
#line 208
      if (! __cil_tmp26) {
        {
        {
        {
#line 211
        error_line("%s is not a valid .CAF file!", infilename);
        }
        }
        }
#line 212
        return (1);
      } else
#line 208
      if ((long )bcount != caf_chunk_header.mChunkSize) {
        {
        {
        {
#line 211
        error_line("%s is not a valid .CAF file!", infilename);
        }
        }
        }
#line 212
        return (1);
      } else {
        {
#line 214
        __cil_tmp27 = WavpackAddWrapper(wpc, & caf_audio_format, (uint32_t )caf_chunk_header.mChunkSize);
        }
#line 214
        if (! (config->qmode & 512)) {
#line 214
          if (! __cil_tmp27) {
            {
#line 216
            __cil_tmp28 = WavpackGetErrorMessage(wpc);
#line 216
            error_line("%s", __cil_tmp28);
            }
#line 217
            return (1);
          }
        }
      }
      {
#line 220
      WavpackBigEndianToNative(& caf_audio_format, "D4LLLLL");
      }
#line 222
      if (debug_logging_mode) {
        {
#line 225
        memcpy((char *)formatstr, (char *)caf_audio_format.mFormatID, (unsigned long )4);
#line 226
        formatstr[4] = (char )0;
#line 227
        error_line("format = %s, flags = %x, sampling rate = %g", (char *)formatstr,
                   caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
#line 229
        error_line("packet = %d bytes and %d frames", caf_audio_format.mBytesPerPacket,
                   caf_audio_format.mFramesPerPacket);
#line 231
        error_line("channels per frame = %d, bits per channel = %d", caf_audio_format.mChannelsPerFrame,
                   caf_audio_format.mBitsPerChannel);
        }
      }
      {
#line 235
      __cil_tmp30 = strncmp((char const   *)((char *)caf_audio_format.mFormatID),
                            "lpcm", (unsigned long )4);
      }
#line 235
      if (__cil_tmp30) {
#line 236
        supported = 0;
      } else
#line 235
      if (caf_audio_format.mFormatFlags & 4294967292U) {
#line 236
        supported = 0;
      } else {
        {
#line 237
        __cil_tmp31 = floor(caf_audio_format.mSampleRate);
        }
#line 237
        if (caf_audio_format.mSampleRate < 1.) {
#line 239
          supported = 0;
        } else
#line 237
        if (caf_audio_format.mSampleRate > 16777215.) {
#line 239
          supported = 0;
        } else
#line 237
        if (caf_audio_format.mSampleRate != __cil_tmp31) {
#line 239
          supported = 0;
        } else
#line 240
        if (! caf_audio_format.mChannelsPerFrame) {
#line 241
          supported = 0;
        } else
#line 240
        if (caf_audio_format.mChannelsPerFrame > 256U) {
#line 241
          supported = 0;
        } else
#line 242
        if (caf_audio_format.mBitsPerChannel < 1U) {
#line 244
          supported = 0;
        } else
#line 242
        if (caf_audio_format.mBitsPerChannel > 32U) {
#line 244
          supported = 0;
        } else
#line 242
        if (caf_audio_format.mFormatFlags & 1U) {
#line 242
          if (caf_audio_format.mBitsPerChannel != 32U) {
#line 244
            supported = 0;
          } else {
#line 242
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 245
        if (caf_audio_format.mFramesPerPacket != 1U) {
#line 249
          supported = 0;
        } else
#line 245
        if (caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7U) / 8U) {
#line 249
          supported = 0;
        } else
#line 245
        if (caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4U) {
#line 249
          supported = 0;
        } else
#line 245
        if (caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame) {
#line 249
          supported = 0;
        }
      }
#line 251
      if (! supported) {
        {
#line 252
        error_line("%s is an unsupported .CAF format!", infilename);
        }
#line 253
        return (1);
      }
#line 256
      config->bytes_per_sample = (int )(caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame);
#line 257
      if (caf_audio_format.mFormatFlags & 1U) {
#line 257
        tmp = 127;
      } else {
#line 257
        tmp = 0;
      }
#line 257
      config->float_norm_exp = tmp;
#line 258
      config->bits_per_sample = (int )caf_audio_format.mBitsPerChannel;
#line 259
      config->num_channels = (int )caf_audio_format.mChannelsPerFrame;
#line 260
      config->sample_rate = (int )caf_audio_format.mSampleRate;
#line 262
      if (! (caf_audio_format.mFormatFlags & 2U)) {
#line 262
        if (config->bytes_per_sample > 1) {
#line 263
          config->qmode |= 1;
        }
      }
#line 265
      if (config->bytes_per_sample == 1) {
#line 266
        config->qmode |= 2;
      }
#line 268
      if (debug_logging_mode) {
#line 269
        if (config->float_norm_exp == 127) {
#line 270
          if (config->qmode & 1) {
#line 270
            tmp___0 = "big";
          } else {
#line 270
            tmp___0 = "little";
          }
          {
#line 270
          error_line("data format: 32-bit %s-endian floating point", tmp___0);
          }
        } else {
#line 272
          if (config->qmode & 1) {
#line 272
            tmp___1 = "big";
          } else {
#line 272
            tmp___1 = "little";
          }
          {
#line 272
          error_line("data format: %d-bit %s-endian integers stored in %d byte(s)",
                     config->bits_per_sample, tmp___1, config->bytes_per_sample);
          }
        }
      }
    } else {
      {
#line 276
      __cil_tmp35 = strncmp((char const   *)((char *)caf_chunk_header.mChunkType),
                            "chan", (unsigned long )4);
      }
#line 276
      if (! __cil_tmp35) {
        {
#line 277
        __cil_tmp37 = malloc((size_t )caf_chunk_header.mChunkSize);
#line 277
        caf_channel_layout = __cil_tmp37;
#line 279
        __cil_tmp38 = DoReadFile(infile, caf_channel_layout, (uint32_t )caf_chunk_header.mChunkSize,
                                 & bcount);
        }
#line 279
        if ((unsigned long )caf_chunk_header.mChunkSize < sizeof(CAFChannelLayout )) {
          {
          {
          {
#line 282
          error_line("%s is not a valid .CAF file!", infilename);
          }
          }
          {
          {
#line 283
          free(caf_channel_layout);
          }
          }
          }
#line 284
          return (1);
        } else
#line 279
        if (! __cil_tmp38) {
          {
          {
          {
#line 282
          error_line("%s is not a valid .CAF file!", infilename);
          }
          }
          {
          {
#line 283
          free(caf_channel_layout);
          }
          }
          }
#line 284
          return (1);
        } else
#line 279
        if ((long )bcount != caf_chunk_header.mChunkSize) {
          {
          {
          {
#line 282
          error_line("%s is not a valid .CAF file!", infilename);
          }
          }
          {
          {
#line 283
          free(caf_channel_layout);
          }
          }
          }
#line 284
          return (1);
        } else {
          {
#line 286
          __cil_tmp39 = WavpackAddWrapper(wpc, caf_channel_layout, (uint32_t )caf_chunk_header.mChunkSize);
          }
#line 286
          if (! (config->qmode & 512)) {
#line 286
            if (! __cil_tmp39) {
              {
#line 288
              __cil_tmp40 = WavpackGetErrorMessage(wpc);
#line 288
              error_line("%s", __cil_tmp40);
#line 289
              free(caf_channel_layout);
              }
#line 290
              return (1);
            }
          }
        }
        {
#line 293
        WavpackBigEndianToNative(caf_channel_layout, "LLL");
#line 294
        chan_chunk = (uint32_t )1;
        }
#line 296
        if (config->channel_mask) {
          {
          {
#line 297
          error_line("this CAF file already has channel order information!");
          }
          {
#line 298
          free(caf_channel_layout);
          }
          }
#line 299
          return (1);
        } else
#line 296
        if (config->qmode & 1024) {
          {
          {
#line 297
          error_line("this CAF file already has channel order information!");
          }
          {
#line 298
          free(caf_channel_layout);
          }
          }
#line 299
          return (1);
        }
        {
#line 303
        if (caf_channel_layout->mChannelLayoutTag == (uint32_t )0) {
#line 303
          goto case_0;
        }
#line 409
        if (caf_channel_layout->mChannelLayoutTag == (uint32_t )65536) {
#line 409
          goto case_65536;
        }
#line 418
        goto switch_default;
        case_0: /* CIL Label */ 
#line 305
        descriptions = (CAFChannelDescription *)(caf_channel_layout + 1);
#line 306
        num_descriptions = (int )caf_channel_layout->mNumberChannelDescriptions;
#line 307
        cindex = 0;
#line 307
        idents = 0;
#line 309
        if ((unsigned long )caf_chunk_header.mChunkSize != sizeof(CAFChannelLayout ) + sizeof(CAFChannelDescription ) * (unsigned long )num_descriptions) {
          {
          {
#line 311
          error_line("channel descriptions in \'chan\' chunk are the wrong size!\220");
          }
          {
#line 312
          free(caf_channel_layout);
          }
          }
#line 313
          return (1);
        } else
#line 309
        if (num_descriptions != config->num_channels) {
          {
          {
#line 311
          error_line("channel descriptions in \'chan\' chunk are the wrong size!\220");
          }
          {
#line 312
          free(caf_channel_layout);
          }
          }
#line 313
          return (1);
        }
#line 316
        if (num_descriptions >= 256) {
          {
#line 317
          error_line("%d channel descriptions is more than we can handle...ignoring!");
          }
#line 318
          goto switch_break;
        }
        {
#line 325
        channel_reorder = (unsigned char *)malloc((unsigned long )num_descriptions);
#line 326
        memset(channel_reorder, - 1, (unsigned long )num_descriptions);
#line 327
        channel_identities = (unsigned char *)malloc((unsigned long )(num_descriptions + 1));
#line 331
        i = 0;
        }
        {
#line 331
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 331
          if (! (i < num_descriptions)) {
#line 331
            goto while_break___0;
          }
          {
#line 332
          WavpackBigEndianToNative(descriptions + i, "LLLLL");
          }
#line 334
          if (debug_logging_mode) {
            {
#line 335
            error_line("chan %d --> %d", i + 1, (descriptions + i)->mChannelLabel);
            }
          }
#line 331
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 340
        label = 1;
        {
#line 340
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 340
          if (! (label <= 18)) {
#line 340
            goto while_break___1;
          }
#line 341
          i = 0;
          {
#line 341
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 341
            if (! (i < num_descriptions)) {
#line 341
              goto while_break___2;
            }
#line 342
            if ((descriptions + i)->mChannelLabel == (unsigned int )label) {
#line 343
              config->channel_mask |= 1 << (label - 1);
#line 344
              __cil_tmp48 = cindex;
#line 344
              cindex ++;
#line 344
              *(channel_reorder + i) = (unsigned char )__cil_tmp48;
#line 345
              goto while_break___2;
            }
#line 341
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 340
          label ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 350
        i = 0;
        {
#line 350
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 350
          if (! (i < num_descriptions)) {
#line 350
            goto while_break___3;
          }
#line 351
          if ((int )*(channel_reorder + i) == 255) {
#line 352
            clabel = (descriptions + i)->mChannelLabel;
#line 354
            if (clabel == 0U) {
#line 355
              __cil_tmp50 = idents;
#line 355
              idents ++;
#line 355
              *(channel_identities + __cil_tmp50) = (unsigned char )255;
            } else
#line 354
            if (clabel == 4294967295U) {
#line 355
              __cil_tmp50 = idents;
#line 355
              idents ++;
#line 355
              *(channel_identities + __cil_tmp50) = (unsigned char )255;
            } else
#line 354
            if (clabel == 100U) {
#line 355
              __cil_tmp50 = idents;
#line 355
              idents ++;
#line 355
              *(channel_identities + __cil_tmp50) = (unsigned char )255;
            } else
#line 356
            if (clabel >= 33U) {
#line 356
              if (clabel <= 44U) {
                _L___29: /* CIL Label */ 
                _L___30: /* CIL Label */ 
#line 357
                if (clabel >= 301U) {
#line 357
                  tmp___2 = clabel - 80U;
                } else {
#line 357
                  tmp___2 = clabel;
                }
#line 357
                __cil_tmp51 = idents;
#line 357
                idents ++;
#line 357
                *(channel_identities + __cil_tmp51) = (unsigned char )tmp___2;
              } else {
#line 356
                goto _L___32;
              }
            } else
            _L___32: /* CIL Label */ 
#line 356
            if (clabel >= 200U) {
#line 356
              if (clabel <= 207U) {
#line 356
                goto _L___29;
              } else {
#line 356
                goto _L___31;
              }
            } else
            _L___31: /* CIL Label */ 
#line 356
            if (clabel >= 301U) {
#line 356
              if (clabel <= 305U) {
#line 356
                goto _L___29;
              } else {
                {
                {
#line 359
                error_line("warning: unknown channel descriptions label: %d", clabel);
                }
#line 360
                __cil_tmp53 = idents;
#line 360
                idents ++;
#line 360
                *(channel_identities + __cil_tmp53) = (unsigned char )255;
                }
              }
            } else {
              {
              {
#line 359
              error_line("warning: unknown channel descriptions label: %d", clabel);
              }
#line 360
              __cil_tmp53 = idents;
#line 360
              idents ++;
#line 360
              *(channel_identities + __cil_tmp53) = (unsigned char )255;
              }
            }
#line 363
            __cil_tmp54 = cindex;
#line 363
            cindex ++;
#line 363
            *(channel_reorder + i) = (unsigned char )__cil_tmp54;
          }
#line 350
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 368
        i = 0;
        {
#line 368
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 368
          if (! (i < num_descriptions)) {
#line 368
            goto while_break___4;
          }
#line 369
          if ((int )*(channel_reorder + i) != i) {
#line 370
            goto while_break___4;
          }
#line 368
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 372
        if (i == num_descriptions) {
          {
#line 373
          free(channel_reorder);
#line 374
          channel_reorder = (unsigned char *)((void *)0);
          }
        } else {
#line 377
          config->qmode |= 8;
#line 378
          channel_layout = (uint32_t )num_descriptions;
        }
#line 381
        if (! idents) {
          {
#line 382
          free(channel_identities);
#line 383
          channel_identities = (unsigned char *)((void *)0);
          }
        } else {
#line 386
          *(channel_identities + idents) = (unsigned char )0;
        }
#line 388
        if (debug_logging_mode) {
          {
#line 389
          error_line("layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS",
                     caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                     caf_channel_layout->mNumberChannelDescriptions, idents);
          }
#line 395
          if (channel_reorder) {
#line 395
            if (num_descriptions <= 8) {
#line 396
              reorder_string = "12345678\f";
#line 398
              i = 0;
              {
#line 398
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 398
                if (! (i < num_descriptions)) {
#line 398
                  goto while_break___5;
                }
#line 399
                reorder_string[i] = (char )((int )*(channel_reorder + i) + 49);
#line 398
                i ++;
              }
              while_break___5: /* CIL Label */ ;
              }
              {
#line 401
              reorder_string[i] = (char )0;
#line 402
              error_line("reordering string = \"%s\"\n", (char *)reorder_string);
              }
            }
          }
        }
#line 407
        goto switch_break;
        case_65536: /* CIL Label */ 
#line 410
        config->channel_mask = (int32_t )caf_channel_layout->mChannelBitmap;
#line 412
        if (debug_logging_mode) {
          {
#line 413
          error_line("layout_tag = 0x%08x, so using supplied bitmap of 0x%08x", caf_channel_layout->mChannelLayoutTag,
                     caf_channel_layout->mChannelBitmap);
          }
        }
#line 416
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 419
        i = 0;
        {
#line 419
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 419
          if (! ((unsigned long )i < sizeof(layouts) / sizeof(layouts[0]))) {
#line 419
            goto while_break___6;
          }
#line 420
          if (caf_channel_layout->mChannelLayoutTag == layouts[i].mChannelLayoutTag) {
#line 421
            config->channel_mask = (int32_t )layouts[i].mChannelBitmap;
#line 422
            channel_layout = layouts[i].mChannelLayoutTag;
#line 424
            if (layouts[i].mChannelReorder) {
              {
#line 425
              __cil_tmp56 = strdup(layouts[i].mChannelReorder);
#line 425
              channel_reorder = (unsigned char *)__cil_tmp56;
#line 426
              config->qmode |= 8;
              }
            }
#line 429
            if (layouts[i].mChannelIdentities) {
              {
#line 430
              __cil_tmp57 = strdup(layouts[i].mChannelIdentities);
#line 430
              channel_identities = (unsigned char *)__cil_tmp57;
              }
            }
#line 432
            if (debug_logging_mode) {
#line 433
              if (channel_reorder) {
#line 433
                tmp___3 = "yes";
              } else {
#line 433
                tmp___3 = "no";
              }
#line 433
              if (channel_identities) {
#line 433
                tmp___4 = "yes";
              } else {
#line 433
                tmp___4 = "no";
              }
              {
#line 433
              error_line("layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\230\001",
                         channel_layout, config->channel_mask, tmp___3, tmp___4);
              }
            }
#line 436
            goto while_break___6;
          }
#line 419
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 439
        if ((unsigned long )i == sizeof(layouts) / sizeof(layouts[0])) {
#line 439
          if (debug_logging_mode) {
            {
#line 440
            error_line("layout_tag 0x%08x not found in table...all channels unassigned",
                       caf_channel_layout->mChannelLayoutTag);
            }
          }
        }
#line 443
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 446
        free(caf_channel_layout);
        }
      } else {
        {
#line 448
        __cil_tmp60 = strncmp((char const   *)((char *)caf_chunk_header.mChunkType),
                              "data", (unsigned long )4);
        }
#line 448
        if (! __cil_tmp60) {
          {
#line 451
          __cil_tmp62 = DoReadFile(infile, & mEditCount, (uint32_t )sizeof(mEditCount),
                                   & bcount);
          }
#line 451
          if (! __cil_tmp62) {
            {
            {
#line 453
            error_line("%s is not a valid .CAF file!", infilename);
            }
            }
#line 454
            return (1);
          } else
#line 451
          if ((unsigned long )bcount != sizeof(mEditCount)) {
            {
            {
#line 453
            error_line("%s is not a valid .CAF file!", infilename);
            }
            }
#line 454
            return (1);
          } else {
            {
#line 456
            __cil_tmp63 = WavpackAddWrapper(wpc, & mEditCount, (uint32_t )sizeof(mEditCount));
            }
#line 456
            if (! (config->qmode & 512)) {
#line 456
              if (! __cil_tmp63) {
                {
#line 458
                __cil_tmp64 = WavpackGetErrorMessage(wpc);
#line 458
                error_line("%s", __cil_tmp64);
                }
#line 459
                return (1);
              }
            }
          }
#line 462
          if (config->qmode & 2048) {
            _L___33: /* CIL Label */ 
            {
#line 463
            config->qmode |= 2048;
#line 465
            __cil_tmp65 = DoGetFilePosition(infile);
            }
#line 465
            if (infilesize) {
#line 465
              if (__cil_tmp65 != -1L) {
                {
#line 466
                __cil_tmp66 = DoGetFilePosition(infile);
#line 466
                total_samples = (infilesize - __cil_tmp66) / (long )caf_audio_format.mBytesPerPacket;
                }
              } else {
#line 468
                total_samples = (int64_t )(- 1);
              }
            } else {
#line 468
              total_samples = (int64_t )(- 1);
            }
          } else
#line 462
          if (caf_chunk_header.mChunkSize == -1L) {
#line 462
            goto _L___33;
          } else {
#line 471
            if (infilesize) {
#line 471
              if (infilesize - caf_chunk_header.mChunkSize > 16777216L) {
                {
#line 472
                error_line(".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!",
                           infilename);
                }
#line 473
                return (1);
              }
            }
#line 476
            if ((caf_chunk_header.mChunkSize - 4L) % (long )caf_audio_format.mBytesPerPacket) {
              {
#line 477
              error_line(".CAF file %s has an invalid data chunk size, probably is corrupt!",
                         infilename);
              }
#line 478
              return (1);
            }
#line 481
            total_samples = (caf_chunk_header.mChunkSize - 4L) / (long )caf_audio_format.mBytesPerPacket;
#line 483
            if (! total_samples) {
              {
#line 484
              error_line("this .CAF file has no audio samples, probably is corrupt!");
              }
#line 485
              return (1);
            }
#line 488
            if ((long long )total_samples > (1LL << 40) - 257LL) {
              {
#line 489
              error_line("%s has too many samples for WavPack!", infilename);
              }
#line 490
              return (1);
            }
          }
#line 494
          goto while_break;
        } else {
          {
#line 498
          bytes_to_copy = (int )((uint32_t )caf_chunk_header.mChunkSize);
#line 499
          __cil_tmp69 = malloc((unsigned long )bytes_to_copy);
#line 499
          buff = __cil_tmp69;
          }
#line 501
          if (debug_logging_mode) {
            {
#line 502
            error_line("extra unknown chunk \"%c%c%c%c\" of %d bytes", (int )caf_chunk_header.mChunkType[0],
                       (int )caf_chunk_header.mChunkType[1], (int )caf_chunk_header.mChunkType[2],
                       (int )caf_chunk_header.mChunkType[3], caf_chunk_header.mChunkSize);
            }
          }
          {
#line 506
          __cil_tmp71 = WavpackAddWrapper(wpc, buff, (uint32_t )bytes_to_copy);
          }
          {
#line 506
          __cil_tmp70 = DoReadFile(infile, buff, (uint32_t )bytes_to_copy, & bcount);
          }
#line 506
          if (! __cil_tmp70) {
            {
            {
            {
#line 510
            __cil_tmp72 = WavpackGetErrorMessage(wpc);
            }
            }
            {
            {
#line 510
            error_line("%s", __cil_tmp72);
            }
            }
            {
            {
#line 511
            free(buff);
            }
            }
            }
#line 512
            return (1);
          } else
#line 506
          if (bcount != (unsigned int )bytes_to_copy) {
            {
            {
            {
#line 510
            __cil_tmp72 = WavpackGetErrorMessage(wpc);
            }
            }
            {
            {
#line 510
            error_line("%s", __cil_tmp72);
            }
            }
            {
            {
#line 511
            free(buff);
            }
            }
            }
#line 512
            return (1);
          } else
#line 506
          if (! (config->qmode & 512)) {
#line 506
            if (! __cil_tmp71) {
              {
              {
              {
#line 510
              __cil_tmp72 = WavpackGetErrorMessage(wpc);
              }
              }
              {
              {
#line 510
              error_line("%s", __cil_tmp72);
              }
              }
              {
              {
#line 511
              free(buff);
              }
              }
              }
#line 512
              return (1);
            }
          }
          {
#line 515
          free(buff);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  if (! chan_chunk) {
#line 519
    if (! config->channel_mask) {
#line 519
      if (config->num_channels <= 2) {
#line 519
        if (! (config->qmode & 1024)) {
#line 520
          config->channel_mask = 5 - config->num_channels;
        }
      }
    }
  }
  {
#line 522
  __cil_tmp73 = WavpackSetConfiguration64(wpc, config, total_samples, (unsigned char const   *)channel_identities);
  }
#line 522
  if (! __cil_tmp73) {
    {
#line 523
    __cil_tmp74 = WavpackGetErrorMessage(wpc);
#line 523
    error_line("%s", __cil_tmp74);
    }
#line 524
    return (1);
  }
#line 527
  if (channel_identities) {
    {
#line 528
    free(channel_identities);
    }
  }
#line 530
  if (channel_reorder) {
    _L___34: /* CIL Label */ 
    {
#line 531
    __cil_tmp75 = WavpackSetChannelLayout(wpc, channel_layout, (unsigned char const   *)channel_reorder);
    }
#line 531
    if (! __cil_tmp75) {
      {
#line 532
      error_line("problem with setting channel layout (should not happen)");
      }
#line 533
      return (1);
    }
#line 536
    if (channel_reorder) {
      {
#line 537
      free(channel_reorder);
      }
    }
  } else
#line 530
  if (channel_layout) {
#line 530
    goto _L___34;
  }
#line 540
  return (0);
}
}
#line 543 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
int WriteCaffHeader(FILE *outfile , WavpackContext *wpc , int64_t total_samples ,
                    int qmode ) 
{ 
  CAFChunkHeader caf_desc_chunk_header ;
  CAFChunkHeader caf_chan_chunk_header ;
  CAFChunkHeader caf_data_chunk_header ;
  CAFChannelLayout caf_channel_layout ;
  CAFAudioFormat caf_audio_format ;
  CAFFileHeader caf_file_header ;
  uint32_t mEditCount ;
  uint32_t bcount ;
  int num_channels ;
  int __cil_tmp14 ;
  int32_t channel_mask ;
  int __cil_tmp16 ;
  int32_t sample_rate ;
  uint32_t __cil_tmp18 ;
  int bytes_per_sample ;
  int __cil_tmp20 ;
  int bits_per_sample ;
  int __cil_tmp22 ;
  int float_norm_exp ;
  int __cil_tmp24 ;
  uint32_t channel_layout_tag ;
  uint32_t __cil_tmp26 ;
  unsigned char *channel_identities ;
  void *__cil_tmp28 ;
  int num_identified_chans ;
  int i ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int tmp ;
  int __cil_tmp35 ;
  int tmp___0 ;
  int bits ;
  int bmask ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  CAFChannelDescription caf_channel_description ;
  unsigned char *new_channel_order ;
  int i___35 ;
  char const   *tmp___1 ;
  void *__cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  unsigned char chan_id ;
  int tmp___2 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;

  {
  {
#line 551
  __cil_tmp14 = WavpackGetNumChannels(wpc);
#line 551
  num_channels = __cil_tmp14;
#line 552
  __cil_tmp16 = WavpackGetChannelMask(wpc);
#line 552
  channel_mask = __cil_tmp16;
#line 553
  __cil_tmp18 = WavpackGetSampleRate(wpc);
#line 553
  sample_rate = (int32_t )__cil_tmp18;
#line 554
  __cil_tmp20 = WavpackGetBytesPerSample(wpc);
#line 554
  bytes_per_sample = __cil_tmp20;
#line 555
  __cil_tmp22 = WavpackGetBitsPerSample(wpc);
#line 555
  bits_per_sample = __cil_tmp22;
#line 556
  __cil_tmp24 = WavpackGetFloatNormExp(wpc);
#line 556
  float_norm_exp = __cil_tmp24;
#line 557
  __cil_tmp26 = WavpackGetChannelLayout(wpc, (unsigned char *)((void *)0));
#line 557
  channel_layout_tag = __cil_tmp26;
#line 558
  __cil_tmp28 = malloc((unsigned long )(num_channels + 1));
#line 558
  channel_identities = __cil_tmp28;
  }
#line 561
  if (float_norm_exp) {
#line 561
    if (float_norm_exp != 127) {
      {
#line 562
      error_line("can\'t create valid CAFF header for non-normalized floating data!\220");
#line 563
      free(channel_identities);
      }
#line 564
      return (0);
    }
  }
  {
#line 569
  WavpackGetChannelIdentities(wpc, channel_identities);
#line 571
  i = 0;
#line 571
  num_identified_chans = i;
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i < num_channels)) {
#line 571
      goto while_break;
    }
#line 572
    if ((int )*(channel_identities + i) != 255) {
#line 573
      num_identified_chans ++;
    }
#line 571
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 577
  strncpy((char *)caf_file_header.mFileType, "caff", sizeof(caf_file_header.mFileType));
#line 578
  caf_file_header.mFileVersion = (uint16_t )1;
#line 579
  caf_file_header.mFileFlags = (uint16_t )0;
#line 580
  WavpackNativeToBigEndian(& caf_file_header, "4SS");
#line 582
  __cil_tmp32 = DoWriteFile(outfile, & caf_file_header, (uint32_t )sizeof(caf_file_header),
                            & bcount);
  }
#line 582
  if (! __cil_tmp32) {
#line 584
    return (0);
  } else
#line 582
  if ((unsigned long )bcount != sizeof(caf_file_header)) {
#line 584
    return (0);
  }
  {
#line 588
  strncpy((char *)caf_desc_chunk_header.mChunkType, "desc", sizeof(caf_desc_chunk_header.mChunkType));
#line 589
  caf_desc_chunk_header.mChunkSize = (int64_t )sizeof(caf_audio_format);
#line 590
  WavpackNativeToBigEndian(& caf_desc_chunk_header, "4D\305>dU");
#line 592
  __cil_tmp33 = DoWriteFile(outfile, & caf_desc_chunk_header, (uint32_t )sizeof(caf_desc_chunk_header),
                            & bcount);
  }
#line 592
  if (! __cil_tmp33) {
#line 594
    return (0);
  } else
#line 592
  if ((unsigned long )bcount != sizeof(caf_desc_chunk_header)) {
#line 594
    return (0);
  }
  {
#line 596
  caf_audio_format.mSampleRate = (double )sample_rate;
#line 597
  strncpy((char *)caf_audio_format.mFormatID, "lpcmdU", sizeof(caf_audio_format.mFormatID));
  }
#line 598
  if (float_norm_exp) {
#line 598
    tmp = 1;
  } else {
#line 598
    tmp = 0;
  }
#line 598
  caf_audio_format.mFormatFlags = (uint32_t )tmp;
#line 600
  if (! (qmode & 1)) {
#line 601
    caf_audio_format.mFormatFlags |= (unsigned int )2;
  }
  {
#line 603
  caf_audio_format.mBytesPerPacket = (uint32_t )(bytes_per_sample * num_channels);
#line 604
  caf_audio_format.mFramesPerPacket = (uint32_t )1;
#line 605
  caf_audio_format.mChannelsPerFrame = (uint32_t )num_channels;
#line 606
  caf_audio_format.mBitsPerChannel = (uint32_t )bits_per_sample;
#line 607
  WavpackNativeToBigEndian(& caf_audio_format, "D4LLLLL");
#line 609
  __cil_tmp35 = DoWriteFile(outfile, & caf_audio_format, (uint32_t )sizeof(caf_audio_format),
                            & bcount);
  }
#line 609
  if (! __cil_tmp35) {
#line 611
    return (0);
  } else
#line 609
  if ((unsigned long )bcount != sizeof(caf_audio_format)) {
#line 611
    return (0);
  }
#line 618
  if (num_channels > 2) {
#line 618
    tmp___0 = num_identified_chans;
  } else {
#line 618
    tmp___0 = channel_mask != 5 - num_channels;
  }
#line 618
  if (channel_layout_tag) {
    _L___40: /* CIL Label */ 
#line 619
    bits = 0;
#line 621
    bmask = 1;
    {
#line 621
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 621
      if (! bmask) {
#line 621
        goto while_break___0;
      }
#line 622
      if (bmask & channel_mask) {
#line 623
        bits ++;
      }
#line 621
      bmask <<= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 629
    if (channel_layout_tag & 16711680U) {
      _L___38: /* CIL Label */ 
      {
#line 631
      strncpy((char *)caf_chan_chunk_header.mChunkType, "chandU", sizeof(caf_chan_chunk_header.mChunkType));
#line 632
      caf_chan_chunk_header.mChunkSize = (int64_t )sizeof(caf_channel_layout);
#line 633
      WavpackNativeToBigEndian(& caf_chan_chunk_header, "4D\305>dU");
#line 635
      __cil_tmp39 = DoWriteFile(outfile, & caf_chan_chunk_header, (uint32_t )sizeof(caf_chan_chunk_header),
                                & bcount);
      }
#line 635
      if (! __cil_tmp39) {
#line 637
        return (0);
      } else
#line 635
      if ((unsigned long )bcount != sizeof(caf_chan_chunk_header)) {
#line 637
        return (0);
      }
#line 639
      if (channel_layout_tag) {
#line 640
        if (debug_logging_mode) {
          {
#line 641
          error_line("writing \"chan\" chunk with layout tag 0x%08x>dU", channel_layout_tag);
          }
        }
#line 643
        caf_channel_layout.mChannelLayoutTag = channel_layout_tag;
#line 644
        caf_channel_layout.mChannelBitmap = (uint32_t )0;
      } else {
#line 647
        if (debug_logging_mode) {
          {
#line 648
          error_line("writing \"chan\" chunk with UseChannelBitmap tag, bitmap = 0x%08x",
                     channel_mask);
          }
        }
#line 650
        caf_channel_layout.mChannelLayoutTag = (uint32_t )65536;
#line 651
        caf_channel_layout.mChannelBitmap = (uint32_t )channel_mask;
      }
      {
#line 654
      caf_channel_layout.mNumberChannelDescriptions = (uint32_t )0;
#line 655
      WavpackNativeToBigEndian(& caf_channel_layout, "LLL>dU");
#line 657
      __cil_tmp40 = DoWriteFile(outfile, & caf_channel_layout, (uint32_t )sizeof(caf_channel_layout),
                                & bcount);
      }
#line 657
      if (! __cil_tmp40) {
#line 659
        return (0);
      } else
#line 657
      if ((unsigned long )bcount != sizeof(caf_channel_layout)) {
#line 659
        return (0);
      }
    } else
#line 629
    if (bits == num_channels) {
#line 629
      if (! (qmode & 8)) {
#line 629
        goto _L___38;
      } else {
#line 629
        goto _L___39;
      }
    } else {
      _L___39: /* CIL Label */ 
#line 663
      new_channel_order = (unsigned char *)((void *)0);
#line 666
      if (debug_logging_mode) {
#line 667
        if (qmode & 8) {
#line 667
          tmp___1 = "yes>dU";
        } else {
#line 667
          tmp___1 = "no\304>dU";
        }
        {
#line 667
        error_line("writing \"chan\" chunk with UseChannelDescriptions tag, bitmap = 0x%08x, reordered = %sU",
                   channel_mask, tmp___1);
        }
      }
#line 670
      if (qmode & 8) {
#line 671
        if ((int )(channel_layout_tag & 255U) <= num_channels) {
          {
#line 672
          new_channel_order = (unsigned char *)malloc((unsigned long )num_channels);
#line 674
          i___35 = 0;
          }
          {
#line 674
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 674
            if (! (i___35 < num_channels)) {
#line 674
              goto while_break___1;
            }
#line 675
            *(new_channel_order + i___35) = (unsigned char )i___35;
#line 674
            i___35 ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 677
          WavpackGetChannelLayout(wpc, new_channel_order);
          }
        }
      }
      {
#line 681
      strncpy((char *)caf_chan_chunk_header.mChunkType, "chandU", sizeof(caf_chan_chunk_header.mChunkType));
#line 682
      caf_chan_chunk_header.mChunkSize = (int64_t )(sizeof(caf_channel_layout) + sizeof(caf_channel_description) * (unsigned long )num_channels);
#line 683
      WavpackNativeToBigEndian(& caf_chan_chunk_header, "4D\305>dU");
#line 685
      __cil_tmp46 = DoWriteFile(outfile, & caf_chan_chunk_header, (uint32_t )sizeof(caf_chan_chunk_header),
                                & bcount);
      }
#line 685
      if (! __cil_tmp46) {
#line 687
        return (0);
      } else
#line 685
      if ((unsigned long )bcount != sizeof(caf_chan_chunk_header)) {
#line 687
        return (0);
      }
      {
#line 689
      caf_channel_layout.mChannelLayoutTag = (uint32_t )0;
#line 690
      caf_channel_layout.mChannelBitmap = (uint32_t )0;
#line 691
      caf_channel_layout.mNumberChannelDescriptions = (uint32_t )num_channels;
#line 692
      WavpackNativeToBigEndian(& caf_channel_layout, "LLL");
#line 694
      __cil_tmp47 = DoWriteFile(outfile, & caf_channel_layout, (uint32_t )sizeof(caf_channel_layout),
                                & bcount);
      }
#line 694
      if (! __cil_tmp47) {
#line 696
        return (0);
      } else
#line 694
      if ((unsigned long )bcount != sizeof(caf_channel_layout)) {
#line 696
        return (0);
      }
#line 698
      i___35 = 0;
      {
#line 698
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 698
        if (! (i___35 < num_channels)) {
#line 698
          goto while_break___2;
        }
#line 699
        if (new_channel_order) {
#line 699
          tmp___2 = (int )*(channel_identities + *(new_channel_order + i___35));
        } else {
#line 699
          tmp___2 = (int )*(channel_identities + i___35);
        }
        {
#line 699
        chan_id = (unsigned char )tmp___2;
#line 700
        memset(& caf_channel_description, 0, sizeof(caf_channel_description));
        }
#line 702
        if ((int )chan_id >= 1) {
#line 702
          if ((int )chan_id <= 18) {
#line 703
            caf_channel_description.mChannelLabel = (uint32_t )chan_id;
          } else {
#line 702
            goto _L___37;
          }
        } else
        _L___37: /* CIL Label */ 
#line 702
        if ((int )chan_id >= 33) {
#line 702
          if ((int )chan_id <= 44) {
#line 703
            caf_channel_description.mChannelLabel = (uint32_t )chan_id;
          } else {
#line 702
            goto _L___36;
          }
        } else
        _L___36: /* CIL Label */ 
#line 702
        if ((int )chan_id >= 200) {
#line 702
          if ((int )chan_id <= 207) {
#line 703
            caf_channel_description.mChannelLabel = (uint32_t )chan_id;
          } else {
#line 702
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 704
        if ((int )chan_id >= 221) {
#line 704
          if ((int )chan_id <= 225) {
#line 705
            caf_channel_description.mChannelLabel = (uint32_t )((int )chan_id + 80);
          }
        }
#line 707
        if (debug_logging_mode) {
          {
#line 708
          error_line("chan %d --> %d", i___35 + 1, caf_channel_description.mChannelLabel);
          }
        }
        {
#line 710
        WavpackNativeToBigEndian(& caf_channel_description, "LLLLLU");
#line 712
        __cil_tmp50 = DoWriteFile(outfile, & caf_channel_description, (uint32_t )sizeof(caf_channel_description),
                                  & bcount);
        }
#line 712
        if (! __cil_tmp50) {
#line 714
          return (0);
        } else
#line 712
        if ((unsigned long )bcount != sizeof(caf_channel_description)) {
#line 714
          return (0);
        }
#line 698
        i___35 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 717
      if (new_channel_order) {
        {
#line 718
        free(new_channel_order);
        }
      }
    }
  } else
#line 618
  if (tmp___0) {
#line 618
    goto _L___40;
  }
  {
#line 724
  strncpy((char *)caf_data_chunk_header.mChunkType, "datadU", sizeof(caf_data_chunk_header.mChunkType));
  }
#line 726
  if (total_samples == -1L) {
#line 727
    caf_data_chunk_header.mChunkSize = (int64_t )(- 1);
  } else {
#line 729
    caf_data_chunk_header.mChunkSize = (int64_t )((unsigned long )((total_samples * (long )bytes_per_sample) * (long )num_channels) + sizeof(mEditCount));
  }
  {
#line 731
  WavpackNativeToBigEndian(& caf_data_chunk_header, "4D");
#line 733
  __cil_tmp51 = DoWriteFile(outfile, & caf_data_chunk_header, (uint32_t )sizeof(caf_data_chunk_header),
                            & bcount);
  }
#line 733
  if (! __cil_tmp51) {
#line 735
    return (0);
  } else
#line 733
  if ((unsigned long )bcount != sizeof(caf_data_chunk_header)) {
#line 735
    return (0);
  }
  {
#line 737
  mEditCount = (uint32_t )0;
#line 738
  WavpackNativeToBigEndian(& mEditCount, "L\025\306>dU");
#line 740
  __cil_tmp52 = DoWriteFile(outfile, & mEditCount, (uint32_t )sizeof(mEditCount),
                            & bcount);
  }
#line 740
  if (! __cil_tmp52) {
#line 742
    return (0);
  } else
#line 740
  if ((unsigned long )bcount != sizeof(mEditCount)) {
#line 742
    return (0);
  }
  {
#line 744
  free(channel_identities);
  }
#line 746
  return (1);
}
}
#line 65 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static char const   *sign_on___0  =    "\n WVTAG  WavPack Metadata Tagging Utility  %s Version %s\n Copyright (c) 2017 David Bryant.  All Rights Reserved.\n\n";
#line 69 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static char const   *version_warning___0  =    "\n WARNING: WVTAG using libwavpack version %s, expected %s (see README)\n\n";
#line 72 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static char const   *help  =    " Usage:\n    WVTAG [-options] file[.wv] [...]\n\n    Multiple input files may be specified. All options and operations\n    specified are applied to each file in this order: clean, import,\n    delete, write, extract, list.\n\n Options:\n    --allow-huge-tags     allow tag data up to 16 MB (embedding > 1 MB is not\n                           recommended for portable devices and may not work\n                           with some programs including WavPack pre-4.70)\n    -c                    extract cuesheet only to stdout\n                           (note: equivalent to -x \"cuesheet\")\n    -cc                   extract cuesheet file (.cue)\n                           (note: equivalent to -xx \"cuesheet=%a.cue\")\n    --clean or --clear    clean all items from tag (done first)\n    -d \"Field\"            delete specified metadata item (text or binary)\n    -h or --help          this help display\n    --import-id3          import ID3v2 tags from the trailer of DSF files only\n                           (add --allow-huge-tags option for > 1 MB images)\n    -l or --list          list all tag items (done last)\n    --no-utf8-convert     don\'t recode passed tags from local encoding to\n                           UTF-8, assume they are in UTF-8 already\n    -q                    quiet (keep console output to a minimum)\n    -v or --version       write the version to stdout\n    -w \"Field=\"           delete specified metadata item (text or binary)\n    -w \"Field=Value\"      write specified text metadata to APEv2 tag\n    -w \"Field=@file.ext\"  write specified text metadata from file to APEv2\n                           tag, normally used for embedded cuesheets and logs\n                           (field names \"Cuesheet\" and \"Log\")\n    --write-binary-tag \"Field=@file.ext\"\n                          write the specified binary metadata file to APEv2\n                           tag, normally used for cover art with the specified\n                           field name \"Cover Art (Front)\"\n    -x \"Field\"            extract specified tag field only to stdout\n    -xx \"Field[=file]\"    extract specified tag field to file, optional\n                           filename spec can include these replacement codes:\n                             %a = source filename\n                             %t = tag field name\n                                 (note: comes from data for binary tags)\n                             %e = extension from binary tag source file\n                                 (or \'txt\' for text tag)\n    -y                    yes to overwrite warning (use with caution!)\n\n Web:\n     Visit www.wavpack.com for latest version and complete information\n";
#line 138
static int overwrite_all___0 ;
#line 138
static int clean_tags ;
#line 138
static int list_tags ;
#line 138
static int import_id3 ;
#line 138
static int quiet_mode___0 ;
#line 138
static int no_utf8_convert___0 ;
#line 138
static int allow_huge_tags ;
#line 145
static int num_tag_items ;
#line 150
static struct tag_item *tag_items ;
#line 152
static char *tag_extract_stdout___0 ;
#line 153
static char **tag_extractions___0 ;
#line 154
static int num_tag_extractions___0 ;
#line 160
int ImportID3v2(WavpackContext *wpc , unsigned char *tag_data , int tag_size , char *error ,
                int32_t *bytes_used ) ;
#line 164
static void add_tag_extraction_to_list___0(char *spec ) ;
#line 165
static void TextToUTF8(void *string , int len ) ;
#line 166
static FILE *wild_fopen(char *filename , char const   *mode ) ;
#line 167
static int process_file(char *infilename ) ;
#line 735
static int dump_tag_item_to_file___0(WavpackContext *wpc , char const   *tag_item ,
                                     FILE *dst , char *fname ) ;
#line 736
static void list_tags_to_file(WavpackContext *wpc , char *name , FILE *dst ) ;
#line 737
static int do_tag_extractions___0(WavpackContext *wpc , char *outfilename ) ;
#line 738
static int calculate_tag_size(WavpackContext *wpc ) ;
#line 739
static void clear_tag_items(WavpackContext *wpc ) ;
#line 741 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static int process_file(char *infilename ) 
{ 
  int open_flags ;
  int write_tag ;
  int huge_tag ;
  WavpackContext *wpc ;
  char error[80] ;
  WavpackContext *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int i ;
  int res ;
  int __cil_tmp13 ;
  char title[40] ;
  char artist[40] ;
  char album[40] ;
  char year[10] ;
  char comment[40] ;
  char track[10] ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  char error___46[80] ;
  uint32_t __cil_tmp27 ;
  int res___47 ;
  unsigned char *__cil_tmp29 ;
  uint32_t __cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned char *__cil_tmp32 ;
  uint32_t __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  char *__cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  char *__cil_tmp41 ;
  int __cil_tmp42 ;
  int result ;
  int __cil_tmp44 ;

  {
#line 743
  open_flags = 258;
#line 743
  write_tag = 0;
#line 743
  huge_tag = 0;
#line 747
  if (clean_tags) {
#line 748
    open_flags |= 64;
  } else
#line 747
  if (num_tag_items) {
#line 748
    open_flags |= 64;
  } else
#line 747
  if (import_id3) {
#line 748
    open_flags |= 64;
  }
#line 754
  if (import_id3) {
#line 755
    open_flags |= 1028;
  }
  {
#line 759
  wpc = WavpackOpenFileInput((char const   *)infilename, (char *)error, open_flags,
                             0);
  }
#line 761
  if (! wpc) {
    {
#line 762
    error_line((char *)error);
    }
#line 763
    return (1);
  }
  {
#line 766
  __cil_tmp8 = calculate_tag_size(wpc);
#line 766
  huge_tag = __cil_tmp8 > 1048576;
#line 770
  __cil_tmp10 = WavpackGetNumBinaryTagItems(wpc);
  }
  {
#line 770
  __cil_tmp9 = WavpackGetNumTagItems(wpc);
  }
#line 770
  if (clean_tags) {
#line 770
    if (__cil_tmp9) {
      {
      {
#line 771
      clear_tag_items(wpc);
      }
#line 772
      write_tag = 1;
      }
    } else
#line 770
    if (__cil_tmp10) {
      {
      {
#line 771
      clear_tag_items(wpc);
      }
#line 772
      write_tag = 1;
      }
    }
  }
#line 777
  if (num_tag_items) {
    _L: /* CIL Label */ 
    {
#line 778
    res = 1;
#line 782
    __cil_tmp13 = WavpackGetMode(wpc);
    }
#line 782
    if (! clean_tags) {
#line 782
      if ((__cil_tmp13 & 272) == 16) {
        {
#line 785
        WavpackGetTagItem(wpc, "titleU", (char *)title, (int )sizeof(title));
#line 786
        WavpackGetTagItem(wpc, "artist", (char *)artist, (int )sizeof(artist));
#line 787
        WavpackGetTagItem(wpc, "albumU", (char *)album, (int )sizeof(album));
#line 788
        WavpackGetTagItem(wpc, "yeardU", (char *)year, (int )sizeof(year));
#line 789
        WavpackGetTagItem(wpc, "comment", (char *)comment, (int )sizeof(comment));
#line 790
        WavpackGetTagItem(wpc, "track", (char *)track, (int )sizeof(track));
        }
#line 792
        if (title[0]) {
          {
#line 793
          __cil_tmp20 = strlen((char const   *)((char *)title));
#line 793
          WavpackAppendTagItem(wpc, "Title", (char const   *)((char *)title), (int )__cil_tmp20);
          }
        }
#line 795
        if (artist[0]) {
          {
#line 796
          __cil_tmp21 = strlen((char const   *)((char *)artist));
#line 796
          WavpackAppendTagItem(wpc, "Artist", (char const   *)((char *)artist), (int )__cil_tmp21);
          }
        }
#line 798
        if (album[0]) {
          {
#line 799
          __cil_tmp22 = strlen((char const   *)((char *)album));
#line 799
          WavpackAppendTagItem(wpc, "Album", (char const   *)((char *)album), (int )__cil_tmp22);
          }
        }
#line 801
        if (year[0]) {
          {
#line 802
          __cil_tmp23 = strlen((char const   *)((char *)year));
#line 802
          WavpackAppendTagItem(wpc, "Year", (char const   *)((char *)year), (int )__cil_tmp23);
          }
        }
#line 804
        if (comment[0]) {
          {
#line 805
          __cil_tmp24 = strlen((char const   *)((char *)comment));
#line 805
          WavpackAppendTagItem(wpc, "Comment", (char const   *)((char *)comment),
                               (int )__cil_tmp24);
          }
        }
#line 807
        if (track[0]) {
          {
#line 808
          __cil_tmp25 = strlen((char const   *)((char *)track));
#line 808
          WavpackAppendTagItem(wpc, "Track", (char const   *)((char *)track), (int )__cil_tmp25);
          }
        }
        {
#line 810
        error_line("warning: ID3v1 tag converted to APEv2U");
#line 811
        write_tag = 1;
        }
      }
    }
#line 816
    if (import_id3) {
      {
#line 819
      WavpackFreeWrapper(wpc);
#line 820
      WavpackSeekTrailingWrapper(wpc);
#line 822
      __cil_tmp27 = WavpackGetWrapperBytes(wpc);
      }
#line 822
      if (__cil_tmp27 > 10U) {
        {
#line 826
        __cil_tmp29 = WavpackGetWrapperData(wpc);
        }
        {
#line 826
        __cil_tmp30 = WavpackGetWrapperBytes(wpc);
#line 826
        __cil_tmp31 = ImportID3v2((void *)0, __cil_tmp29, (int )__cil_tmp30, (char *)error___46,
                                  (int32_t *)((void *)0));
#line 826
        res___47 = __cil_tmp31;
        }
#line 828
        if (res___47 > 0) {
          {
#line 829
          __cil_tmp32 = WavpackGetWrapperData(wpc);
          }
          {
#line 829
          __cil_tmp33 = WavpackGetWrapperBytes(wpc);
#line 829
          __cil_tmp34 = ImportID3v2(wpc, __cil_tmp32, (int )__cil_tmp33, (char *)error___46,
                                    (int32_t *)((void *)0));
#line 829
          res___47 = __cil_tmp34;
          }
        }
#line 831
        if (res___47 > 0) {
#line 832
          if (! quiet_mode___0) {
            {
#line 833
            error_line("successfully imported %d items from ID3v2 tagU", res___47);
            }
          }
#line 835
          write_tag = 1;
        } else
#line 837
        if (res___47 == 0) {
          {
#line 838
          error_line("ID3v2 import: no applicable items found");
          }
        } else {
          {
#line 840
          error_line("ID3v2 import: %s\230\001", (char *)error___46);
          }
        }
      }
    }
#line 846
    i = 0;
    {
#line 846
    while (1) {
      while_continue: /* CIL Label */ ;
#line 846
      if (! (i < num_tag_items)) {
#line 846
        goto while_break;
      }
#line 847
      if (! (tag_items + i)->vsize) {
        {
#line 848
        __cil_tmp35 = WavpackDeleteTagItem(wpc, (char const   *)(tag_items + i)->item);
        }
#line 848
        if (! __cil_tmp35) {
          {
#line 849
          error_line("warning: field \"%s\" not found, can\'t delete", (tag_items + i)->item);
          }
        } else {
#line 851
          write_tag = 1;
        }
      }
#line 846
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 856
    i = 0;
    {
#line 856
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 856
      if (! (i < num_tag_items)) {
#line 856
        goto while_break___0;
      }
#line 857
      if ((tag_items + i)->vsize) {
#line 858
        if ((tag_items + i)->binary) {
          {
#line 859
          res = WavpackAppendBinaryTagItem(wpc, (char const   *)(tag_items + i)->item,
                                           (char const   *)(tag_items + i)->value,
                                           (tag_items + i)->vsize);
          }
        } else {
          {
#line 861
          res = WavpackAppendTagItem(wpc, (char const   *)(tag_items + i)->item, (char const   *)(tag_items + i)->value,
                                     (tag_items + i)->vsize);
          }
        }
#line 863
        if (! res) {
          {
#line 864
          __cil_tmp38 = WavpackGetErrorMessage(wpc);
#line 864
          error_line("%s", __cil_tmp38);
#line 865
          WavpackCloseFile(wpc);
          }
#line 866
          return (2);
        }
#line 869
        write_tag = 1;
      }
#line 856
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 874
    __cil_tmp39 = calculate_tag_size(wpc);
    }
#line 874
    if (write_tag) {
#line 874
      if (! huge_tag) {
#line 874
        if (! allow_huge_tags) {
#line 874
          if (__cil_tmp39 > 1048576) {
            {
#line 875
            error_line("APEv2 tag exceeds 1 MB, use --allow-huge-tags to override\333\346>dU");
#line 876
            WavpackCloseFile(wpc);
            }
#line 877
            return (1);
          }
        }
      }
    }
  } else
#line 777
  if (import_id3) {
#line 777
    goto _L;
  }
  {
#line 883
  __cil_tmp40 = WavpackWriteTag(wpc);
  }
#line 883
  if (write_tag) {
#line 883
    if (! __cil_tmp40) {
      {
#line 884
      __cil_tmp41 = WavpackGetErrorMessage(wpc);
#line 884
      error_line("%s", __cil_tmp41);
#line 885
      WavpackCloseFile(wpc);
      }
#line 886
      return (2);
    }
  }
#line 891
  if (tag_extract_stdout___0) {
    {
#line 892
    __cil_tmp42 = dump_tag_item_to_file___0(wpc, (char const   *)tag_extract_stdout___0,
                                            stdout, (char *)((void *)0));
    }
#line 892
    if (! __cil_tmp42) {
      {
#line 893
      error_line("tag \"%s\" not found!>dU", tag_extract_stdout___0);
#line 894
      WavpackCloseFile(wpc);
      }
#line 895
      return (1);
    }
  } else
#line 898
  if (num_tag_extractions___0) {
    {
#line 899
    __cil_tmp44 = do_tag_extractions___0(wpc, infilename);
#line 899
    result = __cil_tmp44;
    }
#line 901
    if (result != 0) {
      {
#line 902
      WavpackCloseFile(wpc);
      }
#line 903
      return (result);
    }
  }
#line 907
  if (list_tags) {
    {
#line 908
    list_tags_to_file(wpc, infilename, stdout);
    }
  }
  {
#line 910
  WavpackCloseFile(wpc);
  }
#line 911
  return (0);
}
}
#line 914 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static void add_tag_extraction_to_list___0(char *spec ) 
{ 
  void *__cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 916
  tag_extractions___0 = (char **)realloc(tag_extractions___0, (unsigned long )(num_tag_extractions___0 + 1) * sizeof(*tag_extractions___0));
#line 917
  __cil_tmp3 = strlen((char const   *)spec);
#line 917
  __cil_tmp4 = malloc(__cil_tmp3 + 10UL);
#line 917
  *(tag_extractions___0 + num_tag_extractions___0) = __cil_tmp4;
#line 918
  strcpy(*(tag_extractions___0 + num_tag_extractions___0), (char const   *)spec);
#line 919
  num_tag_extractions___0 ++;
  }
  return;
}
}
#line 922 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static int do_tag_extractions___0(WavpackContext *wpc , char *outfilename ) 
{ 
  int result ;
  int i ;
  FILE *outfile ;
  char *extraction_spec ;
  char *__cil_tmp7 ;
  char *output_spec ;
  char *__cil_tmp9 ;
  char tag_filename[256] ;
  unsigned long __cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;
  int max_length ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  char *full_filename ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  char *dst ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  FILE *__cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  char *__cil_tmp41 ;
  char *tmp ;
  char __cil_tmp43 ;
  FILE *__cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  char *__cil_tmp46 ;
  char *tmp___0 ;
  int __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  char *__cil_tmp50 ;
  char *tmp___1 ;
  unsigned long __cil_tmp52 ;
  char *__cil_tmp53 ;
  char *tmp___2 ;

  {
#line 924
  result = 0;
#line 927
  i = 0;
  {
#line 927
  while (1) {
    while_continue: /* CIL Label */ ;
#line 927
    if (! (result == 0 && i < num_tag_extractions___0)) {
#line 927
      goto while_break;
    }
    {
#line 928
    __cil_tmp7 = strdup((char const   *)*(tag_extractions___0 + i));
#line 928
    extraction_spec = __cil_tmp7;
#line 929
    __cil_tmp9 = strchr((char const   *)extraction_spec, '=');
#line 929
    output_spec = __cil_tmp9;
#line 932
    __cil_tmp11 = strlen((char const   *)output_spec);
    }
#line 932
    if (output_spec) {
#line 932
      if (output_spec > extraction_spec) {
#line 932
        if (__cil_tmp11 > 1UL) {
#line 933
          __cil_tmp12 = output_spec;
#line 933
          output_spec ++;
#line 933
          *__cil_tmp12 = (char )0;
        }
      }
    }
    {
#line 935
    __cil_tmp13 = dump_tag_item_to_file___0(wpc, (char const   *)extraction_spec,
                                            (FILE *)((void *)0), (char *)tag_filename);
    }
#line 935
    if (__cil_tmp13) {
      {
#line 936
      __cil_tmp16 = strlen((char const   *)((char *)tag_filename));
      }
      {
#line 936
      __cil_tmp15 = strlen((char const   *)outfilename);
#line 936
      max_length = ((int )__cil_tmp15 + (int )__cil_tmp16) + 10;
      }
#line 939
      if (output_spec) {
        {
#line 940
        __cil_tmp18 = strlen((char const   *)output_spec);
        }
#line 940
        max_length += (int )__cil_tmp18 + 256;
      }
      {
#line 942
      full_filename = (char *)malloc((unsigned long )(max_length * 2 + 1));
#line 943
      strcpy(full_filename, (char const   *)outfilename);
      }
#line 945
      if (output_spec) {
        {
#line 946
        __cil_tmp21 = filespec_name(full_filename);
#line 946
        dst = __cil_tmp21;
        }
        {
#line 948
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 948
          if (! (dst - full_filename < (long )max_length && (int )*output_spec)) {
#line 948
            goto while_break___0;
          }
#line 949
          if ((int )*output_spec == 37) {
#line 950
            output_spec ++;
            {
#line 951
            if ((int )*output_spec == 'a') {
#line 951
              goto case_97;
            }
#line 962
            if ((int )*output_spec == 't') {
#line 962
              goto case_116;
            }
#line 973
            if ((int )*output_spec == 'e') {
#line 973
              goto case_101;
            }
#line 982
            goto switch_default;
            case_97: /* CIL Label */ 
            {
#line 952
            __cil_tmp22 = filespec_name(outfilename);
#line 952
            strcpy(dst, (char const   *)__cil_tmp22);
            }
            {
#line 954
            __cil_tmp23 = filespec_ext(dst);
            }
#line 954
            if (__cil_tmp23) {
              {
#line 955
              dst = filespec_ext(dst);
              }
            } else {
              {
#line 957
              __cil_tmp25 = strlen((char const   *)dst);
              }
#line 957
              dst += __cil_tmp25;
            }
#line 959
            output_spec ++;
#line 960
            goto switch_break;
            case_116: /* CIL Label */ 
            {
#line 963
            strcpy(dst, (char const   *)((char *)tag_filename));
            }
            {
#line 965
            __cil_tmp27 = filespec_ext(dst);
            }
#line 965
            if (__cil_tmp27) {
              {
#line 966
              dst = filespec_ext(dst);
              }
            } else {
              {
#line 968
              __cil_tmp29 = strlen((char const   *)dst);
              }
#line 968
              dst += __cil_tmp29;
            }
#line 970
            output_spec ++;
#line 971
            goto switch_break;
            case_101: /* CIL Label */ 
            {
#line 974
            __cil_tmp31 = filespec_ext((char *)tag_filename);
            }
#line 974
            if (__cil_tmp31) {
              {
#line 975
              __cil_tmp32 = filespec_ext((char *)tag_filename);
#line 975
              strcpy(dst, (char const   *)(__cil_tmp32 + 1));
#line 976
              __cil_tmp33 = strlen((char const   *)dst);
              }
#line 976
              dst += __cil_tmp33;
            }
#line 979
            output_spec ++;
#line 980
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 983
            __cil_tmp35 = dst;
#line 983
            dst ++;
#line 983
            *__cil_tmp35 = (char )'%';
            switch_break: /* CIL Label */ ;
            }
          } else {
#line 987
            __cil_tmp37 = output_spec;
#line 987
            output_spec ++;
#line 987
            __cil_tmp36 = dst;
#line 987
            dst ++;
#line 987
            *__cil_tmp36 = *__cil_tmp37;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 990
        *dst = (char )0;
      } else {
        {
#line 993
        __cil_tmp38 = filespec_name(full_filename);
#line 993
        strcpy(__cil_tmp38, (char const   *)((char *)tag_filename));
        }
      }
      {
#line 995
      outfile = fopen((char const   *)full_filename, "r\034\257>dU");
      }
#line 995
      if (outfile != (void *)0) {
#line 995
        if (! overwrite_all___0) {
          {
#line 996
          DoCloseHandle(outfile);
#line 997
          __cil_tmp40 = strlen((char const   *)full_filename);
          }
#line 997
          if (__cil_tmp40 > 30UL) {
            {
#line 997
            __cil_tmp41 = filespec_name(full_filename);
#line 997
            tmp = __cil_tmp41;
            }
          } else {
#line 997
            tmp = full_filename;
          }
          {
#line 997
          fprintf(stderr, "overwrite %s (yes/no/all)? ", tmp);
#line 998
          fflush(stderr);
#line 1000
          __cil_tmp43 = yna();
          }
          {
#line 1002
          if ((int )__cil_tmp43 == 'n') {
#line 1002
            goto case_110;
          }
#line 1006
          if ((int )__cil_tmp43 == 'a') {
#line 1006
            goto case_97___0;
          }
#line 1000
          goto switch_break___0;
          case_110: /* CIL Label */ 
#line 1003
          *full_filename = (char )0;
#line 1004
          goto switch_break___0;
          case_97___0: /* CIL Label */ 
#line 1007
          overwrite_all___0 = 1;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
#line 1013
      if (*full_filename) {
        {
#line 1014
        outfile = fopen((char const   *)full_filename, "w");
        }
#line 1014
        if (outfile == (void *)0) {
          {
#line 1015
          __cil_tmp45 = strlen((char const   *)full_filename);
          }
#line 1015
          if (__cil_tmp45 > 30UL) {
            {
#line 1015
            __cil_tmp46 = filespec_name(full_filename);
#line 1015
            tmp___0 = __cil_tmp46;
            }
          } else {
#line 1015
            tmp___0 = full_filename;
          }
          {
#line 1015
          error_line("can\'t create file %s!U", tmp___0);
#line 1016
          result = 1;
          }
        } else {
          {
#line 1019
          dump_tag_item_to_file___0(wpc, (char const   *)extraction_spec, outfile,
                                    (char *)((void *)0));
#line 1021
          __cil_tmp48 = DoCloseHandle(outfile);
          }
#line 1021
          if (! __cil_tmp48) {
            {
#line 1022
            __cil_tmp49 = strlen((char const   *)full_filename);
            }
#line 1022
            if (__cil_tmp49 > 30UL) {
              {
#line 1022
              __cil_tmp50 = filespec_name(full_filename);
#line 1022
              tmp___1 = __cil_tmp50;
              }
            } else {
#line 1022
              tmp___1 = full_filename;
            }
            {
#line 1022
            error_line("can\'t close file %s!dU", tmp___1);
#line 1023
            result = 1;
            }
          } else
#line 1025
          if (! quiet_mode___0) {
            {
#line 1026
            __cil_tmp52 = strlen((char const   *)full_filename);
            }
#line 1026
            if (__cil_tmp52 > 30UL) {
              {
#line 1026
              __cil_tmp53 = filespec_name(full_filename);
#line 1026
              tmp___2 = __cil_tmp53;
              }
            } else {
#line 1026
              tmp___2 = full_filename;
            }
            {
#line 1026
            error_line("extracted tag \"%s\" to file %sU", extraction_spec, tmp___2);
            }
          }
        }
      }
      {
#line 1030
      free(full_filename);
      }
    }
    {
#line 1033
    free(extraction_spec);
    }
#line 927
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1036
  return (result);
}
}
#line 1039 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static void clear_tag_items(WavpackContext *wpc ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int item_len ;
  char *item ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 1041
  __cil_tmp3 = WavpackGetMode(wpc);
  }
  {
#line 1041
  __cil_tmp2 = WavpackGetMode(wpc);
  }
#line 1041
  if (__cil_tmp2 & 16) {
#line 1041
    if (__cil_tmp3 & 256) {
      {
#line 1045
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1045
        __cil_tmp6 = WavpackGetNumTagItems(wpc);
        }
#line 1045
        if (! __cil_tmp6) {
#line 1045
          goto while_break;
        }
        {
#line 1046
        item_len = WavpackGetTagItemIndexed(wpc, 0, (char *)((void *)0), 0);
#line 1047
        item = (char *)malloc((unsigned long )(item_len + 1));
#line 1048
        WavpackGetTagItemIndexed(wpc, 0, item, item_len + 1);
        }
        {
#line 1049
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1049
          __cil_tmp9 = WavpackDeleteTagItem(wpc, (char const   *)item);
          }
#line 1049
          if (! __cil_tmp9) {
#line 1049
            goto while_break___0;
          }

        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1050
        free(item);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1053
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1053
        __cil_tmp10 = WavpackGetNumBinaryTagItems(wpc);
        }
#line 1053
        if (! __cil_tmp10) {
#line 1053
          goto while_break___1;
        }
        {
#line 1054
        item_len = WavpackGetBinaryTagItemIndexed(wpc, 0, (char *)((void *)0), 0);
#line 1055
        item = (char *)malloc((unsigned long )(item_len + 1));
#line 1056
        WavpackGetBinaryTagItemIndexed(wpc, 0, item, item_len + 1);
        }
        {
#line 1057
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1057
          __cil_tmp13 = WavpackDeleteTagItem(wpc, (char const   *)item);
          }
#line 1057
          if (! __cil_tmp13) {
#line 1057
            goto while_break___2;
          }

        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1058
        free(item);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 1063
static void dump_UTF8_string___0(char *string , FILE *dst ) ;
#line 1064
static void UTF8ToAnsi___0(char *string , int len ) ;
#line 1066 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static void list_tags_to_file(WavpackContext *wpc , char *name , FILE *dst ) 
{ 
  int __cil_tmp4 ;
  int ape_tag ;
  int __cil_tmp6 ;
  int num_binary_items ;
  int __cil_tmp8 ;
  int num_items ;
  int __cil_tmp10 ;
  int i ;
  char *spaces ;
  char const   *tmp ;
  int __cil_tmp14 ;
  int item_len ;
  int value_len ;
  int j ;
  char *item ;
  char *value ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  int __cil_tmp22 ;
  void *__cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  char *tmp___0 ;
  char *__cil_tmp28 ;
  int item_len___0 ;
  int value_len___0 ;
  char *item___0 ;
  char fname[256] ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  char *tmp___1 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
#line 1068
  __cil_tmp4 = WavpackGetMode(wpc);
  }
#line 1068
  if (__cil_tmp4 & 16) {
    {
#line 1069
    __cil_tmp6 = WavpackGetMode(wpc);
#line 1069
    ape_tag = __cil_tmp6 & 256;
#line 1070
    __cil_tmp8 = WavpackGetNumBinaryTagItems(wpc);
#line 1070
    num_binary_items = __cil_tmp8;
#line 1071
    __cil_tmp10 = WavpackGetNumTagItems(wpc);
#line 1071
    num_items = __cil_tmp10;
#line 1072
    spaces = "                  \347>dU";
    }
#line 1074
    if (num_items + num_binary_items) {
#line 1075
      if (ape_tag) {
#line 1075
        tmp = "APEv2";
      } else {
#line 1075
        tmp = "ID3v1";
      }
      {
#line 1075
      __cil_tmp14 = calculate_tag_size(wpc);
#line 1075
      fprintf(dst, "\n%s tag items:   %d (%d bytes used)\n", tmp, num_items + num_binary_items,
              __cil_tmp14);
      }
    }
#line 1078
    i = 0;
    {
#line 1078
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1078
      if (! (i < num_items)) {
#line 1078
        goto while_break;
      }
      {
#line 1082
      item_len = WavpackGetTagItemIndexed(wpc, i, (char *)((void *)0), 0);
#line 1083
      item = (char *)malloc((unsigned long )(item_len + 1));
#line 1084
      WavpackGetTagItemIndexed(wpc, i, item, item_len + 1);
#line 1085
      value_len = WavpackGetTagItem(wpc, (char const   *)item, (char *)((void *)0),
                                    0);
#line 1086
      value = (char *)malloc((unsigned long )(value_len * 2 + 1));
#line 1087
      WavpackGetTagItem(wpc, (char const   *)item, value, value_len + 1);
#line 1089
      __cil_tmp25 = strlen((char const   *)spaces);
      }
      {
#line 1089
      __cil_tmp24 = strlen((char const   *)item);
      }
#line 1089
      if (__cil_tmp24 < __cil_tmp25) {
        {
#line 1089
        __cil_tmp26 = strlen((char const   *)item);
#line 1089
        tmp___0 = spaces + __cil_tmp26;
        }
      } else {
#line 1089
        tmp___0 = (char *)" ";
      }
      {
#line 1089
      fprintf(dst, "%s:%sU", item, (int )tmp___0);
      }
#line 1091
      if (ape_tag) {
#line 1092
        j = 0;
        {
#line 1092
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1092
          if (! (j < value_len)) {
#line 1092
            goto while_break___0;
          }
#line 1093
          if (! *(value + j)) {
#line 1094
            *(value + j) = (char )'\\';
          }
#line 1092
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1096
        __cil_tmp28 = strchr((char const   *)value, '\n');
        }
#line 1096
        if (__cil_tmp28) {
          {
#line 1097
          fprintf(dst, "%d-byte multi-line text string\n", value_len);
          }
        } else {
          {
#line 1099
          dump_UTF8_string___0(value, dst);
#line 1100
          fprintf(dst, "\n\372\346>dU");
          }
        }
      } else {
        {
#line 1104
        fprintf(dst, "%s\n>dU", value);
        }
      }
      {
#line 1106
      free(value);
#line 1107
      free(item);
      }
#line 1078
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1110
    i = 0;
    {
#line 1110
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1110
      if (! (i < num_binary_items)) {
#line 1110
        goto while_break___1;
      }
      {
#line 1114
      item_len___0 = WavpackGetBinaryTagItemIndexed(wpc, i, (char *)((void *)0), 0);
#line 1115
      item___0 = (char *)malloc((unsigned long )(item_len___0 + 1));
#line 1116
      WavpackGetBinaryTagItemIndexed(wpc, i, item___0, item_len___0 + 1);
#line 1117
      value_len___0 = dump_tag_item_to_file___0(wpc, (char const   *)item___0, (FILE *)((void *)0),
                                                (char *)fname);
#line 1118
      __cil_tmp37 = strlen((char const   *)spaces);
      }
      {
#line 1118
      __cil_tmp36 = strlen((char const   *)item___0);
      }
#line 1118
      if (__cil_tmp36 < __cil_tmp37) {
        {
#line 1118
        __cil_tmp38 = strlen((char const   *)item___0);
#line 1118
        tmp___1 = spaces + __cil_tmp38;
        }
      } else {
#line 1118
        tmp___1 = (char *)" ";
      }
      {
#line 1118
      fprintf(dst, "%s:%s", item___0, (int )tmp___1);
#line 1120
      __cil_tmp40 = filespec_ext((char *)fname);
      }
#line 1120
      if (__cil_tmp40) {
        {
#line 1121
        __cil_tmp41 = filespec_ext((char *)fname);
#line 1121
        fprintf(dst, "%d-byte binary item (%s)\n\005\350>dU", value_len___0, __cil_tmp41 + 1);
        }
      } else {
        {
#line 1123
        fprintf(dst, "%d-byte binary item\ndU", value_len___0);
        }
      }
      {
#line 1155
      free(item___0);
      }
#line 1110
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 1170 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static int dump_tag_item_to_file___0(WavpackContext *wpc , char const   *tag_item ,
                                     FILE *dst , char *fname ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int value_len ;
  int __cil_tmp8 ;
  char *value ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;
  int value_len___0 ;
  int __cil_tmp13 ;
  int res ;
  int i ;
  uint32_t bcount ;
  char *value___0 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 1172
  __cil_tmp5 = WavpackGetMode(wpc);
  }
#line 1172
  if (__cil_tmp5 & 16) {
    {
#line 1173
    __cil_tmp6 = WavpackGetTagItem(wpc, tag_item, (char *)((void *)0), 0);
    }
#line 1173
    if (__cil_tmp6) {
      {
#line 1174
      __cil_tmp8 = WavpackGetTagItem(wpc, tag_item, (char *)((void *)0), 0);
#line 1174
      value_len = __cil_tmp8;
      }
#line 1177
      if (fname) {
        {
#line 1178
        strcpy(fname, tag_item);
#line 1179
        strcat(fname, ".txt");
        }
      }
#line 1182
      if (! dst) {
#line 1183
        return (value_len);
      } else
#line 1182
      if (! value_len) {
#line 1183
        return (value_len);
      }
      {
#line 1191
      value = (char *)malloc((unsigned long )(value_len * 2 + 1));
#line 1192
      WavpackGetTagItem(wpc, tag_item, value, value_len + 1);
#line 1193
      dump_UTF8_string___0(value, dst);
#line 1194
      free(value);
      }
#line 1195
      return (value_len);
    } else {
      {
#line 1197
      __cil_tmp11 = WavpackGetBinaryTagItem(wpc, tag_item, (char *)((void *)0), 0);
      }
#line 1197
      if (__cil_tmp11) {
        {
#line 1198
        __cil_tmp13 = WavpackGetBinaryTagItem(wpc, tag_item, (char *)((void *)0),
                                              0);
#line 1198
        value_len___0 = __cil_tmp13;
        }
        {
#line 1198
        res = 0;
#line 1199
        bcount = (uint32_t )0;
#line 1202
        value___0 = (char *)malloc((unsigned long )value_len___0);
#line 1203
        WavpackGetBinaryTagItem(wpc, tag_item, value___0, value_len___0);
#line 1205
        i = 0;
        }
        {
#line 1205
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1205
          if (! (i < value_len___0)) {
#line 1205
            goto while_break;
          }
#line 1206
          if (! *(value___0 + i)) {
#line 1208
            if (dst) {
              {
#line 1215
              res = DoWriteFile(dst, ((unsigned char *)value___0 + i) + 1, (uint32_t )((value_len___0 - i) - 1),
                                & bcount);
              }
            }
#line 1218
            if (fname) {
#line 1219
              if (i < 256) {
                {
#line 1220
                strcpy(fname, (char const   *)value___0);
                }
              } else {
                {
#line 1222
                strcpy(fname, tag_item);
#line 1223
                strcat(fname, ".bindU");
                }
              }
            }
#line 1227
            goto while_break;
          }
#line 1205
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1230
        free(value___0);
        }
#line 1232
        if (i == value_len___0) {
#line 1233
          return (0);
        }
#line 1235
        if (dst) {
#line 1235
          if (! res) {
#line 1236
            return (0);
          } else
#line 1235
          if (bcount != (unsigned int )((value_len___0 - i) - 1)) {
#line 1236
            return (0);
          }
        }
#line 1238
        return ((value_len___0 - i) - 1);
      } else {
#line 1241
        return (0);
      }
    }
  } else {
#line 1244
    return (0);
  }
}
}
#line 1254 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static int calculate_tag_size(WavpackContext *wpc ) 
{ 
  int mode ;
  int __cil_tmp3 ;
  int num_binary_items ;
  int __cil_tmp5 ;
  int num_items ;
  int __cil_tmp7 ;
  int i ;
  int ape_tag_size ;
  int item_len ;
  int value_len ;
  char *item ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 1256
  __cil_tmp3 = WavpackGetMode(wpc);
#line 1256
  mode = __cil_tmp3;
  }
#line 1258
  if (mode & 16) {
#line 1258
    if (mode & 256) {
      {
#line 1259
      __cil_tmp5 = WavpackGetNumBinaryTagItems(wpc);
#line 1259
      num_binary_items = __cil_tmp5;
#line 1260
      __cil_tmp7 = WavpackGetNumTagItems(wpc);
#line 1260
      num_items = __cil_tmp7;
#line 1261
      ape_tag_size = 64;
      }
#line 1265
      if (num_items + num_binary_items == 0) {
#line 1266
        return (0);
      }
#line 1268
      i = 0;
      {
#line 1268
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1268
        if (! (i < num_items)) {
#line 1268
          goto while_break;
        }
        {
#line 1269
        item_len = WavpackGetTagItemIndexed(wpc, i, (char *)((void *)0), 0);
#line 1270
        item = (char *)malloc((unsigned long )(item_len + 1));
#line 1271
        WavpackGetTagItemIndexed(wpc, i, item, item_len + 1);
#line 1272
        value_len = WavpackGetTagItem(wpc, (char const   *)item, (char *)((void *)0),
                                      0);
#line 1273
        ape_tag_size += ((8 + item_len) + 1) + value_len;
#line 1274
        free(item);
        }
#line 1268
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1277
      i = 0;
      {
#line 1277
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1277
        if (! (i < num_binary_items)) {
#line 1277
          goto while_break___0;
        }
        {
#line 1278
        item_len = WavpackGetBinaryTagItemIndexed(wpc, i, (char *)((void *)0), 0);
#line 1279
        item = (char *)malloc((unsigned long )(item_len + 1));
#line 1280
        WavpackGetBinaryTagItemIndexed(wpc, i, item, item_len + 1);
#line 1281
        value_len = WavpackGetBinaryTagItem(wpc, (char const   *)item, (char *)((void *)0),
                                            0);
#line 1282
        ape_tag_size += ((8 + item_len) + 1) + value_len;
#line 1283
        free(item);
        }
#line 1277
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1286
      return (ape_tag_size);
    } else {
#line 1258
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1288
  if (mode & 16) {
#line 1289
    return (128);
  } else {
#line 1291
    return (0);
  }
}
}
#line 1300 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static void dump_UTF8_string___0(char *string , FILE *dst ) 
{ 
  char *p ;
  char *temp ;
  int len ;
  char *__cil_tmp6 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1302
    if (! *string) {
#line 1302
      goto while_break;
    }
#line 1303
    p = string;
#line 1304
    len = 0;
    {
#line 1306
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1306
      if (! *p) {
#line 1306
        goto while_break___0;
      }
#line 1307
      if ((int )*p != 13) {
#line 1308
        len ++;
      }
#line 1310
      __cil_tmp6 = p;
#line 1310
      p ++;
#line 1310
      if ((int )*__cil_tmp6 == 10) {
#line 1311
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1314
    if (! len) {
#line 1315
      return;
    }
    {
#line 1317
    p = (char *)malloc((unsigned long )(len * 2 + 1));
    }
    {
#line 1319
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1319
      if (! *string) {
#line 1319
        goto while_break___1;
      }
#line 1320
      if ((int )*string != 13) {
#line 1321
        __cil_tmp8 = p;
#line 1321
        p ++;
#line 1321
        *__cil_tmp8 = *string;
      }
#line 1323
      __cil_tmp9 = string;
#line 1323
      string ++;
#line 1323
      if ((int )*__cil_tmp9 == 10) {
#line 1324
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1327
    *p = (char )0;
#line 1332
    if (! no_utf8_convert___0) {
      {
#line 1334
      UTF8ToAnsi___0(temp, len * 2);
      }
    }
    {
#line 1336
    fputs((char const   *)temp, dst);
#line 1337
    free(temp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1347
static int UTF8ToWideChar(unsigned char const   *pUTF8 , wchar_t *pWide ) ;
#line 1349 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static void UTF8ToAnsi___0(char *string , int len ) 
{ 
  int max_chars ;
  unsigned long __cil_tmp4 ;
  char *temp ;
  void *__cil_tmp6 ;
  char *outp ;
  char *inp ;
  size_t insize ;
  size_t outsize ;
  int err ;
  char *old_locale ;
  iconv_t converter ;
  char *__cil_tmp14 ;
  iconv_t __cil_tmp15 ;
  size_t __cil_tmp16 ;

  {
  {
#line 1351
  __cil_tmp4 = strlen((char const   *)string);
#line 1351
  max_chars = (int )__cil_tmp4;
#line 1368
  __cil_tmp6 = malloc((unsigned long )len);
#line 1368
  temp = __cil_tmp6;
#line 1369
  outp = temp;
#line 1370
  inp = string;
#line 1371
  insize = (size_t )max_chars;
#line 1372
  outsize = (size_t )(len - 1);
#line 1373
  err = 0;
#line 1377
  memset(temp, 0, (unsigned long )len);
#line 1378
  old_locale = setlocale(0, "\320x\350>dU");
#line 1379
  converter = iconv_open("\323\001 >\001", "UTF-8");
  }
#line 1381
  if (converter != (iconv_t )-1) {
    {
#line 1382
    __cil_tmp16 = iconv(converter, & inp, & insize, & outp, & outsize);
#line 1382
    err = (int )__cil_tmp16;
#line 1383
    iconv_close(converter);
    }
  } else {
#line 1386
    err = - 1;
  }
  {
#line 1388
  setlocale(0, (char const   *)old_locale);
  }
#line 1390
  if (err == -1) {
    {
#line 1391
    free(temp);
    }
#line 1392
    return;
  }
  {
#line 1395
  memmove(string, temp, (unsigned long )len);
#line 1397
  free(temp);
  }
  return;
}
}
#line 1513 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static void TextToUTF8(void *string , int len ) 
{ 
  char *temp ;
  void *__cil_tmp4 ;
  char *outp ;
  char *inp ;
  size_t insize ;
  size_t outsize ;
  int err ;
  char *old_locale ;
  iconv_t converter ;
  char *__cil_tmp12 ;
  uint16_t *utf16p ;
  uint16_t *__cil_tmp14 ;
  iconv_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  iconv_t __cil_tmp17 ;
  size_t __cil_tmp18 ;

  {
  {
#line 1515
  __cil_tmp4 = malloc((unsigned long )len);
#line 1515
  temp = __cil_tmp4;
#line 1516
  outp = temp;
#line 1517
  inp = string;
#line 1518
  insize = (size_t )0;
#line 1519
  outsize = (size_t )(len - 1);
#line 1520
  err = 0;
  }
#line 1526
  if (len > 3) {
#line 1526
    if ((int )((unsigned char )*(inp + 0)) == 239) {
#line 1526
      if ((int )((unsigned char )*(inp + 1)) == 187) {
#line 1526
        if ((int )((unsigned char )*(inp + 2)) == 191) {
          {
#line 1528
          memmove(inp, inp + 3, (unsigned long )(len - 3));
#line 1529
          *(inp + (len - 3)) = (char )0;
          }
#line 1530
          return;
        }
      }
    }
  }
  {
#line 1533
  memset(temp, 0, (unsigned long )len);
#line 1534
  old_locale = setlocale(0, "\220");
  }
#line 1536
  if ((int )((unsigned char )*(inp + 0)) == 255) {
#line 1536
    if ((int )((unsigned char )*(inp + 1)) == 254) {
#line 1537
      inp += 2;
#line 1537
      utf16p = (uint16_t *)inp;
      {
#line 1539
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1539
        __cil_tmp14 = utf16p;
#line 1539
        utf16p ++;
#line 1539
        if (! *__cil_tmp14) {
#line 1539
          goto while_break;
        }
#line 1540
        insize += (unsigned long )2;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1542
      converter = iconv_open("UTF-8U", "UTF-16LE\220");
      }
    } else {
      {
      {
#line 1545
      insize = strlen(string);
      }
      {
#line 1546
      converter = iconv_open("UTF-8", "\220");
      }
      }
    }
  } else {
    {
    {
#line 1545
    insize = strlen(string);
    }
    {
#line 1546
    converter = iconv_open("UTF-8", "\220");
    }
    }
  }
#line 1549
  if (converter != (iconv_t )-1) {
    {
#line 1550
    __cil_tmp18 = iconv(converter, & inp, & insize, & outp, & outsize);
#line 1550
    err = (int )__cil_tmp18;
#line 1551
    iconv_close(converter);
    }
  } else {
#line 1554
    err = - 1;
  }
  {
#line 1556
  setlocale(0, (char const   *)old_locale);
  }
#line 1558
  if (err == -1) {
    {
#line 1559
    free(temp);
    }
#line 1560
    return;
  }
  {
#line 1563
  memmove(string, temp, (unsigned long )len);
#line 1564
  free(temp);
  }
  return;
}
}
#line 1624 "/doner/wavpack/wavpack-5.1.0/cli/wvtag.c"
static FILE *wild_fopen(char *filename , char const   *mode ) 
{ 
  char *matchname ;
  struct stat statbuf ;
  FILE *res ;
  glob_t globbuf ;
  int i ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  FILE *__cil_tmp11 ;

  {
  {
#line 1626
  matchname = (char *)((void *)0);
#line 1628
  res = (FILE *)((void *)0);
#line 1632
  glob((char const   *)filename, 0, (int (*)(char const   * , int  ))((void *)0),
       & globbuf);
#line 1634
  i = 0;
  }
  {
#line 1634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1634
    if (! ((unsigned long )i < globbuf.gl_pathc)) {
#line 1634
      goto while_break;
    }
    {
#line 1635
    __cil_tmp8 = stat((char const   *)*(globbuf.gl_pathv + i), & statbuf);
    }
#line 1635
    if (__cil_tmp8 == -1) {
#line 1636
      goto while_continue;
    } else
#line 1635
    if ((statbuf.st_mode & 61440U) == 16384U) {
#line 1636
      goto while_continue;
    }
#line 1638
    if (matchname) {
      {
#line 1639
      free(matchname);
#line 1640
      matchname = (char *)((void *)0);
      }
#line 1641
      goto while_break;
    } else {
      {
#line 1644
      __cil_tmp9 = strlen((char const   *)*(globbuf.gl_pathv + i));
#line 1644
      __cil_tmp10 = malloc(__cil_tmp9 + 10UL);
#line 1644
      matchname = __cil_tmp10;
#line 1645
      strcpy(matchname, (char const   *)*(globbuf.gl_pathv + i));
      }
    }
#line 1634
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1649
  globfree(& globbuf);
  }
#line 1651
  if (matchname) {
    {
#line 1652
    res = fopen((char const   *)matchname, mode);
#line 1653
    free(matchname);
    }
  }
#line 1656
  return (res);
}
}
#line 302 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
static int waiting_input___0 ;
#line 580
static int break_flag___0 ;
#line 582 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
static void int_handler___0(int s ) 
{ 


  {
#line 584
  break_flag___0 = 1;
  return;
}
}
#line 24 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
static struct __anonstruct_253 text_tag_table[8]  = 
#line 24 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
  {      {"TALB", "Album"}, 
        {"TIT2", "Title"}, 
        {"TPE1", "Artist"}, 
        {"TCON", "Genre"}, 
        {"TYER", "Year"}, 
        {"TRCK", "Track"}, 
        {"TCOM", "Composer\250"}, 
        {"TPE3", "Conductor"}};
#line 37
static int WideCharToUTF8(wchar_t *Wide , unsigned char *pUTF8 , int len ) ;
#line 38
static void Latin1ToUTF8(void *string , int len ) ;
#line 47 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
int ImportID3v2(WavpackContext *wpc , unsigned char *tag_data , int tag_size , char *error ,
                int32_t *bytes_used ) 
{ 
  int tag_size_from_header ;
  int items_imported ;
  int done_cover ;
  unsigned char id3_header[10] ;
  int __cil_tmp10 ;
  unsigned char frame_header[10] ;
  unsigned char *frame_body ;
  int frame_size ;
  int i ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *utf8_string ;
  int nchars ;
  unsigned char *fp ;
  void *__cil_tmp20 ;
  unsigned char *__cil_tmp21 ;
  int nchars___0 ;
  wchar_t *wide_string ;
  void *__cil_tmp24 ;
  unsigned char *fp___0 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  char *__cil_tmp30 ;
  int __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  char *mime_type ;
  char *description ;
  char *extension ;
  char *item ;
  unsigned char *frame_ptr ;
  int frame_bytes ;
  unsigned char picture_type ;
  int __cil_tmp42 ;
  unsigned char *__cil_tmp43 ;
  unsigned char *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  unsigned char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  int binary_tag_size ;
  unsigned long __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  char *binary_tag_image ;
  void *__cil_tmp56 ;
  int __cil_tmp57 ;
  char *__cil_tmp58 ;
  int __cil_tmp59 ;
  unsigned long __cil_tmp60 ;

  {
#line 49
  items_imported = 0;
#line 49
  done_cover = 0;
#line 52
  if (bytes_used) {
#line 53
    *bytes_used = 0;
  }
#line 55
  if ((unsigned long )tag_size < sizeof(id3_header)) {
    {
#line 56
    strcpy(error, "can\'t read tag header");
    }
#line 57
    return (- 1);
  }
  {
#line 60
  memcpy((unsigned char *)id3_header, tag_data, sizeof(id3_header));
#line 61
  tag_size -= sizeof(id3_header);
#line 62
  tag_data += sizeof(id3_header);
#line 64
  __cil_tmp10 = strncmp((char const   *)((char *)((unsigned char *)id3_header)), "ID3",
                        (unsigned long )3);
  }
#line 64
  if (__cil_tmp10) {
    {
#line 65
    strcpy(error, "no ID3v2 tag found");
    }
#line 66
    return (- 1);
  }
#line 69
  if ((int )id3_header[3] != 3) {
    {
    {
    {
#line 70
    strcpy(error, "not valid ID3v2.3");
    }
    }
    }
#line 71
    return (- 1);
  } else
#line 69
  if ((int )id3_header[4] == 255) {
    {
    {
    {
#line 70
    strcpy(error, "not valid ID3v2.3");
    }
    }
    }
#line 71
    return (- 1);
  } else
#line 69
  if ((int )id3_header[5] & 31) {
    {
    {
    {
#line 70
    strcpy(error, "not valid ID3v2.3");
    }
    }
    }
#line 71
    return (- 1);
  }
#line 74
  if ((int )id3_header[5] & 128) {
    {
#line 75
    strcpy(error, "unsynchonization detected");
    }
#line 76
    return (- 1);
  }
#line 79
  if ((int )id3_header[5] & 64) {
    {
#line 80
    strcpy(error, "extended header detected\220");
    }
#line 81
    return (- 1);
  }
#line 84
  if ((int )id3_header[5] & 32) {
    {
#line 85
    strcpy(error, "experimental indicator detected");
    }
#line 86
    return (- 1);
  }
#line 89
  if (((((int )id3_header[6] | (int )id3_header[7]) | (int )id3_header[8]) | (int )id3_header[9]) & 128) {
    {
#line 90
    strcpy(error, "not valid ID3v2.3 (bad size)");
    }
#line 91
    return (- 1);
  }
#line 94
  tag_size_from_header = (((int )id3_header[9] + ((int )id3_header[8] << 7)) + ((int )id3_header[7] << 14)) + ((int )id3_header[6] << 21);
#line 96
  if (tag_size_from_header > tag_size) {
    {
#line 97
    strcpy(error, "tag is truncated\220");
    }
#line 98
    return (- 1);
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if ((unsigned long )tag_size < sizeof(frame_header)) {
#line 106
      goto while_break;
    }
    {
#line 108
    memcpy((unsigned char *)frame_header, tag_data, sizeof(frame_header));
#line 109
    tag_size -= sizeof(frame_header);
#line 110
    tag_data += sizeof(frame_header);
    }
#line 112
    if (! frame_header[0]) {
#line 112
      if (! frame_header[1]) {
#line 112
        if (! frame_header[2]) {
#line 112
          if (! frame_header[3]) {
#line 113
            goto while_break;
          }
        }
      }
    }
#line 115
    i = 0;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! (i < 4)) {
#line 115
        goto while_break___0;
      }
#line 116
      if ((int )frame_header[i] < 48) {
        {
        {
        {
#line 119
        strcpy(error, "bad frame identity");
        }
        }
        }
#line 120
        return (- 1);
      } else
#line 116
      if ((int )frame_header[i] > 57) {
#line 116
        if ((int )frame_header[i] < 65) {
          {
          {
          {
#line 119
          strcpy(error, "bad frame identity");
          }
          }
          }
#line 120
          return (- 1);
        } else {
#line 116
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 116
      if ((int )frame_header[i] > 90) {
        {
        {
        {
#line 119
        strcpy(error, "bad frame identity");
        }
        }
        }
#line 120
        return (- 1);
      }
#line 115
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 123
    if (frame_header[9]) {
      {
#line 124
      strcpy(error, "unknown frame_header flag set");
      }
#line 125
      return (- 1);
    }
#line 128
    frame_size = (((int )frame_header[7] + ((int )frame_header[6] << 8)) + ((int )frame_header[5] << 16)) + ((int )frame_header[4] << 24);
#line 130
    if (! frame_size) {
      {
#line 131
      strcpy(error, "empty frame not allowed");
      }
#line 132
      return (- 1);
    }
    {
#line 135
    frame_body = (unsigned char *)malloc((unsigned long )(frame_size + 4));
    }
#line 137
    if (frame_size > tag_size) {
      {
#line 138
      strcpy(error, "can\'t read frame body");
      }
#line 139
      return (- 1);
    }
    {
#line 142
    memcpy(frame_body, tag_data, (unsigned long )frame_size);
#line 143
    tag_size -= frame_size;
#line 144
    tag_data += frame_size;
#line 146
    __cil_tmp16 = strncmp((char const   *)((char *)((unsigned char *)frame_header)),
                          "TXXX", (unsigned long )4);
    }
#line 146
    if ((int )frame_header[0] == 84) {
#line 146
      if (__cil_tmp16) {
#line 147
        utf8_string = (unsigned char *)((void *)0);
#line 149
        if ((int )*(frame_body + 0) == 0) {
          {
#line 150
          nchars = frame_size - 1;
#line 151
          fp = frame_body + 1;
#line 153
          utf8_string = (unsigned char *)malloc((unsigned long )((nchars + 1) * 3));
#line 155
          i = 0;
          }
          {
#line 155
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 155
            if (! (i < nchars)) {
#line 155
              goto while_break___1;
            }
#line 156
            __cil_tmp21 = fp;
#line 156
            fp ++;
#line 156
            *(utf8_string + i) = *__cil_tmp21;
#line 156
            if (! *(utf8_string + i)) {
#line 157
              goto while_break___1;
            }
#line 155
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 159
          if (i == nchars) {
#line 160
            *(utf8_string + nchars) = (unsigned char )0;
          }
          {
#line 162
          Latin1ToUTF8(utf8_string, (nchars + 1) * 3);
          }
        } else
#line 164
        if ((int )*(frame_body + 0) == 1) {
#line 164
          if (frame_size > 2) {
#line 164
            if ((int )*(frame_body + 1) == 255) {
#line 164
              if ((int )*(frame_body + 2) == 254) {
                {
#line 165
                nchars___0 = (frame_size - 3) / 2;
#line 166
                __cil_tmp24 = malloc((unsigned long )(nchars___0 + 1) * sizeof(wchar_t ));
#line 166
                wide_string = __cil_tmp24;
#line 167
                fp___0 = frame_body + 3;
#line 169
                utf8_string = (unsigned char *)malloc((unsigned long )((nchars___0 + 1) * 3));
#line 171
                i = 0;
                }
                {
#line 171
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 171
                  if (! (i < nchars___0)) {
#line 171
                    goto while_break___2;
                  }
#line 172
                  *(wide_string + i) = (int )*(fp___0 + 0) | ((int )*(fp___0 + 1) << 8);
#line 172
                  if (! *(wide_string + i)) {
#line 173
                    goto while_break___2;
                  }
#line 171
                  fp___0 += 2;
#line 171
                  i ++;
                }
                while_break___2: /* CIL Label */ ;
                }
#line 175
                if (i == nchars___0) {
#line 176
                  *(wide_string + nchars___0) = 0;
                }
                {
#line 178
                WideCharToUTF8(wide_string, utf8_string, (nchars___0 + 1) * 3);
#line 179
                free(wide_string);
                }
              } else {
                {
                {
                {
                {
#line 182
                strcpy(error, "unknown character encoding");
                }
                }
                }
                }
#line 183
                return (- 1);
              }
            } else {
              {
              {
              {
              {
#line 182
              strcpy(error, "unknown character encoding");
              }
              }
              }
              }
#line 183
              return (- 1);
            }
          } else {
            {
            {
            {
            {
#line 182
            strcpy(error, "unknown character encoding");
            }
            }
            }
            }
#line 183
            return (- 1);
          }
        } else {
          {
          {
          {
          {
#line 182
          strcpy(error, "unknown character encoding");
          }
          }
          }
          }
#line 183
          return (- 1);
        }
#line 188
        if (utf8_string) {
#line 189
          i = 0;
          {
#line 189
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 189
            if (! ((unsigned long )i < sizeof(text_tag_table) / sizeof(text_tag_table[0]))) {
#line 189
              goto while_break___3;
            }
            {
#line 190
            __cil_tmp27 = strncmp((char const   *)((char *)((unsigned char *)frame_header)),
                                  (char const   *)text_tag_table[i].id3_item, (unsigned long )4);
            }
#line 190
            if (! __cil_tmp27) {
              {
#line 191
              __cil_tmp28 = strlen((char const   *)((char *)utf8_string));
#line 191
              __cil_tmp29 = WavpackAppendTagItem(wpc, (char const   *)text_tag_table[i].ape_item,
                                                 (char const   *)((char *)utf8_string),
                                                 (int )__cil_tmp28);
              }
#line 191
              if (wpc) {
#line 191
                if (! __cil_tmp29) {
                  {
#line 192
                  __cil_tmp30 = WavpackGetErrorMessage(wpc);
#line 192
                  strcpy(error, (char const   *)__cil_tmp30);
                  }
#line 193
                  return (- 1);
                }
              }
#line 196
              items_imported ++;
#line 197
              if (bytes_used) {
                {
#line 197
                __cil_tmp33 = strlen((char const   *)text_tag_table[i].ape_item);
                }
                {
#line 197
                __cil_tmp32 = strlen((char const   *)((char *)utf8_string));
                }
#line 197
                *bytes_used += (int )((__cil_tmp32 + __cil_tmp33) + 1UL);
              }
            }
#line 189
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 200
          free(utf8_string);
          }
        }
      } else {
#line 146
        goto _L___49;
      }
    } else {
      _L___49: /* CIL Label */ 
      {
#line 203
      __cil_tmp34 = strncmp((char const   *)((char *)((unsigned char *)frame_header)),
                            "APIC", (unsigned long )4);
      }
#line 203
      if (! __cil_tmp34) {
#line 204
        if ((int )*(frame_body + 0) == 0) {
#line 205
          item = (char *)((void *)0);
#line 206
          frame_ptr = frame_body + 1;
#line 207
          frame_bytes = frame_size - 1;
#line 210
          mime_type = (char *)frame_ptr;
          {
#line 212
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 212
            __cil_tmp43 = frame_ptr;
#line 212
            frame_ptr ++;
#line 212
            __cil_tmp42 = frame_bytes;
#line 212
            frame_bytes --;
#line 212
            if (! (__cil_tmp42 && (int )*__cil_tmp43)) {
#line 212
              goto while_break___4;
            }

          }
          while_break___4: /* CIL Label */ ;
          }
#line 214
          if (frame_bytes < 0) {
            {
#line 215
            strcpy(error, "unterminated picture mime type");
            }
#line 216
            return (- 1);
          }
#line 219
          if (frame_bytes == 0) {
            {
#line 220
            strcpy(error, "no picture type");
            }
#line 221
            return (- 1);
          }
#line 224
          __cil_tmp44 = frame_ptr;
#line 224
          frame_ptr ++;
#line 224
          picture_type = *__cil_tmp44;
#line 225
          __cil_tmp45 = frame_bytes;
#line 225
          frame_bytes --;
#line 227
          description = (char *)frame_ptr;
          {
#line 229
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 229
            __cil_tmp47 = frame_ptr;
#line 229
            frame_ptr ++;
#line 229
            __cil_tmp46 = frame_bytes;
#line 229
            frame_bytes --;
#line 229
            if (! (__cil_tmp46 && (int )*__cil_tmp47)) {
#line 229
              goto while_break___5;
            }

          }
          while_break___5: /* CIL Label */ ;
          }
#line 231
          if (frame_bytes < 0) {
            {
#line 232
            strcpy(error, "unterminated picture description\220");
            }
#line 233
            return (- 1);
          }
#line 236
          if (frame_bytes < 2) {
            {
#line 237
            strcpy(error, "no picture data");
            }
#line 238
            return (- 1);
          }
          {
#line 241
          __cil_tmp49 = strstr((char const   *)mime_type, "JPEG");
          }
          {
#line 241
          __cil_tmp48 = strstr((char const   *)mime_type, "jpeg");
          }
#line 241
          if (__cil_tmp48) {
#line 242
            extension = ".jpg";
          } else
#line 241
          if (__cil_tmp49) {
#line 242
            extension = ".jpg";
          } else {
            {
#line 243
            __cil_tmp51 = strstr((char const   *)mime_type, "PNG");
            }
            {
#line 243
            __cil_tmp50 = strstr((char const   *)mime_type, "png");
            }
#line 243
            if (__cil_tmp50) {
#line 244
              extension = ".png";
            } else
#line 243
            if (__cil_tmp51) {
#line 244
              extension = ".png";
            } else
#line 245
            if ((int )*(frame_ptr + 0) == 255) {
#line 245
              if ((int )*(frame_ptr + 1) == 216) {
#line 246
                extension = ".jpg";
              } else {
#line 245
                goto _L___48;
              }
            } else
            _L___48: /* CIL Label */ 
#line 247
            if ((int )*(frame_ptr + 0) == 137) {
#line 247
              if ((int )*(frame_ptr + 1) == 80) {
#line 248
                extension = ".png";
              } else {
#line 250
                extension = "\220";
              }
            } else {
#line 250
              extension = "\220";
            }
          }
#line 252
          if ((int )picture_type == 3) {
#line 253
            item = "Cover Art (Front)";
#line 254
            done_cover = 1;
          } else
#line 256
          if ((int )picture_type == 4) {
#line 257
            item = "Cover Art (Back)\220";
          } else
#line 258
          if ((int )picture_type != 1) {
#line 258
            if ((int )picture_type != 2) {
#line 258
              if (! done_cover) {
#line 259
                item = "Cover Art (Front)";
#line 260
                done_cover = 1;
              }
            }
          }
#line 263
          if (item) {
            {
#line 264
            __cil_tmp54 = strlen((char const   *)extension);
            }
            {
#line 264
            __cil_tmp53 = strlen((char const   *)item);
#line 264
            binary_tag_size = (((int )__cil_tmp53 + (int )__cil_tmp54) + 1) + frame_bytes;
#line 265
            __cil_tmp56 = malloc((unsigned long )binary_tag_size);
#line 265
            binary_tag_image = __cil_tmp56;
#line 267
            strcpy(binary_tag_image, (char const   *)item);
#line 268
            strcat(binary_tag_image, (char const   *)extension);
#line 269
            memcpy((binary_tag_image + binary_tag_size) - frame_bytes, frame_ptr,
                   (unsigned long )frame_bytes);
#line 271
            __cil_tmp57 = WavpackAppendBinaryTagItem(wpc, (char const   *)item, (char const   *)binary_tag_image,
                                                     binary_tag_size);
            }
#line 271
            if (wpc) {
#line 271
              if (! __cil_tmp57) {
                {
#line 272
                __cil_tmp58 = WavpackGetErrorMessage(wpc);
#line 272
                strcpy(error, (char const   *)__cil_tmp58);
                }
#line 273
                return (- 1);
              }
            }
#line 276
            items_imported ++;
#line 277
            if (bytes_used) {
              {
#line 277
              __cil_tmp60 = strlen((char const   *)item);
              }
#line 277
              *bytes_used += ((int )__cil_tmp60 + 1) + binary_tag_size;
            }
            {
#line 278
            free(binary_tag_image);
            }
          }
        } else {
          {
#line 282
          strcpy(error, "unhandled APIC character encoding");
          }
#line 283
          return (- 1);
        }
      }
    }
    {
#line 287
    free(frame_body);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return (items_imported);
}
}
#line 300 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
static int WideCharToUTF8(wchar_t *Wide , unsigned char *pUTF8 , int len ) 
{ 
  wchar_t *pWide ;
  int outndx ;
  int __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  wchar_t *__cil_tmp14 ;

  {
#line 302
  pWide = Wide;
#line 303
  outndx = 0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! *pWide) {
#line 305
      goto while_break;
    }
#line 306
    if (*pWide < 128) {
#line 306
      if (outndx + 1 < len) {
#line 307
        __cil_tmp7 = pWide;
#line 307
        pWide ++;
#line 307
        __cil_tmp6 = outndx;
#line 307
        outndx ++;
#line 307
        *(pUTF8 + __cil_tmp6) = (unsigned char )*__cil_tmp7;
      } else {
#line 306
        goto _L___50;
      }
    } else
    _L___50: /* CIL Label */ 
#line 308
    if (*pWide < 2048) {
#line 308
      if (outndx + 2 < len) {
#line 309
        __cil_tmp8 = outndx;
#line 309
        outndx ++;
#line 309
        *(pUTF8 + __cil_tmp8) = (unsigned char )(192 | ((*pWide >> 6) & 31));
#line 310
        __cil_tmp10 = pWide;
#line 310
        pWide ++;
#line 310
        __cil_tmp9 = outndx;
#line 310
        outndx ++;
#line 310
        *(pUTF8 + __cil_tmp9) = (unsigned char )(128 | (*__cil_tmp10 & 63));
      } else {
#line 308
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 312
    if (outndx + 3 < len) {
#line 313
      __cil_tmp11 = outndx;
#line 313
      outndx ++;
#line 313
      *(pUTF8 + __cil_tmp11) = (unsigned char )(224 | ((*pWide >> 12) & 15));
#line 314
      __cil_tmp12 = outndx;
#line 314
      outndx ++;
#line 314
      *(pUTF8 + __cil_tmp12) = (unsigned char )(128 | ((*pWide >> 6) & 63));
#line 315
      __cil_tmp14 = pWide;
#line 315
      pWide ++;
#line 315
      __cil_tmp13 = outndx;
#line 315
      outndx ++;
#line 315
      *(pUTF8 + __cil_tmp13) = (unsigned char )(128 | (*__cil_tmp14 & 63));
    } else {
#line 318
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  *(pUTF8 + outndx) = (unsigned char )0;
#line 322
  return ((int )(pWide - Wide));
}
}
#line 349 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
static void Latin1ToUTF8(void *string , int len ) 
{ 
  char *temp ;
  void *__cil_tmp4 ;
  char *outp ;
  char *inp ;
  size_t insize ;
  size_t outsize ;
  int err ;
  iconv_t converter ;
  unsigned long __cil_tmp11 ;
  iconv_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 351
  __cil_tmp4 = malloc((unsigned long )len);
#line 351
  temp = __cil_tmp4;
#line 352
  outp = temp;
#line 353
  inp = string;
#line 354
  insize = (size_t )0;
#line 355
  outsize = (size_t )(len - 1);
#line 356
  err = 0;
#line 359
  memset(temp, 0, (unsigned long )len);
#line 361
  insize = strlen(string);
#line 362
  converter = iconv_open("UTF-8", "ISO-8859-1\023?dU");
  }
#line 364
  if (converter != (iconv_t )-1) {
    {
#line 365
    __cil_tmp13 = iconv(converter, & inp, & insize, & outp, & outsize);
#line 365
    err = (int )__cil_tmp13;
#line 366
    iconv_close(converter);
    }
  } else {
#line 369
    err = - 1;
  }
#line 371
  if (err == -1) {
    {
#line 372
    free(temp);
    }
#line 373
    return;
  }
  {
#line 376
  memmove(string, temp, (unsigned long )len);
#line 377
  free(temp);
  }
  return;
}
}
#line 62 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static char const   *sign_on___1  =    "\n WVGAIN  ReplayGain Scanner/Tagger for WavPack  %s Version %s\n Copyright (c) 2005 - 2017 David Bryant.  All Rights Reserved.\n\n";
#line 66 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static char const   *version_warning___1  =    "\n WARNING: WVGAIN using libwavpack version %s, expected %s (see README)\n\n";
#line 69 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static char const   *usage___0  =    " Usage:   WVGAIN [-options] [@]infile[.wv] [...]\n             (multiple input files are allowed)\n\n Options: -a  = album mode (all files scanned are considered an album)\n          -c  = clean ReplayGain values from all files (no analysis)\n          -d  = display calculated values only (no files are modified)\n          -i  = ignore .wvc file (forces hybrid lossy)\n          -n  = new files only (skip files with track info, or album\n                 info if album mode specified)\n          -q  = quiet (keep console output to a minimum)\n          -s  = show stored values only (no analysis)\n          -v  = write the version to stdout\n          -z1 = set console title to indicate progress\n\n Web:     Visit www.wavpack.com for latest version and info\n";
#line 101
static uint32_t track_histogram[12000] ;
#line 101
static uint32_t album_histogram[12000] ;
#line 103
static char album_mode ;
#line 103
static char clean_mode ;
#line 103
static char display_mode ;
#line 103
static char ignore_wvc___0 ;
#line 103
static char quiet_mode___1 ;
#line 103
static char show_mode ;
#line 103
static char new_mode ;
#line 103
static char set_console_title___0 ;
#line 104
static int num_files___0 ;
#line 104
static int file_index___0 ;
#line 108
static int update_file(char *infilename , float track_gain , float track_peak , float album_gain ,
                       float album_peak ) ;
#line 109
static int analyze_file(char *infilename , uint32_t *histogram , float *peak ) ;
#line 110
static int show_file_info(char *infilename , FILE *dst ) ;
#line 111
static float calc_replaygain(uint32_t *histogram ) ;
#line 112
static void *decimation_init(int num_channels , int ratio ) ;
#line 113
static int decimation_run(void *context , int32_t *samples , int num_samples ) ;
#line 114
static void *decimation_destroy(void *context ) ;
#line 578
static void calc_stereo_peak(float *samples , uint32_t samcnt , float *peak_p ) ;
#line 579
static double calc_stereo_rms(float *samples , uint32_t samcnt ) ;
#line 580
static int filter_init(uint32_t sample_rate ) ;
#line 581
static void filter_stereo_samples(float *samples , uint32_t samcnt ) ;
#line 582
static void float_samples(float *dst , int32_t *src , uint32_t samcnt , float scale ) ;
#line 584 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static int analyze_file(char *infilename , uint32_t *histogram , float *peak ) 
{ 
  int result ;
  int open_flags ;
  int num_channels ;
  int wvc_mode ;
  uint32_t sample_rate ;
  uint32_t window_samples ;
  int64_t total_unpacked_samples ;
  void *decimation_context ;
  double progress ;
  int32_t *temp_buffer ;
  WavpackContext *wpc ;
  char error[80] ;
  WavpackContext *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  uint32_t __cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  int __cil_tmp28 ;
  uint32_t samples_to_unpack ;
  uint32_t samples_unpacked ;
  int32_t level ;
  uint32_t __cil_tmp32 ;
  int __cil_tmp33 ;
  uint32_t __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int32_t *dst ;
  int32_t *src ;
  uint32_t cnt ;
  uint32_t __cil_tmp40 ;
  double __cil_tmp41 ;
  double __cil_tmp42 ;
  uint32_t __cil_tmp43 ;
  uint32_t __cil_tmp44 ;
  uint32_t __cil_tmp45 ;
  int __cil_tmp46 ;
  double __cil_tmp47 ;
  double __cil_tmp48 ;
  double __cil_tmp49 ;
  int nobs ;
  double __cil_tmp51 ;
  double __cil_tmp52 ;
  char const   *tmp___2 ;
  int64_t __cil_tmp54 ;
  int64_t __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;

  {
#line 586
  result = 0;
  {
#line 586
  open_flags = 0;
#line 588
  total_unpacked_samples = (int64_t )0;
#line 589
  decimation_context = (void *)0;
#line 590
  progress = - 1.;
#line 595
  memset(histogram, 0, sizeof(*histogram) * 12000UL);
#line 596
  *peak = (float )0.;
  }
#line 604
  if (! ignore_wvc___0) {
#line 605
    open_flags |= 1;
  }
  {
#line 607
  open_flags |= 530;
#line 609
  wpc = WavpackOpenFileInput((char const   *)infilename, (char *)error, open_flags,
                             0);
  }
#line 611
  if (! wpc) {
    {
#line 612
    error_line((char *)error);
    }
#line 613
    return (1);
  }
  {
#line 616
  __cil_tmp17 = WavpackGetMode(wpc);
#line 616
  wvc_mode = __cil_tmp17 & 1;
#line 617
  num_channels = WavpackGetNumChannels(wpc);
  }
#line 619
  if (num_channels > 2) {
    {
#line 620
    error_line("can\'t handle multichannel files yet!");
    }
#line 621
    return (1);
  }
#line 624
  if (! quiet_mode___1) {
#line 625
    if ((int )*infilename == 45) {
#line 625
      tmp___0 = "stdin";
    } else {
      {
#line 625
      __cil_tmp19 = strlen((char const   *)infilename);
      }
#line 625
      if (__cil_tmp19 > 30UL) {
        {
#line 625
        __cil_tmp20 = filespec_name(infilename);
#line 625
        tmp = __cil_tmp20;
        }
      } else {
#line 625
        tmp = infilename;
      }
#line 625
      tmp___0 = (char const   *)tmp;
    }
#line 625
    if (wvc_mode) {
#line 625
      tmp___1 = " (+.wvc)\323\001 ";
    } else {
#line 625
      tmp___1 = "\220";
    }
    {
#line 625
    fprintf(stderr, "analyzing %s%s,", (int )tmp___0, tmp___1);
#line 627
    fflush(stderr);
    }
  }
  {
#line 630
  sample_rate = WavpackGetSampleRate(wpc);
  }
#line 632
  if (sample_rate >= 256000U) {
    {
#line 633
    decimation_context = decimation_init(num_channels, 4);
#line 634
    sample_rate /= (unsigned int )4;
    }
  }
#line 637
  window_samples = sample_rate / 20U;
#line 639
  if (decimation_context) {
    {
#line 640
    temp_buffer = (int32_t *)malloc((unsigned long )((window_samples * 8U) * 4U));
    }
  } else {
    {
#line 642
    temp_buffer = (int32_t *)malloc((unsigned long )(window_samples * 8U));
    }
  }
  {
#line 644
  __cil_tmp28 = filter_init(sample_rate);
  }
#line 644
  if (! __cil_tmp28) {
#line 645
    result = 1;
  }
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! (result == 0)) {
#line 647
      goto while_break;
    }
#line 651
    samples_to_unpack = window_samples;
#line 653
    if (decimation_context) {
      {
#line 654
      samples_unpacked = WavpackUnpackSamples(wpc, temp_buffer, samples_to_unpack * 4U);
#line 655
      total_unpacked_samples += (long )samples_unpacked;
#line 656
      __cil_tmp33 = decimation_run(decimation_context, temp_buffer, (int )samples_unpacked);
#line 656
      samples_unpacked = (uint32_t )__cil_tmp33;
      }
    } else {
      {
#line 659
      samples_unpacked = WavpackUnpackSamples(wpc, temp_buffer, samples_to_unpack);
#line 660
      total_unpacked_samples += (long )samples_unpacked;
      }
    }
#line 663
    if (samples_unpacked) {
      {
#line 664
      __cil_tmp35 = WavpackGetMode(wpc);
      }
#line 664
      if (! (__cil_tmp35 & 8)) {
        {
#line 665
        __cil_tmp36 = WavpackGetBytesPerSample(wpc);
        }
        {
#line 666
        if (__cil_tmp36 == 1) {
#line 666
          goto case_1;
        }
#line 670
        if (__cil_tmp36 == 2) {
#line 670
          goto case_2;
        }
#line 674
        if (__cil_tmp36 == 3) {
#line 674
          goto case_3;
        }
#line 678
        if (__cil_tmp36 == 4) {
#line 678
          goto case_4;
        }
#line 665
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 667
        float_samples((float *)temp_buffer, temp_buffer, samples_unpacked * (unsigned int )num_channels,
                      (float )(1. / 128.));
        }
#line 668
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 671
        float_samples((float *)temp_buffer, temp_buffer, samples_unpacked * (unsigned int )num_channels,
                      (float )(1. / 32768.));
        }
#line 672
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 675
        float_samples((float *)temp_buffer, temp_buffer, samples_unpacked * (unsigned int )num_channels,
                      (float )(1. / 8388608.));
        }
#line 676
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 679
        float_samples((float *)temp_buffer, temp_buffer, samples_unpacked * (unsigned int )num_channels,
                      (float )(1. / 2147483648.));
        }
#line 680
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 683
      if (num_channels == 1) {
#line 684
        dst = temp_buffer + samples_unpacked * 2U;
#line 685
        src = temp_buffer + samples_unpacked;
#line 686
        cnt = samples_unpacked;
        {
#line 688
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 688
          __cil_tmp40 = cnt;
#line 688
          cnt --;
#line 688
          if (! __cil_tmp40) {
#line 688
            goto while_break___0;
          }
#line 689
          src --;
#line 689
          dst --;
#line 689
          *dst = *src;
#line 690
          dst --;
#line 690
          *dst = *src;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 694
      calc_stereo_peak((float *)temp_buffer, samples_unpacked, peak);
#line 695
      filter_stereo_samples((float *)temp_buffer, samples_unpacked);
#line 696
      __cil_tmp41 = calc_stereo_rms((float *)temp_buffer, samples_unpacked);
#line 696
      __cil_tmp42 = floor((double )100 * __cil_tmp41);
#line 696
      level = (int32_t )__cil_tmp42;
      }
#line 698
      if (level < 0) {
#line 699
        (*(histogram + 0)) ++;
      } else
#line 700
      if (level >= 12000) {
#line 701
        (*(histogram + 11999)) ++;
      } else {
#line 703
        (*(histogram + level)) ++;
      }
    } else {
#line 706
      goto while_break;
    }
    {
#line 708
    __cil_tmp46 = check_break();
    }
#line 708
    if (__cil_tmp46) {
      {
#line 712
      fprintf(stderr, "\n");
#line 714
      fflush(stderr);
#line 715
      result = 2;
      }
#line 716
      goto while_break;
    }
    {
#line 719
    __cil_tmp48 = WavpackGetProgress(wpc);
#line 719
    __cil_tmp49 = floor(__cil_tmp48 * 100. + 0.5);
    }
    {
#line 719
    __cil_tmp47 = WavpackGetProgress(wpc);
    }
#line 719
    if (__cil_tmp47 != - 1.) {
#line 719
      if (progress != __cil_tmp49) {
        {
#line 721
        nobs = progress == - 1.;
#line 723
        progress = WavpackGetProgress(wpc);
#line 724
        display_progress(progress);
#line 725
        progress = floor(progress * 100. + 0.5);
        }
#line 727
        if (! quiet_mode___1) {
#line 728
          if (nobs) {
#line 728
            tmp___2 = " ";
          } else {
#line 728
            tmp___2 = "\b\b\b\b\b\b\b\b\b\b\b\b";
          }
          {
#line 728
          fprintf(stderr, "%s%3d%% done...", tmp___2, (int )progress);
#line 730
          fflush(stderr);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 735
  free(temp_buffer);
  }
#line 737
  if (decimation_context) {
    {
#line 738
    decimation_destroy(decimation_context);
    }
  }
  {
#line 740
  __cil_tmp55 = WavpackGetNumSamples64(wpc);
  }
  {
#line 740
  __cil_tmp54 = WavpackGetNumSamples64(wpc);
  }
#line 740
  if (result == 0) {
#line 740
    if (__cil_tmp54 != -1L) {
#line 740
      if (total_unpacked_samples != __cil_tmp55) {
        {
#line 742
        error_line("incorrect number of samples!");
#line 743
        result = 1;
        }
      }
    }
  }
  {
#line 746
  __cil_tmp56 = WavpackGetNumErrors(wpc);
  }
#line 746
  if (result == 0) {
#line 746
    if (__cil_tmp56) {
      {
#line 747
      __cil_tmp57 = WavpackGetNumErrors(wpc);
#line 747
      error_line("crc errors detected in %d block(s)!", __cil_tmp57);
#line 748
      result = 1;
      }
    }
  }
  {
#line 751
  WavpackCloseFile(wpc);
  }
#line 752
  return (result);
}
}
#line 758 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static int update_file(char *infilename , float track_gain , float track_peak , float album_gain ,
                       float album_peak ) 
{ 
  int write_tag ;
  char error[80] ;
  char value[20] ;
  WavpackContext *wpc ;
  WavpackContext *__cil_tmp10 ;
  int items_removed ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char title[40] ;
  char artist[40] ;
  char album[40] ;
  char year[10] ;
  char comment[40] ;
  char track[10] ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  int tmp ;
  int __cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 760
  write_tag = 0;
#line 769
  wpc = WavpackOpenFileInput((char const   *)infilename, (char *)error, 576, 0);
  }
#line 772
  if (! wpc) {
    {
#line 773
    error_line((char *)error);
    }
#line 774
    return (1);
  }
#line 777
  if (clean_mode) {
    {
#line 778
    items_removed = 0;
#line 780
    __cil_tmp12 = WavpackDeleteTagItem(wpc, "replaygain_track_gain");
    }
#line 780
    if (__cil_tmp12) {
#line 781
      items_removed ++;
    }
    {
#line 783
    __cil_tmp13 = WavpackDeleteTagItem(wpc, "replaygain_track_peakU");
    }
#line 783
    if (__cil_tmp13) {
#line 784
      items_removed ++;
    }
    {
#line 786
    __cil_tmp14 = WavpackDeleteTagItem(wpc, "replaygain_album_gainU");
    }
#line 786
    if (__cil_tmp14) {
#line 787
      items_removed ++;
    }
    {
#line 789
    __cil_tmp15 = WavpackDeleteTagItem(wpc, "replaygain_album_peak");
    }
#line 789
    if (__cil_tmp15) {
#line 790
      items_removed ++;
    }
#line 792
    if (items_removed) {
#line 793
      if (! quiet_mode___1) {
        {
#line 794
        error_line("%d ReplayGain values cleaned", items_removed);
        }
      }
#line 796
      write_tag = 1;
    } else {
      {
#line 799
      error_line("no ReplayGain values found4?dU");
      }
    }
  } else {
    {
#line 802
    __cil_tmp16 = WavpackGetMode(wpc);
    }
#line 802
    if ((__cil_tmp16 & 272) == 16) {
      {
#line 805
      WavpackGetTagItem(wpc, "title", (char *)title, (int )sizeof(title));
#line 806
      WavpackGetTagItem(wpc, "artist", (char *)artist, (int )sizeof(artist));
#line 807
      WavpackGetTagItem(wpc, "album", (char *)album, (int )sizeof(album));
#line 808
      WavpackGetTagItem(wpc, "year", (char *)year, (int )sizeof(year));
#line 809
      WavpackGetTagItem(wpc, "comment", (char *)comment, (int )sizeof(comment));
#line 810
      WavpackGetTagItem(wpc, "track", (char *)track, (int )sizeof(track));
      }
#line 812
      if (title[0]) {
        {
#line 813
        __cil_tmp23 = strlen((char const   *)((char *)title));
#line 813
        WavpackAppendTagItem(wpc, "Title", (char const   *)((char *)title), (int )__cil_tmp23);
        }
      }
#line 815
      if (artist[0]) {
        {
#line 816
        __cil_tmp24 = strlen((char const   *)((char *)artist));
#line 816
        WavpackAppendTagItem(wpc, "Artist", (char const   *)((char *)artist), (int )__cil_tmp24);
        }
      }
#line 818
      if (album[0]) {
        {
#line 819
        __cil_tmp25 = strlen((char const   *)((char *)album));
#line 819
        WavpackAppendTagItem(wpc, "Album", (char const   *)((char *)album), (int )__cil_tmp25);
        }
      }
#line 821
      if (year[0]) {
        {
#line 822
        __cil_tmp26 = strlen((char const   *)((char *)year));
#line 822
        WavpackAppendTagItem(wpc, "Year", (char const   *)((char *)year), (int )__cil_tmp26);
        }
      }
#line 824
      if (comment[0]) {
        {
#line 825
        __cil_tmp27 = strlen((char const   *)((char *)comment));
#line 825
        WavpackAppendTagItem(wpc, "Comment", (char const   *)((char *)comment), (int )__cil_tmp27);
        }
      }
#line 827
      if (track[0]) {
        {
#line 828
        __cil_tmp28 = strlen((char const   *)((char *)track));
#line 828
        WavpackAppendTagItem(wpc, "TrackU", (char const   *)((char *)track), (int )__cil_tmp28);
        }
      }
      {
#line 830
      error_line("warning: ID3v1 tag converted to APEv2");
      }
    }
    {
#line 833
    sprintf((char *)value, "%+.2f dB\230\001", (double )track_gain);
#line 834
    __cil_tmp29 = strlen((char const   *)((char *)value));
#line 834
    WavpackAppendTagItem(wpc, "replaygain_track_gain", (char const   *)((char *)value),
                         (int )__cil_tmp29);
#line 836
    sprintf((char *)value, "%.6f", (double )track_peak);
#line 837
    __cil_tmp30 = strlen((char const   *)((char *)value));
#line 837
    WavpackAppendTagItem(wpc, "replaygain_track_peak", (char const   *)((char *)value),
                         (int )__cil_tmp30);
    }
#line 839
    if (album_mode) {
      {
#line 840
      sprintf((char *)value, "%+.2f dB\230\001", (double )album_gain);
#line 841
      __cil_tmp31 = strlen((char const   *)((char *)value));
#line 841
      WavpackAppendTagItem(wpc, "replaygain_album_gainU", (char const   *)((char *)value),
                           (int )__cil_tmp31);
#line 842
      sprintf((char *)value, "%.6f", (double )album_peak);
#line 843
      __cil_tmp32 = strlen((char const   *)((char *)value));
#line 843
      WavpackAppendTagItem(wpc, "replaygain_album_peakU", (char const   *)((char *)value),
                           (int )__cil_tmp32);
      }
    }
#line 846
    if (! quiet_mode___1) {
#line 847
      if ((int )album_mode) {
#line 847
        tmp = 4;
      } else {
#line 847
        tmp = 2;
      }
      {
#line 847
      error_line("%d ReplayGain values appended", tmp);
      }
    }
#line 849
    write_tag = 1;
  }
  {
#line 852
  __cil_tmp34 = WavpackWriteTag(wpc);
  }
#line 852
  if (write_tag) {
#line 852
    if (! __cil_tmp34) {
      {
#line 853
      __cil_tmp35 = WavpackGetErrorMessage(wpc);
#line 853
      error_line("%s", __cil_tmp35);
      }
#line 854
      return (1);
    }
  }
  {
#line 857
  WavpackCloseFile(wpc);
  }
#line 858
  return (0);
}
}
#line 863 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static int show_file_info(char *infilename , FILE *dst ) 
{ 
  char error[80] ;
  char value[20] ;
  WavpackContext *wpc ;
  int items ;
  WavpackContext *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 867
  items = 0;
#line 874
  wpc = WavpackOpenFileInput((char const   *)infilename, (char *)error, 514, 0);
  }
#line 877
  if (! wpc) {
    {
#line 878
    error_line((char *)error);
    }
#line 879
    return (1);
  }
  {
#line 882
  fprintf(dst, "\nfile: %s\n", infilename);
#line 884
  __cil_tmp8 = WavpackGetTagItem(wpc, "replaygain_track_gain", (char *)value, (int )sizeof(value));
  }
#line 884
  if (__cil_tmp8) {
    {
#line 885
    fprintf(dst, "replaygain_track_gain = %s\n", (char *)value);
#line 886
    items ++;
    }
  }
  {
#line 889
  __cil_tmp9 = WavpackGetTagItem(wpc, "replaygain_track_peak", (char *)value, (int )sizeof(value));
  }
#line 889
  if (__cil_tmp9) {
    {
#line 890
    fprintf(dst, "replaygain_track_peak = %s\n?dU", (char *)value);
#line 891
    items ++;
    }
  }
  {
#line 894
  __cil_tmp10 = WavpackGetTagItem(wpc, "replaygain_album_gainU", (char *)value, (int )sizeof(value));
  }
#line 894
  if (__cil_tmp10) {
    {
#line 895
    fprintf(dst, "replaygain_album_gain = %s\n?dU", (char *)value);
#line 896
    items ++;
    }
  }
  {
#line 899
  __cil_tmp11 = WavpackGetTagItem(wpc, "replaygain_album_peak", (char *)value, (int )sizeof(value));
  }
#line 899
  if (__cil_tmp11) {
    {
#line 900
    fprintf(dst, "replaygain_album_peak = %s\n>dU", (char *)value);
#line 901
    items ++;
    }
  }
#line 904
  if (! items) {
    {
#line 905
    fprintf(dst, "no ReplayGain values found\n?dU");
    }
  }
  {
#line 907
  WavpackCloseFile(wpc);
  }
#line 908
  return (0);
}
}
#line 913 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static float calc_replaygain(uint32_t *histogram ) 
{ 
  uint32_t loud_count ;
  uint32_t total_windows ;
  float unclipped_gain ;
  int i ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 915
  loud_count = (uint32_t )0;
#line 915
  total_windows = (uint32_t )0;
#line 919
  i = 0;
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (i < 12000)) {
#line 919
      goto while_break;
    }
#line 920
    total_windows += *(histogram + i);
#line 919
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 922
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 922
    __cil_tmp7 = i;
#line 922
    i --;
#line 922
    if (! __cil_tmp7) {
#line 922
      goto while_break___0;
    }
#line 923
    loud_count += *(histogram + i);
#line 923
    if (loud_count * 20U >= total_windows) {
#line 924
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 926
  unclipped_gain = (float )(64.5400000001 - (double )i / 100.);
#line 928
  if ((double )unclipped_gain > 64.) {
#line 929
    return ((float )64.);
  } else
#line 930
  if ((double )unclipped_gain < - 24.) {
#line 931
    return ((float )(- 24.));
  } else {
#line 933
    return (unclipped_gain);
  }
}
}
#line 938 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static void float_samples(float *dst , int32_t *src , uint32_t samcnt , float scale ) 
{ 
  uint32_t __cil_tmp5 ;
  float *__cil_tmp6 ;
  int32_t *__cil_tmp7 ;

  {
  {
#line 940
  while (1) {
    while_continue: /* CIL Label */ ;
#line 940
    __cil_tmp5 = samcnt;
#line 940
    samcnt --;
#line 940
    if (! __cil_tmp5) {
#line 940
      goto while_break;
    }
#line 941
    __cil_tmp7 = src;
#line 941
    src ++;
#line 941
    __cil_tmp6 = dst;
#line 941
    dst ++;
#line 941
    *__cil_tmp6 = (float )*__cil_tmp7 * scale;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 956 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static struct rg_freqinfo freqinfos[20]  = 
#line 956
  {      {(uint32_t )48000, {0.0385759943521, - 0.0216036718419, - 0.00123395316852, - 9.291677959e-05,
                         - 0.0165526034162, 0.0216152684328, - 0.0207404521529, 0.00594298065125,
                         0.00306428023191, 0.00012025322027, 0.00288463683917}, {1.,
                                                                                 - 3.84664617119,
                                                                                 7.81501653006,
                                                                                 - 11.3417035514,
                                                                                 13.0550421933,
                                                                                 - 12.2875989515,
                                                                                 9.4829380632,
                                                                                 - 5.87257861776,
                                                                                 2.75465861875,
                                                                                 - 0.869843765936,
                                                                                 0.139193145675},
      {0.986211924628, - 1.97242384926, 0.986211924628}, {1., - 1.9722337292, 0.972613969314}}, 
        {(uint32_t )44100,
      {0.0541865640644, - 0.0291100780895, - 0.00848709379852, - 0.0085116564547,
       - 0.00834990904936, 0.0224529325334, - 0.0259633851292, 0.0162486496298, - 0.00240879051585,
       0.00674613682247, - 0.00187763777363}, {1., - 3.47845948551, 6.36317777567,
                                               - 8.54751527472, 9.47693607802, - 8.81498681371,
                                               6.85401540937, - 4.3947099608, 2.19611684891,
                                               - 0.751043024515, 0.131493179589},
      {0.985001757873, - 1.97000351575, 0.985001757873}, {1., - 1.96977855583, 0.970228475664}}, 
        {(uint32_t )32000,
      {0.15457299682, - 0.0933104905632, - 0.0624788015366, 0.021635418888, - 0.0558839332986,
       0.0478147667493, 0.00222312597744, 0.0317409254005, - 0.013905894219, 0.00651420667831,
       - 0.00881362733839}, {1., - 2.37898834974, 2.84868151157, - 2.6457717023, 2.23697657452,
                             - 1.67148153368, 1.00595954809, - 0.45953458055, 0.163781648586,
                             - 0.0503207771714, 0.0234789740702}, {0.979389327353,
                                                                   - 1.95877865471,
                                                                   0.979389327353},
      {1., - 1.95835380976, 0.959203499655}}, 
        {(uint32_t )24000, {0.302969073194, - 0.226139886822, - 0.0858732373078, 0.0328293017267,
                         - 0.00915702933435, - 0.0236414120253, - 0.00584456039914,
                         0.0627610132175, - 8.28086748001e-06, 0.00205861885565, - 0.0295013498329},
      {1., - 1.61273165138, 1.0797749226, - 0.256562577541, - 0.162767191205, - 0.22638893774,
       0.391208007883, - 0.22138138955, 0.0450023538736, 0.0200585180651, 0.00302439095741},
      {0.97531843205, - 1.9506368641, 0.97531843205}, {1., - 1.9500275915, 0.951246136699}}, 
        {(uint32_t )22050,
      {0.336423048562, - 0.255722414256, - 0.118285701776, 0.119211486753, - 0.0783448960948,
       - 0.0046997791438, - 0.00589500224441, 0.0572422814036, 0.00832043980773, - 0.0163538138454,
       - 0.0176017656816}, {1., - 1.49858979368, 0.873502714182, 0.122050223081, - 0.807749446715,
                            0.478547945624, - 0.124534581401, - 0.0406751019702, 0.0833375528411,
                            - 0.0423734802575, 0.0297720731993}, {0.973165234982,
                                                                  - 1.94633046997,
                                                                  0.973165234982},
      {1., - 1.94561023567, 0.947050704262}}, 
        {(uint32_t )16000, {0.449152566085, - 0.143517574646, - 0.227843944298, - 0.0141914010056,
                         0.0407826279714, - 0.123981633818, 0.0409756513565, 0.104785036003,
                         - 0.0186388781093, - 0.0319342843892, 0.00541907748708},
      {1., - 0.628206192337, 0.296617837064, - 0.372563729425, 0.00213767857124, - 0.42029820171,
       0.221996505649, 0.00613424350683, 0.0674762074469, 0.0578482037581, 0.0322275407218},
      {0.964545155529, - 1.92909031106, 0.964545155529}, {1., - 1.92783286978, 0.930347752343}}, 
        {(uint32_t )12000,
      {0.566194707577, - 0.754644569394, 0.162421377423, 0.167442434937, - 0.189016041997,
       0.309317828419, - 0.275629619863, 0.00647310677246, 0.0864750378036, - 0.0378898455484,
       - 0.00588215443422}, {1., - 1.04800335127, 0.291563119713, - 0.26806001043,
                             0.00819999645858, 0.450547345051, - 0.330324033141, 0.0673936833312,
                             - 0.0478425422904, 0.0163990783619, 0.0180736432358},
      {0.960091429506, - 1.92018285902, 0.960091429506}, {1., - 1.91858953034, 0.921776187684}}, 
        {(uint32_t )11025,
      {0.581004949606, - 0.531749090586, - 0.142897990343, 0.175207048356, 0.0237794521762,
       0.155584491356, - 0.253447900594, 0.0162846240634, 0.0692046776396, - 0.0372161139581,
       - 0.00749618797173}, {1., - 0.510353270952, - 0.318635633253, - 0.202564134845,
                             0.147281541344, 0.38952639979, - 0.233132718809, - 0.0524601902447,
                             - 0.0250596172406, 0.024423573161, 0.0181880111151},
      {0.958569165997, - 1.917138332, 0.958569165997}, {1., - 1.91542108075, 0.918855583237}}, 
        {(uint32_t )8000,
      {0.536487892552, - 0.421630343507, - 0.0027595361193, 0.0426784221942, - 0.102148641797,
       0.145907722894, - 0.0245986485935, - 0.112023151954, - 0.04060034127, 0.0478866554819,
       - 0.0221793680114}, {1., - 0.250498719561, - 0.431939423112, - 0.0342468101768,
                            - 0.0467832878425, 0.26408300201, 0.151131305333, - 0.175564933665,
                            - 0.188230092622, 0.0547772042868, 0.0470440968813}, {0.945976856003,
                                                                                  - 1.89195371201,
                                                                                  0.945976856003},
      {1., - 1.8890330794, 0.894874344617}}, 
        {(uint32_t )18900, {0.385245310152, - 0.276822120621, - 0.0998018148881, 0.0995148675565,
                         - 0.0893402015663, - 0.00322369330199, - 0.00110329090689,
                         0.0378450984469, 0.0168390621331, - 0.0114703986258, - 0.019417679872},
      {1., - 1.29708918405, 0.903993396743, - 0.296137990179, - 0.423266459163, 0.379348874023,
       - 0.37919795945, 0.234102832848, - 0.0389297175888, 0.00403009552352, 0.0364016662628},
      {0.965353268159, - 1.93070653632, 0.965353268159}, {1., - 1.92950577984, 0.931907292798}}, 
        {(uint32_t )37800,
      {0.0871787997785, - 0.0100037401618, - 0.0626585212237, - 0.0111932880096, - 0.00114279372961,
       0.0208133395477, - 0.0160326186321, 0.0193676302855, 0.00760044736443, - 0.00303979112272,
       - 0.000750886057881}, {1., - 2.62816311473, 3.53734535818, - 3.81003448679,
                              3.91291636731, - 3.53518605897, 2.71356866158, - 1.86723311847,
                              1.12075382368, - 0.485740868869, 0.113305446639}, {0.982524008152,
                                                                                 - 1.96504801631,
                                                                                 0.982524008152},
      {1., - 1.9647425827, 0.965353449918}}, 
        {(uint32_t )56000, {0.0314491473409, - 0.0615172920697, 0.0806678870815, - 0.0973793992152,
                         0.08943210804, - 0.0698998467201, 0.0492697284105, - 0.0316125784846,
                         0.0145683749351, - 0.00316015108496, 0.00132807215875}, {1.,
                                                                                  - 4.87377313091,
                                                                                  12.0392216015,
                                                                                  - 20.1015111839,
                                                                                  25.1038853442,
                                                                                  - 24.2906556082,
                                                                                  18.271584691,
                                                                                  - 10.4524955257,
                                                                                  4.30319491873,
                                                                                  - 1.13716992071,
                                                                                  0.145107335271},
      {0.988169950074, - 1.97633990015, 0.988169950074}, {1., - 1.97619994517, 0.976479855126}}, 
        {(uint32_t )64000,
      {0.0261305656818, - 0.0812878648811, 0.149372823474, - 0.216957116752, 0.250102866735,
       - 0.231622836193, 0.174240418331, - 0.102995992167, 0.0425869648199, - 0.00977952936493,
       0.0010532555889}, {1., - 5.73625477093, 16.1524979436, - 29.6865491247, 39.5570615568,
                          - 39.8252455625, 30.5060534502, - 17.4305177283, 7.05154573909,
                          - 1.80783839721, 0.221278402109}, {0.989641019335, - 1.97928203867,
                                                             0.989641019335}, {1.,
                                                                               - 1.97917472732,
                                                                               0.979389350029}}, 
        {(uint32_t )88200,
      {0.0266748204742, - 0.113774793361, 0.23063167911, - 0.307264779456, 0.331885206866,
       - 0.338626802491, 0.318071615314, - 0.237307969299, 0.122738947904, - 0.0384001796729,
       0.00549673387936}, {1., - 6.31836451658, 18.3135131081, - 31.8821001482, 36.5379214698,
                           - 28.2339303647, 14.2472525823, - 4.04670980013, 0.188657572806,
                           0.25420333564, - 0.0601233353107}, {0.992472550462, - 1.98494510093,
                                                               0.992472550462}, {1.,
                                                                                 - 1.98488843763,
                                                                                 0.985001764222}}, 
        {(uint32_t )96000,
      {0.00588138296683, - 0.0161355973043, 0.0218479895422, - 0.0174249040532, 0.00464635643781,
       0.0111777251321, - 0.0212386582437, 0.0195935441336, - 0.0107972064353, 0.00352183686289,
       - 0.000631243414211}, {1., - 5.97808823643, 16.2136250797, - 25.7292373066,
                              25.4047066314, - 14.6616628778, 2.8159748436, 2.5144712597,
                              - 2.23575306986, 0.757881510368, - 0.100780251991},
      {0.993082035176, - 1.98616407036, 0.993082035176}, {1., - 1.98611621155, 0.986211929161}}, 
        {(uint32_t )112000,
      {0.00528778718259, - 0.0189324090725, 0.0318598256187, - 0.0292626029784, 0.00715743034073,
       0.0198574335583, - 0.0322261485095, 0.025656819782, - 0.0121066231348, 0.00325436284542,
       - 0.000441735930011}, {1., - 6.24932108457, 17.4234432054, - 27.8681970906,
                              26.7908734469, - 13.4371108149, - 0.660236129482, 6.03658091815,
                              - 4.24926577031, 1.4082926871, - 0.194808526282}, {0.994067378109,
                                                                                 - 1.98813475622,
                                                                                 0.994067378109},
      {1., - 1.98809955991, 0.98816995253}}, 
        {(uint32_t )128000, {0.00553120584305, - 0.0211262054502, 0.0354907624312, - 0.0336249831231,
                          0.0142586724819, 0.0134468692879, - 0.0339277078784, 0.0346413645953,
                          - 0.0203911605155, 0.00667420794705, - 0.00093763762995},
      {1., - 6.1458171084, 16.0478590368, - 22.1908913141, 15.2475647159, - 0.520014404003,
       - 8.004886417, 6.60916094769, - 2.37856022811, 0.331069479862, 0.00459820832037},
      {0.994807026813, - 1.98961405363, 0.994807026813}, {1., - 1.98958708648, 0.989641020778}}, 
        {(uint32_t )144000,
      {0.0063968235945, - 0.0255643797096, 0.0423085440094, - 0.0372246220127, 0.017185148273,
       0.00610592243009, - 0.0306596574737, 0.0434574500354, - 0.0329859268131, 0.0132093723681,
       - 0.00220304127758}, {1., - 6.14814623524, 15.8000245715, - 20.7848758769,
                             11.9884855232, 3.36462015063, - 10.2241986836, 6.65599702147,
                             - 1.67141861111, - 0.0541795653672, 0.0737476786741},
      {0.995382689588, - 1.99076537918, 0.995382689588}, {1., - 1.99074405951, 0.990786698844}}, 
        {(uint32_t )176400,
      {0.00268568524529, - 0.00852379426081, 0.00852704191348, 0.00146116310296, - 0.00950855828762,
       0.00625449515499, 0.00116183868722, - 0.00362461417136, 0.00203961000135, - 0.00050664587933,
       4.32745542701e-05}, {1., - 5.57512782764, 12.4429105607, - 12.8746279969, 3.08554846962,
                            6.62493459881, - 7.07662766314, 2.51175542737, 0.0673151080274,
                            - 0.245677538193, 0.0396140416238}, {0.996229165812, - 1.99245833163,
                                                                 0.996229165812},
      {1., - 1.99244411239, 0.992472550864}}, 
        {(uint32_t )192000, {0.0118474212313, - 0.0463109240009, 0.0658422696124, - 0.0216558852248,
                          - 0.0565626077896, 0.0860749359277, - 0.0337554433979, - 0.0421657993276,
                          0.0641671149065, - 0.0344470826085, 0.00697275872241}, {1.,
                                                                                  - 5.24727318349,
                                                                                  10.608215852,
                                                                                  - 8.74127665811,
                                                                                  - 1.33906071372,
                                                                                  8.07972882097,
                                                                                  - 5.46179918951,
                                                                                  0.543180706526,
                                                                                  0.874509692243,
                                                                                  - 0.346560835398,
                                                                                  0.0303479684359},
      {0.996535014652, - 1.99307002931, 0.996535014652}, {1., - 1.99305802315, 0.993082035463}}};
#line 1119
static double *yule_coeff_a ;
#line 1119
static double *yule_coeff_b ;
#line 1119
static double *butter_coeff_a ;
#line 1119
static double *butter_coeff_b ;
#line 1120
static float yule_hist_a[256] ;
#line 1120
static float yule_hist_b[256] ;
#line 1120
static float butter_hist_a[256] ;
#line 1120
static float butter_hist_b[256] ;
#line 1121
static int yule_hist_i ;
#line 1121
static int butter_hist_i ;
#line 1125 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static int filter_init(uint32_t sample_rate ) 
{ 
  int i ;
  int n ;

  {
#line 1127
  n = (int )(sizeof(freqinfos) / sizeof(freqinfos[0]));
#line 1129
  i = 0;
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    if (! (i < n)) {
#line 1129
      goto while_break;
    }
#line 1130
    if (freqinfos[i].rate == sample_rate) {
#line 1131
      goto while_break;
    }
#line 1129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1133
  if (i == n) {
    {
#line 1134
    error_line("sample rate of %d is not supported!", sample_rate);
    }
#line 1135
    return (0);
  }
  {
#line 1138
  yule_coeff_a = (double *)freqinfos[i].AYule;
#line 1139
  yule_coeff_b = (double *)freqinfos[i].BYule;
#line 1140
  butter_coeff_a = (double *)freqinfos[i].AButter;
#line 1141
  butter_coeff_b = (double *)freqinfos[i].BButter;
#line 1143
  memset((float *)yule_hist_a, 0, sizeof(yule_hist_a));
#line 1144
  memset((float *)yule_hist_b, 0, sizeof(yule_hist_b));
#line 1145
  yule_hist_i = 20;
#line 1147
  memset((float *)butter_hist_a, 0, sizeof(butter_hist_a));
#line 1148
  memset((float *)butter_hist_b, 0, sizeof(butter_hist_b));
#line 1149
  butter_hist_i = 4;
  }
#line 1150
  return (1);
}
}
#line 1155 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static void butter_filter_stereo_samples(float *samples , uint32_t samcnt ) 
{ 
  double left ;
  double right ;
  int i ;
  int j ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  uint32_t __cil_tmp9 ;

  {
#line 1160
  i = butter_hist_i;
#line 1165
  j = - 4;
  {
#line 1165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1165
    if (! (j < 0)) {
#line 1165
      goto while_break;
    }
    {
#line 1166
    __cil_tmp8 = fabs((double )butter_hist_b[i + j]);
    }
    {
#line 1166
    __cil_tmp7 = fabs((double )butter_hist_a[i + j]);
    }
#line 1166
    if (__cil_tmp7 > 1.00000000001e-10) {
#line 1167
      goto while_break;
    } else
#line 1166
    if (__cil_tmp8 > 1.00000000001e-10) {
#line 1167
      goto while_break;
    }
#line 1165
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1169
  if (! j) {
    {
#line 1170
    memset((float *)butter_hist_a, 0, sizeof(butter_hist_a));
#line 1171
    memset((float *)butter_hist_b, 0, sizeof(butter_hist_b));
    }
  }
  {
#line 1174
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1174
    __cil_tmp9 = samcnt;
#line 1174
    samcnt --;
#line 1174
    if (! __cil_tmp9) {
#line 1174
      goto while_break___0;
    }
#line 1175
    butter_hist_b[i] = *(samples + 0);
#line 1175
    left = (double )butter_hist_b[i] * *(butter_coeff_b + 0);
#line 1176
    butter_hist_b[i + 1] = *(samples + 1);
#line 1176
    right = (double )butter_hist_b[i + 1] * *(butter_coeff_b + 0);
#line 1177
    left += (double )butter_hist_b[i - 2] * *(butter_coeff_b + 1) - (double )butter_hist_a[i - 2] * *(butter_coeff_a + 1);
#line 1178
    right += (double )butter_hist_b[i - 1] * *(butter_coeff_b + 1) - (double )butter_hist_a[i - 1] * *(butter_coeff_a + 1);
#line 1179
    left += (double )butter_hist_b[i - 4] * *(butter_coeff_b + 2) - (double )butter_hist_a[i - 4] * *(butter_coeff_a + 2);
#line 1180
    right += (double )butter_hist_b[i - 3] * *(butter_coeff_b + 2) - (double )butter_hist_a[i - 3] * *(butter_coeff_a + 2);
#line 1181
    butter_hist_a[i] = (float )left;
#line 1181
    *(samples + 0) = butter_hist_a[i];
#line 1182
    butter_hist_a[i + 1] = (float )right;
#line 1182
    *(samples + 1) = butter_hist_a[i + 1];
#line 1183
    samples += 2;
#line 1185
    i += 2;
#line 1185
    if (i == 256) {
      {
#line 1186
      memcpy((float *)butter_hist_a, (float *)butter_hist_a + 252, sizeof(butter_hist_a[0]) * 4UL);
#line 1187
      memcpy((float *)butter_hist_b, (float *)butter_hist_b + 252, sizeof(butter_hist_b[0]) * 4UL);
#line 1188
      i = 4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1192
  butter_hist_i = i;
  return;
}
}
#line 1197 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static void yule_filter_stereo_samples(float *samples , uint32_t samcnt ) 
{ 
  double left ;
  double right ;
  int i ;
  int j ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  uint32_t __cil_tmp9 ;

  {
#line 1202
  i = yule_hist_i;
#line 1207
  j = - 20;
  {
#line 1207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1207
    if (! (j < 0)) {
#line 1207
      goto while_break;
    }
    {
#line 1208
    __cil_tmp8 = fabs((double )yule_hist_b[i + j]);
    }
    {
#line 1208
    __cil_tmp7 = fabs((double )yule_hist_a[i + j]);
    }
#line 1208
    if (__cil_tmp7 > 1.00000000001e-10) {
#line 1209
      goto while_break;
    } else
#line 1208
    if (__cil_tmp8 > 1.00000000001e-10) {
#line 1209
      goto while_break;
    }
#line 1207
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1211
  if (! j) {
    {
#line 1212
    memset((float *)yule_hist_a, 0, sizeof(yule_hist_a));
#line 1213
    memset((float *)yule_hist_b, 0, sizeof(yule_hist_b));
    }
  }
  {
#line 1216
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1216
    __cil_tmp9 = samcnt;
#line 1216
    samcnt --;
#line 1216
    if (! __cil_tmp9) {
#line 1216
      goto while_break___0;
    }
#line 1217
    yule_hist_b[i] = *(samples + 0);
#line 1217
    left = (double )yule_hist_b[i] * *(yule_coeff_b + 0);
#line 1218
    yule_hist_b[i + 1] = *(samples + 1);
#line 1218
    right = (double )yule_hist_b[i + 1] * *(yule_coeff_b + 0);
#line 1219
    left += (double )yule_hist_b[i - 2] * *(yule_coeff_b + 1) - (double )yule_hist_a[i - 2] * *(yule_coeff_a + 1);
#line 1220
    right += (double )yule_hist_b[i - 1] * *(yule_coeff_b + 1) - (double )yule_hist_a[i - 1] * *(yule_coeff_a + 1);
#line 1221
    left += (double )yule_hist_b[i - 4] * *(yule_coeff_b + 2) - (double )yule_hist_a[i - 4] * *(yule_coeff_a + 2);
#line 1222
    right += (double )yule_hist_b[i - 3] * *(yule_coeff_b + 2) - (double )yule_hist_a[i - 3] * *(yule_coeff_a + 2);
#line 1223
    left += (double )yule_hist_b[i - 6] * *(yule_coeff_b + 3) - (double )yule_hist_a[i - 6] * *(yule_coeff_a + 3);
#line 1224
    right += (double )yule_hist_b[i - 5] * *(yule_coeff_b + 3) - (double )yule_hist_a[i - 5] * *(yule_coeff_a + 3);
#line 1225
    left += (double )yule_hist_b[i - 8] * *(yule_coeff_b + 4) - (double )yule_hist_a[i - 8] * *(yule_coeff_a + 4);
#line 1226
    right += (double )yule_hist_b[i - 7] * *(yule_coeff_b + 4) - (double )yule_hist_a[i - 7] * *(yule_coeff_a + 4);
#line 1227
    left += (double )yule_hist_b[i - 10] * *(yule_coeff_b + 5) - (double )yule_hist_a[i - 10] * *(yule_coeff_a + 5);
#line 1228
    right += (double )yule_hist_b[i - 9] * *(yule_coeff_b + 5) - (double )yule_hist_a[i - 9] * *(yule_coeff_a + 5);
#line 1229
    left += (double )yule_hist_b[i - 12] * *(yule_coeff_b + 6) - (double )yule_hist_a[i - 12] * *(yule_coeff_a + 6);
#line 1230
    right += (double )yule_hist_b[i - 11] * *(yule_coeff_b + 6) - (double )yule_hist_a[i - 11] * *(yule_coeff_a + 6);
#line 1231
    left += (double )yule_hist_b[i - 14] * *(yule_coeff_b + 7) - (double )yule_hist_a[i - 14] * *(yule_coeff_a + 7);
#line 1232
    right += (double )yule_hist_b[i - 13] * *(yule_coeff_b + 7) - (double )yule_hist_a[i - 13] * *(yule_coeff_a + 7);
#line 1233
    left += (double )yule_hist_b[i - 16] * *(yule_coeff_b + 8) - (double )yule_hist_a[i - 16] * *(yule_coeff_a + 8);
#line 1234
    right += (double )yule_hist_b[i - 15] * *(yule_coeff_b + 8) - (double )yule_hist_a[i - 15] * *(yule_coeff_a + 8);
#line 1235
    left += (double )yule_hist_b[i - 18] * *(yule_coeff_b + 9) - (double )yule_hist_a[i - 18] * *(yule_coeff_a + 9);
#line 1236
    right += (double )yule_hist_b[i - 17] * *(yule_coeff_b + 9) - (double )yule_hist_a[i - 17] * *(yule_coeff_a + 9);
#line 1237
    left += (double )yule_hist_b[i - 20] * *(yule_coeff_b + 10) - (double )yule_hist_a[i - 20] * *(yule_coeff_a + 10);
#line 1238
    right += (double )yule_hist_b[i - 19] * *(yule_coeff_b + 10) - (double )yule_hist_a[i - 19] * *(yule_coeff_a + 10);
#line 1239
    yule_hist_a[i] = (float )left;
#line 1239
    *(samples + 0) = yule_hist_a[i];
#line 1240
    yule_hist_a[i + 1] = (float )right;
#line 1240
    *(samples + 1) = yule_hist_a[i + 1];
#line 1241
    samples += 2;
#line 1243
    i += 2;
#line 1243
    if (i == 256) {
      {
#line 1244
      memcpy((float *)yule_hist_a, (float *)yule_hist_a + 236, sizeof(yule_hist_a[0]) * 20UL);
#line 1245
      memcpy((float *)yule_hist_b, (float *)yule_hist_b + 236, sizeof(yule_hist_b[0]) * 20UL);
#line 1246
      i = 20;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1250
  yule_hist_i = i;
  return;
}
}
#line 1255 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static void filter_stereo_samples(float *samples , uint32_t samcnt ) 
{ 


  {
  {
#line 1257
  yule_filter_stereo_samples(samples, samcnt);
#line 1258
  butter_filter_stereo_samples(samples, samcnt);
  }
  return;
}
}
#line 1263 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static void calc_stereo_peak(float *samples , uint32_t samcnt , float *peak_p ) 
{ 
  float peak ;
  uint32_t __cil_tmp5 ;

  {
#line 1265
  peak = (float )0.;
  {
#line 1267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1267
    __cil_tmp5 = samcnt;
#line 1267
    samcnt --;
#line 1267
    if (! __cil_tmp5) {
#line 1267
      goto while_break;
    }
#line 1268
    if (*(samples + 0) > peak) {
#line 1269
      peak = *(samples + 0);
    } else
#line 1270
    if (- *(samples + 0) > peak) {
#line 1271
      peak = - *(samples + 0);
    }
#line 1273
    if (*(samples + 1) > peak) {
#line 1274
      peak = *(samples + 1);
    } else
#line 1275
    if (- *(samples + 1) > peak) {
#line 1276
      peak = - *(samples + 1);
    }
#line 1278
    samples += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1281
  if (peak > *peak_p) {
#line 1282
    *peak_p = peak;
  }
  return;
}
}
#line 1288 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static double calc_stereo_rms(float *samples , uint32_t samcnt ) 
{ 
  uint32_t cnt ;
  double sum ;
  uint32_t __cil_tmp5 ;
  double __cil_tmp6 ;

  {
#line 1290
  cnt = samcnt;
#line 1291
  sum = 1e-16;
  {
#line 1293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1293
    __cil_tmp5 = cnt;
#line 1293
    cnt --;
#line 1293
    if (! __cil_tmp5) {
#line 1293
      goto while_break;
    }
#line 1294
    sum += (double )(*(samples + 0) * *(samples + 0) + *(samples + 1) * *(samples + 1));
#line 1295
    samples += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1298
  __cil_tmp6 = log10(sum / (double )samcnt);
  }
#line 1298
  return (((double )10 * __cil_tmp6 + 90.) - 3.);
}
}
#line 1307 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static int32_t filter[80]  = 
#line 1307
  {      50,      464,      968,      711, 
        - 1203,      - 5028,      - 9818,      - 13376, 
        - 12870,      - 6021,      7526,      25238, 
        41688,      49778,      43050,      18447, 
        - 21428,      - 67553,      - 105876,      - 120890, 
        - 100640,      - 41752,      47201,      145510, 
        224022,      252377,      208224,      86014, 
        - 97312,      - 301919,      - 470919,      - 541796, 
        - 461126,      - 199113,      239795,      813326, 
        1446343,      2043793,      2509064,      2763659, 
        2763659,      2509064,      2043793,      1446343, 
        813326,      239795,      - 199113,      - 461126, 
        - 541796,      - 470919,      - 301919,      - 97312, 
        86014,      208224,      252377,      224022, 
        145510,      47201,      - 41752,      - 100640, 
        - 120890,      - 105876,      - 67553,      - 21428, 
        18447,      43050,      49778,      41688, 
        25238,      7526,      - 6021,      - 12870, 
        - 13376,      - 9818,      - 5028,      - 1203, 
        711,      968,      464,      50};
#line 1326 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static void *decimation_init(int num_channels , int ratio ) 
{ 
  ChanState *sp ;
  void *__cil_tmp4 ;
  int i ;

  {
  {
#line 1328
  __cil_tmp4 = malloc(sizeof(ChanState ) * (unsigned long )num_channels);
#line 1328
  sp = __cil_tmp4;
  }
#line 1331
  if (sp) {
    {
#line 1332
    memset(sp, 0, sizeof(ChanState ) * (unsigned long )num_channels);
#line 1334
    i = 0;
    }
    {
#line 1334
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1334
      if (! (i < num_channels)) {
#line 1334
        goto while_break;
      }
#line 1335
      (sp + i)->num_channels = num_channels;
#line 1336
      (sp + i)->index = (int )(sizeof(filter) / sizeof(filter[0])) - ratio;
#line 1337
      (sp + i)->ratio = ratio;
#line 1334
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1341
  return (sp);
}
}
#line 1344 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static int decimation_run(void *context , int32_t *samples , int num_samples ) 
{ 
  int32_t *in_samples ;
  int32_t *out_samples ;
  ChanState *sp ;
  int num_channels ;
  int ratio ;
  int chan ;
  int __cil_tmp10 ;
  int32_t *__cil_tmp11 ;
  int64_t sum ;
  int i ;
  int32_t *__cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 1346
  in_samples = samples;
#line 1346
  out_samples = samples;
#line 1347
  sp = (ChanState *)context;
#line 1350
  if (! sp) {
#line 1351
    return (0);
  }
#line 1353
  num_channels = sp->num_channels;
#line 1354
  ratio = sp->ratio;
#line 1355
  chan = 0;
  {
#line 1357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1357
    if (! num_samples) {
#line 1357
      goto while_break;
    }
#line 1358
    sp = (ChanState *)context + chan;
#line 1360
    __cil_tmp11 = in_samples;
#line 1360
    in_samples ++;
#line 1360
    __cil_tmp10 = sp->index;
#line 1360
    (sp->index) ++;
#line 1360
    sp->delay[__cil_tmp10] = *__cil_tmp11;
#line 1362
    if (sp->index == (int )(sizeof(filter) / sizeof(filter[0]))) {
#line 1363
      sum = (int64_t )0;
#line 1366
      i = 0;
      {
#line 1366
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1366
        if (! (i < (int )(sizeof(filter) / sizeof(filter[0])))) {
#line 1366
          goto while_break___0;
        }
#line 1367
        sum += (int64_t )filter[i] * (long )sp->delay[i];
#line 1366
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1369
      __cil_tmp14 = out_samples;
#line 1369
      out_samples ++;
#line 1369
      *__cil_tmp14 = (int32_t )(sum >> 24);
#line 1370
      memmove((int *)sp->delay, (int *)sp->delay + ratio, sizeof(sp->delay[0]) * (unsigned long )((int )(sizeof(filter) / sizeof(filter[0])) - ratio));
#line 1371
      sp->index = (int )(sizeof(filter) / sizeof(filter[0])) - ratio;
      }
    }
#line 1374
    chan ++;
#line 1374
    if (chan == num_channels) {
#line 1375
      __cil_tmp15 = num_samples;
#line 1375
      num_samples --;
#line 1376
      chan = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1380
  return ((int )(out_samples - samples) / num_channels);
}
}
#line 1383 "/doner/wavpack/wavpack-5.1.0/cli/wvgain.c"
static void *decimation_destroy(void *context ) 
{ 


  {
#line 1385
  if (context) {
    {
#line 1386
    free(context);
    }
  }
#line 1388
  return ((void *)0);
}
}
#line 302 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
static int waiting_input___1 ;
#line 580
static int break_flag___1 ;
#line 582 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
static void int_handler___1(int s ) 
{ 


  {
#line 584
  break_flag___1 = 1;
  return;
}
}
#line 66 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static char const   *sign_on___2  =    "\n WAVPACK  Hybrid Lossless Audio Compressor  %s Version %s\n Copyright (c) 1998 - 2017 David Bryant.  All Rights Reserved.\n\n";
#line 70 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static char const   *version_warning___2  =    "\n WARNING: WAVPACK using libwavpack version %s, expected %s (see README)\n\n";
#line 73 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static char const   *usage___1  =    " Usage:   WAVPACK [-options] infile[.wav]|infile.ext|- [...] [-o outfile[.wv]|outpath|-]\n             (default is lossless; multiple input files allowed)\n\n Formats: .wav (default, bwf/rf64 okay)  .wv (transcode, with tags)\n          .w64 (Sony Wave64)             .caf (Core Audio Format)\n          .dff (Philips DSDIFF)          .dsf (Sony DSD stream)\n\n Options: -bn = enable hybrid compression, n = 2.0 to 23.9 bits/sample, or\n                                           n = 24-9600 kbits/second (kbps)\n          -c  = create correction file (.wvc) for hybrid mode (=lossless)\n          -f  = fast mode (fast, but some compromise in compression ratio)\n          -h  = high quality (better compression ratio, but slower)\n          -v  = verify output file integrity after write (no pipes)\n          -x  = extra encode processing (no decoding speed penalty)\n          --help = complete help\n\n Web:     Visit www.wavpack.com for latest version and info\n";
#line 94 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static char const   *help___0  =    " Usage:\n    WAVPACK [-options] infile[.wav]|infile.ext|- [...] [-o outfile[.wv]|outpath|-]\n\n    The default operation is lossless. Multiple input files may be specified\n    and the source file type is automatically determined (see accepted formats\n    below). Raw PCM data may also be used (see --raw-pcm option).\n\n Input Formats:             .wav (default, includes bwf/rf64 varients)\n                            .wv  (transcode operation, tags copied)\n                            .caf (Core Audio Format)\n                            .w64 (Sony Wave64)\n                            .dff (Philips DSDIFF)\n                            .dsf (Sony DSD stream)\n\n Options:\n    -a                      Adobe Audition (CoolEdit) mode for 32-bit floats\n    --allow-huge-tags       allow tag data up to 16 MB (embedding > 1 MB is not\n                             recommended for portable devices and may not work\n                             with some programs including WavPack pre-4.70)\n    -bn                     enable hybrid compression\n                              n = 2.0 to 23.9 bits/sample, or\n                              n = 24-9600 kbits/second (kbps)\n                              add -c to create correction file (.wvc)\n    --blocksize=n           specify block size in samples (max = 131072 and\n                               min = 16 with --merge-blocks, otherwise 128)\n    -c                      hybrid lossless mode (use with -b to create\n                             correction file (.wvc) in hybrid mode)\n    -cc                     maximum hybrid lossless compression (but degrades\n                             decode speed and may result in lower quality)\n    --channel-order=<list>  specify (comma separated) channel order if not\n                             Microsoft standard (which is FL,FR,FC,LFE,BL,BR,\n                             FLC,FRC,BC,SL,SR,TC,TFL,TFC,TFR,TBL,TBC,TBR);\n                             specify \'...\' to indicate that channels are not\n                             assigned to specific speakers, or terminate list\n                             with \'...\' to indicate that any channels beyond\n                             those specified are unassigned\n    --cross-decorr          use cross-channel correlation in hybrid mode (on by\n                             default in lossless mode and with -cc option)\n    -d                      delete source file if successful (use with caution!)\n    -f                      fast mode (faster encode and decode, but some\n                             compromise in compression ratio)\n    -h                      high quality (better compression ratio, but slower\n                             encode and decode than default mode)\n    -hh                     very high quality (best compression, but slowest\n                             and NOT recommended for portable hardware use)\n    --help                  this extended help display\n    -i                      ignore length in file header (no pipe output allowed)\n    --import-id3            import ID3v2 tags from the trailer of DSF files only\n    -jn                     joint-stereo override (0 = left/right, 1 = mid/side)\n    -m                      compute & store MD5 signature of raw audio data\n    --merge-blocks          merge consecutive blocks with equal redundancy\n                             (used with --blocksize option and is useful for\n                             files generated by the lossyWAV program or\n                             decoded HDCD files)\n    -n                      calculate average and peak quantization noise\n                             (for hybrid mode only, reference fullscale sine)\n    --no-utf8-convert       don\'t recode passed tags from local encoding to\n                             UTF-8, assume they are in UTF-8 already\n    -o FILENAME | PATH      specify output filename or path\n    --pair-unassigned-chans encode unassigned channels into stereo pairs\n    --pre-quantize=bits     pre-quantize samples to <bits> BEFORE encoding and MD5\n                             (common use would be --pre-quantize=20 for 24-bit or\n                             float material recorded with typical converters)\n    -q                      quiet (keep console output to a minimum)\n    -r                      remove file headers (file-appropriate headers\n                             will be regenerated during unpacking)\n    --raw-pcm               input data is raw pcm (default is 44100 Hz, 16-bit\n                             signed, 2-channels, little-endian)\n    --raw-pcm=sr,bps[f|s|u],nch,[le|be]\n                            input data is raw pcm with specified sample rate,\n                             sample bit depth (float or signed or unsigned), number\n                             of channels, and little-endian or big-endian\n                             (defaulted parameters may be omitted)\n    --raw-pcm-skip=begin[,end]\n                            skip <begin> bytes before encoding (i.e., a header)\n                             and <end> bytes at the end-of-file (i.e., a trailer)\n    -sn                     override default noise shaping where n is a float\n                             value between -1.0 and 1.0; negative values move noise\n                             lower in freq, positive values move noise higher\n                             in freq, use \'0\' for no shaping (white noise)\n    -t                      copy input file\'s time stamp to output file(s)\n    --use-dns               force use of dynamic noise shaping (hybrid mode only)\n    -v                      verify output file integrity after write (no pipes)\n    --version               write the version to stdout\n    -w Encoder              write actual \"Encoder\" information to APEv2 tag\n    -w Settings             write actual \"Settings\" information to APEv2 tag\n    -w \"Field=Value\"        write specified text metadata to APEv2 tag\n    -w \"Field=@file.ext\"    write specified text metadata from file to APEv2\n                             tag, normally used for embedded cuesheets and logs\n                             (field names \"Cuesheet\" and \"Log\")\n    --write-binary-tag \"Field=@file.ext\"\n                            write the specified binary metadata file to APEv2\n                             tag, normally used for cover art with the specified\n                             field name \"Cover Art (Front)\"\n    -x[n]                   extra encode processing (optional n = 1 to 6, 1=default)\n                             -x1 to -x3 to choose best of predefined filters\n                             -x4 to -x6 to generate custom filters (very slow!)\n    -y                      yes to all warnings (use with caution!)\n    -z1                     set console title to indicate progress\n\n Web:\n     Visit www.wavpack.com for latest version and complete information\n";
#line 217 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static char const   *speakers___0[18]  = 
#line 217
  {      "FL",      "FR",      "FC",      "LFE", 
        "BL",      "BR",      "FLC",      "FRC", 
        "BC",      "SL",      "SR",      "TC", 
        "TFL",      "TFC",      "TFR",      "TBL", 
        "TBC",      "TBR"};
#line 235 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static struct __anonstruct_272 file_formats___0[6]  = {      {(unsigned char )0, "RIFF", "wav", & ParseRiffHeaderConfig, 2}, 
        {(unsigned char )0, "RF64", "wav", & ParseRiffHeaderConfig, 2}, 
        {(unsigned char )1, "riff", "w64", & ParseWave64HeaderConfig, 8}, 
        {(unsigned char )2, "caff", "caf", & ParseCaffHeaderConfig, 1}, 
        {(unsigned char )3, "FRM8", "dff", & ParseDsdiffHeaderConfig, 2}, 
        {(unsigned char )4, "DSD ", "dsf", & ParseDsfHeaderConfig, 1}};
#line 251
static int overwrite_all___1 ;
#line 251
static int num_files___1 ;
#line 251
static int file_index___1 ;
#line 251
static int copy_time___0 ;
#line 251
static int quiet_mode___2 ;
#line 251
static int verify_mode ;
#line 251
static int delete_source___0 ;
#line 252
static int no_utf8_convert___1 ;
#line 252
static int set_console_title___1 ;
#line 252
static int allow_huge_tags___0 ;
#line 252
static int quantize_bits ;
#line 252
static int quantize_round ;
#line 252
static int import_id3___0 ;
#line 253
static int raw_pcm_skip_bytes_begin ;
#line 253
static int raw_pcm_skip_bytes_end ;
#line 255
static int num_channels_order ;
#line 256
static unsigned char channel_order[18] ;
#line 257
static double encode_time_percent ;
#line 264
static int num_tag_items___0 ;
#line 264
static int total_tag_size ;
#line 269
static struct tag_item *tag_items___0 ;
#line 277
static FILE *wild_fopen___0(char *filename , char const   *mode ) ;
#line 278
static int pack_file(char *infilename , char *outfilename , char *out2filename , WavpackConfig *config ) ;
#line 279
static int pack_audio(WavpackContext *wpc , FILE *infile , int qmode , unsigned char *new_order ,
                      unsigned char *md5_digest_source ) ;
#line 280
static int pack_dsd_audio(WavpackContext *wpc , FILE *infile , int qmode , unsigned char *new_order ,
                          unsigned char *md5_digest_source ) ;
#line 281
static int repack_file(char *infilename , char *outfilename , char *out2filename ,
                       WavpackConfig *config ) ;
#line 282
static int repack_audio(WavpackContext *outfile , WavpackContext *infile , unsigned char *md5_digest_source ) ;
#line 283
static int verify_audio(char *infilename , unsigned char *md5_digest_source ) ;
#line 284
static void make_settings_string(char *settings , WavpackConfig *config ) ;
#line 285
static void display_progress___0(double file_progress ) ;
#line 286
static void TextToUTF8___0(void *string , int len ) ;
#line 1373 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static int write_block(void *id , void *data , int32_t length ) 
{ 
  write_id *wid ;
  uint32_t bcount ;
  int __cil_tmp6 ;

  {
#line 1375
  wid = (write_id *)id;
#line 1378
  if (wid->error) {
#line 1379
    return (0);
  }
#line 1381
  if (wid) {
#line 1381
    if (wid->file) {
#line 1381
      if (data) {
#line 1381
        if (length) {
          {
#line 1382
          __cil_tmp6 = DoWriteFile(wid->file, data, (uint32_t )length, & bcount);
          }
#line 1382
          if (! __cil_tmp6) {
            {
            {
#line 1383
            DoTruncateFile(wid->file);
            }
            {
#line 1384
            DoCloseHandle(wid->file);
            }
#line 1385
            wid->file = (FILE *)((void *)0);
#line 1386
            wid->error = 1;
            }
#line 1387
            return (0);
          } else
#line 1382
          if (bcount != (unsigned int )length) {
            {
            {
#line 1383
            DoTruncateFile(wid->file);
            }
            {
#line 1384
            DoCloseHandle(wid->file);
            }
#line 1385
            wid->file = (FILE *)((void *)0);
#line 1386
            wid->error = 1;
            }
#line 1387
            return (0);
          } else {
#line 1390
            wid->bytes_written += (unsigned int )length;
#line 1392
            if (! wid->first_block_size) {
#line 1393
              wid->first_block_size = bcount;
            }
          }
        }
      }
    }
  }
#line 1397
  return (1);
}
}
#line 1455 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static FILE *wild_fopen___0(char *filename , char const   *mode ) 
{ 
  char *matchname ;
  struct stat statbuf ;
  FILE *res ;
  glob_t globbuf ;
  int i ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  FILE *__cil_tmp11 ;

  {
  {
#line 1457
  matchname = (char *)((void *)0);
#line 1459
  res = (FILE *)((void *)0);
#line 1463
  glob((char const   *)filename, 0, (int (*)(char const   * , int  ))((void *)0),
       & globbuf);
#line 1465
  i = 0;
  }
  {
#line 1465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1465
    if (! ((unsigned long )i < globbuf.gl_pathc)) {
#line 1465
      goto while_break;
    }
    {
#line 1466
    __cil_tmp8 = stat((char const   *)*(globbuf.gl_pathv + i), & statbuf);
    }
#line 1466
    if (__cil_tmp8 == -1) {
#line 1467
      goto while_continue;
    } else
#line 1466
    if ((statbuf.st_mode & 61440U) == 16384U) {
#line 1467
      goto while_continue;
    }
#line 1469
    if (matchname) {
      {
#line 1470
      free(matchname);
#line 1471
      matchname = (char *)((void *)0);
      }
#line 1472
      goto while_break;
    } else {
      {
#line 1475
      __cil_tmp9 = strlen((char const   *)*(globbuf.gl_pathv + i));
#line 1475
      __cil_tmp10 = malloc(__cil_tmp9 + 10UL);
#line 1475
      matchname = __cil_tmp10;
#line 1476
      strcpy(matchname, (char const   *)*(globbuf.gl_pathv + i));
      }
    }
#line 1465
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1480
  globfree(& globbuf);
  }
#line 1482
  if (matchname) {
    {
#line 1483
    res = fopen((char const   *)matchname, mode);
#line 1484
    free(matchname);
    }
  }
#line 1487
  return (res);
}
}
#line 1500 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static int pack_file(char *infilename , char *outfilename , char *out2filename , WavpackConfig *config ) 
{ 
  char *outfilename_temp ;
  char *out2filename_temp ;
  char dummy ;
  int use_tempfiles ;
  int chunk_alignment ;
  int imported_tag_items ;
  uint32_t bcount ;
  WavpackConfig loc_config ;
  unsigned char *new_channel_order ;
  unsigned char md5_digest[16] ;
  write_id wv_file ;
  write_id wvc_file ;
  WavpackContext *wpc ;
  double dtime ;
  FILE *infile ;
  int result ;
  struct timeval time1 ;
  struct timeval time2 ;
  struct timezone timez ;
  write_id *tmp ;
  WavpackContext *__cil_tmp25 ;
  FILE *__cil_tmp26 ;
  int64_t infilesize ;
  int64_t __cil_tmp28 ;
  int64_t total_samples ;
  int sample_size ;
  int __cil_tmp31 ;
  char *__cil_tmp32 ;
  FILE *__cil_tmp33 ;
  size_t res ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  char *__cil_tmp37 ;
  char *tmp___0 ;
  char __cil_tmp39 ;
  FILE *__cil_tmp40 ;
  size_t res___0 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  char *__cil_tmp44 ;
  char *tmp___1 ;
  char __cil_tmp46 ;
  FILE *testfile ;
  int count ;
  unsigned long __cil_tmp49 ;
  void *__cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  void *__cil_tmp52 ;
  char *__cil_tmp53 ;
  int __cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  int __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  FILE *__cil_tmp60 ;
  int res___1 ;
  unsigned long __cil_tmp62 ;
  FILE *__cil_tmp63 ;
  int res___2 ;
  unsigned long __cil_tmp65 ;
  char *tmp___2 ;
  FILE *__cil_tmp67 ;
  char *tmp___3 ;
  unsigned long __cil_tmp69 ;
  char *__cil_tmp70 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  unsigned long __cil_tmp73 ;
  char *__cil_tmp74 ;
  char *tmp___6 ;
  char *__cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  char *__cil_tmp78 ;
  char *tmp___7 ;
  char fourcc[4] ;
  int i ;
  int __cil_tmp82 ;
  char *tmp___8 ;
  int __cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *tmp___9 ;
  int __cil_tmp88 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int bytes_to_skip ;
  char dummy___58[256] ;
  int requested_bytes ;
  unsigned long tmp___12 ;
  int __cil_tmp95 ;
  char *tmp___13 ;
  int layout ;
  uint32_t __cil_tmp98 ;
  int i___0 ;
  void *__cil_tmp100 ;
  int i___1 ;
  int j ;
  char *tmp___14 ;
  void *__cil_tmp104 ;
  int __cil_tmp105 ;
  unsigned char __cil_tmp106 ;
  char *tmp___15 ;
  FILE *__cil_tmp108 ;
  char *tmp___16 ;
  unsigned char *tmp___17 ;
  int __cil_tmp111 ;
  unsigned char *tmp___18 ;
  int __cil_tmp113 ;
  int wrapper_size ;
  int buffer_size ;
  unsigned char *buffer ;
  int64_t data_chunk_bytes ;
  int64_t __cil_tmp118 ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;
  int bytes_over ;
  int padding_bytes ;
  int tmp___19 ;
  unsigned char pad_byte ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;
  void *__cil_tmp127 ;
  int __cil_tmp128 ;
  void *__cil_tmp129 ;
  int __cil_tmp130 ;
  char *__cil_tmp131 ;
  int __cil_tmp132 ;
  int32_t bytes_used ;
  int32_t id3_res ;
  char error[80] ;
  int __cil_tmp136 ;
  int __cil_tmp137 ;
  int __cil_tmp138 ;
  char *__cil_tmp139 ;
  int i___2 ;
  int res___3 ;
  int __cil_tmp142 ;
  int __cil_tmp143 ;
  int __cil_tmp144 ;
  char *__cil_tmp145 ;
  int64_t __cil_tmp146 ;
  int64_t __cil_tmp147 ;
  char *block_buff ;
  void *__cil_tmp149 ;
  int __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  int __cil_tmp153 ;
  int __cil_tmp154 ;
  void *__cil_tmp155 ;
  int __cil_tmp156 ;
  int __cil_tmp157 ;
  int __cil_tmp158 ;
  int __cil_tmp159 ;
  int __cil_tmp160 ;
  int __cil_tmp161 ;
  int __cil_tmp162 ;
  char *tmp___20 ;
  int __cil_tmp164 ;
  unsigned char *tmp___21 ;
  int __cil_tmp166 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int __cil_tmp169 ;
  int __cil_tmp170 ;
  int __cil_tmp171 ;
  int __cil_tmp172 ;
  int res___4 ;
  int __cil_tmp174 ;
  char const   *tmp___24 ;
  double __cil_tmp176 ;
  int full_scale_bits ;
  int __cil_tmp178 ;
  double full_scale_rms ;
  double sum ;
  double peak ;
  int __cil_tmp182 ;
  double __cil_tmp183 ;
  int64_t __cil_tmp184 ;
  double __cil_tmp185 ;
  double __cil_tmp186 ;
  char *file ;
  char *fext ;
  char *oper ;
  char *cmode ;
  char cratio[16] ;
  char md5_string[57] ;
  int i___3 ;
  unsigned long __cil_tmp194 ;
  char *__cil_tmp195 ;
  char *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  unsigned long __cil_tmp199 ;
  char *__cil_tmp200 ;
  char *tmp___28 ;
  char const   *tmp___29 ;
  int __cil_tmp203 ;
  double __cil_tmp204 ;
  double __cil_tmp205 ;
  double __cil_tmp206 ;
  double __cil_tmp207 ;

  {
#line 1502
  outfilename_temp = (char *)((void *)0);
#line 1502
  out2filename_temp = (char *)((void *)0);
#line 1503
  use_tempfiles = out2filename != (void *)0;
  {
#line 1503
  chunk_alignment = 1;
#line 1504
  imported_tag_items = 0;
#line 1506
  loc_config = *config;
#line 1507
  new_channel_order = (unsigned char *)((void *)0);
#line 1522
  memset(& wv_file, 0, sizeof(wv_file));
#line 1523
  memset(& wvc_file, 0, sizeof(wvc_file));
  }
#line 1524
  if (out2filename) {
#line 1524
    tmp = & wvc_file;
  } else {
#line 1524
    tmp = (write_id *)((void *)0);
  }
  {
#line 1524
  __cil_tmp25 = WavpackOpenFileOutput(& write_block, & wv_file, tmp);
#line 1524
  wpc = __cil_tmp25;
  }
#line 1528
  if ((int )*infilename == 45) {
#line 1529
    infile = stdin;
  } else {
    {
#line 1537
    infile = fopen((char const   *)infilename, "rb");
    }
#line 1537
    if (infile == (void *)0) {
      {
#line 1538
      error_line("can\'t open file %s!?dU", infilename);
#line 1539
      WavpackCloseFile(wpc);
      }
#line 1540
      return (1);
    }
  }
#line 1543
  if (loc_config.qmode & 4096) {
    {
#line 1544
    __cil_tmp28 = DoGetFileSize(infile);
#line 1544
    infilesize = __cil_tmp28;
    }
#line 1546
    if (infilesize) {
#line 1547
      sample_size = loc_config.bytes_per_sample * loc_config.num_channels;
#line 1549
      infilesize -= (long )(raw_pcm_skip_bytes_begin + raw_pcm_skip_bytes_end);
#line 1550
      total_samples = infilesize / (long )sample_size;
#line 1552
      if (total_samples <= 0L) {
        {
#line 1553
        error_line("no raw PCM data to encode!q?dU");
#line 1554
        DoCloseHandle(infile);
#line 1555
        WavpackCloseFile(wpc);
        }
#line 1556
        return (1);
      }
#line 1559
      if (infilesize % (long )sample_size) {
        {
#line 1560
        error_line("warning: raw PCM infile length does not divide evenly, %d bytes will be discarded/q?dU",
                   (int )(infilesize % (long )sample_size));
        }
      }
    } else {
#line 1564
      if (raw_pcm_skip_bytes_end) {
        {
#line 1565
        error_line("can\'t skip trailer in raw PCM read from stdin!");
#line 1566
        DoCloseHandle(infile);
#line 1567
        WavpackCloseFile(wpc);
        }
#line 1568
        return (1);
      }
#line 1571
      loc_config.qmode |= 2048;
#line 1572
      total_samples = (int64_t )(- 1);
    }
#line 1575
    if (! loc_config.channel_mask) {
#line 1575
      if (! (loc_config.qmode & 1024)) {
#line 1576
        if (loc_config.num_channels <= 2) {
#line 1577
          loc_config.channel_mask = 5 - loc_config.num_channels;
        } else
#line 1578
        if (loc_config.num_channels <= 18) {
#line 1579
          loc_config.channel_mask = (1 << loc_config.num_channels) - 1;
        } else {
#line 1581
          loc_config.channel_mask = 262143;
        }
      }
    }
    {
#line 1584
    __cil_tmp31 = WavpackSetConfiguration64(wpc, & loc_config, total_samples, (unsigned char const   *)((void *)0));
    }
#line 1584
    if (! __cil_tmp31) {
      {
#line 1585
      __cil_tmp32 = WavpackGetErrorMessage(wpc);
#line 1585
      error_line("%sq?dU", __cil_tmp32);
#line 1586
      DoCloseHandle(infile);
#line 1587
      WavpackCloseFile(wpc);
      }
#line 1588
      return (1);
    }
  }
  {
#line 1597
  wv_file.file = fopen((char const   *)outfilename, "rbq?dU");
  }
#line 1597
  if (wv_file.file != (void *)0) {
#line 1597
    if ((int )*outfilename != 45) {
      {
#line 1598
      __cil_tmp35 = fread(& dummy, (unsigned long )1, (unsigned long )1, wv_file.file);
#line 1598
      res = __cil_tmp35;
#line 1600
      DoCloseHandle(wv_file.file);
      }
#line 1602
      if (res == 1UL) {
#line 1603
        use_tempfiles = 1;
#line 1605
        if (! overwrite_all___1) {
          {
#line 1606
          __cil_tmp36 = strlen((char const   *)outfilename);
          }
#line 1606
          if (__cil_tmp36 > 30UL) {
            {
#line 1606
            __cil_tmp37 = filespec_name(outfilename);
#line 1606
            tmp___0 = __cil_tmp37;
            }
          } else {
#line 1606
            tmp___0 = outfilename;
          }
          {
#line 1606
          fprintf(stderr, "overwrite %s (yes/no/all)? ", tmp___0);
#line 1607
          fflush(stderr);
          }
#line 1609
          if (set_console_title___1) {
            {
#line 1610
            DoSetConsoleTitle("overwrite?");
            }
          }
          {
#line 1612
          __cil_tmp39 = yna();
          }
          {
#line 1613
          if ((int )__cil_tmp39 == 'n') {
#line 1613
            goto case_110;
          }
#line 1618
          if ((int )__cil_tmp39 == 'a') {
#line 1618
            goto case_97;
          }
#line 1612
          goto switch_break;
          case_110: /* CIL Label */ 
          {
#line 1614
          DoCloseHandle(infile);
          }
          {
#line 1615
          WavpackCloseFile(wpc);
          }
#line 1616
          return (1);
          case_97: /* CIL Label */ 
#line 1619
          overwrite_all___1 = 1;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 1625
  wvc_file.file = fopen((char const   *)out2filename, "rb");
  }
#line 1625
  if (out2filename) {
#line 1625
    if (! overwrite_all___1) {
#line 1625
      if (wvc_file.file != (void *)0) {
        {
#line 1626
        __cil_tmp42 = fread(& dummy, (unsigned long )1, (unsigned long )1, wvc_file.file);
#line 1626
        res___0 = __cil_tmp42;
#line 1628
        DoCloseHandle(wvc_file.file);
        }
#line 1630
        if (res___0 == 1UL) {
          {
#line 1631
          __cil_tmp43 = strlen((char const   *)out2filename);
          }
#line 1631
          if (__cil_tmp43 > 30UL) {
            {
#line 1631
            __cil_tmp44 = filespec_name(out2filename);
#line 1631
            tmp___1 = __cil_tmp44;
            }
          } else {
#line 1631
            tmp___1 = out2filename;
          }
          {
#line 1631
          fprintf(stderr, "overwrite %s (yes/no/all)? ?dU", tmp___1);
#line 1632
          fflush(stderr);
          }
#line 1634
          if (set_console_title___1) {
            {
#line 1635
            DoSetConsoleTitle("overwrite?");
            }
          }
          {
#line 1637
          __cil_tmp46 = yna();
          }
          {
#line 1639
          if ((int )__cil_tmp46 == 'n') {
#line 1639
            goto case_110___0;
          }
#line 1644
          if ((int )__cil_tmp46 == 'a') {
#line 1644
            goto case_97___0;
          }
#line 1637
          goto switch_break___0;
          case_110___0: /* CIL Label */ 
          {
#line 1640
          DoCloseHandle(infile);
          }
          {
#line 1641
          WavpackCloseFile(wpc);
          }
#line 1642
          return (1);
          case_97___0: /* CIL Label */ 
#line 1645
          overwrite_all___1 = 1;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 1653
  if (use_tempfiles) {
    {
#line 1655
    count = 0;
#line 1657
    __cil_tmp49 = strlen((char const   *)outfilename);
#line 1657
    __cil_tmp50 = malloc(__cil_tmp49 + 16UL);
#line 1657
    outfilename_temp = __cil_tmp50;
    }
#line 1659
    if (out2filename) {
      {
#line 1660
      __cil_tmp51 = strlen((char const   *)outfilename);
#line 1660
      __cil_tmp52 = malloc(__cil_tmp51 + 16UL);
#line 1660
      out2filename_temp = __cil_tmp52;
      }
    }
    {
#line 1662
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1663
      strcpy(outfilename_temp, (char const   *)outfilename);
#line 1665
      __cil_tmp53 = filespec_ext(outfilename_temp);
      }
#line 1665
      if (__cil_tmp53) {
#line 1666
        __cil_tmp54 = count;
#line 1666
        count ++;
#line 1666
        if (__cil_tmp54) {
          {
#line 1667
          __cil_tmp55 = filespec_ext(outfilename_temp);
#line 1667
          sprintf(__cil_tmp55, ".tmp%d", count - 1);
          }
        } else {
          {
#line 1669
          __cil_tmp56 = filespec_ext(outfilename_temp);
#line 1669
          strcpy(__cil_tmp56, ".tmpdU");
          }
        }
        {
#line 1671
        __cil_tmp57 = filespec_ext(outfilename);
#line 1671
        strcat(outfilename_temp, (char const   *)__cil_tmp57);
        }
      } else {
#line 1674
        __cil_tmp58 = count;
#line 1674
        count ++;
#line 1674
        if (__cil_tmp58) {
          {
#line 1675
          __cil_tmp59 = strlen((char const   *)outfilename_temp);
#line 1675
          sprintf(outfilename_temp + __cil_tmp59, ".tmp%d", count - 1);
          }
        } else {
          {
#line 1677
          strcat(outfilename_temp, ".tmp");
          }
        }
      }
      {
#line 1680
      testfile = fopen((char const   *)outfilename_temp, "rb");
      }
#line 1682
      if (testfile) {
        {
#line 1683
        __cil_tmp62 = fread(& dummy, (unsigned long )1, (unsigned long )1, testfile);
#line 1683
        res___1 = (int )__cil_tmp62;
#line 1685
        fclose(testfile);
        }
#line 1687
        if (res___1 == 1) {
#line 1688
          goto while_continue;
        }
      }
#line 1691
      if (out2filename) {
        {
#line 1692
        strcpy(out2filename_temp, (char const   *)outfilename_temp);
#line 1693
        strcat(out2filename_temp, "c\004q?dU");
#line 1695
        testfile = fopen((char const   *)out2filename_temp, "rbq?dU");
        }
#line 1697
        if (testfile) {
          {
#line 1698
          __cil_tmp65 = fread(& dummy, (unsigned long )1, (unsigned long )1, testfile);
#line 1698
          res___2 = (int )__cil_tmp65;
#line 1700
          fclose(testfile);
          }
#line 1702
          if (res___2 == 1) {
#line 1703
            goto while_continue;
          }
        }
      }
#line 1707
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1714
  gettimeofday(& time1, & timez);
  }
#line 1719
  if ((int )*outfilename == 45) {
#line 1720
    wv_file.file = stdout;
  } else {
#line 1728
    if (use_tempfiles) {
#line 1728
      tmp___2 = outfilename_temp;
    } else {
#line 1728
      tmp___2 = outfilename;
    }
    {
#line 1728
    __cil_tmp67 = fopen((char const   *)tmp___2, "w+b?dU");
#line 1728
    wv_file.file = __cil_tmp67;
    }
#line 1728
    if (wv_file.file == (void *)0) {
#line 1729
      if (use_tempfiles) {
#line 1729
        tmp___3 = outfilename_temp;
      } else {
#line 1729
        tmp___3 = outfilename;
      }
      {
#line 1729
      error_line("can\'t create file %s!", tmp___3);
#line 1730
      DoCloseHandle(infile);
#line 1731
      WavpackCloseFile(wpc);
      }
#line 1732
      return (1);
    }
  }
#line 1735
  if (! quiet_mode___2) {
#line 1736
    if ((int )*outfilename == 45) {
#line 1737
      if ((int )*infilename == 45) {
#line 1737
        tmp___5 = "stdin";
      } else {
        {
#line 1737
        __cil_tmp69 = strlen((char const   *)infilename);
        }
#line 1737
        if (__cil_tmp69 > 30UL) {
          {
#line 1737
          __cil_tmp70 = filespec_name(infilename);
#line 1737
          tmp___4 = __cil_tmp70;
          }
        } else {
#line 1737
          tmp___4 = infilename;
        }
#line 1737
        tmp___5 = (char const   *)tmp___4;
      }
      {
#line 1737
      fprintf(stderr, "packing %s to stdout,", (int )tmp___5);
      }
    } else
#line 1738
    if (out2filename) {
      {
#line 1739
      __cil_tmp73 = strlen((char const   *)outfilename);
      }
#line 1739
      if (__cil_tmp73 > 30UL) {
        {
#line 1739
        __cil_tmp74 = filespec_name(outfilename);
#line 1739
        tmp___6 = __cil_tmp74;
        }
      } else {
#line 1739
        tmp___6 = outfilename;
      }
      {
#line 1739
      __cil_tmp76 = filespec_ext(out2filename);
#line 1739
      fprintf(stderr, "creating %s (+%s),", tmp___6, __cil_tmp76);
      }
    } else {
      {
#line 1741
      __cil_tmp77 = strlen((char const   *)outfilename);
      }
#line 1741
      if (__cil_tmp77 > 30UL) {
        {
#line 1741
        __cil_tmp78 = filespec_name(outfilename);
#line 1741
        tmp___7 = __cil_tmp78;
        }
      } else {
#line 1741
        tmp___7 = outfilename;
      }
      {
#line 1741
      fprintf(stderr, "creating %s,dU", tmp___7);
      }
    }
    {
#line 1743
    fflush(stderr);
    }
  }
#line 1748
  if (loc_config.qmode & 4096) {
#line 1749
    if (loc_config.qmode & 48) {
      {
#line 1750
      WavpackSetFileInformation(wpc, "dff", (unsigned char )3);
      }
    }
  }
#line 1754
  if (! (loc_config.qmode & 4096)) {
    {
#line 1758
    __cil_tmp82 = DoReadFile(infile, (char *)fourcc, (uint32_t )sizeof(fourcc), & bcount);
    }
#line 1758
    if (! __cil_tmp82) {
      _L: /* CIL Label */ 
      {
#line 1759
      error_line("can\'t read file %s!?dU", infilename);
#line 1760
      DoCloseHandle(infile);
#line 1761
      DoCloseHandle(wv_file.file);
      }
#line 1762
      if (use_tempfiles) {
#line 1762
        tmp___8 = outfilename_temp;
      } else {
#line 1762
        tmp___8 = outfilename;
      }
      {
#line 1762
      DoDeleteFile(tmp___8);
#line 1763
      WavpackCloseFile(wpc);
      }
#line 1764
      return (1);
    } else
#line 1758
    if ((unsigned long )bcount != sizeof(fourcc)) {
#line 1758
      goto _L;
    }
#line 1767
    i = 0;
    {
#line 1767
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1767
      if (! ((unsigned long )i < sizeof(file_formats___0) / sizeof(file_formats___0[0]))) {
#line 1767
        goto while_break___0;
      }
      {
#line 1768
      __cil_tmp84 = strncmp((char const   *)((char *)fourcc), (char const   *)file_formats___0[i].fourcc,
                            (unsigned long )4);
      }
#line 1768
      if (! __cil_tmp84) {
        {
#line 1770
        __cil_tmp85 = filespec_ext(infilename);
        }
#line 1770
        if (__cil_tmp85) {
          {
#line 1770
          __cil_tmp86 = filespec_ext(infilename);
#line 1770
          tmp___9 = __cil_tmp86 + 1;
          }
        } else {
#line 1770
          tmp___9 = file_formats___0[i].default_extension;
        }
        {
#line 1770
        WavpackSetFileInformation(wpc, tmp___9, file_formats___0[i].id);
#line 1774
        __cil_tmp88 = (*(file_formats___0[i].ParseHeader))(infile, infilename, (char *)fourcc,
                                                           wpc, & loc_config);
        }
#line 1774
        if (__cil_tmp88) {
          {
#line 1775
          DoCloseHandle(infile);
#line 1776
          DoCloseHandle(wv_file.file);
          }
#line 1777
          if (use_tempfiles) {
#line 1777
            tmp___10 = outfilename_temp;
          } else {
#line 1777
            tmp___10 = outfilename;
          }
          {
#line 1777
          DoDeleteFile(tmp___10);
#line 1778
          WavpackCloseFile(wpc);
          }
#line 1779
          return (1);
        }
#line 1782
        chunk_alignment = file_formats___0[i].chunk_alignment;
#line 1783
        goto while_break___0;
      }
#line 1767
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1786
    if ((unsigned long )i == sizeof(file_formats___0) / sizeof(file_formats___0[0])) {
      {
#line 1787
      error_line("%s is not a recognized file type!", infilename);
#line 1788
      DoCloseHandle(infile);
#line 1789
      DoCloseHandle(wv_file.file);
      }
#line 1790
      if (use_tempfiles) {
#line 1790
        tmp___11 = outfilename_temp;
      } else {
#line 1790
        tmp___11 = outfilename;
      }
      {
#line 1790
      DoDeleteFile(tmp___11);
#line 1791
      WavpackCloseFile(wpc);
      }
#line 1792
      return (1);
    }
  } else
#line 1795
  if (raw_pcm_skip_bytes_begin) {
#line 1796
    bytes_to_skip = raw_pcm_skip_bytes_begin;
    {
#line 1799
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1799
      if (! bytes_to_skip) {
#line 1799
        goto while_break___1;
      }
#line 1800
      if ((unsigned long )bytes_to_skip >= sizeof(dummy___58)) {
#line 1800
        tmp___12 = sizeof(dummy___58);
      } else {
#line 1800
        tmp___12 = (unsigned long )bytes_to_skip;
      }
      {
#line 1800
      requested_bytes = (int )tmp___12;
#line 1802
      __cil_tmp95 = DoReadFile(infile, (char *)dummy___58, (uint32_t )requested_bytes,
                               & bcount);
      }
#line 1802
      if (__cil_tmp95) {
#line 1802
        if (bcount == (unsigned int )requested_bytes) {
#line 1803
          bytes_to_skip -= bcount;
        } else {
#line 1805
          goto while_break___1;
        }
      } else {
#line 1805
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1808
    if (bytes_to_skip) {
      {
#line 1809
      error_line("can\'t read file %s!?dU", infilename);
#line 1810
      DoCloseHandle(infile);
#line 1811
      DoCloseHandle(wv_file.file);
      }
#line 1812
      if (use_tempfiles) {
#line 1812
        tmp___13 = outfilename_temp;
      } else {
#line 1812
        tmp___13 = outfilename;
      }
      {
#line 1812
      DoDeleteFile(tmp___13);
#line 1813
      WavpackCloseFile(wpc);
      }
#line 1814
      return (1);
    }
  }
#line 1820
  if (loc_config.qmode & 8) {
    {
#line 1821
    __cil_tmp98 = WavpackGetChannelLayout(wpc, (unsigned char *)((void *)0));
#line 1821
    layout = (int )__cil_tmp98;
    }
#line 1823
    if ((layout & 255) <= loc_config.num_channels) {
      {
#line 1824
      new_channel_order = (unsigned char *)malloc((unsigned long )loc_config.num_channels);
#line 1826
      i___0 = 0;
      }
      {
#line 1826
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1826
        if (! (i___0 < loc_config.num_channels)) {
#line 1826
          goto while_break___2;
        }
#line 1827
        *(new_channel_order + i___0) = (unsigned char )i___0;
#line 1826
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1829
      WavpackGetChannelLayout(wpc, new_channel_order);
      }
    }
  }
#line 1835
  if (num_channels_order) {
    _L___60: /* CIL Label */ 
#line 1838
    if (loc_config.num_channels < num_channels_order) {
      _L___59: /* CIL Label */ 
      {
#line 1840
      error_line("file does not have %d channel(s)!\211r?dU", num_channels_order);
#line 1841
      DoCloseHandle(infile);
#line 1842
      DoCloseHandle(wv_file.file);
      }
#line 1843
      if (use_tempfiles) {
#line 1843
        tmp___14 = outfilename_temp;
      } else {
#line 1843
        tmp___14 = outfilename;
      }
      {
#line 1843
      DoDeleteFile(tmp___14);
#line 1844
      WavpackCloseFile(wpc);
      }
#line 1845
      return (1);
    } else
#line 1838
    if (loc_config.num_channels > num_channels_order) {
#line 1838
      if (! (loc_config.qmode & 1024)) {
#line 1838
        goto _L___59;
      }
    }
#line 1848
    if (num_channels_order) {
      {
#line 1849
      new_channel_order = (unsigned char *)malloc((unsigned long )loc_config.num_channels);
#line 1851
      i___1 = 0;
      }
      {
#line 1851
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1851
        if (! (i___1 < loc_config.num_channels)) {
#line 1851
          goto while_break___3;
        }
#line 1852
        *(new_channel_order + i___1) = (unsigned char )i___1;
#line 1851
        i___1 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1854
      memcpy(new_channel_order, (unsigned char *)channel_order, (unsigned long )num_channels_order);
#line 1856
      i___1 = 0;
      }
      {
#line 1856
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1856
        if (! (i___1 < num_channels_order)) {
#line 1856
          goto while_break___4;
        }
#line 1857
        j = 0;
        {
#line 1857
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1857
          if (! (j < num_channels_order)) {
#line 1857
            goto while_break___5;
          }
#line 1858
          if ((int )*(new_channel_order + j) == i___1) {
#line 1859
            i___1 ++;
#line 1860
            goto while_break___5;
          }
#line 1857
          j ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1863
        if (j == num_channels_order) {
#line 1864
          j = 0;
          {
#line 1864
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1864
            if (! (j < num_channels_order)) {
#line 1864
              goto while_break___6;
            }
#line 1865
            if ((int )*(new_channel_order + j) > i___1) {
#line 1866
              __cil_tmp106 = *(new_channel_order + j);
#line 1866
              (*(new_channel_order + j)) --;
            }
#line 1864
            j ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  } else
#line 1835
  if (loc_config.qmode & 1024) {
#line 1835
    goto _L___60;
  }
#line 1873
  if (out2filename) {
#line 1874
    if (use_tempfiles) {
#line 1874
      tmp___15 = out2filename_temp;
    } else {
#line 1874
      tmp___15 = out2filename;
    }
    {
#line 1874
    __cil_tmp108 = fopen((char const   *)tmp___15, "w+b");
#line 1874
    wvc_file.file = __cil_tmp108;
    }
#line 1874
    if (wvc_file.file == (void *)0) {
      {
#line 1875
      error_line("can\'t create correction file!");
#line 1876
      DoCloseHandle(infile);
#line 1877
      DoCloseHandle(wv_file.file);
      }
#line 1878
      if (use_tempfiles) {
#line 1878
        tmp___16 = outfilename_temp;
      } else {
#line 1878
        tmp___16 = outfilename;
      }
      {
#line 1878
      DoDeleteFile(tmp___16);
#line 1879
      WavpackCloseFile(wpc);
      }
#line 1880
      return (1);
    }
  }
#line 1886
  if (loc_config.qmode & 48) {
#line 1887
    if (loc_config.flags & 134217728 || verify_mode) {
#line 1887
      tmp___17 = (unsigned char *)md5_digest;
    } else {
#line 1887
      tmp___17 = (unsigned char *)((void *)0);
    }
    {
#line 1887
    __cil_tmp111 = pack_dsd_audio(wpc, infile, loc_config.qmode, new_channel_order,
                                  tmp___17);
#line 1887
    result = __cil_tmp111;
    }
  } else {
#line 1889
    if (loc_config.flags & 134217728 || verify_mode) {
#line 1889
      tmp___18 = (unsigned char *)md5_digest;
    } else {
#line 1889
      tmp___18 = (unsigned char *)((void *)0);
    }
    {
#line 1889
    __cil_tmp113 = pack_audio(wpc, infile, loc_config.qmode, new_channel_order, tmp___18);
#line 1889
    result = __cil_tmp113;
    }
  }
#line 1891
  if (new_channel_order) {
    {
#line 1892
    free(new_channel_order);
    }
  }
#line 1896
  if (result == 0) {
#line 1896
    if (loc_config.flags & 134217728) {
      {
#line 1897
      WavpackStoreMD5Sum(wpc, (unsigned char *)md5_digest);
      }
    }
  }
#line 1904
  if (result == 0) {
#line 1904
    if (! (loc_config.qmode & 6144)) {
#line 1905
      wrapper_size = 0;
#line 1910
      if (chunk_alignment != 1) {
        {
#line 1911
        __cil_tmp120 = WavpackGetBytesPerSample(wpc);
        }
        {
#line 1911
        __cil_tmp119 = WavpackGetNumChannels(wpc);
        }
        {
#line 1911
        __cil_tmp118 = WavpackGetNumSamples64(wpc);
#line 1911
        data_chunk_bytes = (__cil_tmp118 * (long )__cil_tmp119) * (long )__cil_tmp120;
#line 1912
        bytes_over = (int )(data_chunk_bytes % (long )chunk_alignment);
        }
#line 1913
        if (bytes_over) {
#line 1913
          tmp___19 = chunk_alignment - bytes_over;
        } else {
#line 1913
          tmp___19 = 0;
        }
#line 1913
        padding_bytes = tmp___19;
        {
#line 1916
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1916
          __cil_tmp125 = padding_bytes;
#line 1916
          padding_bytes --;
#line 1916
          if (! __cil_tmp125) {
#line 1916
            goto while_break___7;
          }
          {
#line 1917
          __cil_tmp126 = DoReadFile(infile, & pad_byte, (uint32_t )1, & bcount);
          }
#line 1917
          if (! __cil_tmp126) {
            {
            {
#line 1918
            error_line("warning: input file missing required padding byte!");
            }
            }
          } else
#line 1917
          if (bcount != 1U) {
            {
            {
#line 1918
            error_line("warning: input file missing required padding byte!");
            }
            }
          } else
#line 1919
          if (pad_byte) {
            {
#line 1920
            error_line("warning: input file has non-zero padding byte!");
            }
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      }
      {
#line 1926
      buffer_size = 65536;
#line 1926
      __cil_tmp127 = malloc((unsigned long )buffer_size);
#line 1926
      buffer = __cil_tmp127;
      }
      {
#line 1928
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 1928
        __cil_tmp128 = DoReadFile(infile, buffer + wrapper_size, (uint32_t )(buffer_size - wrapper_size),
                                  & bcount);
        }
#line 1928
        if (! (__cil_tmp128 && bcount)) {
#line 1928
          goto while_break___8;
        }
#line 1929
        wrapper_size += bcount;
#line 1929
        if (wrapper_size == buffer_size) {
          {
#line 1930
          buffer_size += 65536;
#line 1930
          __cil_tmp129 = realloc(buffer, (unsigned long )buffer_size);
#line 1930
          buffer = __cil_tmp129;
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 1934
      __cil_tmp130 = WavpackAddWrapper(wpc, buffer, (uint32_t )wrapper_size);
      }
#line 1934
      if (wrapper_size) {
#line 1934
        if (! (loc_config.qmode & 512)) {
#line 1934
          if (! __cil_tmp130) {
            {
#line 1935
            __cil_tmp131 = WavpackGetErrorMessage(wpc);
#line 1935
            error_line("%s", __cil_tmp131);
#line 1936
            result = 2;
            }
          }
        }
      }
      {
#line 1942
      __cil_tmp132 = strncmp((char const   *)((char *)buffer), "ID3", (unsigned long )3);
      }
#line 1942
      if (result == 0) {
#line 1942
        if (import_id3___0) {
#line 1942
          if (wrapper_size > 10) {
#line 1942
            if (! __cil_tmp132) {
              {
#line 1948
              id3_res = ImportID3v2((void *)0, buffer, wrapper_size, (char *)error,
                                    & bytes_used);
              }
#line 1950
              if (! allow_huge_tags___0) {
#line 1950
                if (bytes_used > 1048576) {
                  {
#line 1951
                  error_line("imported tag items exceed 1 MB, use --allow-huge-tags to override\353r?dU");
#line 1952
                  result = 1;
                  }
                } else {
#line 1950
                  goto _L___61;
                }
              } else
              _L___61: /* CIL Label */ 
#line 1954
              if (bytes_used > 16777216) {
                {
#line 1955
                error_line("imported tag items exceed 16 MB");
#line 1956
                result = 1;
                }
              } else {
#line 1959
                if (id3_res > 0) {
                  {
#line 1960
                  id3_res = ImportID3v2(wpc, buffer, wrapper_size, (char *)error,
                                        (int32_t *)((void *)0));
                  }
                }
#line 1962
                if (id3_res < 0) {
                  {
#line 1963
                  error_line("ID3v2 import: %s\230\001", (char *)error);
#line 1964
                  result = 1;
                  }
                } else
#line 1966
                if (id3_res > 0) {
#line 1967
                  imported_tag_items = id3_res;
                }
              }
            }
          }
        }
      }
      {
#line 1971
      free(buffer);
      }
    }
  }
  {
#line 1974
  DoCloseHandle(infile);
#line 1978
  __cil_tmp138 = WavpackFlushSamples(wpc);
  }
#line 1978
  if (result == 0) {
#line 1978
    if (! __cil_tmp138) {
      {
#line 1979
      __cil_tmp139 = WavpackGetErrorMessage(wpc);
#line 1979
      error_line("%s", __cil_tmp139);
#line 1980
      result = 2;
      }
    }
  }
#line 1986
  if (result == 0) {
#line 1986
    if (num_tag_items___0) {
      _L___62: /* CIL Label */ 
#line 1987
      res___3 = 1;
#line 1989
      i___2 = 0;
      {
#line 1989
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1989
        if (! (i___2 < num_tag_items___0 && res___3)) {
#line 1989
          goto while_break___9;
        }
#line 1990
        if ((tag_items___0 + i___2)->vsize) {
#line 1991
          if ((tag_items___0 + i___2)->binary) {
            {
#line 1992
            res___3 = WavpackAppendBinaryTagItem(wpc, (char const   *)(tag_items___0 + i___2)->item,
                                                 (char const   *)(tag_items___0 + i___2)->value,
                                                 (tag_items___0 + i___2)->vsize);
            }
          } else {
            {
#line 1994
            res___3 = WavpackAppendTagItem(wpc, (char const   *)(tag_items___0 + i___2)->item,
                                           (char const   *)(tag_items___0 + i___2)->value,
                                           (tag_items___0 + i___2)->vsize);
            }
          }
        }
#line 1989
        i___2 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1997
      __cil_tmp144 = WavpackWriteTag(wpc);
      }
#line 1997
      if (! res___3) {
        {
        {
#line 1998
        __cil_tmp145 = WavpackGetErrorMessage(wpc);
        }
        {
#line 1998
        error_line("%s", __cil_tmp145);
        }
#line 1999
        result = 2;
        }
      } else
#line 1997
      if (! __cil_tmp144) {
        {
        {
#line 1998
        __cil_tmp145 = WavpackGetErrorMessage(wpc);
        }
        {
#line 1998
        error_line("%s", __cil_tmp145);
        }
#line 1999
        result = 2;
        }
      }
    } else
#line 1986
    if (imported_tag_items) {
#line 1986
      goto _L___62;
    }
  }
  {
#line 2008
  __cil_tmp147 = WavpackGetSampleIndex64(wpc);
  }
  {
#line 2008
  __cil_tmp146 = WavpackGetNumSamples64(wpc);
  }
#line 2008
  if (result == 0) {
#line 2008
    if (__cil_tmp146 != __cil_tmp147) {
#line 2009
      if (loc_config.qmode & 2048) {
        {
#line 2010
        __cil_tmp149 = malloc((unsigned long )wv_file.first_block_size);
#line 2010
        block_buff = __cil_tmp149;
#line 2012
        __cil_tmp152 = strncmp((char const   *)block_buff, "wvpkdU", (unsigned long )4);
        }
        {
#line 2012
        __cil_tmp151 = DoReadFile(wv_file.file, block_buff, wv_file.first_block_size,
                                  & bcount);
        }
        {
#line 2012
        __cil_tmp150 = DoSetFilePositionAbsolute(wv_file.file, (int64_t )0);
        }
#line 2012
        if (block_buff) {
#line 2012
          if (! __cil_tmp150) {
#line 2012
            if (__cil_tmp151) {
#line 2012
              if (bcount == wv_file.first_block_size) {
#line 2012
                if (! __cil_tmp152) {
                  {
#line 2018
                  WavpackUpdateNumSamples(wpc, block_buff);
#line 2020
                  __cil_tmp154 = DoWriteFile(wv_file.file, block_buff, wv_file.first_block_size,
                                             & bcount);
                  }
                  {
#line 2020
                  __cil_tmp153 = DoSetFilePositionAbsolute(wv_file.file, (int64_t )0);
                  }
#line 2020
                  if (__cil_tmp153) {
                    {
                    {
                    {
#line 2023
                    error_line("couldn\'t update WavPack header with actual length!!");
                    }
                    }
#line 2024
                    result = 1;
                    }
                  } else
#line 2020
                  if (! __cil_tmp154) {
                    {
                    {
                    {
#line 2023
                    error_line("couldn\'t update WavPack header with actual length!!");
                    }
                    }
#line 2024
                    result = 1;
                    }
                  } else
#line 2020
                  if (bcount != wv_file.first_block_size) {
                    {
                    {
                    {
#line 2023
                    error_line("couldn\'t update WavPack header with actual length!!");
                    }
                    }
#line 2024
                    result = 1;
                    }
                  }
                } else {
                  {
                  {
                  {
                  {
                  {
#line 2028
                  error_line("couldn\'t update WavPack header with actual length!!?dU");
                  }
                  }
                  }
                  }
#line 2029
                  result = 1;
                  }
                }
              } else {
                {
                {
                {
                {
                {
#line 2028
                error_line("couldn\'t update WavPack header with actual length!!?dU");
                }
                }
                }
                }
#line 2029
                result = 1;
                }
              }
            } else {
              {
              {
              {
              {
              {
#line 2028
              error_line("couldn\'t update WavPack header with actual length!!?dU");
              }
              }
              }
              }
#line 2029
              result = 1;
              }
            }
          } else {
            {
            {
            {
            {
            {
#line 2028
            error_line("couldn\'t update WavPack header with actual length!!?dU");
            }
            }
            }
            }
#line 2029
            result = 1;
            }
          }
        } else {
          {
          {
          {
          {
          {
#line 2028
          error_line("couldn\'t update WavPack header with actual length!!?dU");
          }
          }
          }
          }
#line 2029
          result = 1;
          }
        }
#line 2032
        if (block_buff) {
          {
#line 2033
          free(block_buff);
          }
        }
#line 2035
        if (wvc_file.file) {
#line 2035
          if (result == 0) {
            {
#line 2036
            block_buff = (char *)malloc((unsigned long )wvc_file.first_block_size);
#line 2038
            __cil_tmp158 = strncmp((char const   *)block_buff, "wvpk", (unsigned long )4);
            }
            {
#line 2038
            __cil_tmp157 = DoReadFile(wvc_file.file, block_buff, wvc_file.first_block_size,
                                      & bcount);
            }
            {
#line 2038
            __cil_tmp156 = DoSetFilePositionAbsolute(wvc_file.file, (int64_t )0);
            }
#line 2038
            if (block_buff) {
#line 2038
              if (! __cil_tmp156) {
#line 2038
                if (__cil_tmp157) {
#line 2038
                  if (bcount == wvc_file.first_block_size) {
#line 2038
                    if (! __cil_tmp158) {
                      {
#line 2042
                      WavpackUpdateNumSamples(wpc, block_buff);
#line 2044
                      __cil_tmp160 = DoWriteFile(wvc_file.file, block_buff, wvc_file.first_block_size,
                                                 & bcount);
                      }
                      {
#line 2044
                      __cil_tmp159 = DoSetFilePositionAbsolute(wvc_file.file, (int64_t )0);
                      }
#line 2044
                      if (__cil_tmp159) {
                        {
                        {
                        {
#line 2047
                        error_line("couldn\'t update WavPack header with actual length!!");
                        }
                        }
#line 2048
                        result = 1;
                        }
                      } else
#line 2044
                      if (! __cil_tmp160) {
                        {
                        {
                        {
#line 2047
                        error_line("couldn\'t update WavPack header with actual length!!");
                        }
                        }
#line 2048
                        result = 1;
                        }
                      } else
#line 2044
                      if (bcount != wvc_file.first_block_size) {
                        {
                        {
                        {
#line 2047
                        error_line("couldn\'t update WavPack header with actual length!!");
                        }
                        }
#line 2048
                        result = 1;
                        }
                      }
                    } else {
                      {
                      {
                      {
                      {
                      {
#line 2052
                      error_line("couldn\'t update WavPack header with actual length!!");
                      }
                      }
                      }
                      }
#line 2053
                      result = 1;
                      }
                    }
                  } else {
                    {
                    {
                    {
                    {
                    {
#line 2052
                    error_line("couldn\'t update WavPack header with actual length!!");
                    }
                    }
                    }
                    }
#line 2053
                    result = 1;
                    }
                  }
                } else {
                  {
                  {
                  {
                  {
                  {
#line 2052
                  error_line("couldn\'t update WavPack header with actual length!!");
                  }
                  }
                  }
                  }
#line 2053
                  result = 1;
                  }
                }
              } else {
                {
                {
                {
                {
                {
#line 2052
                error_line("couldn\'t update WavPack header with actual length!!");
                }
                }
                }
                }
#line 2053
                result = 1;
                }
              }
            } else {
              {
              {
              {
              {
              {
#line 2052
              error_line("couldn\'t update WavPack header with actual length!!");
              }
              }
              }
              }
#line 2053
              result = 1;
              }
            }
#line 2056
            if (block_buff) {
              {
#line 2057
              free(block_buff);
              }
            }
          }
        }
      } else {
        {
#line 2061
        error_line("couldn\'t read all samples, file may be corrupt!!\220");
#line 2062
        result = 1;
        }
      }
    }
  }
  {
#line 2069
  __cil_tmp161 = DoCloseHandle(wv_file.file);
  }
#line 2069
  if (! __cil_tmp161) {
    {
#line 2070
    error_line("can\'t close WavPack file!\377\377\377");
    }
#line 2072
    if (result == 0) {
#line 2073
      result = 1;
    }
  }
  {
#line 2076
  __cil_tmp162 = DoCloseHandle(wvc_file.file);
  }
#line 2076
  if (out2filename) {
#line 2076
    if (! __cil_tmp162) {
      {
#line 2077
      error_line("can\'t close correction file!");
      }
#line 2079
      if (result == 0) {
#line 2080
        result = 1;
      }
    }
  }
#line 2086
  if (result == 0) {
#line 2086
    if (verify_mode) {
#line 2087
      if (use_tempfiles) {
#line 2087
        tmp___20 = outfilename_temp;
      } else {
#line 2087
        tmp___20 = outfilename;
      }
      {
#line 2087
      __cil_tmp164 = WavpackLossyBlocks(wpc);
      }
#line 2087
      if (! __cil_tmp164) {
#line 2087
        tmp___21 = (unsigned char *)md5_digest;
      } else {
#line 2087
        tmp___21 = (unsigned char *)((void *)0);
      }
      {
#line 2087
      __cil_tmp166 = verify_audio(tmp___20, tmp___21);
#line 2087
      result = __cil_tmp166;
      }
    }
  }
#line 2091
  if (result != 0) {
#line 2092
    if (use_tempfiles) {
#line 2092
      tmp___22 = outfilename_temp;
    } else {
#line 2092
      tmp___22 = outfilename;
    }
    {
#line 2092
    DoDeleteFile(tmp___22);
    }
#line 2094
    if (out2filename) {
#line 2095
      if (use_tempfiles) {
#line 2095
        tmp___23 = out2filename_temp;
      } else {
#line 2095
        tmp___23 = out2filename;
      }
      {
#line 2095
      DoDeleteFile(tmp___23);
      }
    }
    {
#line 2097
    WavpackCloseFile(wpc);
    }
#line 2098
    return (result);
  }
#line 2104
  if (use_tempfiles) {
    {
#line 2115
    __cil_tmp169 = rename((char const   *)outfilename_temp, (char const   *)outfilename);
    }
#line 2115
    if (__cil_tmp169) {
      {
#line 2116
      error_line("can not rename temp file %s to %s!", outfilename_temp, outfilename);
#line 2117
      result = 1;
      }
    }
#line 2120
    if (out2filename) {
      {
#line 2131
      __cil_tmp170 = rename((char const   *)out2filename_temp, (char const   *)out2filename);
      }
#line 2131
      if (__cil_tmp170) {
        {
#line 2132
        error_line("can not rename temp file %s to %s!s?dU", out2filename_temp, out2filename);
#line 2133
        result = 1;
        }
      }
    }
    {
#line 2137
    free(outfilename_temp);
    }
#line 2138
    if (out2filename) {
      {
#line 2138
      free(out2filename_temp);
      }
    }
#line 2140
    if (result != 0) {
      {
#line 2141
      WavpackCloseFile(wpc);
      }
#line 2142
      return (result);
    }
  }
#line 2146
  if (result == 0) {
#line 2146
    if (copy_time___0) {
      {
#line 2147
      __cil_tmp172 = copy_timestamp((char const   *)infilename, (char const   *)out2filename);
      }
      {
#line 2147
      __cil_tmp171 = copy_timestamp((char const   *)infilename, (char const   *)outfilename);
      }
#line 2147
      if (out2filename) {
#line 2147
        if (! __cil_tmp172) {
          {
          {
#line 2149
          error_line("failure copying time stamp!?dU");
          }
          }
        } else {
#line 2147
          goto _L___63;
        }
      } else
      _L___63: /* CIL Label */ 
#line 2147
      if (! __cil_tmp171) {
        {
        {
#line 2149
        error_line("failure copying time stamp!?dU");
        }
        }
      }
    }
  }
#line 2153
  if (result == 0) {
#line 2153
    if (delete_source___0) {
      {
#line 2154
      __cil_tmp174 = DoDeleteFile(infilename);
#line 2154
      res___4 = __cil_tmp174;
      }
#line 2156
      if (! quiet_mode___2) {
        _L___64: /* CIL Label */ 
#line 2157
        if (res___4) {
#line 2157
          tmp___24 = "deleted";
        } else {
#line 2157
          tmp___24 = "can\'t delete";
        }
        {
#line 2157
        error_line("%s source file %sSp?dU", tmp___24, infilename);
        }
      } else
#line 2156
      if (! res___4) {
#line 2156
        goto _L___64;
      }
    }
  }
  {
#line 2169
  gettimeofday(& time2, & timez);
#line 2170
  dtime = (double )time2.tv_sec + (double )time2.tv_usec / 1000000.;
#line 2171
  dtime -= (double )time1.tv_sec + (double )time1.tv_usec / 1000000.;
#line 2174
  __cil_tmp176 = WavpackGetEncodedNoise(wpc, (double *)((void *)0));
  }
#line 2174
  if (loc_config.flags & 8388608) {
#line 2174
    if (__cil_tmp176 > 0.) {
      {
#line 2175
      __cil_tmp178 = WavpackGetBitsPerSample(wpc);
#line 2175
      full_scale_bits = __cil_tmp178;
#line 2176
      full_scale_rms = 0.5;
      }
      {
#line 2178
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2178
        __cil_tmp182 = full_scale_bits;
#line 2178
        full_scale_bits --;
#line 2178
        if (! __cil_tmp182) {
#line 2178
          goto while_break___10;
        }
#line 2179
        full_scale_rms *= 2.;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 2181
      full_scale_rms = (full_scale_rms * (full_scale_rms - 1.)) * 0.5;
#line 2182
      sum = WavpackGetEncodedNoise(wpc, & peak);
#line 2184
      __cil_tmp184 = WavpackGetNumSamples64(wpc);
#line 2184
      __cil_tmp185 = log10((sum / (double )__cil_tmp184) / full_scale_rms);
      }
      {
#line 2184
      __cil_tmp186 = log10(peak / full_scale_rms);
#line 2184
      error_line("ave noise = %.2f dB, peak noise = %.2f dB", __cil_tmp185 * (double )10,
                 __cil_tmp186 * (double )10);
      }
    }
  }
#line 2189
  if (! quiet_mode___2) {
#line 2190
    cratio = "\005";
#line 2192
    if (imported_tag_items) {
      {
#line 2193
      error_line("successfully imported %d items from ID3v2 tag", imported_tag_items);
      }
    }
#line 2195
    if (loc_config.flags & 134217728) {
#line 2196
      md5_string = "original md5 signature: 00000000000000000000000000000000\f";
#line 2199
      i___3 = 0;
      {
#line 2199
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 2199
        if (! (i___3 < 16)) {
#line 2199
          goto while_break___11;
        }
        {
#line 2200
        sprintf(((char *)md5_string + 24) + i___3 * 2, "%02xdU", (int )md5_digest[i___3]);
        }
#line 2199
        i___3 ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 2202
      error_line((char *)md5_string);
      }
    }
#line 2205
    if (outfilename) {
#line 2205
      if ((int )*outfilename != 45) {
        {
#line 2206
        __cil_tmp194 = strlen((char const   *)outfilename);
        }
#line 2206
        if (__cil_tmp194 > 30UL) {
          {
#line 2206
          __cil_tmp195 = filespec_name(outfilename);
#line 2206
          tmp___25 = __cil_tmp195;
          }
        } else {
#line 2206
          tmp___25 = outfilename;
        }
#line 2206
        file = tmp___25;
#line 2207
        if (wvc_file.bytes_written) {
#line 2207
          tmp___26 = " (+.wvc)\323\001 ";
        } else {
#line 2207
          tmp___26 = "\220";
        }
#line 2207
        fext = tmp___26;
#line 2208
        if (verify_mode) {
#line 2208
          tmp___27 = "created (and verified)";
        } else {
#line 2208
          tmp___27 = "created";
        }
#line 2208
        oper = tmp___27;
      } else {
#line 2205
        goto _L___65;
      }
    } else {
      _L___65: /* CIL Label */ 
#line 2211
      if ((int )*infilename == 45) {
#line 2211
        tmp___29 = "stdinU";
      } else {
        {
#line 2211
        __cil_tmp199 = strlen((char const   *)infilename);
        }
#line 2211
        if (__cil_tmp199 > 30UL) {
          {
#line 2211
          __cil_tmp200 = filespec_name(infilename);
#line 2211
          tmp___28 = __cil_tmp200;
          }
        } else {
#line 2211
          tmp___28 = infilename;
        }
#line 2211
        tmp___29 = (char const   *)tmp___28;
      }
#line 2211
      file = (int )tmp___29;
#line 2212
      fext = "\220";
#line 2213
      oper = "packed";
    }
    {
#line 2216
    __cil_tmp203 = WavpackLossyBlocks(wpc);
    }
#line 2216
    if (__cil_tmp203) {
      {
#line 2217
      cmode = "lossyU";
#line 2219
      __cil_tmp204 = WavpackGetAverageBitrate(wpc, 1);
      }
#line 2219
      if (__cil_tmp204 != 0.) {
        {
#line 2220
        __cil_tmp205 = WavpackGetAverageBitrate(wpc, 1);
#line 2220
        sprintf((char *)cratio, ", %d kbpsus?dU", (int )(__cil_tmp205 / 1000.));
        }
      }
    } else {
      {
#line 2223
      cmode = "lossless\220";
#line 2225
      __cil_tmp206 = WavpackGetRatio(wpc);
      }
#line 2225
      if (__cil_tmp206 != 0.) {
        {
#line 2226
        __cil_tmp207 = WavpackGetRatio(wpc);
#line 2226
        sprintf((char *)cratio, ", %.2f%%\240", 100. - __cil_tmp207 * 100.);
        }
      }
    }
    {
#line 2229
    error_line("%s %s%s in %.2f secs (%s%s)", oper, file, fext, dtime, cmode, (char *)cratio);
    }
  }
  {
#line 2232
  WavpackCloseFile(wpc);
  }
#line 2233
  return (0);
}
}
#line 2242
static void reorder_channels(void *data , unsigned char *order , int num_chans , int num_samples ,
                             int bytes_per_sample ) ;
#line 2245
static void load_samples(int32_t *dst , void *src , int qmode , int bps , int count ) ;
#line 2246
static void *store_samples___0(void *dst , int32_t *src , int qmode , int bps , int count ) ;
#line 2247
static void unreorder_channels___0(int32_t *data , unsigned char *order , int num_chans ,
                                   int num_samples ) ;
#line 2251 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static int pack_audio(WavpackContext *wpc , FILE *infile , int qmode , unsigned char *new_order ,
                      unsigned char *md5_digest_source ) 
{ 
  int64_t samples_remaining ;
  int64_t input_samples ;
  double progress ;
  int bytes_per_sample ;
  int32_t *sample_buffer ;
  unsigned char *input_buffer ;
  MD5_CTX md5_context ;
  int32_t quantize_bit_mask ;
  double fquantize_scale ;
  double fquantize_iscale ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  int64_t __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int float_norm_exp ;
  int __cil_tmp27 ;
  double __cil_tmp28 ;
  double __cil_tmp29 ;
  uint32_t bytes_to_read ;
  uint32_t bytes_read ;
  int32_t sample_count ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int bps ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  unsigned int x ;
  unsigned int l ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int32_t offset ;
  int shift ;
  int __cil_tmp46 ;
  unsigned int __cil_tmp47 ;
  unsigned int __cil_tmp48 ;
  float f ;
  double __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  char *__cil_tmp55 ;
  int __cil_tmp56 ;
  double __cil_tmp57 ;
  double __cil_tmp58 ;
  double __cil_tmp59 ;
  int nobs ;
  double __cil_tmp61 ;
  double __cil_tmp62 ;
  char const   *tmp ;
  int __cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 2253
  input_samples = (int64_t )65536;
#line 2254
  progress = - 1.;
#line 2259
  quantize_bit_mask = 0;
#line 2260
  fquantize_scale = 1.;
#line 2260
  fquantize_iscale = 1.;
  {
#line 2264
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2264
    __cil_tmp16 = WavpackGetNumChannels(wpc);
    }
#line 2264
    if (! (((unsigned long )input_samples * sizeof(int32_t )) * (unsigned long )__cil_tmp16 > 2097152UL)) {
#line 2264
      goto while_break;
    }
#line 2265
    input_samples >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2267
  if (md5_digest_source) {
    {
#line 2268
    MD5Init(& md5_context);
    }
  }
  {
#line 2270
  WavpackPackInit(wpc);
#line 2271
  __cil_tmp18 = WavpackGetNumChannels(wpc);
  }
  {
#line 2271
  __cil_tmp17 = WavpackGetBytesPerSample(wpc);
#line 2271
  bytes_per_sample = __cil_tmp17 * __cil_tmp18;
#line 2272
  input_buffer = (unsigned char *)malloc((unsigned long )((uint32_t )input_samples * (unsigned int )bytes_per_sample));
#line 2273
  __cil_tmp20 = WavpackGetNumChannels(wpc);
#line 2273
  __cil_tmp21 = malloc(((unsigned long )((uint32_t )input_samples) * sizeof(int32_t )) * (unsigned long )__cil_tmp20);
#line 2273
  sample_buffer = __cil_tmp21;
#line 2274
  samples_remaining = WavpackGetNumSamples64(wpc);
#line 2276
  __cil_tmp23 = WavpackGetBytesPerSample(wpc);
  }
#line 2276
  if (quantize_bits) {
#line 2276
    if (quantize_bits < __cil_tmp23 * 8) {
      {
#line 2277
      __cil_tmp24 = WavpackGetBytesPerSample(wpc);
#line 2277
      quantize_bit_mask = ~ ((1 << (__cil_tmp24 * 8 - quantize_bits)) - 1);
#line 2278
      __cil_tmp25 = WavpackGetMode(wpc);
      }
#line 2278
      if (8 == (__cil_tmp25 & 8)) {
        {
#line 2279
        __cil_tmp27 = WavpackGetFloatNormExp(wpc);
#line 2279
        float_norm_exp = __cil_tmp27;
#line 2280
        fquantize_scale = exp2((double )((quantize_bits + 126) - float_norm_exp));
#line 2281
        fquantize_iscale = exp2((double )((float_norm_exp - 126) - quantize_bits));
        }
      }
    }
  }
  {
#line 2285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2286
    bytes_read = (uint32_t )0;
#line 2289
    if (qmode & 2048) {
#line 2290
      bytes_to_read = (uint32_t )input_samples * (unsigned int )bytes_per_sample;
    } else
#line 2289
    if (samples_remaining > input_samples) {
#line 2290
      bytes_to_read = (uint32_t )input_samples * (unsigned int )bytes_per_sample;
    } else {
#line 2292
      bytes_to_read = (uint32_t )samples_remaining * (unsigned int )bytes_per_sample;
    }
    {
#line 2294
    samples_remaining -= (long )(bytes_to_read / (unsigned int )bytes_per_sample);
#line 2295
    DoReadFile(infile, input_buffer, bytes_to_read, & bytes_read);
#line 2296
    sample_count = (int32_t )(bytes_read / (unsigned int )bytes_per_sample);
    }
#line 2303
    if (new_order) {
#line 2303
      if (! (qmode & 8)) {
        {
#line 2304
        __cil_tmp33 = WavpackGetNumChannels(wpc);
        }
        {
#line 2304
        __cil_tmp34 = WavpackGetBytesPerSample(wpc);
#line 2304
        reorder_channels(input_buffer, new_order, __cil_tmp33, sample_count, __cil_tmp34);
        }
      }
    }
#line 2307
    if (md5_digest_source) {
#line 2307
      if (quantize_bit_mask == 0) {
        {
#line 2308
        MD5Update(& md5_context, input_buffer, (unsigned int )(sample_count * bytes_per_sample));
        }
      }
    }
#line 2314
    if (new_order) {
#line 2314
      if (qmode & 8) {
        {
#line 2315
        __cil_tmp35 = WavpackGetNumChannels(wpc);
        }
        {
#line 2315
        __cil_tmp36 = WavpackGetBytesPerSample(wpc);
#line 2315
        reorder_channels(input_buffer, new_order, __cil_tmp35, sample_count, __cil_tmp36);
        }
      }
    }
#line 2318
    if (! sample_count) {
#line 2319
      goto while_break___0;
    }
#line 2321
    if (sample_count) {
      {
#line 2322
      __cil_tmp38 = WavpackGetBytesPerSample(wpc);
#line 2322
      bps = __cil_tmp38;
#line 2324
      __cil_tmp39 = WavpackGetNumChannels(wpc);
#line 2324
      load_samples(sample_buffer, input_buffer, qmode, bps, sample_count * __cil_tmp39);
      }
#line 2326
      if (quantize_bit_mask) {
        {
#line 2327
        __cil_tmp42 = WavpackGetNumChannels(wpc);
#line 2327
        l = (unsigned int )(sample_count * __cil_tmp42);
#line 2328
        __cil_tmp43 = WavpackGetMode(wpc);
        }
#line 2328
        if (0 == (__cil_tmp43 & 8)) {
#line 2329
          if (quantize_round) {
            {
#line 2330
            offset = (quantize_bit_mask >> 1) ^ quantize_bit_mask;
#line 2331
            __cil_tmp46 = WavpackGetBytesPerSample(wpc);
#line 2331
            shift = 32 - __cil_tmp46 * 8;
#line 2333
            x = (unsigned int )0;
            }
            {
#line 2333
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 2333
              if (! (x < l)) {
#line 2333
                goto while_break___1;
              }
#line 2334
              if (*(sample_buffer + x) < 0) {
#line 2335
                *(sample_buffer + x) += offset;
              } else
#line 2334
              if ((*(sample_buffer + x) + offset) << shift > 0) {
#line 2335
                *(sample_buffer + x) += offset;
              }
#line 2333
              x ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 2338
          x = (unsigned int )0;
          {
#line 2338
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2338
            if (! (x < l)) {
#line 2338
              goto while_break___2;
            }
#line 2338
            *(sample_buffer + x) &= quantize_bit_mask;
#line 2338
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 2341
          x = (unsigned int )0;
          {
#line 2341
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2341
            if (! (x < l)) {
#line 2341
              goto while_break___3;
            }
            {
#line 2342
            f = *((float *)(sample_buffer + x));
#line 2343
            __cil_tmp50 = floor((double )f * fquantize_scale + 0.5);
#line 2343
            *((float *)(sample_buffer + x)) = (float )(__cil_tmp50 * fquantize_iscale);
            }
#line 2341
            x ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 2347
        if (md5_digest_source) {
          {
#line 2348
          __cil_tmp52 = WavpackGetNumChannels(wpc);
#line 2348
          store_samples___0(input_buffer, sample_buffer, qmode, bps, sample_count * __cil_tmp52);
#line 2349
          __cil_tmp53 = WavpackGetBytesPerSample(wpc);
#line 2349
          MD5Update(& md5_context, input_buffer, (unsigned int )__cil_tmp53 * l);
          }
        }
      }
    }
    {
#line 2354
    __cil_tmp54 = WavpackPackSamples(wpc, sample_buffer, (uint32_t )sample_count);
    }
#line 2354
    if (! __cil_tmp54) {
      {
#line 2355
      __cil_tmp55 = WavpackGetErrorMessage(wpc);
#line 2355
      error_line("%s", __cil_tmp55);
#line 2356
      free(sample_buffer);
#line 2357
      free(input_buffer);
      }
#line 2358
      return (2);
    }
    {
#line 2361
    __cil_tmp56 = check_break();
    }
#line 2361
    if (__cil_tmp56) {
      {
#line 2365
      fprintf(stderr, "\n");
#line 2367
      fflush(stderr);
#line 2368
      free(sample_buffer);
#line 2369
      free(input_buffer);
      }
#line 2370
      return (1);
    }
    {
#line 2373
    __cil_tmp58 = WavpackGetProgress(wpc);
#line 2373
    __cil_tmp59 = floor(__cil_tmp58 * encode_time_percent + 0.5);
    }
    {
#line 2373
    __cil_tmp57 = WavpackGetProgress(wpc);
    }
#line 2373
    if (__cil_tmp57 != - 1.) {
#line 2373
      if (progress != __cil_tmp59) {
        {
#line 2375
        nobs = progress == - 1.;
#line 2377
        __cil_tmp61 = WavpackGetProgress(wpc);
#line 2377
        __cil_tmp62 = floor(__cil_tmp61 * encode_time_percent + 0.5);
#line 2377
        progress = __cil_tmp62;
#line 2378
        display_progress___0(progress / 100.);
        }
#line 2380
        if (! quiet_mode___2) {
#line 2381
          if (nobs) {
#line 2381
            tmp = " ";
          } else {
#line 2381
            tmp = "\b\b\b\b\b\b\b\b\b\b\b\b";
          }
          {
#line 2381
          fprintf(stderr, "%s%3d%% done...", tmp, (int )progress);
#line 2383
          fflush(stderr);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2388
  free(sample_buffer);
#line 2389
  free(input_buffer);
#line 2391
  __cil_tmp64 = WavpackFlushSamples(wpc);
  }
#line 2391
  if (! __cil_tmp64) {
    {
#line 2392
    __cil_tmp65 = WavpackGetErrorMessage(wpc);
#line 2392
    error_line("%st?dU", __cil_tmp65);
    }
#line 2393
    return (2);
  }
#line 2396
  if (md5_digest_source) {
    {
#line 2397
    MD5Final(md5_digest_source, & md5_context);
    }
  }
#line 2399
  return (0);
}
}
#line 2402 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static unsigned char const   bit_reverse_table___0[256]  = 
#line 2402
  {      (unsigned char )0,      (unsigned char )128,      (unsigned char )64,      (unsigned char )192, 
        (unsigned char )32,      (unsigned char )160,      (unsigned char )96,      (unsigned char )224, 
        (unsigned char )16,      (unsigned char )144,      (unsigned char )80,      (unsigned char )208, 
        (unsigned char )48,      (unsigned char )176,      (unsigned char )112,      (unsigned char )240, 
        (unsigned char )8,      (unsigned char )136,      (unsigned char )72,      (unsigned char )200, 
        (unsigned char )40,      (unsigned char )168,      (unsigned char )104,      (unsigned char )232, 
        (unsigned char )24,      (unsigned char )152,      (unsigned char )88,      (unsigned char )216, 
        (unsigned char )56,      (unsigned char )184,      (unsigned char )120,      (unsigned char )248, 
        (unsigned char )4,      (unsigned char )132,      (unsigned char )68,      (unsigned char )196, 
        (unsigned char )36,      (unsigned char )164,      (unsigned char )100,      (unsigned char )228, 
        (unsigned char )20,      (unsigned char )148,      (unsigned char )84,      (unsigned char )212, 
        (unsigned char )52,      (unsigned char )180,      (unsigned char )116,      (unsigned char )244, 
        (unsigned char )12,      (unsigned char )140,      (unsigned char )76,      (unsigned char )204, 
        (unsigned char )44,      (unsigned char )172,      (unsigned char )108,      (unsigned char )236, 
        (unsigned char )28,      (unsigned char )156,      (unsigned char )92,      (unsigned char )220, 
        (unsigned char )60,      (unsigned char )188,      (unsigned char )124,      (unsigned char )252, 
        (unsigned char )2,      (unsigned char )130,      (unsigned char )66,      (unsigned char )194, 
        (unsigned char )34,      (unsigned char )162,      (unsigned char )98,      (unsigned char )226, 
        (unsigned char )18,      (unsigned char )146,      (unsigned char )82,      (unsigned char )210, 
        (unsigned char )50,      (unsigned char )178,      (unsigned char )114,      (unsigned char )242, 
        (unsigned char )10,      (unsigned char )138,      (unsigned char )74,      (unsigned char )202, 
        (unsigned char )42,      (unsigned char )170,      (unsigned char )106,      (unsigned char )234, 
        (unsigned char )26,      (unsigned char )154,      (unsigned char )90,      (unsigned char )218, 
        (unsigned char )58,      (unsigned char )186,      (unsigned char )122,      (unsigned char )250, 
        (unsigned char )6,      (unsigned char )134,      (unsigned char )70,      (unsigned char )198, 
        (unsigned char )38,      (unsigned char )166,      (unsigned char )102,      (unsigned char )230, 
        (unsigned char )22,      (unsigned char )150,      (unsigned char )86,      (unsigned char )214, 
        (unsigned char )54,      (unsigned char )182,      (unsigned char )118,      (unsigned char )246, 
        (unsigned char )14,      (unsigned char )142,      (unsigned char )78,      (unsigned char )206, 
        (unsigned char )46,      (unsigned char )174,      (unsigned char )110,      (unsigned char )238, 
        (unsigned char )30,      (unsigned char )158,      (unsigned char )94,      (unsigned char )222, 
        (unsigned char )62,      (unsigned char )190,      (unsigned char )126,      (unsigned char )254, 
        (unsigned char )1,      (unsigned char )129,      (unsigned char )65,      (unsigned char )193, 
        (unsigned char )33,      (unsigned char )161,      (unsigned char )97,      (unsigned char )225, 
        (unsigned char )17,      (unsigned char )145,      (unsigned char )81,      (unsigned char )209, 
        (unsigned char )49,      (unsigned char )177,      (unsigned char )113,      (unsigned char )241, 
        (unsigned char )9,      (unsigned char )137,      (unsigned char )73,      (unsigned char )201, 
        (unsigned char )41,      (unsigned char )169,      (unsigned char )105,      (unsigned char )233, 
        (unsigned char )25,      (unsigned char )153,      (unsigned char )89,      (unsigned char )217, 
        (unsigned char )57,      (unsigned char )185,      (unsigned char )121,      (unsigned char )249, 
        (unsigned char )5,      (unsigned char )133,      (unsigned char )69,      (unsigned char )197, 
        (unsigned char )37,      (unsigned char )165,      (unsigned char )101,      (unsigned char )229, 
        (unsigned char )21,      (unsigned char )149,      (unsigned char )85,      (unsigned char )213, 
        (unsigned char )53,      (unsigned char )181,      (unsigned char )117,      (unsigned char )245, 
        (unsigned char )13,      (unsigned char )141,      (unsigned char )77,      (unsigned char )205, 
        (unsigned char )45,      (unsigned char )173,      (unsigned char )109,      (unsigned char )237, 
        (unsigned char )29,      (unsigned char )157,      (unsigned char )93,      (unsigned char )221, 
        (unsigned char )61,      (unsigned char )189,      (unsigned char )125,      (unsigned char )253, 
        (unsigned char )3,      (unsigned char )131,      (unsigned char )67,      (unsigned char )195, 
        (unsigned char )35,      (unsigned char )163,      (unsigned char )99,      (unsigned char )227, 
        (unsigned char )19,      (unsigned char )147,      (unsigned char )83,      (unsigned char )211, 
        (unsigned char )51,      (unsigned char )179,      (unsigned char )115,      (unsigned char )243, 
        (unsigned char )11,      (unsigned char )139,      (unsigned char )75,      (unsigned char )203, 
        (unsigned char )43,      (unsigned char )171,      (unsigned char )107,      (unsigned char )235, 
        (unsigned char )27,      (unsigned char )155,      (unsigned char )91,      (unsigned char )219, 
        (unsigned char )59,      (unsigned char )187,      (unsigned char )123,      (unsigned char )251, 
        (unsigned char )7,      (unsigned char )135,      (unsigned char )71,      (unsigned char )199, 
        (unsigned char )39,      (unsigned char )167,      (unsigned char )103,      (unsigned char )231, 
        (unsigned char )23,      (unsigned char )151,      (unsigned char )87,      (unsigned char )215, 
        (unsigned char )55,      (unsigned char )183,      (unsigned char )119,      (unsigned char )247, 
        (unsigned char )15,      (unsigned char )143,      (unsigned char )79,      (unsigned char )207, 
        (unsigned char )47,      (unsigned char )175,      (unsigned char )111,      (unsigned char )239, 
        (unsigned char )31,      (unsigned char )159,      (unsigned char )95,      (unsigned char )223, 
        (unsigned char )63,      (unsigned char )191,      (unsigned char )127,      (unsigned char )255};
#line 2423 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static int pack_dsd_audio(WavpackContext *wpc , FILE *infile , int qmode , unsigned char *new_order ,
                          unsigned char *md5_digest_source ) 
{ 
  int64_t samples_remaining ;
  double progress ;
  int num_channels ;
  int32_t *sample_buffer ;
  unsigned char *input_buffer ;
  MD5_CTX md5_context ;
  int __cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int64_t __cil_tmp15 ;
  uint32_t bytes_to_read ;
  uint32_t bytes_read ;
  int32_t sample_count ;
  int32_t sindex ;
  int32_t *sptr ;
  int32_t non_null ;
  unsigned char *srcp ;
  int cc ;
  int __cil_tmp24 ;
  int32_t *__cil_tmp25 ;
  int tmp ;
  int32_t __cil_tmp27 ;
  int32_t scount ;
  int32_t *sptr___0 ;
  unsigned char *iptr ;
  int32_t __cil_tmp31 ;
  int32_t *__cil_tmp32 ;
  unsigned char *__cil_tmp33 ;
  int __cil_tmp34 ;
  char *__cil_tmp35 ;
  int __cil_tmp36 ;
  double __cil_tmp37 ;
  double __cil_tmp38 ;
  double __cil_tmp39 ;
  int nobs ;
  double __cil_tmp41 ;
  double __cil_tmp42 ;
  char const   *tmp___0 ;
  int __cil_tmp44 ;
  char *__cil_tmp45 ;

  {
#line 2426
  progress = - 1.;
#line 2432
  if (md5_digest_source) {
    {
#line 2433
    MD5Init(& md5_context);
    }
  }
  {
#line 2435
  WavpackPackInit(wpc);
#line 2436
  num_channels = WavpackGetNumChannels(wpc);
#line 2437
  input_buffer = (unsigned char *)malloc((unsigned long )(4096 * num_channels));
#line 2438
  sample_buffer = (int32_t *)malloc((4096UL * sizeof(int32_t )) * (unsigned long )num_channels);
#line 2439
  samples_remaining = WavpackGetNumSamples64(wpc);
  }
  {
#line 2441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2441
    if (! samples_remaining) {
#line 2441
      goto while_break;
    }
#line 2442
    bytes_read = (uint32_t )0;
#line 2445
    if (qmode & 64) {
#line 2446
      bytes_to_read = (uint32_t )(4096 * num_channels);
    } else
#line 2445
    if (samples_remaining > 4096L) {
#line 2446
      bytes_to_read = (uint32_t )(4096 * num_channels);
    } else {
#line 2448
      bytes_to_read = (uint32_t )samples_remaining * (unsigned int )num_channels;
    }
    {
#line 2450
    DoReadFile(infile, input_buffer, bytes_to_read, & bytes_read);
    }
#line 2452
    if (qmode & 64) {
#line 2453
      if (bytes_read != bytes_to_read) {
        {
#line 2454
        error_line("incomplete DSD block!");
#line 2455
        sample_count = 0;
#line 2455
        samples_remaining = (int64_t )sample_count;
        }
      } else
#line 2457
      if (samples_remaining < 4096L) {
#line 2458
        sample_count = (int32_t )samples_remaining;
      } else {
#line 2460
        sample_count = 4096;
      }
    } else {
#line 2463
      sample_count = (int32_t )(bytes_read / (unsigned int )num_channels);
    }
#line 2465
    samples_remaining -= (long )sample_count;
#line 2472
    if (new_order) {
#line 2472
      if (! (qmode & 8)) {
#line 2473
        if (qmode & 64) {
          {
#line 2474
          reorder_channels(input_buffer, new_order, num_channels, 1, 4096);
          }
        } else {
          {
#line 2476
          reorder_channels(input_buffer, new_order, num_channels, sample_count, 1);
          }
        }
      }
    }
#line 2479
    if (md5_digest_source) {
      {
#line 2480
      MD5Update(& md5_context, input_buffer, bytes_read);
      }
    }
#line 2482
    if (! sample_count) {
#line 2483
      goto while_break;
    }
#line 2485
    if (sample_count) {
#line 2486
      if (qmode & 64) {
#line 2487
        sptr = sample_buffer;
#line 2487
        non_null = 0;
#line 2489
        sindex = 0;
        {
#line 2489
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2489
          if (! (sindex < 4096)) {
#line 2489
            goto while_break___0;
          }
#line 2490
          srcp = input_buffer + sindex;
#line 2493
          cc = num_channels;
          {
#line 2493
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2493
            if (! __cil_tmp24) {
#line 2493
              goto while_break___1;
            }
#line 2494
            if (sindex < sample_count) {
#line 2495
              if (qmode & 16) {
#line 2495
                tmp = (int )bit_reverse_table___0[*srcp];
              } else {
#line 2495
                tmp = (int )*srcp;
              }
#line 2495
              __cil_tmp25 = sptr;
#line 2495
              sptr ++;
#line 2495
              *__cil_tmp25 = tmp;
            } else
#line 2496
            if (*srcp) {
#line 2497
              non_null ++;
            }
#line 2493
            srcp += 4096;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 2489
          sindex ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2500
        if (non_null) {
          {
#line 2501
          error_line("blocks not padded with NULLs, MD5 will not match!\243t?dU");
          }
        }
      } else {
#line 2504
        scount = sample_count * num_channels;
#line 2504
        sptr___0 = sample_buffer;
#line 2505
        iptr = input_buffer;
        {
#line 2507
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2507
          __cil_tmp31 = scount;
#line 2507
          scount --;
#line 2507
          if (! __cil_tmp31) {
#line 2507
            goto while_break___2;
          }
#line 2508
          __cil_tmp33 = iptr;
#line 2508
          iptr ++;
#line 2508
          __cil_tmp32 = sptr___0;
#line 2508
          sptr___0 ++;
#line 2508
          *__cil_tmp32 = (int32_t )*__cil_tmp33;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    {
#line 2512
    __cil_tmp34 = WavpackPackSamples(wpc, sample_buffer, (uint32_t )sample_count);
    }
#line 2512
    if (! __cil_tmp34) {
      {
#line 2513
      __cil_tmp35 = WavpackGetErrorMessage(wpc);
#line 2513
      error_line("%s", __cil_tmp35);
#line 2514
      free(sample_buffer);
#line 2515
      free(input_buffer);
      }
#line 2516
      return (2);
    }
    {
#line 2519
    __cil_tmp36 = check_break();
    }
#line 2519
    if (__cil_tmp36) {
      {
#line 2523
      fprintf(stderr, "\n\265t?dU");
#line 2525
      fflush(stderr);
#line 2526
      free(sample_buffer);
#line 2527
      free(input_buffer);
      }
#line 2528
      return (1);
    }
    {
#line 2531
    __cil_tmp38 = WavpackGetProgress(wpc);
#line 2531
    __cil_tmp39 = floor(__cil_tmp38 * encode_time_percent + 0.5);
    }
    {
#line 2531
    __cil_tmp37 = WavpackGetProgress(wpc);
    }
#line 2531
    if (__cil_tmp37 != - 1.) {
#line 2531
      if (progress != __cil_tmp39) {
        {
#line 2533
        nobs = progress == - 1.;
#line 2535
        __cil_tmp41 = WavpackGetProgress(wpc);
#line 2535
        __cil_tmp42 = floor(__cil_tmp41 * encode_time_percent + 0.5);
#line 2535
        progress = __cil_tmp42;
#line 2536
        display_progress___0(progress / 100.);
        }
#line 2538
        if (! quiet_mode___2) {
#line 2539
          if (nobs) {
#line 2539
            tmp___0 = " ";
          } else {
#line 2539
            tmp___0 = "\b\b\b\b\b\b\b\b\b\b\b\bdU";
          }
          {
#line 2539
          fprintf(stderr, "%s%3d%% done...", tmp___0, (int )progress);
#line 2541
          fflush(stderr);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2546
  free(sample_buffer);
#line 2547
  free(input_buffer);
#line 2549
  __cil_tmp44 = WavpackFlushSamples(wpc);
  }
#line 2549
  if (! __cil_tmp44) {
    {
#line 2550
    __cil_tmp45 = WavpackGetErrorMessage(wpc);
#line 2550
    error_line("%st?dU", __cil_tmp45);
    }
#line 2551
    return (2);
  }
#line 2554
  if (md5_digest_source) {
    {
#line 2555
    MD5Final(md5_digest_source, & md5_context);
    }
  }
#line 2557
  return (0);
}
}
#line 2567 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static int repack_file(char *infilename , char *outfilename , char *out2filename ,
                       WavpackConfig *config ) 
{ 
  int output_lossless ;
  int flags ;
  int imported_tag_items ;
  char *outfilename_temp ;
  char *out2filename_temp ;
  int use_tempfiles ;
  int input_mode ;
  unsigned char md5_verify[16] ;
  unsigned char md5_display[16] ;
  WavpackConfig loc_config ;
  WavpackContext *infile ;
  WavpackContext *outfile ;
  write_id wv_file ;
  write_id wvc_file ;
  int64_t total_samples ;
  unsigned char *chan_ids ;
  char error[80] ;
  double dtime ;
  int result ;
  struct timeval time1 ;
  struct timeval time2 ;
  struct timezone timez ;
  WavpackContext *__cil_tmp27 ;
  int __cil_tmp28 ;
  int64_t __cil_tmp29 ;
  write_id *tmp ;
  WavpackContext *__cil_tmp31 ;
  FILE *__cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  char *__cil_tmp34 ;
  char *tmp___0 ;
  unsigned long __cil_tmp36 ;
  char *__cil_tmp37 ;
  char *tmp___1 ;
  char __cil_tmp39 ;
  FILE *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  char *__cil_tmp42 ;
  char *tmp___2 ;
  char __cil_tmp44 ;
  FILE *testfile ;
  int count ;
  unsigned long __cil_tmp47 ;
  void *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  void *__cil_tmp50 ;
  char *__cil_tmp51 ;
  int __cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  FILE *__cil_tmp58 ;
  FILE *__cil_tmp59 ;
  char *tmp___3 ;
  FILE *__cil_tmp61 ;
  char *tmp___4 ;
  unsigned long __cil_tmp63 ;
  char *__cil_tmp64 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  unsigned long __cil_tmp67 ;
  char *__cil_tmp68 ;
  char *tmp___7 ;
  char *__cil_tmp70 ;
  unsigned long __cil_tmp71 ;
  char *__cil_tmp72 ;
  char *tmp___8 ;
  char *__cil_tmp74 ;
  unsigned char __cil_tmp75 ;
  uint32_t __cil_tmp76 ;
  unsigned char *__cil_tmp77 ;
  uint32_t __cil_tmp78 ;
  int __cil_tmp79 ;
  char *__cil_tmp80 ;
  char *tmp___9 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  uint32_t __cil_tmp86 ;
  int __cil_tmp87 ;
  void *__cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  char *__cil_tmp91 ;
  char *tmp___10 ;
  uint32_t layout ;
  uint32_t __cil_tmp94 ;
  unsigned char order[256] ;
  uint32_t __cil_tmp96 ;
  char *tmp___11 ;
  FILE *__cil_tmp98 ;
  char *tmp___12 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int64_t __cil_tmp103 ;
  unsigned char md5_source[16] ;
  int __cil_tmp105 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  uint32_t __cil_tmp108 ;
  unsigned char *buffer ;
  unsigned char *__cil_tmp110 ;
  int wrapper_size ;
  uint32_t __cil_tmp112 ;
  int __cil_tmp113 ;
  char *__cil_tmp114 ;
  int __cil_tmp115 ;
  int32_t bytes_used ;
  int32_t id3_res ;
  char error___66[80] ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;
  int __cil_tmp121 ;
  char *__cil_tmp122 ;
  int num_binary_items ;
  int __cil_tmp124 ;
  int num_items ;
  int __cil_tmp126 ;
  int i ;
  int item_len ;
  int value_len ;
  char *item ;
  char *value ;
  int res ;
  int __cil_tmp133 ;
  void *__cil_tmp134 ;
  int __cil_tmp135 ;
  void *__cil_tmp136 ;
  unsigned long __cil_tmp137 ;
  int __cil_tmp138 ;
  void *__cil_tmp139 ;
  unsigned long __cil_tmp140 ;
  int __cil_tmp141 ;
  void *__cil_tmp142 ;
  int __cil_tmp143 ;
  int __cil_tmp144 ;
  void *__cil_tmp145 ;
  int __cil_tmp146 ;
  void *__cil_tmp147 ;
  int __cil_tmp148 ;
  int __cil_tmp149 ;
  int __cil_tmp150 ;
  int __cil_tmp151 ;
  int __cil_tmp152 ;
  char *__cil_tmp153 ;
  int __cil_tmp154 ;
  int __cil_tmp155 ;
  char *tmp___13 ;
  int __cil_tmp157 ;
  unsigned char *tmp___14 ;
  int __cil_tmp159 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int __cil_tmp163 ;
  char *tmp___18 ;
  int __cil_tmp165 ;
  int res___0 ;
  int __cil_tmp167 ;
  int __cil_tmp168 ;
  char const   *tmp___19 ;
  char in2filename[4096] ;
  int __cil_tmp171 ;
  int __cil_tmp172 ;
  char const   *tmp___20 ;
  int __cil_tmp174 ;
  int __cil_tmp175 ;
  double __cil_tmp176 ;
  int full_scale_bits ;
  int __cil_tmp178 ;
  double full_scale_rms ;
  double sum ;
  double peak ;
  int __cil_tmp182 ;
  double __cil_tmp183 ;
  uint32_t __cil_tmp184 ;
  double __cil_tmp185 ;
  double __cil_tmp186 ;
  char *file ;
  char *fext ;
  char *oper ;
  char *cmode ;
  char cratio[16] ;
  char md5_string[57] ;
  int i___0 ;
  unsigned long __cil_tmp194 ;
  char *__cil_tmp195 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  unsigned long __cil_tmp199 ;
  char *__cil_tmp200 ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  int __cil_tmp203 ;
  double __cil_tmp204 ;
  double __cil_tmp205 ;
  double __cil_tmp206 ;
  double __cil_tmp207 ;

  {
#line 2569
  output_lossless = ! (config->flags & 8) || config->flags & 524288;
#line 2570
  flags = 1283;
#line 2570
  imported_tag_items = 0;
#line 2571
  outfilename_temp = (char *)((void *)0);
#line 2571
  out2filename_temp = (char *)((void *)0);
#line 2572
  use_tempfiles = out2filename != (void *)0;
#line 2574
  loc_config = *config;
#line 2577
  total_samples = (int64_t )0;
#line 2590
  if (! (loc_config.qmode & 512)) {
#line 2591
    flags |= 4;
  } else
#line 2590
  if (import_id3___0) {
#line 2591
    flags |= 4;
  }
  {
#line 2599
  infile = WavpackOpenFileInput((char const   *)infilename, (char *)error, flags,
                                0);
  }
#line 2601
  if (! infile) {
    {
#line 2602
    error_line((char *)error);
    }
#line 2603
    return (1);
  }
  {
#line 2606
  input_mode = WavpackGetMode(infile);
  }
#line 2608
  if (! (input_mode & 2)) {
#line 2608
    if (output_lossless) {
      {
#line 2609
      error_line("can\'t transcode lossy file %s to lossless...not allowed!\230\001",
                 infilename);
#line 2610
      WavpackCloseFile(infile);
      }
#line 2611
      return (1);
    }
  }
  {
#line 2614
  total_samples = WavpackGetNumSamples64(infile);
  }
#line 2616
  if (total_samples == -1L) {
    {
#line 2617
    error_line("can\'t transcode file %s of unknown length!t?dU", infilename);
#line 2618
    WavpackCloseFile(infile);
    }
#line 2619
    return (1);
  }
  {
#line 2624
  memset(& wv_file, 0, sizeof(wv_file));
#line 2625
  memset(& wvc_file, 0, sizeof(wvc_file));
  }
#line 2626
  if (out2filename) {
#line 2626
    tmp = & wvc_file;
  } else {
#line 2626
    tmp = (write_id *)((void *)0);
  }
  {
#line 2626
  __cil_tmp31 = WavpackOpenFileOutput(& write_block, & wv_file, tmp);
#line 2626
  outfile = __cil_tmp31;
#line 2630
  wv_file.file = fopen((char const   *)outfilename, "rbt?dU");
  }
#line 2630
  if (wv_file.file != (void *)0) {
#line 2630
    if ((int )*outfilename != 45) {
      {
#line 2631
      DoCloseHandle(wv_file.file);
#line 2632
      use_tempfiles = 1;
      }
#line 2634
      if (! overwrite_all___1) {
#line 2635
        if (output_lossless) {
          {
#line 2636
          __cil_tmp33 = strlen((char const   *)outfilename);
          }
#line 2636
          if (__cil_tmp33 > 30UL) {
            {
#line 2636
            __cil_tmp34 = filespec_name(outfilename);
#line 2636
            tmp___0 = __cil_tmp34;
            }
          } else {
#line 2636
            tmp___0 = outfilename;
          }
          {
#line 2636
          fprintf(stderr, "overwrite %s (yes/no/all)? ", tmp___0);
          }
        } else {
          {
#line 2638
          __cil_tmp36 = strlen((char const   *)outfilename);
          }
#line 2638
          if (__cil_tmp36 > 30UL) {
            {
#line 2638
            __cil_tmp37 = filespec_name(outfilename);
#line 2638
            tmp___1 = __cil_tmp37;
            }
          } else {
#line 2638
            tmp___1 = outfilename;
          }
          {
#line 2638
          fprintf(stderr, "overwrite %s with lossy transcode (yes/no/all)? \230",
                  tmp___1);
          }
        }
        {
#line 2640
        fflush(stderr);
        }
#line 2642
        if (set_console_title___1) {
          {
#line 2643
          DoSetConsoleTitle("overwrite?r?dU");
          }
        }
        {
#line 2645
        __cil_tmp39 = yna();
        }
        {
#line 2646
        if ((int )__cil_tmp39 == 'n') {
#line 2646
          goto case_110;
        }
#line 2651
        if ((int )__cil_tmp39 == 'a') {
#line 2651
          goto case_97;
        }
#line 2645
        goto switch_break;
        case_110: /* CIL Label */ 
        {
#line 2647
        WavpackCloseFile(infile);
        }
        {
#line 2648
        WavpackCloseFile(outfile);
        }
#line 2649
        return (1);
        case_97: /* CIL Label */ 
#line 2652
        overwrite_all___1 = 1;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 2657
  wvc_file.file = fopen((char const   *)out2filename, "rb");
  }
#line 2657
  if (out2filename) {
#line 2657
    if (! overwrite_all___1) {
#line 2657
      if (wvc_file.file != (void *)0) {
        {
#line 2658
        DoCloseHandle(wvc_file.file);
#line 2659
        __cil_tmp41 = strlen((char const   *)out2filename);
        }
#line 2659
        if (__cil_tmp41 > 30UL) {
          {
#line 2659
          __cil_tmp42 = filespec_name(out2filename);
#line 2659
          tmp___2 = __cil_tmp42;
          }
        } else {
#line 2659
          tmp___2 = out2filename;
        }
        {
#line 2659
        fprintf(stderr, "overwrite %s (yes/no/all)? ", tmp___2);
#line 2660
        fflush(stderr);
        }
#line 2662
        if (set_console_title___1) {
          {
#line 2663
          DoSetConsoleTitle("overwrite?t?dU");
          }
        }
        {
#line 2665
        __cil_tmp44 = yna();
        }
        {
#line 2667
        if ((int )__cil_tmp44 == 'n') {
#line 2667
          goto case_110___0;
        }
#line 2672
        if ((int )__cil_tmp44 == 'a') {
#line 2672
          goto case_97___0;
        }
#line 2665
        goto switch_break___0;
        case_110___0: /* CIL Label */ 
        {
#line 2668
        WavpackCloseFile(infile);
        }
        {
#line 2669
        WavpackCloseFile(outfile);
        }
#line 2670
        return (1);
        case_97___0: /* CIL Label */ 
#line 2673
        overwrite_all___1 = 1;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 2680
  if (use_tempfiles) {
    {
#line 2682
    count = 0;
#line 2684
    __cil_tmp47 = strlen((char const   *)outfilename);
#line 2684
    __cil_tmp48 = malloc(__cil_tmp47 + 16UL);
#line 2684
    outfilename_temp = __cil_tmp48;
    }
#line 2686
    if (out2filename) {
      {
#line 2687
      __cil_tmp49 = strlen((char const   *)outfilename);
#line 2687
      __cil_tmp50 = malloc(__cil_tmp49 + 16UL);
#line 2687
      out2filename_temp = __cil_tmp50;
      }
    }
    {
#line 2689
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2690
      strcpy(outfilename_temp, (char const   *)outfilename);
#line 2692
      __cil_tmp51 = filespec_ext(outfilename_temp);
      }
#line 2692
      if (__cil_tmp51) {
#line 2693
        __cil_tmp52 = count;
#line 2693
        count ++;
#line 2693
        if (__cil_tmp52) {
          {
#line 2694
          __cil_tmp53 = filespec_ext(outfilename_temp);
#line 2694
          sprintf(__cil_tmp53, ".tmp%d", count - 1);
          }
        } else {
          {
#line 2696
          __cil_tmp54 = filespec_ext(outfilename_temp);
#line 2696
          strcpy(__cil_tmp54, ".tmpdU");
          }
        }
        {
#line 2698
        __cil_tmp55 = filespec_ext(outfilename);
#line 2698
        strcat(outfilename_temp, (char const   *)__cil_tmp55);
        }
      } else {
#line 2701
        __cil_tmp56 = count;
#line 2701
        count ++;
#line 2701
        if (__cil_tmp56) {
          {
#line 2702
          __cil_tmp57 = strlen((char const   *)outfilename_temp);
#line 2702
          sprintf(outfilename_temp + __cil_tmp57, ".tmp%d", count - 1);
          }
        } else {
          {
#line 2704
          strcat(outfilename_temp, ".tmpdU");
          }
        }
      }
      {
#line 2707
      testfile = fopen((char const   *)outfilename_temp, "rb");
      }
#line 2709
      if (testfile) {
        {
#line 2710
        fclose(testfile);
        }
#line 2711
        goto while_continue;
      }
#line 2714
      if (out2filename) {
        {
#line 2715
        strcpy(out2filename_temp, (char const   *)outfilename_temp);
#line 2716
        strcat(out2filename_temp, "c");
#line 2718
        testfile = fopen((char const   *)out2filename_temp, "rb");
        }
#line 2720
        if (testfile) {
          {
#line 2721
          fclose(testfile);
          }
#line 2722
          goto while_continue;
        }
      }
#line 2726
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2733
  gettimeofday(& time1, & timez);
  }
#line 2738
  if ((int )*outfilename == 45) {
#line 2739
    wv_file.file = stdout;
  } else {
#line 2747
    if (use_tempfiles) {
#line 2747
      tmp___3 = outfilename_temp;
    } else {
#line 2747
      tmp___3 = outfilename;
    }
    {
#line 2747
    __cil_tmp61 = fopen((char const   *)tmp___3, "w+b?dU");
#line 2747
    wv_file.file = __cil_tmp61;
    }
#line 2747
    if (wv_file.file == (void *)0) {
#line 2748
      if (use_tempfiles) {
#line 2748
        tmp___4 = outfilename_temp;
      } else {
#line 2748
        tmp___4 = outfilename;
      }
      {
#line 2748
      error_line("can\'t create file %s!", tmp___4);
#line 2749
      WavpackCloseFile(infile);
#line 2750
      WavpackCloseFile(outfile);
      }
#line 2751
      return (1);
    }
  }
#line 2754
  if (! quiet_mode___2) {
#line 2755
    if ((int )*outfilename == 45) {
#line 2756
      if ((int )*infilename == 45) {
#line 2756
        tmp___6 = "stdin";
      } else {
        {
#line 2756
        __cil_tmp63 = strlen((char const   *)infilename);
        }
#line 2756
        if (__cil_tmp63 > 30UL) {
          {
#line 2756
          __cil_tmp64 = filespec_name(infilename);
#line 2756
          tmp___5 = __cil_tmp64;
          }
        } else {
#line 2756
          tmp___5 = infilename;
        }
#line 2756
        tmp___6 = (char const   *)tmp___5;
      }
      {
#line 2756
      fprintf(stderr, "packing %s to stdout,U", (int )tmp___6);
      }
    } else
#line 2757
    if (out2filename) {
      {
#line 2758
      __cil_tmp67 = strlen((char const   *)outfilename);
      }
#line 2758
      if (__cil_tmp67 > 30UL) {
        {
#line 2758
        __cil_tmp68 = filespec_name(outfilename);
#line 2758
        tmp___7 = __cil_tmp68;
        }
      } else {
#line 2758
        tmp___7 = outfilename;
      }
      {
#line 2758
      __cil_tmp70 = filespec_ext(out2filename);
#line 2758
      fprintf(stderr, "creating %s (+%s),u?dU", tmp___7, __cil_tmp70);
      }
    } else {
      {
#line 2760
      __cil_tmp71 = strlen((char const   *)outfilename);
      }
#line 2760
      if (__cil_tmp71 > 30UL) {
        {
#line 2760
        __cil_tmp72 = filespec_name(outfilename);
#line 2760
        tmp___8 = __cil_tmp72;
        }
      } else {
#line 2760
        tmp___8 = outfilename;
      }
      {
#line 2760
      fprintf(stderr, "creating %s,dU", tmp___8);
      }
    }
    {
#line 2762
    fflush(stderr);
    }
  }
  {
#line 2765
  __cil_tmp74 = WavpackGetFileExtension(infile);
  }
  {
#line 2765
  __cil_tmp75 = WavpackGetFileFormat(infile);
#line 2765
  WavpackSetFileInformation(outfile, __cil_tmp74, __cil_tmp75);
#line 2769
  __cil_tmp76 = WavpackGetWrapperBytes(infile);
  }
#line 2769
  if (__cil_tmp76) {
    {
#line 2770
    __cil_tmp77 = WavpackGetWrapperData(infile);
    }
    {
#line 2770
    __cil_tmp78 = WavpackGetWrapperBytes(infile);
#line 2770
    __cil_tmp79 = WavpackAddWrapper(outfile, __cil_tmp77, __cil_tmp78);
    }
#line 2770
    if (! (loc_config.qmode & 512)) {
#line 2770
      if (! __cil_tmp79) {
        {
#line 2771
        __cil_tmp80 = WavpackGetErrorMessage(outfile);
#line 2771
        error_line("%s", __cil_tmp80);
#line 2772
        WavpackCloseFile(infile);
#line 2773
        DoCloseHandle(wv_file.file);
        }
#line 2774
        if (use_tempfiles) {
#line 2774
          tmp___9 = outfilename_temp;
        } else {
#line 2774
          tmp___9 = outfilename;
        }
        {
#line 2774
        DoDeleteFile(tmp___9);
#line 2775
        WavpackCloseFile(outfile);
        }
#line 2776
        return (1);
      }
    }
    {
#line 2779
    WavpackFreeWrapper(infile);
    }
  }
  {
#line 2782
  loc_config.bytes_per_sample = WavpackGetBytesPerSample(infile);
#line 2783
  loc_config.bits_per_sample = WavpackGetBitsPerSample(infile);
#line 2784
  loc_config.channel_mask = WavpackGetChannelMask(infile);
#line 2785
  loc_config.num_channels = WavpackGetNumChannels(infile);
#line 2786
  __cil_tmp86 = WavpackGetSampleRate(infile);
#line 2786
  loc_config.sample_rate = (int32_t )__cil_tmp86;
#line 2787
  __cil_tmp87 = WavpackGetQualifyMode(infile);
  }
  {
#line 2787
  loc_config.qmode |= __cil_tmp87;
#line 2788
  chan_ids = (unsigned char *)malloc((unsigned long )(loc_config.num_channels + 1));
#line 2789
  WavpackGetChannelIdentities(infile, chan_ids);
  }
#line 2791
  if (input_mode & 8) {
    {
#line 2792
    loc_config.float_norm_exp = WavpackGetFloatNormExp(infile);
    }
  }
#line 2794
  if (input_mode & 2048) {
#line 2795
    loc_config.flags |= 134217728;
  }
  {
#line 2797
  __cil_tmp90 = WavpackSetConfiguration64(outfile, & loc_config, total_samples, (unsigned char const   *)chan_ids);
  }
#line 2797
  if (! __cil_tmp90) {
    {
#line 2798
    __cil_tmp91 = WavpackGetErrorMessage(outfile);
#line 2798
    error_line("%s", __cil_tmp91);
#line 2799
    WavpackCloseFile(infile);
#line 2800
    DoCloseHandle(wv_file.file);
    }
#line 2801
    if (use_tempfiles) {
#line 2801
      tmp___10 = outfilename_temp;
    } else {
#line 2801
      tmp___10 = outfilename;
    }
    {
#line 2801
    DoDeleteFile(tmp___10);
#line 2802
    WavpackCloseFile(outfile);
    }
#line 2803
    return (1);
  }
  {
#line 2806
  free(chan_ids);
  }
#line 2808
  if (loc_config.qmode & 8) {
    {
#line 2809
    __cil_tmp94 = WavpackGetChannelLayout(infile, (unsigned char *)((void *)0));
#line 2809
    layout = __cil_tmp94;
    }
#line 2812
    if (layout & 255U) {
      {
#line 2813
      WavpackGetChannelLayout(infile, (unsigned char *)order);
#line 2814
      WavpackSetChannelLayout(outfile, layout, (unsigned char const   *)((unsigned char *)order));
      }
    }
  } else {
    {
#line 2818
    __cil_tmp96 = WavpackGetChannelLayout(infile, (unsigned char *)((void *)0));
#line 2818
    WavpackSetChannelLayout(outfile, __cil_tmp96, (unsigned char const   *)((void *)0));
    }
  }
#line 2822
  if (out2filename) {
#line 2823
    if (use_tempfiles) {
#line 2823
      tmp___11 = out2filename_temp;
    } else {
#line 2823
      tmp___11 = out2filename;
    }
    {
#line 2823
    __cil_tmp98 = fopen((char const   *)tmp___11, "w+b?dU");
#line 2823
    wvc_file.file = __cil_tmp98;
    }
#line 2823
    if (wvc_file.file == (void *)0) {
      {
#line 2824
      error_line("can\'t create correction file!");
#line 2825
      WavpackCloseFile(infile);
#line 2826
      DoCloseHandle(wv_file.file);
      }
#line 2827
      if (use_tempfiles) {
#line 2827
        tmp___12 = outfilename_temp;
      } else {
#line 2827
        tmp___12 = outfilename;
      }
      {
#line 2827
      DoDeleteFile(tmp___12);
#line 2828
      WavpackCloseFile(outfile);
      }
#line 2829
      return (1);
    }
  }
  {
#line 2835
  result = repack_audio(outfile, infile, (unsigned char *)md5_verify);
  }
#line 2839
  if (result == 0) {
    {
#line 2840
    __cil_tmp101 = WavpackGetNumErrors(infile);
    }
#line 2840
    if (__cil_tmp101) {
      {
#line 2841
      __cil_tmp102 = WavpackGetNumErrors(infile);
#line 2841
      error_line("missing data or crc errors detected in %d block(s)!", __cil_tmp102);
#line 2842
      result = 1;
      }
    }
    {
#line 2845
    __cil_tmp103 = WavpackGetNumSamples64(outfile);
    }
#line 2845
    if (__cil_tmp103 != total_samples) {
      {
#line 2846
      error_line("incorrect number of samples read from source file!");
#line 2847
      result = 1;
      }
    }
#line 2850
    if (input_mode & 2) {
#line 2850
      if (! quantize_bits) {
        {
#line 2853
        __cil_tmp106 = memcmp((unsigned char *)md5_source, (unsigned char *)md5_verify,
                              sizeof(md5_source));
        }
        {
#line 2853
        __cil_tmp105 = WavpackGetMD5Sum(infile, (unsigned char *)md5_source);
        }
#line 2853
        if (__cil_tmp105) {
#line 2853
          if (__cil_tmp106) {
            {
#line 2854
            error_line("MD5 signature in source should match, but does not!?dU");
#line 2855
            result = 1;
            }
          }
        }
      }
    }
  }
#line 2863
  if (result == 0) {
    {
#line 2864
    __cil_tmp107 = WavpackGetMD5Sum(infile, (unsigned char *)md5_display);
    }
#line 2864
    if (__cil_tmp107) {
#line 2865
      if (input_mode & 2) {
#line 2865
        if (quantize_bits) {
          {
#line 2866
          memcpy((unsigned char *)md5_display, (unsigned char *)md5_verify, sizeof(md5_verify));
          }
        }
      }
      {
#line 2868
      WavpackStoreMD5Sum(outfile, (unsigned char *)md5_display);
      }
    } else
#line 2870
    if (loc_config.flags & 134217728) {
      {
#line 2871
      memcpy((unsigned char *)md5_display, (unsigned char *)md5_verify, sizeof(md5_display));
#line 2872
      WavpackStoreMD5Sum(outfile, (unsigned char *)md5_verify);
      }
    }
  }
  {
#line 2878
  __cil_tmp108 = WavpackGetWrapperBytes(infile);
  }
#line 2878
  if (result == 0) {
#line 2878
    if (__cil_tmp108) {
      {
#line 2879
      __cil_tmp110 = WavpackGetWrapperData(infile);
#line 2879
      buffer = __cil_tmp110;
#line 2880
      __cil_tmp112 = WavpackGetWrapperBytes(infile);
#line 2880
      wrapper_size = (int )__cil_tmp112;
#line 2884
      __cil_tmp113 = WavpackAddWrapper(outfile, buffer, (uint32_t )wrapper_size);
      }
#line 2884
      if (! (loc_config.qmode & 512)) {
#line 2884
        if (! __cil_tmp113) {
          {
#line 2885
          __cil_tmp114 = WavpackGetErrorMessage(outfile);
#line 2885
          error_line("%s", __cil_tmp114);
#line 2886
          result = 1;
          }
        }
      }
      {
#line 2892
      __cil_tmp115 = strncmp((char const   *)((char *)buffer), "ID3", (unsigned long )3);
      }
#line 2892
      if (result == 0) {
#line 2892
        if (import_id3___0) {
#line 2892
          if (wrapper_size > 10) {
#line 2892
            if (! __cil_tmp115) {
              {
#line 2898
              id3_res = ImportID3v2((void *)0, buffer, wrapper_size, (char *)error___66,
                                    & bytes_used);
              }
#line 2900
              if (! allow_huge_tags___0) {
#line 2900
                if (bytes_used > 1048576) {
                  {
#line 2901
                  error_line("imported tag items exceed 1 MB, use --allow-huge-tags to override\230u?dU");
#line 2902
                  result = 1;
                  }
                } else {
#line 2900
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 2904
              if (bytes_used > 16777216) {
                {
#line 2905
                error_line("imported tag items exceed 16 MB");
#line 2906
                result = 1;
                }
              } else {
#line 2909
                if (id3_res > 0) {
                  {
#line 2910
                  id3_res = ImportID3v2(outfile, buffer, wrapper_size, (char *)error___66,
                                        (int32_t *)((void *)0));
                  }
                }
#line 2912
                if (id3_res < 0) {
                  {
#line 2913
                  error_line("ID3v2 import: %s\230\001", (char *)error___66);
#line 2914
                  result = 1;
                  }
                } else
#line 2916
                if (id3_res > 0) {
#line 2917
                  imported_tag_items = id3_res;
                }
              }
            }
          }
        }
      }
      {
#line 2921
      WavpackFreeWrapper(infile);
      }
    }
  }
  {
#line 2926
  __cil_tmp121 = WavpackFlushSamples(outfile);
  }
#line 2926
  if (result == 0) {
#line 2926
    if (! __cil_tmp121) {
      {
#line 2927
      __cil_tmp122 = WavpackGetErrorMessage(outfile);
#line 2927
      error_line("%s", __cil_tmp122);
#line 2928
      result = 2;
      }
    }
  }
#line 2934
  if (result == 0) {
#line 2934
    if (input_mode & 16) {
      _L___67: /* CIL Label */ 
      _L___68: /* CIL Label */ 
      {
#line 2935
      __cil_tmp124 = WavpackGetNumBinaryTagItems(infile);
#line 2935
      num_binary_items = __cil_tmp124;
#line 2936
      __cil_tmp126 = WavpackGetNumTagItems(infile);
#line 2936
      num_items = __cil_tmp126;
#line 2939
      res = 1;
#line 2941
      i = 0;
      }
      {
#line 2941
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2941
        if (! (i < num_items && res)) {
#line 2941
          goto while_break___0;
        }
        {
#line 2942
        item_len = WavpackGetTagItemIndexed(infile, i, (char *)((void *)0), 0);
#line 2943
        item = (char *)malloc((unsigned long )(item_len + 1));
#line 2944
        WavpackGetTagItemIndexed(infile, i, item, item_len + 1);
#line 2949
        __cil_tmp135 = strcasecmp((char const   *)item, "encoder");
        }
#line 2949
        if (! __cil_tmp135) {
          {
#line 2950
          value = (char *)malloc((unsigned long )80);
#line 2951
          sprintf(value, "WavPack %su?dU", "5.1.0");
#line 2952
          __cil_tmp137 = strlen((char const   *)value);
#line 2952
          value_len = (int )__cil_tmp137;
          }
        } else {
          {
#line 2954
          __cil_tmp138 = strcasecmp((char const   *)item, "settings\220");
          }
#line 2954
          if (! __cil_tmp138) {
            {
#line 2955
            value = (char *)malloc((unsigned long )256);
#line 2956
            make_settings_string(value, & loc_config);
#line 2957
            __cil_tmp140 = strlen((char const   *)value);
#line 2957
            value_len = (int )__cil_tmp140;
            }
          } else {
            {
#line 2960
            value_len = WavpackGetTagItem(infile, (char const   *)item, (char *)((void *)0),
                                          0);
#line 2961
            value = (char *)malloc((unsigned long )(value_len + 1));
#line 2962
            WavpackGetTagItem(infile, (char const   *)item, value, value_len + 1);
            }
          }
        }
        {
#line 2965
        res = WavpackAppendTagItem(outfile, (char const   *)item, (char const   *)value,
                                   value_len);
#line 2966
        free(value);
#line 2967
        free(item);
        }
#line 2941
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2970
      i = 0;
      {
#line 2970
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2970
        if (! (i < num_binary_items && res)) {
#line 2970
          goto while_break___1;
        }
        {
#line 2971
        item_len = WavpackGetBinaryTagItemIndexed(infile, i, (char *)((void *)0),
                                                  0);
#line 2972
        item = (char *)malloc((unsigned long )(item_len + 1));
#line 2973
        WavpackGetBinaryTagItemIndexed(infile, i, item, item_len + 1);
#line 2974
        value_len = WavpackGetBinaryTagItem(infile, (char const   *)item, (char *)((void *)0),
                                            0);
#line 2975
        value = (char *)malloc((unsigned long )value_len);
#line 2976
        value_len = WavpackGetBinaryTagItem(infile, (char const   *)item, value, value_len);
#line 2977
        res = WavpackAppendBinaryTagItem(outfile, (char const   *)item, (char const   *)value,
                                         value_len);
#line 2978
        free(value);
#line 2979
        free(item);
        }
#line 2970
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2982
      i = 0;
      {
#line 2982
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2982
        if (! (i < num_tag_items___0 && res)) {
#line 2982
          goto while_break___2;
        }
#line 2983
        if ((tag_items___0 + i)->vsize) {
#line 2984
          if ((tag_items___0 + i)->binary) {
            {
#line 2985
            res = WavpackAppendBinaryTagItem(outfile, (char const   *)(tag_items___0 + i)->item,
                                             (char const   *)(tag_items___0 + i)->value,
                                             (tag_items___0 + i)->vsize);
            }
          } else {
            {
#line 2987
            res = WavpackAppendTagItem(outfile, (char const   *)(tag_items___0 + i)->item,
                                       (char const   *)(tag_items___0 + i)->value,
                                       (tag_items___0 + i)->vsize);
            }
          }
        } else {
          {
#line 2990
          WavpackDeleteTagItem(outfile, (char const   *)(tag_items___0 + i)->item);
          }
        }
#line 2982
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2992
      __cil_tmp152 = WavpackWriteTag(outfile);
      }
#line 2992
      if (! res) {
        {
        {
#line 2993
        __cil_tmp153 = WavpackGetErrorMessage(outfile);
        }
        {
#line 2993
        error_line("%su?dU", __cil_tmp153);
        }
#line 2994
        result = 2;
        }
      } else
#line 2992
      if (! __cil_tmp152) {
        {
        {
#line 2993
        __cil_tmp153 = WavpackGetErrorMessage(outfile);
        }
        {
#line 2993
        error_line("%su?dU", __cil_tmp153);
        }
#line 2994
        result = 2;
        }
      }
    } else
#line 2934
    if (num_tag_items___0) {
#line 2934
      goto _L___67;
    } else
#line 2934
    if (imported_tag_items) {
#line 2934
      goto _L___67;
    }
  }
  {
#line 2998
  WavpackCloseFile(infile);
#line 3003
  __cil_tmp154 = DoCloseHandle(wv_file.file);
  }
#line 3003
  if (! __cil_tmp154) {
    {
#line 3004
    error_line("can\'t close WavPack file!\035r?dU");
    }
#line 3006
    if (result == 0) {
#line 3007
      result = 1;
    }
  }
  {
#line 3010
  __cil_tmp155 = DoCloseHandle(wvc_file.file);
  }
#line 3010
  if (out2filename) {
#line 3010
    if (! __cil_tmp155) {
      {
#line 3011
      error_line("can\'t close correction file!dU");
      }
#line 3013
      if (result == 0) {
#line 3014
        result = 1;
      }
    }
  }
#line 3020
  if (result == 0) {
#line 3020
    if (verify_mode) {
#line 3021
      if (use_tempfiles) {
#line 3021
        tmp___13 = outfilename_temp;
      } else {
#line 3021
        tmp___13 = outfilename;
      }
      {
#line 3021
      __cil_tmp157 = WavpackLossyBlocks(outfile);
      }
#line 3021
      if (! __cil_tmp157) {
#line 3021
        tmp___14 = (unsigned char *)md5_verify;
      } else {
#line 3021
        tmp___14 = (unsigned char *)((void *)0);
      }
      {
#line 3021
      __cil_tmp159 = verify_audio(tmp___13, tmp___14);
#line 3021
      result = __cil_tmp159;
      }
    }
  }
#line 3025
  if (result != 0) {
#line 3026
    if (use_tempfiles) {
#line 3026
      tmp___15 = outfilename_temp;
    } else {
#line 3026
      tmp___15 = outfilename;
    }
    {
#line 3026
    DoDeleteFile(tmp___15);
    }
#line 3028
    if (out2filename) {
#line 3029
      if (use_tempfiles) {
#line 3029
        tmp___16 = out2filename_temp;
      } else {
#line 3029
        tmp___16 = out2filename;
      }
      {
#line 3029
      DoDeleteFile(tmp___16);
      }
    }
    {
#line 3031
    WavpackCloseFile(outfile);
    }
#line 3032
    return (result);
  }
#line 3035
  if (result == 0) {
#line 3035
    if (copy_time___0) {
#line 3036
      if (use_tempfiles) {
#line 3036
        tmp___18 = out2filename_temp;
      } else {
#line 3036
        tmp___18 = out2filename;
      }
      {
#line 3036
      __cil_tmp165 = copy_timestamp((char const   *)infilename, (char const   *)tmp___18);
      }
#line 3036
      if (use_tempfiles) {
#line 3036
        tmp___17 = outfilename_temp;
      } else {
#line 3036
        tmp___17 = outfilename;
      }
      {
#line 3036
      __cil_tmp163 = copy_timestamp((char const   *)infilename, (char const   *)tmp___17);
      }
#line 3036
      if (out2filename) {
#line 3036
        if (! __cil_tmp165) {
          {
          {
#line 3038
          error_line("failure copying time stamp!");
          }
          }
        } else {
#line 3036
          goto _L___69;
        }
      } else
      _L___69: /* CIL Label */ 
#line 3036
      if (! __cil_tmp163) {
        {
        {
#line 3038
        error_line("failure copying time stamp!");
        }
        }
      }
    }
  }
#line 3043
  if (result == 0) {
#line 3043
    if (delete_source___0) {
      {
#line 3046
      __cil_tmp167 = strcasecmp((char const   *)infilename, (char const   *)outfilename);
      }
#line 3046
      if (__cil_tmp167) {
        {
#line 3047
        res___0 = DoDeleteFile(infilename);
        }
#line 3049
        if (! quiet_mode___2) {
          _L___70: /* CIL Label */ 
#line 3050
          if (res___0) {
#line 3050
            tmp___19 = "deleted";
          } else {
#line 3050
            tmp___19 = "can\'t delete";
          }
          {
#line 3050
          error_line("%s source file %s", tmp___19, infilename);
          }
        } else
#line 3049
        if (! res___0) {
#line 3049
          goto _L___70;
        }
      }
#line 3054
      if (input_mode & 1) {
        {
#line 3057
        strcpy((char *)in2filename, (char const   *)infilename);
#line 3058
        strcat((char *)in2filename, "c");
#line 3060
        __cil_tmp171 = strcasecmp((char const   *)((char *)in2filename), (char const   *)out2filename);
        }
#line 3060
        if (! out2filename) {
          _L___72: /* CIL Label */ 
          {
#line 3061
          res___0 = DoDeleteFile((char *)in2filename);
          }
#line 3063
          if (! quiet_mode___2) {
            _L___71: /* CIL Label */ 
#line 3064
            if (res___0) {
#line 3064
              tmp___20 = "deleted";
            } else {
#line 3064
              tmp___20 = "can\'t delete";
            }
            {
#line 3064
            error_line("%s source file %s", tmp___20, (char *)in2filename);
            }
          } else
#line 3063
          if (! res___0) {
#line 3063
            goto _L___71;
          }
        } else
#line 3060
        if (__cil_tmp171) {
#line 3060
          goto _L___72;
        }
      }
    }
  }
#line 3073
  if (use_tempfiles) {
    {
#line 3084
    __cil_tmp174 = rename((char const   *)outfilename_temp, (char const   *)outfilename);
    }
#line 3084
    if (__cil_tmp174) {
      {
#line 3085
      error_line("can not rename temp file %s to %s!", outfilename_temp, outfilename);
#line 3086
      result = 1;
      }
    }
#line 3089
    if (out2filename) {
      {
#line 3100
      __cil_tmp175 = rename((char const   *)out2filename_temp, (char const   *)out2filename);
      }
#line 3100
      if (__cil_tmp175) {
        {
#line 3101
        error_line("can not rename temp file %s to %s!", out2filename_temp, out2filename);
#line 3102
        result = 1;
        }
      }
    }
    {
#line 3106
    free(outfilename_temp);
    }
#line 3107
    if (out2filename) {
      {
#line 3107
      free(out2filename_temp);
      }
    }
#line 3109
    if (result != 0) {
      {
#line 3110
      WavpackCloseFile(outfile);
      }
#line 3111
      return (result);
    }
  }
  {
#line 3123
  gettimeofday(& time2, & timez);
#line 3124
  dtime = (double )time2.tv_sec + (double )time2.tv_usec / 1000000.;
#line 3125
  dtime -= (double )time1.tv_sec + (double )time1.tv_usec / 1000000.;
#line 3128
  __cil_tmp176 = WavpackGetEncodedNoise(outfile, (double *)((void *)0));
  }
#line 3128
  if (loc_config.flags & 8388608) {
#line 3128
    if (__cil_tmp176 > 0.) {
      {
#line 3129
      __cil_tmp178 = WavpackGetBitsPerSample(outfile);
#line 3129
      full_scale_bits = __cil_tmp178;
#line 3130
      full_scale_rms = 0.5;
      }
      {
#line 3132
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3132
        __cil_tmp182 = full_scale_bits;
#line 3132
        full_scale_bits --;
#line 3132
        if (! __cil_tmp182) {
#line 3132
          goto while_break___3;
        }
#line 3133
        full_scale_rms *= 2.;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 3135
      full_scale_rms = (full_scale_rms * (full_scale_rms - 1.)) * 0.5;
#line 3136
      sum = WavpackGetEncodedNoise(outfile, & peak);
#line 3138
      __cil_tmp184 = WavpackGetNumSamples(outfile);
#line 3138
      __cil_tmp185 = log10((sum / (double )__cil_tmp184) / full_scale_rms);
      }
      {
#line 3138
      __cil_tmp186 = log10(peak / full_scale_rms);
#line 3138
      error_line("ave noise = %.2f dB, peak noise = %.2f dB", __cil_tmp185 * (double )10,
                 __cil_tmp186 * (double )10);
      }
    }
  }
#line 3143
  if (! quiet_mode___2) {
#line 3144
    cratio = "\005";
#line 3146
    if (imported_tag_items) {
      {
#line 3147
      error_line("successfully imported %d items from ID3v2 tag", imported_tag_items);
      }
    }
#line 3149
    if (config->flags & 134217728) {
#line 3150
      md5_string = "original md5 signature: 00000000000000000000000000000000\f";
#line 3153
      i___0 = 0;
      {
#line 3153
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3153
        if (! (i___0 < 16)) {
#line 3153
          goto while_break___4;
        }
        {
#line 3154
        sprintf(((char *)md5_string + 24) + i___0 * 2, "%02x", (int )md5_display[i___0]);
        }
#line 3153
        i___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 3156
      error_line((char *)md5_string);
      }
    }
#line 3159
    if (outfilename) {
#line 3159
      if ((int )*outfilename != 45) {
        {
#line 3160
        __cil_tmp194 = strlen((char const   *)outfilename);
        }
#line 3160
        if (__cil_tmp194 > 30UL) {
          {
#line 3160
          __cil_tmp195 = filespec_name(outfilename);
#line 3160
          tmp___21 = __cil_tmp195;
          }
        } else {
#line 3160
          tmp___21 = outfilename;
        }
#line 3160
        file = tmp___21;
#line 3161
        if (wvc_file.bytes_written) {
#line 3161
          tmp___22 = " (+.wvc)\323\001 ";
        } else {
#line 3161
          tmp___22 = "\220";
        }
#line 3161
        fext = tmp___22;
#line 3162
        if (verify_mode) {
#line 3162
          tmp___23 = "created (and verified)";
        } else {
#line 3162
          tmp___23 = "created";
        }
#line 3162
        oper = tmp___23;
      } else {
#line 3159
        goto _L___73;
      }
    } else {
      _L___73: /* CIL Label */ 
#line 3165
      if ((int )*infilename == 45) {
#line 3165
        tmp___25 = "stdin";
      } else {
        {
#line 3165
        __cil_tmp199 = strlen((char const   *)infilename);
        }
#line 3165
        if (__cil_tmp199 > 30UL) {
          {
#line 3165
          __cil_tmp200 = filespec_name(infilename);
#line 3165
          tmp___24 = __cil_tmp200;
          }
        } else {
#line 3165
          tmp___24 = infilename;
        }
#line 3165
        tmp___25 = (char const   *)tmp___24;
      }
#line 3165
      file = (int )tmp___25;
#line 3166
      fext = "\220";
#line 3167
      oper = "packed";
    }
    {
#line 3170
    __cil_tmp203 = WavpackLossyBlocks(outfile);
    }
#line 3170
    if (__cil_tmp203) {
      {
#line 3171
      cmode = "lossy";
#line 3173
      __cil_tmp204 = WavpackGetAverageBitrate(outfile, 1);
      }
#line 3173
      if (__cil_tmp204 != 0.) {
        {
#line 3174
        __cil_tmp205 = WavpackGetAverageBitrate(outfile, 1);
#line 3174
        sprintf((char *)cratio, ", %d kbps", (int )(__cil_tmp205 / 1000.));
        }
      }
    } else {
      {
#line 3177
      cmode = "lossless\220";
#line 3179
      __cil_tmp206 = WavpackGetRatio(outfile);
      }
#line 3179
      if (__cil_tmp206 != 0.) {
        {
#line 3180
        __cil_tmp207 = WavpackGetRatio(outfile);
#line 3180
        sprintf((char *)cratio, ", %.2f%%\240", 100. - __cil_tmp207 * 100.);
        }
      }
    }
    {
#line 3183
    error_line("%s %s%s in %.2f secs (%s%s)", oper, file, fext, dtime, cmode, (char *)cratio);
    }
  }
  {
#line 3186
  WavpackCloseFile(outfile);
  }
#line 3187
  return (0);
}
}
#line 3198 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static int repack_audio(WavpackContext *outfile , WavpackContext *infile , unsigned char *md5_digest_source ) 
{ 
  int bps ;
  int __cil_tmp5 ;
  int num_channels ;
  int __cil_tmp7 ;
  int qmode ;
  int __cil_tmp9 ;
  unsigned char *new_channel_order ;
  uint32_t input_samples ;
  unsigned char *format_buffer ;
  int32_t *sample_buffer ;
  double progress ;
  MD5_CTX md5_context ;
  int32_t quantize_bit_mask ;
  double fquantize_scale ;
  double fquantize_iscale ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  int layout ;
  uint32_t __cil_tmp23 ;
  int i ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  int __cil_tmp28 ;
  int float_norm_exp ;
  int __cil_tmp30 ;
  double __cil_tmp31 ;
  double __cil_tmp32 ;
  int32_t sample_count ;
  uint32_t __cil_tmp34 ;
  unsigned int x ;
  unsigned int l ;
  int __cil_tmp37 ;
  int32_t offset ;
  int shift ;
  unsigned int __cil_tmp40 ;
  unsigned int __cil_tmp41 ;
  float f ;
  double __cil_tmp43 ;
  unsigned int __cil_tmp44 ;
  int __cil_tmp45 ;
  char *__cil_tmp46 ;
  unsigned char *dptr ;
  int32_t *sptr ;
  int cc ;
  int __cil_tmp50 ;
  int si ;
  unsigned char *__cil_tmp52 ;
  int tmp ;
  unsigned char *__cil_tmp54 ;
  int __cil_tmp55 ;
  int scount ;
  int __cil_tmp57 ;
  unsigned char *__cil_tmp58 ;
  int32_t *__cil_tmp59 ;
  int __cil_tmp60 ;
  double __cil_tmp61 ;
  double __cil_tmp62 ;
  double __cil_tmp63 ;
  int nobs ;
  double __cil_tmp65 ;
  double __cil_tmp66 ;
  char const   *tmp___0 ;
  int __cil_tmp68 ;
  char *__cil_tmp69 ;

  {
  {
#line 3200
  __cil_tmp5 = WavpackGetBytesPerSample(infile);
#line 3200
  bps = __cil_tmp5;
  }
  {
#line 3200
  __cil_tmp7 = WavpackGetNumChannels(infile);
#line 3200
  num_channels = __cil_tmp7;
#line 3201
  __cil_tmp9 = WavpackGetQualifyMode(infile);
#line 3201
  qmode = __cil_tmp9;
#line 3202
  new_channel_order = (unsigned char *)((void *)0);
#line 3203
  input_samples = (uint32_t )65536;
#line 3206
  progress = - 1.;
#line 3208
  quantize_bit_mask = 0;
#line 3209
  fquantize_scale = 1.;
  }
#line 3209
  fquantize_iscale = 1.;
#line 3213
  if (qmode & 64) {
#line 3214
    input_samples = (uint32_t )4096;
  } else {
    {
#line 3216
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3216
      __cil_tmp19 = WavpackGetNumChannels(outfile);
      }
#line 3216
      if (! (((unsigned long )input_samples * sizeof(int32_t )) * (unsigned long )__cil_tmp19 > 2097152UL)) {
#line 3216
        goto while_break;
      }
#line 3217
      input_samples >>= 1;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3219
  if (md5_digest_source) {
    {
#line 3220
    __cil_tmp20 = WavpackGetNumChannels(outfile);
#line 3220
    __cil_tmp21 = malloc((unsigned long )((input_samples * (unsigned int )bps) * (unsigned int )__cil_tmp20));
#line 3220
    format_buffer = __cil_tmp21;
#line 3221
    MD5Init(& md5_context);
    }
#line 3223
    if (qmode & 8) {
      {
#line 3224
      __cil_tmp23 = WavpackGetChannelLayout(infile, (unsigned char *)((void *)0));
#line 3224
      layout = (int )__cil_tmp23;
      }
#line 3226
      if ((layout & 255) <= num_channels) {
        {
#line 3227
        new_channel_order = (unsigned char *)malloc((unsigned long )num_channels);
#line 3229
        i = 0;
        }
        {
#line 3229
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3229
          if (! (i < num_channels)) {
#line 3229
            goto while_break___0;
          }
#line 3230
          *(new_channel_order + i) = (unsigned char )i;
#line 3229
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 3232
        WavpackGetChannelLayout(infile, new_channel_order);
        }
      }
    }
  }
  {
#line 3237
  WavpackPackInit(outfile);
#line 3238
  __cil_tmp26 = WavpackGetNumChannels(outfile);
#line 3238
  __cil_tmp27 = malloc(((unsigned long )input_samples * sizeof(int32_t )) * (unsigned long )__cil_tmp26);
#line 3238
  sample_buffer = __cil_tmp27;
  }
#line 3240
  if (quantize_bits) {
#line 3240
    if (quantize_bits < bps * 8) {
      {
#line 3241
      quantize_bit_mask = ~ ((1 << (bps * 8 - quantize_bits)) - 1);
#line 3242
      __cil_tmp28 = WavpackGetMode(infile);
      }
#line 3242
      if (8 == (__cil_tmp28 & 8)) {
        {
#line 3243
        __cil_tmp30 = WavpackGetFloatNormExp(infile);
#line 3243
        float_norm_exp = __cil_tmp30;
#line 3244
        fquantize_scale = exp2((double )((quantize_bits + 126) - float_norm_exp));
#line 3245
        fquantize_iscale = exp2((double )((float_norm_exp - 126) - quantize_bits));
        }
      }
    }
  }
  {
#line 3249
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 3250
    __cil_tmp34 = WavpackUnpackSamples(infile, sample_buffer, input_samples);
#line 3250
    sample_count = (int32_t )__cil_tmp34;
    }
#line 3252
    if (! sample_count) {
#line 3253
      goto while_break___1;
    }
#line 3255
    if (quantize_bit_mask) {
      {
#line 3256
      l = (unsigned int )(sample_count * num_channels);
#line 3257
      __cil_tmp37 = WavpackGetMode(infile);
      }
#line 3257
      if (0 == (__cil_tmp37 & 8)) {
#line 3258
        if (quantize_round) {
#line 3259
          offset = (quantize_bit_mask >> 1) ^ quantize_bit_mask;
#line 3260
          shift = 32 - bps * 8;
#line 3262
          x = (unsigned int )0;
          {
#line 3262
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3262
            if (! (x < l)) {
#line 3262
              goto while_break___2;
            }
#line 3263
            if (*(sample_buffer + x) < 0) {
#line 3264
              *(sample_buffer + x) += offset;
            } else
#line 3263
            if ((*(sample_buffer + x) + offset) << shift > 0) {
#line 3264
              *(sample_buffer + x) += offset;
            }
#line 3262
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 3267
        x = (unsigned int )0;
        {
#line 3267
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3267
          if (! (x < l)) {
#line 3267
            goto while_break___3;
          }
#line 3267
          *(sample_buffer + x) &= quantize_bit_mask;
#line 3267
          x ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 3270
        x = (unsigned int )0;
        {
#line 3270
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3270
          if (! (x < l)) {
#line 3270
            goto while_break___4;
          }
          {
#line 3271
          f = *((float *)(sample_buffer + x));
#line 3272
          __cil_tmp43 = floor((double )f * fquantize_scale + 0.5);
#line 3272
          *((float *)(sample_buffer + x)) = (float )(__cil_tmp43 * fquantize_iscale);
          }
#line 3270
          x ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
    {
#line 3277
    __cil_tmp45 = WavpackPackSamples(outfile, sample_buffer, (uint32_t )sample_count);
    }
#line 3277
    if (! __cil_tmp45) {
      {
#line 3278
      __cil_tmp46 = WavpackGetErrorMessage(outfile);
#line 3278
      error_line("%s", __cil_tmp46);
#line 3279
      free(sample_buffer);
      }
#line 3280
      return (2);
    }
#line 3283
    if (md5_digest_source) {
#line 3284
      if (new_channel_order) {
        {
#line 3285
        unreorder_channels___0(sample_buffer, new_channel_order, num_channels, sample_count);
        }
      }
#line 3287
      if (qmode & 48) {
#line 3288
        dptr = format_buffer;
#line 3289
        sptr = sample_buffer;
#line 3291
        if (qmode & 64) {
#line 3292
          cc = num_channels;
          {
#line 3294
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3294
            __cil_tmp50 = cc;
#line 3294
            cc --;
#line 3294
            if (! __cil_tmp50) {
#line 3294
              goto while_break___5;
            }
#line 3297
            si = 0;
            {
#line 3297
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 3297
              if (! (si < 4096)) {
#line 3297
                goto while_break___6;
              }
#line 3298
              if (si < sample_count) {
#line 3299
                if (qmode & 16) {
#line 3299
                  tmp = (int )bit_reverse_table___0[*sptr & 255];
                } else {
#line 3299
                  tmp = *sptr;
                }
#line 3299
                __cil_tmp52 = dptr;
#line 3299
                dptr ++;
#line 3299
                *__cil_tmp52 = (unsigned char )tmp;
              } else {
#line 3301
                __cil_tmp54 = dptr;
#line 3301
                dptr ++;
#line 3301
                *__cil_tmp54 = (unsigned char )0;
              }
#line 3297
              sptr += num_channels;
#line 3297
              __cil_tmp55 = si;
#line 3297
              si ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 3303
            sptr -= 4096 * num_channels - 1;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 3306
          sample_count = 4096;
        } else {
#line 3309
          scount = sample_count * num_channels;
          {
#line 3311
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 3311
            __cil_tmp57 = scount;
#line 3311
            scount --;
#line 3311
            if (! __cil_tmp57) {
#line 3311
              goto while_break___7;
            }
#line 3312
            __cil_tmp59 = sptr;
#line 3312
            sptr ++;
#line 3312
            __cil_tmp58 = dptr;
#line 3312
            dptr ++;
#line 3312
            *__cil_tmp58 = (unsigned char )*__cil_tmp59;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 3316
        store_samples___0(format_buffer, sample_buffer, qmode, bps, sample_count * num_channels);
        }
      }
      {
#line 3318
      MD5Update(& md5_context, format_buffer, (unsigned int )((bps * sample_count) * num_channels));
      }
    }
    {
#line 3321
    __cil_tmp60 = check_break();
    }
#line 3321
    if (__cil_tmp60) {
      {
#line 3325
      fprintf(stderr, "\n\260v?dU");
#line 3327
      fflush(stderr);
#line 3328
      free(sample_buffer);
      }
#line 3329
      return (1);
    }
    {
#line 3332
    __cil_tmp62 = WavpackGetProgress(outfile);
#line 3332
    __cil_tmp63 = floor(__cil_tmp62 * encode_time_percent + 0.5);
    }
    {
#line 3332
    __cil_tmp61 = WavpackGetProgress(outfile);
    }
#line 3332
    if (__cil_tmp61 != - 1.) {
#line 3332
      if (progress != __cil_tmp63) {
        {
#line 3334
        nobs = progress == - 1.;
#line 3336
        __cil_tmp65 = WavpackGetProgress(outfile);
#line 3336
        __cil_tmp66 = floor(__cil_tmp65 * encode_time_percent + 0.5);
#line 3336
        progress = __cil_tmp66;
#line 3337
        display_progress___0(progress / 100.);
        }
#line 3339
        if (! quiet_mode___2) {
#line 3340
          if (nobs) {
#line 3340
            tmp___0 = " ";
          } else {
#line 3340
            tmp___0 = "\b\b\b\b\b\b\b\b\b\b\b\b";
          }
          {
#line 3340
          fprintf(stderr, "%s%3d%% done...", tmp___0, (int )progress);
#line 3342
          fflush(stderr);
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3347
  if (new_channel_order) {
    {
#line 3348
    free(new_channel_order);
    }
  }
  {
#line 3350
  free(sample_buffer);
#line 3352
  __cil_tmp68 = WavpackFlushSamples(outfile);
  }
#line 3352
  if (! __cil_tmp68) {
    {
#line 3353
    __cil_tmp69 = WavpackGetErrorMessage(outfile);
#line 3353
    error_line("%sw?dU", __cil_tmp69);
    }
#line 3354
    return (2);
  }
#line 3357
  if (md5_digest_source) {
    {
#line 3358
    MD5Final(md5_digest_source, & md5_context);
#line 3359
    free(format_buffer);
    }
  }
#line 3362
  return (0);
}
}
#line 3365 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void reorder_channels(void *data , unsigned char *order , int num_chans , int num_samples ,
                             int bytes_per_sample ) 
{ 
  char reorder_buffer[64] ;
  char *temp ;
  char *src ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  char *start ;
  int chan ;
  char *dst ;
  int bc ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 3368
  temp = (char *)reorder_buffer;
#line 3369
  src = data;
#line 3371
  if (num_chans * bytes_per_sample > 64) {
    {
#line 3372
    temp = (char *)malloc((unsigned long )(num_chans * bytes_per_sample));
    }
  }
  {
#line 3374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3374
    __cil_tmp10 = num_samples;
#line 3374
    num_samples --;
#line 3374
    if (! __cil_tmp10) {
#line 3374
      goto while_break;
    }
#line 3375
    start = src;
#line 3378
    chan = 0;
    {
#line 3378
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3378
      if (! (chan < num_chans)) {
#line 3378
        goto while_break___0;
      }
#line 3379
      dst = temp + (int )*(order + chan) * bytes_per_sample;
#line 3380
      bc = bytes_per_sample;
      {
#line 3382
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3382
        __cil_tmp15 = bc;
#line 3382
        bc --;
#line 3382
        if (! __cil_tmp15) {
#line 3382
          goto while_break___1;
        }
#line 3383
        __cil_tmp17 = src;
#line 3383
        src ++;
#line 3383
        __cil_tmp16 = dst;
#line 3383
        dst ++;
#line 3383
        *__cil_tmp16 = *__cil_tmp17;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3378
      chan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3386
    memcpy(start, temp, (unsigned long )(num_chans * bytes_per_sample));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3389
  if (num_chans * bytes_per_sample > 64) {
    {
#line 3390
    free(temp);
    }
  }
  return;
}
}
#line 3393 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void unreorder_channels___0(int32_t *data , unsigned char *order , int num_chans ,
                                   int num_samples ) 
{ 
  int32_t reorder_buffer[16] ;
  int32_t *temp ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  int chan ;

  {
#line 3395
  temp = (int32_t *)reorder_buffer;
#line 3397
  if (num_chans > 16) {
    {
#line 3398
    temp = (int32_t *)malloc((unsigned long )num_chans * sizeof(*data));
    }
  }
  {
#line 3400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3400
    __cil_tmp8 = num_samples;
#line 3400
    num_samples --;
#line 3400
    if (! __cil_tmp8) {
#line 3400
      goto while_break;
    }
#line 3403
    chan = 0;
    {
#line 3403
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3403
      if (! (chan < num_chans)) {
#line 3403
        goto while_break___0;
      }
#line 3404
      *(temp + chan) = *(data + *(order + chan));
#line 3403
      chan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3406
    memcpy(data, temp, (unsigned long )num_chans * sizeof(*data));
#line 3407
    data += num_chans;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3410
  if (num_chans > 16) {
    {
#line 3411
    free(temp);
    }
  }
  return;
}
}
#line 3424 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static int verify_audio(char *infilename , unsigned char *md5_digest_source ) 
{ 
  int num_channels ;
  int bps ;
  int qmode ;
  int result ;
  unsigned char *new_channel_order ;
  int64_t total_unpacked_samples ;
  unsigned char md5_digest_result[16] ;
  double progress ;
  int32_t *temp_buffer ;
  MD5_CTX md5_context ;
  WavpackContext *wpc ;
  char error[80] ;
  WavpackContext *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int layout ;
  uint32_t __cil_tmp21 ;
  int i ;
  void *__cil_tmp23 ;
  int32_t samples_unpacked ;
  uint32_t __cil_tmp25 ;
  unsigned char *dsd_buffer ;
  void *__cil_tmp27 ;
  unsigned char *dptr ;
  int32_t *sptr ;
  int cc ;
  int __cil_tmp31 ;
  int si ;
  unsigned char *__cil_tmp33 ;
  int tmp ;
  unsigned char *__cil_tmp35 ;
  int __cil_tmp36 ;
  int scount ;
  int __cil_tmp38 ;
  unsigned char *__cil_tmp39 ;
  int32_t *__cil_tmp40 ;
  int __cil_tmp41 ;
  double __cil_tmp42 ;
  double __cil_tmp43 ;
  double __cil_tmp44 ;
  double __cil_tmp45 ;
  double __cil_tmp46 ;
  int __cil_tmp47 ;
  char md5_string1[33] ;
  char md5_string2[33] ;
  int i___0 ;
  int64_t __cil_tmp51 ;
  int64_t __cil_tmp52 ;
  int64_t __cil_tmp53 ;
  int64_t __cil_tmp54 ;
  int64_t __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;

  {
  {
#line 3426
  result = 0;
#line 3427
  new_channel_order = (unsigned char *)((void *)0);
#line 3428
  total_unpacked_samples = (int64_t )0;
#line 3430
  progress = - 1.;
#line 3441
  wpc = WavpackOpenFileInput((char const   *)infilename, (char *)error, 1281, 0);
  }
#line 3444
  if (! wpc) {
    {
#line 3445
    error_line((char *)error);
    }
#line 3446
    return (1);
  }
#line 3449
  if (md5_digest_source) {
    {
#line 3450
    MD5Init(& md5_context);
    }
  }
  {
#line 3452
  qmode = WavpackGetQualifyMode(wpc);
#line 3453
  num_channels = WavpackGetNumChannels(wpc);
#line 3454
  bps = WavpackGetBytesPerSample(wpc);
#line 3455
  temp_buffer = (int32_t *)malloc((unsigned long )((4096 * num_channels) * 4));
  }
#line 3457
  if (qmode & 8) {
    {
#line 3458
    __cil_tmp21 = WavpackGetChannelLayout(wpc, (unsigned char *)((void *)0));
#line 3458
    layout = (int )__cil_tmp21;
    }
#line 3460
    if ((layout & 255) <= num_channels) {
      {
#line 3461
      new_channel_order = (unsigned char *)malloc((unsigned long )num_channels);
#line 3463
      i = 0;
      }
      {
#line 3463
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3463
        if (! (i < num_channels)) {
#line 3463
          goto while_break;
        }
#line 3464
        *(new_channel_order + i) = (unsigned char )i;
#line 3463
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3466
      WavpackGetChannelLayout(wpc, new_channel_order);
      }
    }
  }
  {
#line 3470
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3470
    if (! (result == 0)) {
#line 3470
      goto while_break___0;
    }
    {
#line 3473
    __cil_tmp25 = WavpackUnpackSamples(wpc, temp_buffer, (uint32_t )4096);
#line 3473
    samples_unpacked = (int32_t )__cil_tmp25;
#line 3474
    total_unpacked_samples += (long )samples_unpacked;
    }
#line 3476
    if (samples_unpacked) {
#line 3477
      if (md5_digest_source) {
#line 3478
        if (new_channel_order) {
          {
#line 3479
          unreorder_channels___0(temp_buffer, new_channel_order, num_channels, samples_unpacked);
          }
        }
#line 3481
        if (qmode & 48) {
          {
#line 3482
          __cil_tmp27 = malloc((unsigned long )(4096 * num_channels));
#line 3482
          dsd_buffer = __cil_tmp27;
#line 3483
          dptr = dsd_buffer;
#line 3484
          sptr = temp_buffer;
          }
#line 3486
          if (qmode & 64) {
#line 3487
            cc = num_channels;
            {
#line 3489
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 3489
              __cil_tmp31 = cc;
#line 3489
              cc --;
#line 3489
              if (! __cil_tmp31) {
#line 3489
                goto while_break___1;
              }
#line 3492
              si = 0;
              {
#line 3492
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 3492
                if (! (si < 4096)) {
#line 3492
                  goto while_break___2;
                }
#line 3493
                if (si < samples_unpacked) {
#line 3494
                  if (qmode & 16) {
#line 3494
                    tmp = (int )bit_reverse_table___0[*sptr & 255];
                  } else {
#line 3494
                    tmp = *sptr;
                  }
#line 3494
                  __cil_tmp33 = dptr;
#line 3494
                  dptr ++;
#line 3494
                  *__cil_tmp33 = (unsigned char )tmp;
                } else {
#line 3496
                  __cil_tmp35 = dptr;
#line 3496
                  dptr ++;
#line 3496
                  *__cil_tmp35 = (unsigned char )0;
                }
#line 3492
                sptr += num_channels;
#line 3492
                __cil_tmp36 = si;
#line 3492
                si ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 3498
              sptr -= 4096 * num_channels - 1;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 3501
            samples_unpacked = 4096;
          } else {
#line 3504
            scount = samples_unpacked * num_channels;
            {
#line 3506
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 3506
              __cil_tmp38 = scount;
#line 3506
              scount --;
#line 3506
              if (! __cil_tmp38) {
#line 3506
                goto while_break___3;
              }
#line 3507
              __cil_tmp40 = sptr;
#line 3507
              sptr ++;
#line 3507
              __cil_tmp39 = dptr;
#line 3507
              dptr ++;
#line 3507
              *__cil_tmp39 = (unsigned char )*__cil_tmp40;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
          {
#line 3510
          MD5Update(& md5_context, dsd_buffer, (unsigned int )(samples_unpacked * num_channels));
#line 3511
          free(dsd_buffer);
          }
        } else {
          {
#line 3514
          store_samples___0(temp_buffer, temp_buffer, qmode, bps, samples_unpacked * num_channels);
#line 3515
          MD5Update(& md5_context, (unsigned char *)temp_buffer, (unsigned int )((bps * samples_unpacked) * num_channels));
          }
        }
      }
    } else {
#line 3520
      goto while_break___0;
    }
    {
#line 3522
    __cil_tmp41 = check_break();
    }
#line 3522
    if (__cil_tmp41) {
      {
#line 3526
      fprintf(stderr, "\n\037w?dU");
#line 3528
      fflush(stderr);
#line 3529
      result = 1;
      }
#line 3530
      goto while_break___0;
    }
    {
#line 3533
    __cil_tmp43 = WavpackGetProgress(wpc);
#line 3533
    __cil_tmp44 = floor((__cil_tmp43 * (100. - encode_time_percent) + encode_time_percent) + 0.5);
    }
    {
#line 3533
    __cil_tmp42 = WavpackGetProgress(wpc);
    }
#line 3533
    if (__cil_tmp42 != - 1.) {
#line 3533
      if (progress != __cil_tmp44) {
        {
#line 3536
        __cil_tmp45 = WavpackGetProgress(wpc);
#line 3536
        __cil_tmp46 = floor((__cil_tmp45 * (100. - encode_time_percent) + encode_time_percent) + 0.5);
#line 3536
        progress = __cil_tmp46;
#line 3537
        display_progress___0(progress / 100.);
        }
#line 3539
        if (! quiet_mode___2) {
          {
#line 3540
          fprintf(stderr, "%s%3d%% done...", "\b\b\b\b\b\b\b\b\b\b\b\b", (int )progress);
#line 3542
          fflush(stderr);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3547
  free(temp_buffer);
  }
#line 3549
  if (new_channel_order) {
    {
#line 3550
    free(new_channel_order);
    }
  }
#line 3556
  if (md5_digest_source) {
#line 3556
    if (result == 0) {
      {
#line 3557
      MD5Final((unsigned char *)md5_digest_result, & md5_context);
#line 3559
      __cil_tmp47 = memcmp((unsigned char *)md5_digest_result, md5_digest_source,
                           (unsigned long )16);
      }
#line 3559
      if (__cil_tmp47) {
#line 3560
        md5_string1 = "00000000000000000000000000000000\f8w?dU";
#line 3561
        md5_string2 = "00000000000000000000000000000000\f2w?dU";
#line 3564
        i___0 = 0;
        {
#line 3564
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3564
          if (! (i___0 < 16)) {
#line 3564
            goto while_break___4;
          }
          {
#line 3565
          sprintf((char *)md5_string1 + i___0 * 2, "%02xdU", (int )*(md5_digest_source + i___0));
#line 3566
          sprintf((char *)md5_string2 + i___0 * 2, "%02xdU", (int )md5_digest_result[i___0]);
          }
#line 3564
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 3569
        error_line("original md5: %s\230\001", (char *)md5_string1);
#line 3570
        error_line("verified md5: %s\230\001", (char *)md5_string2);
#line 3571
        error_line("MD5 signatures should match, but do not!\220");
#line 3572
        result = 1;
        }
      }
    }
  }
#line 3582
  if (result == 0) {
    {
#line 3583
    __cil_tmp51 = WavpackGetNumSamples64(wpc);
    }
#line 3583
    if (__cil_tmp51 != -1L) {
      {
#line 3584
      __cil_tmp52 = WavpackGetNumSamples64(wpc);
      }
#line 3584
      if (total_unpacked_samples < __cil_tmp52) {
        {
#line 3585
        __cil_tmp53 = WavpackGetNumSamples64(wpc);
#line 3585
        error_line("file is missing %llu samples!U", __cil_tmp53 - total_unpacked_samples);
#line 3587
        result = 1;
        }
      } else {
        {
#line 3589
        __cil_tmp54 = WavpackGetNumSamples64(wpc);
        }
#line 3589
        if (total_unpacked_samples > __cil_tmp54) {
          {
#line 3590
          __cil_tmp55 = WavpackGetNumSamples64(wpc);
#line 3590
          error_line("file has %llu extra samples!dU", total_unpacked_samples - __cil_tmp55);
#line 3592
          result = 1;
          }
        }
      }
    }
    {
#line 3596
    __cil_tmp56 = WavpackGetNumErrors(wpc);
    }
#line 3596
    if (__cil_tmp56) {
      {
#line 3597
      __cil_tmp57 = WavpackGetNumErrors(wpc);
#line 3597
      error_line("missing data or crc errors detected in %d block(s)!", __cil_tmp57);
#line 3598
      result = 1;
      }
    }
  }
  {
#line 3602
  WavpackCloseFile(wpc);
  }
#line 3603
  return (result);
}
}
#line 3610 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void make_settings_string(char *settings , WavpackConfig *config ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int tmp ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char const   *tmp___0 ;
  unsigned long __cil_tmp9 ;

  {
  {
#line 3612
  strcpy(settings, "-Sw?dU");
  }
#line 3616
  if (config->flags & 512) {
    {
#line 3617
    strcat(settings, "f\317u?dU");
    }
  } else
#line 3618
  if (config->flags & 4096) {
    {
#line 3619
    strcat(settings, "hh");
    }
  } else
#line 3620
  if (config->flags & 2048) {
    {
#line 3621
    strcat(settings, "h\341v?dU");
    }
  }
#line 3623
  if (config->flags & 8) {
    {
#line 3624
    __cil_tmp3 = strlen((char const   *)settings);
#line 3624
    sprintf(settings + __cil_tmp3, "b%g?dU", (double )config->bitrate);
    }
#line 3626
    if (config->flags & 1048576) {
      {
#line 3627
      strcat(settings, "ccv?dU");
      }
    } else
#line 3628
    if (config->flags & 524288) {
      {
#line 3629
      strcat(settings, "c");
      }
    }
  }
#line 3632
  if (config->flags & 33554432) {
    {
#line 3633
    __cil_tmp4 = strlen((char const   *)settings);
    }
#line 3633
    if (config->xmode) {
#line 3633
      tmp = config->xmode;
    } else {
#line 3633
      tmp = 1;
    }
    {
#line 3633
    sprintf(settings + __cil_tmp4, "x%d", tmp);
    }
  }
#line 3637
  if (config->flags & 65536) {
#line 3638
    if (config->flags & 16) {
      {
#line 3639
      strcat(settings, "j1");
      }
    } else {
      {
#line 3641
      strcat(settings, "j0");
      }
    }
  }
#line 3644
  if (config->flags & 32768) {
    {
#line 3645
    __cil_tmp6 = strlen((char const   *)settings);
#line 3645
    sprintf(settings + __cil_tmp6, "s%g", (double )config->shaping_weight);
    }
  }
#line 3649
  if (quantize_bits) {
    {
#line 3650
    __cil_tmp7 = strlen((char const   *)settings);
    }
#line 3650
    if (quantize_round) {
#line 3650
      tmp___0 = "-round";
    } else {
#line 3650
      tmp___0 = "\220";
    }
    {
#line 3650
    sprintf(settings + __cil_tmp7, " --pre-quantize%s=%ddU", tmp___0, quantize_bits);
    }
  }
#line 3653
  if (config->block_samples) {
    {
#line 3654
    __cil_tmp9 = strlen((char const   *)settings);
#line 3654
    sprintf(settings + __cil_tmp9, " --blocksize=%d", config->block_samples);
    }
  }
#line 3656
  if (config->flags & 131072) {
    {
#line 3657
    strcat(settings, " --use-dnsu?dU");
    }
  }
#line 3659
  if (config->flags & 32) {
    {
#line 3660
    strcat(settings, " --cross-decorr");
    }
  }
#line 3662
  if (config->flags & 268435456) {
    {
#line 3663
    strcat(settings, " --merge-blocks");
    }
  }
#line 3665
  if (config->flags & 536870912) {
    {
#line 3666
    strcat(settings, " --pair-unassigned-chans\220");
    }
  }
#line 3668
  if (allow_huge_tags___0) {
    {
#line 3669
    strcat(settings, " --allow-huge-tags");
    }
  }
  return;
}
}
#line 3678
static void load_little_endian_unsigned_samples(int32_t *dst , void *src , int bps ,
                                                int count ) ;
#line 3679
static void load_little_endian_signed_samples(int32_t *dst , void *src , int bps ,
                                              int count ) ;
#line 3680
static void load_big_endian_unsigned_samples(int32_t *dst , void *src , int bps ,
                                             int count ) ;
#line 3681
static void load_big_endian_signed_samples(int32_t *dst , void *src , int bps , int count ) ;
#line 3683 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void load_samples(int32_t *dst , void *src , int qmode , int bps , int count ) 
{ 


  {
#line 3685
  if (qmode & 1) {
#line 3686
    if (qmode & 4) {
      {
      {
#line 3687
      load_big_endian_unsigned_samples(dst, src, bps, count);
      }
      }
    } else
#line 3686
    if (bps == 1) {
#line 3686
      if (! (qmode & 2)) {
        {
        {
#line 3687
        load_big_endian_unsigned_samples(dst, src, bps, count);
        }
        }
      } else {
        {
        {
#line 3689
        load_big_endian_signed_samples(dst, src, bps, count);
        }
        }
      }
    } else {
      {
      {
#line 3689
      load_big_endian_signed_samples(dst, src, bps, count);
      }
      }
    }
  } else
#line 3691
  if (qmode & 4) {
    {
    {
#line 3692
    load_little_endian_unsigned_samples(dst, src, bps, count);
    }
    }
  } else
#line 3691
  if (bps == 1) {
#line 3691
    if (! (qmode & 2)) {
      {
      {
#line 3692
      load_little_endian_unsigned_samples(dst, src, bps, count);
      }
      }
    } else {
      {
      {
#line 3694
      load_little_endian_signed_samples(dst, src, bps, count);
      }
      }
    }
  } else {
    {
    {
#line 3694
    load_little_endian_signed_samples(dst, src, bps, count);
    }
    }
  }
  return;
}
}
#line 3697 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void load_little_endian_unsigned_samples(int32_t *dst , void *src , int bps ,
                                                int count ) 
{ 
  unsigned char *sptr ;
  int __cil_tmp6 ;
  int32_t *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int32_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  int __cil_tmp13 ;
  int32_t *__cil_tmp14 ;

  {
#line 3699
  sptr = src;
  {
#line 3703
  if (bps == 1) {
#line 3703
    goto case_1;
  }
#line 3709
  if (bps == 2) {
#line 3709
    goto case_2;
  }
#line 3717
  if (bps == 3) {
#line 3717
    goto case_3;
  }
#line 3725
  if (bps == 4) {
#line 3725
    goto case_4;
  }
#line 3701
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 3704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3704
    __cil_tmp6 = count;
#line 3704
    count --;
#line 3704
    if (! __cil_tmp6) {
#line 3704
      goto while_break;
    }
#line 3705
    __cil_tmp8 = sptr;
#line 3705
    sptr ++;
#line 3705
    __cil_tmp7 = dst;
#line 3705
    dst ++;
#line 3705
    *__cil_tmp7 = (int )*__cil_tmp8 - 128;
  }
  while_break: /* CIL Label */ ;
  }
#line 3707
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3710
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3710
    __cil_tmp9 = count;
#line 3710
    count --;
#line 3710
    if (! __cil_tmp9) {
#line 3710
      goto while_break___0;
    }
#line 3711
    __cil_tmp10 = dst;
#line 3711
    dst ++;
#line 3711
    *__cil_tmp10 = ((int )*(sptr + 0) | ((int32_t )*(sptr + 1) << 8)) - 32768;
#line 3712
    sptr += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3715
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3718
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3718
    __cil_tmp11 = count;
#line 3718
    count --;
#line 3718
    if (! __cil_tmp11) {
#line 3718
      goto while_break___1;
    }
#line 3719
    __cil_tmp12 = dst;
#line 3719
    dst ++;
#line 3719
    *__cil_tmp12 = (((int )*(sptr + 0) | ((int32_t )*(sptr + 1) << 8)) | ((int32_t )*(sptr + 2) << 16)) - 8388608;
#line 3720
    sptr += 3;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3723
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 3726
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3726
    __cil_tmp13 = count;
#line 3726
    count --;
#line 3726
    if (! __cil_tmp13) {
#line 3726
      goto while_break___2;
    }
#line 3727
    __cil_tmp14 = dst;
#line 3727
    dst ++;
#line 3727
    *__cil_tmp14 = (int32_t )((unsigned int )((((int )*(sptr + 0) | ((int32_t )*(sptr + 1) << 8)) | ((int32_t )*(sptr + 2) << 16)) | ((int32_t )*(sptr + 3) << 24)) - 2147483648U);
#line 3728
    sptr += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3731
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 3735 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void load_little_endian_signed_samples(int32_t *dst , void *src , int bps ,
                                              int count ) 
{ 
  unsigned char *sptr ;
  int __cil_tmp6 ;
  int32_t *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int32_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  int __cil_tmp13 ;
  int32_t *__cil_tmp14 ;

  {
#line 3737
  sptr = src;
  {
#line 3741
  if (bps == 1) {
#line 3741
    goto case_1;
  }
#line 3747
  if (bps == 2) {
#line 3747
    goto case_2;
  }
#line 3755
  if (bps == 3) {
#line 3755
    goto case_3;
  }
#line 3763
  if (bps == 4) {
#line 3763
    goto case_4;
  }
#line 3739
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 3742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3742
    __cil_tmp6 = count;
#line 3742
    count --;
#line 3742
    if (! __cil_tmp6) {
#line 3742
      goto while_break;
    }
#line 3743
    __cil_tmp8 = sptr;
#line 3743
    sptr ++;
#line 3743
    __cil_tmp7 = dst;
#line 3743
    dst ++;
#line 3743
    *__cil_tmp7 = (int32_t )((signed char )*__cil_tmp8);
  }
  while_break: /* CIL Label */ ;
  }
#line 3745
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3748
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3748
    __cil_tmp9 = count;
#line 3748
    count --;
#line 3748
    if (! __cil_tmp9) {
#line 3748
      goto while_break___0;
    }
#line 3749
    __cil_tmp10 = dst;
#line 3749
    dst ++;
#line 3749
    *__cil_tmp10 = (int )*(sptr + 0) | ((int32_t )((signed char )*(sptr + 1)) << 8);
#line 3750
    sptr += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3753
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3756
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3756
    __cil_tmp11 = count;
#line 3756
    count --;
#line 3756
    if (! __cil_tmp11) {
#line 3756
      goto while_break___1;
    }
#line 3757
    __cil_tmp12 = dst;
#line 3757
    dst ++;
#line 3757
    *__cil_tmp12 = ((int )*(sptr + 0) | ((int32_t )*(sptr + 1) << 8)) | ((int32_t )((signed char )*(sptr + 2)) << 16);
#line 3758
    sptr += 3;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3761
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 3764
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3764
    __cil_tmp13 = count;
#line 3764
    count --;
#line 3764
    if (! __cil_tmp13) {
#line 3764
      goto while_break___2;
    }
#line 3765
    __cil_tmp14 = dst;
#line 3765
    dst ++;
#line 3765
    *__cil_tmp14 = (((int )*(sptr + 0) | ((int32_t )*(sptr + 1) << 8)) | ((int32_t )*(sptr + 2) << 16)) | ((int32_t )((signed char )*(sptr + 3)) << 24);
#line 3766
    sptr += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3769
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 3773 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void load_big_endian_unsigned_samples(int32_t *dst , void *src , int bps ,
                                             int count ) 
{ 
  unsigned char *sptr ;
  int __cil_tmp6 ;
  int32_t *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int32_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  int __cil_tmp13 ;
  int32_t *__cil_tmp14 ;

  {
#line 3775
  sptr = src;
  {
#line 3779
  if (bps == 1) {
#line 3779
    goto case_1;
  }
#line 3785
  if (bps == 2) {
#line 3785
    goto case_2;
  }
#line 3793
  if (bps == 3) {
#line 3793
    goto case_3;
  }
#line 3801
  if (bps == 4) {
#line 3801
    goto case_4;
  }
#line 3777
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 3780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3780
    __cil_tmp6 = count;
#line 3780
    count --;
#line 3780
    if (! __cil_tmp6) {
#line 3780
      goto while_break;
    }
#line 3781
    __cil_tmp8 = sptr;
#line 3781
    sptr ++;
#line 3781
    __cil_tmp7 = dst;
#line 3781
    dst ++;
#line 3781
    *__cil_tmp7 = (int )*__cil_tmp8 - 128;
  }
  while_break: /* CIL Label */ ;
  }
#line 3783
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3786
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3786
    __cil_tmp9 = count;
#line 3786
    count --;
#line 3786
    if (! __cil_tmp9) {
#line 3786
      goto while_break___0;
    }
#line 3787
    __cil_tmp10 = dst;
#line 3787
    dst ++;
#line 3787
    *__cil_tmp10 = ((int )*(sptr + 1) | ((int32_t )*(sptr + 0) << 8)) - 32768;
#line 3788
    sptr += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3791
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3794
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3794
    __cil_tmp11 = count;
#line 3794
    count --;
#line 3794
    if (! __cil_tmp11) {
#line 3794
      goto while_break___1;
    }
#line 3795
    __cil_tmp12 = dst;
#line 3795
    dst ++;
#line 3795
    *__cil_tmp12 = (((int )*(sptr + 2) | ((int32_t )*(sptr + 1) << 8)) | ((int32_t )*(sptr + 0) << 16)) - 8388608;
#line 3796
    sptr += 3;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3799
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 3802
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3802
    __cil_tmp13 = count;
#line 3802
    count --;
#line 3802
    if (! __cil_tmp13) {
#line 3802
      goto while_break___2;
    }
#line 3803
    __cil_tmp14 = dst;
#line 3803
    dst ++;
#line 3803
    *__cil_tmp14 = (int32_t )((unsigned int )((((int )*(sptr + 3) | ((int32_t )*(sptr + 2) << 8)) | ((int32_t )*(sptr + 1) << 16)) | ((int32_t )*(sptr + 0) << 24)) - 2147483648U);
#line 3804
    sptr += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3807
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 3811 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void load_big_endian_signed_samples(int32_t *dst , void *src , int bps , int count ) 
{ 
  unsigned char *sptr ;
  int __cil_tmp6 ;
  int32_t *__cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int32_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  int __cil_tmp13 ;
  int32_t *__cil_tmp14 ;

  {
#line 3813
  sptr = src;
  {
#line 3817
  if (bps == 1) {
#line 3817
    goto case_1;
  }
#line 3823
  if (bps == 2) {
#line 3823
    goto case_2;
  }
#line 3831
  if (bps == 3) {
#line 3831
    goto case_3;
  }
#line 3839
  if (bps == 4) {
#line 3839
    goto case_4;
  }
#line 3815
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 3818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3818
    __cil_tmp6 = count;
#line 3818
    count --;
#line 3818
    if (! __cil_tmp6) {
#line 3818
      goto while_break;
    }
#line 3819
    __cil_tmp8 = sptr;
#line 3819
    sptr ++;
#line 3819
    __cil_tmp7 = dst;
#line 3819
    dst ++;
#line 3819
    *__cil_tmp7 = (int32_t )((signed char )*__cil_tmp8);
  }
  while_break: /* CIL Label */ ;
  }
#line 3821
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3824
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3824
    __cil_tmp9 = count;
#line 3824
    count --;
#line 3824
    if (! __cil_tmp9) {
#line 3824
      goto while_break___0;
    }
#line 3825
    __cil_tmp10 = dst;
#line 3825
    dst ++;
#line 3825
    *__cil_tmp10 = (int )*(sptr + 1) | ((int32_t )((signed char )*(sptr + 0)) << 8);
#line 3826
    sptr += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3829
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3832
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3832
    __cil_tmp11 = count;
#line 3832
    count --;
#line 3832
    if (! __cil_tmp11) {
#line 3832
      goto while_break___1;
    }
#line 3833
    __cil_tmp12 = dst;
#line 3833
    dst ++;
#line 3833
    *__cil_tmp12 = ((int )*(sptr + 2) | ((int32_t )*(sptr + 1) << 8)) | ((int32_t )((signed char )*(sptr + 0)) << 16);
#line 3834
    sptr += 3;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3837
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 3840
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3840
    __cil_tmp13 = count;
#line 3840
    count --;
#line 3840
    if (! __cil_tmp13) {
#line 3840
      goto while_break___2;
    }
#line 3841
    __cil_tmp14 = dst;
#line 3841
    dst ++;
#line 3841
    *__cil_tmp14 = (((int )*(sptr + 3) | ((int32_t )*(sptr + 2) << 8)) | ((int32_t )*(sptr + 1) << 16)) | ((int32_t )((signed char )*(sptr + 0)) << 24);
#line 3842
    sptr += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3845
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 3855
static void *store_little_endian_unsigned_samples___0(void *dst , int32_t *src , int bps ,
                                                      int count ) ;
#line 3856
static void *store_little_endian_signed_samples___0(void *dst , int32_t *src , int bps ,
                                                    int count ) ;
#line 3857
static void *store_big_endian_unsigned_samples___0(void *dst , int32_t *src , int bps ,
                                                   int count ) ;
#line 3858
static void *store_big_endian_signed_samples___0(void *dst , int32_t *src , int bps ,
                                                 int count ) ;
#line 3860 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void *store_samples___0(void *dst , int32_t *src , int qmode , int bps , int count ) 
{ 
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 3862
  if (qmode & 1) {
#line 3863
    if (qmode & 4) {
      {
      {
#line 3864
      __cil_tmp6 = store_big_endian_unsigned_samples___0(dst, src, bps, count);
      }
      }
#line 3864
      return (__cil_tmp6);
    } else
#line 3863
    if (bps == 1) {
#line 3863
      if (! (qmode & 2)) {
        {
        {
#line 3864
        __cil_tmp6 = store_big_endian_unsigned_samples___0(dst, src, bps, count);
        }
        }
#line 3864
        return (__cil_tmp6);
      } else {
        {
        {
#line 3866
        __cil_tmp7 = store_big_endian_signed_samples___0(dst, src, bps, count);
        }
        }
#line 3866
        return (__cil_tmp7);
      }
    } else {
      {
      {
#line 3866
      __cil_tmp7 = store_big_endian_signed_samples___0(dst, src, bps, count);
      }
      }
#line 3866
      return (__cil_tmp7);
    }
  } else
#line 3868
  if (qmode & 4) {
    {
    {
#line 3869
    __cil_tmp8 = store_little_endian_unsigned_samples___0(dst, src, bps, count);
    }
    }
#line 3869
    return (__cil_tmp8);
  } else
#line 3868
  if (bps == 1) {
#line 3868
    if (! (qmode & 2)) {
      {
      {
#line 3869
      __cil_tmp8 = store_little_endian_unsigned_samples___0(dst, src, bps, count);
      }
      }
#line 3869
      return (__cil_tmp8);
    } else {
      {
      {
#line 3871
      __cil_tmp9 = store_little_endian_signed_samples___0(dst, src, bps, count);
      }
      }
#line 3871
      return (__cil_tmp9);
    }
  } else {
    {
    {
#line 3871
    __cil_tmp9 = store_little_endian_signed_samples___0(dst, src, bps, count);
    }
    }
#line 3871
    return (__cil_tmp9);
  }
}
}
#line 3874 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void *store_little_endian_unsigned_samples___0(void *dst , int32_t *src , int bps ,
                                                      int count ) 
{ 
  unsigned char *dptr ;
  int32_t temp ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int32_t *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int32_t *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int32_t *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;

  {
#line 3876
  dptr = dst;
  {
#line 3881
  if (bps == 1) {
#line 3881
    goto case_1;
  }
#line 3887
  if (bps == 2) {
#line 3887
    goto case_2;
  }
#line 3895
  if (bps == 3) {
#line 3895
    goto case_3;
  }
#line 3904
  if (bps == 4) {
#line 3904
    goto case_4;
  }
#line 3879
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 3882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3882
    __cil_tmp7 = count;
#line 3882
    count --;
#line 3882
    if (! __cil_tmp7) {
#line 3882
      goto while_break;
    }
#line 3883
    __cil_tmp9 = src;
#line 3883
    src ++;
#line 3883
    __cil_tmp8 = dptr;
#line 3883
    dptr ++;
#line 3883
    *__cil_tmp8 = (unsigned char )(*__cil_tmp9 + 128);
  }
  while_break: /* CIL Label */ ;
  }
#line 3885
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3888
    __cil_tmp10 = count;
#line 3888
    count --;
#line 3888
    if (! __cil_tmp10) {
#line 3888
      goto while_break___0;
    }
#line 3889
    __cil_tmp12 = src;
#line 3889
    src ++;
#line 3889
    temp = *__cil_tmp12 + 32768;
#line 3889
    __cil_tmp11 = dptr;
#line 3889
    dptr ++;
#line 3889
    *__cil_tmp11 = (unsigned char )temp;
#line 3890
    __cil_tmp13 = dptr;
#line 3890
    dptr ++;
#line 3890
    *__cil_tmp13 = (unsigned char )(temp >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3893
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3896
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3896
    __cil_tmp14 = count;
#line 3896
    count --;
#line 3896
    if (! __cil_tmp14) {
#line 3896
      goto while_break___1;
    }
#line 3897
    __cil_tmp16 = src;
#line 3897
    src ++;
#line 3897
    temp = *__cil_tmp16 + 8388608;
#line 3897
    __cil_tmp15 = dptr;
#line 3897
    dptr ++;
#line 3897
    *__cil_tmp15 = (unsigned char )temp;
#line 3898
    __cil_tmp17 = dptr;
#line 3898
    dptr ++;
#line 3898
    *__cil_tmp17 = (unsigned char )(temp >> 8);
#line 3899
    __cil_tmp18 = dptr;
#line 3899
    dptr ++;
#line 3899
    *__cil_tmp18 = (unsigned char )(temp >> 16);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3902
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 3905
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3905
    __cil_tmp19 = count;
#line 3905
    count --;
#line 3905
    if (! __cil_tmp19) {
#line 3905
      goto while_break___2;
    }
#line 3906
    __cil_tmp21 = src;
#line 3906
    src ++;
#line 3906
    temp = (int32_t )((unsigned int )*__cil_tmp21 + 2147483648U);
#line 3906
    __cil_tmp20 = dptr;
#line 3906
    dptr ++;
#line 3906
    *__cil_tmp20 = (unsigned char )temp;
#line 3907
    __cil_tmp22 = dptr;
#line 3907
    dptr ++;
#line 3907
    *__cil_tmp22 = (unsigned char )(temp >> 8);
#line 3908
    __cil_tmp23 = dptr;
#line 3908
    dptr ++;
#line 3908
    *__cil_tmp23 = (unsigned char )(temp >> 16);
#line 3909
    __cil_tmp24 = dptr;
#line 3909
    dptr ++;
#line 3909
    *__cil_tmp24 = (unsigned char )(temp >> 24);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3912
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3915
  return (dptr);
}
}
#line 3918 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void *store_little_endian_signed_samples___0(void *dst , int32_t *src , int bps ,
                                                    int count ) 
{ 
  unsigned char *dptr ;
  int32_t temp ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int32_t *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int32_t *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int32_t *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;

  {
#line 3920
  dptr = dst;
  {
#line 3925
  if (bps == 1) {
#line 3925
    goto case_1;
  }
#line 3931
  if (bps == 2) {
#line 3931
    goto case_2;
  }
#line 3939
  if (bps == 3) {
#line 3939
    goto case_3;
  }
#line 3948
  if (bps == 4) {
#line 3948
    goto case_4;
  }
#line 3923
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 3926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3926
    __cil_tmp7 = count;
#line 3926
    count --;
#line 3926
    if (! __cil_tmp7) {
#line 3926
      goto while_break;
    }
#line 3927
    __cil_tmp9 = src;
#line 3927
    src ++;
#line 3927
    __cil_tmp8 = dptr;
#line 3927
    dptr ++;
#line 3927
    *__cil_tmp8 = (unsigned char )*__cil_tmp9;
  }
  while_break: /* CIL Label */ ;
  }
#line 3929
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3932
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3932
    __cil_tmp10 = count;
#line 3932
    count --;
#line 3932
    if (! __cil_tmp10) {
#line 3932
      goto while_break___0;
    }
#line 3933
    __cil_tmp12 = src;
#line 3933
    src ++;
#line 3933
    temp = *__cil_tmp12;
#line 3933
    __cil_tmp11 = dptr;
#line 3933
    dptr ++;
#line 3933
    *__cil_tmp11 = (unsigned char )temp;
#line 3934
    __cil_tmp13 = dptr;
#line 3934
    dptr ++;
#line 3934
    *__cil_tmp13 = (unsigned char )(temp >> 8);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3937
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3940
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3940
    __cil_tmp14 = count;
#line 3940
    count --;
#line 3940
    if (! __cil_tmp14) {
#line 3940
      goto while_break___1;
    }
#line 3941
    __cil_tmp16 = src;
#line 3941
    src ++;
#line 3941
    temp = *__cil_tmp16;
#line 3941
    __cil_tmp15 = dptr;
#line 3941
    dptr ++;
#line 3941
    *__cil_tmp15 = (unsigned char )temp;
#line 3942
    __cil_tmp17 = dptr;
#line 3942
    dptr ++;
#line 3942
    *__cil_tmp17 = (unsigned char )(temp >> 8);
#line 3943
    __cil_tmp18 = dptr;
#line 3943
    dptr ++;
#line 3943
    *__cil_tmp18 = (unsigned char )(temp >> 16);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3946
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 3949
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3949
    __cil_tmp19 = count;
#line 3949
    count --;
#line 3949
    if (! __cil_tmp19) {
#line 3949
      goto while_break___2;
    }
#line 3950
    __cil_tmp21 = src;
#line 3950
    src ++;
#line 3950
    temp = *__cil_tmp21;
#line 3950
    __cil_tmp20 = dptr;
#line 3950
    dptr ++;
#line 3950
    *__cil_tmp20 = (unsigned char )temp;
#line 3951
    __cil_tmp22 = dptr;
#line 3951
    dptr ++;
#line 3951
    *__cil_tmp22 = (unsigned char )(temp >> 8);
#line 3952
    __cil_tmp23 = dptr;
#line 3952
    dptr ++;
#line 3952
    *__cil_tmp23 = (unsigned char )(temp >> 16);
#line 3953
    __cil_tmp24 = dptr;
#line 3953
    dptr ++;
#line 3953
    *__cil_tmp24 = (unsigned char )(temp >> 24);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3956
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3959
  return (dptr);
}
}
#line 3962 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void *store_big_endian_unsigned_samples___0(void *dst , int32_t *src , int bps ,
                                                   int count ) 
{ 
  unsigned char *dptr ;
  int32_t temp ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int32_t *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int32_t *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int32_t *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;

  {
#line 3964
  dptr = dst;
  {
#line 3969
  if (bps == 1) {
#line 3969
    goto case_1;
  }
#line 3975
  if (bps == 2) {
#line 3975
    goto case_2;
  }
#line 3983
  if (bps == 3) {
#line 3983
    goto case_3;
  }
#line 3992
  if (bps == 4) {
#line 3992
    goto case_4;
  }
#line 3967
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 3970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3970
    __cil_tmp7 = count;
#line 3970
    count --;
#line 3970
    if (! __cil_tmp7) {
#line 3970
      goto while_break;
    }
#line 3971
    __cil_tmp9 = src;
#line 3971
    src ++;
#line 3971
    __cil_tmp8 = dptr;
#line 3971
    dptr ++;
#line 3971
    *__cil_tmp8 = (unsigned char )(*__cil_tmp9 + 128);
  }
  while_break: /* CIL Label */ ;
  }
#line 3973
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3976
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3976
    __cil_tmp10 = count;
#line 3976
    count --;
#line 3976
    if (! __cil_tmp10) {
#line 3976
      goto while_break___0;
    }
#line 3977
    __cil_tmp12 = src;
#line 3977
    src ++;
#line 3977
    temp = *__cil_tmp12 + 32768;
#line 3977
    __cil_tmp11 = dptr;
#line 3977
    dptr ++;
#line 3977
    *__cil_tmp11 = (unsigned char )(temp >> 8);
#line 3978
    __cil_tmp13 = dptr;
#line 3978
    dptr ++;
#line 3978
    *__cil_tmp13 = (unsigned char )temp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3981
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3984
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3984
    __cil_tmp14 = count;
#line 3984
    count --;
#line 3984
    if (! __cil_tmp14) {
#line 3984
      goto while_break___1;
    }
#line 3985
    __cil_tmp16 = src;
#line 3985
    src ++;
#line 3985
    temp = *__cil_tmp16 + 8388608;
#line 3985
    __cil_tmp15 = dptr;
#line 3985
    dptr ++;
#line 3985
    *__cil_tmp15 = (unsigned char )(temp >> 16);
#line 3986
    __cil_tmp17 = dptr;
#line 3986
    dptr ++;
#line 3986
    *__cil_tmp17 = (unsigned char )(temp >> 8);
#line 3987
    __cil_tmp18 = dptr;
#line 3987
    dptr ++;
#line 3987
    *__cil_tmp18 = (unsigned char )temp;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3990
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 3993
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3993
    __cil_tmp19 = count;
#line 3993
    count --;
#line 3993
    if (! __cil_tmp19) {
#line 3993
      goto while_break___2;
    }
#line 3994
    __cil_tmp21 = src;
#line 3994
    src ++;
#line 3994
    temp = (int32_t )((unsigned int )*__cil_tmp21 + 2147483648U);
#line 3994
    __cil_tmp20 = dptr;
#line 3994
    dptr ++;
#line 3994
    *__cil_tmp20 = (unsigned char )(temp >> 24);
#line 3995
    __cil_tmp22 = dptr;
#line 3995
    dptr ++;
#line 3995
    *__cil_tmp22 = (unsigned char )(temp >> 16);
#line 3996
    __cil_tmp23 = dptr;
#line 3996
    dptr ++;
#line 3996
    *__cil_tmp23 = (unsigned char )(temp >> 8);
#line 3997
    __cil_tmp24 = dptr;
#line 3997
    dptr ++;
#line 3997
    *__cil_tmp24 = (unsigned char )temp;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 4000
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4003
  return (dptr);
}
}
#line 4006 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void *store_big_endian_signed_samples___0(void *dst , int32_t *src , int bps ,
                                                 int count ) 
{ 
  unsigned char *dptr ;
  int32_t temp ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int32_t *__cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int32_t *__cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int32_t *__cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  int __cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int32_t *__cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  unsigned char *__cil_tmp23 ;
  unsigned char *__cil_tmp24 ;

  {
#line 4008
  dptr = dst;
  {
#line 4013
  if (bps == 1) {
#line 4013
    goto case_1;
  }
#line 4019
  if (bps == 2) {
#line 4019
    goto case_2;
  }
#line 4027
  if (bps == 3) {
#line 4027
    goto case_3;
  }
#line 4036
  if (bps == 4) {
#line 4036
    goto case_4;
  }
#line 4011
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 4014
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4014
    __cil_tmp7 = count;
#line 4014
    count --;
#line 4014
    if (! __cil_tmp7) {
#line 4014
      goto while_break;
    }
#line 4015
    __cil_tmp9 = src;
#line 4015
    src ++;
#line 4015
    __cil_tmp8 = dptr;
#line 4015
    dptr ++;
#line 4015
    *__cil_tmp8 = (unsigned char )*__cil_tmp9;
  }
  while_break: /* CIL Label */ ;
  }
#line 4017
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 4020
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4020
    __cil_tmp10 = count;
#line 4020
    count --;
#line 4020
    if (! __cil_tmp10) {
#line 4020
      goto while_break___0;
    }
#line 4021
    __cil_tmp12 = src;
#line 4021
    src ++;
#line 4021
    temp = *__cil_tmp12;
#line 4021
    __cil_tmp11 = dptr;
#line 4021
    dptr ++;
#line 4021
    *__cil_tmp11 = (unsigned char )(temp >> 8);
#line 4022
    __cil_tmp13 = dptr;
#line 4022
    dptr ++;
#line 4022
    *__cil_tmp13 = (unsigned char )temp;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4025
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 4028
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4028
    __cil_tmp14 = count;
#line 4028
    count --;
#line 4028
    if (! __cil_tmp14) {
#line 4028
      goto while_break___1;
    }
#line 4029
    __cil_tmp16 = src;
#line 4029
    src ++;
#line 4029
    temp = *__cil_tmp16;
#line 4029
    __cil_tmp15 = dptr;
#line 4029
    dptr ++;
#line 4029
    *__cil_tmp15 = (unsigned char )(temp >> 16);
#line 4030
    __cil_tmp17 = dptr;
#line 4030
    dptr ++;
#line 4030
    *__cil_tmp17 = (unsigned char )(temp >> 8);
#line 4031
    __cil_tmp18 = dptr;
#line 4031
    dptr ++;
#line 4031
    *__cil_tmp18 = (unsigned char )temp;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4034
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 4037
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 4037
    __cil_tmp19 = count;
#line 4037
    count --;
#line 4037
    if (! __cil_tmp19) {
#line 4037
      goto while_break___2;
    }
#line 4038
    __cil_tmp21 = src;
#line 4038
    src ++;
#line 4038
    temp = *__cil_tmp21;
#line 4038
    __cil_tmp20 = dptr;
#line 4038
    dptr ++;
#line 4038
    *__cil_tmp20 = (unsigned char )(temp >> 24);
#line 4039
    __cil_tmp22 = dptr;
#line 4039
    dptr ++;
#line 4039
    *__cil_tmp22 = (unsigned char )(temp >> 16);
#line 4040
    __cil_tmp23 = dptr;
#line 4040
    dptr ++;
#line 4040
    *__cil_tmp23 = (unsigned char )(temp >> 8);
#line 4041
    __cil_tmp24 = dptr;
#line 4041
    dptr ++;
#line 4041
    *__cil_tmp24 = (unsigned char )temp;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 4044
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4047
  return (dptr);
}
}
#line 4118 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void TextToUTF8___0(void *string , int len ) 
{ 
  char *temp ;
  void *__cil_tmp4 ;
  char *outp ;
  char *inp ;
  size_t insize ;
  size_t outsize ;
  int err ;
  char *old_locale ;
  iconv_t converter ;
  char *__cil_tmp12 ;
  uint16_t *utf16p ;
  uint16_t *__cil_tmp14 ;
  iconv_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  iconv_t __cil_tmp17 ;
  size_t __cil_tmp18 ;

  {
  {
#line 4120
  __cil_tmp4 = malloc((unsigned long )len);
#line 4120
  temp = __cil_tmp4;
#line 4121
  outp = temp;
#line 4122
  inp = string;
#line 4123
  insize = (size_t )0;
#line 4124
  outsize = (size_t )(len - 1);
#line 4125
  err = 0;
  }
#line 4131
  if (len > 3) {
#line 4131
    if ((int )((unsigned char )*(inp + 0)) == 239) {
#line 4131
      if ((int )((unsigned char )*(inp + 1)) == 187) {
#line 4131
        if ((int )((unsigned char )*(inp + 2)) == 191) {
          {
#line 4133
          memmove(inp, inp + 3, (unsigned long )(len - 3));
#line 4134
          *(inp + (len - 3)) = (char )0;
          }
#line 4135
          return;
        }
      }
    }
  }
  {
#line 4138
  memset(temp, 0, (unsigned long )len);
#line 4139
  old_locale = setlocale(0, "");
  }
#line 4141
  if ((int )((unsigned char )*(inp + 0)) == 255) {
#line 4141
    if ((int )((unsigned char )*(inp + 1)) == 254) {
#line 4142
      inp += 2;
#line 4142
      utf16p = (uint16_t *)inp;
      {
#line 4144
      while (1) {
        while_continue: /* CIL Label */ ;
#line 4144
        __cil_tmp14 = utf16p;
#line 4144
        utf16p ++;
#line 4144
        if (! *__cil_tmp14) {
#line 4144
          goto while_break;
        }
#line 4145
        insize += (unsigned long )2;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 4147
      converter = iconv_open("UTF-8", "UTF-16LE");
      }
    } else {
      {
      {
#line 4150
      insize = strlen(string);
      }
      {
#line 4151
      converter = iconv_open("UTF-8U", "\220");
      }
      }
    }
  } else {
    {
    {
#line 4150
    insize = strlen(string);
    }
    {
#line 4151
    converter = iconv_open("UTF-8U", "\220");
    }
    }
  }
#line 4154
  if (converter != (iconv_t )-1) {
    {
#line 4155
    __cil_tmp18 = iconv(converter, & inp, & insize, & outp, & outsize);
#line 4155
    err = (int )__cil_tmp18;
#line 4156
    iconv_close(converter);
    }
  } else {
#line 4159
    err = - 1;
  }
  {
#line 4161
  setlocale(0, (char const   *)old_locale);
  }
#line 4163
  if (err == -1) {
    {
#line 4164
    free(temp);
    }
#line 4165
    return;
  }
  {
#line 4168
  memmove(string, temp, (unsigned long )len);
#line 4169
  free(temp);
  }
  return;
}
}
#line 4181 "/doner/wavpack/wavpack-5.1.0/cli/wavpack.c"
static void display_progress___0(double file_progress ) 
{ 
  char title[40] ;

  {
#line 4185
  if (set_console_title___1) {
    {
#line 4186
    file_progress = ((double )file_index___1 + file_progress) / (double )num_files___1;
#line 4187
    sprintf((char *)title, "%d%% (WavPack)", (int )(file_progress * 100. + 0.5));
#line 4188
    DoSetConsoleTitle((char *)title);
    }
  }
  return;
}
}
#line 39 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
static unsigned char const   riff_guid___0[16]  = 
#line 39 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
  {      (unsigned char )'r',      (unsigned char )'i',      (unsigned char )'f',      (unsigned char )'f', 
        (unsigned char )46,      (unsigned char )145,      (unsigned char )207,      (unsigned char )17, 
        (unsigned char )165,      (unsigned char )214,      (unsigned char )40,      (unsigned char )219, 
        (unsigned char )4,      (unsigned char )193,      (unsigned char )0,      (unsigned char )0};
#line 40 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
static unsigned char const   wave_guid___0[16]  = 
#line 40
  {      (unsigned char )'w',      (unsigned char )'a',      (unsigned char )'v',      (unsigned char )'e', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 41 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
static unsigned char const   fmt_guid___0[16]  = 
#line 41
  {      (unsigned char )'f',      (unsigned char )'m',      (unsigned char )'t',      (unsigned char )' ', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 42 "/doner/wavpack/wavpack-5.1.0/cli/wave64.c"
static unsigned char const   data_guid___0[16]  = 
#line 42
  {      (unsigned char )'d',      (unsigned char )'a',      (unsigned char )'t',      (unsigned char )'a', 
        (unsigned char )243,      (unsigned char )172,      (unsigned char )211,      (unsigned char )17, 
        (unsigned char )140,      (unsigned char )209,      (unsigned char )0,      (unsigned char )192, 
        (unsigned char )79,      (unsigned char )142,      (unsigned char )219,      (unsigned char )138};
#line 302 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
static int waiting_input___2 ;
#line 580
static int break_flag___2 ;
#line 582 "/doner/wavpack/wavpack-5.1.0/cli/utils.c"
static void int_handler___2(int s ) 
{ 


  {
#line 584
  break_flag___2 = 1;
  return;
}
}
#line 24 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
static struct __anonstruct_253___0 text_tag_table___0[8]  = 
#line 24 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
  {      {"TALB", "Album"}, 
        {"TIT2", "Title"}, 
        {"TPE1", "Artist"}, 
        {"TCON", "Genre"}, 
        {"TYER", "Year"}, 
        {"TRCK", "Track"}, 
        {"TCOM", "Composer\250"}, 
        {"TPE3", "Conductor"}};
#line 37
static int WideCharToUTF8___0(wchar_t *Wide , unsigned char *pUTF8 , int len ) ;
#line 38
static void Latin1ToUTF8___0(void *string , int len ) ;
#line 300 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
static int WideCharToUTF8___0(wchar_t *Wide , unsigned char *pUTF8 , int len ) 
{ 
  wchar_t *pWide ;
  int outndx ;
  int __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  wchar_t *__cil_tmp14 ;

  {
#line 302
  pWide = Wide;
#line 303
  outndx = 0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! *pWide) {
#line 305
      goto while_break;
    }
#line 306
    if (*pWide < 128) {
#line 306
      if (outndx + 1 < len) {
#line 307
        __cil_tmp7 = pWide;
#line 307
        pWide ++;
#line 307
        __cil_tmp6 = outndx;
#line 307
        outndx ++;
#line 307
        *(pUTF8 + __cil_tmp6) = (unsigned char )*__cil_tmp7;
      } else {
#line 306
        goto _L___80;
      }
    } else
    _L___80: /* CIL Label */ 
#line 308
    if (*pWide < 2048) {
#line 308
      if (outndx + 2 < len) {
#line 309
        __cil_tmp8 = outndx;
#line 309
        outndx ++;
#line 309
        *(pUTF8 + __cil_tmp8) = (unsigned char )(192 | ((*pWide >> 6) & 31));
#line 310
        __cil_tmp10 = pWide;
#line 310
        pWide ++;
#line 310
        __cil_tmp9 = outndx;
#line 310
        outndx ++;
#line 310
        *(pUTF8 + __cil_tmp9) = (unsigned char )(128 | (*__cil_tmp10 & 63));
      } else {
#line 308
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 312
    if (outndx + 3 < len) {
#line 313
      __cil_tmp11 = outndx;
#line 313
      outndx ++;
#line 313
      *(pUTF8 + __cil_tmp11) = (unsigned char )(224 | ((*pWide >> 12) & 15));
#line 314
      __cil_tmp12 = outndx;
#line 314
      outndx ++;
#line 314
      *(pUTF8 + __cil_tmp12) = (unsigned char )(128 | ((*pWide >> 6) & 63));
#line 315
      __cil_tmp14 = pWide;
#line 315
      pWide ++;
#line 315
      __cil_tmp13 = outndx;
#line 315
      outndx ++;
#line 315
      *(pUTF8 + __cil_tmp13) = (unsigned char )(128 | (*__cil_tmp14 & 63));
    } else {
#line 318
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  *(pUTF8 + outndx) = (unsigned char )0;
#line 322
  return ((int )(pWide - Wide));
}
}
#line 349 "/doner/wavpack/wavpack-5.1.0/cli/import_id3.c"
static void Latin1ToUTF8___0(void *string , int len ) 
{ 
  char *temp ;
  void *__cil_tmp4 ;
  char *outp ;
  char *inp ;
  size_t insize ;
  size_t outsize ;
  int err ;
  iconv_t converter ;
  unsigned long __cil_tmp11 ;
  iconv_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 351
  __cil_tmp4 = malloc((unsigned long )len);
#line 351
  temp = __cil_tmp4;
#line 352
  outp = temp;
#line 353
  inp = string;
#line 354
  insize = (size_t )0;
#line 355
  outsize = (size_t )(len - 1);
#line 356
  err = 0;
#line 359
  memset(temp, 0, (unsigned long )len);
#line 361
  insize = strlen(string);
#line 362
  converter = iconv_open("UTF-8", "ISO-8859-1\344?dU");
  }
#line 364
  if (converter != (iconv_t )-1) {
    {
#line 365
    __cil_tmp13 = iconv(converter, & inp, & insize, & outp, & outsize);
#line 365
    err = (int )__cil_tmp13;
#line 366
    iconv_close(converter);
    }
  } else {
#line 369
    err = - 1;
  }
#line 371
  if (err == -1) {
    {
#line 372
    free(temp);
    }
#line 373
    return;
  }
  {
#line 376
  memmove(string, temp, (unsigned long )len);
#line 377
  free(temp);
  }
  return;
}
}
#line 65 "/doner/wavpack/wavpack-5.1.0/cli/dsf.c"
static uint16_t channel_masks___0[7]  = {      (uint16_t )4,      (uint16_t )3,      (uint16_t )7,      (uint16_t )51, 
        (uint16_t )15,      (uint16_t )55,      (uint16_t )63};
#line 92 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
static char const   TMH_full___0[21]  = 
#line 92 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
  {      (char )1,      (char )2,      (char )3,      (char )13, 
        (char )9,      (char )10,      (char )5,      (char )6, 
        (char )12,      (char )14,      (char )15,      (char )16, 
        (char )17,      (char )9,      (char )4,      (char )18, 
        (char )7,      (char )8,      (char )19,      (char )20, 
        (char )21};
#line 93 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
static char const   TMH_std___0[16]  = 
#line 93
  {      (char )1,      (char )2,      (char )3,      (char )11, 
        (char )8,      (char )9,      (char )5,      (char )6, 
        (char )10,      (char )12,      (char )13,      (char )14, 
        (char )15,      (char )7,      (char )4,      (char )16};
#line 100 "/doner/wavpack/wavpack-5.1.0/cli/caff.c"
static struct __anonstruct_166___0 layouts___0[47]  = 
#line 100
  {      {(uint32_t )((100 << 16) | 1), (uint32_t )4, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((101 << 16) | 2),
      (uint32_t )3, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((102 << 16) | 2), (uint32_t )3, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((103 << 16) | 2),
      (uint32_t )0, (char const   *)((void *)0), "&\'"}, 
        {(uint32_t )((104 << 16) | 2), (uint32_t )0, (char const   *)((void *)0), "\314\315"}, 
        {(uint32_t )((105 << 16) | 2),
      (uint32_t )0, (char const   *)((void *)0), "\316\317"}, 
        {(uint32_t )((106 << 16) | 2), (uint32_t )3, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((107 << 16) | 4),
      (uint32_t )0, (char const   *)((void *)0), "\310\311\312\313"}, 
        {(uint32_t )((108 << 16) | 4), (uint32_t )51, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((109 << 16) | 5),
      (uint32_t )55, "12453", (char const   *)((void *)0)}, 
        {(uint32_t )((110 << 16) | 6), (uint32_t )311, "124536", (char const   *)((void *)0)}, 
        {(uint32_t )((111 << 16) | 8),
      (uint32_t )1847, "12453678\251", (char const   *)((void *)0)}, 
        {(uint32_t )((112 << 16) | 8), (uint32_t )184371, (char const   *)((void *)0),
      (char const   *)((void *)0)}, 
        {(uint32_t )((113 << 16) | 3), (uint32_t )7, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((114 << 16) | 3),
      (uint32_t )7, "312", (char const   *)((void *)0)}, 
        {(uint32_t )((115 << 16) | 4), (uint32_t )263, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((116 << 16) | 4),
      (uint32_t )263, "3124", (char const   *)((void *)0)}, 
        {(uint32_t )((117 << 16) | 5), (uint32_t )55, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((118 << 16) | 5),
      (uint32_t )55, "12453", (char const   *)((void *)0)}, 
        {(uint32_t )((119 << 16) | 5), (uint32_t )55, "13245", (char const   *)((void *)0)}, 
        {(uint32_t )((120 << 16) | 5),
      (uint32_t )55, "31245", (char const   *)((void *)0)}, 
        {(uint32_t )((121 << 16) | 6), (uint32_t )63, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((122 << 16) | 6),
      (uint32_t )63, "125634", (char const   *)((void *)0)}, 
        {(uint32_t )((123 << 16) | 6), (uint32_t )63, "132564", (char const   *)((void *)0)}, 
        {(uint32_t )((124 << 16) | 6),
      (uint32_t )63, "312564", (char const   *)((void *)0)}, 
        {(uint32_t )((125 << 16) | 7), (uint32_t )319, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((126 << 16) | 8),
      (uint32_t )255, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((127 << 16) | 8), (uint32_t )255, "37812564\251", (char const   *)((void *)0)}, 
        {(uint32_t )((128 << 16) | 8),
      (uint32_t )63, (char const   *)((void *)0), "!\""}, 
        {(uint32_t )((129 << 16) | 8), (uint32_t )255, "12563478\251", (char const   *)((void *)0)}, 
        {(uint32_t )((130 << 16) | 8),
      (uint32_t )63, (char const   *)((void *)0), "&\'"}, 
        {(uint32_t )((131 << 16) | 3), (uint32_t )259, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((132 << 16) | 4),
      (uint32_t )51, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((133 << 16) | 3), (uint32_t )11, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((134 << 16) | 4),
      (uint32_t )267, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((135 << 16) | 5), (uint32_t )59, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((136 << 16) | 4),
      (uint32_t )15, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((137 << 16) | 5), (uint32_t )271, (char const   *)((void *)0), (char const   *)((void *)0)}, 
        {(uint32_t )((138 << 16) | 5),
      (uint32_t )59, "12453", (char const   *)((void *)0)}, 
        {(uint32_t )((139 << 16) | 6), (uint32_t )311, "124536", (char const   *)((void *)0)}, 
        {(uint32_t )((140 << 16) | 7),
      (uint32_t )55, "1245367", "!\""}, 
        {(uint32_t )((141 << 16) | 6), (uint32_t )311, "312456", (char const   *)((void *)0)}, 
        {(uint32_t )((142 << 16) | 7),
      (uint32_t )319, "3125674", (char const   *)((void *)0)}, 
        {(uint32_t )((143 << 16) | 7), (uint32_t )55, "3124567", "!\""}, 
        {(uint32_t )((144 << 16) | 8), (uint32_t )311, "31245786\323\001 ", "!\""}, 
        {(uint32_t )((145 << 16) | 16), (uint32_t )30527, (char const   *)TMH_std___0,
      "#$,%\033"}, 
        {(uint32_t )((146 << 16) | 21), (uint32_t )30719, (char const   *)TMH_full___0,
      "#$,% "}};
