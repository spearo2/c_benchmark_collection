# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 343 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 32 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 439 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 440 "/usr/include/features.h" 2 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 1 3 4
# 46 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stdarg.h" 1 3 4
# 14 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 32 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4








typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 77 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ ));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ ));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ ));
# 173 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) ;
# 187 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ )) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ )) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 279 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ )) ;
# 292 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ )) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ )) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ ));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ ));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ ));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ ));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 379 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ ));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf") ;


extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf") ;

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ ));
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ ))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 757 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ ));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ )) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ )) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ ));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;







extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ )) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ ));
# 840 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ ));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ )) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ ));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 33 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 1 3 4
# 74 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ )) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ )) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;
# 59 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 144 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;





# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{



  return ((__uint16_t) ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));

}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{



  return ((((__bsx) & 0xff000000u) >> 24) | (((__bsx) & 0x00ff0000u) >> 8) | (((__bsx) & 0x0000ff00u) << 8) | (((__bsx) & 0x000000ffu) << 24));

}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{



  return ((((__bsx) & 0xff00000000000000ull) >> 56) | (((__bsx) & 0x00ff000000000000ull) >> 40) | (((__bsx) & 0x0000ff0000000000ull) >> 24) | (((__bsx) & 0x000000ff00000000ull) >> 8) | (((__bsx) & 0x00000000ff000000ull) << 8) | (((__bsx) & 0x0000000000ff0000ull) << 24) | (((__bsx) & 0x000000000000ff00ull) << 40) | (((__bsx) & 0x00000000000000ffull) << 56));

}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 227 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ ));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ ));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ ));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ ));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ ));







extern double drand48 (void) __attribute__ ((__nothrow__ ));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ ));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ ));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ ));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__))
                                         ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__)) ;







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__))
                                      ;



extern void free (void *__ptr) __attribute__ ((__nothrow__ ));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ ));
# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__))
                                         ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;



extern void abort (void) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 647 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ ));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ )) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 820 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 840 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ ));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ ));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ ));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 1003 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1014 "/usr/include/stdlib.h" 2 3 4
# 34 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ ));
extern int isalpha (int) __attribute__ ((__nothrow__ ));
extern int iscntrl (int) __attribute__ ((__nothrow__ ));
extern int isdigit (int) __attribute__ ((__nothrow__ ));
extern int islower (int) __attribute__ ((__nothrow__ ));
extern int isgraph (int) __attribute__ ((__nothrow__ ));
extern int isprint (int) __attribute__ ((__nothrow__ ));
extern int ispunct (int) __attribute__ ((__nothrow__ ));
extern int isspace (int) __attribute__ ((__nothrow__ ));
extern int isupper (int) __attribute__ ((__nothrow__ ));
extern int isxdigit (int) __attribute__ ((__nothrow__ ));



extern int tolower (int __c) __attribute__ ((__nothrow__ ));


extern int toupper (int __c) __attribute__ ((__nothrow__ ));




extern int isblank (int) __attribute__ ((__nothrow__ ));
# 142 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ ));



extern int toascii (int __c) __attribute__ ((__nothrow__ ));



extern int _toupper (int) __attribute__ ((__nothrow__ ));
extern int _tolower (int) __attribute__ ((__nothrow__ ));
# 237 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 238 "/usr/include/ctype.h" 2 3 4
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ ));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ ));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
# 35 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h" 1
# 23 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h"
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jconfig.h" 1
# 24 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h" 2
# 38 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h"
# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 1 3
# 35 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 3
typedef long int ptrdiff_t;
# 102 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 3
# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/__stddef_max_align_t.h" 1 3
# 19 "/usr/lib/llvm-13/lib/clang/13.0.1/include/__stddef_max_align_t.h" 3
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 103 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 2 3
# 39 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h" 2
# 71 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h"
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 122 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 385 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ ));
# 410 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 428 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ ));




# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4
# 34 "/usr/include/strings.h" 3 4
extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));
# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ ));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 72 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h" 2
# 36 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2

# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h" 1
# 31 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h" 1
# 51 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h"
typedef unsigned char JSAMPLE;
# 91 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h"
typedef short JCOEF;
# 102 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h"
typedef unsigned char JOCTET;
# 127 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h"
typedef unsigned char UINT8;
# 139 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h"
typedef unsigned short UINT16;







typedef short INT16;
# 179 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h"
typedef long INT32;
# 194 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h"
typedef unsigned int JDIMENSION;
# 242 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h"
typedef int boolean;
# 368 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jmorecfg.h"
static const int rgb_red[17] = {
  -1, -1, 0, -1, -1, -1, 0, 0,
  2, 2, 3, 1,
  0, 2, 3, 1,
  -1
};

static const int rgb_green[17] = {
  -1, -1, 1, -1, -1, -1, 1, 1,
  1, 1, 2, 2,
  1, 1, 2, 2,
  -1
};

static const int rgb_blue[17] = {
  -1, -1, 2, -1, -1, -1, 2, 2,
  0, 0, 1, 3,
  2, 0, 1, 3,
  -1
};

static const int rgb_pixelsize[17] = {
  -1, -1, 3, -1, -1, -1, 3, 4,
  3, 4, 4, 4,
  4, 4, 4, 4,
  -1
};
# 32 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h" 2
# 69 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
typedef JSAMPLE *JSAMPROW;
typedef JSAMPROW *JSAMPARRAY;
typedef JSAMPARRAY *JSAMPIMAGE;

typedef JCOEF JBLOCK[64];
typedef JBLOCK *JBLOCKROW;
typedef JBLOCKROW *JBLOCKARRAY;
typedef JBLOCKARRAY *JBLOCKIMAGE;

typedef JCOEF *JCOEFPTR;







typedef struct {




  UINT16 quantval[64];





  boolean sent_table;
} JQUANT_TBL;




typedef struct {

  UINT8 bits[17];

  UINT8 huffval[256];





  boolean sent_table;
} JHUFF_TBL;




typedef struct {



  int component_id;
  int component_index;
  int h_samp_factor;
  int v_samp_factor;
  int quant_tbl_no;




  int dc_tbl_no;
  int ac_tbl_no;
# 142 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  JDIMENSION width_in_blocks;
  JDIMENSION height_in_blocks;
# 154 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  int DCT_scaled_size;







  JDIMENSION downsampled_width;
  JDIMENSION downsampled_height;




  boolean component_needed;



  int MCU_width;
  int MCU_height;
  int MCU_blocks;
  int MCU_sample_width;
  int last_col_width;
  int last_row_height;





  JQUANT_TBL *quant_table;


  void *dct_table;
} jpeg_component_info;




typedef struct {
  int comps_in_scan;
  int component_index[4];
  int Ss, Se;
  int Ah, Al;
} jpeg_scan_info;



typedef struct jpeg_marker_struct *jpeg_saved_marker_ptr;

struct jpeg_marker_struct {
  jpeg_saved_marker_ptr next;
  UINT8 marker;
  unsigned int original_length;
  unsigned int data_length;
  JOCTET *data;

};






typedef enum {
  JCS_UNKNOWN,
  JCS_GRAYSCALE,
  JCS_RGB,

  JCS_YCbCr,
  JCS_CMYK,
  JCS_YCCK,
  JCS_EXT_RGB,
  JCS_EXT_RGBX,
  JCS_EXT_BGR,
  JCS_EXT_BGRX,
  JCS_EXT_XBGR,
  JCS_EXT_XRGB,






  JCS_EXT_RGBA,
  JCS_EXT_BGRA,
  JCS_EXT_ABGR,
  JCS_EXT_ARGB,
  JCS_RGB565
} J_COLOR_SPACE;



typedef enum {
  JDCT_ISLOW,
  JDCT_IFAST,
  JDCT_FLOAT
} J_DCT_METHOD;
# 261 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
typedef enum {
  JDITHER_NONE,
  JDITHER_ORDERED,
  JDITHER_FS
} J_DITHER_MODE;
# 282 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
struct jpeg_common_struct {
  struct jpeg_error_mgr *err; struct jpeg_memory_mgr *mem; struct jpeg_progress_mgr *progress; void *client_data; boolean is_decompressor; int global_state;




};

typedef struct jpeg_common_struct *j_common_ptr;
typedef struct jpeg_compress_struct *j_compress_ptr;
typedef struct jpeg_decompress_struct *j_decompress_ptr;




struct jpeg_compress_struct {
  struct jpeg_error_mgr *err; struct jpeg_memory_mgr *mem; struct jpeg_progress_mgr *progress; void *client_data; boolean is_decompressor; int global_state;


  struct jpeg_destination_mgr *dest;






  JDIMENSION image_width;
  JDIMENSION image_height;
  int input_components;
  J_COLOR_SPACE in_color_space;

  double input_gamma;
# 336 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  int data_precision;

  int num_components;
  J_COLOR_SPACE jpeg_color_space;

  jpeg_component_info *comp_info;


  JQUANT_TBL *quant_tbl_ptrs[4];







  JHUFF_TBL *dc_huff_tbl_ptrs[4];
  JHUFF_TBL *ac_huff_tbl_ptrs[4];


  UINT8 arith_dc_L[16];
  UINT8 arith_dc_U[16];
  UINT8 arith_ac_K[16];

  int num_scans;
  const jpeg_scan_info *scan_info;





  boolean raw_data_in;
  boolean arith_code;
  boolean optimize_coding;
  boolean CCIR601_sampling;



  int smoothing_factor;
  J_DCT_METHOD dct_method;






  unsigned int restart_interval;
  int restart_in_rows;



  boolean write_JFIF_header;
  UINT8 JFIF_major_version;
  UINT8 JFIF_minor_version;




  UINT8 density_unit;
  UINT16 X_density;
  UINT16 Y_density;
  boolean write_Adobe_marker;






  JDIMENSION next_scanline;
# 413 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  boolean progressive_mode;
  int max_h_samp_factor;
  int max_v_samp_factor;






  JDIMENSION total_iMCU_rows;
# 433 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  int comps_in_scan;
  jpeg_component_info *cur_comp_info[4];


  JDIMENSION MCUs_per_row;
  JDIMENSION MCU_rows_in_scan;

  int blocks_in_MCU;
  int MCU_membership[10];



  int Ss, Se, Ah, Al;
# 456 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  struct jpeg_comp_master *master;
  struct jpeg_c_main_controller *main;
  struct jpeg_c_prep_controller *prep;
  struct jpeg_c_coef_controller *coef;
  struct jpeg_marker_writer *marker;
  struct jpeg_color_converter *cconvert;
  struct jpeg_downsampler *downsample;
  struct jpeg_forward_dct *fdct;
  struct jpeg_entropy_encoder *entropy;
  jpeg_scan_info *script_space;
  int script_space_size;
};




struct jpeg_decompress_struct {
  struct jpeg_error_mgr *err; struct jpeg_memory_mgr *mem; struct jpeg_progress_mgr *progress; void *client_data; boolean is_decompressor; int global_state;


  struct jpeg_source_mgr *src;




  JDIMENSION image_width;
  JDIMENSION image_height;
  int num_components;
  J_COLOR_SPACE jpeg_color_space;






  J_COLOR_SPACE out_color_space;

  unsigned int scale_num, scale_denom;

  double output_gamma;

  boolean buffered_image;
  boolean raw_data_out;

  J_DCT_METHOD dct_method;
  boolean do_fancy_upsampling;
  boolean do_block_smoothing;

  boolean quantize_colors;

  J_DITHER_MODE dither_mode;
  boolean two_pass_quantize;
  int desired_number_of_colors;

  boolean enable_1pass_quant;
  boolean enable_external_quant;
  boolean enable_2pass_quant;







  JDIMENSION output_width;
  JDIMENSION output_height;
  int out_color_components;
  int output_components;



  int rec_outbuf_height;
# 539 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  int actual_number_of_colors;
  JSAMPARRAY colormap;
# 550 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  JDIMENSION output_scanline;




  int input_scan_number;
  JDIMENSION input_iMCU_row;





  int output_scan_number;
  JDIMENSION output_iMCU_row;
# 572 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  int (*coef_bits)[64];
# 583 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  JQUANT_TBL *quant_tbl_ptrs[4];


  JHUFF_TBL *dc_huff_tbl_ptrs[4];
  JHUFF_TBL *ac_huff_tbl_ptrs[4];






  int data_precision;

  jpeg_component_info *comp_info;





  boolean progressive_mode;
  boolean arith_code;

  UINT8 arith_dc_L[16];
  UINT8 arith_dc_U[16];
  UINT8 arith_ac_K[16];

  unsigned int restart_interval;




  boolean saw_JFIF_marker;

  UINT8 JFIF_major_version;
  UINT8 JFIF_minor_version;
  UINT8 density_unit;
  UINT16 X_density;
  UINT16 Y_density;
  boolean saw_Adobe_marker;
  UINT8 Adobe_transform;

  boolean CCIR601_sampling;





  jpeg_saved_marker_ptr marker_list;
# 639 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  int max_h_samp_factor;
  int max_v_samp_factor;





  int min_DCT_scaled_size;


  JDIMENSION total_iMCU_rows;
# 658 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  JSAMPLE *sample_range_limit;






  int comps_in_scan;
  jpeg_component_info *cur_comp_info[4];


  JDIMENSION MCUs_per_row;
  JDIMENSION MCU_rows_in_scan;

  int blocks_in_MCU;
  int MCU_membership[10];



  int Ss, Se, Ah, Al;
# 691 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  int unread_marker;




  struct jpeg_decomp_master *master;
  struct jpeg_d_main_controller *main;
  struct jpeg_d_coef_controller *coef;
  struct jpeg_d_post_controller *post;
  struct jpeg_input_controller *inputctl;
  struct jpeg_marker_reader *marker;
  struct jpeg_entropy_decoder *entropy;
  struct jpeg_inverse_dct *idct;
  struct jpeg_upsampler *upsample;
  struct jpeg_color_deconverter *cconvert;
  struct jpeg_color_quantizer *cquantize;
};
# 720 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
struct jpeg_error_mgr {

  void (*error_exit) (j_common_ptr cinfo);

  void (*emit_message) (j_common_ptr cinfo, int msg_level);

  void (*output_message) (j_common_ptr cinfo);

  void (*format_message) (j_common_ptr cinfo, char *buffer);


  void (*reset_error_mgr) (j_common_ptr cinfo);




  int msg_code;

  union {
    int i[8];
    char s[80];
  } msg_parm;



  int trace_level;







  long num_warnings;
# 765 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
  const char * const *jpeg_message_table;
  int last_jpeg_message;



  const char * const *addon_message_table;
  int first_addon_message;
  int last_addon_message;
};




struct jpeg_progress_mgr {
  void (*progress_monitor) (j_common_ptr cinfo);

  long pass_counter;
  long pass_limit;
  int completed_passes;
  int total_passes;
};




struct jpeg_destination_mgr {
  JOCTET *next_output_byte;
  size_t free_in_buffer;

  void (*init_destination) (j_compress_ptr cinfo);
  boolean (*empty_output_buffer) (j_compress_ptr cinfo);
  void (*term_destination) (j_compress_ptr cinfo);
};




struct jpeg_source_mgr {
  const JOCTET *next_input_byte;
  size_t bytes_in_buffer;

  void (*init_source) (j_decompress_ptr cinfo);
  boolean (*fill_input_buffer) (j_decompress_ptr cinfo);
  void (*skip_input_data) (j_decompress_ptr cinfo, long num_bytes);
  boolean (*resync_to_restart) (j_decompress_ptr cinfo, int desired);
  void (*term_source) (j_decompress_ptr cinfo);
};
# 829 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
typedef struct jvirt_sarray_control *jvirt_sarray_ptr;
typedef struct jvirt_barray_control *jvirt_barray_ptr;


struct jpeg_memory_mgr {

  void *(*alloc_small) (j_common_ptr cinfo, int pool_id, size_t sizeofobject);
  void *(*alloc_large) (j_common_ptr cinfo, int pool_id,
                        size_t sizeofobject);
  JSAMPARRAY (*alloc_sarray) (j_common_ptr cinfo, int pool_id,
                              JDIMENSION samplesperrow, JDIMENSION numrows);
  JBLOCKARRAY (*alloc_barray) (j_common_ptr cinfo, int pool_id,
                               JDIMENSION blocksperrow, JDIMENSION numrows);
  jvirt_sarray_ptr (*request_virt_sarray) (j_common_ptr cinfo, int pool_id,
                                           boolean pre_zero,
                                           JDIMENSION samplesperrow,
                                           JDIMENSION numrows,
                                           JDIMENSION maxaccess);
  jvirt_barray_ptr (*request_virt_barray) (j_common_ptr cinfo, int pool_id,
                                           boolean pre_zero,
                                           JDIMENSION blocksperrow,
                                           JDIMENSION numrows,
                                           JDIMENSION maxaccess);
  void (*realize_virt_arrays) (j_common_ptr cinfo);
  JSAMPARRAY (*access_virt_sarray) (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
                                    JDIMENSION start_row, JDIMENSION num_rows,
                                    boolean writable);
  JBLOCKARRAY (*access_virt_barray) (j_common_ptr cinfo, jvirt_barray_ptr ptr,
                                     JDIMENSION start_row, JDIMENSION num_rows,
                                     boolean writable);
  void (*free_pool) (j_common_ptr cinfo, int pool_id);
  void (*self_destruct) (j_common_ptr cinfo);






  long max_memory_to_use;


  long max_alloc_chunk;
};





typedef boolean (*jpeg_marker_parser_method) (j_decompress_ptr cinfo);
# 891 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *err);
# 906 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
extern void jpeg_CreateCompress(j_compress_ptr cinfo, int version,
                                 size_t structsize);
extern void jpeg_CreateDecompress(j_decompress_ptr cinfo, int version,
                                   size_t structsize);

extern void jpeg_destroy_compress(j_compress_ptr cinfo);
extern void jpeg_destroy_decompress(j_decompress_ptr cinfo);



extern void jpeg_stdio_dest(j_compress_ptr cinfo, FILE *outfile);
extern void jpeg_stdio_src(j_decompress_ptr cinfo, FILE *infile);



extern void jpeg_mem_dest(j_compress_ptr cinfo, unsigned char **outbuffer,
                           unsigned long *outsize);
extern void jpeg_mem_src(j_decompress_ptr cinfo,
                          const unsigned char *inbuffer, unsigned long insize);



extern void jpeg_set_defaults(j_compress_ptr cinfo);

extern void jpeg_set_colorspace(j_compress_ptr cinfo,
                                 J_COLOR_SPACE colorspace);
extern void jpeg_default_colorspace(j_compress_ptr cinfo);
extern void jpeg_set_quality(j_compress_ptr cinfo, int quality,
                              boolean force_baseline);
extern void jpeg_set_linear_quality(j_compress_ptr cinfo, int scale_factor,
                                     boolean force_baseline);




extern void jpeg_add_quant_table(j_compress_ptr cinfo, int which_tbl,
                                  const unsigned int *basic_table,
                                  int scale_factor, boolean force_baseline);
extern int jpeg_quality_scaling(int quality);
extern void jpeg_simple_progression(j_compress_ptr cinfo);
extern void jpeg_suppress_tables(j_compress_ptr cinfo, boolean suppress);
extern JQUANT_TBL * jpeg_alloc_quant_table(j_common_ptr cinfo);
extern JHUFF_TBL * jpeg_alloc_huff_table(j_common_ptr cinfo);


extern void jpeg_start_compress(j_compress_ptr cinfo,
                                 boolean write_all_tables);
extern JDIMENSION jpeg_write_scanlines(j_compress_ptr cinfo,
                                        JSAMPARRAY scanlines,
                                        JDIMENSION num_lines);
extern void jpeg_finish_compress(j_compress_ptr cinfo);







extern JDIMENSION jpeg_write_raw_data(j_compress_ptr cinfo, JSAMPIMAGE data,
                                       JDIMENSION num_lines);


extern void jpeg_write_marker(j_compress_ptr cinfo, int marker,
                               const JOCTET *dataptr, unsigned int datalen);

extern void jpeg_write_m_header(j_compress_ptr cinfo, int marker,
                                 unsigned int datalen);
extern void jpeg_write_m_byte(j_compress_ptr cinfo, int val);


extern void jpeg_write_tables(j_compress_ptr cinfo);


extern void jpeg_write_icc_profile(j_compress_ptr cinfo,
                                    const JOCTET *icc_data_ptr,
                                    unsigned int icc_data_len);



extern int jpeg_read_header(j_decompress_ptr cinfo, boolean require_image);
# 997 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
extern boolean jpeg_start_decompress(j_decompress_ptr cinfo);
extern JDIMENSION jpeg_read_scanlines(j_decompress_ptr cinfo,
                                       JSAMPARRAY scanlines,
                                       JDIMENSION max_lines);
extern JDIMENSION jpeg_skip_scanlines(j_decompress_ptr cinfo,
                                       JDIMENSION num_lines);
extern void jpeg_crop_scanline(j_decompress_ptr cinfo, JDIMENSION *xoffset,
                                JDIMENSION *width);
extern boolean jpeg_finish_decompress(j_decompress_ptr cinfo);


extern JDIMENSION jpeg_read_raw_data(j_decompress_ptr cinfo, JSAMPIMAGE data,
                                      JDIMENSION max_lines);


extern boolean jpeg_has_multiple_scans(j_decompress_ptr cinfo);
extern boolean jpeg_start_output(j_decompress_ptr cinfo, int scan_number);
extern boolean jpeg_finish_output(j_decompress_ptr cinfo);
extern boolean jpeg_input_complete(j_decompress_ptr cinfo);
extern void jpeg_new_colormap(j_decompress_ptr cinfo);
extern int jpeg_consume_input(j_decompress_ptr cinfo);
# 1029 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
extern void jpeg_calc_output_dimensions(j_decompress_ptr cinfo);


extern void jpeg_save_markers(j_decompress_ptr cinfo, int marker_code,
                               unsigned int length_limit);


extern void jpeg_set_marker_processor(j_decompress_ptr cinfo,
                                       int marker_code,
                                       jpeg_marker_parser_method routine);


extern jvirt_barray_ptr * jpeg_read_coefficients(j_decompress_ptr cinfo);
extern void jpeg_write_coefficients(j_compress_ptr cinfo,
                                     jvirt_barray_ptr *coef_arrays);
extern void jpeg_copy_critical_parameters(j_decompress_ptr srcinfo,
                                           j_compress_ptr dstinfo);







extern void jpeg_abort_compress(j_compress_ptr cinfo);
extern void jpeg_abort_decompress(j_decompress_ptr cinfo);




extern void jpeg_abort(j_common_ptr cinfo);
extern void jpeg_destroy(j_common_ptr cinfo);


extern boolean jpeg_resync_to_restart(j_decompress_ptr cinfo, int desired);


extern boolean jpeg_read_icc_profile(j_decompress_ptr cinfo,
                                      JOCTET **icc_data_ptr,
                                      unsigned int *icc_data_len);
# 1122 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h"
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpegint.h" 1
# 21 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpegint.h"
typedef enum {
  JBUF_PASS_THRU,

  JBUF_SAVE_SOURCE,
  JBUF_CRANK_DEST,
  JBUF_SAVE_AND_PASS
} J_BUF_MODE;
# 48 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpegint.h"
typedef long JLONG;
# 62 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpegint.h"
struct jpeg_comp_master {
  void (*prepare_for_pass) (j_compress_ptr cinfo);
  void (*pass_startup) (j_compress_ptr cinfo);
  void (*finish_pass) (j_compress_ptr cinfo);


  boolean call_pass_startup;
  boolean is_last_pass;
};


struct jpeg_c_main_controller {
  void (*start_pass) (j_compress_ptr cinfo, J_BUF_MODE pass_mode);
  void (*process_data) (j_compress_ptr cinfo, JSAMPARRAY input_buf,
                        JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail);
};


struct jpeg_c_prep_controller {
  void (*start_pass) (j_compress_ptr cinfo, J_BUF_MODE pass_mode);
  void (*pre_process_data) (j_compress_ptr cinfo, JSAMPARRAY input_buf,
                            JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail,
                            JSAMPIMAGE output_buf,
                            JDIMENSION *out_row_group_ctr,
                            JDIMENSION out_row_groups_avail);
};


struct jpeg_c_coef_controller {
  void (*start_pass) (j_compress_ptr cinfo, J_BUF_MODE pass_mode);
  boolean (*compress_data) (j_compress_ptr cinfo, JSAMPIMAGE input_buf);
};


struct jpeg_color_converter {
  void (*start_pass) (j_compress_ptr cinfo);
  void (*color_convert) (j_compress_ptr cinfo, JSAMPARRAY input_buf,
                         JSAMPIMAGE output_buf, JDIMENSION output_row,
                         int num_rows);
};


struct jpeg_downsampler {
  void (*start_pass) (j_compress_ptr cinfo);
  void (*downsample) (j_compress_ptr cinfo, JSAMPIMAGE input_buf,
                      JDIMENSION in_row_index, JSAMPIMAGE output_buf,
                      JDIMENSION out_row_group_index);

  boolean need_context_rows;
};


struct jpeg_forward_dct {
  void (*start_pass) (j_compress_ptr cinfo);

  void (*forward_DCT) (j_compress_ptr cinfo, jpeg_component_info *compptr,
                       JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
                       JDIMENSION start_row, JDIMENSION start_col,
                       JDIMENSION num_blocks);
};


struct jpeg_entropy_encoder {
  void (*start_pass) (j_compress_ptr cinfo, boolean gather_statistics);
  boolean (*encode_mcu) (j_compress_ptr cinfo, JBLOCKROW *MCU_data);
  void (*finish_pass) (j_compress_ptr cinfo);
};


struct jpeg_marker_writer {
  void (*write_file_header) (j_compress_ptr cinfo);
  void (*write_frame_header) (j_compress_ptr cinfo);
  void (*write_scan_header) (j_compress_ptr cinfo);
  void (*write_file_trailer) (j_compress_ptr cinfo);
  void (*write_tables_only) (j_compress_ptr cinfo);


  void (*write_marker_header) (j_compress_ptr cinfo, int marker,
                               unsigned int datalen);
  void (*write_marker_byte) (j_compress_ptr cinfo, int val);
};





struct jpeg_decomp_master {
  void (*prepare_for_output_pass) (j_decompress_ptr cinfo);
  void (*finish_output_pass) (j_decompress_ptr cinfo);


  boolean is_dummy_pass;


  JDIMENSION first_iMCU_col;
  JDIMENSION last_iMCU_col;
  JDIMENSION first_MCU_col[10];
  JDIMENSION last_MCU_col[10];
  boolean jinit_upsampler_no_alloc;
};


struct jpeg_input_controller {
  int (*consume_input) (j_decompress_ptr cinfo);
  void (*reset_input_controller) (j_decompress_ptr cinfo);
  void (*start_input_pass) (j_decompress_ptr cinfo);
  void (*finish_input_pass) (j_decompress_ptr cinfo);


  boolean has_multiple_scans;
  boolean eoi_reached;
};


struct jpeg_d_main_controller {
  void (*start_pass) (j_decompress_ptr cinfo, J_BUF_MODE pass_mode);
  void (*process_data) (j_decompress_ptr cinfo, JSAMPARRAY output_buf,
                        JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);
};


struct jpeg_d_coef_controller {
  void (*start_input_pass) (j_decompress_ptr cinfo);
  int (*consume_data) (j_decompress_ptr cinfo);
  void (*start_output_pass) (j_decompress_ptr cinfo);
  int (*decompress_data) (j_decompress_ptr cinfo, JSAMPIMAGE output_buf);

  jvirt_barray_ptr *coef_arrays;
};


struct jpeg_d_post_controller {
  void (*start_pass) (j_decompress_ptr cinfo, J_BUF_MODE pass_mode);
  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                             JDIMENSION *in_row_group_ctr,
                             JDIMENSION in_row_groups_avail,
                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
                             JDIMENSION out_rows_avail);
};


struct jpeg_marker_reader {
  void (*reset_marker_reader) (j_decompress_ptr cinfo);




  int (*read_markers) (j_decompress_ptr cinfo);

  jpeg_marker_parser_method read_restart_marker;




  boolean saw_SOI;
  boolean saw_SOF;
  int next_restart_num;
  unsigned int discarded_bytes;
};


struct jpeg_entropy_decoder {
  void (*start_pass) (j_decompress_ptr cinfo);
  boolean (*decode_mcu) (j_decompress_ptr cinfo, JBLOCKROW *MCU_data);



  boolean insufficient_data;
};


typedef void (*inverse_DCT_method_ptr) (j_decompress_ptr cinfo,
                                        jpeg_component_info *compptr,
                                        JCOEFPTR coef_block,
                                        JSAMPARRAY output_buf,
                                        JDIMENSION output_col);

struct jpeg_inverse_dct {
  void (*start_pass) (j_decompress_ptr cinfo);

  inverse_DCT_method_ptr inverse_DCT[10];
};


struct jpeg_upsampler {
  void (*start_pass) (j_decompress_ptr cinfo);
  void (*upsample) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                    JDIMENSION *in_row_group_ctr,
                    JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,
                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail);

  boolean need_context_rows;
};


struct jpeg_color_deconverter {
  void (*start_pass) (j_decompress_ptr cinfo);
  void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,
                         JDIMENSION input_row, JSAMPARRAY output_buf,
                         int num_rows);
};


struct jpeg_color_quantizer {
  void (*start_pass) (j_decompress_ptr cinfo, boolean is_pre_scan);
  void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                          JSAMPARRAY output_buf, int num_rows);
  void (*finish_pass) (j_decompress_ptr cinfo);
  void (*new_color_map) (j_decompress_ptr cinfo);
};
# 305 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpegint.h"
extern void jinit_compress_master(j_compress_ptr cinfo);
extern void jinit_c_master_control(j_compress_ptr cinfo,
                                    boolean transcode_only);
extern void jinit_c_main_controller(j_compress_ptr cinfo,
                                     boolean need_full_buffer);
extern void jinit_c_prep_controller(j_compress_ptr cinfo,
                                     boolean need_full_buffer);
extern void jinit_c_coef_controller(j_compress_ptr cinfo,
                                     boolean need_full_buffer);
extern void jinit_color_converter(j_compress_ptr cinfo);
extern void jinit_downsampler(j_compress_ptr cinfo);
extern void jinit_forward_dct(j_compress_ptr cinfo);
extern void jinit_huff_encoder(j_compress_ptr cinfo);
extern void jinit_phuff_encoder(j_compress_ptr cinfo);
extern void jinit_arith_encoder(j_compress_ptr cinfo);
extern void jinit_marker_writer(j_compress_ptr cinfo);

extern void jinit_master_decompress(j_decompress_ptr cinfo);
extern void jinit_d_main_controller(j_decompress_ptr cinfo,
                                     boolean need_full_buffer);
extern void jinit_d_coef_controller(j_decompress_ptr cinfo,
                                     boolean need_full_buffer);
extern void jinit_d_post_controller(j_decompress_ptr cinfo,
                                     boolean need_full_buffer);
extern void jinit_input_controller(j_decompress_ptr cinfo);
extern void jinit_marker_reader(j_decompress_ptr cinfo);
extern void jinit_huff_decoder(j_decompress_ptr cinfo);
extern void jinit_phuff_decoder(j_decompress_ptr cinfo);
extern void jinit_arith_decoder(j_decompress_ptr cinfo);
extern void jinit_inverse_dct(j_decompress_ptr cinfo);
extern void jinit_upsampler(j_decompress_ptr cinfo);
extern void jinit_color_deconverter(j_decompress_ptr cinfo);
extern void jinit_1pass_quantizer(j_decompress_ptr cinfo);
extern void jinit_2pass_quantizer(j_decompress_ptr cinfo);
extern void jinit_merged_upsampler(j_decompress_ptr cinfo);

extern void jinit_memory_mgr(j_common_ptr cinfo);


extern long jdiv_round_up(long a, long b);
extern long jround_up(long a, long b);
extern void jcopy_sample_rows(JSAMPARRAY input_array, int source_row,
                               JSAMPARRAY output_array, int dest_row,
                               int num_rows, JDIMENSION num_cols);
extern void jcopy_block_row(JBLOCKROW input_row, JBLOCKROW output_row,
                             JDIMENSION num_blocks);
extern void jzero_far(void *target, size_t bytestozero);




extern const int jpeg_natural_order[];


extern const JLONG jpeg_aritab[];
# 1123 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jerror.h" 1
# 37 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jerror.h"
typedef enum {





JMSG_NOMESSAGE,



JERR_ARITH_NOTIMPL,

JERR_BAD_ALIGN_TYPE,
JERR_BAD_ALLOC_CHUNK,
JERR_BAD_BUFFER_MODE,
JERR_BAD_COMPONENT_ID,



JERR_BAD_DCT_COEF,
JERR_BAD_DCTSIZE,




JERR_BAD_HUFF_TABLE,
JERR_BAD_IN_COLORSPACE,
JERR_BAD_J_COLORSPACE,
JERR_BAD_LENGTH,
JERR_BAD_LIB_VERSION,

JERR_BAD_MCU_SIZE,
JERR_BAD_POOL_ID,
JERR_BAD_PRECISION,
JERR_BAD_PROGRESSION,

JERR_BAD_PROG_SCRIPT,

JERR_BAD_SAMPLING,
JERR_BAD_SCAN_SCRIPT,
JERR_BAD_STATE,
JERR_BAD_STRUCT_SIZE,

JERR_BAD_VIRTUAL_ACCESS,
JERR_BUFFER_SIZE,
JERR_CANT_SUSPEND,
JERR_CCIR601_NOTIMPL,
JERR_COMPONENT_COUNT,
JERR_CONVERSION_NOTIMPL,
JERR_DAC_INDEX,
JERR_DAC_VALUE,
JERR_DHT_INDEX,
JERR_DQT_INDEX,
JERR_EMPTY_IMAGE,
JERR_EMS_READ,
JERR_EMS_WRITE,
JERR_EOI_EXPECTED,
JERR_FILE_READ,
JERR_FILE_WRITE,
JERR_FRACT_SAMPLE_NOTIMPL,
JERR_HUFF_CLEN_OVERFLOW,
JERR_HUFF_MISSING_CODE,
JERR_IMAGE_TOO_BIG,
JERR_INPUT_EMPTY,
JERR_INPUT_EOF,
JERR_MISMATCHED_QUANT_TABLE,

JERR_MISSING_DATA,
JERR_MODE_CHANGE,
JERR_NOTIMPL,
JERR_NOT_COMPILED,



JERR_NO_BACKING_STORE,
JERR_NO_HUFF_TABLE,
JERR_NO_IMAGE,
JERR_NO_QUANT_TABLE,
JERR_NO_SOI,
JERR_OUT_OF_MEMORY,
JERR_QUANT_COMPONENTS,

JERR_QUANT_FEW_COLORS,
JERR_QUANT_MANY_COLORS,
JERR_SOF_DUPLICATE,
JERR_SOF_NO_SOS,
JERR_SOF_UNSUPPORTED,
JERR_SOI_DUPLICATE,
JERR_SOS_NO_SOF,
JERR_TFILE_CREATE,
JERR_TFILE_READ,
JERR_TFILE_SEEK,
JERR_TFILE_WRITE,

JERR_TOO_LITTLE_DATA,
JERR_UNKNOWN_MARKER,
JERR_VIRTUAL_BUG,
JERR_WIDTH_OVERFLOW,
JERR_XMS_READ,
JERR_XMS_WRITE,
JMSG_COPYRIGHT,
JMSG_VERSION,
JTRC_16BIT_TABLES,

JTRC_ADOBE,

JTRC_APP0,
JTRC_APP14,
JTRC_DAC,
JTRC_DHT,
JTRC_DQT,
JTRC_DRI,
JTRC_EMS_CLOSE,
JTRC_EMS_OPEN,
JTRC_EOI,
JTRC_HUFFBITS,
JTRC_JFIF,
JTRC_JFIF_BADTHUMBNAILSIZE,

JTRC_JFIF_EXTENSION,
JTRC_JFIF_THUMBNAIL,
JTRC_MISC_MARKER,
JTRC_PARMLESS_MARKER,
JTRC_QUANTVALS,
JTRC_QUANT_3_NCOLORS,
JTRC_QUANT_NCOLORS,
JTRC_QUANT_SELECTED,
JTRC_RECOVERY_ACTION,
JTRC_RST,
JTRC_SMOOTH_NOTIMPL,

JTRC_SOF,
JTRC_SOF_COMPONENT,
JTRC_SOI,
JTRC_SOS,
JTRC_SOS_COMPONENT,
JTRC_SOS_PARAMS,
JTRC_TFILE_CLOSE,
JTRC_TFILE_OPEN,
JTRC_THUMB_JPEG,

JTRC_THUMB_PALETTE,

JTRC_THUMB_RGB,

JTRC_UNKNOWN_IDS,

JTRC_XMS_CLOSE,
JTRC_XMS_OPEN,
JWRN_ADOBE_XFORM,



JWRN_BOGUS_PROGRESSION,

JWRN_EXTRANEOUS_DATA,

JWRN_HIT_MARKER,
JWRN_HUFF_BAD_CODE,
JWRN_JFIF_MAJOR,
JWRN_JPEG_EOF,
JWRN_MUST_RESYNC,

JWRN_NOT_SEQUENTIAL,
JWRN_TOO_MUCH_DATA,

JERR_BAD_CROP_SPEC,

JERR_NO_ARITH_TABLE,
JWRN_ARITH_BAD_CODE,


JWRN_BOGUS_ICC,



  JMSG_LASTMSGCODE
} J_MESSAGE_CODE;
# 1124 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jpeglib.h" 2
# 38 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jerror.h" 1
# 39 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/usr/include/setjmp.h" 1 3 4
# 29 "/usr/include/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };


typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));




extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
# 67 "/usr/include/setjmp.h" 3 4
extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));





extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 93 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 40 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 41 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h" 1
# 92 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
enum TJSAMP {





  TJSAMP_444 = 0,




  TJSAMP_422,




  TJSAMP_420,



  TJSAMP_GRAY,






  TJSAMP_440,
# 131 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
  TJSAMP_411
};
# 143 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
static const int tjMCUWidth[6] = { 8, 16, 16, 8, 8, 32 };
# 154 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
static const int tjMCUHeight[6] = { 8, 8, 16, 8, 16, 8 };
# 165 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
enum TJPF {





  TJPF_RGB = 0,





  TJPF_BGR,






  TJPF_RGBX,






  TJPF_BGRX,






  TJPF_XBGR,






  TJPF_XRGB,




  TJPF_GRAY,





  TJPF_RGBA,





  TJPF_BGRA,





  TJPF_ABGR,





  TJPF_ARGB,
# 250 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
  TJPF_CMYK,



  TJPF_UNKNOWN = -1
};
# 264 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
static const int tjRedOffset[12] = {
  0, 2, 0, 2, 3, 1, -1, 0, 2, 3, 1, -1
};
# 275 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
static const int tjGreenOffset[12] = {
  1, 1, 1, 1, 2, 2, -1, 1, 1, 2, 2, -1
};







static const int tjBlueOffset[12] = {
  2, 0, 2, 0, 1, 3, -1, 2, 0, 1, 3, -1
};
# 296 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
static const int tjAlphaOffset[12] = {
  -1, -1, -1, -1, -1, -1, -1, 3, 3, 0, 0, -1
};



static const int tjPixelSize[12] = {
  3, 3, 4, 4, 4, 4, 1, 4, 4, 4, 4, 4
};
# 315 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
enum TJCS {







  TJCS_RGB = 0,
# 339 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
  TJCS_YCbCr,







  TJCS_GRAY,






  TJCS_CMYK,
# 364 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
  TJCS_YCCK
};
# 431 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
enum TJERR {




  TJERR_WARNING = 0,



  TJERR_FATAL
};
# 452 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
enum TJXOP {



  TJXOP_NONE = 0,




  TJXOP_HFLIP,




  TJXOP_VFLIP,




  TJXOP_TRANSPOSE,





  TJXOP_TRANSVERSE,





  TJXOP_ROT90,




  TJXOP_ROT180,





  TJXOP_ROT270
};
# 552 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
typedef struct {



  int num;



  int denom;
} tjscalingfactor;




typedef struct {




  int x;




  int y;




  int w;




  int h;
} tjregion;




typedef struct tjtransform {



  tjregion r;



  int op;



  int options;




  void *data;
# 643 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
  int (*customFilter) (short *coeffs, tjregion arrayRegion,
                       tjregion planeRegion, int componentIndex,
                       int transformIndex, struct tjtransform *transform);
} tjtransform;




typedef void *tjhandle;
# 680 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          tjhandle tjInitCompress(void);
# 743 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjCompress2(tjhandle handle, const unsigned char *srcBuf,
                          int width, int pitch, int height, int pixelFormat,
                          unsigned char **jpegBuf, unsigned long *jpegSize,
                          int jpegSubsamp, int jpegQual, int flags);
# 809 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,
                                int width, int pad, int height, int subsamp,
                                unsigned char **jpegBuf,
                                unsigned long *jpegSize, int jpegQual,
                                int flags);
# 882 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjCompressFromYUVPlanes(tjhandle handle,
                                      const unsigned char **srcPlanes,
                                      int width, const int *strides,
                                      int height, int subsamp,
                                      unsigned char **jpegBuf,
                                      unsigned long *jpegSize, int jpegQual,
                                      int flags);
# 913 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          unsigned long tjBufSize(int width, int height, int jpegSubsamp);
# 933 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          unsigned long tjBufSizeYUV2(int width, int pad, int height,
                                      int subsamp);
# 958 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          unsigned long tjPlaneSizeYUV(int componentID, int width, int stride,
                                       int height, int subsamp);
# 976 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjPlaneWidth(int componentID, int width, int subsamp);
# 993 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjPlaneHeight(int componentID, int height, int subsamp);
# 1045 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,
                           int width, int pitch, int height, int pixelFormat,
                           unsigned char *dstBuf, int pad, int subsamp,
                           int flags);
# 1105 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjEncodeYUVPlanes(tjhandle handle, const unsigned char *srcBuf,
                                int width, int pitch, int height,
                                int pixelFormat, unsigned char **dstPlanes,
                                int *strides, int subsamp, int flags);
# 1117 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          tjhandle tjInitDecompress(void);
# 1146 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjDecompressHeader3(tjhandle handle,
                                  const unsigned char *jpegBuf,
                                  unsigned long jpegSize, int *width,
                                  int *height, int *jpegSubsamp,
                                  int *jpegColorspace);
# 1163 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          tjscalingfactor *tjGetScalingFactors(int *numscalingfactors);
# 1216 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjDecompress2(tjhandle handle, const unsigned char *jpegBuf,
                            unsigned long jpegSize, unsigned char *dstBuf,
                            int width, int pitch, int height, int pixelFormat,
                            int flags);
# 1268 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,
                                 unsigned long jpegSize, unsigned char *dstBuf,
                                 int width, int pad, int height, int flags);
# 1325 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjDecompressToYUVPlanes(tjhandle handle,
                                      const unsigned char *jpegBuf,
                                      unsigned long jpegSize,
                                      unsigned char **dstPlanes, int width,
                                      int *strides, int height, int flags);
# 1380 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
                          int pad, int subsamp, unsigned char *dstBuf,
                          int width, int pitch, int height, int pixelFormat,
                          int flags);
# 1439 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjDecodeYUVPlanes(tjhandle handle,
                                const unsigned char **srcPlanes,
                                const int *strides, int subsamp,
                                unsigned char *dstBuf, int width, int pitch,
                                int height, int pixelFormat, int flags);
# 1452 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          tjhandle tjInitTransform(void);
# 1515 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjTransform(tjhandle handle, const unsigned char *jpegBuf,
                          unsigned long jpegSize, int n,
                          unsigned char **dstBufs, unsigned long *dstSizes,
                          tjtransform *transforms, int flags);
# 1529 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjDestroy(tjhandle handle);
# 1545 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          unsigned char *tjAlloc(int bytes);
# 1591 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          unsigned char *tjLoadImage(const char *filename, int *width,
                                     int align, int *height, int *pixelFormat,
                                     int flags);
# 1628 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjSaveImage(const char *filename, unsigned char *buffer,
                          int width, int pitch, int height, int pixelFormat,
                          int flags);
# 1643 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          void tjFree(unsigned char *buffer);
# 1656 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          char *tjGetErrorStr2(tjhandle handle);
# 1669 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          int tjGetErrorCode(tjhandle handle);
# 1697 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./turbojpeg.h"
          unsigned long TJBUFSIZE(int width, int height);

          unsigned long TJBUFSIZEYUV(int width, int height, int jpegSubsamp);

          unsigned long tjBufSizeYUV(int width, int height, int subsamp);

          int tjCompress(tjhandle handle, unsigned char *srcBuf, int width,
                         int pitch, int height, int pixelSize,
                         unsigned char *dstBuf, unsigned long *compressedSize,
                         int jpegSubsamp, int jpegQual, int flags);

          int tjEncodeYUV(tjhandle handle, unsigned char *srcBuf, int width,
                          int pitch, int height, int pixelSize,
                          unsigned char *dstBuf, int subsamp, int flags);

          int tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf, int width,
                           int pitch, int height, int pixelFormat,
                           unsigned char *dstBuf, int subsamp, int flags);

          int tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,
                                 unsigned long jpegSize, int *width,
                                 int *height);

          int tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,
                                  unsigned long jpegSize, int *width,
                                  int *height, int *jpegSubsamp);

          int tjDecompress(tjhandle handle, unsigned char *jpegBuf,
                           unsigned long jpegSize, unsigned char *dstBuf,
                           int width, int pitch, int height, int pixelSize,
                           int flags);

          int tjDecompressToYUV(tjhandle handle, unsigned char *jpegBuf,
                                unsigned long jpegSize, unsigned char *dstBuf,
                                int flags);

          char *tjGetErrorStr(void);
# 42 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./tjutil.h" 1
# 47 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./tjutil.h"
extern double getTime(void);
# 43 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/transupp.h" 1
# 87 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/transupp.h"
typedef enum {
  JXFORM_NONE,
  JXFORM_FLIP_H,
  JXFORM_FLIP_V,
  JXFORM_TRANSPOSE,
  JXFORM_TRANSVERSE,
  JXFORM_ROT_90,
  JXFORM_ROT_180,
  JXFORM_ROT_270
} JXFORM_CODE;







typedef enum {
  JCROP_UNSET,
  JCROP_POS,
  JCROP_NEG,
  JCROP_FORCE
} JCROP_CODE;







typedef struct {

  JXFORM_CODE transform;
  boolean perfect;
  boolean trim;
  boolean force_grayscale;
  boolean crop;
  boolean slow_hflip;
# 135 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/transupp.h"
  JDIMENSION crop_width;
  JCROP_CODE crop_width_set;
  JDIMENSION crop_height;
  JCROP_CODE crop_height_set;
  JDIMENSION crop_xoffset;
  JCROP_CODE crop_xoffset_set;
  JDIMENSION crop_yoffset;
  JCROP_CODE crop_yoffset_set;


  int num_components;
  jvirt_barray_ptr *workspace_coef_arrays;
  JDIMENSION output_width;
  JDIMENSION output_height;
  JDIMENSION x_crop_offset;
  JDIMENSION y_crop_offset;
  int iMCU_sample_width;
  int iMCU_sample_height;
} jpeg_transform_info;





extern boolean jtransform_parse_crop_spec(jpeg_transform_info *info,
                                           const char *spec);

extern boolean jtransform_request_workspace(j_decompress_ptr srcinfo,
                                             jpeg_transform_info *info);

extern jvirt_barray_ptr * jtransform_adjust_parameters
  (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
   jvirt_barray_ptr *src_coef_arrays, jpeg_transform_info *info);

extern void jtransform_execute_transform(j_decompress_ptr srcinfo,
                                          j_compress_ptr dstinfo,
                                          jvirt_barray_ptr *src_coef_arrays,
                                          jpeg_transform_info *info);



extern boolean jtransform_perfect_transform(JDIMENSION image_width,
                                             JDIMENSION image_height,
                                             int MCU_width, int MCU_height,
                                             JXFORM_CODE transform);
# 195 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/transupp.h"
typedef enum {
  JCOPYOPT_NONE,
  JCOPYOPT_COMMENTS,
  JCOPYOPT_ALL,
  JCOPYOPT_ALL_EXCEPT_ICC
} JCOPY_OPTION;




extern void jcopy_markers_setup(j_decompress_ptr srcinfo,
                                 JCOPY_OPTION option);

extern void jcopy_markers_execute(j_decompress_ptr srcinfo,
                                   j_compress_ptr dstinfo,
                                   JCOPY_OPTION option);
# 44 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./jpegcomp.h" 1
# 45 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./cdjpeg.h" 1
# 17 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./cdjpeg.h"
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h" 1
# 23 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h"
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jconfig.h" 1
# 24 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h" 2
# 38 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h"
# 1 "/usr/lib/llvm-13/lib/clang/13.0.1/include/stddef.h" 1 3
# 39 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jinclude.h" 2
# 18 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./cdjpeg.h" 2

# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/jerror.h" 1
# 20 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./cdjpeg.h" 2
# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/cderror.h" 1
# 35 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/cderror.h"
typedef enum {





JMSG_FIRSTADDONCODE = 1000,


JERR_BMP_BADCMAP,
JERR_BMP_BADDEPTH,
JERR_BMP_BADHEADER,
JERR_BMP_BADPLANES,
JERR_BMP_COLORSPACE,
JERR_BMP_COMPRESSED,
JERR_BMP_EMPTY,
JERR_BMP_NOT,
JERR_BMP_OUTOFRANGE,
JTRC_BMP,
JTRC_BMP_MAPPED,
JTRC_BMP_OS2,
JTRC_BMP_OS2_MAPPED,
# 77 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/cderror.h"
JERR_PPM_COLORSPACE,
JERR_PPM_NONNUMERIC,
JERR_PPM_NOT,
JERR_PPM_OUTOFRANGE,
JTRC_PGM,
JTRC_PGM_TEXT,
JTRC_PPM,
JTRC_PPM_TEXT,
# 112 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/cderror.h"
JERR_TGA_NOTCOMP,


JERR_BAD_CMAP_FILE,

JERR_TOO_MANY_COLORS,

JERR_UNGETC_FAILED,




JERR_UNKNOWN_FORMAT,

JERR_UNSUPPORTED_FORMAT,



  JMSG_LASTADDONCODE
} ADDON_MESSAGE_CODE;
# 21 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./cdjpeg.h" 2






typedef struct cjpeg_source_struct *cjpeg_source_ptr;

struct cjpeg_source_struct {
  void (*start_input) (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);
  JDIMENSION (*get_pixel_rows) (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);
  void (*finish_input) (j_compress_ptr cinfo, cjpeg_source_ptr sinfo);

  FILE *input_file;

  JSAMPARRAY buffer;
  JDIMENSION buffer_height;
};






typedef struct djpeg_dest_struct *djpeg_dest_ptr;

struct djpeg_dest_struct {



  void (*start_output) (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo);

  void (*put_pixel_rows) (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
                          JDIMENSION rows_supplied);

  void (*finish_output) (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo);





  void (*calc_buffer_dimensions) (j_decompress_ptr cinfo,
                                  djpeg_dest_ptr dinfo);



  FILE *output_file;





  JSAMPARRAY buffer;
  JDIMENSION buffer_height;
};
# 86 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/./cdjpeg.h"
struct cdjpeg_progress_mgr {
  struct jpeg_progress_mgr pub;
  int completed_extra_passes;
  int total_extra_passes;

  int percent_done;
};

typedef struct cdjpeg_progress_mgr *cd_progress_ptr;




extern cjpeg_source_ptr jinit_read_bmp(j_compress_ptr cinfo,
                                        boolean use_inversion_array);
extern djpeg_dest_ptr jinit_write_bmp(j_decompress_ptr cinfo, boolean is_os2,
                                       boolean use_inversion_array);
extern cjpeg_source_ptr jinit_read_gif(j_compress_ptr cinfo);
extern djpeg_dest_ptr jinit_write_gif(j_decompress_ptr cinfo);
extern cjpeg_source_ptr jinit_read_ppm(j_compress_ptr cinfo);
extern djpeg_dest_ptr jinit_write_ppm(j_decompress_ptr cinfo);
extern cjpeg_source_ptr jinit_read_rle(j_compress_ptr cinfo);
extern djpeg_dest_ptr jinit_write_rle(j_decompress_ptr cinfo);
extern cjpeg_source_ptr jinit_read_targa(j_compress_ptr cinfo);
extern djpeg_dest_ptr jinit_write_targa(j_decompress_ptr cinfo);



extern boolean read_quant_tables(j_compress_ptr cinfo, char *filename,
                                  boolean force_baseline);
extern boolean read_scan_script(j_compress_ptr cinfo, char *filename);
extern boolean set_quality_ratings(j_compress_ptr cinfo, char *arg,
                                    boolean force_baseline);
extern boolean set_quant_slots(j_compress_ptr cinfo, char *arg);
extern boolean set_sample_factors(j_compress_ptr cinfo, char *arg);



extern void read_color_map(j_decompress_ptr cinfo, FILE *infile);



extern void enable_signal_catcher(j_common_ptr cinfo);
extern void start_progress_monitor(j_common_ptr cinfo,
                                    cd_progress_ptr progress);
extern void end_progress_monitor(j_common_ptr cinfo);
extern boolean keymatch(char *arg, const char *keyword, int minchars);
extern FILE * read_stdin(void);
extern FILE * write_stdout(void);
# 46 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2

extern void jpeg_mem_dest_tj(j_compress_ptr, unsigned char **, unsigned long *,
                             boolean);
extern void jpeg_mem_src_tj(j_decompress_ptr, const unsigned char *,
                            unsigned long);







static char errStr[200] = "No error";

struct my_error_mgr {
  struct jpeg_error_mgr pub;
  jmp_buf setjmp_buffer;
  void (*emit_message) (j_common_ptr, int);
  boolean warning, stopOnWarning;
};
typedef struct my_error_mgr *my_error_ptr;


static const char *turbojpeg_message_table[] = {

# 1 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/cderror.h" 1
# 41 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/cderror.h"
((void*)0),


"Unsupported BMP colormap format",
"Only 8- and 24-bit BMP files are supported",
"Invalid BMP file: bad header length",
"Invalid BMP file: biPlanes not equal to 1",
"BMP output must be grayscale or RGB",
"Sorry, compressed BMPs not yet supported",
"Empty BMP image",
"Not a BMP file - does not start with BM",
"Numeric value out of range in BMP file",
"%ux%u 24-bit BMP image",
"%ux%u 8-bit colormapped BMP image",
"%ux%u 24-bit OS2 BMP image",
"%ux%u 8-bit colormapped OS2 BMP image",
# 77 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/cderror.h"
"PPM output must be grayscale or RGB",
"Nonnumeric data in PPM file",
"Not a PPM/PGM file",
"Numeric value out of range in PPM file",
"%ux%u PGM image",
"%ux%u text PGM image",
"%ux%u PPM image",
"%ux%u text PPM image",
# 112 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/cderror.h"
"Targa support was not compiled",


"Color map file is invalid or of unsupported format",

"Output file format cannot handle %d colormap entries",

"ungetc failed",




"Unrecognized input file format",

"Unsupported output file format",
# 71 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c" 2
 ((void*)0)
};

static void my_error_exit(j_common_ptr cinfo)
{
  my_error_ptr myerr = (my_error_ptr)cinfo->err;

  (*cinfo->err->output_message) (cinfo);
  longjmp(myerr->setjmp_buffer, 1);
}



static void my_output_message(j_common_ptr cinfo)
{
  (*cinfo->err->format_message) (cinfo, errStr);
}

static void my_emit_message(j_common_ptr cinfo, int msg_level)
{
  my_error_ptr myerr = (my_error_ptr)cinfo->err;

  myerr->emit_message(cinfo, msg_level);
  if (msg_level < 0) {
    myerr->warning = 1;
    if (myerr->stopOnWarning) longjmp(myerr->setjmp_buffer, 1);
  }
}




enum { COMPRESS = 1, DECOMPRESS = 2 };

typedef struct _tjinstance {
  struct jpeg_compress_struct cinfo;
  struct jpeg_decompress_struct dinfo;
  struct my_error_mgr jerr;
  int init, headerRead;
  char errStr[200];
  boolean isInstanceError;
} tjinstance;

static const int pixelsize[6] = { 3, 3, 3, 1, 3, 3 };

static const JXFORM_CODE xformtypes[8] = {
  JXFORM_NONE, JXFORM_FLIP_H, JXFORM_FLIP_V, JXFORM_TRANSPOSE,
  JXFORM_TRANSVERSE, JXFORM_ROT_90, JXFORM_ROT_180, JXFORM_ROT_270
};


static const tjscalingfactor sf[16] = {
  { 2, 1 },
  { 15, 8 },
  { 7, 4 },
  { 13, 8 },
  { 3, 2 },
  { 11, 8 },
  { 5, 4 },
  { 9, 8 },
  { 1, 1 },
  { 7, 8 },
  { 3, 4 },
  { 5, 8 },
  { 1, 2 },
  { 3, 8 },
  { 1, 4 },
  { 1, 8 }
};

static J_COLOR_SPACE pf2cs[12] = {
  JCS_EXT_RGB, JCS_EXT_BGR, JCS_EXT_RGBX, JCS_EXT_BGRX, JCS_EXT_XBGR,
  JCS_EXT_XRGB, JCS_GRAYSCALE, JCS_EXT_RGBA, JCS_EXT_BGRA, JCS_EXT_ABGR,
  JCS_EXT_ARGB, JCS_CMYK
};

static int cs2pf[17] = {
  TJPF_UNKNOWN, TJPF_GRAY,

  TJPF_RGB,
# 162 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c"
  TJPF_UNKNOWN, TJPF_CMYK, TJPF_UNKNOWN, TJPF_RGB, TJPF_RGBX, TJPF_BGR,
  TJPF_BGRX, TJPF_XBGR, TJPF_XRGB, TJPF_RGBA, TJPF_BGRA, TJPF_ABGR, TJPF_ARGB,
  TJPF_UNKNOWN
};
# 217 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c"
static int getPixelFormat(int pixelSize, int flags)
{
  if (pixelSize == 1) return TJPF_GRAY;
  if (pixelSize == 3) {
    if (flags & 1) return TJPF_BGR;
    else return TJPF_RGB;
  }
  if (pixelSize == 4) {
    if (flags & 64) {
      if (flags & 1) return TJPF_XBGR;
      else return TJPF_XRGB;
    } else {
      if (flags & 1) return TJPF_BGRX;
      else return TJPF_RGBX;
    }
  }
  return -1;
}

static int setCompDefaults(struct jpeg_compress_struct *cinfo, int pixelFormat,
                           int subsamp, int jpegQual, int flags)
{
  int retval = 0;
  char *env = ((void*)0);

  cinfo->in_color_space = pf2cs[pixelFormat];
  cinfo->input_components = tjPixelSize[pixelFormat];
  jpeg_set_defaults(cinfo);


  if ((env = getenv("TJ_OPTIMIZE")) != ((void*)0) && strlen(env) > 0 &&
      !strcmp(env, "1"))
    cinfo->optimize_coding = 1;
  if ((env = getenv("TJ_ARITHMETIC")) != ((void*)0) && strlen(env) > 0 &&
      !strcmp(env, "1"))
    cinfo->arith_code = 1;
  if ((env = getenv("TJ_RESTART")) != ((void*)0) && strlen(env) > 0) {
    int temp = -1;
    char tempc = 0;

    if (sscanf(env, "%d%c", &temp, &tempc) >= 1 && temp >= 0 &&
        temp <= 65535) {
      if (toupper(tempc) == 'B') {
        cinfo->restart_interval = temp;
        cinfo->restart_in_rows = 0;
      } else
        cinfo->restart_in_rows = temp;
    }
  }


  if (jpegQual >= 0) {
    jpeg_set_quality(cinfo, jpegQual, 1);
    if (jpegQual >= 96 || flags & 4096)
      cinfo->dct_method = JDCT_ISLOW;
    else
      cinfo->dct_method = JDCT_IFAST;
  }
  if (subsamp == TJSAMP_GRAY)
    jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
  else if (pixelFormat == TJPF_CMYK)
    jpeg_set_colorspace(cinfo, JCS_YCCK);
  else
    jpeg_set_colorspace(cinfo, JCS_YCbCr);

  if (flags & 16384)
    jpeg_simple_progression(cinfo);

  else if ((env = getenv("TJ_PROGRESSIVE")) != ((void*)0) && strlen(env) > 0 &&
           !strcmp(env, "1"))
    jpeg_simple_progression(cinfo);


  cinfo->comp_info[0].h_samp_factor = tjMCUWidth[subsamp] / 8;
  cinfo->comp_info[1].h_samp_factor = 1;
  cinfo->comp_info[2].h_samp_factor = 1;
  if (cinfo->num_components > 3)
    cinfo->comp_info[3].h_samp_factor = tjMCUWidth[subsamp] / 8;
  cinfo->comp_info[0].v_samp_factor = tjMCUHeight[subsamp] / 8;
  cinfo->comp_info[1].v_samp_factor = 1;
  cinfo->comp_info[2].v_samp_factor = 1;
  if (cinfo->num_components > 3)
    cinfo->comp_info[3].v_samp_factor = tjMCUHeight[subsamp] / 8;

  return retval;
}


static int getSubsamp(j_decompress_ptr dinfo)
{
  int retval = -1, i, k;





  if (dinfo->num_components == 1 && dinfo->jpeg_color_space == JCS_GRAYSCALE)
    return TJSAMP_GRAY;

  for (i = 0; i < 6; i++) {
    if (dinfo->num_components == pixelsize[i] ||
        ((dinfo->jpeg_color_space == JCS_YCCK ||
          dinfo->jpeg_color_space == JCS_CMYK) &&
         pixelsize[i] == 3 && dinfo->num_components == 4)) {
      if (dinfo->comp_info[0].h_samp_factor == tjMCUWidth[i] / 8 &&
          dinfo->comp_info[0].v_samp_factor == tjMCUHeight[i] / 8) {
        int match = 0;

        for (k = 1; k < dinfo->num_components; k++) {
          int href = 1, vref = 1;

          if ((dinfo->jpeg_color_space == JCS_YCCK ||
               dinfo->jpeg_color_space == JCS_CMYK) && k == 3) {
            href = tjMCUWidth[i] / 8; vref = tjMCUHeight[i] / 8;
          }
          if (dinfo->comp_info[k].h_samp_factor == href &&
              dinfo->comp_info[k].v_samp_factor == vref)
            match++;
        }
        if (match == dinfo->num_components - 1) {
          retval = i; break;
        }
      }


      if (dinfo->comp_info[0].h_samp_factor == 2 &&
          dinfo->comp_info[0].v_samp_factor == 2 &&
          (i == TJSAMP_422 || i == TJSAMP_440)) {
        int match = 0;

        for (k = 1; k < dinfo->num_components; k++) {
          int href = tjMCUHeight[i] / 8, vref = tjMCUWidth[i] / 8;

          if ((dinfo->jpeg_color_space == JCS_YCCK ||
               dinfo->jpeg_color_space == JCS_CMYK) && k == 3) {
            href = vref = 2;
          }
          if (dinfo->comp_info[k].h_samp_factor == href &&
              dinfo->comp_info[k].v_samp_factor == vref)
            match++;
        }
        if (match == dinfo->num_components - 1) {
          retval = i; break;
        }
      }
    }
  }
  return retval;
}




          char *tjGetErrorStr2(tjhandle handle)
{
  tjinstance *this = (tjinstance *)handle;

  if (this && this->isInstanceError) {
    this->isInstanceError = 0;
    return this->errStr;
  } else
    return errStr;
}


          char *tjGetErrorStr(void)
{
  return errStr;
}


          int tjGetErrorCode(tjhandle handle)
{
  tjinstance *this = (tjinstance *)handle;

  if (this && this->jerr.warning) return TJERR_WARNING;
  else return TJERR_FATAL;
}


          int tjDestroy(tjhandle handle)
{
  tjinstance *this = (tjinstance *)handle; j_compress_ptr cinfo = ((void*)0); j_decompress_ptr dinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } cinfo = &this->cinfo; dinfo = &this->dinfo; this->jerr.warning = 0; this->isInstanceError = 0;;

  if (_setjmp (this->jerr.setjmp_buffer)) return -1;
  if (this->init & COMPRESS) jpeg_destroy_compress(cinfo);
  if (this->init & DECOMPRESS) jpeg_destroy_decompress(dinfo);
  free(this);
  return 0;
}







          void tjFree(unsigned char *buf)
{
  if (buf) free(buf);
}


          unsigned char *tjAlloc(int bytes)
{
  return (unsigned char *)malloc(bytes);
}




static tjhandle _tjInitCompress(tjinstance *this)
{
  static unsigned char buffer[1];
  unsigned char *buf = buffer;
  unsigned long size = 1;


  this->cinfo.err = jpeg_std_error(&this->jerr.pub);
  this->jerr.pub.error_exit = my_error_exit;
  this->jerr.pub.output_message = my_output_message;
  this->jerr.emit_message = this->jerr.pub.emit_message;
  this->jerr.pub.emit_message = my_emit_message;
  this->jerr.pub.addon_message_table = turbojpeg_message_table;
  this->jerr.pub.first_addon_message = JMSG_FIRSTADDONCODE;
  this->jerr.pub.last_addon_message = JMSG_LASTADDONCODE;

  if (_setjmp (this->jerr.setjmp_buffer)) {

    if (this) free(this);
    return ((void*)0);
  }

  jpeg_CreateCompress((&this->cinfo), 62, (size_t)sizeof(struct jpeg_compress_struct));

  jpeg_mem_dest_tj(&this->cinfo, &buf, &size, 0);

  this->init |= COMPRESS;
  return (tjhandle)this;
}

          tjhandle tjInitCompress(void)
{
  tjinstance *this = ((void*)0);

  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == ((void*)0)) {
    snprintf(errStr, 200,
             "tjInitCompress(): Memory allocation failure");
    return ((void*)0);
  }
  memset((void *)(this), 0, (size_t)(sizeof(tjinstance)));
  snprintf(this->errStr, 200, "No error");
  return _tjInitCompress(this);
}


          unsigned long tjBufSize(int width, int height, int jpegSubsamp)
{
  unsigned long retval = 0;
  int mcuw, mcuh, chromasf;

  if (width < 1 || height < 1 || jpegSubsamp < 0 || jpegSubsamp >= 6)
    { snprintf(errStr, 200, "%s", "tjBufSize(): Invalid argument"); retval = -1; goto bailout; };




  mcuw = tjMCUWidth[jpegSubsamp];
  mcuh = tjMCUHeight[jpegSubsamp];
  chromasf = jpegSubsamp == TJSAMP_GRAY ? 0 : 4 * 64 / (mcuw * mcuh);
  retval = ((width + (mcuw) - 1) & (~((mcuw) - 1))) * ((height + (mcuh) - 1) & (~((mcuh) - 1))) * (2 + chromasf) + 2048;

bailout:
  return retval;
}

          unsigned long TJBUFSIZE(int width, int height)
{
  unsigned long retval = 0;

  if (width < 1 || height < 1)
    { snprintf(errStr, 200, "%s", "TJBUFSIZE(): Invalid argument"); retval = -1; goto bailout; };




  retval = ((width + (16) - 1) & (~((16) - 1))) * ((height + (16) - 1) & (~((16) - 1))) * 6 + 2048;

bailout:
  return retval;
}


          unsigned long tjBufSizeYUV2(int width, int pad, int height,
                                      int subsamp)
{
  int retval = 0, nc, i;

  if (subsamp < 0 || subsamp >= 6)
    { snprintf(errStr, 200, "%s", "tjBufSizeYUV2(): Invalid argument"); retval = -1; goto bailout; };

  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
  for (i = 0; i < nc; i++) {
    int pw = tjPlaneWidth(i, width, subsamp);
    int stride = ((pw + (pad) - 1) & (~((pad) - 1)));
    int ph = tjPlaneHeight(i, height, subsamp);

    if (pw < 0 || ph < 0) return -1;
    else retval += stride * ph;
  }

bailout:
  return retval;
}

          unsigned long tjBufSizeYUV(int width, int height, int subsamp)
{
  return tjBufSizeYUV2(width, 4, height, subsamp);
}

          unsigned long TJBUFSIZEYUV(int width, int height, int subsamp)
{
  return tjBufSizeYUV(width, height, subsamp);
}


          int tjPlaneWidth(int componentID, int width, int subsamp)
{
  int pw, nc, retval = 0;

  if (width < 1 || subsamp < 0 || subsamp >= 6)
    { snprintf(errStr, 200, "%s", "tjPlaneWidth(): Invalid argument"); retval = -1; goto bailout; };
  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
  if (componentID < 0 || componentID >= nc)
    { snprintf(errStr, 200, "%s", "tjPlaneWidth(): Invalid argument"); retval = -1; goto bailout; };

  pw = ((width + (tjMCUWidth[subsamp] / 8) - 1) & (~((tjMCUWidth[subsamp] / 8) - 1)));
  if (componentID == 0)
    retval = pw;
  else
    retval = pw * 8 / tjMCUWidth[subsamp];

bailout:
  return retval;
}


          int tjPlaneHeight(int componentID, int height, int subsamp)
{
  int ph, nc, retval = 0;

  if (height < 1 || subsamp < 0 || subsamp >= 6)
    { snprintf(errStr, 200, "%s", "tjPlaneHeight(): Invalid argument"); retval = -1; goto bailout; };
  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
  if (componentID < 0 || componentID >= nc)
    { snprintf(errStr, 200, "%s", "tjPlaneHeight(): Invalid argument"); retval = -1; goto bailout; };

  ph = ((height + (tjMCUHeight[subsamp] / 8) - 1) & (~((tjMCUHeight[subsamp] / 8) - 1)));
  if (componentID == 0)
    retval = ph;
  else
    retval = ph * 8 / tjMCUHeight[subsamp];

bailout:
  return retval;
}


          unsigned long tjPlaneSizeYUV(int componentID, int width, int stride,
                                       int height, int subsamp)
{
  unsigned long retval = 0;
  int pw, ph;

  if (width < 1 || height < 1 || subsamp < 0 || subsamp >= 6)
    { snprintf(errStr, 200, "%s", "tjPlaneSizeYUV(): Invalid argument"); retval = -1; goto bailout; };

  pw = tjPlaneWidth(componentID, width, subsamp);
  ph = tjPlaneHeight(componentID, height, subsamp);
  if (pw < 0 || ph < 0) return -1;

  if (stride == 0) stride = pw;
  else stride = abs(stride);

  retval = stride * (ph - 1) + pw;

bailout:
  return retval;
}


          int tjCompress2(tjhandle handle, const unsigned char *srcBuf,
                          int width, int pitch, int height, int pixelFormat,
                          unsigned char **jpegBuf, unsigned long *jpegSize,
                          int jpegSubsamp, int jpegQual, int flags)
{
  int i, retval = 0, alloc = 1;
  JSAMPROW *row_pointer = ((void*)0);

  tjinstance *this = (tjinstance *)handle; j_compress_ptr cinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } cinfo = &this->cinfo; this->jerr.warning = 0; this->isInstanceError = 0;
  this->jerr.stopOnWarning = (flags & 8192) ? 1 : 0;
  if ((this->init & COMPRESS) == 0)
    { snprintf(this->errStr, 200, "%s", "tjCompress2(): Instance has not been initialized for compression"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompress2(): Instance has not been initialized for compression"); retval = -1; goto bailout; } };

  if (srcBuf == ((void*)0) || width <= 0 || pitch < 0 || height <= 0 ||
      pixelFormat < 0 || pixelFormat >= 12 || jpegBuf == ((void*)0) ||
      jpegSize == ((void*)0) || jpegSubsamp < 0 || jpegSubsamp >= 6 ||
      jpegQual < 0 || jpegQual > 100)
    { snprintf(this->errStr, 200, "%s", "tjCompress2(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompress2(): Invalid argument"); retval = -1; goto bailout; } };

  if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];

  if ((row_pointer = (JSAMPROW *)malloc(sizeof(JSAMPROW) * height)) == ((void*)0))
    { snprintf(this->errStr, 200, "%s", "tjCompress2(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompress2(): Memory allocation failure"); retval = -1; goto bailout; } };

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  cinfo->image_width = width;
  cinfo->image_height = height;


  if (flags & 8) putenv("JSIMD_FORCEMMX=1");
  else if (flags & 16) putenv("JSIMD_FORCESSE=1");
  else if (flags & 32) putenv("JSIMD_FORCESSE2=1");


  if (flags & 1024) {
    alloc = 0; *jpegSize = tjBufSize(width, height, jpegSubsamp);
  }
  jpeg_mem_dest_tj(cinfo, jpegBuf, jpegSize, alloc);
  if (setCompDefaults(cinfo, pixelFormat, jpegSubsamp, jpegQual, flags) == -1)
    return -1;

  jpeg_start_compress(cinfo, 1);
  for (i = 0; i < height; i++) {
    if (flags & 2)
      row_pointer[i] = (JSAMPROW)&srcBuf[(height - i - 1) * pitch];
    else
      row_pointer[i] = (JSAMPROW)&srcBuf[i * pitch];
  }
  while (cinfo->next_scanline < cinfo->image_height)
    jpeg_write_scanlines(cinfo, &row_pointer[cinfo->next_scanline],
                         cinfo->image_height - cinfo->next_scanline);
  jpeg_finish_compress(cinfo);

bailout:
  if (cinfo->global_state > 100) jpeg_abort_compress(cinfo);
  if (row_pointer) free(row_pointer);
  if (this->jerr.warning) retval = -1;
  this->jerr.stopOnWarning = 0;
  return retval;
}

          int tjCompress(tjhandle handle, unsigned char *srcBuf, int width,
                         int pitch, int height, int pixelSize,
                         unsigned char *jpegBuf, unsigned long *jpegSize,
                         int jpegSubsamp, int jpegQual, int flags)
{
  int retval = 0;
  unsigned long size;

  if (flags & 512) {
    size = tjBufSizeYUV(width, height, jpegSubsamp);
    retval = tjEncodeYUV2(handle, srcBuf, width, pitch, height,
                          getPixelFormat(pixelSize, flags), jpegBuf,
                          jpegSubsamp, flags);
  } else {
    retval = tjCompress2(handle, srcBuf, width, pitch, height,
                         getPixelFormat(pixelSize, flags), &jpegBuf, &size,
                         jpegSubsamp, jpegQual, flags | 1024);
  }
  *jpegSize = size;
  return retval;
}


          int tjEncodeYUVPlanes(tjhandle handle, const unsigned char *srcBuf,
                                int width, int pitch, int height,
                                int pixelFormat, unsigned char **dstPlanes,
                                int *strides, int subsamp, int flags)
{
  JSAMPROW *row_pointer = ((void*)0);
  JSAMPLE *_tmpbuf[10], *_tmpbuf2[10];
  JSAMPROW *tmpbuf[10], *tmpbuf2[10];
  JSAMPROW *outbuf[10];
  int i, retval = 0, row, pw0, ph0, pw[10], ph[10];
  JSAMPLE *ptr;
  jpeg_component_info *compptr;

  tjinstance *this = (tjinstance *)handle; j_compress_ptr cinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } cinfo = &this->cinfo; this->jerr.warning = 0; this->isInstanceError = 0;;
  this->jerr.stopOnWarning = (flags & 8192) ? 1 : 0;

  for (i = 0; i < 10; i++) {
    tmpbuf[i] = ((void*)0); _tmpbuf[i] = ((void*)0);
    tmpbuf2[i] = ((void*)0); _tmpbuf2[i] = ((void*)0); outbuf[i] = ((void*)0);
  }

  if ((this->init & COMPRESS) == 0)
    { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Instance has not been initialized for compression"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Instance has not been initialized for compression"); retval = -1; goto bailout; } };

  if (srcBuf == ((void*)0) || width <= 0 || pitch < 0 || height <= 0 ||
      pixelFormat < 0 || pixelFormat >= 12 || !dstPlanes ||
      !dstPlanes[0] || subsamp < 0 || subsamp >= 6)
    { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Invalid argument"); retval = -1; goto bailout; } };
  if (subsamp != TJSAMP_GRAY && (!dstPlanes[1] || !dstPlanes[2]))
    { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Invalid argument"); retval = -1; goto bailout; } };

  if (pixelFormat == TJPF_CMYK)
    { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Cannot generate YUV images from CMYK pixels"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Cannot generate YUV images from CMYK pixels"); retval = -1; goto bailout; } };

  if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  cinfo->image_width = width;
  cinfo->image_height = height;


  if (flags & 8) putenv("JSIMD_FORCEMMX=1");
  else if (flags & 16) putenv("JSIMD_FORCESSE=1");
  else if (flags & 32) putenv("JSIMD_FORCESSE2=1");


  if (setCompDefaults(cinfo, pixelFormat, subsamp, -1, flags) == -1) return -1;





  if (cinfo->global_state != 100)
    { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): libjpeg API is in the wrong state"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): libjpeg API is in the wrong state"); retval = -1; goto bailout; } };
  (*cinfo->err->reset_error_mgr) ((j_common_ptr)cinfo);
  jinit_c_master_control(cinfo, 0);
  jinit_color_converter(cinfo);
  jinit_downsampler(cinfo);
  (*cinfo->cconvert->start_pass) (cinfo);

  pw0 = ((width + (cinfo->max_h_samp_factor) - 1) & (~((cinfo->max_h_samp_factor) - 1)));
  ph0 = ((height + (cinfo->max_v_samp_factor) - 1) & (~((cinfo->max_v_samp_factor) - 1)));

  if ((row_pointer = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph0)) == ((void*)0))
    { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
  for (i = 0; i < height; i++) {
    if (flags & 2)
      row_pointer[i] = (JSAMPROW)&srcBuf[(height - i - 1) * pitch];
    else
      row_pointer[i] = (JSAMPROW)&srcBuf[i * pitch];
  }
  if (height < ph0)
    for (i = height; i < ph0; i++) row_pointer[i] = row_pointer[height - 1];

  for (i = 0; i < cinfo->num_components; i++) {
    compptr = &cinfo->comp_info[i];
    _tmpbuf[i] = (JSAMPLE *)malloc(
      (((compptr->width_in_blocks * cinfo->max_h_samp_factor * 8) / compptr->h_samp_factor + (32) - 1) & (~((32) - 1))) *

      cinfo->max_v_samp_factor + 32);
    if (!_tmpbuf[i])
      { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    tmpbuf[i] =
      (JSAMPROW *)malloc(sizeof(JSAMPROW) * cinfo->max_v_samp_factor);
    if (!tmpbuf[i])
      { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    for (row = 0; row < cinfo->max_v_samp_factor; row++) {
      unsigned char *_tmpbuf_aligned =
        (unsigned char *)(((size_t)_tmpbuf[i] + (32) - 1) & (~((32) - 1)));

      tmpbuf[i][row] = &_tmpbuf_aligned[
        (((compptr->width_in_blocks * cinfo->max_h_samp_factor * 8) / compptr->h_samp_factor + (32) - 1) & (~((32) - 1))) * row];

    }
    _tmpbuf2[i] =
      (JSAMPLE *)malloc(((compptr->width_in_blocks * 8 + (32) - 1) & (~((32) - 1))) *
                        compptr->v_samp_factor + 32);
    if (!_tmpbuf2[i])
      { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    tmpbuf2[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * compptr->v_samp_factor);
    if (!tmpbuf2[i])
      { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    for (row = 0; row < compptr->v_samp_factor; row++) {
      unsigned char *_tmpbuf2_aligned =
        (unsigned char *)(((size_t)_tmpbuf2[i] + (32) - 1) & (~((32) - 1)));

      tmpbuf2[i][row] =
        &_tmpbuf2_aligned[((compptr->width_in_blocks * 8 + (32) - 1) & (~((32) - 1))) * row];
    }
    pw[i] = pw0 * compptr->h_samp_factor / cinfo->max_h_samp_factor;
    ph[i] = ph0 * compptr->v_samp_factor / cinfo->max_v_samp_factor;
    outbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph[i]);
    if (!outbuf[i])
      { snprintf(this->errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    ptr = dstPlanes[i];
    for (row = 0; row < ph[i]; row++) {
      outbuf[i][row] = ptr;
      ptr += (strides && strides[i] != 0) ? strides[i] : pw[i];
    }
  }

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  for (row = 0; row < ph0; row += cinfo->max_v_samp_factor) {
    (*cinfo->cconvert->color_convert) (cinfo, &row_pointer[row], tmpbuf, 0,
                                       cinfo->max_v_samp_factor);
    (cinfo->downsample->downsample) (cinfo, tmpbuf, 0, tmpbuf2, 0);
    for (i = 0, compptr = cinfo->comp_info; i < cinfo->num_components;
         i++, compptr++)
      jcopy_sample_rows(tmpbuf2[i], 0, outbuf[i],
        row * compptr->v_samp_factor / cinfo->max_v_samp_factor,
        compptr->v_samp_factor, pw[i]);
  }
  cinfo->next_scanline += height;
  jpeg_abort_compress(cinfo);

bailout:
  if (cinfo->global_state > 100) jpeg_abort_compress(cinfo);
  if (row_pointer) free(row_pointer);
  for (i = 0; i < 10; i++) {
    if (tmpbuf[i] != ((void*)0)) free(tmpbuf[i]);
    if (_tmpbuf[i] != ((void*)0)) free(_tmpbuf[i]);
    if (tmpbuf2[i] != ((void*)0)) free(tmpbuf2[i]);
    if (_tmpbuf2[i] != ((void*)0)) free(_tmpbuf2[i]);
    if (outbuf[i] != ((void*)0)) free(outbuf[i]);
  }
  if (this->jerr.warning) retval = -1;
  this->jerr.stopOnWarning = 0;
  return retval;
}

          int tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,
                           int width, int pitch, int height, int pixelFormat,
                           unsigned char *dstBuf, int pad, int subsamp,
                           int flags)
{
  unsigned char *dstPlanes[3];
  int pw0, ph0, strides[3], retval = -1;
  tjinstance *this = (tjinstance *)handle;

  if (!this) { snprintf(errStr, 200, "%s", "tjEncodeYUV3(): Invalid handle"); retval = -1; goto bailout; };
  this->isInstanceError = 0;

  if (width <= 0 || height <= 0 || dstBuf == ((void*)0) || pad < 0 || !(((pad) & (pad - 1)) == 0) ||
      subsamp < 0 || subsamp >= 6)
    { snprintf(this->errStr, 200, "%s", "tjEncodeYUV3(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjEncodeYUV3(): Invalid argument"); retval = -1; goto bailout; } };

  pw0 = tjPlaneWidth(0, width, subsamp);
  ph0 = tjPlaneHeight(0, height, subsamp);
  dstPlanes[0] = dstBuf;
  strides[0] = ((pw0 + (pad) - 1) & (~((pad) - 1)));
  if (subsamp == TJSAMP_GRAY) {
    strides[1] = strides[2] = 0;
    dstPlanes[1] = dstPlanes[2] = ((void*)0);
  } else {
    int pw1 = tjPlaneWidth(1, width, subsamp);
    int ph1 = tjPlaneHeight(1, height, subsamp);

    strides[1] = strides[2] = ((pw1 + (pad) - 1) & (~((pad) - 1)));
    dstPlanes[1] = dstPlanes[0] + strides[0] * ph0;
    dstPlanes[2] = dstPlanes[1] + strides[1] * ph1;
  }

  return tjEncodeYUVPlanes(handle, srcBuf, width, pitch, height, pixelFormat,
                           dstPlanes, strides, subsamp, flags);

bailout:
  return retval;
}

          int tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf, int width,
                           int pitch, int height, int pixelFormat,
                           unsigned char *dstBuf, int subsamp, int flags)
{
  return tjEncodeYUV3(handle, srcBuf, width, pitch, height, pixelFormat,
                      dstBuf, 4, subsamp, flags);
}

          int tjEncodeYUV(tjhandle handle, unsigned char *srcBuf, int width,
                          int pitch, int height, int pixelSize,
                          unsigned char *dstBuf, int subsamp, int flags)
{
  return tjEncodeYUV2(handle, srcBuf, width, pitch, height,
                      getPixelFormat(pixelSize, flags), dstBuf, subsamp,
                      flags);
}


          int tjCompressFromYUVPlanes(tjhandle handle,
                                      const unsigned char **srcPlanes,
                                      int width, const int *strides,
                                      int height, int subsamp,
                                      unsigned char **jpegBuf,
                                      unsigned long *jpegSize, int jpegQual,
                                      int flags)
{
  int i, row, retval = 0, alloc = 1;
  int pw[10], ph[10], iw[10],
    tmpbufsize = 0, usetmpbuf = 0, th[10];
  JSAMPLE *_tmpbuf = ((void*)0), *ptr;
  JSAMPROW *inbuf[10], *tmpbuf[10];

  tjinstance *this = (tjinstance *)handle; j_compress_ptr cinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } cinfo = &this->cinfo; this->jerr.warning = 0; this->isInstanceError = 0;
  this->jerr.stopOnWarning = (flags & 8192) ? 1 : 0;

  for (i = 0; i < 10; i++) {
    tmpbuf[i] = ((void*)0); inbuf[i] = ((void*)0);
  }

  if ((this->init & COMPRESS) == 0)
    { snprintf(this->errStr, 200, "%s", "tjCompressFromYUVPlanes(): Instance has not been initialized for compression"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Instance has not been initialized for compression"); retval = -1; goto bailout; } };

  if (!srcPlanes || !srcPlanes[0] || width <= 0 || height <= 0 ||
      subsamp < 0 || subsamp >= 6 || jpegBuf == ((void*)0) ||
      jpegSize == ((void*)0) || jpegQual < 0 || jpegQual > 100)
    { snprintf(this->errStr, 200, "%s", "tjCompressFromYUVPlanes(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Invalid argument"); retval = -1; goto bailout; } };
  if (subsamp != TJSAMP_GRAY && (!srcPlanes[1] || !srcPlanes[2]))
    { snprintf(this->errStr, 200, "%s", "tjCompressFromYUVPlanes(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Invalid argument"); retval = -1; goto bailout; } };

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  cinfo->image_width = width;
  cinfo->image_height = height;


  if (flags & 8) putenv("JSIMD_FORCEMMX=1");
  else if (flags & 16) putenv("JSIMD_FORCESSE=1");
  else if (flags & 32) putenv("JSIMD_FORCESSE2=1");


  if (flags & 1024) {
    alloc = 0; *jpegSize = tjBufSize(width, height, subsamp);
  }
  jpeg_mem_dest_tj(cinfo, jpegBuf, jpegSize, alloc);
  if (setCompDefaults(cinfo, TJPF_RGB, subsamp, jpegQual, flags) == -1)
    return -1;
  cinfo->raw_data_in = 1;

  jpeg_start_compress(cinfo, 1);
  for (i = 0; i < cinfo->num_components; i++) {
    jpeg_component_info *compptr = &cinfo->comp_info[i];
    int ih;

    iw[i] = compptr->width_in_blocks * 8;
    ih = compptr->height_in_blocks * 8;
    pw[i] = ((cinfo->image_width + (cinfo->max_h_samp_factor) - 1) & (~((cinfo->max_h_samp_factor) - 1))) *
            compptr->h_samp_factor / cinfo->max_h_samp_factor;
    ph[i] = ((cinfo->image_height + (cinfo->max_v_samp_factor) - 1) & (~((cinfo->max_v_samp_factor) - 1))) *
            compptr->v_samp_factor / cinfo->max_v_samp_factor;
    if (iw[i] != pw[i] || ih != ph[i]) usetmpbuf = 1;
    th[i] = compptr->v_samp_factor * 8;
    tmpbufsize += iw[i] * th[i];
    if ((inbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph[i])) == ((void*)0))
      { snprintf(this->errStr, 200, "%s", "tjCompressFromYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    ptr = (JSAMPLE *)srcPlanes[i];
    for (row = 0; row < ph[i]; row++) {
      inbuf[i][row] = ptr;
      ptr += (strides && strides[i] != 0) ? strides[i] : pw[i];
    }
  }
  if (usetmpbuf) {
    if ((_tmpbuf = (JSAMPLE *)malloc(sizeof(JSAMPLE) * tmpbufsize)) == ((void*)0))
      { snprintf(this->errStr, 200, "%s", "tjCompressFromYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    ptr = _tmpbuf;
    for (i = 0; i < cinfo->num_components; i++) {
      if ((tmpbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * th[i])) == ((void*)0))
        { snprintf(this->errStr, 200, "%s", "tjCompressFromYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompressFromYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
      for (row = 0; row < th[i]; row++) {
        tmpbuf[i][row] = ptr;
        ptr += iw[i];
      }
    }
  }

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  for (row = 0; row < (int)cinfo->image_height;
       row += cinfo->max_v_samp_factor * 8) {
    JSAMPARRAY yuvptr[10];
    int crow[10];

    for (i = 0; i < cinfo->num_components; i++) {
      jpeg_component_info *compptr = &cinfo->comp_info[i];

      crow[i] = row * compptr->v_samp_factor / cinfo->max_v_samp_factor;
      if (usetmpbuf) {
        int j, k;

        for (j = 0; j < ((th[i]) < (ph[i] - crow[i]) ? (th[i]) : (ph[i] - crow[i])); j++) {
          memcpy(tmpbuf[i][j], inbuf[i][crow[i] + j], pw[i]);

          for (k = pw[i]; k < iw[i]; k++)
            tmpbuf[i][j][k] = tmpbuf[i][j][pw[i] - 1];
        }

        for (j = ph[i] - crow[i]; j < th[i]; j++)
          memcpy(tmpbuf[i][j], tmpbuf[i][ph[i] - crow[i] - 1], iw[i]);
        yuvptr[i] = tmpbuf[i];
      } else
        yuvptr[i] = &inbuf[i][crow[i]];
    }
    jpeg_write_raw_data(cinfo, yuvptr, cinfo->max_v_samp_factor * 8);
  }
  jpeg_finish_compress(cinfo);

bailout:
  if (cinfo->global_state > 100) jpeg_abort_compress(cinfo);
  for (i = 0; i < 10; i++) {
    if (tmpbuf[i]) free(tmpbuf[i]);
    if (inbuf[i]) free(inbuf[i]);
  }
  if (_tmpbuf) free(_tmpbuf);
  if (this->jerr.warning) retval = -1;
  this->jerr.stopOnWarning = 0;
  return retval;
}

          int tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,
                                int width, int pad, int height, int subsamp,
                                unsigned char **jpegBuf,
                                unsigned long *jpegSize, int jpegQual,
                                int flags)
{
  const unsigned char *srcPlanes[3];
  int pw0, ph0, strides[3], retval = -1;
  tjinstance *this = (tjinstance *)handle;

  if (!this) { snprintf(errStr, 200, "%s", "tjCompressFromYUV(): Invalid handle"); retval = -1; goto bailout; };
  this->isInstanceError = 0;

  if (srcBuf == ((void*)0) || width <= 0 || pad < 1 || height <= 0 || subsamp < 0 ||
      subsamp >= 6)
    { snprintf(this->errStr, 200, "%s", "tjCompressFromYUV(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjCompressFromYUV(): Invalid argument"); retval = -1; goto bailout; } };

  pw0 = tjPlaneWidth(0, width, subsamp);
  ph0 = tjPlaneHeight(0, height, subsamp);
  srcPlanes[0] = srcBuf;
  strides[0] = ((pw0 + (pad) - 1) & (~((pad) - 1)));
  if (subsamp == TJSAMP_GRAY) {
    strides[1] = strides[2] = 0;
    srcPlanes[1] = srcPlanes[2] = ((void*)0);
  } else {
    int pw1 = tjPlaneWidth(1, width, subsamp);
    int ph1 = tjPlaneHeight(1, height, subsamp);

    strides[1] = strides[2] = ((pw1 + (pad) - 1) & (~((pad) - 1)));
    srcPlanes[1] = srcPlanes[0] + strides[0] * ph0;
    srcPlanes[2] = srcPlanes[1] + strides[1] * ph1;
  }

  return tjCompressFromYUVPlanes(handle, srcPlanes, width, strides, height,
                                 subsamp, jpegBuf, jpegSize, jpegQual, flags);

bailout:
  return retval;
}




static tjhandle _tjInitDecompress(tjinstance *this)
{
  static unsigned char buffer[1];


  this->dinfo.err = jpeg_std_error(&this->jerr.pub);
  this->jerr.pub.error_exit = my_error_exit;
  this->jerr.pub.output_message = my_output_message;
  this->jerr.emit_message = this->jerr.pub.emit_message;
  this->jerr.pub.emit_message = my_emit_message;
  this->jerr.pub.addon_message_table = turbojpeg_message_table;
  this->jerr.pub.first_addon_message = JMSG_FIRSTADDONCODE;
  this->jerr.pub.last_addon_message = JMSG_LASTADDONCODE;

  if (_setjmp (this->jerr.setjmp_buffer)) {

    if (this) free(this);
    return ((void*)0);
  }

  jpeg_CreateDecompress((&this->dinfo), 62, (size_t)sizeof(struct jpeg_decompress_struct));

  jpeg_mem_src_tj(&this->dinfo, buffer, 1);

  this->init |= DECOMPRESS;
  return (tjhandle)this;
}

          tjhandle tjInitDecompress(void)
{
  tjinstance *this;

  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == ((void*)0)) {
    snprintf(errStr, 200,
             "tjInitDecompress(): Memory allocation failure");
    return ((void*)0);
  }
  memset((void *)(this), 0, (size_t)(sizeof(tjinstance)));
  snprintf(this->errStr, 200, "No error");
  return _tjInitDecompress(this);
}


          int tjDecompressHeader3(tjhandle handle,
                                  const unsigned char *jpegBuf,
                                  unsigned long jpegSize, int *width,
                                  int *height, int *jpegSubsamp,
                                  int *jpegColorspace)
{
  int retval = 0;

  tjinstance *this = (tjinstance *)handle; j_decompress_ptr dinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } dinfo = &this->dinfo; this->jerr.warning = 0; this->isInstanceError = 0;;
  if ((this->init & DECOMPRESS) == 0)
    { snprintf(this->errStr, 200, "%s", "tjDecompressHeader3(): Instance has not been initialized for decompression"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Instance has not been initialized for decompression"); retval = -1; goto bailout; } };

  if (jpegBuf == ((void*)0) || jpegSize <= 0 || width == ((void*)0) || height == ((void*)0) ||
      jpegSubsamp == ((void*)0) || jpegColorspace == ((void*)0))
    { snprintf(this->errStr, 200, "%s", "tjDecompressHeader3(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Invalid argument"); retval = -1; goto bailout; } };

  if (_setjmp (this->jerr.setjmp_buffer)) {

    return -1;
  }

  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);
  jpeg_read_header(dinfo, 1);

  *width = dinfo->image_width;
  *height = dinfo->image_height;
  *jpegSubsamp = getSubsamp(dinfo);
  switch (dinfo->jpeg_color_space) {
  case JCS_GRAYSCALE: *jpegColorspace = TJCS_GRAY; break;
  case JCS_RGB: *jpegColorspace = TJCS_RGB; break;
  case JCS_YCbCr: *jpegColorspace = TJCS_YCbCr; break;
  case JCS_CMYK: *jpegColorspace = TJCS_CMYK; break;
  case JCS_YCCK: *jpegColorspace = TJCS_YCCK; break;
  default: *jpegColorspace = -1; break;
  }

  jpeg_abort_decompress(dinfo);

  if (*jpegSubsamp < 0)
    { snprintf(this->errStr, 200, "%s", "tjDecompressHeader3(): Could not determine subsampling type for JPEG image"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Could not determine subsampling type for JPEG image"); retval = -1; goto bailout; } };
  if (*jpegColorspace < 0)
    { snprintf(this->errStr, 200, "%s", "tjDecompressHeader3(): Could not determine colorspace of JPEG image"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Could not determine colorspace of JPEG image"); retval = -1; goto bailout; } };
  if (*width < 1 || *height < 1)
    { snprintf(this->errStr, 200, "%s", "tjDecompressHeader3(): Invalid data returned in header"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressHeader3(): Invalid data returned in header"); retval = -1; goto bailout; } };

bailout:
  if (this->jerr.warning) retval = -1;
  return retval;
}

          int tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,
                                  unsigned long jpegSize, int *width,
                                  int *height, int *jpegSubsamp)
{
  int jpegColorspace;

  return tjDecompressHeader3(handle, jpegBuf, jpegSize, width, height,
                             jpegSubsamp, &jpegColorspace);
}

          int tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,
                                 unsigned long jpegSize, int *width,
                                 int *height)
{
  int jpegSubsamp;

  return tjDecompressHeader2(handle, jpegBuf, jpegSize, width, height,
                             &jpegSubsamp);
}


          tjscalingfactor *tjGetScalingFactors(int *numscalingfactors)
{
  if (numscalingfactors == ((void*)0)) {
    snprintf(errStr, 200,
             "tjGetScalingFactors(): Invalid argument");
    return ((void*)0);
  }

  *numscalingfactors = 16;
  return (tjscalingfactor *)sf;
}


          int tjDecompress2(tjhandle handle, const unsigned char *jpegBuf,
                            unsigned long jpegSize, unsigned char *dstBuf,
                            int width, int pitch, int height, int pixelFormat,
                            int flags)
{
  JSAMPROW *row_pointer = ((void*)0);
  int i, retval = 0, jpegwidth, jpegheight, scaledw, scaledh;

  tjinstance *this = (tjinstance *)handle; j_decompress_ptr dinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } dinfo = &this->dinfo; this->jerr.warning = 0; this->isInstanceError = 0;;
  this->jerr.stopOnWarning = (flags & 8192) ? 1 : 0;
  if ((this->init & DECOMPRESS) == 0)
    { snprintf(this->errStr, 200, "%s", "tjDecompress2(): Instance has not been initialized for decompression"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompress2(): Instance has not been initialized for decompression"); retval = -1; goto bailout; } };

  if (jpegBuf == ((void*)0) || jpegSize <= 0 || dstBuf == ((void*)0) || width < 0 ||
      pitch < 0 || height < 0 || pixelFormat < 0 || pixelFormat >= 12)
    { snprintf(this->errStr, 200, "%s", "tjDecompress2(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompress2(): Invalid argument"); retval = -1; goto bailout; } };


  if (flags & 8) putenv("JSIMD_FORCEMMX=1");
  else if (flags & 16) putenv("JSIMD_FORCESSE=1");
  else if (flags & 32) putenv("JSIMD_FORCESSE2=1");


  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);
  jpeg_read_header(dinfo, 1);
  this->dinfo.out_color_space = pf2cs[pixelFormat];
  if (flags & 2048) this->dinfo.dct_method = JDCT_IFAST;
  if (flags & 256) dinfo->do_fancy_upsampling = 0;

  jpegwidth = dinfo->image_width; jpegheight = dinfo->image_height;
  if (width == 0) width = jpegwidth;
  if (height == 0) height = jpegheight;
  for (i = 0; i < 16; i++) {
    scaledw = ((jpegwidth * sf[i].num + sf[i].denom - 1) / sf[i].denom);
    scaledh = ((jpegheight * sf[i].num + sf[i].denom - 1) / sf[i].denom);
    if (scaledw <= width && scaledh <= height)
      break;
  }
  if (i >= 16)
    { snprintf(this->errStr, 200, "%s", "tjDecompress2(): Could not scale down to desired image dimensions"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompress2(): Could not scale down to desired image dimensions"); retval = -1; goto bailout; } };
  width = scaledw; height = scaledh;
  dinfo->scale_num = sf[i].num;
  dinfo->scale_denom = sf[i].denom;

  jpeg_start_decompress(dinfo);
  if (pitch == 0) pitch = dinfo->output_width * tjPixelSize[pixelFormat];

  if ((row_pointer =
       (JSAMPROW *)malloc(sizeof(JSAMPROW) * dinfo->output_height)) == ((void*)0))
    { snprintf(this->errStr, 200, "%s", "tjDecompress2(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompress2(): Memory allocation failure"); retval = -1; goto bailout; } };
  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }
  for (i = 0; i < (int)dinfo->output_height; i++) {
    if (flags & 2)
      row_pointer[i] = &dstBuf[(dinfo->output_height - i - 1) * pitch];
    else
      row_pointer[i] = &dstBuf[i * pitch];
  }
  while (dinfo->output_scanline < dinfo->output_height)
    jpeg_read_scanlines(dinfo, &row_pointer[dinfo->output_scanline],
                        dinfo->output_height - dinfo->output_scanline);
  jpeg_finish_decompress(dinfo);

bailout:
  if (dinfo->global_state > 200) jpeg_abort_decompress(dinfo);
  if (row_pointer) free(row_pointer);
  if (this->jerr.warning) retval = -1;
  this->jerr.stopOnWarning = 0;
  return retval;
}

          int tjDecompress(tjhandle handle, unsigned char *jpegBuf,
                           unsigned long jpegSize, unsigned char *dstBuf,
                           int width, int pitch, int height, int pixelSize,
                           int flags)
{
  if (flags & 512)
    return tjDecompressToYUV(handle, jpegBuf, jpegSize, dstBuf, flags);
  else
    return tjDecompress2(handle, jpegBuf, jpegSize, dstBuf, width, pitch,
                         height, getPixelFormat(pixelSize, flags), flags);
}


static int setDecodeDefaults(struct jpeg_decompress_struct *dinfo,
                             int pixelFormat, int subsamp, int flags)
{
  int i;

  dinfo->scale_num = dinfo->scale_denom = 1;

  if (subsamp == TJSAMP_GRAY) {
    dinfo->num_components = dinfo->comps_in_scan = 1;
    dinfo->jpeg_color_space = JCS_GRAYSCALE;
  } else {
    dinfo->num_components = dinfo->comps_in_scan = 3;
    dinfo->jpeg_color_space = JCS_YCbCr;
  }

  dinfo->comp_info = (jpeg_component_info *)
    (*dinfo->mem->alloc_small) ((j_common_ptr)dinfo, 1,
                                dinfo->num_components *
                                sizeof(jpeg_component_info));

  for (i = 0; i < dinfo->num_components; i++) {
    jpeg_component_info *compptr = &dinfo->comp_info[i];

    compptr->h_samp_factor = (i == 0) ? tjMCUWidth[subsamp] / 8 : 1;
    compptr->v_samp_factor = (i == 0) ? tjMCUHeight[subsamp] / 8 : 1;
    compptr->component_index = i;
    compptr->component_id = i + 1;
    compptr->quant_tbl_no = compptr->dc_tbl_no =
      compptr->ac_tbl_no = (i == 0) ? 0 : 1;
    dinfo->cur_comp_info[i] = compptr;
  }
  dinfo->data_precision = 8;
  for (i = 0; i < 2; i++) {
    if (dinfo->quant_tbl_ptrs[i] == ((void*)0))
      dinfo->quant_tbl_ptrs[i] = jpeg_alloc_quant_table((j_common_ptr)dinfo);
  }

  return 0;
}


int my_read_markers(j_decompress_ptr dinfo)
{
  return 1;
}

void my_reset_marker_reader(j_decompress_ptr dinfo)
{
}

          int tjDecodeYUVPlanes(tjhandle handle,
                                const unsigned char **srcPlanes,
                                const int *strides, int subsamp,
                                unsigned char *dstBuf, int width, int pitch,
                                int height, int pixelFormat, int flags)
{
  JSAMPROW *row_pointer = ((void*)0);
  JSAMPLE *_tmpbuf[10];
  JSAMPROW *tmpbuf[10], *inbuf[10];
  int i, retval = 0, row, pw0, ph0, pw[10], ph[10];
  JSAMPLE *ptr;
  jpeg_component_info *compptr;
  int (*old_read_markers) (j_decompress_ptr);
  void (*old_reset_marker_reader) (j_decompress_ptr);

  tjinstance *this = (tjinstance *)handle; j_decompress_ptr dinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } dinfo = &this->dinfo; this->jerr.warning = 0; this->isInstanceError = 0;;
  this->jerr.stopOnWarning = (flags & 8192) ? 1 : 0;

  for (i = 0; i < 10; i++) {
    tmpbuf[i] = ((void*)0); _tmpbuf[i] = ((void*)0); inbuf[i] = ((void*)0);
  }

  if ((this->init & DECOMPRESS) == 0)
    { snprintf(this->errStr, 200, "%s", "tjDecodeYUVPlanes(): Instance has not been initialized for decompression"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Instance has not been initialized for decompression"); retval = -1; goto bailout; } };

  if (!srcPlanes || !srcPlanes[0] || subsamp < 0 || subsamp >= 6 ||
      dstBuf == ((void*)0) || width <= 0 || pitch < 0 || height <= 0 ||
      pixelFormat < 0 || pixelFormat >= 12)
    { snprintf(this->errStr, 200, "%s", "tjDecodeYUVPlanes(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Invalid argument"); retval = -1; goto bailout; } };
  if (subsamp != TJSAMP_GRAY && (!srcPlanes[1] || !srcPlanes[2]))
    { snprintf(this->errStr, 200, "%s", "tjDecodeYUVPlanes(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Invalid argument"); retval = -1; goto bailout; } };

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  if (pixelFormat == TJPF_CMYK)
    { snprintf(this->errStr, 200, "%s", "tjDecodeYUVPlanes(): Cannot decode YUV images into CMYK pixels."); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Cannot decode YUV images into CMYK pixels."); retval = -1; goto bailout; } };

  if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];
  dinfo->image_width = width;
  dinfo->image_height = height;


  if (flags & 8) putenv("JSIMD_FORCEMMX=1");
  else if (flags & 16) putenv("JSIMD_FORCESSE=1");
  else if (flags & 32) putenv("JSIMD_FORCESSE2=1");


  if (setDecodeDefaults(dinfo, pixelFormat, subsamp, flags) == -1) {
    retval = -1; goto bailout;
  }
  old_read_markers = dinfo->marker->read_markers;
  dinfo->marker->read_markers = my_read_markers;
  old_reset_marker_reader = dinfo->marker->reset_marker_reader;
  dinfo->marker->reset_marker_reader = my_reset_marker_reader;
  jpeg_read_header(dinfo, 1);
  dinfo->marker->read_markers = old_read_markers;
  dinfo->marker->reset_marker_reader = old_reset_marker_reader;

  this->dinfo.out_color_space = pf2cs[pixelFormat];
  if (flags & 2048) this->dinfo.dct_method = JDCT_IFAST;
  dinfo->do_fancy_upsampling = 0;
  dinfo->Se = 64 - 1;
  jinit_master_decompress(dinfo);
  (*dinfo->upsample->start_pass) (dinfo);

  pw0 = ((width + (dinfo->max_h_samp_factor) - 1) & (~((dinfo->max_h_samp_factor) - 1)));
  ph0 = ((height + (dinfo->max_v_samp_factor) - 1) & (~((dinfo->max_v_samp_factor) - 1)));

  if (pitch == 0) pitch = dinfo->output_width * tjPixelSize[pixelFormat];

  if ((row_pointer = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph0)) == ((void*)0))
    { snprintf(this->errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
  for (i = 0; i < height; i++) {
    if (flags & 2)
      row_pointer[i] = &dstBuf[(height - i - 1) * pitch];
    else
      row_pointer[i] = &dstBuf[i * pitch];
  }
  if (height < ph0)
    for (i = height; i < ph0; i++) row_pointer[i] = row_pointer[height - 1];

  for (i = 0; i < dinfo->num_components; i++) {
    compptr = &dinfo->comp_info[i];
    _tmpbuf[i] =
      (JSAMPLE *)malloc(((compptr->width_in_blocks * 8 + (32) - 1) & (~((32) - 1))) *
                        compptr->v_samp_factor + 32);
    if (!_tmpbuf[i])
      { snprintf(this->errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    tmpbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * compptr->v_samp_factor);
    if (!tmpbuf[i])
      { snprintf(this->errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    for (row = 0; row < compptr->v_samp_factor; row++) {
      unsigned char *_tmpbuf_aligned =
        (unsigned char *)(((size_t)_tmpbuf[i] + (32) - 1) & (~((32) - 1)));

      tmpbuf[i][row] =
        &_tmpbuf_aligned[((compptr->width_in_blocks * 8 + (32) - 1) & (~((32) - 1))) * row];
    }
    pw[i] = pw0 * compptr->h_samp_factor / dinfo->max_h_samp_factor;
    ph[i] = ph0 * compptr->v_samp_factor / dinfo->max_v_samp_factor;
    inbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph[i]);
    if (!inbuf[i])
      { snprintf(this->errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecodeYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    ptr = (JSAMPLE *)srcPlanes[i];
    for (row = 0; row < ph[i]; row++) {
      inbuf[i][row] = ptr;
      ptr += (strides && strides[i] != 0) ? strides[i] : pw[i];
    }
  }

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  for (row = 0; row < ph0; row += dinfo->max_v_samp_factor) {
    JDIMENSION inrow = 0, outrow = 0;

    for (i = 0, compptr = dinfo->comp_info; i < dinfo->num_components;
         i++, compptr++)
      jcopy_sample_rows(inbuf[i],
        row * compptr->v_samp_factor / dinfo->max_v_samp_factor, tmpbuf[i], 0,
        compptr->v_samp_factor, pw[i]);
    (dinfo->upsample->upsample) (dinfo, tmpbuf, &inrow,
                                 dinfo->max_v_samp_factor, &row_pointer[row],
                                 &outrow, dinfo->max_v_samp_factor);
  }
  jpeg_abort_decompress(dinfo);

bailout:
  if (dinfo->global_state > 200) jpeg_abort_decompress(dinfo);
  if (row_pointer) free(row_pointer);
  for (i = 0; i < 10; i++) {
    if (tmpbuf[i] != ((void*)0)) free(tmpbuf[i]);
    if (_tmpbuf[i] != ((void*)0)) free(_tmpbuf[i]);
    if (inbuf[i] != ((void*)0)) free(inbuf[i]);
  }
  if (this->jerr.warning) retval = -1;
  this->jerr.stopOnWarning = 0;
  return retval;
}

          int tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
                          int pad, int subsamp, unsigned char *dstBuf,
                          int width, int pitch, int height, int pixelFormat,
                          int flags)
{
  const unsigned char *srcPlanes[3];
  int pw0, ph0, strides[3], retval = -1;
  tjinstance *this = (tjinstance *)handle;

  if (!this) { snprintf(errStr, 200, "%s", "tjDecodeYUV(): Invalid handle"); retval = -1; goto bailout; };
  this->isInstanceError = 0;

  if (srcBuf == ((void*)0) || pad < 0 || !(((pad) & (pad - 1)) == 0) || subsamp < 0 ||
      subsamp >= 6 || width <= 0 || height <= 0)
    { snprintf(this->errStr, 200, "%s", "tjDecodeYUV(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecodeYUV(): Invalid argument"); retval = -1; goto bailout; } };

  pw0 = tjPlaneWidth(0, width, subsamp);
  ph0 = tjPlaneHeight(0, height, subsamp);
  srcPlanes[0] = srcBuf;
  strides[0] = ((pw0 + (pad) - 1) & (~((pad) - 1)));
  if (subsamp == TJSAMP_GRAY) {
    strides[1] = strides[2] = 0;
    srcPlanes[1] = srcPlanes[2] = ((void*)0);
  } else {
    int pw1 = tjPlaneWidth(1, width, subsamp);
    int ph1 = tjPlaneHeight(1, height, subsamp);

    strides[1] = strides[2] = ((pw1 + (pad) - 1) & (~((pad) - 1)));
    srcPlanes[1] = srcPlanes[0] + strides[0] * ph0;
    srcPlanes[2] = srcPlanes[1] + strides[1] * ph1;
  }

  return tjDecodeYUVPlanes(handle, srcPlanes, strides, subsamp, dstBuf, width,
                           pitch, height, pixelFormat, flags);

bailout:
  return retval;
}

          int tjDecompressToYUVPlanes(tjhandle handle,
                                      const unsigned char *jpegBuf,
                                      unsigned long jpegSize,
                                      unsigned char **dstPlanes, int width,
                                      int *strides, int height, int flags)
{
  int i, sfi, row, retval = 0;
  int jpegwidth, jpegheight, jpegSubsamp, scaledw, scaledh;
  int pw[10], ph[10], iw[10],
    tmpbufsize = 0, usetmpbuf = 0, th[10];
  JSAMPLE *_tmpbuf = ((void*)0), *ptr;
  JSAMPROW *outbuf[10], *tmpbuf[10];
  int dctsize;

  tjinstance *this = (tjinstance *)handle; j_decompress_ptr dinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } dinfo = &this->dinfo; this->jerr.warning = 0; this->isInstanceError = 0;;
  this->jerr.stopOnWarning = (flags & 8192) ? 1 : 0;

  for (i = 0; i < 10; i++) {
    tmpbuf[i] = ((void*)0); outbuf[i] = ((void*)0);
  }

  if ((this->init & DECOMPRESS) == 0)
    { snprintf(this->errStr, 200, "%s", "tjDecompressToYUVPlanes(): Instance has not been initialized for decompression"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Instance has not been initialized for decompression"); retval = -1; goto bailout; } };

  if (jpegBuf == ((void*)0) || jpegSize <= 0 || !dstPlanes || !dstPlanes[0] ||
      width < 0 || height < 0)
    { snprintf(this->errStr, 200, "%s", "tjDecompressToYUVPlanes(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Invalid argument"); retval = -1; goto bailout; } };


  if (flags & 8) putenv("JSIMD_FORCEMMX=1");
  else if (flags & 16) putenv("JSIMD_FORCESSE=1");
  else if (flags & 32) putenv("JSIMD_FORCESSE2=1");


  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  if (!this->headerRead) {
    jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);
    jpeg_read_header(dinfo, 1);
  }
  this->headerRead = 0;
  jpegSubsamp = getSubsamp(dinfo);
  if (jpegSubsamp < 0)
    { snprintf(this->errStr, 200, "%s", "tjDecompressToYUVPlanes(): Could not determine subsampling type for JPEG image"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Could not determine subsampling type for JPEG image"); retval = -1; goto bailout; } };

  if (jpegSubsamp != TJSAMP_GRAY && (!dstPlanes[1] || !dstPlanes[2]))
    { snprintf(this->errStr, 200, "%s", "tjDecompressToYUVPlanes(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Invalid argument"); retval = -1; goto bailout; } };

  jpegwidth = dinfo->image_width; jpegheight = dinfo->image_height;
  if (width == 0) width = jpegwidth;
  if (height == 0) height = jpegheight;
  for (i = 0; i < 16; i++) {
    scaledw = ((jpegwidth * sf[i].num + sf[i].denom - 1) / sf[i].denom);
    scaledh = ((jpegheight * sf[i].num + sf[i].denom - 1) / sf[i].denom);
    if (scaledw <= width && scaledh <= height)
      break;
  }
  if (i >= 16)
    { snprintf(this->errStr, 200, "%s", "tjDecompressToYUVPlanes(): Could not scale down to desired image dimensions"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Could not scale down to desired image dimensions"); retval = -1; goto bailout; } };
  if (dinfo->num_components > 3)
    { snprintf(this->errStr, 200, "%s", "tjDecompressToYUVPlanes(): JPEG image must have 3 or fewer components"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): JPEG image must have 3 or fewer components"); retval = -1; goto bailout; } };

  width = scaledw; height = scaledh;
  dinfo->scale_num = sf[i].num;
  dinfo->scale_denom = sf[i].denom;
  sfi = i;
  jpeg_calc_output_dimensions(dinfo);

  dctsize = 8 * sf[sfi].num / sf[sfi].denom;

  for (i = 0; i < dinfo->num_components; i++) {
    jpeg_component_info *compptr = &dinfo->comp_info[i];
    int ih;

    iw[i] = compptr->width_in_blocks * dctsize;
    ih = compptr->height_in_blocks * dctsize;
    pw[i] = ((dinfo->output_width + (dinfo->max_h_samp_factor) - 1) & (~((dinfo->max_h_samp_factor) - 1))) *
            compptr->h_samp_factor / dinfo->max_h_samp_factor;
    ph[i] = ((dinfo->output_height + (dinfo->max_v_samp_factor) - 1) & (~((dinfo->max_v_samp_factor) - 1))) *
            compptr->v_samp_factor / dinfo->max_v_samp_factor;
    if (iw[i] != pw[i] || ih != ph[i]) usetmpbuf = 1;
    th[i] = compptr->v_samp_factor * dctsize;
    tmpbufsize += iw[i] * th[i];
    if ((outbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * ph[i])) == ((void*)0))
      { snprintf(this->errStr, 200, "%s", "tjDecompressToYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    ptr = dstPlanes[i];
    for (row = 0; row < ph[i]; row++) {
      outbuf[i][row] = ptr;
      ptr += (strides && strides[i] != 0) ? strides[i] : pw[i];
    }
  }
  if (usetmpbuf) {
    if ((_tmpbuf = (JSAMPLE *)malloc(sizeof(JSAMPLE) * tmpbufsize)) == ((void*)0))
      { snprintf(this->errStr, 200, "%s", "tjDecompressToYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
    ptr = _tmpbuf;
    for (i = 0; i < dinfo->num_components; i++) {
      if ((tmpbuf[i] = (JSAMPROW *)malloc(sizeof(JSAMPROW) * th[i])) == ((void*)0))
        { snprintf(this->errStr, 200, "%s", "tjDecompressToYUVPlanes(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUVPlanes(): Memory allocation failure"); retval = -1; goto bailout; } };
      for (row = 0; row < th[i]; row++) {
        tmpbuf[i][row] = ptr;
        ptr += iw[i];
      }
    }
  }

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  if (flags & 256) dinfo->do_fancy_upsampling = 0;
  if (flags & 2048) dinfo->dct_method = JDCT_IFAST;
  dinfo->raw_data_out = 1;

  jpeg_start_decompress(dinfo);
  for (row = 0; row < (int)dinfo->output_height;
       row += dinfo->max_v_samp_factor * dinfo->min_DCT_scaled_size) {
    JSAMPARRAY yuvptr[10];
    int crow[10];

    for (i = 0; i < dinfo->num_components; i++) {
      jpeg_component_info *compptr = &dinfo->comp_info[i];

      if (jpegSubsamp == TJSAMP_420) {
# 1678 "/doner/libjpeg/libjpeg-beefb62/libjpeg-turbo/turbojpeg.c"
        compptr->DCT_scaled_size = dctsize;
        compptr->MCU_sample_width = tjMCUWidth[jpegSubsamp] *
          sf[sfi].num / sf[sfi].denom *
          compptr->v_samp_factor / dinfo->max_v_samp_factor;
        dinfo->idct->inverse_DCT[i] = dinfo->idct->inverse_DCT[0];
      }
      crow[i] = row * compptr->v_samp_factor / dinfo->max_v_samp_factor;
      if (usetmpbuf) yuvptr[i] = tmpbuf[i];
      else yuvptr[i] = &outbuf[i][crow[i]];
    }
    jpeg_read_raw_data(dinfo, yuvptr,
                       dinfo->max_v_samp_factor * dinfo->min_DCT_scaled_size);
    if (usetmpbuf) {
      int j;

      for (i = 0; i < dinfo->num_components; i++) {
        for (j = 0; j < ((th[i]) < (ph[i] - crow[i]) ? (th[i]) : (ph[i] - crow[i])); j++) {
          memcpy(outbuf[i][crow[i] + j], tmpbuf[i][j], pw[i]);
        }
      }
    }
  }
  jpeg_finish_decompress(dinfo);

bailout:
  if (dinfo->global_state > 200) jpeg_abort_decompress(dinfo);
  for (i = 0; i < 10; i++) {
    if (tmpbuf[i]) free(tmpbuf[i]);
    if (outbuf[i]) free(outbuf[i]);
  }
  if (_tmpbuf) free(_tmpbuf);
  if (this->jerr.warning) retval = -1;
  this->jerr.stopOnWarning = 0;
  return retval;
}

          int tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,
                                 unsigned long jpegSize, unsigned char *dstBuf,
                                 int width, int pad, int height, int flags)
{
  unsigned char *dstPlanes[3];
  int pw0, ph0, strides[3], retval = -1, jpegSubsamp = -1;
  int i, jpegwidth, jpegheight, scaledw, scaledh;

  tjinstance *this = (tjinstance *)handle; j_decompress_ptr dinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } dinfo = &this->dinfo; this->jerr.warning = 0; this->isInstanceError = 0;;
  this->jerr.stopOnWarning = (flags & 8192) ? 1 : 0;

  if (jpegBuf == ((void*)0) || jpegSize <= 0 || dstBuf == ((void*)0) || width < 0 ||
      pad < 1 || !(((pad) & (pad - 1)) == 0) || height < 0)
    { snprintf(this->errStr, 200, "%s", "tjDecompressToYUV2(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUV2(): Invalid argument"); retval = -1; goto bailout; } };

  if (_setjmp (this->jerr.setjmp_buffer)) {

    return -1;
  }

  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);
  jpeg_read_header(dinfo, 1);
  jpegSubsamp = getSubsamp(dinfo);
  if (jpegSubsamp < 0)
    { snprintf(this->errStr, 200, "%s", "tjDecompressToYUV2(): Could not determine subsampling type for JPEG image"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUV2(): Could not determine subsampling type for JPEG image"); retval = -1; goto bailout; } };

  jpegwidth = dinfo->image_width; jpegheight = dinfo->image_height;
  if (width == 0) width = jpegwidth;
  if (height == 0) height = jpegheight;

  for (i = 0; i < 16; i++) {
    scaledw = ((jpegwidth * sf[i].num + sf[i].denom - 1) / sf[i].denom);
    scaledh = ((jpegheight * sf[i].num + sf[i].denom - 1) / sf[i].denom);
    if (scaledw <= width && scaledh <= height)
      break;
  }
  if (i >= 16)
    { snprintf(this->errStr, 200, "%s", "tjDecompressToYUV2(): Could not scale down to desired image dimensions"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjDecompressToYUV2(): Could not scale down to desired image dimensions"); retval = -1; goto bailout; } };

  pw0 = tjPlaneWidth(0, width, jpegSubsamp);
  ph0 = tjPlaneHeight(0, height, jpegSubsamp);
  dstPlanes[0] = dstBuf;
  strides[0] = ((pw0 + (pad) - 1) & (~((pad) - 1)));
  if (jpegSubsamp == TJSAMP_GRAY) {
    strides[1] = strides[2] = 0;
    dstPlanes[1] = dstPlanes[2] = ((void*)0);
  } else {
    int pw1 = tjPlaneWidth(1, width, jpegSubsamp);
    int ph1 = tjPlaneHeight(1, height, jpegSubsamp);

    strides[1] = strides[2] = ((pw1 + (pad) - 1) & (~((pad) - 1)));
    dstPlanes[1] = dstPlanes[0] + strides[0] * ph0;
    dstPlanes[2] = dstPlanes[1] + strides[1] * ph1;
  }

  this->headerRead = 1;
  return tjDecompressToYUVPlanes(handle, jpegBuf, jpegSize, dstPlanes, width,
                                 strides, height, flags);

bailout:
  this->jerr.stopOnWarning = 0;
  return retval;
}

          int tjDecompressToYUV(tjhandle handle, unsigned char *jpegBuf,
                                unsigned long jpegSize, unsigned char *dstBuf,
                                int flags)
{
  return tjDecompressToYUV2(handle, jpegBuf, jpegSize, dstBuf, 0, 4, 0, flags);
}




          tjhandle tjInitTransform(void)
{
  tjinstance *this = ((void*)0);
  tjhandle handle = ((void*)0);

  if ((this = (tjinstance *)malloc(sizeof(tjinstance))) == ((void*)0)) {
    snprintf(errStr, 200,
             "tjInitTransform(): Memory allocation failure");
    return ((void*)0);
  }
  memset((void *)(this), 0, (size_t)(sizeof(tjinstance)));
  snprintf(this->errStr, 200, "No error");
  handle = _tjInitCompress(this);
  if (!handle) return ((void*)0);
  handle = _tjInitDecompress(this);
  return handle;
}


          int tjTransform(tjhandle handle, const unsigned char *jpegBuf,
                          unsigned long jpegSize, int n,
                          unsigned char **dstBufs, unsigned long *dstSizes,
                          tjtransform *t, int flags)
{
  jpeg_transform_info *xinfo = ((void*)0);
  jvirt_barray_ptr *srccoefs, *dstcoefs;
  int retval = 0, i, jpegSubsamp, saveMarkers = 0;

  tjinstance *this = (tjinstance *)handle; j_compress_ptr cinfo = ((void*)0); j_decompress_ptr dinfo = ((void*)0); if (!this) { snprintf(errStr, 200, "Invalid handle"); return -1; } cinfo = &this->cinfo; dinfo = &this->dinfo; this->jerr.warning = 0; this->isInstanceError = 0;;
  this->jerr.stopOnWarning = (flags & 8192) ? 1 : 0;
  if ((this->init & COMPRESS) == 0 || (this->init & DECOMPRESS) == 0)
    { snprintf(this->errStr, 200, "%s", "tjTransform(): Instance has not been initialized for transformation"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjTransform(): Instance has not been initialized for transformation"); retval = -1; goto bailout; } };

  if (jpegBuf == ((void*)0) || jpegSize <= 0 || n < 1 || dstBufs == ((void*)0) ||
      dstSizes == ((void*)0) || t == ((void*)0) || flags < 0)
    { snprintf(this->errStr, 200, "%s", "tjTransform(): Invalid argument"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjTransform(): Invalid argument"); retval = -1; goto bailout; } };


  if (flags & 8) putenv("JSIMD_FORCEMMX=1");
  else if (flags & 16) putenv("JSIMD_FORCESSE=1");
  else if (flags & 32) putenv("JSIMD_FORCESSE2=1");


  if ((xinfo =
       (jpeg_transform_info *)malloc(sizeof(jpeg_transform_info) * n)) == ((void*)0))
    { snprintf(this->errStr, 200, "%s", "tjTransform(): Memory allocation failure"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjTransform(): Memory allocation failure"); retval = -1; goto bailout; } };
  memset((void *)(xinfo), 0, (size_t)(sizeof(jpeg_transform_info) * n));

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);

  for (i = 0; i < n; i++) {
    xinfo[i].transform = xformtypes[t[i].op];
    xinfo[i].perfect = (t[i].options & 1) ? 1 : 0;
    xinfo[i].trim = (t[i].options & 2) ? 1 : 0;
    xinfo[i].force_grayscale = (t[i].options & 8) ? 1 : 0;
    xinfo[i].crop = (t[i].options & 4) ? 1 : 0;
    if (n != 1 && t[i].op == TJXOP_HFLIP) xinfo[i].slow_hflip = 1;
    else xinfo[i].slow_hflip = 0;

    if (xinfo[i].crop) {
      xinfo[i].crop_xoffset = t[i].r.x; xinfo[i].crop_xoffset_set = JCROP_POS;
      xinfo[i].crop_yoffset = t[i].r.y; xinfo[i].crop_yoffset_set = JCROP_POS;
      if (t[i].r.w != 0) {
        xinfo[i].crop_width = t[i].r.w; xinfo[i].crop_width_set = JCROP_POS;
      } else
        xinfo[i].crop_width = JCROP_UNSET;
      if (t[i].r.h != 0) {
        xinfo[i].crop_height = t[i].r.h; xinfo[i].crop_height_set = JCROP_POS;
      } else
        xinfo[i].crop_height = JCROP_UNSET;
    }
    if (!(t[i].options & 64)) saveMarkers = 1;
  }

  jcopy_markers_setup(dinfo, saveMarkers ? JCOPYOPT_ALL : JCOPYOPT_NONE);
  jpeg_read_header(dinfo, 1);
  jpegSubsamp = getSubsamp(dinfo);
  if (jpegSubsamp < 0)
    { snprintf(this->errStr, 200, "%s", "tjTransform(): Could not determine subsampling type for JPEG image"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjTransform(): Could not determine subsampling type for JPEG image"); retval = -1; goto bailout; } };

  for (i = 0; i < n; i++) {
    if (!jtransform_request_workspace(dinfo, &xinfo[i]))
      { snprintf(this->errStr, 200, "%s", "tjTransform(): Transform is not perfect"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjTransform(): Transform is not perfect"); retval = -1; goto bailout; } };

    if (xinfo[i].crop) {
      if ((t[i].r.x % xinfo[i].iMCU_sample_width) != 0 ||
          (t[i].r.y % xinfo[i].iMCU_sample_height) != 0) {
        snprintf(errStr, 200,
                 "To crop this JPEG image, x must be a multiple of %d\n"
                 "and y must be a multiple of %d.\n",
                 xinfo[i].iMCU_sample_width, xinfo[i].iMCU_sample_height);
        retval = -1; goto bailout;
      }
    }
  }

  srccoefs = jpeg_read_coefficients(dinfo);

  for (i = 0; i < n; i++) {
    int w, h, alloc = 1;

    if (!xinfo[i].crop) {
      w = dinfo->image_width; h = dinfo->image_height;
    } else {
      w = xinfo[i].crop_width; h = xinfo[i].crop_height;
    }
    if (flags & 1024) {
      alloc = 0; dstSizes[i] = tjBufSize(w, h, jpegSubsamp);
    }
    if (!(t[i].options & 16))
      jpeg_mem_dest_tj(cinfo, &dstBufs[i], &dstSizes[i], alloc);
    jpeg_copy_critical_parameters(dinfo, cinfo);
    dstcoefs = jtransform_adjust_parameters(dinfo, cinfo, srccoefs, &xinfo[i]);
    if (flags & 16384 || t[i].options & 32)
      jpeg_simple_progression(cinfo);
    if (!(t[i].options & 16)) {
      jpeg_write_coefficients(cinfo, dstcoefs);
      jcopy_markers_execute(dinfo, cinfo, t[i].options & 64 ?
                                          JCOPYOPT_NONE : JCOPYOPT_ALL);
    } else
      jinit_c_master_control(cinfo, 1);
    jtransform_execute_transform(dinfo, cinfo, srccoefs, &xinfo[i]);
    if (t[i].customFilter) {
      int ci, y;
      JDIMENSION by;

      for (ci = 0; ci < cinfo->num_components; ci++) {
        jpeg_component_info *compptr = &cinfo->comp_info[ci];
        tjregion arrayRegion = {
          0, 0, compptr->width_in_blocks * 8, 8
        };
        tjregion planeRegion = {
          0, 0, compptr->width_in_blocks * 8,
          compptr->height_in_blocks * 8
        };

        for (by = 0; by < compptr->height_in_blocks;
             by += compptr->v_samp_factor) {
          JBLOCKARRAY barray = (dinfo->mem->access_virt_barray)
            ((j_common_ptr)dinfo, dstcoefs[ci], by, compptr->v_samp_factor,
             1);

          for (y = 0; y < compptr->v_samp_factor; y++) {
            if (t[i].customFilter(barray[y][0], arrayRegion, planeRegion, ci,
                                  i, &t[i]) == -1)
              { snprintf(this->errStr, 200, "%s", "tjTransform(): Error in custom filter"); this->isInstanceError = 1; { snprintf(errStr, 200, "%s", "tjTransform(): Error in custom filter"); retval = -1; goto bailout; } };
            arrayRegion.y += 8;
          }
        }
      }
    }
    if (!(t[i].options & 16)) jpeg_finish_compress(cinfo);
  }

  jpeg_finish_decompress(dinfo);

bailout:
  if (cinfo->global_state > 100) jpeg_abort_compress(cinfo);
  if (dinfo->global_state > 200) jpeg_abort_decompress(dinfo);
  if (xinfo) free(xinfo);
  if (this->jerr.warning) retval = -1;
  this->jerr.stopOnWarning = 0;
  return retval;
}


          unsigned char *tjLoadImage(const char *filename, int *width,
                                     int align, int *height, int *pixelFormat,
                                     int flags)
{
  int retval = 0, tempc;
  size_t pitch;
  tjhandle handle = ((void*)0);
  tjinstance *this;
  j_compress_ptr cinfo = ((void*)0);
  cjpeg_source_ptr src;
  unsigned char *dstBuf = ((void*)0);
  FILE *file = ((void*)0);
  boolean invert;

  if (!filename || !width || align < 1 || !height || !pixelFormat ||
      *pixelFormat < TJPF_UNKNOWN || *pixelFormat >= 12)
    { snprintf(errStr, 200, "%s", "tjLoadImage(): Invalid argument"); retval = -1; goto bailout; };
  if ((align & (align - 1)) != 0)
    { snprintf(errStr, 200, "%s", "tjLoadImage(): Alignment must be a power of 2"); retval = -1; goto bailout; };

  if ((handle = tjInitCompress()) == ((void*)0)) return ((void*)0);
  this = (tjinstance *)handle;
  cinfo = &this->cinfo;

  if ((file = fopen(filename, "rb")) == ((void*)0))
    { snprintf(errStr, 200, "%s\n%s", "tjLoadImage(): Cannot open input file", strerror((*__errno_location ()))); retval = -1; goto bailout; };

  if ((tempc = getc(file)) < 0 || ungetc(tempc, file) == (-1))
    { snprintf(errStr, 200, "%s\n%s", "tjLoadImage(): Could not read input file", strerror((*__errno_location ()))); retval = -1; goto bailout; }
  else if (tempc == (-1))
    { snprintf(errStr, 200, "%s", "tjLoadImage(): Input file contains no data"); retval = -1; goto bailout; };

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  if (*pixelFormat == TJPF_UNKNOWN) cinfo->in_color_space = JCS_UNKNOWN;
  else cinfo->in_color_space = pf2cs[*pixelFormat];
  if (tempc == 'B') {
    if ((src = jinit_read_bmp(cinfo, 0)) == ((void*)0))
      { snprintf(errStr, 200, "%s", "tjLoadImage(): Could not initialize bitmap loader"); retval = -1; goto bailout; };
    invert = (flags & 2) == 0;
  } else if (tempc == 'P') {
    if ((src = jinit_read_ppm(cinfo)) == ((void*)0))
      { snprintf(errStr, 200, "%s", "tjLoadImage(): Could not initialize bitmap loader"); retval = -1; goto bailout; };
    invert = (flags & 2) != 0;
  } else
    { snprintf(errStr, 200, "%s", "tjLoadImage(): Unsupported file type"); retval = -1; goto bailout; };

  src->input_file = file;
  (*src->start_input) (cinfo, src);
  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr)cinfo);

  *width = cinfo->image_width; *height = cinfo->image_height;
  *pixelFormat = cs2pf[cinfo->in_color_space];

  pitch = (((*width) * tjPixelSize[*pixelFormat] + (align) - 1) & (~((align) - 1)));
  if ((unsigned long long)pitch * (unsigned long long)(*height) >
      (unsigned long long)((size_t)-1) ||
      (dstBuf = (unsigned char *)malloc(pitch * (*height))) == ((void*)0))
    { snprintf(errStr, 200, "%s", "tjLoadImage(): Memory allocation failure"); retval = -1; goto bailout; };

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  while (cinfo->next_scanline < cinfo->image_height) {
    int i, nlines = (*src->get_pixel_rows) (cinfo, src);

    for (i = 0; i < nlines; i++) {
      unsigned char *dstptr;
      int row;

      row = cinfo->next_scanline + i;
      if (invert) dstptr = &dstBuf[((*height) - row - 1) * pitch];
      else dstptr = &dstBuf[row * pitch];
      memcpy(dstptr, src->buffer[i], (*width) * tjPixelSize[*pixelFormat]);
    }
    cinfo->next_scanline += nlines;
  }

  (*src->finish_input) (cinfo, src);

bailout:
  if (handle) tjDestroy(handle);
  if (file) fclose(file);
  if (retval < 0 && dstBuf) { free(dstBuf); dstBuf = ((void*)0); }
  return dstBuf;
}


          int tjSaveImage(const char *filename, unsigned char *buffer,
                          int width, int pitch, int height, int pixelFormat,
                          int flags)
{
  int retval = 0;
  tjhandle handle = ((void*)0);
  tjinstance *this;
  j_decompress_ptr dinfo = ((void*)0);
  djpeg_dest_ptr dst;
  FILE *file = ((void*)0);
  char *ptr = ((void*)0);
  boolean invert;

  if (!filename || !buffer || width < 1 || pitch < 0 || height < 1 ||
      pixelFormat < 0 || pixelFormat >= 12)
    { snprintf(errStr, 200, "%s", "tjSaveImage(): Invalid argument"); retval = -1; goto bailout; };

  if ((handle = tjInitDecompress()) == ((void*)0))
    return -1;
  this = (tjinstance *)handle;
  dinfo = &this->dinfo;

  if ((file = fopen(filename, "wb")) == ((void*)0))
    { snprintf(errStr, 200, "%s\n%s", "tjSaveImage(): Cannot open output file", strerror((*__errno_location ()))); retval = -1; goto bailout; };

  if (_setjmp (this->jerr.setjmp_buffer)) {

    retval = -1; goto bailout;
  }

  this->dinfo.out_color_space = pf2cs[pixelFormat];
  dinfo->image_width = width; dinfo->image_height = height;
  dinfo->global_state = 202;
  dinfo->scale_num = dinfo->scale_denom = 1;

  ptr = strrchr(filename, '.');
  if (ptr && !strcasecmp(ptr, ".bmp")) {
    if ((dst = jinit_write_bmp(dinfo, 0, 0)) == ((void*)0))
      { snprintf(errStr, 200, "%s", "tjSaveImage(): Could not initialize bitmap writer"); retval = -1; goto bailout; };
    invert = (flags & 2) == 0;
  } else {
    if ((dst = jinit_write_ppm(dinfo)) == ((void*)0))
      { snprintf(errStr, 200, "%s", "tjSaveImage(): Could not initialize PPM writer"); retval = -1; goto bailout; };
    invert = (flags & 2) != 0;
  }

  dst->output_file = file;
  (*dst->start_output) (dinfo, dst);
  (*dinfo->mem->realize_virt_arrays) ((j_common_ptr)dinfo);

  if (pitch == 0) pitch = width * tjPixelSize[pixelFormat];

  while (dinfo->output_scanline < dinfo->output_height) {
    unsigned char *rowptr;

    if (invert)
      rowptr = &buffer[(height - dinfo->output_scanline - 1) * pitch];
    else
      rowptr = &buffer[dinfo->output_scanline * pitch];
    memcpy(dst->buffer[0], rowptr, width * tjPixelSize[pixelFormat]);
    (*dst->put_pixel_rows) (dinfo, dst, 1);
    dinfo->output_scanline++;
  }

  (*dst->finish_output) (dinfo, dst);

bailout:
  if (handle) tjDestroy(handle);
  if (file) fclose(file);
  return retval;
}
