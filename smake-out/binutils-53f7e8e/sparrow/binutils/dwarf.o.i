# 1 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
# 1 "/doner/binutils/binutils-53f7e8e/binutils//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
# 21 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
# 1 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 1
# 23 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h"
# 1 "./../include/alloca-conf.h" 1
# 16 "./../include/alloca-conf.h"
# 1 "./config.h" 1
# 17 "./../include/alloca-conf.h" 2






# 1 "/usr/include/alloca.h" 1 3 4
# 21 "/usr/include/alloca.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 22 "/usr/include/alloca.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 24 "./../include/alloca-conf.h" 2
# 24 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2
# 1 "./../include/ansidecl.h" 1
# 25 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 873 "/usr/include/stdio.h" 3 4

# 26 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 27 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2

# 1 "../bfd/bfdver.h" 1
# 29 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2

# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 31 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2




# 1 "./../include/fopen-same.h" 1
# 36 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4




# 39 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2





# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 870 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 991 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1003 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1014 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1024 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1035 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1056 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1079 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1089 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1107 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1124 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1161 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;
# 1170 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));
# 1171 "/usr/include/unistd.h" 2 3 4


# 45 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2



# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 104 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 115 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 154 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 266 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 360 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 499 "/usr/include/string.h" 3 4

# 49 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2
# 64 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));
# 574 "/usr/include/stdlib.h" 3 4
extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1014 "/usr/include/stdlib.h" 2 3 4
# 1023 "/usr/include/stdlib.h" 3 4

# 65 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2



# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 353 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 392 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 447 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 79 "/usr/include/fcntl.h" 2 3 4
# 148 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 168 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 178 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 293 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 304 "/usr/include/fcntl.h" 3 4

# 69 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2







# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));


# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4



int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 5)));


# 39 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 447 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 534 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 77 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2


# 1 "./../include/binary-io.h" 1
# 80 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2
# 147 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h"
# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4


# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) __attribute__ ((__nothrow__ , __leaf__));
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));



extern void freelocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));






extern locale_t uselocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));








# 148 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2



# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4





extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/libintl.h" 3 4

# 152 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2
# 173 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 174 "/doner/binutils/binutils-53f7e8e/binutils/sysdep.h" 2
# 22 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2
# 1 "./../include/libiberty.h" 1
# 42 "./../include/libiberty.h"
# 1 "./../include/ansidecl.h" 1
# 43 "./../include/libiberty.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;
# 46 "./../include/libiberty.h" 2
# 55 "./../include/libiberty.h"

# 55 "./../include/libiberty.h"
extern void unlock_stream (FILE *);





extern void unlock_std_streams (void);





extern FILE *fopen_unlocked (const char *, const char *);
extern FILE *fdopen_unlocked (int, const char *);
extern FILE *freopen_unlocked (const char *, const char *, FILE *);




extern char **buildargv (const char *) __attribute__ ((__malloc__));



extern void freeargv (char **);




extern char **dupargv (char * const *) __attribute__ ((__malloc__));



extern void expandargv (int *, char ***);



extern int writeargv (char * const *, FILE *);



extern int countargv (char * const *);
# 112 "./../include/libiberty.h"
extern char *basename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));
# 123 "./../include/libiberty.h"
extern const char *lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));




extern const char *dos_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));





extern const char *unix_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));



extern char *lrealpath (const char *);





extern char *concat (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));
# 153 "./../include/libiberty.h"
extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));





extern unsigned long concat_length (const char *, ...) __attribute__ ((__sentinel__));






extern char *concat_copy (char *, const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__sentinel__));






extern char *concat_copy2 (const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));



extern char *libiberty_concat_ptr;
# 189 "./../include/libiberty.h"
extern int fdmatch (int fd1, int fd2);
# 201 "./../include/libiberty.h"
extern char * getpwd (void);
# 214 "./../include/libiberty.h"
extern long get_run_time (void);




extern char *make_relative_prefix (const char *, const char *,
                                   const char *) __attribute__ ((__malloc__));





extern char *make_relative_prefix_ignore_links (const char *, const char *,
      const char *) __attribute__ ((__malloc__));




extern const char *choose_tmpdir (void) __attribute__ ((__returns_nonnull__));



extern char *choose_temp_base (void) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *make_temp_file (const char *) __attribute__ ((__malloc__));



extern int unlink_if_ordinary (const char *);



extern const char *spaces (int count);




extern int errno_max (void);




extern const char *strerrno (int);



extern int strtoerrno (const char *);



extern char *xstrerror (int) __attribute__ ((__returns_nonnull__));




extern int signo_max (void);
# 283 "./../include/libiberty.h"
extern const char *strsigno (int);



extern int strtosigno (const char *);



extern int xatexit (void (*fn) (void));



extern void xexit (int status) __attribute__ ((__noreturn__));



extern void xmalloc_set_program_name (const char *);


extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));





extern void *xmalloc (size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));





extern void *xrealloc (void *, size_t) __attribute__ ((__returns_nonnull__));




extern void *xcalloc (size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *xstrdup (const char *) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern void *xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));


extern double physmem_total (void);
extern double physmem_available (void);


extern unsigned int xcrc32 (const unsigned char *, int, unsigned int);
# 382 "./../include/libiberty.h"
extern const unsigned char _hex_value[256];
extern void hex_init (void);
# 419 "./../include/libiberty.h"
extern struct pex_obj *pex_init (int flags, const char *pname,
     const char *tempbase) __attribute__ ((__returns_nonnull__));
# 519 "./../include/libiberty.h"
extern const char *pex_run (struct pex_obj *obj, int flags,
       const char *executable, char * const *argv,
       const char *outname, const char *errname,
       int *err);
# 534 "./../include/libiberty.h"
extern const char *pex_run_in_environment (struct pex_obj *obj, int flags,
                      const char *executable,
                                           char * const *argv,
                                           char * const *env,
                              const char *outname,
        const char *errname, int *err);





extern FILE *pex_input_file (struct pex_obj *obj, int flags,
                             const char *in_name);






extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);







extern FILE *pex_read_output (struct pex_obj *, int binary);







extern FILE *pex_read_err (struct pex_obj *, int binary);





extern int pex_get_status (struct pex_obj *, int count, int *vector);






struct pex_time
{
  unsigned long user_seconds;
  unsigned long user_microseconds;
  unsigned long system_seconds;
  unsigned long system_microseconds;
};

extern int pex_get_times (struct pex_obj *, int count,
     struct pex_time *vector);




extern void pex_free (struct pex_obj *);
# 609 "./../include/libiberty.h"
extern const char *pex_one (int flags, const char *executable,
       char * const *argv, const char *pname,
       const char *outname, const char *errname,
       int *status, int *err);
# 628 "./../include/libiberty.h"
extern int pexecute (const char *, char * const *, const char *,
                     const char *, char **, char **, int);



extern int pwait (int, int *, int);
# 645 "./../include/libiberty.h"
extern char *xasprintf (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));





extern int vasprintf (char **, const char *, va_list) __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__nonnull__ (2)));





extern char *xvasprintf (const char *, va_list) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));
# 706 "./../include/libiberty.h"
extern void setproctitle (const char *name, ...);


extern void stack_limit_increase (unsigned long);
# 719 "./../include/libiberty.h"
extern void *C_alloca (size_t) __attribute__ ((__malloc__));
# 23 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2
# 1 "../bfd/bfd.h" 1
# 43 "../bfd/bfd.h"
# 1 "./../include/symcat.h" 1
# 44 "../bfd/bfd.h" 2
# 97 "../bfd/bfd.h"
typedef long bfd_int64_t;
typedef unsigned long bfd_uint64_t;
# 115 "../bfd/bfd.h"
typedef unsigned long bfd_hostptr_t;


typedef struct bfd bfd;
# 129 "../bfd/bfd.h"
typedef int bfd_boolean;
# 141 "../bfd/bfd.h"
typedef unsigned long bfd_vma;
typedef long bfd_signed_vma;
typedef unsigned long bfd_size_type;
typedef unsigned long symvalue;
# 196 "../bfd/bfd.h"
typedef long file_ptr;
typedef unsigned long ufile_ptr;

extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);




typedef unsigned int flagword;
typedef unsigned char bfd_byte;



typedef enum bfd_format
{
  bfd_unknown = 0,
  bfd_object,
  bfd_archive,
  bfd_core,
  bfd_type_end
}
bfd_format;




typedef unsigned long symindex;


typedef const struct reloc_howto_struct reloc_howto_type;
# 248 "../bfd/bfd.h"
typedef struct carsym
{
  char *name;
  file_ptr file_offset;
}
carsym;



struct orl
{
  char **name;
  union
  {
    file_ptr pos;
    bfd *abfd;
  } u;
  int namidx;
};


typedef struct lineno_cache_entry
{
  unsigned int line_number;
  union
  {
    struct bfd_symbol *sym;
    bfd_vma offset;
  } u;
}
alent;


typedef struct bfd_section *sec_ptr;
# 326 "../bfd/bfd.h"
typedef enum bfd_print_symbol
{
  bfd_print_symbol_name,
  bfd_print_symbol_more,
  bfd_print_symbol_all
} bfd_print_symbol_type;



typedef struct _symbol_info
{
  symvalue value;
  char type;
  const char *name;
  unsigned char stab_type;
  char stab_other;
  short stab_desc;
  const char *stab_name;
} symbol_info;



extern const char *bfd_get_stab_name (int);






struct bfd_hash_entry
{

  struct bfd_hash_entry *next;

  const char *string;


  unsigned long hash;
};



struct bfd_hash_table
{

  struct bfd_hash_entry **table;







  struct bfd_hash_entry *(*newfunc)
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


  void *memory;

  unsigned int size;

  unsigned int count;

  unsigned int entsize;

  unsigned int frozen:1;
};


extern bfd_boolean bfd_hash_table_init
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int);


extern bfd_boolean bfd_hash_table_init_n
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int, unsigned int);


extern void bfd_hash_table_free
  (struct bfd_hash_table *);





extern struct bfd_hash_entry *bfd_hash_lookup
  (struct bfd_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy);


extern struct bfd_hash_entry *bfd_hash_insert
  (struct bfd_hash_table *, const char *, unsigned long);


extern void bfd_hash_rename
  (struct bfd_hash_table *, const char *, struct bfd_hash_entry *);


extern void bfd_hash_replace
  (struct bfd_hash_table *, struct bfd_hash_entry *old,
   struct bfd_hash_entry *nw);


extern struct bfd_hash_entry *bfd_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


extern void *bfd_hash_allocate
  (struct bfd_hash_table *, unsigned int);




extern void bfd_hash_traverse
  (struct bfd_hash_table *,
   bfd_boolean (*) (struct bfd_hash_entry *, void *),
   void *info);




extern unsigned long bfd_hash_set_default_size (unsigned long);



enum compressed_debug_section_type
{
  COMPRESS_DEBUG_NONE = 0,
  COMPRESS_DEBUG = 1 << 0,
  COMPRESS_DEBUG_GNU_ZLIB = COMPRESS_DEBUG | 1 << 1,
  COMPRESS_DEBUG_GABI_ZLIB = COMPRESS_DEBUG | 1 << 2
};




struct stab_info
{

  struct bfd_strtab_hash *strings;

  struct bfd_hash_table includes;

  struct bfd_section *stabstr;
};
# 486 "../bfd/bfd.h"
extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
extern int bfd_seek (bfd *, file_ptr, int);
extern file_ptr bfd_tell (bfd *);
extern int bfd_flush (bfd *);
extern int bfd_stat (bfd *, struct stat *);
# 509 "../bfd/bfd.h"
extern void warn_deprecated (const char *, const char *, int, const char *);
# 545 "../bfd/bfd.h"
extern bfd_boolean bfd_cache_close
  (bfd *abfd);


extern bfd_boolean bfd_cache_close_all (void);

extern bfd_boolean bfd_record_phdr
  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);



bfd_uint64_t bfd_getb64 (const void *);
bfd_uint64_t bfd_getl64 (const void *);
bfd_int64_t bfd_getb_signed_64 (const void *);
bfd_int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (bfd_uint64_t, void *);
void bfd_putl64 (bfd_uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);



bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);


struct ecoff_debug_info;
struct ecoff_debug_swap;
struct ecoff_extr;
struct bfd_symbol;
struct bfd_link_info;
struct bfd_link_hash_entry;
struct bfd_section_already_linked;
struct bfd_elf_version_tree;


extern bfd_boolean bfd_section_already_linked_table_init (void);
extern void bfd_section_already_linked_table_free (void);
extern bfd_boolean _bfd_handle_already_linked
  (struct bfd_section *, struct bfd_section_already_linked *,
   struct bfd_link_info *);



extern bfd_vma bfd_ecoff_get_gp_value
  (bfd * abfd);
extern bfd_boolean bfd_ecoff_set_gp_value
  (bfd *abfd, bfd_vma gp_value);
extern bfd_boolean bfd_ecoff_set_regmasks
  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
   unsigned long *cprmask);
extern void *bfd_ecoff_debug_init
  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern void bfd_ecoff_debug_free
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct ecoff_debug_info *input_debug,
   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate_other
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_externals
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
   void (*set_index) (struct bfd_symbol *, bfd_size_type));
extern bfd_boolean bfd_ecoff_debug_one_external
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, const char *name,
   struct ecoff_extr *esym);
extern bfd_size_type bfd_ecoff_debug_size
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap);
extern bfd_boolean bfd_ecoff_write_debug
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, file_ptr where);
extern bfd_boolean bfd_ecoff_write_accumulated_debug
  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap,
   struct bfd_link_info *info, file_ptr where);



struct bfd_link_needed_list
{
  struct bfd_link_needed_list *next;
  bfd *by;
  const char *name;
};

enum dynamic_lib_link_class {
  DYN_NORMAL = 0,
  DYN_AS_NEEDED = 1,
  DYN_DT_NEEDED = 2,
  DYN_NO_ADD_NEEDED = 4,
  DYN_NO_NEEDED = 8
};

enum notice_asneeded_action {
  notice_as_needed,
  notice_not_needed,
  notice_needed
};

extern bfd_boolean bfd_elf_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
   bfd_boolean);
extern struct bfd_link_needed_list *bfd_elf_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_get_bfd_needed_list
  (bfd *, struct bfd_link_needed_list **);
extern bfd_boolean bfd_elf_stack_segment_size (bfd *, struct bfd_link_info *,
            const char *, bfd_vma);
extern bfd_boolean bfd_elf_size_dynamic_sections
  (bfd *, const char *, const char *, const char *, const char *, const char *,
   const char * const *, struct bfd_link_info *, struct bfd_section **);
extern bfd_boolean bfd_elf_size_dynsym_hash_dynstr
  (bfd *, struct bfd_link_info *);
extern void bfd_elf_set_dt_needed_name
  (bfd *, const char *);
extern const char *bfd_elf_get_dt_soname
  (bfd *);
extern void bfd_elf_set_dyn_lib_class
  (bfd *, enum dynamic_lib_link_class);
extern int bfd_elf_get_dyn_lib_class
  (bfd *);
extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
  (bfd *, struct bfd_link_info *);
extern int bfd_elf_discard_info
  (bfd *, struct bfd_link_info *);
extern unsigned int _bfd_elf_default_action_discarded
  (struct bfd_section *);




extern long bfd_get_elf_phdr_upper_bound
  (bfd *abfd);
# 707 "../bfd/bfd.h"
extern int bfd_get_elf_phdrs
  (bfd *abfd, void *phdrs);
# 724 "../bfd/bfd.h"
extern bfd *bfd_elf_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr,
         bfd_size_type len));

extern struct bfd_section *_bfd_elf_tls_setup
  (bfd *, struct bfd_link_info *);

extern struct bfd_section *
_bfd_nearby_section (bfd *, struct bfd_section *, bfd_vma);

extern void _bfd_fix_excluded_sec_syms
  (bfd *, struct bfd_link_info *);

extern unsigned bfd_m68k_mach_to_features (int);

extern int bfd_m68k_features_to_mach (unsigned);

extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);

extern void bfd_elf_m68k_set_target_options (struct bfd_link_info *, int);

extern bfd_boolean bfd_bfin_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);

extern bfd_boolean bfd_cr16_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);



extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sunos_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_sunos_size_dynamic_sections
  (bfd *, struct bfd_link_info *, struct bfd_section **,
   struct bfd_section **, struct bfd_section **);



extern bfd_boolean bfd_i386linux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_m68klinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sparclinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);



struct _bfd_window_internal;
typedef struct _bfd_window_internal bfd_window_internal;

typedef struct _bfd_window
{

  void *data;
  bfd_size_type size;






  struct _bfd_window_internal *i;
}
bfd_window;

extern void bfd_init_window
  (bfd_window *);
extern void bfd_free_window
  (bfd_window *);
extern bfd_boolean bfd_get_file_window
  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);



extern bfd_boolean bfd_xcoff_split_import_path
  (bfd *, const char *, const char **, const char **);
extern bfd_boolean bfd_xcoff_set_archive_import_path
  (struct bfd_link_info *, bfd *, const char *);
extern bfd_boolean bfd_xcoff_link_record_set
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
extern bfd_boolean bfd_xcoff_import_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
   const char *, const char *, const char *, unsigned int);
extern bfd_boolean bfd_xcoff_export_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
extern bfd_boolean bfd_xcoff_link_count_reloc
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_size_dynamic_sections
  (bfd *, struct bfd_link_info *, const char *, const char *,
   unsigned long, unsigned long, unsigned long, bfd_boolean,
   int, bfd_boolean, unsigned int, struct bfd_section **, bfd_boolean);
extern bfd_boolean bfd_xcoff_link_generate_rtinit
  (bfd *, const char *, const char *, bfd_boolean);


extern bfd_boolean bfd_xcoff_ar_archive_set_magic
  (bfd *, char *);




struct internal_syment;
union internal_auxent;


extern bfd_boolean bfd_coff_set_symbol_class
  (bfd *, struct bfd_symbol *, unsigned int);

extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);


typedef enum
{
  BFD_ARM_VFP11_FIX_DEFAULT,
  BFD_ARM_VFP11_FIX_NONE,
  BFD_ARM_VFP11_FIX_SCALAR,
  BFD_ARM_VFP11_FIX_VECTOR
} bfd_arm_vfp11_fix;

extern void bfd_elf32_arm_init_maps
  (bfd *);

extern void bfd_elf32_arm_set_vfp11_fix
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_set_cortex_a8_fix
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_vfp11_erratum_scan
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_vfp11_fix_veneer_locations
  (bfd *, struct bfd_link_info *);


typedef enum
{
  BFD_ARM_STM32L4XX_FIX_NONE,
  BFD_ARM_STM32L4XX_FIX_DEFAULT,
  BFD_ARM_STM32L4XX_FIX_ALL
} bfd_arm_stm32l4xx_fix;

extern void bfd_elf32_arm_set_stm32l4xx_fix
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_stm32l4xx_erratum_scan
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_stm32l4xx_fix_veneer_locations
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_pe_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_process_before_allocation
  (bfd *, struct bfd_link_info *);

struct elf32_arm_params {
  char *thumb_entry_symbol;
  int byteswap_code;
  int target1_is_rel;
  char * target2_type;
  int fix_v4bx;
  int use_blx;
  bfd_arm_vfp11_fix vfp11_denorm_fix;
  bfd_arm_stm32l4xx_fix stm32l4xx_fix;
  int no_enum_size_warning;
  int no_wchar_size_warning;
  int pic_veneer;
  int fix_cortex_a8;
  int fix_arm1176;
  int merge_exidx_entries;
  int cmse_implib;
  bfd *in_implib_bfd;
};

void bfd_elf32_arm_set_target_params
  (bfd *, struct bfd_link_info *, struct elf32_arm_params *);

extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_keep_private_stub_output_sections
  (struct bfd_link_info *);







extern bfd_boolean bfd_is_arm_special_symbol_name
  (const char *, int);

extern void bfd_elf32_arm_set_byteswap_code
  (struct bfd_link_info *, int);

extern void bfd_elf32_arm_use_long_plt (void);


extern bfd_boolean bfd_arm_merge_machines
  (bfd *, bfd *);

extern bfd_boolean bfd_arm_update_notes
  (bfd *, const char *);

extern unsigned int bfd_arm_get_mach_from_notes
  (bfd *, const char *);


extern int elf32_arm_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf32_arm_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf32_arm_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *,
        struct bfd_section *, unsigned int),
   void (*) (void));
extern bfd_boolean elf32_arm_build_stubs
  (struct bfd_link_info *);


extern bfd_boolean elf32_arm_fix_exidx_coverage
(struct bfd_section **, unsigned int, struct bfd_link_info *, bfd_boolean);


extern bfd_boolean elf32_tic6x_fix_exidx_coverage
(struct bfd_section **, unsigned int, struct bfd_link_info *, bfd_boolean);

extern void bfd_elf64_aarch64_init_maps
  (bfd *);

extern void bfd_elf32_aarch64_init_maps
  (bfd *);

extern void bfd_elf64_aarch64_set_options
  (bfd *, struct bfd_link_info *, int, int, int, int, int, int);

extern void bfd_elf32_aarch64_set_options
  (bfd *, struct bfd_link_info *, int, int, int, int, int, int);






extern bfd_boolean bfd_is_aarch64_special_symbol_name
  (const char * name, int type);


extern int elf64_aarch64_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf64_aarch64_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf64_aarch64_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *),
   void (*) (void));
extern bfd_boolean elf64_aarch64_build_stubs
  (struct bfd_link_info *);

extern int elf32_aarch64_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf32_aarch64_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf32_aarch64_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *),
   void (*) (void));
extern bfd_boolean elf32_aarch64_build_stubs
  (struct bfd_link_info *);



extern void bfd_ticoff_set_section_load_page
  (struct bfd_section *, int);

extern int bfd_ticoff_get_section_load_page
  (struct bfd_section *);


extern bfd_vma bfd_h8300_pad_address
  (bfd *, bfd_vma);


extern void bfd_elf32_ia64_after_parse
  (int);

extern void bfd_elf64_ia64_after_parse
  (int);


extern bfd_boolean v850_elf_create_sections
  (struct bfd_link_info *);

extern bfd_boolean v850_elf_set_note
  (bfd *, unsigned int, unsigned int);


struct elf_internal_abiflags_v0;
extern struct elf_internal_abiflags_v0 *bfd_mips_elf_get_abiflags (bfd *);

void bfd_init (void);



extern unsigned int bfd_use_reserved_id;
bfd *bfd_fopen (const char *filename, const char *target,
    const char *mode, int fd);

bfd *bfd_openr (const char *filename, const char *target);

bfd *bfd_fdopenr (const char *filename, const char *target, int fd);

bfd *bfd_openstreamr (const char * filename, const char * target, void * stream);

bfd *bfd_openr_iovec (const char *filename, const char *target,
    void *(*open_func) (struct bfd *nbfd,
    void *open_closure),
    void *open_closure,
    file_ptr (*pread_func) (struct bfd *nbfd,
    void *stream,
    void *buf,
    file_ptr nbytes,
    file_ptr offset),
    int (*close_func) (struct bfd *nbfd,
    void *stream),
    int (*stat_func) (struct bfd *abfd,
    void *stream,
    struct stat *sb));

bfd *bfd_openw (const char *filename, const char *target);

bfd_boolean bfd_close (bfd *abfd);

bfd_boolean bfd_close_all_done (bfd *);

bfd *bfd_create (const char *filename, bfd *templ);

bfd_boolean bfd_make_writable (bfd *abfd);

bfd_boolean bfd_make_readable (bfd *abfd);

void *bfd_alloc (bfd *abfd, bfd_size_type wanted);

void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);

unsigned long bfd_calc_gnu_debuglink_crc32
   (unsigned long crc, const unsigned char *buf, bfd_size_type len);

char *bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out);

char *bfd_get_alt_debug_link_info (bfd * abfd,
    bfd_size_type *buildid_len,
    bfd_byte **buildid_out);

char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

char *bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir);

struct bfd_section *bfd_create_gnu_debuglink_section
   (bfd *abfd, const char *filename);

bfd_boolean bfd_fill_in_gnu_debuglink_section
   (bfd *abfd, struct bfd_section *sect, const char *filename);

char *bfd_follow_build_id_debuglink (bfd *abfd, const char *dir);
# 1240 "../bfd/bfd.h"
long bfd_get_mtime (bfd *abfd);

file_ptr bfd_get_size (bfd *abfd);

void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
    int prot, int flags, file_ptr offset,
    void **map_addr, bfd_size_type *map_len);




typedef struct bfd_section
{


  const char *name;


  unsigned int id;


  unsigned int index;


  struct bfd_section *next;


  struct bfd_section *prev;




  flagword flags;
# 1472 "../bfd/bfd.h"
  unsigned int user_set_vma : 1;


  unsigned int linker_mark : 1;



  unsigned int linker_has_input : 1;


  unsigned int gc_mark : 1;


  unsigned int compress_status : 2;







  unsigned int segment_mark : 1;


  unsigned int sec_info_type:3;
# 1506 "../bfd/bfd.h"
  unsigned int use_rela_p:1;




  unsigned int sec_flg0:1;
  unsigned int sec_flg1:1;
  unsigned int sec_flg2:1;
  unsigned int sec_flg3:1;
  unsigned int sec_flg4:1;
  unsigned int sec_flg5:1;
# 1526 "../bfd/bfd.h"
  bfd_vma vma;




  bfd_vma lma;




  bfd_size_type size;
# 1546 "../bfd/bfd.h"
  bfd_size_type rawsize;


  bfd_size_type compressed_size;


  struct relax_table *relax;


  int relax_count;
# 1565 "../bfd/bfd.h"
  bfd_vma output_offset;


  struct bfd_section *output_section;



  unsigned int alignment_power;



  struct reloc_cache_entry *relocation;



  struct reloc_cache_entry **orelocation;


  unsigned reloc_count;





  file_ptr filepos;


  file_ptr rel_filepos;


  file_ptr line_filepos;


  void *userdata;



  unsigned char *contents;


  alent *lineno;


  unsigned int lineno_count;


  unsigned int entsize;



  struct bfd_section *kept_section;



  file_ptr moving_line_filepos;


  int target_index;

  void *used_by_bfd;



  struct relent_chain *constructor_chain;


  bfd *owner;


  struct bfd_symbol *symbol;
  struct bfd_symbol **symbol_ptr_ptr;





  union {
    struct bfd_link_order *link_order;
    struct bfd_section *s;
  } map_head, map_tail;
} asection;




struct relax_table {

  bfd_vma addr;


  int size;
};





static inline bfd_boolean
bfd_set_section_userdata (bfd * abfd __attribute__ ((__unused__)), asection * ptr, void * val)
{
  ptr->userdata = val;
  return 1;
}

static inline bfd_boolean
bfd_set_section_vma (bfd * abfd __attribute__ ((__unused__)), asection * ptr, bfd_vma val)
{
  ptr->vma = ptr->lma = val;
  ptr->user_set_vma = 1;
  return 1;
}

static inline bfd_boolean
bfd_set_section_alignment (bfd * abfd __attribute__ ((__unused__)), asection * ptr, unsigned int val)
{
  ptr->alignment_power = val;
  return 1;
}




extern asection _bfd_std_section[4];
# 1841 "../bfd/bfd.h"
void bfd_section_list_clear (bfd *);

asection *bfd_get_section_by_name (bfd *abfd, const char *name);

asection *bfd_get_next_section_by_name (bfd *ibfd, asection *sec);

asection *bfd_get_linker_section (bfd *abfd, const char *name);

asection *bfd_get_section_by_name_if
   (bfd *abfd,
    const char *name,
    bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

char *bfd_get_unique_section_name
   (bfd *abfd, const char *templat, int *count);

asection *bfd_make_section_old_way (bfd *abfd, const char *name);

asection *bfd_make_section_anyway_with_flags
   (bfd *abfd, const char *name, flagword flags);

asection *bfd_make_section_anyway (bfd *abfd, const char *name);

asection *bfd_make_section_with_flags
   (bfd *, const char *name, flagword flags);

asection *bfd_make_section (bfd *, const char *name);

int bfd_get_next_section_id (void);

bfd_boolean bfd_set_section_flags
   (bfd *abfd, asection *sec, flagword flags);

void bfd_rename_section
   (bfd *abfd, asection *sec, const char *newname);

void bfd_map_over_sections
   (bfd *abfd,
    void (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

asection *bfd_sections_find_if
   (bfd *abfd,
    bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
    void *obj);

bfd_boolean bfd_set_section_size
   (bfd *abfd, asection *sec, bfd_size_type val);

bfd_boolean bfd_set_section_contents
   (bfd *abfd, asection *section, const void *data,
    file_ptr offset, bfd_size_type count);

bfd_boolean bfd_get_section_contents
   (bfd *abfd, asection *section, void *location, file_ptr offset,
    bfd_size_type count);

bfd_boolean bfd_malloc_and_get_section
   (bfd *abfd, asection *section, bfd_byte **buf);

bfd_boolean bfd_copy_private_section_data
   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);




bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);

bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);


enum bfd_architecture
{
  bfd_arch_unknown,
  bfd_arch_obscure,
  bfd_arch_m68k,
# 1949 "../bfd/bfd.h"
  bfd_arch_vax,
  bfd_arch_i960,
# 1968 "../bfd/bfd.h"
  bfd_arch_or1k,



  bfd_arch_sparc,
# 2007 "../bfd/bfd.h"
  bfd_arch_spu,

  bfd_arch_mips,
# 2055 "../bfd/bfd.h"
  bfd_arch_i386,
# 2064 "../bfd/bfd.h"
  bfd_arch_l1om,


  bfd_arch_k1om,






  bfd_arch_iamcu,



  bfd_arch_we32k,
  bfd_arch_tahoe,
  bfd_arch_i860,
  bfd_arch_i370,
  bfd_arch_romp,
  bfd_arch_convex,
  bfd_arch_m88k,
  bfd_arch_m98k,
  bfd_arch_pyramid,
  bfd_arch_h8300,







  bfd_arch_pdp11,
  bfd_arch_plugin,
  bfd_arch_powerpc,
# 2124 "../bfd/bfd.h"
  bfd_arch_rs6000,




  bfd_arch_hppa,




  bfd_arch_d10v,



  bfd_arch_d30v,
  bfd_arch_dlx,
  bfd_arch_m68hc11,
  bfd_arch_m68hc12,



  bfd_arch_m9s12x,
  bfd_arch_m9s12xg,
  bfd_arch_z8k,


  bfd_arch_h8500,
  bfd_arch_sh,
# 2173 "../bfd/bfd.h"
  bfd_arch_alpha,



  bfd_arch_arm,
# 2192 "../bfd/bfd.h"
  bfd_arch_nds32,





  bfd_arch_ns32k,
  bfd_arch_w65,
  bfd_arch_tic30,
  bfd_arch_tic4x,


  bfd_arch_tic54x,
  bfd_arch_tic6x,
  bfd_arch_tic80,
  bfd_arch_v850,
  bfd_arch_v850_rh850,






  bfd_arch_arc,






 bfd_arch_m32c,


  bfd_arch_m32r,



  bfd_arch_mn10200,
  bfd_arch_mn10300,



  bfd_arch_fr30,

  bfd_arch_frv,
# 2245 "../bfd/bfd.h"
  bfd_arch_moxie,

  bfd_arch_ft32,

  bfd_arch_mcore,
  bfd_arch_mep,



  bfd_arch_metag,

  bfd_arch_ia64,


  bfd_arch_ip2k,


 bfd_arch_iq2000,


  bfd_arch_epiphany,


  bfd_arch_mt,



  bfd_arch_pj,
  bfd_arch_avr,
# 2292 "../bfd/bfd.h"
  bfd_arch_bfin,

  bfd_arch_cr16,

  bfd_arch_cr16c,

  bfd_arch_crx,

  bfd_arch_cris,



  bfd_arch_riscv,


  bfd_arch_rl78,

  bfd_arch_rx,

  bfd_arch_s390,


  bfd_arch_score,


  bfd_arch_mmix,
  bfd_arch_xstormy16,

  bfd_arch_msp430,
# 2345 "../bfd/bfd.h"
  bfd_arch_xc16x,



  bfd_arch_xgate,

  bfd_arch_xtensa,

  bfd_arch_z80,




  bfd_arch_lm32,

  bfd_arch_microblaze,
  bfd_arch_tilepro,
  bfd_arch_tilegx,



  bfd_arch_aarch64,


  bfd_arch_nios2,



  bfd_arch_visium,

  bfd_arch_pru,

  bfd_arch_last
  };

typedef struct bfd_arch_info
{
  int bits_per_word;
  int bits_per_address;
  int bits_per_byte;
  enum bfd_architecture arch;
  unsigned long mach;
  const char *arch_name;
  const char *printable_name;
  unsigned int section_align_power;



  bfd_boolean the_default;
  const struct bfd_arch_info * (*compatible)
    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);

  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);




  void *(*fill) (bfd_size_type count, bfd_boolean is_bigendian,
                 bfd_boolean code);

  const struct bfd_arch_info *next;
}
bfd_arch_info_type;

const char *bfd_printable_name (bfd *abfd);

const bfd_arch_info_type *bfd_scan_arch (const char *string);

const char **bfd_arch_list (void);

const bfd_arch_info_type *bfd_arch_get_compatible
   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);

void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);

bfd_boolean bfd_default_set_arch_mach
   (bfd *abfd, enum bfd_architecture arch, unsigned long mach);

enum bfd_architecture bfd_get_arch (bfd *abfd);

unsigned long bfd_get_mach (bfd *abfd);

unsigned int bfd_arch_bits_per_byte (bfd *abfd);

unsigned int bfd_arch_bits_per_address (bfd *abfd);

const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);

const bfd_arch_info_type *bfd_lookup_arch
   (enum bfd_architecture arch, unsigned long machine);

const char *bfd_printable_arch_mach
   (enum bfd_architecture arch, unsigned long machine);

unsigned int bfd_octets_per_byte (bfd *abfd);

unsigned int bfd_arch_mach_octets_per_byte
   (enum bfd_architecture arch, unsigned long machine);



typedef enum bfd_reloc_status
{

  bfd_reloc_ok,


  bfd_reloc_overflow,


  bfd_reloc_outofrange,


  bfd_reloc_continue,


  bfd_reloc_notsupported,


  bfd_reloc_other,


  bfd_reloc_undefined,





  bfd_reloc_dangerous
 }
 bfd_reloc_status_type;


typedef struct reloc_cache_entry
{

  struct bfd_symbol **sym_ptr_ptr;


  bfd_size_type address;


  bfd_vma addend;


  reloc_howto_type *howto;

}
arelent;


enum complain_overflow
{

  complain_overflow_dont,




  complain_overflow_bitfield,



  complain_overflow_signed,



  complain_overflow_unsigned
};
struct bfd_symbol;

struct reloc_howto_struct
{






  unsigned int type;



  unsigned int rightshift;




  int size;



  unsigned int bitsize;


  bfd_boolean pc_relative;



  unsigned int bitpos;



  enum complain_overflow complain_on_overflow;





  bfd_reloc_status_type (*special_function)
    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
     bfd *, char **);


  char *name;
# 2576 "../bfd/bfd.h"
  bfd_boolean partial_inplace;
# 2586 "../bfd/bfd.h"
  bfd_vma src_mask;



  bfd_vma dst_mask;







  bfd_boolean pcrel_offset;
};
# 2626 "../bfd/bfd.h"
unsigned int bfd_get_reloc_size (reloc_howto_type *);

typedef struct relent_chain
{
  arelent relent;
  struct relent_chain *next;
}
arelent_chain;

bfd_reloc_status_type bfd_check_overflow
   (enum complain_overflow how,
    unsigned int bitsize,
    unsigned int rightshift,
    unsigned int addrsize,
    bfd_vma relocation);

bfd_reloc_status_type bfd_perform_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data,
    asection *input_section,
    bfd *output_bfd,
    char **error_message);

bfd_reloc_status_type bfd_install_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data, bfd_vma data_start,
    asection *input_section,
    char **error_message);

enum bfd_reloc_code_real {
  _dummy_first_bfd_reloc_code_real,



  BFD_RELOC_64,
  BFD_RELOC_32,
  BFD_RELOC_26,
  BFD_RELOC_24,
  BFD_RELOC_16,
  BFD_RELOC_14,
  BFD_RELOC_8,






  BFD_RELOC_64_PCREL,
  BFD_RELOC_32_PCREL,
  BFD_RELOC_24_PCREL,
  BFD_RELOC_16_PCREL,
  BFD_RELOC_12_PCREL,
  BFD_RELOC_8_PCREL,


  BFD_RELOC_32_SECREL,


  BFD_RELOC_32_GOT_PCREL,
  BFD_RELOC_16_GOT_PCREL,
  BFD_RELOC_8_GOT_PCREL,
  BFD_RELOC_32_GOTOFF,
  BFD_RELOC_16_GOTOFF,
  BFD_RELOC_LO16_GOTOFF,
  BFD_RELOC_HI16_GOTOFF,
  BFD_RELOC_HI16_S_GOTOFF,
  BFD_RELOC_8_GOTOFF,
  BFD_RELOC_64_PLT_PCREL,
  BFD_RELOC_32_PLT_PCREL,
  BFD_RELOC_24_PLT_PCREL,
  BFD_RELOC_16_PLT_PCREL,
  BFD_RELOC_8_PLT_PCREL,
  BFD_RELOC_64_PLTOFF,
  BFD_RELOC_32_PLTOFF,
  BFD_RELOC_16_PLTOFF,
  BFD_RELOC_LO16_PLTOFF,
  BFD_RELOC_HI16_PLTOFF,
  BFD_RELOC_HI16_S_PLTOFF,
  BFD_RELOC_8_PLTOFF,


  BFD_RELOC_SIZE32,
  BFD_RELOC_SIZE64,


  BFD_RELOC_68K_GLOB_DAT,
  BFD_RELOC_68K_JMP_SLOT,
  BFD_RELOC_68K_RELATIVE,
  BFD_RELOC_68K_TLS_GD32,
  BFD_RELOC_68K_TLS_GD16,
  BFD_RELOC_68K_TLS_GD8,
  BFD_RELOC_68K_TLS_LDM32,
  BFD_RELOC_68K_TLS_LDM16,
  BFD_RELOC_68K_TLS_LDM8,
  BFD_RELOC_68K_TLS_LDO32,
  BFD_RELOC_68K_TLS_LDO16,
  BFD_RELOC_68K_TLS_LDO8,
  BFD_RELOC_68K_TLS_IE32,
  BFD_RELOC_68K_TLS_IE16,
  BFD_RELOC_68K_TLS_IE8,
  BFD_RELOC_68K_TLS_LE32,
  BFD_RELOC_68K_TLS_LE16,
  BFD_RELOC_68K_TLS_LE8,


  BFD_RELOC_32_BASEREL,
  BFD_RELOC_16_BASEREL,
  BFD_RELOC_LO16_BASEREL,
  BFD_RELOC_HI16_BASEREL,
  BFD_RELOC_HI16_S_BASEREL,
  BFD_RELOC_8_BASEREL,
  BFD_RELOC_RVA,


  BFD_RELOC_8_FFnn,







  BFD_RELOC_32_PCREL_S2,
  BFD_RELOC_16_PCREL_S2,
  BFD_RELOC_23_PCREL_S2,



  BFD_RELOC_HI22,
  BFD_RELOC_LO10,





  BFD_RELOC_GPREL16,
  BFD_RELOC_GPREL32,


  BFD_RELOC_I960_CALLJ,



  BFD_RELOC_NONE,
  BFD_RELOC_SPARC_WDISP22,
  BFD_RELOC_SPARC22,
  BFD_RELOC_SPARC13,
  BFD_RELOC_SPARC_GOT10,
  BFD_RELOC_SPARC_GOT13,
  BFD_RELOC_SPARC_GOT22,
  BFD_RELOC_SPARC_PC10,
  BFD_RELOC_SPARC_PC22,
  BFD_RELOC_SPARC_WPLT30,
  BFD_RELOC_SPARC_COPY,
  BFD_RELOC_SPARC_GLOB_DAT,
  BFD_RELOC_SPARC_JMP_SLOT,
  BFD_RELOC_SPARC_RELATIVE,
  BFD_RELOC_SPARC_UA16,
  BFD_RELOC_SPARC_UA32,
  BFD_RELOC_SPARC_UA64,
  BFD_RELOC_SPARC_GOTDATA_HIX22,
  BFD_RELOC_SPARC_GOTDATA_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP_HIX22,
  BFD_RELOC_SPARC_GOTDATA_OP_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP,
  BFD_RELOC_SPARC_JMP_IREL,
  BFD_RELOC_SPARC_IRELATIVE,


  BFD_RELOC_SPARC_BASE13,
  BFD_RELOC_SPARC_BASE22,



  BFD_RELOC_SPARC_10,
  BFD_RELOC_SPARC_11,
  BFD_RELOC_SPARC_OLO10,
  BFD_RELOC_SPARC_HH22,
  BFD_RELOC_SPARC_HM10,
  BFD_RELOC_SPARC_LM22,
  BFD_RELOC_SPARC_PC_HH22,
  BFD_RELOC_SPARC_PC_HM10,
  BFD_RELOC_SPARC_PC_LM22,
  BFD_RELOC_SPARC_WDISP16,
  BFD_RELOC_SPARC_WDISP19,
  BFD_RELOC_SPARC_7,
  BFD_RELOC_SPARC_6,
  BFD_RELOC_SPARC_5,

  BFD_RELOC_SPARC_PLT32,
  BFD_RELOC_SPARC_PLT64,
  BFD_RELOC_SPARC_HIX22,
  BFD_RELOC_SPARC_LOX10,
  BFD_RELOC_SPARC_H44,
  BFD_RELOC_SPARC_M44,
  BFD_RELOC_SPARC_L44,
  BFD_RELOC_SPARC_REGISTER,
  BFD_RELOC_SPARC_H34,
  BFD_RELOC_SPARC_SIZE32,
  BFD_RELOC_SPARC_SIZE64,
  BFD_RELOC_SPARC_WDISP10,


  BFD_RELOC_SPARC_REV32,


  BFD_RELOC_SPARC_TLS_GD_HI22,
  BFD_RELOC_SPARC_TLS_GD_LO10,
  BFD_RELOC_SPARC_TLS_GD_ADD,
  BFD_RELOC_SPARC_TLS_GD_CALL,
  BFD_RELOC_SPARC_TLS_LDM_HI22,
  BFD_RELOC_SPARC_TLS_LDM_LO10,
  BFD_RELOC_SPARC_TLS_LDM_ADD,
  BFD_RELOC_SPARC_TLS_LDM_CALL,
  BFD_RELOC_SPARC_TLS_LDO_HIX22,
  BFD_RELOC_SPARC_TLS_LDO_LOX10,
  BFD_RELOC_SPARC_TLS_LDO_ADD,
  BFD_RELOC_SPARC_TLS_IE_HI22,
  BFD_RELOC_SPARC_TLS_IE_LO10,
  BFD_RELOC_SPARC_TLS_IE_LD,
  BFD_RELOC_SPARC_TLS_IE_LDX,
  BFD_RELOC_SPARC_TLS_IE_ADD,
  BFD_RELOC_SPARC_TLS_LE_HIX22,
  BFD_RELOC_SPARC_TLS_LE_LOX10,
  BFD_RELOC_SPARC_TLS_DTPMOD32,
  BFD_RELOC_SPARC_TLS_DTPMOD64,
  BFD_RELOC_SPARC_TLS_DTPOFF32,
  BFD_RELOC_SPARC_TLS_DTPOFF64,
  BFD_RELOC_SPARC_TLS_TPOFF32,
  BFD_RELOC_SPARC_TLS_TPOFF64,


  BFD_RELOC_SPU_IMM7,
  BFD_RELOC_SPU_IMM8,
  BFD_RELOC_SPU_IMM10,
  BFD_RELOC_SPU_IMM10W,
  BFD_RELOC_SPU_IMM16,
  BFD_RELOC_SPU_IMM16W,
  BFD_RELOC_SPU_IMM18,
  BFD_RELOC_SPU_PCREL9a,
  BFD_RELOC_SPU_PCREL9b,
  BFD_RELOC_SPU_PCREL16,
  BFD_RELOC_SPU_LO16,
  BFD_RELOC_SPU_HI16,
  BFD_RELOC_SPU_PPU32,
  BFD_RELOC_SPU_PPU64,
  BFD_RELOC_SPU_ADD_PIC,







  BFD_RELOC_ALPHA_GPDISP_HI16,





  BFD_RELOC_ALPHA_GPDISP_LO16,




  BFD_RELOC_ALPHA_GPDISP,
# 2918 "../bfd/bfd.h"
  BFD_RELOC_ALPHA_LITERAL,
  BFD_RELOC_ALPHA_ELF_LITERAL,
  BFD_RELOC_ALPHA_LITUSE,




  BFD_RELOC_ALPHA_HINT,



  BFD_RELOC_ALPHA_LINKAGE,



  BFD_RELOC_ALPHA_CODEADDR,



  BFD_RELOC_ALPHA_GPREL_HI16,
  BFD_RELOC_ALPHA_GPREL_LO16,




  BFD_RELOC_ALPHA_BRSGP,



  BFD_RELOC_ALPHA_NOP,



  BFD_RELOC_ALPHA_BSR,



  BFD_RELOC_ALPHA_LDA,



  BFD_RELOC_ALPHA_BOH,


  BFD_RELOC_ALPHA_TLSGD,
  BFD_RELOC_ALPHA_TLSLDM,
  BFD_RELOC_ALPHA_DTPMOD64,
  BFD_RELOC_ALPHA_GOTDTPREL16,
  BFD_RELOC_ALPHA_DTPREL64,
  BFD_RELOC_ALPHA_DTPREL_HI16,
  BFD_RELOC_ALPHA_DTPREL_LO16,
  BFD_RELOC_ALPHA_DTPREL16,
  BFD_RELOC_ALPHA_GOTTPREL16,
  BFD_RELOC_ALPHA_TPREL64,
  BFD_RELOC_ALPHA_TPREL_HI16,
  BFD_RELOC_ALPHA_TPREL_LO16,
  BFD_RELOC_ALPHA_TPREL16,


  BFD_RELOC_MIPS_JMP,
  BFD_RELOC_MICROMIPS_JMP,


  BFD_RELOC_MIPS16_JMP,


  BFD_RELOC_MIPS16_GPREL,


  BFD_RELOC_HI16,





  BFD_RELOC_HI16_S,


  BFD_RELOC_LO16,


  BFD_RELOC_HI16_PCREL,


  BFD_RELOC_HI16_S_PCREL,


  BFD_RELOC_LO16_PCREL,



  BFD_RELOC_MIPS16_GOT16,
  BFD_RELOC_MIPS16_CALL16,


  BFD_RELOC_MIPS16_HI16,





  BFD_RELOC_MIPS16_HI16_S,


  BFD_RELOC_MIPS16_LO16,


  BFD_RELOC_MIPS16_TLS_GD,
  BFD_RELOC_MIPS16_TLS_LDM,
  BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS16_TLS_GOTTPREL,
  BFD_RELOC_MIPS16_TLS_TPREL_HI16,
  BFD_RELOC_MIPS16_TLS_TPREL_LO16,


  BFD_RELOC_MIPS_LITERAL,
  BFD_RELOC_MICROMIPS_LITERAL,


  BFD_RELOC_MICROMIPS_7_PCREL_S1,
  BFD_RELOC_MICROMIPS_10_PCREL_S1,
  BFD_RELOC_MICROMIPS_16_PCREL_S1,


  BFD_RELOC_MIPS16_16_PCREL_S1,


  BFD_RELOC_MIPS_21_PCREL_S2,
  BFD_RELOC_MIPS_26_PCREL_S2,
  BFD_RELOC_MIPS_18_PCREL_S3,
  BFD_RELOC_MIPS_19_PCREL_S2,


  BFD_RELOC_MICROMIPS_GPREL16,
  BFD_RELOC_MICROMIPS_HI16,
  BFD_RELOC_MICROMIPS_HI16_S,
  BFD_RELOC_MICROMIPS_LO16,


  BFD_RELOC_MIPS_GOT16,
  BFD_RELOC_MICROMIPS_GOT16,
  BFD_RELOC_MIPS_CALL16,
  BFD_RELOC_MICROMIPS_CALL16,
  BFD_RELOC_MIPS_GOT_HI16,
  BFD_RELOC_MICROMIPS_GOT_HI16,
  BFD_RELOC_MIPS_GOT_LO16,
  BFD_RELOC_MICROMIPS_GOT_LO16,
  BFD_RELOC_MIPS_CALL_HI16,
  BFD_RELOC_MICROMIPS_CALL_HI16,
  BFD_RELOC_MIPS_CALL_LO16,
  BFD_RELOC_MICROMIPS_CALL_LO16,
  BFD_RELOC_MIPS_SUB,
  BFD_RELOC_MICROMIPS_SUB,
  BFD_RELOC_MIPS_GOT_PAGE,
  BFD_RELOC_MICROMIPS_GOT_PAGE,
  BFD_RELOC_MIPS_GOT_OFST,
  BFD_RELOC_MICROMIPS_GOT_OFST,
  BFD_RELOC_MIPS_GOT_DISP,
  BFD_RELOC_MICROMIPS_GOT_DISP,
  BFD_RELOC_MIPS_SHIFT5,
  BFD_RELOC_MIPS_SHIFT6,
  BFD_RELOC_MIPS_INSERT_A,
  BFD_RELOC_MIPS_INSERT_B,
  BFD_RELOC_MIPS_DELETE,
  BFD_RELOC_MIPS_HIGHEST,
  BFD_RELOC_MICROMIPS_HIGHEST,
  BFD_RELOC_MIPS_HIGHER,
  BFD_RELOC_MICROMIPS_HIGHER,
  BFD_RELOC_MIPS_SCN_DISP,
  BFD_RELOC_MICROMIPS_SCN_DISP,
  BFD_RELOC_MIPS_REL16,
  BFD_RELOC_MIPS_RELGOT,
  BFD_RELOC_MIPS_JALR,
  BFD_RELOC_MICROMIPS_JALR,
  BFD_RELOC_MIPS_TLS_DTPMOD32,
  BFD_RELOC_MIPS_TLS_DTPREL32,
  BFD_RELOC_MIPS_TLS_DTPMOD64,
  BFD_RELOC_MIPS_TLS_DTPREL64,
  BFD_RELOC_MIPS_TLS_GD,
  BFD_RELOC_MICROMIPS_TLS_GD,
  BFD_RELOC_MIPS_TLS_LDM,
  BFD_RELOC_MICROMIPS_TLS_LDM,
  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS_TLS_GOTTPREL,
  BFD_RELOC_MICROMIPS_TLS_GOTTPREL,
  BFD_RELOC_MIPS_TLS_TPREL32,
  BFD_RELOC_MIPS_TLS_TPREL64,
  BFD_RELOC_MIPS_TLS_TPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_HI16,
  BFD_RELOC_MIPS_TLS_TPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_LO16,
  BFD_RELOC_MIPS_EH,



  BFD_RELOC_MIPS_COPY,
  BFD_RELOC_MIPS_JUMP_SLOT,



  BFD_RELOC_MOXIE_10_PCREL,



  BFD_RELOC_FT32_10,
  BFD_RELOC_FT32_20,
  BFD_RELOC_FT32_17,
  BFD_RELOC_FT32_18,



  BFD_RELOC_FRV_LABEL16,
  BFD_RELOC_FRV_LABEL24,
  BFD_RELOC_FRV_LO16,
  BFD_RELOC_FRV_HI16,
  BFD_RELOC_FRV_GPREL12,
  BFD_RELOC_FRV_GPRELU12,
  BFD_RELOC_FRV_GPREL32,
  BFD_RELOC_FRV_GPRELHI,
  BFD_RELOC_FRV_GPRELLO,
  BFD_RELOC_FRV_GOT12,
  BFD_RELOC_FRV_GOTHI,
  BFD_RELOC_FRV_GOTLO,
  BFD_RELOC_FRV_FUNCDESC,
  BFD_RELOC_FRV_FUNCDESC_GOT12,
  BFD_RELOC_FRV_FUNCDESC_GOTHI,
  BFD_RELOC_FRV_FUNCDESC_GOTLO,
  BFD_RELOC_FRV_FUNCDESC_VALUE,
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
  BFD_RELOC_FRV_GOTOFF12,
  BFD_RELOC_FRV_GOTOFFHI,
  BFD_RELOC_FRV_GOTOFFLO,
  BFD_RELOC_FRV_GETTLSOFF,
  BFD_RELOC_FRV_TLSDESC_VALUE,
  BFD_RELOC_FRV_GOTTLSDESC12,
  BFD_RELOC_FRV_GOTTLSDESCHI,
  BFD_RELOC_FRV_GOTTLSDESCLO,
  BFD_RELOC_FRV_TLSMOFF12,
  BFD_RELOC_FRV_TLSMOFFHI,
  BFD_RELOC_FRV_TLSMOFFLO,
  BFD_RELOC_FRV_GOTTLSOFF12,
  BFD_RELOC_FRV_GOTTLSOFFHI,
  BFD_RELOC_FRV_GOTTLSOFFLO,
  BFD_RELOC_FRV_TLSOFF,
  BFD_RELOC_FRV_TLSDESC_RELAX,
  BFD_RELOC_FRV_GETTLSOFF_RELAX,
  BFD_RELOC_FRV_TLSOFF_RELAX,
  BFD_RELOC_FRV_TLSMOFF,



  BFD_RELOC_MN10300_GOTOFF24,



  BFD_RELOC_MN10300_GOT32,



  BFD_RELOC_MN10300_GOT24,



  BFD_RELOC_MN10300_GOT16,


  BFD_RELOC_MN10300_COPY,


  BFD_RELOC_MN10300_GLOB_DAT,


  BFD_RELOC_MN10300_JMP_SLOT,


  BFD_RELOC_MN10300_RELATIVE,




  BFD_RELOC_MN10300_SYM_DIFF,




  BFD_RELOC_MN10300_ALIGN,


  BFD_RELOC_MN10300_TLS_GD,
  BFD_RELOC_MN10300_TLS_LD,
  BFD_RELOC_MN10300_TLS_LDO,
  BFD_RELOC_MN10300_TLS_GOTIE,
  BFD_RELOC_MN10300_TLS_IE,
  BFD_RELOC_MN10300_TLS_LE,
  BFD_RELOC_MN10300_TLS_DTPMOD,
  BFD_RELOC_MN10300_TLS_DTPOFF,
  BFD_RELOC_MN10300_TLS_TPOFF,



  BFD_RELOC_MN10300_32_PCREL,



  BFD_RELOC_MN10300_16_PCREL,



  BFD_RELOC_386_GOT32,
  BFD_RELOC_386_PLT32,
  BFD_RELOC_386_COPY,
  BFD_RELOC_386_GLOB_DAT,
  BFD_RELOC_386_JUMP_SLOT,
  BFD_RELOC_386_RELATIVE,
  BFD_RELOC_386_GOTOFF,
  BFD_RELOC_386_GOTPC,
  BFD_RELOC_386_TLS_TPOFF,
  BFD_RELOC_386_TLS_IE,
  BFD_RELOC_386_TLS_GOTIE,
  BFD_RELOC_386_TLS_LE,
  BFD_RELOC_386_TLS_GD,
  BFD_RELOC_386_TLS_LDM,
  BFD_RELOC_386_TLS_LDO_32,
  BFD_RELOC_386_TLS_IE_32,
  BFD_RELOC_386_TLS_LE_32,
  BFD_RELOC_386_TLS_DTPMOD32,
  BFD_RELOC_386_TLS_DTPOFF32,
  BFD_RELOC_386_TLS_TPOFF32,
  BFD_RELOC_386_TLS_GOTDESC,
  BFD_RELOC_386_TLS_DESC_CALL,
  BFD_RELOC_386_TLS_DESC,
  BFD_RELOC_386_IRELATIVE,
  BFD_RELOC_386_GOT32X,


  BFD_RELOC_X86_64_GOT32,
  BFD_RELOC_X86_64_PLT32,
  BFD_RELOC_X86_64_COPY,
  BFD_RELOC_X86_64_GLOB_DAT,
  BFD_RELOC_X86_64_JUMP_SLOT,
  BFD_RELOC_X86_64_RELATIVE,
  BFD_RELOC_X86_64_GOTPCREL,
  BFD_RELOC_X86_64_32S,
  BFD_RELOC_X86_64_DTPMOD64,
  BFD_RELOC_X86_64_DTPOFF64,
  BFD_RELOC_X86_64_TPOFF64,
  BFD_RELOC_X86_64_TLSGD,
  BFD_RELOC_X86_64_TLSLD,
  BFD_RELOC_X86_64_DTPOFF32,
  BFD_RELOC_X86_64_GOTTPOFF,
  BFD_RELOC_X86_64_TPOFF32,
  BFD_RELOC_X86_64_GOTOFF64,
  BFD_RELOC_X86_64_GOTPC32,
  BFD_RELOC_X86_64_GOT64,
  BFD_RELOC_X86_64_GOTPCREL64,
  BFD_RELOC_X86_64_GOTPC64,
  BFD_RELOC_X86_64_GOTPLT64,
  BFD_RELOC_X86_64_PLTOFF64,
  BFD_RELOC_X86_64_GOTPC32_TLSDESC,
  BFD_RELOC_X86_64_TLSDESC_CALL,
  BFD_RELOC_X86_64_TLSDESC,
  BFD_RELOC_X86_64_IRELATIVE,
  BFD_RELOC_X86_64_PC32_BND,
  BFD_RELOC_X86_64_PLT32_BND,
  BFD_RELOC_X86_64_GOTPCRELX,
  BFD_RELOC_X86_64_REX_GOTPCRELX,


  BFD_RELOC_NS32K_IMM_8,
  BFD_RELOC_NS32K_IMM_16,
  BFD_RELOC_NS32K_IMM_32,
  BFD_RELOC_NS32K_IMM_8_PCREL,
  BFD_RELOC_NS32K_IMM_16_PCREL,
  BFD_RELOC_NS32K_IMM_32_PCREL,
  BFD_RELOC_NS32K_DISP_8,
  BFD_RELOC_NS32K_DISP_16,
  BFD_RELOC_NS32K_DISP_32,
  BFD_RELOC_NS32K_DISP_8_PCREL,
  BFD_RELOC_NS32K_DISP_16_PCREL,
  BFD_RELOC_NS32K_DISP_32_PCREL,


  BFD_RELOC_PDP11_DISP_8_PCREL,
  BFD_RELOC_PDP11_DISP_6_PCREL,


  BFD_RELOC_PJ_CODE_HI16,
  BFD_RELOC_PJ_CODE_LO16,
  BFD_RELOC_PJ_CODE_DIR16,
  BFD_RELOC_PJ_CODE_DIR32,
  BFD_RELOC_PJ_CODE_REL16,
  BFD_RELOC_PJ_CODE_REL32,


  BFD_RELOC_PPC_B26,
  BFD_RELOC_PPC_BA26,
  BFD_RELOC_PPC_TOC16,
  BFD_RELOC_PPC_B16,
  BFD_RELOC_PPC_B16_BRTAKEN,
  BFD_RELOC_PPC_B16_BRNTAKEN,
  BFD_RELOC_PPC_BA16,
  BFD_RELOC_PPC_BA16_BRTAKEN,
  BFD_RELOC_PPC_BA16_BRNTAKEN,
  BFD_RELOC_PPC_COPY,
  BFD_RELOC_PPC_GLOB_DAT,
  BFD_RELOC_PPC_JMP_SLOT,
  BFD_RELOC_PPC_RELATIVE,
  BFD_RELOC_PPC_LOCAL24PC,
  BFD_RELOC_PPC_EMB_NADDR32,
  BFD_RELOC_PPC_EMB_NADDR16,
  BFD_RELOC_PPC_EMB_NADDR16_LO,
  BFD_RELOC_PPC_EMB_NADDR16_HI,
  BFD_RELOC_PPC_EMB_NADDR16_HA,
  BFD_RELOC_PPC_EMB_SDAI16,
  BFD_RELOC_PPC_EMB_SDA2I16,
  BFD_RELOC_PPC_EMB_SDA2REL,
  BFD_RELOC_PPC_EMB_SDA21,
  BFD_RELOC_PPC_EMB_MRKREF,
  BFD_RELOC_PPC_EMB_RELSEC16,
  BFD_RELOC_PPC_EMB_RELST_LO,
  BFD_RELOC_PPC_EMB_RELST_HI,
  BFD_RELOC_PPC_EMB_RELST_HA,
  BFD_RELOC_PPC_EMB_BIT_FLD,
  BFD_RELOC_PPC_EMB_RELSDA,
  BFD_RELOC_PPC_VLE_REL8,
  BFD_RELOC_PPC_VLE_REL15,
  BFD_RELOC_PPC_VLE_REL24,
  BFD_RELOC_PPC_VLE_LO16A,
  BFD_RELOC_PPC_VLE_LO16D,
  BFD_RELOC_PPC_VLE_HI16A,
  BFD_RELOC_PPC_VLE_HI16D,
  BFD_RELOC_PPC_VLE_HA16A,
  BFD_RELOC_PPC_VLE_HA16D,
  BFD_RELOC_PPC_VLE_SDA21,
  BFD_RELOC_PPC_VLE_SDA21_LO,
  BFD_RELOC_PPC_VLE_SDAREL_LO16A,
  BFD_RELOC_PPC_VLE_SDAREL_LO16D,
  BFD_RELOC_PPC_VLE_SDAREL_HI16A,
  BFD_RELOC_PPC_VLE_SDAREL_HI16D,
  BFD_RELOC_PPC_VLE_SDAREL_HA16A,
  BFD_RELOC_PPC_VLE_SDAREL_HA16D,
  BFD_RELOC_PPC_REL16DX_HA,
  BFD_RELOC_PPC64_HIGHER,
  BFD_RELOC_PPC64_HIGHER_S,
  BFD_RELOC_PPC64_HIGHEST,
  BFD_RELOC_PPC64_HIGHEST_S,
  BFD_RELOC_PPC64_TOC16_LO,
  BFD_RELOC_PPC64_TOC16_HI,
  BFD_RELOC_PPC64_TOC16_HA,
  BFD_RELOC_PPC64_TOC,
  BFD_RELOC_PPC64_PLTGOT16,
  BFD_RELOC_PPC64_PLTGOT16_LO,
  BFD_RELOC_PPC64_PLTGOT16_HI,
  BFD_RELOC_PPC64_PLTGOT16_HA,
  BFD_RELOC_PPC64_ADDR16_DS,
  BFD_RELOC_PPC64_ADDR16_LO_DS,
  BFD_RELOC_PPC64_GOT16_DS,
  BFD_RELOC_PPC64_GOT16_LO_DS,
  BFD_RELOC_PPC64_PLT16_LO_DS,
  BFD_RELOC_PPC64_SECTOFF_DS,
  BFD_RELOC_PPC64_SECTOFF_LO_DS,
  BFD_RELOC_PPC64_TOC16_DS,
  BFD_RELOC_PPC64_TOC16_LO_DS,
  BFD_RELOC_PPC64_PLTGOT16_DS,
  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
  BFD_RELOC_PPC64_ADDR16_HIGH,
  BFD_RELOC_PPC64_ADDR16_HIGHA,
  BFD_RELOC_PPC64_ADDR64_LOCAL,
  BFD_RELOC_PPC64_ENTRY,


  BFD_RELOC_PPC_TLS,
  BFD_RELOC_PPC_TLSGD,
  BFD_RELOC_PPC_TLSLD,
  BFD_RELOC_PPC_DTPMOD,
  BFD_RELOC_PPC_TPREL16,
  BFD_RELOC_PPC_TPREL16_LO,
  BFD_RELOC_PPC_TPREL16_HI,
  BFD_RELOC_PPC_TPREL16_HA,
  BFD_RELOC_PPC_TPREL,
  BFD_RELOC_PPC_DTPREL16,
  BFD_RELOC_PPC_DTPREL16_LO,
  BFD_RELOC_PPC_DTPREL16_HI,
  BFD_RELOC_PPC_DTPREL16_HA,
  BFD_RELOC_PPC_DTPREL,
  BFD_RELOC_PPC_GOT_TLSGD16,
  BFD_RELOC_PPC_GOT_TLSGD16_LO,
  BFD_RELOC_PPC_GOT_TLSGD16_HI,
  BFD_RELOC_PPC_GOT_TLSGD16_HA,
  BFD_RELOC_PPC_GOT_TLSLD16,
  BFD_RELOC_PPC_GOT_TLSLD16_LO,
  BFD_RELOC_PPC_GOT_TLSLD16_HI,
  BFD_RELOC_PPC_GOT_TLSLD16_HA,
  BFD_RELOC_PPC_GOT_TPREL16,
  BFD_RELOC_PPC_GOT_TPREL16_LO,
  BFD_RELOC_PPC_GOT_TPREL16_HI,
  BFD_RELOC_PPC_GOT_TPREL16_HA,
  BFD_RELOC_PPC_GOT_DTPREL16,
  BFD_RELOC_PPC_GOT_DTPREL16_LO,
  BFD_RELOC_PPC_GOT_DTPREL16_HI,
  BFD_RELOC_PPC_GOT_DTPREL16_HA,
  BFD_RELOC_PPC64_TPREL16_DS,
  BFD_RELOC_PPC64_TPREL16_LO_DS,
  BFD_RELOC_PPC64_TPREL16_HIGHER,
  BFD_RELOC_PPC64_TPREL16_HIGHERA,
  BFD_RELOC_PPC64_TPREL16_HIGHEST,
  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
  BFD_RELOC_PPC64_DTPREL16_DS,
  BFD_RELOC_PPC64_DTPREL16_LO_DS,
  BFD_RELOC_PPC64_DTPREL16_HIGHER,
  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
  BFD_RELOC_PPC64_TPREL16_HIGH,
  BFD_RELOC_PPC64_TPREL16_HIGHA,
  BFD_RELOC_PPC64_DTPREL16_HIGH,
  BFD_RELOC_PPC64_DTPREL16_HIGHA,


  BFD_RELOC_I370_D12,




  BFD_RELOC_CTOR,



  BFD_RELOC_ARM_PCREL_BRANCH,




  BFD_RELOC_ARM_PCREL_BLX,




  BFD_RELOC_THUMB_PCREL_BLX,


  BFD_RELOC_ARM_PCREL_CALL,


  BFD_RELOC_ARM_PCREL_JUMP,






  BFD_RELOC_THUMB_PCREL_BRANCH7,
  BFD_RELOC_THUMB_PCREL_BRANCH9,
  BFD_RELOC_THUMB_PCREL_BRANCH12,
  BFD_RELOC_THUMB_PCREL_BRANCH20,
  BFD_RELOC_THUMB_PCREL_BRANCH23,
  BFD_RELOC_THUMB_PCREL_BRANCH25,


  BFD_RELOC_ARM_OFFSET_IMM,


  BFD_RELOC_ARM_THUMB_OFFSET,



  BFD_RELOC_ARM_TARGET1,


  BFD_RELOC_ARM_ROSEGREL32,


  BFD_RELOC_ARM_SBREL32,




  BFD_RELOC_ARM_TARGET2,


  BFD_RELOC_ARM_PREL31,


  BFD_RELOC_ARM_MOVW,
  BFD_RELOC_ARM_MOVT,
  BFD_RELOC_ARM_MOVW_PCREL,
  BFD_RELOC_ARM_MOVT_PCREL,
  BFD_RELOC_ARM_THUMB_MOVW,
  BFD_RELOC_ARM_THUMB_MOVT,
  BFD_RELOC_ARM_THUMB_MOVW_PCREL,
  BFD_RELOC_ARM_THUMB_MOVT_PCREL,


  BFD_RELOC_ARM_JUMP_SLOT,
  BFD_RELOC_ARM_GLOB_DAT,
  BFD_RELOC_ARM_GOT32,
  BFD_RELOC_ARM_PLT32,
  BFD_RELOC_ARM_RELATIVE,
  BFD_RELOC_ARM_GOTOFF,
  BFD_RELOC_ARM_GOTPC,
  BFD_RELOC_ARM_GOT_PREL,


  BFD_RELOC_ARM_TLS_GD32,
  BFD_RELOC_ARM_TLS_LDO32,
  BFD_RELOC_ARM_TLS_LDM32,
  BFD_RELOC_ARM_TLS_DTPOFF32,
  BFD_RELOC_ARM_TLS_DTPMOD32,
  BFD_RELOC_ARM_TLS_TPOFF32,
  BFD_RELOC_ARM_TLS_IE32,
  BFD_RELOC_ARM_TLS_LE32,
  BFD_RELOC_ARM_TLS_GOTDESC,
  BFD_RELOC_ARM_TLS_CALL,
  BFD_RELOC_ARM_THM_TLS_CALL,
  BFD_RELOC_ARM_TLS_DESCSEQ,
  BFD_RELOC_ARM_THM_TLS_DESCSEQ,
  BFD_RELOC_ARM_TLS_DESC,


  BFD_RELOC_ARM_ALU_PC_G0_NC,
  BFD_RELOC_ARM_ALU_PC_G0,
  BFD_RELOC_ARM_ALU_PC_G1_NC,
  BFD_RELOC_ARM_ALU_PC_G1,
  BFD_RELOC_ARM_ALU_PC_G2,
  BFD_RELOC_ARM_LDR_PC_G0,
  BFD_RELOC_ARM_LDR_PC_G1,
  BFD_RELOC_ARM_LDR_PC_G2,
  BFD_RELOC_ARM_LDRS_PC_G0,
  BFD_RELOC_ARM_LDRS_PC_G1,
  BFD_RELOC_ARM_LDRS_PC_G2,
  BFD_RELOC_ARM_LDC_PC_G0,
  BFD_RELOC_ARM_LDC_PC_G1,
  BFD_RELOC_ARM_LDC_PC_G2,
  BFD_RELOC_ARM_ALU_SB_G0_NC,
  BFD_RELOC_ARM_ALU_SB_G0,
  BFD_RELOC_ARM_ALU_SB_G1_NC,
  BFD_RELOC_ARM_ALU_SB_G1,
  BFD_RELOC_ARM_ALU_SB_G2,
  BFD_RELOC_ARM_LDR_SB_G0,
  BFD_RELOC_ARM_LDR_SB_G1,
  BFD_RELOC_ARM_LDR_SB_G2,
  BFD_RELOC_ARM_LDRS_SB_G0,
  BFD_RELOC_ARM_LDRS_SB_G1,
  BFD_RELOC_ARM_LDRS_SB_G2,
  BFD_RELOC_ARM_LDC_SB_G0,
  BFD_RELOC_ARM_LDC_SB_G1,
  BFD_RELOC_ARM_LDC_SB_G2,


  BFD_RELOC_ARM_V4BX,


  BFD_RELOC_ARM_IRELATIVE,


  BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC,



  BFD_RELOC_ARM_IMMEDIATE,
  BFD_RELOC_ARM_ADRL_IMMEDIATE,
  BFD_RELOC_ARM_T32_IMMEDIATE,
  BFD_RELOC_ARM_T32_ADD_IMM,
  BFD_RELOC_ARM_T32_IMM12,
  BFD_RELOC_ARM_T32_ADD_PC12,
  BFD_RELOC_ARM_SHIFT_IMM,
  BFD_RELOC_ARM_SMC,
  BFD_RELOC_ARM_HVC,
  BFD_RELOC_ARM_SWI,
  BFD_RELOC_ARM_MULTI,
  BFD_RELOC_ARM_CP_OFF_IMM,
  BFD_RELOC_ARM_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_T32_CP_OFF_IMM,
  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_ADR_IMM,
  BFD_RELOC_ARM_LDR_IMM,
  BFD_RELOC_ARM_LITERAL,
  BFD_RELOC_ARM_IN_POOL,
  BFD_RELOC_ARM_OFFSET_IMM8,
  BFD_RELOC_ARM_T32_OFFSET_U8,
  BFD_RELOC_ARM_T32_OFFSET_IMM,
  BFD_RELOC_ARM_HWLITERAL,
  BFD_RELOC_ARM_THUMB_ADD,
  BFD_RELOC_ARM_THUMB_IMM,
  BFD_RELOC_ARM_THUMB_SHIFT,


  BFD_RELOC_SH_PCDISP8BY2,
  BFD_RELOC_SH_PCDISP12BY2,
  BFD_RELOC_SH_IMM3,
  BFD_RELOC_SH_IMM3U,
  BFD_RELOC_SH_DISP12,
  BFD_RELOC_SH_DISP12BY2,
  BFD_RELOC_SH_DISP12BY4,
  BFD_RELOC_SH_DISP12BY8,
  BFD_RELOC_SH_DISP20,
  BFD_RELOC_SH_DISP20BY8,
  BFD_RELOC_SH_IMM4,
  BFD_RELOC_SH_IMM4BY2,
  BFD_RELOC_SH_IMM4BY4,
  BFD_RELOC_SH_IMM8,
  BFD_RELOC_SH_IMM8BY2,
  BFD_RELOC_SH_IMM8BY4,
  BFD_RELOC_SH_PCRELIMM8BY2,
  BFD_RELOC_SH_PCRELIMM8BY4,
  BFD_RELOC_SH_SWITCH16,
  BFD_RELOC_SH_SWITCH32,
  BFD_RELOC_SH_USES,
  BFD_RELOC_SH_COUNT,
  BFD_RELOC_SH_ALIGN,
  BFD_RELOC_SH_CODE,
  BFD_RELOC_SH_DATA,
  BFD_RELOC_SH_LABEL,
  BFD_RELOC_SH_LOOP_START,
  BFD_RELOC_SH_LOOP_END,
  BFD_RELOC_SH_COPY,
  BFD_RELOC_SH_GLOB_DAT,
  BFD_RELOC_SH_JMP_SLOT,
  BFD_RELOC_SH_RELATIVE,
  BFD_RELOC_SH_GOTPC,
  BFD_RELOC_SH_GOT_LOW16,
  BFD_RELOC_SH_GOT_MEDLOW16,
  BFD_RELOC_SH_GOT_MEDHI16,
  BFD_RELOC_SH_GOT_HI16,
  BFD_RELOC_SH_GOTPLT_LOW16,
  BFD_RELOC_SH_GOTPLT_MEDLOW16,
  BFD_RELOC_SH_GOTPLT_MEDHI16,
  BFD_RELOC_SH_GOTPLT_HI16,
  BFD_RELOC_SH_PLT_LOW16,
  BFD_RELOC_SH_PLT_MEDLOW16,
  BFD_RELOC_SH_PLT_MEDHI16,
  BFD_RELOC_SH_PLT_HI16,
  BFD_RELOC_SH_GOTOFF_LOW16,
  BFD_RELOC_SH_GOTOFF_MEDLOW16,
  BFD_RELOC_SH_GOTOFF_MEDHI16,
  BFD_RELOC_SH_GOTOFF_HI16,
  BFD_RELOC_SH_GOTPC_LOW16,
  BFD_RELOC_SH_GOTPC_MEDLOW16,
  BFD_RELOC_SH_GOTPC_MEDHI16,
  BFD_RELOC_SH_GOTPC_HI16,
  BFD_RELOC_SH_COPY64,
  BFD_RELOC_SH_GLOB_DAT64,
  BFD_RELOC_SH_JMP_SLOT64,
  BFD_RELOC_SH_RELATIVE64,
  BFD_RELOC_SH_GOT10BY4,
  BFD_RELOC_SH_GOT10BY8,
  BFD_RELOC_SH_GOTPLT10BY4,
  BFD_RELOC_SH_GOTPLT10BY8,
  BFD_RELOC_SH_GOTPLT32,
  BFD_RELOC_SH_SHMEDIA_CODE,
  BFD_RELOC_SH_IMMU5,
  BFD_RELOC_SH_IMMS6,
  BFD_RELOC_SH_IMMS6BY32,
  BFD_RELOC_SH_IMMU6,
  BFD_RELOC_SH_IMMS10,
  BFD_RELOC_SH_IMMS10BY2,
  BFD_RELOC_SH_IMMS10BY4,
  BFD_RELOC_SH_IMMS10BY8,
  BFD_RELOC_SH_IMMS16,
  BFD_RELOC_SH_IMMU16,
  BFD_RELOC_SH_IMM_LOW16,
  BFD_RELOC_SH_IMM_LOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDLOW16,
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDHI16,
  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
  BFD_RELOC_SH_IMM_HI16,
  BFD_RELOC_SH_IMM_HI16_PCREL,
  BFD_RELOC_SH_PT_16,
  BFD_RELOC_SH_TLS_GD_32,
  BFD_RELOC_SH_TLS_LD_32,
  BFD_RELOC_SH_TLS_LDO_32,
  BFD_RELOC_SH_TLS_IE_32,
  BFD_RELOC_SH_TLS_LE_32,
  BFD_RELOC_SH_TLS_DTPMOD32,
  BFD_RELOC_SH_TLS_DTPOFF32,
  BFD_RELOC_SH_TLS_TPOFF32,
  BFD_RELOC_SH_GOT20,
  BFD_RELOC_SH_GOTOFF20,
  BFD_RELOC_SH_GOTFUNCDESC,
  BFD_RELOC_SH_GOTFUNCDESC20,
  BFD_RELOC_SH_GOTOFFFUNCDESC,
  BFD_RELOC_SH_GOTOFFFUNCDESC20,
  BFD_RELOC_SH_FUNCDESC,


  BFD_RELOC_ARC_NONE,
  BFD_RELOC_ARC_8,
  BFD_RELOC_ARC_16,
  BFD_RELOC_ARC_24,
  BFD_RELOC_ARC_32,
  BFD_RELOC_ARC_N8,
  BFD_RELOC_ARC_N16,
  BFD_RELOC_ARC_N24,
  BFD_RELOC_ARC_N32,
  BFD_RELOC_ARC_SDA,
  BFD_RELOC_ARC_SECTOFF,
  BFD_RELOC_ARC_S21H_PCREL,
  BFD_RELOC_ARC_S21W_PCREL,
  BFD_RELOC_ARC_S25H_PCREL,
  BFD_RELOC_ARC_S25W_PCREL,
  BFD_RELOC_ARC_SDA32,
  BFD_RELOC_ARC_SDA_LDST,
  BFD_RELOC_ARC_SDA_LDST1,
  BFD_RELOC_ARC_SDA_LDST2,
  BFD_RELOC_ARC_SDA16_LD,
  BFD_RELOC_ARC_SDA16_LD1,
  BFD_RELOC_ARC_SDA16_LD2,
  BFD_RELOC_ARC_S13_PCREL,
  BFD_RELOC_ARC_W,
  BFD_RELOC_ARC_32_ME,
  BFD_RELOC_ARC_32_ME_S,
  BFD_RELOC_ARC_N32_ME,
  BFD_RELOC_ARC_SECTOFF_ME,
  BFD_RELOC_ARC_SDA32_ME,
  BFD_RELOC_ARC_W_ME,
  BFD_RELOC_AC_SECTOFF_U8,
  BFD_RELOC_AC_SECTOFF_U8_1,
  BFD_RELOC_AC_SECTOFF_U8_2,
  BFD_RELOC_AC_SECTOFF_S9,
  BFD_RELOC_AC_SECTOFF_S9_1,
  BFD_RELOC_AC_SECTOFF_S9_2,
  BFD_RELOC_ARC_SECTOFF_ME_1,
  BFD_RELOC_ARC_SECTOFF_ME_2,
  BFD_RELOC_ARC_SECTOFF_1,
  BFD_RELOC_ARC_SECTOFF_2,
  BFD_RELOC_ARC_SDA_12,
  BFD_RELOC_ARC_SDA16_ST2,
  BFD_RELOC_ARC_32_PCREL,
  BFD_RELOC_ARC_PC32,
  BFD_RELOC_ARC_GOT32,
  BFD_RELOC_ARC_GOTPC32,
  BFD_RELOC_ARC_PLT32,
  BFD_RELOC_ARC_COPY,
  BFD_RELOC_ARC_GLOB_DAT,
  BFD_RELOC_ARC_JMP_SLOT,
  BFD_RELOC_ARC_RELATIVE,
  BFD_RELOC_ARC_GOTOFF,
  BFD_RELOC_ARC_GOTPC,
  BFD_RELOC_ARC_S21W_PCREL_PLT,
  BFD_RELOC_ARC_S25H_PCREL_PLT,
  BFD_RELOC_ARC_TLS_DTPMOD,
  BFD_RELOC_ARC_TLS_TPOFF,
  BFD_RELOC_ARC_TLS_GD_GOT,
  BFD_RELOC_ARC_TLS_GD_LD,
  BFD_RELOC_ARC_TLS_GD_CALL,
  BFD_RELOC_ARC_TLS_IE_GOT,
  BFD_RELOC_ARC_TLS_DTPOFF,
  BFD_RELOC_ARC_TLS_DTPOFF_S9,
  BFD_RELOC_ARC_TLS_LE_S9,
  BFD_RELOC_ARC_TLS_LE_32,
  BFD_RELOC_ARC_S25W_PCREL_PLT,
  BFD_RELOC_ARC_S21H_PCREL_PLT,
  BFD_RELOC_ARC_NPS_CMEM16,


  BFD_RELOC_BFIN_16_IMM,


  BFD_RELOC_BFIN_16_HIGH,


  BFD_RELOC_BFIN_4_PCREL,


  BFD_RELOC_BFIN_5_PCREL,


  BFD_RELOC_BFIN_16_LOW,


  BFD_RELOC_BFIN_10_PCREL,


  BFD_RELOC_BFIN_11_PCREL,


  BFD_RELOC_BFIN_12_PCREL_JUMP,


  BFD_RELOC_BFIN_12_PCREL_JUMP_S,


  BFD_RELOC_BFIN_24_PCREL_CALL_X,


  BFD_RELOC_BFIN_24_PCREL_JUMP_L,


  BFD_RELOC_BFIN_GOT17M4,
  BFD_RELOC_BFIN_GOTHI,
  BFD_RELOC_BFIN_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC,
  BFD_RELOC_BFIN_FUNCDESC_GOT17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC_VALUE,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO,
  BFD_RELOC_BFIN_GOTOFF17M4,
  BFD_RELOC_BFIN_GOTOFFHI,
  BFD_RELOC_BFIN_GOTOFFLO,


  BFD_RELOC_BFIN_GOT,


  BFD_RELOC_BFIN_PLTPC,


  BFD_ARELOC_BFIN_PUSH,


  BFD_ARELOC_BFIN_CONST,


  BFD_ARELOC_BFIN_ADD,


  BFD_ARELOC_BFIN_SUB,


  BFD_ARELOC_BFIN_MULT,


  BFD_ARELOC_BFIN_DIV,


  BFD_ARELOC_BFIN_MOD,


  BFD_ARELOC_BFIN_LSHIFT,


  BFD_ARELOC_BFIN_RSHIFT,


  BFD_ARELOC_BFIN_AND,


  BFD_ARELOC_BFIN_OR,


  BFD_ARELOC_BFIN_XOR,


  BFD_ARELOC_BFIN_LAND,


  BFD_ARELOC_BFIN_LOR,


  BFD_ARELOC_BFIN_LEN,


  BFD_ARELOC_BFIN_NEG,


  BFD_ARELOC_BFIN_COMP,


  BFD_ARELOC_BFIN_PAGE,


  BFD_ARELOC_BFIN_HWPAGE,


  BFD_ARELOC_BFIN_ADDR,




  BFD_RELOC_D10V_10_PCREL_R,






  BFD_RELOC_D10V_10_PCREL_L,



  BFD_RELOC_D10V_18,



  BFD_RELOC_D10V_18_PCREL,



  BFD_RELOC_D30V_6,



  BFD_RELOC_D30V_9_PCREL,





  BFD_RELOC_D30V_9_PCREL_R,



  BFD_RELOC_D30V_15,



  BFD_RELOC_D30V_15_PCREL,





  BFD_RELOC_D30V_15_PCREL_R,



  BFD_RELOC_D30V_21,



  BFD_RELOC_D30V_21_PCREL,





  BFD_RELOC_D30V_21_PCREL_R,


  BFD_RELOC_D30V_32,


  BFD_RELOC_D30V_32_PCREL,


  BFD_RELOC_DLX_HI16_S,


  BFD_RELOC_DLX_LO16,


  BFD_RELOC_DLX_JMP26,


  BFD_RELOC_M32C_HI8,
  BFD_RELOC_M32C_RL_JUMP,
  BFD_RELOC_M32C_RL_1ADDR,
  BFD_RELOC_M32C_RL_2ADDR,



  BFD_RELOC_M32R_24,


  BFD_RELOC_M32R_10_PCREL,


  BFD_RELOC_M32R_18_PCREL,


  BFD_RELOC_M32R_26_PCREL,



  BFD_RELOC_M32R_HI16_ULO,



  BFD_RELOC_M32R_HI16_SLO,


  BFD_RELOC_M32R_LO16,



  BFD_RELOC_M32R_SDA16,


  BFD_RELOC_M32R_GOT24,
  BFD_RELOC_M32R_26_PLTREL,
  BFD_RELOC_M32R_COPY,
  BFD_RELOC_M32R_GLOB_DAT,
  BFD_RELOC_M32R_JMP_SLOT,
  BFD_RELOC_M32R_RELATIVE,
  BFD_RELOC_M32R_GOTOFF,
  BFD_RELOC_M32R_GOTOFF_HI_ULO,
  BFD_RELOC_M32R_GOTOFF_HI_SLO,
  BFD_RELOC_M32R_GOTOFF_LO,
  BFD_RELOC_M32R_GOTPC24,
  BFD_RELOC_M32R_GOT16_HI_ULO,
  BFD_RELOC_M32R_GOT16_HI_SLO,
  BFD_RELOC_M32R_GOT16_LO,
  BFD_RELOC_M32R_GOTPC_HI_ULO,
  BFD_RELOC_M32R_GOTPC_HI_SLO,
  BFD_RELOC_M32R_GOTPC_LO,



  BFD_RELOC_NDS32_20,


  BFD_RELOC_NDS32_9_PCREL,


  BFD_RELOC_NDS32_WORD_9_PCREL,


  BFD_RELOC_NDS32_15_PCREL,


  BFD_RELOC_NDS32_17_PCREL,


  BFD_RELOC_NDS32_25_PCREL,



  BFD_RELOC_NDS32_HI20,



  BFD_RELOC_NDS32_LO12S3,



  BFD_RELOC_NDS32_LO12S2,



  BFD_RELOC_NDS32_LO12S1,



  BFD_RELOC_NDS32_LO12S0,



  BFD_RELOC_NDS32_LO12S0_ORI,



  BFD_RELOC_NDS32_SDA15S3,



  BFD_RELOC_NDS32_SDA15S2,



  BFD_RELOC_NDS32_SDA15S1,



  BFD_RELOC_NDS32_SDA15S0,



  BFD_RELOC_NDS32_SDA16S3,



  BFD_RELOC_NDS32_SDA17S2,



  BFD_RELOC_NDS32_SDA18S1,



  BFD_RELOC_NDS32_SDA19S0,


  BFD_RELOC_NDS32_GOT20,
  BFD_RELOC_NDS32_9_PLTREL,
  BFD_RELOC_NDS32_25_PLTREL,
  BFD_RELOC_NDS32_COPY,
  BFD_RELOC_NDS32_GLOB_DAT,
  BFD_RELOC_NDS32_JMP_SLOT,
  BFD_RELOC_NDS32_RELATIVE,
  BFD_RELOC_NDS32_GOTOFF,
  BFD_RELOC_NDS32_GOTOFF_HI20,
  BFD_RELOC_NDS32_GOTOFF_LO12,
  BFD_RELOC_NDS32_GOTPC20,
  BFD_RELOC_NDS32_GOT_HI20,
  BFD_RELOC_NDS32_GOT_LO12,
  BFD_RELOC_NDS32_GOTPC_HI20,
  BFD_RELOC_NDS32_GOTPC_LO12,


  BFD_RELOC_NDS32_INSN16,
  BFD_RELOC_NDS32_LABEL,
  BFD_RELOC_NDS32_LONGCALL1,
  BFD_RELOC_NDS32_LONGCALL2,
  BFD_RELOC_NDS32_LONGCALL3,
  BFD_RELOC_NDS32_LONGJUMP1,
  BFD_RELOC_NDS32_LONGJUMP2,
  BFD_RELOC_NDS32_LONGJUMP3,
  BFD_RELOC_NDS32_LOADSTORE,
  BFD_RELOC_NDS32_9_FIXED,
  BFD_RELOC_NDS32_15_FIXED,
  BFD_RELOC_NDS32_17_FIXED,
  BFD_RELOC_NDS32_25_FIXED,
  BFD_RELOC_NDS32_LONGCALL4,
  BFD_RELOC_NDS32_LONGCALL5,
  BFD_RELOC_NDS32_LONGCALL6,
  BFD_RELOC_NDS32_LONGJUMP4,
  BFD_RELOC_NDS32_LONGJUMP5,
  BFD_RELOC_NDS32_LONGJUMP6,
  BFD_RELOC_NDS32_LONGJUMP7,


  BFD_RELOC_NDS32_PLTREL_HI20,
  BFD_RELOC_NDS32_PLTREL_LO12,
  BFD_RELOC_NDS32_PLT_GOTREL_HI20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO12,


  BFD_RELOC_NDS32_SDA12S2_DP,
  BFD_RELOC_NDS32_SDA12S2_SP,
  BFD_RELOC_NDS32_LO12S2_DP,
  BFD_RELOC_NDS32_LO12S2_SP,


  BFD_RELOC_NDS32_DWARF2_OP1,
  BFD_RELOC_NDS32_DWARF2_OP2,
  BFD_RELOC_NDS32_DWARF2_LEB,


  BFD_RELOC_NDS32_UPDATE_TA,


  BFD_RELOC_NDS32_PLT_GOTREL_LO20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO15,
  BFD_RELOC_NDS32_PLT_GOTREL_LO19,
  BFD_RELOC_NDS32_GOT_LO15,
  BFD_RELOC_NDS32_GOT_LO19,
  BFD_RELOC_NDS32_GOTOFF_LO15,
  BFD_RELOC_NDS32_GOTOFF_LO19,
  BFD_RELOC_NDS32_GOT15S2,
  BFD_RELOC_NDS32_GOT17S2,



  BFD_RELOC_NDS32_5,


  BFD_RELOC_NDS32_10_UPCREL,


  BFD_RELOC_NDS32_SDA_FP7U2_RELA,


  BFD_RELOC_NDS32_RELAX_ENTRY,
  BFD_RELOC_NDS32_GOT_SUFF,
  BFD_RELOC_NDS32_GOTOFF_SUFF,
  BFD_RELOC_NDS32_PLT_GOT_SUFF,
  BFD_RELOC_NDS32_MULCALL_SUFF,
  BFD_RELOC_NDS32_PTR,
  BFD_RELOC_NDS32_PTR_COUNT,
  BFD_RELOC_NDS32_PTR_RESOLVED,
  BFD_RELOC_NDS32_PLTBLOCK,
  BFD_RELOC_NDS32_RELAX_REGION_BEGIN,
  BFD_RELOC_NDS32_RELAX_REGION_END,
  BFD_RELOC_NDS32_MINUEND,
  BFD_RELOC_NDS32_SUBTRAHEND,
  BFD_RELOC_NDS32_DIFF8,
  BFD_RELOC_NDS32_DIFF16,
  BFD_RELOC_NDS32_DIFF32,
  BFD_RELOC_NDS32_DIFF_ULEB128,
  BFD_RELOC_NDS32_EMPTY,


  BFD_RELOC_NDS32_25_ABS,


  BFD_RELOC_NDS32_DATA,
  BFD_RELOC_NDS32_TRAN,
  BFD_RELOC_NDS32_17IFC_PCREL,
  BFD_RELOC_NDS32_10IFCU_PCREL,


  BFD_RELOC_NDS32_TPOFF,
  BFD_RELOC_NDS32_TLS_LE_HI20,
  BFD_RELOC_NDS32_TLS_LE_LO12,
  BFD_RELOC_NDS32_TLS_LE_ADD,
  BFD_RELOC_NDS32_TLS_LE_LS,
  BFD_RELOC_NDS32_GOTTPOFF,
  BFD_RELOC_NDS32_TLS_IE_HI20,
  BFD_RELOC_NDS32_TLS_IE_LO12S2,
  BFD_RELOC_NDS32_TLS_TPOFF,
  BFD_RELOC_NDS32_TLS_LE_20,
  BFD_RELOC_NDS32_TLS_LE_15S0,
  BFD_RELOC_NDS32_TLS_LE_15S1,
  BFD_RELOC_NDS32_TLS_LE_15S2,


  BFD_RELOC_V850_9_PCREL,


  BFD_RELOC_V850_22_PCREL,


  BFD_RELOC_V850_SDA_16_16_OFFSET,



  BFD_RELOC_V850_SDA_15_16_OFFSET,


  BFD_RELOC_V850_ZDA_16_16_OFFSET,



  BFD_RELOC_V850_ZDA_15_16_OFFSET,



  BFD_RELOC_V850_TDA_6_8_OFFSET,



  BFD_RELOC_V850_TDA_7_8_OFFSET,


  BFD_RELOC_V850_TDA_7_7_OFFSET,


  BFD_RELOC_V850_TDA_16_16_OFFSET,



  BFD_RELOC_V850_TDA_4_5_OFFSET,


  BFD_RELOC_V850_TDA_4_4_OFFSET,



  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,



  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,


  BFD_RELOC_V850_CALLT_6_7_OFFSET,


  BFD_RELOC_V850_CALLT_16_16_OFFSET,


  BFD_RELOC_V850_LONGCALL,


  BFD_RELOC_V850_LONGJUMP,


  BFD_RELOC_V850_ALIGN,



  BFD_RELOC_V850_LO16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_PCREL,


  BFD_RELOC_V850_17_PCREL,


  BFD_RELOC_V850_23,


  BFD_RELOC_V850_32_PCREL,


  BFD_RELOC_V850_32_ABS,


  BFD_RELOC_V850_16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_S1,


  BFD_RELOC_V850_LO16_S1,


  BFD_RELOC_V850_CALLT_15_16_OFFSET,


  BFD_RELOC_V850_32_GOTPCREL,


  BFD_RELOC_V850_16_GOT,


  BFD_RELOC_V850_32_GOT,


  BFD_RELOC_V850_22_PLT_PCREL,


  BFD_RELOC_V850_32_PLT_PCREL,


  BFD_RELOC_V850_COPY,


  BFD_RELOC_V850_GLOB_DAT,


  BFD_RELOC_V850_JMP_SLOT,


  BFD_RELOC_V850_RELATIVE,


  BFD_RELOC_V850_16_GOTOFF,


  BFD_RELOC_V850_32_GOTOFF,


  BFD_RELOC_V850_CODE,


  BFD_RELOC_V850_DATA,




  BFD_RELOC_TIC30_LDP,




  BFD_RELOC_TIC54X_PARTLS7,




  BFD_RELOC_TIC54X_PARTMS9,


  BFD_RELOC_TIC54X_23,




  BFD_RELOC_TIC54X_16_OF_23,




  BFD_RELOC_TIC54X_MS7_OF_23,


  BFD_RELOC_C6000_PCR_S21,
  BFD_RELOC_C6000_PCR_S12,
  BFD_RELOC_C6000_PCR_S10,
  BFD_RELOC_C6000_PCR_S7,
  BFD_RELOC_C6000_ABS_S16,
  BFD_RELOC_C6000_ABS_L16,
  BFD_RELOC_C6000_ABS_H16,
  BFD_RELOC_C6000_SBR_U15_B,
  BFD_RELOC_C6000_SBR_U15_H,
  BFD_RELOC_C6000_SBR_U15_W,
  BFD_RELOC_C6000_SBR_S16,
  BFD_RELOC_C6000_SBR_L16_B,
  BFD_RELOC_C6000_SBR_L16_H,
  BFD_RELOC_C6000_SBR_L16_W,
  BFD_RELOC_C6000_SBR_H16_B,
  BFD_RELOC_C6000_SBR_H16_H,
  BFD_RELOC_C6000_SBR_H16_W,
  BFD_RELOC_C6000_SBR_GOT_U15_W,
  BFD_RELOC_C6000_SBR_GOT_L16_W,
  BFD_RELOC_C6000_SBR_GOT_H16_W,
  BFD_RELOC_C6000_DSBT_INDEX,
  BFD_RELOC_C6000_PREL31,
  BFD_RELOC_C6000_COPY,
  BFD_RELOC_C6000_JUMP_SLOT,
  BFD_RELOC_C6000_EHTYPE,
  BFD_RELOC_C6000_PCR_H16,
  BFD_RELOC_C6000_PCR_L16,
  BFD_RELOC_C6000_ALIGN,
  BFD_RELOC_C6000_FPHEAD,
  BFD_RELOC_C6000_NOCMP,


  BFD_RELOC_FR30_48,



  BFD_RELOC_FR30_20,



  BFD_RELOC_FR30_6_IN_4,



  BFD_RELOC_FR30_8_IN_8,



  BFD_RELOC_FR30_9_IN_8,



  BFD_RELOC_FR30_10_IN_8,



  BFD_RELOC_FR30_9_PCREL,



  BFD_RELOC_FR30_12_PCREL,


  BFD_RELOC_MCORE_PCREL_IMM8BY4,
  BFD_RELOC_MCORE_PCREL_IMM11BY2,
  BFD_RELOC_MCORE_PCREL_IMM4BY2,
  BFD_RELOC_MCORE_PCREL_32,
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_MCORE_RVA,


  BFD_RELOC_MEP_8,
  BFD_RELOC_MEP_16,
  BFD_RELOC_MEP_32,
  BFD_RELOC_MEP_PCREL8A2,
  BFD_RELOC_MEP_PCREL12A2,
  BFD_RELOC_MEP_PCREL17A2,
  BFD_RELOC_MEP_PCREL24A2,
  BFD_RELOC_MEP_PCABS24A2,
  BFD_RELOC_MEP_LOW16,
  BFD_RELOC_MEP_HI16U,
  BFD_RELOC_MEP_HI16S,
  BFD_RELOC_MEP_GPREL,
  BFD_RELOC_MEP_TPREL,
  BFD_RELOC_MEP_TPREL7,
  BFD_RELOC_MEP_TPREL7A2,
  BFD_RELOC_MEP_TPREL7A4,
  BFD_RELOC_MEP_UIMM24,
  BFD_RELOC_MEP_ADDR24A4,
  BFD_RELOC_MEP_GNU_VTINHERIT,
  BFD_RELOC_MEP_GNU_VTENTRY,



  BFD_RELOC_METAG_HIADDR16,
  BFD_RELOC_METAG_LOADDR16,
  BFD_RELOC_METAG_RELBRANCH,
  BFD_RELOC_METAG_GETSETOFF,
  BFD_RELOC_METAG_HIOG,
  BFD_RELOC_METAG_LOOG,
  BFD_RELOC_METAG_REL8,
  BFD_RELOC_METAG_REL16,
  BFD_RELOC_METAG_HI16_GOTOFF,
  BFD_RELOC_METAG_LO16_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOT,
  BFD_RELOC_METAG_HI16_GOTPC,
  BFD_RELOC_METAG_LO16_GOTPC,
  BFD_RELOC_METAG_HI16_PLT,
  BFD_RELOC_METAG_LO16_PLT,
  BFD_RELOC_METAG_RELBRANCH_PLT,
  BFD_RELOC_METAG_GOTOFF,
  BFD_RELOC_METAG_PLT,
  BFD_RELOC_METAG_COPY,
  BFD_RELOC_METAG_JMP_SLOT,
  BFD_RELOC_METAG_RELATIVE,
  BFD_RELOC_METAG_GLOB_DAT,
  BFD_RELOC_METAG_TLS_GD,
  BFD_RELOC_METAG_TLS_LDM,
  BFD_RELOC_METAG_TLS_LDO_HI16,
  BFD_RELOC_METAG_TLS_LDO_LO16,
  BFD_RELOC_METAG_TLS_LDO,
  BFD_RELOC_METAG_TLS_IE,
  BFD_RELOC_METAG_TLS_IENONPIC,
  BFD_RELOC_METAG_TLS_IENONPIC_HI16,
  BFD_RELOC_METAG_TLS_IENONPIC_LO16,
  BFD_RELOC_METAG_TLS_TPOFF,
  BFD_RELOC_METAG_TLS_DTPMOD,
  BFD_RELOC_METAG_TLS_DTPOFF,
  BFD_RELOC_METAG_TLS_LE,
  BFD_RELOC_METAG_TLS_LE_HI16,
  BFD_RELOC_METAG_TLS_LE_LO16,


  BFD_RELOC_MMIX_GETA,
  BFD_RELOC_MMIX_GETA_1,
  BFD_RELOC_MMIX_GETA_2,
  BFD_RELOC_MMIX_GETA_3,


  BFD_RELOC_MMIX_CBRANCH,
  BFD_RELOC_MMIX_CBRANCH_J,
  BFD_RELOC_MMIX_CBRANCH_1,
  BFD_RELOC_MMIX_CBRANCH_2,
  BFD_RELOC_MMIX_CBRANCH_3,


  BFD_RELOC_MMIX_PUSHJ,
  BFD_RELOC_MMIX_PUSHJ_1,
  BFD_RELOC_MMIX_PUSHJ_2,
  BFD_RELOC_MMIX_PUSHJ_3,
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,


  BFD_RELOC_MMIX_JMP,
  BFD_RELOC_MMIX_JMP_1,
  BFD_RELOC_MMIX_JMP_2,
  BFD_RELOC_MMIX_JMP_3,



  BFD_RELOC_MMIX_ADDR19,


  BFD_RELOC_MMIX_ADDR27,



  BFD_RELOC_MMIX_REG_OR_BYTE,



  BFD_RELOC_MMIX_REG,



  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,



  BFD_RELOC_MMIX_LOCAL,



  BFD_RELOC_AVR_7_PCREL,



  BFD_RELOC_AVR_13_PCREL,



  BFD_RELOC_AVR_16_PM,



  BFD_RELOC_AVR_LO8_LDI,



  BFD_RELOC_AVR_HI8_LDI,



  BFD_RELOC_AVR_HH8_LDI,



  BFD_RELOC_AVR_MS8_LDI,



  BFD_RELOC_AVR_LO8_LDI_NEG,




  BFD_RELOC_AVR_HI8_LDI_NEG,




  BFD_RELOC_AVR_HH8_LDI_NEG,



  BFD_RELOC_AVR_MS8_LDI_NEG,



  BFD_RELOC_AVR_LO8_LDI_PM,





  BFD_RELOC_AVR_LO8_LDI_GS,



  BFD_RELOC_AVR_HI8_LDI_PM,





  BFD_RELOC_AVR_HI8_LDI_GS,



  BFD_RELOC_AVR_HH8_LDI_PM,



  BFD_RELOC_AVR_LO8_LDI_PM_NEG,




  BFD_RELOC_AVR_HI8_LDI_PM_NEG,




  BFD_RELOC_AVR_HH8_LDI_PM_NEG,



  BFD_RELOC_AVR_CALL,



  BFD_RELOC_AVR_LDI,



  BFD_RELOC_AVR_6,



  BFD_RELOC_AVR_6_ADIW,



  BFD_RELOC_AVR_8_LO,



  BFD_RELOC_AVR_8_HI,



  BFD_RELOC_AVR_8_HLO,







  BFD_RELOC_AVR_DIFF8,
  BFD_RELOC_AVR_DIFF16,
  BFD_RELOC_AVR_DIFF32,



  BFD_RELOC_AVR_LDS_STS_16,



  BFD_RELOC_AVR_PORT6,



  BFD_RELOC_AVR_PORT5,


  BFD_RELOC_RISCV_HI20,
  BFD_RELOC_RISCV_PCREL_HI20,
  BFD_RELOC_RISCV_PCREL_LO12_I,
  BFD_RELOC_RISCV_PCREL_LO12_S,
  BFD_RELOC_RISCV_LO12_I,
  BFD_RELOC_RISCV_LO12_S,
  BFD_RELOC_RISCV_GPREL12_I,
  BFD_RELOC_RISCV_GPREL12_S,
  BFD_RELOC_RISCV_TPREL_HI20,
  BFD_RELOC_RISCV_TPREL_LO12_I,
  BFD_RELOC_RISCV_TPREL_LO12_S,
  BFD_RELOC_RISCV_TPREL_ADD,
  BFD_RELOC_RISCV_CALL,
  BFD_RELOC_RISCV_CALL_PLT,
  BFD_RELOC_RISCV_ADD8,
  BFD_RELOC_RISCV_ADD16,
  BFD_RELOC_RISCV_ADD32,
  BFD_RELOC_RISCV_ADD64,
  BFD_RELOC_RISCV_SUB8,
  BFD_RELOC_RISCV_SUB16,
  BFD_RELOC_RISCV_SUB32,
  BFD_RELOC_RISCV_SUB64,
  BFD_RELOC_RISCV_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GD_HI20,
  BFD_RELOC_RISCV_JMP,
  BFD_RELOC_RISCV_TLS_DTPMOD32,
  BFD_RELOC_RISCV_TLS_DTPREL32,
  BFD_RELOC_RISCV_TLS_DTPMOD64,
  BFD_RELOC_RISCV_TLS_DTPREL64,
  BFD_RELOC_RISCV_TLS_TPREL32,
  BFD_RELOC_RISCV_TLS_TPREL64,
  BFD_RELOC_RISCV_ALIGN,
  BFD_RELOC_RISCV_RVC_BRANCH,
  BFD_RELOC_RISCV_RVC_JUMP,
  BFD_RELOC_RISCV_RVC_LUI,
  BFD_RELOC_RISCV_GPREL_I,
  BFD_RELOC_RISCV_GPREL_S,
  BFD_RELOC_RISCV_TPREL_I,
  BFD_RELOC_RISCV_TPREL_S,
  BFD_RELOC_RISCV_RELAX,
  BFD_RELOC_RISCV_CFA,
  BFD_RELOC_RISCV_SUB6,
  BFD_RELOC_RISCV_SET6,
  BFD_RELOC_RISCV_SET8,
  BFD_RELOC_RISCV_SET16,
  BFD_RELOC_RISCV_SET32,


  BFD_RELOC_RL78_NEG8,
  BFD_RELOC_RL78_NEG16,
  BFD_RELOC_RL78_NEG24,
  BFD_RELOC_RL78_NEG32,
  BFD_RELOC_RL78_16_OP,
  BFD_RELOC_RL78_24_OP,
  BFD_RELOC_RL78_32_OP,
  BFD_RELOC_RL78_8U,
  BFD_RELOC_RL78_16U,
  BFD_RELOC_RL78_24U,
  BFD_RELOC_RL78_DIR3U_PCREL,
  BFD_RELOC_RL78_DIFF,
  BFD_RELOC_RL78_GPRELB,
  BFD_RELOC_RL78_GPRELW,
  BFD_RELOC_RL78_GPRELL,
  BFD_RELOC_RL78_SYM,
  BFD_RELOC_RL78_OP_SUBTRACT,
  BFD_RELOC_RL78_OP_NEG,
  BFD_RELOC_RL78_OP_AND,
  BFD_RELOC_RL78_OP_SHRA,
  BFD_RELOC_RL78_ABS8,
  BFD_RELOC_RL78_ABS16,
  BFD_RELOC_RL78_ABS16_REV,
  BFD_RELOC_RL78_ABS32,
  BFD_RELOC_RL78_ABS32_REV,
  BFD_RELOC_RL78_ABS16U,
  BFD_RELOC_RL78_ABS16UW,
  BFD_RELOC_RL78_ABS16UL,
  BFD_RELOC_RL78_RELAX,
  BFD_RELOC_RL78_HI16,
  BFD_RELOC_RL78_HI8,
  BFD_RELOC_RL78_LO16,
  BFD_RELOC_RL78_CODE,
  BFD_RELOC_RL78_SADDR,


  BFD_RELOC_RX_NEG8,
  BFD_RELOC_RX_NEG16,
  BFD_RELOC_RX_NEG24,
  BFD_RELOC_RX_NEG32,
  BFD_RELOC_RX_16_OP,
  BFD_RELOC_RX_24_OP,
  BFD_RELOC_RX_32_OP,
  BFD_RELOC_RX_8U,
  BFD_RELOC_RX_16U,
  BFD_RELOC_RX_24U,
  BFD_RELOC_RX_DIR3U_PCREL,
  BFD_RELOC_RX_DIFF,
  BFD_RELOC_RX_GPRELB,
  BFD_RELOC_RX_GPRELW,
  BFD_RELOC_RX_GPRELL,
  BFD_RELOC_RX_SYM,
  BFD_RELOC_RX_OP_SUBTRACT,
  BFD_RELOC_RX_OP_NEG,
  BFD_RELOC_RX_ABS8,
  BFD_RELOC_RX_ABS16,
  BFD_RELOC_RX_ABS16_REV,
  BFD_RELOC_RX_ABS32,
  BFD_RELOC_RX_ABS32_REV,
  BFD_RELOC_RX_ABS16U,
  BFD_RELOC_RX_ABS16UW,
  BFD_RELOC_RX_ABS16UL,
  BFD_RELOC_RX_RELAX,


  BFD_RELOC_390_12,


  BFD_RELOC_390_GOT12,


  BFD_RELOC_390_PLT32,


  BFD_RELOC_390_COPY,


  BFD_RELOC_390_GLOB_DAT,


  BFD_RELOC_390_JMP_SLOT,


  BFD_RELOC_390_RELATIVE,


  BFD_RELOC_390_GOTPC,


  BFD_RELOC_390_GOT16,


  BFD_RELOC_390_PC12DBL,


  BFD_RELOC_390_PLT12DBL,


  BFD_RELOC_390_PC16DBL,


  BFD_RELOC_390_PLT16DBL,


  BFD_RELOC_390_PC24DBL,


  BFD_RELOC_390_PLT24DBL,


  BFD_RELOC_390_PC32DBL,


  BFD_RELOC_390_PLT32DBL,


  BFD_RELOC_390_GOTPCDBL,


  BFD_RELOC_390_GOT64,


  BFD_RELOC_390_PLT64,


  BFD_RELOC_390_GOTENT,


  BFD_RELOC_390_GOTOFF64,


  BFD_RELOC_390_GOTPLT12,


  BFD_RELOC_390_GOTPLT16,


  BFD_RELOC_390_GOTPLT32,


  BFD_RELOC_390_GOTPLT64,


  BFD_RELOC_390_GOTPLTENT,


  BFD_RELOC_390_PLTOFF16,


  BFD_RELOC_390_PLTOFF32,


  BFD_RELOC_390_PLTOFF64,


  BFD_RELOC_390_TLS_LOAD,
  BFD_RELOC_390_TLS_GDCALL,
  BFD_RELOC_390_TLS_LDCALL,
  BFD_RELOC_390_TLS_GD32,
  BFD_RELOC_390_TLS_GD64,
  BFD_RELOC_390_TLS_GOTIE12,
  BFD_RELOC_390_TLS_GOTIE32,
  BFD_RELOC_390_TLS_GOTIE64,
  BFD_RELOC_390_TLS_LDM32,
  BFD_RELOC_390_TLS_LDM64,
  BFD_RELOC_390_TLS_IE32,
  BFD_RELOC_390_TLS_IE64,
  BFD_RELOC_390_TLS_IEENT,
  BFD_RELOC_390_TLS_LE32,
  BFD_RELOC_390_TLS_LE64,
  BFD_RELOC_390_TLS_LDO32,
  BFD_RELOC_390_TLS_LDO64,
  BFD_RELOC_390_TLS_DTPMOD,
  BFD_RELOC_390_TLS_DTPOFF,
  BFD_RELOC_390_TLS_TPOFF,


  BFD_RELOC_390_20,
  BFD_RELOC_390_GOT20,
  BFD_RELOC_390_GOTPLT20,
  BFD_RELOC_390_TLS_GOTIE20,


  BFD_RELOC_390_IRELATIVE,



  BFD_RELOC_SCORE_GPREL15,


  BFD_RELOC_SCORE_DUMMY2,
  BFD_RELOC_SCORE_JMP,


  BFD_RELOC_SCORE_BRANCH,


  BFD_RELOC_SCORE_IMM30,


  BFD_RELOC_SCORE_IMM32,


  BFD_RELOC_SCORE16_JMP,


  BFD_RELOC_SCORE16_BRANCH,


  BFD_RELOC_SCORE_BCMP,


  BFD_RELOC_SCORE_GOT15,
  BFD_RELOC_SCORE_GOT_LO16,
  BFD_RELOC_SCORE_CALL15,
  BFD_RELOC_SCORE_DUMMY_HI16,


  BFD_RELOC_IP2K_FR9,


  BFD_RELOC_IP2K_BANK,


  BFD_RELOC_IP2K_ADDR16CJP,


  BFD_RELOC_IP2K_PAGE3,


  BFD_RELOC_IP2K_LO8DATA,
  BFD_RELOC_IP2K_HI8DATA,
  BFD_RELOC_IP2K_EX8DATA,


  BFD_RELOC_IP2K_LO8INSN,
  BFD_RELOC_IP2K_HI8INSN,


  BFD_RELOC_IP2K_PC_SKIP,


  BFD_RELOC_IP2K_TEXT,


  BFD_RELOC_IP2K_FR_OFFSET,


  BFD_RELOC_VPE4KMATH_DATA,
  BFD_RELOC_VPE4KMATH_INSN,
# 5023 "../bfd/bfd.h"
  BFD_RELOC_VTABLE_INHERIT,
  BFD_RELOC_VTABLE_ENTRY,


  BFD_RELOC_IA64_IMM14,
  BFD_RELOC_IA64_IMM22,
  BFD_RELOC_IA64_IMM64,
  BFD_RELOC_IA64_DIR32MSB,
  BFD_RELOC_IA64_DIR32LSB,
  BFD_RELOC_IA64_DIR64MSB,
  BFD_RELOC_IA64_DIR64LSB,
  BFD_RELOC_IA64_GPREL22,
  BFD_RELOC_IA64_GPREL64I,
  BFD_RELOC_IA64_GPREL32MSB,
  BFD_RELOC_IA64_GPREL32LSB,
  BFD_RELOC_IA64_GPREL64MSB,
  BFD_RELOC_IA64_GPREL64LSB,
  BFD_RELOC_IA64_LTOFF22,
  BFD_RELOC_IA64_LTOFF64I,
  BFD_RELOC_IA64_PLTOFF22,
  BFD_RELOC_IA64_PLTOFF64I,
  BFD_RELOC_IA64_PLTOFF64MSB,
  BFD_RELOC_IA64_PLTOFF64LSB,
  BFD_RELOC_IA64_FPTR64I,
  BFD_RELOC_IA64_FPTR32MSB,
  BFD_RELOC_IA64_FPTR32LSB,
  BFD_RELOC_IA64_FPTR64MSB,
  BFD_RELOC_IA64_FPTR64LSB,
  BFD_RELOC_IA64_PCREL21B,
  BFD_RELOC_IA64_PCREL21BI,
  BFD_RELOC_IA64_PCREL21M,
  BFD_RELOC_IA64_PCREL21F,
  BFD_RELOC_IA64_PCREL22,
  BFD_RELOC_IA64_PCREL60B,
  BFD_RELOC_IA64_PCREL64I,
  BFD_RELOC_IA64_PCREL32MSB,
  BFD_RELOC_IA64_PCREL32LSB,
  BFD_RELOC_IA64_PCREL64MSB,
  BFD_RELOC_IA64_PCREL64LSB,
  BFD_RELOC_IA64_LTOFF_FPTR22,
  BFD_RELOC_IA64_LTOFF_FPTR64I,
  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
  BFD_RELOC_IA64_SEGREL32MSB,
  BFD_RELOC_IA64_SEGREL32LSB,
  BFD_RELOC_IA64_SEGREL64MSB,
  BFD_RELOC_IA64_SEGREL64LSB,
  BFD_RELOC_IA64_SECREL32MSB,
  BFD_RELOC_IA64_SECREL32LSB,
  BFD_RELOC_IA64_SECREL64MSB,
  BFD_RELOC_IA64_SECREL64LSB,
  BFD_RELOC_IA64_REL32MSB,
  BFD_RELOC_IA64_REL32LSB,
  BFD_RELOC_IA64_REL64MSB,
  BFD_RELOC_IA64_REL64LSB,
  BFD_RELOC_IA64_LTV32MSB,
  BFD_RELOC_IA64_LTV32LSB,
  BFD_RELOC_IA64_LTV64MSB,
  BFD_RELOC_IA64_LTV64LSB,
  BFD_RELOC_IA64_IPLTMSB,
  BFD_RELOC_IA64_IPLTLSB,
  BFD_RELOC_IA64_COPY,
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,
  BFD_RELOC_IA64_TPREL14,
  BFD_RELOC_IA64_TPREL22,
  BFD_RELOC_IA64_TPREL64I,
  BFD_RELOC_IA64_TPREL64MSB,
  BFD_RELOC_IA64_TPREL64LSB,
  BFD_RELOC_IA64_LTOFF_TPREL22,
  BFD_RELOC_IA64_DTPMOD64MSB,
  BFD_RELOC_IA64_DTPMOD64LSB,
  BFD_RELOC_IA64_LTOFF_DTPMOD22,
  BFD_RELOC_IA64_DTPREL14,
  BFD_RELOC_IA64_DTPREL22,
  BFD_RELOC_IA64_DTPREL64I,
  BFD_RELOC_IA64_DTPREL32MSB,
  BFD_RELOC_IA64_DTPREL32LSB,
  BFD_RELOC_IA64_DTPREL64MSB,
  BFD_RELOC_IA64_DTPREL64LSB,
  BFD_RELOC_IA64_LTOFF_DTPREL22,



  BFD_RELOC_M68HC11_HI8,



  BFD_RELOC_M68HC11_LO8,



  BFD_RELOC_M68HC11_3B,






  BFD_RELOC_M68HC11_RL_JUMP,





  BFD_RELOC_M68HC11_RL_GROUP,





  BFD_RELOC_M68HC11_LO16,





  BFD_RELOC_M68HC11_PAGE,





  BFD_RELOC_M68HC11_24,



  BFD_RELOC_M68HC12_5B,



  BFD_RELOC_XGATE_RL_JUMP,





  BFD_RELOC_XGATE_RL_GROUP,




  BFD_RELOC_XGATE_LO16,


  BFD_RELOC_XGATE_GPAGE,


  BFD_RELOC_XGATE_24,



  BFD_RELOC_XGATE_PCREL_9,



  BFD_RELOC_XGATE_PCREL_10,




  BFD_RELOC_XGATE_IMM8_LO,




  BFD_RELOC_XGATE_IMM8_HI,



  BFD_RELOC_XGATE_IMM3,



  BFD_RELOC_XGATE_IMM4,



  BFD_RELOC_XGATE_IMM5,



  BFD_RELOC_M68HC12_9B,



  BFD_RELOC_M68HC12_16B,



  BFD_RELOC_M68HC12_9_PCREL,



  BFD_RELOC_M68HC12_10_PCREL,




  BFD_RELOC_M68HC12_LO8XG,




  BFD_RELOC_M68HC12_HI8XG,


  BFD_RELOC_16C_NUM08,
  BFD_RELOC_16C_NUM08_C,
  BFD_RELOC_16C_NUM16,
  BFD_RELOC_16C_NUM16_C,
  BFD_RELOC_16C_NUM32,
  BFD_RELOC_16C_NUM32_C,
  BFD_RELOC_16C_DISP04,
  BFD_RELOC_16C_DISP04_C,
  BFD_RELOC_16C_DISP08,
  BFD_RELOC_16C_DISP08_C,
  BFD_RELOC_16C_DISP16,
  BFD_RELOC_16C_DISP16_C,
  BFD_RELOC_16C_DISP24,
  BFD_RELOC_16C_DISP24_C,
  BFD_RELOC_16C_DISP24a,
  BFD_RELOC_16C_DISP24a_C,
  BFD_RELOC_16C_REG04,
  BFD_RELOC_16C_REG04_C,
  BFD_RELOC_16C_REG04a,
  BFD_RELOC_16C_REG04a_C,
  BFD_RELOC_16C_REG14,
  BFD_RELOC_16C_REG14_C,
  BFD_RELOC_16C_REG16,
  BFD_RELOC_16C_REG16_C,
  BFD_RELOC_16C_REG20,
  BFD_RELOC_16C_REG20_C,
  BFD_RELOC_16C_ABS20,
  BFD_RELOC_16C_ABS20_C,
  BFD_RELOC_16C_ABS24,
  BFD_RELOC_16C_ABS24_C,
  BFD_RELOC_16C_IMM04,
  BFD_RELOC_16C_IMM04_C,
  BFD_RELOC_16C_IMM16,
  BFD_RELOC_16C_IMM16_C,
  BFD_RELOC_16C_IMM20,
  BFD_RELOC_16C_IMM20_C,
  BFD_RELOC_16C_IMM24,
  BFD_RELOC_16C_IMM24_C,
  BFD_RELOC_16C_IMM32,
  BFD_RELOC_16C_IMM32_C,


  BFD_RELOC_CR16_NUM8,
  BFD_RELOC_CR16_NUM16,
  BFD_RELOC_CR16_NUM32,
  BFD_RELOC_CR16_NUM32a,
  BFD_RELOC_CR16_REGREL0,
  BFD_RELOC_CR16_REGREL4,
  BFD_RELOC_CR16_REGREL4a,
  BFD_RELOC_CR16_REGREL14,
  BFD_RELOC_CR16_REGREL14a,
  BFD_RELOC_CR16_REGREL16,
  BFD_RELOC_CR16_REGREL20,
  BFD_RELOC_CR16_REGREL20a,
  BFD_RELOC_CR16_ABS20,
  BFD_RELOC_CR16_ABS24,
  BFD_RELOC_CR16_IMM4,
  BFD_RELOC_CR16_IMM8,
  BFD_RELOC_CR16_IMM16,
  BFD_RELOC_CR16_IMM20,
  BFD_RELOC_CR16_IMM24,
  BFD_RELOC_CR16_IMM32,
  BFD_RELOC_CR16_IMM32a,
  BFD_RELOC_CR16_DISP4,
  BFD_RELOC_CR16_DISP8,
  BFD_RELOC_CR16_DISP16,
  BFD_RELOC_CR16_DISP20,
  BFD_RELOC_CR16_DISP24,
  BFD_RELOC_CR16_DISP24a,
  BFD_RELOC_CR16_SWITCH8,
  BFD_RELOC_CR16_SWITCH16,
  BFD_RELOC_CR16_SWITCH32,
  BFD_RELOC_CR16_GOT_REGREL20,
  BFD_RELOC_CR16_GOTC_REGREL20,
  BFD_RELOC_CR16_GLOB_DAT,


  BFD_RELOC_CRX_REL4,
  BFD_RELOC_CRX_REL8,
  BFD_RELOC_CRX_REL8_CMP,
  BFD_RELOC_CRX_REL16,
  BFD_RELOC_CRX_REL24,
  BFD_RELOC_CRX_REL32,
  BFD_RELOC_CRX_REGREL12,
  BFD_RELOC_CRX_REGREL22,
  BFD_RELOC_CRX_REGREL28,
  BFD_RELOC_CRX_REGREL32,
  BFD_RELOC_CRX_ABS16,
  BFD_RELOC_CRX_ABS32,
  BFD_RELOC_CRX_NUM8,
  BFD_RELOC_CRX_NUM16,
  BFD_RELOC_CRX_NUM32,
  BFD_RELOC_CRX_IMM16,
  BFD_RELOC_CRX_IMM32,
  BFD_RELOC_CRX_SWITCH8,
  BFD_RELOC_CRX_SWITCH16,
  BFD_RELOC_CRX_SWITCH32,



  BFD_RELOC_CRIS_BDISP8,
  BFD_RELOC_CRIS_UNSIGNED_5,
  BFD_RELOC_CRIS_SIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_6,
  BFD_RELOC_CRIS_SIGNED_8,
  BFD_RELOC_CRIS_UNSIGNED_8,
  BFD_RELOC_CRIS_SIGNED_16,
  BFD_RELOC_CRIS_UNSIGNED_16,
  BFD_RELOC_CRIS_LAPCQ_OFFSET,
  BFD_RELOC_CRIS_UNSIGNED_4,


  BFD_RELOC_CRIS_COPY,
  BFD_RELOC_CRIS_GLOB_DAT,
  BFD_RELOC_CRIS_JUMP_SLOT,
  BFD_RELOC_CRIS_RELATIVE,


  BFD_RELOC_CRIS_32_GOT,


  BFD_RELOC_CRIS_16_GOT,


  BFD_RELOC_CRIS_32_GOTPLT,


  BFD_RELOC_CRIS_16_GOTPLT,


  BFD_RELOC_CRIS_32_GOTREL,


  BFD_RELOC_CRIS_32_PLT_GOTREL,


  BFD_RELOC_CRIS_32_PLT_PCREL,


  BFD_RELOC_CRIS_32_GOT_GD,
  BFD_RELOC_CRIS_16_GOT_GD,
  BFD_RELOC_CRIS_32_GD,
  BFD_RELOC_CRIS_DTP,
  BFD_RELOC_CRIS_32_DTPREL,
  BFD_RELOC_CRIS_16_DTPREL,
  BFD_RELOC_CRIS_32_GOT_TPREL,
  BFD_RELOC_CRIS_16_GOT_TPREL,
  BFD_RELOC_CRIS_32_TPREL,
  BFD_RELOC_CRIS_16_TPREL,
  BFD_RELOC_CRIS_DTPMOD,
  BFD_RELOC_CRIS_32_IE,


  BFD_RELOC_860_COPY,
  BFD_RELOC_860_GLOB_DAT,
  BFD_RELOC_860_JUMP_SLOT,
  BFD_RELOC_860_RELATIVE,
  BFD_RELOC_860_PC26,
  BFD_RELOC_860_PLT26,
  BFD_RELOC_860_PC16,
  BFD_RELOC_860_LOW0,
  BFD_RELOC_860_SPLIT0,
  BFD_RELOC_860_LOW1,
  BFD_RELOC_860_SPLIT1,
  BFD_RELOC_860_LOW2,
  BFD_RELOC_860_SPLIT2,
  BFD_RELOC_860_LOW3,
  BFD_RELOC_860_LOGOT0,
  BFD_RELOC_860_SPGOT0,
  BFD_RELOC_860_LOGOT1,
  BFD_RELOC_860_SPGOT1,
  BFD_RELOC_860_LOGOTOFF0,
  BFD_RELOC_860_SPGOTOFF0,
  BFD_RELOC_860_LOGOTOFF1,
  BFD_RELOC_860_SPGOTOFF1,
  BFD_RELOC_860_LOGOTOFF2,
  BFD_RELOC_860_LOGOTOFF3,
  BFD_RELOC_860_LOPC,
  BFD_RELOC_860_HIGHADJ,
  BFD_RELOC_860_HAGOT,
  BFD_RELOC_860_HAGOTOFF,
  BFD_RELOC_860_HAPC,
  BFD_RELOC_860_HIGH,
  BFD_RELOC_860_HIGOT,
  BFD_RELOC_860_HIGOTOFF,


  BFD_RELOC_OR1K_REL_26,
  BFD_RELOC_OR1K_GOTPC_HI16,
  BFD_RELOC_OR1K_GOTPC_LO16,
  BFD_RELOC_OR1K_GOT16,
  BFD_RELOC_OR1K_PLT26,
  BFD_RELOC_OR1K_GOTOFF_HI16,
  BFD_RELOC_OR1K_GOTOFF_LO16,
  BFD_RELOC_OR1K_COPY,
  BFD_RELOC_OR1K_GLOB_DAT,
  BFD_RELOC_OR1K_JMP_SLOT,
  BFD_RELOC_OR1K_RELATIVE,
  BFD_RELOC_OR1K_TLS_GD_HI16,
  BFD_RELOC_OR1K_TLS_GD_LO16,
  BFD_RELOC_OR1K_TLS_LDM_HI16,
  BFD_RELOC_OR1K_TLS_LDM_LO16,
  BFD_RELOC_OR1K_TLS_LDO_HI16,
  BFD_RELOC_OR1K_TLS_LDO_LO16,
  BFD_RELOC_OR1K_TLS_IE_HI16,
  BFD_RELOC_OR1K_TLS_IE_LO16,
  BFD_RELOC_OR1K_TLS_LE_HI16,
  BFD_RELOC_OR1K_TLS_LE_LO16,
  BFD_RELOC_OR1K_TLS_TPOFF,
  BFD_RELOC_OR1K_TLS_DTPOFF,
  BFD_RELOC_OR1K_TLS_DTPMOD,


  BFD_RELOC_H8_DIR16A8,
  BFD_RELOC_H8_DIR16R8,
  BFD_RELOC_H8_DIR24A8,
  BFD_RELOC_H8_DIR24R8,
  BFD_RELOC_H8_DIR32A16,
  BFD_RELOC_H8_DISP32A16,


  BFD_RELOC_XSTORMY16_REL_12,
  BFD_RELOC_XSTORMY16_12,
  BFD_RELOC_XSTORMY16_24,
  BFD_RELOC_XSTORMY16_FPTR16,


  BFD_RELOC_RELC,



  BFD_RELOC_XC16X_PAG,
  BFD_RELOC_XC16X_POF,
  BFD_RELOC_XC16X_SEG,
  BFD_RELOC_XC16X_SOF,


  BFD_RELOC_VAX_GLOB_DAT,
  BFD_RELOC_VAX_JMP_SLOT,
  BFD_RELOC_VAX_RELATIVE,


  BFD_RELOC_MT_PC16,


  BFD_RELOC_MT_HI16,


  BFD_RELOC_MT_LO16,


  BFD_RELOC_MT_GNU_VTINHERIT,


  BFD_RELOC_MT_GNU_VTENTRY,


  BFD_RELOC_MT_PCINSN8,


  BFD_RELOC_MSP430_10_PCREL,
  BFD_RELOC_MSP430_16_PCREL,
  BFD_RELOC_MSP430_16,
  BFD_RELOC_MSP430_16_PCREL_BYTE,
  BFD_RELOC_MSP430_16_BYTE,
  BFD_RELOC_MSP430_2X_PCREL,
  BFD_RELOC_MSP430_RL_PCREL,
  BFD_RELOC_MSP430_ABS8,
  BFD_RELOC_MSP430X_PCR20_EXT_SRC,
  BFD_RELOC_MSP430X_PCR20_EXT_DST,
  BFD_RELOC_MSP430X_PCR20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_EXT_SRC,
  BFD_RELOC_MSP430X_ABS20_EXT_DST,
  BFD_RELOC_MSP430X_ABS20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_ADR_SRC,
  BFD_RELOC_MSP430X_ABS20_ADR_DST,
  BFD_RELOC_MSP430X_PCR16,
  BFD_RELOC_MSP430X_PCR20_CALL,
  BFD_RELOC_MSP430X_ABS16,
  BFD_RELOC_MSP430_ABS_HI16,
  BFD_RELOC_MSP430_PREL31,
  BFD_RELOC_MSP430_SYM_DIFF,


  BFD_RELOC_NIOS2_S16,
  BFD_RELOC_NIOS2_U16,
  BFD_RELOC_NIOS2_CALL26,
  BFD_RELOC_NIOS2_IMM5,
  BFD_RELOC_NIOS2_CACHE_OPX,
  BFD_RELOC_NIOS2_IMM6,
  BFD_RELOC_NIOS2_IMM8,
  BFD_RELOC_NIOS2_HI16,
  BFD_RELOC_NIOS2_LO16,
  BFD_RELOC_NIOS2_HIADJ16,
  BFD_RELOC_NIOS2_GPREL,
  BFD_RELOC_NIOS2_UJMP,
  BFD_RELOC_NIOS2_CJMP,
  BFD_RELOC_NIOS2_CALLR,
  BFD_RELOC_NIOS2_ALIGN,
  BFD_RELOC_NIOS2_GOT16,
  BFD_RELOC_NIOS2_CALL16,
  BFD_RELOC_NIOS2_GOTOFF_LO,
  BFD_RELOC_NIOS2_GOTOFF_HA,
  BFD_RELOC_NIOS2_PCREL_LO,
  BFD_RELOC_NIOS2_PCREL_HA,
  BFD_RELOC_NIOS2_TLS_GD16,
  BFD_RELOC_NIOS2_TLS_LDM16,
  BFD_RELOC_NIOS2_TLS_LDO16,
  BFD_RELOC_NIOS2_TLS_IE16,
  BFD_RELOC_NIOS2_TLS_LE16,
  BFD_RELOC_NIOS2_TLS_DTPMOD,
  BFD_RELOC_NIOS2_TLS_DTPREL,
  BFD_RELOC_NIOS2_TLS_TPREL,
  BFD_RELOC_NIOS2_COPY,
  BFD_RELOC_NIOS2_GLOB_DAT,
  BFD_RELOC_NIOS2_JUMP_SLOT,
  BFD_RELOC_NIOS2_RELATIVE,
  BFD_RELOC_NIOS2_GOTOFF,
  BFD_RELOC_NIOS2_CALL26_NOAT,
  BFD_RELOC_NIOS2_GOT_LO,
  BFD_RELOC_NIOS2_GOT_HA,
  BFD_RELOC_NIOS2_CALL_LO,
  BFD_RELOC_NIOS2_CALL_HA,
  BFD_RELOC_NIOS2_R2_S12,
  BFD_RELOC_NIOS2_R2_I10_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_2,
  BFD_RELOC_NIOS2_R2_T2I4,
  BFD_RELOC_NIOS2_R2_T2I4_1,
  BFD_RELOC_NIOS2_R2_T2I4_2,
  BFD_RELOC_NIOS2_R2_X1I7_2,
  BFD_RELOC_NIOS2_R2_X2L5,
  BFD_RELOC_NIOS2_R2_F1I5_2,
  BFD_RELOC_NIOS2_R2_L5I4X1,
  BFD_RELOC_NIOS2_R2_T1X1I6,
  BFD_RELOC_NIOS2_R2_T1X1I6_2,


  BFD_RELOC_PRU_U16,


  BFD_RELOC_PRU_U16_PMEMIMM,




  BFD_RELOC_PRU_LDI32,


  BFD_RELOC_PRU_S10_PCREL,


  BFD_RELOC_PRU_U8_PCREL,



  BFD_RELOC_PRU_32_PMEM,
  BFD_RELOC_PRU_16_PMEM,
# 5598 "../bfd/bfd.h"
  BFD_RELOC_PRU_GNU_DIFF8,
  BFD_RELOC_PRU_GNU_DIFF16,
  BFD_RELOC_PRU_GNU_DIFF32,
  BFD_RELOC_PRU_GNU_DIFF16_PMEM,
  BFD_RELOC_PRU_GNU_DIFF32_PMEM,


  BFD_RELOC_IQ2000_OFFSET_16,
  BFD_RELOC_IQ2000_OFFSET_21,
  BFD_RELOC_IQ2000_UHI16,




  BFD_RELOC_XTENSA_RTLD,


  BFD_RELOC_XTENSA_GLOB_DAT,
  BFD_RELOC_XTENSA_JMP_SLOT,
  BFD_RELOC_XTENSA_RELATIVE,



  BFD_RELOC_XTENSA_PLT,







  BFD_RELOC_XTENSA_DIFF8,
  BFD_RELOC_XTENSA_DIFF16,
  BFD_RELOC_XTENSA_DIFF32,





  BFD_RELOC_XTENSA_SLOT0_OP,
  BFD_RELOC_XTENSA_SLOT1_OP,
  BFD_RELOC_XTENSA_SLOT2_OP,
  BFD_RELOC_XTENSA_SLOT3_OP,
  BFD_RELOC_XTENSA_SLOT4_OP,
  BFD_RELOC_XTENSA_SLOT5_OP,
  BFD_RELOC_XTENSA_SLOT6_OP,
  BFD_RELOC_XTENSA_SLOT7_OP,
  BFD_RELOC_XTENSA_SLOT8_OP,
  BFD_RELOC_XTENSA_SLOT9_OP,
  BFD_RELOC_XTENSA_SLOT10_OP,
  BFD_RELOC_XTENSA_SLOT11_OP,
  BFD_RELOC_XTENSA_SLOT12_OP,
  BFD_RELOC_XTENSA_SLOT13_OP,
  BFD_RELOC_XTENSA_SLOT14_OP,



  BFD_RELOC_XTENSA_SLOT0_ALT,
  BFD_RELOC_XTENSA_SLOT1_ALT,
  BFD_RELOC_XTENSA_SLOT2_ALT,
  BFD_RELOC_XTENSA_SLOT3_ALT,
  BFD_RELOC_XTENSA_SLOT4_ALT,
  BFD_RELOC_XTENSA_SLOT5_ALT,
  BFD_RELOC_XTENSA_SLOT6_ALT,
  BFD_RELOC_XTENSA_SLOT7_ALT,
  BFD_RELOC_XTENSA_SLOT8_ALT,
  BFD_RELOC_XTENSA_SLOT9_ALT,
  BFD_RELOC_XTENSA_SLOT10_ALT,
  BFD_RELOC_XTENSA_SLOT11_ALT,
  BFD_RELOC_XTENSA_SLOT12_ALT,
  BFD_RELOC_XTENSA_SLOT13_ALT,
  BFD_RELOC_XTENSA_SLOT14_ALT,



  BFD_RELOC_XTENSA_OP0,
  BFD_RELOC_XTENSA_OP1,
  BFD_RELOC_XTENSA_OP2,




  BFD_RELOC_XTENSA_ASM_EXPAND,





  BFD_RELOC_XTENSA_ASM_SIMPLIFY,


  BFD_RELOC_XTENSA_TLSDESC_FN,
  BFD_RELOC_XTENSA_TLSDESC_ARG,
  BFD_RELOC_XTENSA_TLS_DTPOFF,
  BFD_RELOC_XTENSA_TLS_TPOFF,
  BFD_RELOC_XTENSA_TLS_FUNC,
  BFD_RELOC_XTENSA_TLS_ARG,
  BFD_RELOC_XTENSA_TLS_CALL,


  BFD_RELOC_Z80_DISP8,


  BFD_RELOC_Z8K_DISP7,


  BFD_RELOC_Z8K_CALLR,


  BFD_RELOC_Z8K_IMM4L,


  BFD_RELOC_LM32_CALL,
  BFD_RELOC_LM32_BRANCH,
  BFD_RELOC_LM32_16_GOT,
  BFD_RELOC_LM32_GOTOFF_HI16,
  BFD_RELOC_LM32_GOTOFF_LO16,
  BFD_RELOC_LM32_COPY,
  BFD_RELOC_LM32_GLOB_DAT,
  BFD_RELOC_LM32_JMP_SLOT,
  BFD_RELOC_LM32_RELATIVE,



  BFD_RELOC_MACH_O_SECTDIFF,


  BFD_RELOC_MACH_O_LOCAL_SECTDIFF,


  BFD_RELOC_MACH_O_PAIR,


  BFD_RELOC_MACH_O_SUBTRACTOR32,


  BFD_RELOC_MACH_O_SUBTRACTOR64,



  BFD_RELOC_MACH_O_X86_64_BRANCH32,
  BFD_RELOC_MACH_O_X86_64_BRANCH8,


  BFD_RELOC_MACH_O_X86_64_GOT,



  BFD_RELOC_MACH_O_X86_64_GOT_LOAD,


  BFD_RELOC_MACH_O_X86_64_PCREL32_1,


  BFD_RELOC_MACH_O_X86_64_PCREL32_2,


  BFD_RELOC_MACH_O_X86_64_PCREL32_4,


  BFD_RELOC_MACH_O_ARM64_ADDEND,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12,


  BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT,



  BFD_RELOC_MICROBLAZE_32_LO,



  BFD_RELOC_MICROBLAZE_32_LO_PCREL,



  BFD_RELOC_MICROBLAZE_32_ROSDA,



  BFD_RELOC_MICROBLAZE_32_RWSDA,



  BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM,




  BFD_RELOC_MICROBLAZE_64_NONE,




  BFD_RELOC_MICROBLAZE_64_GOTPC,




  BFD_RELOC_MICROBLAZE_64_GOT,




  BFD_RELOC_MICROBLAZE_64_PLT,




  BFD_RELOC_MICROBLAZE_64_GOTOFF,



  BFD_RELOC_MICROBLAZE_32_GOTOFF,



  BFD_RELOC_MICROBLAZE_COPY,


  BFD_RELOC_MICROBLAZE_64_TLS,




  BFD_RELOC_MICROBLAZE_64_TLSGD,




  BFD_RELOC_MICROBLAZE_64_TLSLD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPMOD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSTPREL,





  BFD_RELOC_AARCH64_RELOC_START,


  BFD_RELOC_AARCH64_NULL,


  BFD_RELOC_AARCH64_NONE,




  BFD_RELOC_AARCH64_64,
  BFD_RELOC_AARCH64_32,
  BFD_RELOC_AARCH64_16,



  BFD_RELOC_AARCH64_64_PCREL,
  BFD_RELOC_AARCH64_32_PCREL,
  BFD_RELOC_AARCH64_16_PCREL,



  BFD_RELOC_AARCH64_MOVW_G0,



  BFD_RELOC_AARCH64_MOVW_G0_NC,



  BFD_RELOC_AARCH64_MOVW_G1,



  BFD_RELOC_AARCH64_MOVW_G1_NC,



  BFD_RELOC_AARCH64_MOVW_G2,



  BFD_RELOC_AARCH64_MOVW_G2_NC,



  BFD_RELOC_AARCH64_MOVW_G3,




  BFD_RELOC_AARCH64_MOVW_G0_S,




  BFD_RELOC_AARCH64_MOVW_G1_S,




  BFD_RELOC_AARCH64_MOVW_G2_S,




  BFD_RELOC_AARCH64_LD_LO19_PCREL,


  BFD_RELOC_AARCH64_ADR_LO21_PCREL,



  BFD_RELOC_AARCH64_ADR_HI21_PCREL,




  BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL,



  BFD_RELOC_AARCH64_ADD_LO12,



  BFD_RELOC_AARCH64_LDST8_LO12,




  BFD_RELOC_AARCH64_TSTBR14,




  BFD_RELOC_AARCH64_BRANCH19,




  BFD_RELOC_AARCH64_JUMP26,




  BFD_RELOC_AARCH64_CALL26,



  BFD_RELOC_AARCH64_LDST16_LO12,



  BFD_RELOC_AARCH64_LDST32_LO12,



  BFD_RELOC_AARCH64_LDST64_LO12,



  BFD_RELOC_AARCH64_LDST128_LO12,






  BFD_RELOC_AARCH64_GOT_LD_PREL19,




  BFD_RELOC_AARCH64_ADR_GOT_PAGE,




  BFD_RELOC_AARCH64_LD64_GOT_LO12_NC,




  BFD_RELOC_AARCH64_LD32_GOT_LO12_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G1,



  BFD_RELOC_AARCH64_LD64_GOTOFF_LO15,


  BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14,


  BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15,





  BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSGD_ADR_PREL21,




  BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G1,


  BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21,


  BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC,




  BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSLD_ADR_PREL21,



  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_LD_PREL19,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSDESC_LD64_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_ADD_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G1,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC,


  BFD_RELOC_AARCH64_TLSDESC_LDR,


  BFD_RELOC_AARCH64_TLSDESC_ADD,


  BFD_RELOC_AARCH64_TLSDESC_CALL,


  BFD_RELOC_AARCH64_COPY,


  BFD_RELOC_AARCH64_GLOB_DAT,


  BFD_RELOC_AARCH64_JUMP_SLOT,


  BFD_RELOC_AARCH64_RELATIVE,


  BFD_RELOC_AARCH64_TLS_DTPMOD,


  BFD_RELOC_AARCH64_TLS_DTPREL,


  BFD_RELOC_AARCH64_TLS_TPREL,


  BFD_RELOC_AARCH64_TLSDESC,


  BFD_RELOC_AARCH64_IRELATIVE,






  BFD_RELOC_AARCH64_RELOC_END,



  BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP,



  BFD_RELOC_AARCH64_LDST_LO12,




  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_LD_GOT_LO12_NC,



  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC,


  BFD_RELOC_TILEPRO_COPY,
  BFD_RELOC_TILEPRO_GLOB_DAT,
  BFD_RELOC_TILEPRO_JMP_SLOT,
  BFD_RELOC_TILEPRO_RELATIVE,
  BFD_RELOC_TILEPRO_BROFF_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT,
  BFD_RELOC_TILEPRO_IMM8_X0,
  BFD_RELOC_TILEPRO_IMM8_Y0,
  BFD_RELOC_TILEPRO_IMM8_X1,
  BFD_RELOC_TILEPRO_IMM8_Y1,
  BFD_RELOC_TILEPRO_DEST_IMM8_X1,
  BFD_RELOC_TILEPRO_MT_IMM15_X1,
  BFD_RELOC_TILEPRO_MF_IMM15_X1,
  BFD_RELOC_TILEPRO_IMM16_X0,
  BFD_RELOC_TILEPRO_IMM16_X1,
  BFD_RELOC_TILEPRO_IMM16_X0_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA,
  BFD_RELOC_TILEPRO_MMSTART_X0,
  BFD_RELOC_TILEPRO_MMEND_X0,
  BFD_RELOC_TILEPRO_MMSTART_X1,
  BFD_RELOC_TILEPRO_MMEND_X1,
  BFD_RELOC_TILEPRO_SHAMT_X0,
  BFD_RELOC_TILEPRO_SHAMT_X1,
  BFD_RELOC_TILEPRO_SHAMT_Y0,
  BFD_RELOC_TILEPRO_SHAMT_Y1,
  BFD_RELOC_TILEPRO_TLS_GD_CALL,
  BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_TLS_IE_LOAD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA,
  BFD_RELOC_TILEPRO_TLS_DTPMOD32,
  BFD_RELOC_TILEPRO_TLS_DTPOFF32,
  BFD_RELOC_TILEPRO_TLS_TPOFF32,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA,


  BFD_RELOC_TILEGX_HW0,
  BFD_RELOC_TILEGX_HW1,
  BFD_RELOC_TILEGX_HW2,
  BFD_RELOC_TILEGX_HW3,
  BFD_RELOC_TILEGX_HW0_LAST,
  BFD_RELOC_TILEGX_HW1_LAST,
  BFD_RELOC_TILEGX_HW2_LAST,
  BFD_RELOC_TILEGX_COPY,
  BFD_RELOC_TILEGX_GLOB_DAT,
  BFD_RELOC_TILEGX_JMP_SLOT,
  BFD_RELOC_TILEGX_RELATIVE,
  BFD_RELOC_TILEGX_BROFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1_PLT,
  BFD_RELOC_TILEGX_IMM8_X0,
  BFD_RELOC_TILEGX_IMM8_Y0,
  BFD_RELOC_TILEGX_IMM8_X1,
  BFD_RELOC_TILEGX_IMM8_Y1,
  BFD_RELOC_TILEGX_DEST_IMM8_X1,
  BFD_RELOC_TILEGX_MT_IMM14_X1,
  BFD_RELOC_TILEGX_MF_IMM14_X1,
  BFD_RELOC_TILEGX_MMSTART_X0,
  BFD_RELOC_TILEGX_MMEND_X0,
  BFD_RELOC_TILEGX_SHAMT_X0,
  BFD_RELOC_TILEGX_SHAMT_X1,
  BFD_RELOC_TILEGX_SHAMT_Y0,
  BFD_RELOC_TILEGX_SHAMT_Y1,
  BFD_RELOC_TILEGX_IMM16_X0_HW0,
  BFD_RELOC_TILEGX_IMM16_X1_HW0,
  BFD_RELOC_TILEGX_IMM16_X0_HW1,
  BFD_RELOC_TILEGX_IMM16_X1_HW1,
  BFD_RELOC_TILEGX_IMM16_X0_HW2,
  BFD_RELOC_TILEGX_IMM16_X1_HW2,
  BFD_RELOC_TILEGX_IMM16_X0_HW3,
  BFD_RELOC_TILEGX_IMM16_X1_HW3,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_TLS_DTPMOD64,
  BFD_RELOC_TILEGX_TLS_DTPOFF64,
  BFD_RELOC_TILEGX_TLS_TPOFF64,
  BFD_RELOC_TILEGX_TLS_DTPMOD32,
  BFD_RELOC_TILEGX_TLS_DTPOFF32,
  BFD_RELOC_TILEGX_TLS_TPOFF32,
  BFD_RELOC_TILEGX_TLS_GD_CALL,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_TLS_IE_LOAD,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD,


  BFD_RELOC_EPIPHANY_SIMM8,


  BFD_RELOC_EPIPHANY_SIMM24,


  BFD_RELOC_EPIPHANY_HIGH,


  BFD_RELOC_EPIPHANY_LOW,


  BFD_RELOC_EPIPHANY_SIMM11,


  BFD_RELOC_EPIPHANY_IMM11,


  BFD_RELOC_EPIPHANY_IMM8,


  BFD_RELOC_VISIUM_HI16,
  BFD_RELOC_VISIUM_LO16,
  BFD_RELOC_VISIUM_IM16,
  BFD_RELOC_VISIUM_REL16,
  BFD_RELOC_VISIUM_HI16_PCREL,
  BFD_RELOC_VISIUM_LO16_PCREL,
  BFD_RELOC_VISIUM_IM16_PCREL,
  BFD_RELOC_UNUSED };

typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
reloc_howto_type *bfd_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code);
reloc_howto_type *bfd_reloc_name_lookup
   (bfd *abfd, const char *reloc_name);

const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);



typedef struct bfd_symbol
{
# 6487 "../bfd/bfd.h"
  struct bfd *the_bfd;



  const char *name;




  symvalue value;
# 6602 "../bfd/bfd.h"
  flagword flags;




  struct bfd_section *section;


  union
    {
      void *p;
      bfd_vma i;
    }
  udata;
}
asymbol;




bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);

bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);




bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);







bfd_boolean bfd_set_symtab
   (bfd *abfd, asymbol **location, unsigned int count);

void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);




asymbol *_bfd_generic_make_empty_symbol (bfd *);




int bfd_decode_symclass (asymbol *symbol);

bfd_boolean bfd_is_undefined_symclass (int symclass);

void bfd_symbol_info (asymbol *symbol, symbol_info *ret);

bfd_boolean bfd_copy_private_symbol_data
   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);







enum bfd_direction
  {
    no_direction = 0,
    read_direction = 1,
    write_direction = 2,
    both_direction = 3
  };

enum bfd_plugin_format
  {
    bfd_plugin_unknown = 0,
    bfd_plugin_yes = 1,
    bfd_plugin_no = 2
  };

struct bfd_build_id
  {
    bfd_size_type size;
    bfd_byte data[1];
  };

struct bfd
{

  const char *filename;


  const struct bfd_target *xvec;



  void *iostream;
  const struct bfd_iovec *iovec;



  struct bfd *lru_prev, *lru_next;



  ufile_ptr where;


  long mtime;


  unsigned int id;


  __extension__ enum bfd_format format : 3;


  __extension__ enum bfd_direction direction : 2;


  flagword flags : 20;
# 6820 "../bfd/bfd.h"
  unsigned int cacheable : 1;




  unsigned int target_defaulted : 1;


  unsigned int opened_once : 1;



  unsigned int mtime_set : 1;


  unsigned int no_export : 1;



  unsigned int output_has_begun : 1;


  unsigned int has_armap : 1;


  unsigned int is_thin_archive : 1;



  unsigned int selective_search : 1;


  unsigned int is_linker_output : 1;


  unsigned int is_linker_input : 1;


  __extension__ enum bfd_plugin_format plugin_format : 2;


  unsigned int lto_output : 1;



  bfd *plugin_dummy_bfd;




  ufile_ptr origin;






  ufile_ptr proxy_origin;


  struct bfd_hash_table section_htab;


  struct bfd_section *sections;


  struct bfd_section *section_last;


  unsigned int section_count;



  int archive_pass;



  bfd_vma start_address;



  struct bfd_symbol **outsymbols;


  unsigned int symcount;


  unsigned int dynsymcount;


  const struct bfd_arch_info *arch_info;


  void *arelt_data;
  struct bfd *my_archive;
  struct bfd *archive_next;
  struct bfd *archive_head;
  struct bfd *nested_archives;


  union {

    struct bfd *next;

    struct bfd_link_hash_table *hash;
  } link;


  union
    {
      struct aout_data_struct *aout_data;
      struct artdata *aout_ar_data;
      struct _oasys_data *oasys_obj_data;
      struct _oasys_ar_data *oasys_ar_data;
      struct coff_tdata *coff_obj_data;
      struct pe_tdata *pe_obj_data;
      struct xcoff_tdata *xcoff_obj_data;
      struct ecoff_tdata *ecoff_obj_data;
      struct ieee_data_struct *ieee_data;
      struct ieee_ar_data_struct *ieee_ar_data;
      struct srec_data_struct *srec_data;
      struct verilog_data_struct *verilog_data;
      struct ihex_data_struct *ihex_data;
      struct tekhex_data_struct *tekhex_data;
      struct elf_obj_tdata *elf_obj_data;
      struct nlm_obj_tdata *nlm_obj_data;
      struct bout_data_struct *bout_data;
      struct mmo_data_struct *mmo_data;
      struct sun_core_struct *sun_core_data;
      struct sco5_core_struct *sco5_core_data;
      struct trad_core_struct *trad_core_data;
      struct som_data_struct *som_data;
      struct hpux_core_struct *hpux_core_data;
      struct hppabsd_core_struct *hppabsd_core_data;
      struct sgi_core_struct *sgi_core_data;
      struct lynx_core_struct *lynx_core_data;
      struct osf_core_struct *osf_core_data;
      struct cisco_core_struct *cisco_core_data;
      struct versados_data_struct *versados_data;
      struct netbsd_core_struct *netbsd_core_data;
      struct mach_o_data_struct *mach_o_data;
      struct mach_o_fat_data_struct *mach_o_fat_data;
      struct plugin_data_struct *plugin_data;
      struct bfd_pef_data_struct *pef_data;
      struct bfd_pef_xlib_data_struct *pef_xlib_data;
      struct bfd_sym_data_struct *sym_data;
      void *any;
    }
  tdata;


  void *usrdata;




  void *memory;


  const struct bfd_build_id *build_id;
};


static inline bfd_boolean
bfd_set_cacheable (bfd * abfd, bfd_boolean val)
{
  abfd->cacheable = val;
  return 1;
}


typedef enum bfd_error
{
  bfd_error_no_error = 0,
  bfd_error_system_call,
  bfd_error_invalid_target,
  bfd_error_wrong_format,
  bfd_error_wrong_object_format,
  bfd_error_invalid_operation,
  bfd_error_no_memory,
  bfd_error_no_symbols,
  bfd_error_no_armap,
  bfd_error_no_more_archived_files,
  bfd_error_malformed_archive,
  bfd_error_missing_dso,
  bfd_error_file_not_recognized,
  bfd_error_file_ambiguously_recognized,
  bfd_error_no_contents,
  bfd_error_nonrepresentable_section,
  bfd_error_no_debug_section,
  bfd_error_bad_value,
  bfd_error_file_truncated,
  bfd_error_file_too_big,
  bfd_error_on_input,
  bfd_error_invalid_error_code
}
bfd_error_type;

bfd_error_type bfd_get_error (void);

void bfd_set_error (bfd_error_type error_tag, ...);

const char *bfd_errmsg (bfd_error_type error_tag);

void bfd_perror (const char *message);


typedef void (*bfd_error_handler_type) (const char *, va_list);

bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);

void bfd_set_error_program_name (const char *);


typedef void (*bfd_assert_handler_type) (const char *bfd_formatmsg,
                                         const char *bfd_version,
                                         const char *bfd_file,
                                         int bfd_line);

bfd_assert_handler_type bfd_set_assert_handler (bfd_assert_handler_type);

long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);

long bfd_canonicalize_reloc
   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);

void bfd_set_reloc
   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);

bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);

int bfd_get_arch_size (bfd *abfd);

int bfd_get_sign_extend_vma (bfd *abfd);

bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);

unsigned int bfd_get_gp_size (bfd *abfd);

void bfd_set_gp_size (bfd *abfd, unsigned int i);

bfd_vma bfd_scan_vma (const char *string, const char **end, int base);

bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);




bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);




bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
# 7167 "../bfd/bfd.h"
extern bfd_byte *bfd_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);

bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);

bfd_vma bfd_emul_get_maxpagesize (const char *);

void bfd_emul_set_maxpagesize (const char *, bfd_vma);

bfd_vma bfd_emul_get_commonpagesize (const char *);

void bfd_emul_set_commonpagesize (const char *, bfd_vma);

char *bfd_demangle (bfd *, const char *, int);

void bfd_update_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec);

bfd_boolean bfd_check_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec,
    bfd_size_type *uncompressed_size);

int bfd_get_compression_header_size (bfd *abfd, asection *sec);

bfd_size_type bfd_convert_section_size
   (bfd *ibfd, asection *isec, bfd *obfd, bfd_size_type size);

bfd_boolean bfd_convert_section_contents
   (bfd *ibfd, asection *isec, bfd *obfd,
    bfd_byte **ptr, bfd_size_type *ptr_size);


symindex bfd_get_next_mapent
   (bfd *abfd, symindex previous, carsym **sym);

bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);

bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);


const char *bfd_core_file_failing_command (bfd *abfd);

int bfd_core_file_failing_signal (bfd *abfd);

int bfd_core_file_pid (bfd *abfd);

bfd_boolean core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);

bfd_boolean generic_core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);
# 7242 "../bfd/bfd.h"
enum bfd_flavour
{

  bfd_target_unknown_flavour,
  bfd_target_aout_flavour,
  bfd_target_coff_flavour,
  bfd_target_ecoff_flavour,
  bfd_target_xcoff_flavour,
  bfd_target_elf_flavour,
  bfd_target_ieee_flavour,
  bfd_target_nlm_flavour,
  bfd_target_oasys_flavour,
  bfd_target_tekhex_flavour,
  bfd_target_srec_flavour,
  bfd_target_verilog_flavour,
  bfd_target_ihex_flavour,
  bfd_target_som_flavour,
  bfd_target_os9k_flavour,
  bfd_target_versados_flavour,
  bfd_target_msdos_flavour,
  bfd_target_ovax_flavour,
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
};

enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };


typedef struct bfd_link_info _bfd_link_info;


typedef struct flag_info flag_info;

typedef struct bfd_target
{

  char *name;



  enum bfd_flavour flavour;


  enum bfd_endian byteorder;


  enum bfd_endian header_byteorder;



  flagword object_flags;



  flagword section_flags;



  char symbol_leading_char;


  char ar_pad_char;


  unsigned char ar_max_namelen;



  unsigned char match_priority;




  bfd_uint64_t (*bfd_getx64) (const void *);
  bfd_int64_t (*bfd_getx_signed_64) (const void *);
  void (*bfd_putx64) (bfd_uint64_t, void *);
  bfd_vma (*bfd_getx32) (const void *);
  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
  void (*bfd_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_getx16) (const void *);
  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
  void (*bfd_putx16) (bfd_vma, void *);


  bfd_uint64_t (*bfd_h_getx64) (const void *);
  bfd_int64_t (*bfd_h_getx_signed_64) (const void *);
  void (*bfd_h_putx64) (bfd_uint64_t, void *);
  bfd_vma (*bfd_h_getx32) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
  void (*bfd_h_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_h_getx16) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
  void (*bfd_h_putx16) (bfd_vma, void *);





  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);


  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);


  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
# 7362 "../bfd/bfd.h"
  bfd_boolean (*_close_and_cleanup) (bfd *);

  bfd_boolean (*_bfd_free_cached_info) (bfd *);

  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);

  bfd_boolean (*_bfd_get_section_contents)
    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
  bfd_boolean (*_bfd_get_section_contents_in_window)
    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
# 7386 "../bfd/bfd.h"
  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);


  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, struct bfd_link_info *);




  bfd_boolean (*_bfd_init_private_section_data)
    (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);


  bfd_boolean (*_bfd_copy_private_section_data)
    (bfd *, sec_ptr, bfd *, sec_ptr);


  bfd_boolean (*_bfd_copy_private_symbol_data)
    (bfd *, asymbol *, bfd *, asymbol *);


  bfd_boolean (*_bfd_copy_private_header_data)
    (bfd *, bfd *);

  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);


  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
# 7421 "../bfd/bfd.h"
  char * (*_core_file_failing_command) (bfd *);
  int (*_core_file_failing_signal) (bfd *);
  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
  int (*_core_file_pid) (bfd *);
# 7440 "../bfd/bfd.h"
  bfd_boolean (*_bfd_slurp_armap) (bfd *);
  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
  bfd_boolean (*_bfd_construct_extended_name_table)
    (bfd *, char **, bfd_size_type *, const char **);
  void (*_bfd_truncate_arname) (bfd *, const char *, char *);
  bfd_boolean (*write_armap)
    (bfd *, unsigned int, struct orl *, unsigned int, int);
  void * (*_bfd_read_ar_hdr_fn) (bfd *);
  bfd_boolean (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);
  bfd * (*openr_next_archived_file) (bfd *, bfd *);

  bfd * (*_bfd_get_elt_at_index) (bfd *, symindex);
  int (*_bfd_stat_arch_elt) (bfd *, struct stat *);
  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
# 7473 "../bfd/bfd.h"
  long (*_bfd_get_symtab_upper_bound) (bfd *);
  long (*_bfd_canonicalize_symtab)
    (bfd *, struct bfd_symbol **);
  struct bfd_symbol *
              (*_bfd_make_empty_symbol) (bfd *);
  void (*_bfd_print_symbol)
    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);

  void (*_bfd_get_symbol_info)
    (bfd *, struct bfd_symbol *, symbol_info *);

  const char *(*_bfd_get_symbol_version_string)
    (bfd *, struct bfd_symbol *, bfd_boolean *);

  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
  alent * (*_get_lineno) (bfd *, struct bfd_symbol *);
  bfd_boolean (*_bfd_find_nearest_line)
    (bfd *, struct bfd_symbol **, struct bfd_section *, bfd_vma,
     const char **, const char **, unsigned int *, unsigned int *);
  bfd_boolean (*_bfd_find_line)
    (bfd *, struct bfd_symbol **, struct bfd_symbol *,
     const char **, unsigned int *);
  bfd_boolean (*_bfd_find_inliner_info)
    (bfd *, const char **, const char **, unsigned int *);



  asymbol * (*_bfd_make_debug_symbol)
    (bfd *, void *, unsigned long size);


  long (*_read_minisymbols)
    (bfd *, bfd_boolean, void **, unsigned int *);


  asymbol * (*_minisymbol_to_symbol)
    (bfd *, bfd_boolean, const void *, asymbol *);
# 7519 "../bfd/bfd.h"
  long (*_get_reloc_upper_bound) (bfd *, sec_ptr);
  long (*_bfd_canonicalize_reloc)
    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);

  reloc_howto_type *
              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
  reloc_howto_type *
              (*reloc_name_lookup) (bfd *, const char *);







  bfd_boolean (*_bfd_set_arch_mach)
    (bfd *, enum bfd_architecture, unsigned long);
  bfd_boolean (*_bfd_set_section_contents)
    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
# 7559 "../bfd/bfd.h"
  int (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
  bfd_byte * (*_bfd_get_relocated_section_contents)
    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
     bfd_byte *, bfd_boolean, struct bfd_symbol **);

  bfd_boolean (*_bfd_relax_section)
    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);



  struct bfd_link_hash_table *
              (*_bfd_link_hash_table_create) (bfd *);


  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);


  void (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);





  void (*_bfd_copy_link_hash_symbol_type)
    (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);



  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);


  bfd_boolean (* _bfd_link_check_relocs)(bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_lookup_section_flags) (struct bfd_link_info *,
                                            struct flag_info *,
                                            asection *);


  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);


  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);



  bfd_boolean (*_section_already_linked) (bfd *, asection *,
                                          struct bfd_link_info *);


  bfd_boolean (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,
                                            struct bfd_link_hash_entry *);
# 7630 "../bfd/bfd.h"
  long (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_symtab)
    (bfd *, struct bfd_symbol **);

  long (*_bfd_get_synthetic_symtab)
    (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
     struct bfd_symbol **);

  long (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_reloc)
    (bfd *, arelent **, struct bfd_symbol **);


  const struct bfd_target * alternative_target;



  const void *backend_data;

} bfd_target;

bfd_boolean bfd_set_default_target (const char *name);

const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);

const bfd_target *bfd_get_target_info (const char *target_name,
    bfd *abfd,
    bfd_boolean *is_bigendian,
    int *underscoring,
    const char **def_target_arch);
const char ** bfd_target_list (void);

const bfd_target *bfd_iterate_over_targets
   (int (*func) (const bfd_target *, void *),
    void *data);

const char *bfd_flavour_name (enum bfd_flavour flavour);


bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);

bfd_boolean bfd_check_format_matches
   (bfd *abfd, bfd_format format, char ***matching);

bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);

const char *bfd_format_string (bfd_format format);


bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);




bfd_boolean bfd_section_already_linked (bfd *abfd,
    asection *sec,
    struct bfd_link_info *info);




bfd_boolean bfd_generic_define_common_symbol
   (bfd *output_bfd, struct bfd_link_info *info,
    struct bfd_link_hash_entry *h);




struct bfd_elf_version_tree * bfd_find_version_for_sym
   (struct bfd_elf_version_tree *verdefs,
    const char *sym_name, bfd_boolean *hide);

bfd_boolean bfd_hide_sym_by_version
   (struct bfd_elf_version_tree *verdefs, const char *sym_name);

bfd_boolean bfd_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);

bfd_boolean _bfd_generic_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);

bfd_boolean bfd_merge_private_bfd_data
   (bfd *ibfd, struct bfd_link_info *info);





bfd_byte *bfd_simple_get_relocated_section_contents
   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);


bfd_boolean bfd_get_full_section_contents
   (bfd *abfd, asection *section, bfd_byte **ptr);

void bfd_cache_section_contents
   (asection *sec, void *contents);

bfd_boolean bfd_is_section_compressed_with_header
   (bfd *abfd, asection *section,
    int *compression_header_size_p,
    bfd_size_type *uncompressed_size_p);

bfd_boolean bfd_is_section_compressed
   (bfd *abfd, asection *section);

bfd_boolean bfd_init_section_decompress_status
   (bfd *abfd, asection *section);

bfd_boolean bfd_init_section_compress_status
   (bfd *abfd, asection *section);

bfd_boolean bfd_compress_section
   (bfd *abfd, asection *section, bfd_byte *uncompressed_buffer);
# 24 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2
# 1 "../bfd/bfd_stdint.h" 1






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4

# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 2 3 4
# 8 "../bfd/bfd_stdint.h" 2
# 25 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2
# 1 "/doner/binutils/binutils-53f7e8e/binutils/bucomm.h" 1
# 27 "/doner/binutils/binutils-53f7e8e/binutils/bucomm.h"

# 27 "/doner/binutils/binutils-53f7e8e/binutils/bucomm.h"
const char *bfd_get_archive_filename (const bfd *);

void bfd_nonfatal (const char *);

void bfd_nonfatal_message (const char *, const bfd *, const asection *,
      const char *, ...);

void bfd_fatal (const char *) __attribute__ ((__noreturn__));

void report (const char *, va_list) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));

void fatal (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1))) __attribute__ ((__noreturn__));

void non_fatal (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));

void set_default_bfd_target (void);

void list_matching_formats (char **);

void list_supported_targets (const char *, FILE *);

void list_supported_architectures (const char *, FILE *);

int display_info (void);

void print_arelt_descr (FILE *, bfd *, bfd_boolean);

char *make_tempname (char *);
char *make_tempdir (char *);

bfd_vma parse_vma (const char *, const char *);

off_t get_file_size (const char *);

bfd_boolean is_valid_archive_path (char const *);

extern char *program_name;


void mode_string (unsigned long, char *);


extern void print_version (const char *);


extern void set_times (const char *, const struct stat *);

extern int smart_rename (const char *, const char *, int);


void *xmalloc (size_t);

void *xrealloc (void *, size_t);
# 26 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2
# 1 "/doner/binutils/binutils-53f7e8e/binutils/elfcomm.h" 1
# 27 "/doner/binutils/binutils-53f7e8e/binutils/elfcomm.h"
# 1 "./../include/aout/ar.h" 1
# 44 "./../include/aout/ar.h"
struct ar_hdr
{
  char ar_name[16];
  char ar_date[12];
  char ar_uid[6];
  char ar_gid[6];
  char ar_mode[8];
  char ar_size[10];
  char ar_fmag[2];
};
# 28 "/doner/binutils/binutils-53f7e8e/binutils/elfcomm.h" 2

void error (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));
void warn (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));

typedef unsigned long elf_vma;

extern void (*byte_put) (unsigned char *, elf_vma, int);
extern void byte_put_little_endian (unsigned char *, elf_vma, int);
extern void byte_put_big_endian (unsigned char *, elf_vma, int);

extern elf_vma (*byte_get) (unsigned char *, int);
extern elf_vma byte_get_signed (unsigned char *, int);
extern elf_vma byte_get_little_endian (unsigned char *, int);
extern elf_vma byte_get_big_endian (unsigned char *, int);
extern void byte_get_64 (unsigned char *, elf_vma *, elf_vma *);
# 55 "/doner/binutils/binutils-53f7e8e/binutils/elfcomm.h"
struct archive_info
{
  char * file_name;
  FILE * file;
  elf_vma index_num;
  elf_vma * index_array;
  char * sym_table;
  unsigned long sym_size;
  char * longnames;
  unsigned long longnames_size;
  unsigned long nested_member_origin;
  unsigned long next_arhdr_offset;
  bfd_boolean is_thin_archive;
  bfd_boolean uses_64bit_indicies;
  struct ar_hdr arhdr;
};


extern char *adjust_relative_path (const char *, const char *, unsigned long);


extern int setup_archive (struct archive_info *, const char *, FILE *,
     bfd_boolean, bfd_boolean);


extern int setup_nested_archive (struct archive_info *, const char *);


extern void release_archive (struct archive_info *);



extern char *get_archive_member_name (struct archive_info *,
          struct archive_info *);




extern char *get_archive_member_name_at (struct archive_info *,
      unsigned long,
      struct archive_info *);




extern char *make_qualified_name (struct archive_info *,
      struct archive_info *,
      const char *);
# 27 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2
# 1 "./../include/elf/common.h" 1
# 28 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2
# 1 "./../include/dwarf2.h" 1
# 75 "./../include/dwarf2.h"
# 1 "./../include/dwarf2.def" 1
# 71 "./../include/dwarf2.def"
enum dwarf_tag { DW_TAG_padding = 0x00
, DW_TAG_array_type = 0x01
, DW_TAG_class_type = 0x02
, DW_TAG_entry_point = 0x03
, DW_TAG_enumeration_type = 0x04
, DW_TAG_formal_parameter = 0x05
, DW_TAG_imported_declaration = 0x08
, DW_TAG_label = 0x0a
, DW_TAG_lexical_block = 0x0b
, DW_TAG_member = 0x0d
, DW_TAG_pointer_type = 0x0f
, DW_TAG_reference_type = 0x10
, DW_TAG_compile_unit = 0x11
, DW_TAG_string_type = 0x12
, DW_TAG_structure_type = 0x13
, DW_TAG_subroutine_type = 0x15
, DW_TAG_typedef = 0x16
, DW_TAG_union_type = 0x17
, DW_TAG_unspecified_parameters = 0x18
, DW_TAG_variant = 0x19
, DW_TAG_common_block = 0x1a
, DW_TAG_common_inclusion = 0x1b
, DW_TAG_inheritance = 0x1c
, DW_TAG_inlined_subroutine = 0x1d
, DW_TAG_module = 0x1e
, DW_TAG_ptr_to_member_type = 0x1f
, DW_TAG_set_type = 0x20
, DW_TAG_subrange_type = 0x21
, DW_TAG_with_stmt = 0x22
, DW_TAG_access_declaration = 0x23
, DW_TAG_base_type = 0x24
, DW_TAG_catch_block = 0x25
, DW_TAG_const_type = 0x26
, DW_TAG_constant = 0x27
, DW_TAG_enumerator = 0x28
, DW_TAG_file_type = 0x29
, DW_TAG_friend = 0x2a
, DW_TAG_namelist = 0x2b
, DW_TAG_namelist_item = 0x2c
, DW_TAG_packed_type = 0x2d
, DW_TAG_subprogram = 0x2e
, DW_TAG_template_type_param = 0x2f
, DW_TAG_template_value_param = 0x30
, DW_TAG_thrown_type = 0x31
, DW_TAG_try_block = 0x32
, DW_TAG_variant_part = 0x33
, DW_TAG_variable = 0x34
, DW_TAG_volatile_type = 0x35

, DW_TAG_dwarf_procedure = 0x36
, DW_TAG_restrict_type = 0x37
, DW_TAG_interface_type = 0x38
, DW_TAG_namespace = 0x39
, DW_TAG_imported_module = 0x3a
, DW_TAG_unspecified_type = 0x3b
, DW_TAG_partial_unit = 0x3c
, DW_TAG_imported_unit = 0x3d
, DW_TAG_condition = 0x3f
, DW_TAG_shared_type = 0x40

, DW_TAG_type_unit = 0x41
, DW_TAG_rvalue_reference_type = 0x42
, DW_TAG_template_alias = 0x43

, DW_TAG_coarray_type = 0x44
, DW_TAG_generic_subrange = 0x45
, DW_TAG_dynamic_type = 0x46
, DW_TAG_atomic_type = 0x47
, DW_TAG_call_site = 0x48
, DW_TAG_call_site_parameter = 0x49
, DW_TAG_skeleton_unit = 0x4a
, DW_TAG_immutable_type = 0x4b

, DW_TAG_lo_user = 0x4080
, DW_TAG_hi_user = 0xffff


, DW_TAG_MIPS_loop = 0x4081


, DW_TAG_HP_array_descriptor = 0x4090
, DW_TAG_HP_Bliss_field = 0x4091
, DW_TAG_HP_Bliss_field_set = 0x4092


, DW_TAG_format_label = 0x4101
, DW_TAG_function_template = 0x4102
, DW_TAG_class_template = 0x4103
, DW_TAG_GNU_BINCL = 0x4104
, DW_TAG_GNU_EINCL = 0x4105


, DW_TAG_GNU_template_template_param = 0x4106





, DW_TAG_GNU_template_parameter_pack = 0x4107
, DW_TAG_GNU_formal_parameter_pack = 0x4108




, DW_TAG_GNU_call_site = 0x4109
, DW_TAG_GNU_call_site_parameter = 0x410a

, DW_TAG_upc_shared_type = 0x8765
, DW_TAG_upc_strict_type = 0x8766
, DW_TAG_upc_relaxed_type = 0x8767

, DW_TAG_PGI_kanji_type = 0xA000
, DW_TAG_PGI_interface_block = 0xA020
};

enum dwarf_form { DW_FORM_addr = 0x01
, DW_FORM_block2 = 0x03
, DW_FORM_block4 = 0x04
, DW_FORM_data2 = 0x05
, DW_FORM_data4 = 0x06
, DW_FORM_data8 = 0x07
, DW_FORM_string = 0x08
, DW_FORM_block = 0x09
, DW_FORM_block1 = 0x0a
, DW_FORM_data1 = 0x0b
, DW_FORM_flag = 0x0c
, DW_FORM_sdata = 0x0d
, DW_FORM_strp = 0x0e
, DW_FORM_udata = 0x0f
, DW_FORM_ref_addr = 0x10
, DW_FORM_ref1 = 0x11
, DW_FORM_ref2 = 0x12
, DW_FORM_ref4 = 0x13
, DW_FORM_ref8 = 0x14
, DW_FORM_ref_udata = 0x15
, DW_FORM_indirect = 0x16

, DW_FORM_sec_offset = 0x17
, DW_FORM_exprloc = 0x18
, DW_FORM_flag_present = 0x19
, DW_FORM_ref_sig8 = 0x20

, DW_FORM_strx = 0x1a
, DW_FORM_addrx = 0x1b
, DW_FORM_ref_sup4 = 0x1c
, DW_FORM_strp_sup = 0x1d
, DW_FORM_data16 = 0x1e
, DW_FORM_line_strp = 0x1f
, DW_FORM_implicit_const = 0x21
, DW_FORM_loclistx = 0x22
, DW_FORM_rnglistx = 0x23
, DW_FORM_ref_sup8 = 0x24

, DW_FORM_GNU_addr_index = 0x1f01
, DW_FORM_GNU_str_index = 0x1f02


, DW_FORM_GNU_ref_alt = 0x1f20
, DW_FORM_GNU_strp_alt = 0x1f21
};

enum dwarf_attribute { DW_AT_sibling = 0x01
, DW_AT_location = 0x02
, DW_AT_name = 0x03
, DW_AT_ordering = 0x09
, DW_AT_subscr_data = 0x0a
, DW_AT_byte_size = 0x0b
, DW_AT_bit_offset = 0x0c
, DW_AT_bit_size = 0x0d
, DW_AT_element_list = 0x0f
, DW_AT_stmt_list = 0x10
, DW_AT_low_pc = 0x11
, DW_AT_high_pc = 0x12
, DW_AT_language = 0x13
, DW_AT_member = 0x14
, DW_AT_discr = 0x15
, DW_AT_discr_value = 0x16
, DW_AT_visibility = 0x17
, DW_AT_import = 0x18
, DW_AT_string_length = 0x19
, DW_AT_common_reference = 0x1a
, DW_AT_comp_dir = 0x1b
, DW_AT_const_value = 0x1c
, DW_AT_containing_type = 0x1d
, DW_AT_default_value = 0x1e
, DW_AT_inline = 0x20
, DW_AT_is_optional = 0x21
, DW_AT_lower_bound = 0x22
, DW_AT_producer = 0x25
, DW_AT_prototyped = 0x27
, DW_AT_return_addr = 0x2a
, DW_AT_start_scope = 0x2c
, DW_AT_bit_stride = 0x2e
, DW_AT_upper_bound = 0x2f
, DW_AT_abstract_origin = 0x31
, DW_AT_accessibility = 0x32
, DW_AT_address_class = 0x33
, DW_AT_artificial = 0x34
, DW_AT_base_types = 0x35
, DW_AT_calling_convention = 0x36
, DW_AT_count = 0x37
, DW_AT_data_member_location = 0x38
, DW_AT_decl_column = 0x39
, DW_AT_decl_file = 0x3a
, DW_AT_decl_line = 0x3b
, DW_AT_declaration = 0x3c
, DW_AT_discr_list = 0x3d
, DW_AT_encoding = 0x3e
, DW_AT_external = 0x3f
, DW_AT_frame_base = 0x40
, DW_AT_friend = 0x41
, DW_AT_identifier_case = 0x42
, DW_AT_macro_info = 0x43
, DW_AT_namelist_items = 0x44
, DW_AT_priority = 0x45
, DW_AT_segment = 0x46
, DW_AT_specification = 0x47
, DW_AT_static_link = 0x48
, DW_AT_type = 0x49
, DW_AT_use_location = 0x4a
, DW_AT_variable_parameter = 0x4b
, DW_AT_virtuality = 0x4c
, DW_AT_vtable_elem_location = 0x4d

, DW_AT_allocated = 0x4e
, DW_AT_associated = 0x4f
, DW_AT_data_location = 0x50
, DW_AT_byte_stride = 0x51
, DW_AT_entry_pc = 0x52
, DW_AT_use_UTF8 = 0x53
, DW_AT_extension = 0x54
, DW_AT_ranges = 0x55
, DW_AT_trampoline = 0x56
, DW_AT_call_column = 0x57
, DW_AT_call_file = 0x58
, DW_AT_call_line = 0x59
, DW_AT_description = 0x5a
, DW_AT_binary_scale = 0x5b
, DW_AT_decimal_scale = 0x5c
, DW_AT_small = 0x5d
, DW_AT_decimal_sign = 0x5e
, DW_AT_digit_count = 0x5f
, DW_AT_picture_string = 0x60
, DW_AT_mutable = 0x61
, DW_AT_threads_scaled = 0x62
, DW_AT_explicit = 0x63
, DW_AT_object_pointer = 0x64
, DW_AT_endianity = 0x65
, DW_AT_elemental = 0x66
, DW_AT_pure = 0x67
, DW_AT_recursive = 0x68

, DW_AT_signature = 0x69
, DW_AT_main_subprogram = 0x6a
, DW_AT_data_bit_offset = 0x6b
, DW_AT_const_expr = 0x6c
, DW_AT_enum_class = 0x6d
, DW_AT_linkage_name = 0x6e

, DW_AT_string_length_bit_size = 0x6f
, DW_AT_string_length_byte_size = 0x70
, DW_AT_rank = 0x71
, DW_AT_str_offsets_base = 0x72
, DW_AT_addr_base = 0x73
, DW_AT_rnglists_base = 0x74
, DW_AT_dwo_name = 0x76
, DW_AT_reference = 0x77
, DW_AT_rvalue_reference = 0x78
, DW_AT_macros = 0x79
, DW_AT_call_all_calls = 0x7a
, DW_AT_call_all_source_calls = 0x7b
, DW_AT_call_all_tail_calls = 0x7c
, DW_AT_call_return_pc = 0x7d
, DW_AT_call_value = 0x7e
, DW_AT_call_origin = 0x7f
, DW_AT_call_parameter = 0x80
, DW_AT_call_pc = 0x81
, DW_AT_call_tail_call = 0x82
, DW_AT_call_target = 0x83
, DW_AT_call_target_clobbered = 0x84
, DW_AT_call_data_location = 0x85
, DW_AT_call_data_value = 0x86
, DW_AT_noreturn = 0x87
, DW_AT_alignment = 0x88
, DW_AT_export_symbols = 0x89
, DW_AT_deleted = 0x8a
, DW_AT_defaulted = 0x8b
, DW_AT_loclists_base = 0x8c

, DW_AT_lo_user = 0x2000
, DW_AT_hi_user = 0x3fff


, DW_AT_MIPS_fde = 0x2001
, DW_AT_MIPS_loop_begin = 0x2002
, DW_AT_MIPS_tail_loop_begin = 0x2003
, DW_AT_MIPS_epilog_begin = 0x2004
, DW_AT_MIPS_loop_unroll_factor = 0x2005
, DW_AT_MIPS_software_pipeline_depth = 0x2006
, DW_AT_MIPS_linkage_name = 0x2007
, DW_AT_MIPS_stride = 0x2008
, DW_AT_MIPS_abstract_name = 0x2009
, DW_AT_MIPS_clone_origin = 0x200a
, DW_AT_MIPS_has_inlines = 0x200b

, DW_AT_HP_block_index = 0x2000
, DW_AT_HP_unmodifiable = 0x2001
, DW_AT_HP_prologue = 0x2005
, DW_AT_HP_epilogue = 0x2008
, DW_AT_HP_actuals_stmt_list = 0x2010
, DW_AT_HP_proc_per_section = 0x2011
, DW_AT_HP_raw_data_ptr = 0x2012
, DW_AT_HP_pass_by_reference = 0x2013
, DW_AT_HP_opt_level = 0x2014
, DW_AT_HP_prof_version_id = 0x2015
, DW_AT_HP_opt_flags = 0x2016
, DW_AT_HP_cold_region_low_pc = 0x2017
, DW_AT_HP_cold_region_high_pc = 0x2018
, DW_AT_HP_all_variables_modifiable = 0x2019
, DW_AT_HP_linkage_name = 0x201a
, DW_AT_HP_prof_flags = 0x201b
, DW_AT_HP_unit_name = 0x201f
, DW_AT_HP_unit_size = 0x2020
, DW_AT_HP_widened_byte_size = 0x2021
, DW_AT_HP_definition_points = 0x2022
, DW_AT_HP_default_location = 0x2023
, DW_AT_HP_is_result_param = 0x2029


, DW_AT_sf_names = 0x2101
, DW_AT_src_info = 0x2102
, DW_AT_mac_info = 0x2103
, DW_AT_src_coords = 0x2104
, DW_AT_body_begin = 0x2105
, DW_AT_body_end = 0x2106
, DW_AT_GNU_vector = 0x2107


, DW_AT_GNU_guarded_by = 0x2108
, DW_AT_GNU_pt_guarded_by = 0x2109
, DW_AT_GNU_guarded = 0x210a
, DW_AT_GNU_pt_guarded = 0x210b
, DW_AT_GNU_locks_excluded = 0x210c
, DW_AT_GNU_exclusive_locks_required = 0x210d
, DW_AT_GNU_shared_locks_required = 0x210e


, DW_AT_GNU_odr_signature = 0x210f


, DW_AT_GNU_template_name = 0x2110


, DW_AT_GNU_call_site_value = 0x2111
, DW_AT_GNU_call_site_data_value = 0x2112
, DW_AT_GNU_call_site_target = 0x2113
, DW_AT_GNU_call_site_target_clobbered = 0x2114
, DW_AT_GNU_tail_call = 0x2115
, DW_AT_GNU_all_tail_call_sites = 0x2116
, DW_AT_GNU_all_call_sites = 0x2117
, DW_AT_GNU_all_source_call_sites = 0x2118

, DW_AT_GNU_macros = 0x2119

, DW_AT_GNU_deleted = 0x211a

, DW_AT_GNU_dwo_name = 0x2130
, DW_AT_GNU_dwo_id = 0x2131
, DW_AT_GNU_ranges_base = 0x2132
, DW_AT_GNU_addr_base = 0x2133
, DW_AT_GNU_pubnames = 0x2134
, DW_AT_GNU_pubtypes = 0x2135


, DW_AT_GNU_discriminator = 0x2136

, DW_AT_VMS_rtnbeg_pd_address = 0x2201



, DW_AT_use_GNAT_descriptive_type = 0x2301
, DW_AT_GNAT_descriptive_type = 0x2302


, DW_AT_GNU_numerator = 0x2303
, DW_AT_GNU_denominator = 0x2304


, DW_AT_GNU_bias = 0x2305

, DW_AT_upc_threads_scaled = 0x3210

, DW_AT_PGI_lbase = 0x3a00
, DW_AT_PGI_soffset = 0x3a01
, DW_AT_PGI_lstride = 0x3a02

, DW_AT_APPLE_optimized = 0x3fe1
, DW_AT_APPLE_flags = 0x3fe2
, DW_AT_APPLE_isa = 0x3fe3
, DW_AT_APPLE_block = 0x3fe4
, DW_AT_APPLE_major_runtime_vers = 0x3fe5
, DW_AT_APPLE_runtime_class = 0x3fe6
, DW_AT_APPLE_omit_frame_ptr = 0x3fe7
, DW_AT_APPLE_property_name = 0x3fe8
, DW_AT_APPLE_property_getter = 0x3fe9
, DW_AT_APPLE_property_setter = 0x3fea
, DW_AT_APPLE_property_attribute = 0x3feb
, DW_AT_APPLE_objc_complete_type = 0x3fec
, DW_AT_APPLE_property = 0x3fed
};

enum dwarf_location_atom { DW_OP_addr = 0x03
, DW_OP_deref = 0x06
, DW_OP_const1u = 0x08
, DW_OP_const1s = 0x09
, DW_OP_const2u = 0x0a
, DW_OP_const2s = 0x0b
, DW_OP_const4u = 0x0c
, DW_OP_const4s = 0x0d
, DW_OP_const8u = 0x0e
, DW_OP_const8s = 0x0f
, DW_OP_constu = 0x10
, DW_OP_consts = 0x11
, DW_OP_dup = 0x12
, DW_OP_drop = 0x13
, DW_OP_over = 0x14
, DW_OP_pick = 0x15
, DW_OP_swap = 0x16
, DW_OP_rot = 0x17
, DW_OP_xderef = 0x18
, DW_OP_abs = 0x19
, DW_OP_and = 0x1a
, DW_OP_div = 0x1b
, DW_OP_minus = 0x1c
, DW_OP_mod = 0x1d
, DW_OP_mul = 0x1e
, DW_OP_neg = 0x1f
, DW_OP_not = 0x20
, DW_OP_or = 0x21
, DW_OP_plus = 0x22
, DW_OP_plus_uconst = 0x23
, DW_OP_shl = 0x24
, DW_OP_shr = 0x25
, DW_OP_shra = 0x26
, DW_OP_xor = 0x27
, DW_OP_bra = 0x28
, DW_OP_eq = 0x29
, DW_OP_ge = 0x2a
, DW_OP_gt = 0x2b
, DW_OP_le = 0x2c
, DW_OP_lt = 0x2d
, DW_OP_ne = 0x2e
, DW_OP_skip = 0x2f
, DW_OP_lit0 = 0x30
, DW_OP_lit1 = 0x31
, DW_OP_lit2 = 0x32
, DW_OP_lit3 = 0x33
, DW_OP_lit4 = 0x34
, DW_OP_lit5 = 0x35
, DW_OP_lit6 = 0x36
, DW_OP_lit7 = 0x37
, DW_OP_lit8 = 0x38
, DW_OP_lit9 = 0x39
, DW_OP_lit10 = 0x3a
, DW_OP_lit11 = 0x3b
, DW_OP_lit12 = 0x3c
, DW_OP_lit13 = 0x3d
, DW_OP_lit14 = 0x3e
, DW_OP_lit15 = 0x3f
, DW_OP_lit16 = 0x40
, DW_OP_lit17 = 0x41
, DW_OP_lit18 = 0x42
, DW_OP_lit19 = 0x43
, DW_OP_lit20 = 0x44
, DW_OP_lit21 = 0x45
, DW_OP_lit22 = 0x46
, DW_OP_lit23 = 0x47
, DW_OP_lit24 = 0x48
, DW_OP_lit25 = 0x49
, DW_OP_lit26 = 0x4a
, DW_OP_lit27 = 0x4b
, DW_OP_lit28 = 0x4c
, DW_OP_lit29 = 0x4d
, DW_OP_lit30 = 0x4e
, DW_OP_lit31 = 0x4f
, DW_OP_reg0 = 0x50
, DW_OP_reg1 = 0x51
, DW_OP_reg2 = 0x52
, DW_OP_reg3 = 0x53
, DW_OP_reg4 = 0x54
, DW_OP_reg5 = 0x55
, DW_OP_reg6 = 0x56
, DW_OP_reg7 = 0x57
, DW_OP_reg8 = 0x58
, DW_OP_reg9 = 0x59
, DW_OP_reg10 = 0x5a
, DW_OP_reg11 = 0x5b
, DW_OP_reg12 = 0x5c
, DW_OP_reg13 = 0x5d
, DW_OP_reg14 = 0x5e
, DW_OP_reg15 = 0x5f
, DW_OP_reg16 = 0x60
, DW_OP_reg17 = 0x61
, DW_OP_reg18 = 0x62
, DW_OP_reg19 = 0x63
, DW_OP_reg20 = 0x64
, DW_OP_reg21 = 0x65
, DW_OP_reg22 = 0x66
, DW_OP_reg23 = 0x67
, DW_OP_reg24 = 0x68
, DW_OP_reg25 = 0x69
, DW_OP_reg26 = 0x6a
, DW_OP_reg27 = 0x6b
, DW_OP_reg28 = 0x6c
, DW_OP_reg29 = 0x6d
, DW_OP_reg30 = 0x6e
, DW_OP_reg31 = 0x6f
, DW_OP_breg0 = 0x70
, DW_OP_breg1 = 0x71
, DW_OP_breg2 = 0x72
, DW_OP_breg3 = 0x73
, DW_OP_breg4 = 0x74
, DW_OP_breg5 = 0x75
, DW_OP_breg6 = 0x76
, DW_OP_breg7 = 0x77
, DW_OP_breg8 = 0x78
, DW_OP_breg9 = 0x79
, DW_OP_breg10 = 0x7a
, DW_OP_breg11 = 0x7b
, DW_OP_breg12 = 0x7c
, DW_OP_breg13 = 0x7d
, DW_OP_breg14 = 0x7e
, DW_OP_breg15 = 0x7f
, DW_OP_breg16 = 0x80
, DW_OP_breg17 = 0x81
, DW_OP_breg18 = 0x82
, DW_OP_breg19 = 0x83
, DW_OP_breg20 = 0x84
, DW_OP_breg21 = 0x85
, DW_OP_breg22 = 0x86
, DW_OP_breg23 = 0x87
, DW_OP_breg24 = 0x88
, DW_OP_breg25 = 0x89
, DW_OP_breg26 = 0x8a
, DW_OP_breg27 = 0x8b
, DW_OP_breg28 = 0x8c
, DW_OP_breg29 = 0x8d
, DW_OP_breg30 = 0x8e
, DW_OP_breg31 = 0x8f
, DW_OP_regx = 0x90
, DW_OP_fbreg = 0x91
, DW_OP_bregx = 0x92
, DW_OP_piece = 0x93
, DW_OP_deref_size = 0x94
, DW_OP_xderef_size = 0x95
, DW_OP_nop = 0x96

, DW_OP_push_object_address = 0x97
, DW_OP_call2 = 0x98
, DW_OP_call4 = 0x99
, DW_OP_call_ref = 0x9a
, DW_OP_form_tls_address = 0x9b
, DW_OP_call_frame_cfa = 0x9c
, DW_OP_bit_piece = 0x9d


, DW_OP_implicit_value = 0x9e
, DW_OP_stack_value = 0x9f


, DW_OP_implicit_pointer = 0xa0
, DW_OP_addrx = 0xa1
, DW_OP_constx = 0xa2
, DW_OP_entry_value = 0xa3
, DW_OP_const_type = 0xa4
, DW_OP_regval_type = 0xa5
, DW_OP_deref_type = 0xa6
, DW_OP_xderef_type = 0xa7
, DW_OP_convert = 0xa8
, DW_OP_reinterpret = 0xa9

, DW_OP_lo_user = 0xe0
, DW_OP_hi_user = 0xff


, DW_OP_GNU_push_tls_address = 0xe0

, DW_OP_GNU_uninit = 0xf0
, DW_OP_GNU_encoded_addr = 0xf1


, DW_OP_GNU_implicit_pointer = 0xf2


, DW_OP_GNU_entry_value = 0xf3


, DW_OP_GNU_const_type = 0xf4
, DW_OP_GNU_regval_type = 0xf5
, DW_OP_GNU_deref_type = 0xf6
, DW_OP_GNU_convert = 0xf7
, DW_OP_GNU_reinterpret = 0xf9

, DW_OP_GNU_parameter_ref = 0xfa

, DW_OP_GNU_addr_index = 0xfb
, DW_OP_GNU_const_index = 0xfc

, DW_OP_HP_unknown = 0xe0
, DW_OP_HP_is_value = 0xe1
, DW_OP_HP_fltconst4 = 0xe2
, DW_OP_HP_fltconst8 = 0xe3
, DW_OP_HP_mod_range = 0xe4
, DW_OP_HP_unmod_range = 0xe5
, DW_OP_HP_tls = 0xe6

, DW_OP_PGI_omp_thread_num = 0xf8





, DW_OP_AARCH64_operation = 0xea
};

enum dwarf_type { DW_ATE_void = 0x0
, DW_ATE_address = 0x1
, DW_ATE_boolean = 0x2
, DW_ATE_complex_float = 0x3
, DW_ATE_float = 0x4
, DW_ATE_signed = 0x5
, DW_ATE_signed_char = 0x6
, DW_ATE_unsigned = 0x7
, DW_ATE_unsigned_char = 0x8

, DW_ATE_imaginary_float = 0x9
, DW_ATE_packed_decimal = 0xa
, DW_ATE_numeric_string = 0xb
, DW_ATE_edited = 0xc
, DW_ATE_signed_fixed = 0xd
, DW_ATE_unsigned_fixed = 0xe
, DW_ATE_decimal_float = 0xf

, DW_ATE_UTF = 0x10

, DW_ATE_UCS = 0x11
, DW_ATE_ASCII = 0x12

, DW_ATE_lo_user = 0x80
, DW_ATE_hi_user = 0xff


, DW_ATE_HP_float80 = 0x80
, DW_ATE_HP_complex_float80 = 0x81
, DW_ATE_HP_float128 = 0x82
, DW_ATE_HP_complex_float128 = 0x83
, DW_ATE_HP_floathpintel = 0x84
, DW_ATE_HP_imaginary_float80 = 0x85
, DW_ATE_HP_imaginary_float128 = 0x86
, DW_ATE_HP_VAX_float = 0x88
, DW_ATE_HP_VAX_float_d = 0x89
, DW_ATE_HP_packed_decimal = 0x8a
, DW_ATE_HP_zoned_decimal = 0x8b
, DW_ATE_HP_edited = 0x8c
, DW_ATE_HP_signed_fixed = 0x8d
, DW_ATE_HP_unsigned_fixed = 0x8e
, DW_ATE_HP_VAX_complex_float = 0x8f
, DW_ATE_HP_VAX_complex_float_d = 0x90

};

enum dwarf_call_frame_info { DW_CFA_advance_loc = 0x40
, DW_CFA_offset = 0x80
, DW_CFA_restore = 0xc0
, DW_CFA_nop = 0x00
, DW_CFA_set_loc = 0x01
, DW_CFA_advance_loc1 = 0x02
, DW_CFA_advance_loc2 = 0x03
, DW_CFA_advance_loc4 = 0x04
, DW_CFA_offset_extended = 0x05
, DW_CFA_restore_extended = 0x06
, DW_CFA_undefined = 0x07
, DW_CFA_same_value = 0x08
, DW_CFA_register = 0x09
, DW_CFA_remember_state = 0x0a
, DW_CFA_restore_state = 0x0b
, DW_CFA_def_cfa = 0x0c
, DW_CFA_def_cfa_register = 0x0d
, DW_CFA_def_cfa_offset = 0x0e

, DW_CFA_def_cfa_expression = 0x0f
, DW_CFA_expression = 0x10
, DW_CFA_offset_extended_sf = 0x11
, DW_CFA_def_cfa_sf = 0x12
, DW_CFA_def_cfa_offset_sf = 0x13
, DW_CFA_val_offset = 0x14
, DW_CFA_val_offset_sf = 0x15
, DW_CFA_val_expression = 0x16

, DW_CFA_lo_user = 0x1c
, DW_CFA_hi_user = 0x3f


, DW_CFA_MIPS_advance_loc8 = 0x1d


, DW_CFA_GNU_window_save = 0x2d
, DW_CFA_GNU_args_size = 0x2e
, DW_CFA_GNU_negative_offset_extended = 0x2f

};
# 76 "./../include/dwarf2.h" 2
# 109 "./../include/dwarf2.h"
enum dwarf_decimal_sign_encoding
  {

    DW_DS_unsigned = 0x01,
    DW_DS_leading_overpunch = 0x02,
    DW_DS_trailing_overpunch = 0x03,
    DW_DS_leading_separate = 0x04,
    DW_DS_trailing_separate = 0x05
  };


enum dwarf_endianity_encoding
  {

    DW_END_default = 0x00,
    DW_END_big = 0x01,
    DW_END_little = 0x02,

    DW_END_lo_user = 0x40,
    DW_END_hi_user = 0xff
  };


enum dwarf_array_dim_ordering
  {
    DW_ORD_row_major = 0,
    DW_ORD_col_major = 1
  };


enum dwarf_access_attribute
  {
    DW_ACCESS_public = 1,
    DW_ACCESS_protected = 2,
    DW_ACCESS_private = 3
  };


enum dwarf_visibility_attribute
  {
    DW_VIS_local = 1,
    DW_VIS_exported = 2,
    DW_VIS_qualified = 3
  };


enum dwarf_virtuality_attribute
  {
    DW_VIRTUALITY_none = 0,
    DW_VIRTUALITY_virtual = 1,
    DW_VIRTUALITY_pure_virtual = 2
  };


enum dwarf_id_case
  {
    DW_ID_case_sensitive = 0,
    DW_ID_up_case = 1,
    DW_ID_down_case = 2,
    DW_ID_case_insensitive = 3
  };


enum dwarf_calling_convention
  {
    DW_CC_normal = 0x1,
    DW_CC_program = 0x2,
    DW_CC_nocall = 0x3,


    DW_CC_pass_by_reference = 0x4,
    DW_CC_pass_by_value = 0x5,

    DW_CC_lo_user = 0x40,
    DW_CC_hi_user = 0xff,

    DW_CC_GNU_renesas_sh = 0x40,
    DW_CC_GNU_borland_fastcall_i386 = 0x41,







    DW_CC_GDB_IBM_OpenCL = 0xff
  };


enum dwarf_inline_attribute
  {
    DW_INL_not_inlined = 0,
    DW_INL_inlined = 1,
    DW_INL_declared_not_inlined = 2,
    DW_INL_declared_inlined = 3
  };


enum dwarf_discrim_list
  {
    DW_DSC_label = 0,
    DW_DSC_range = 1
  };


enum dwarf_line_number_ops
  {
    DW_LNS_extended_op = 0,
    DW_LNS_copy = 1,
    DW_LNS_advance_pc = 2,
    DW_LNS_advance_line = 3,
    DW_LNS_set_file = 4,
    DW_LNS_set_column = 5,
    DW_LNS_negate_stmt = 6,
    DW_LNS_set_basic_block = 7,
    DW_LNS_const_add_pc = 8,
    DW_LNS_fixed_advance_pc = 9,

    DW_LNS_set_prologue_end = 10,
    DW_LNS_set_epilogue_begin = 11,
    DW_LNS_set_isa = 12
  };


enum dwarf_line_number_x_ops
  {
    DW_LNE_end_sequence = 1,
    DW_LNE_set_address = 2,
    DW_LNE_define_file = 3,
    DW_LNE_set_discriminator = 4,

    DW_LNE_HP_negate_is_UV_update = 0x11,
    DW_LNE_HP_push_context = 0x12,
    DW_LNE_HP_pop_context = 0x13,
    DW_LNE_HP_set_file_line_column = 0x14,
    DW_LNE_HP_set_routine_name = 0x15,
    DW_LNE_HP_set_sequence = 0x16,
    DW_LNE_HP_negate_post_semantics = 0x17,
    DW_LNE_HP_negate_function_exit = 0x18,
    DW_LNE_HP_negate_front_end_logical = 0x19,
    DW_LNE_HP_define_proc = 0x20,
    DW_LNE_HP_source_file_correlation = 0x80,

    DW_LNE_lo_user = 0x80,
    DW_LNE_hi_user = 0xff
  };


enum dwarf_line_number_hp_sfc_ops
  {
    DW_LNE_HP_SFC_formfeed = 1,
    DW_LNE_HP_SFC_set_listing_line = 2,
    DW_LNE_HP_SFC_associate = 3
  };



enum dwarf_line_number_content_type
  {
    DW_LNCT_path = 0x1,
    DW_LNCT_directory_index = 0x2,
    DW_LNCT_timestamp = 0x3,
    DW_LNCT_size = 0x4,
    DW_LNCT_MD5 = 0x5,
    DW_LNCT_lo_user = 0x2000,
    DW_LNCT_hi_user = 0x3fff
  };


enum dwarf_location_list_entry_type
  {
    DW_LLE_end_of_list = 0x00,
    DW_LLE_base_addressx = 0x01,
    DW_LLE_startx_endx = 0x02,
    DW_LLE_startx_length = 0x03,
    DW_LLE_offset_pair = 0x04,
    DW_LLE_default_location = 0x05,
    DW_LLE_base_address = 0x06,
    DW_LLE_start_end = 0x07,
    DW_LLE_start_length = 0x08,



    DW_LLE_GNU_end_of_list_entry = 0x00,
    DW_LLE_GNU_base_address_selection_entry = 0x01,
    DW_LLE_GNU_start_end_entry = 0x02,
    DW_LLE_GNU_start_length_entry = 0x03
  };
# 310 "./../include/dwarf2.h"
enum dwarf_source_language
  {
    DW_LANG_C89 = 0x0001,
    DW_LANG_C = 0x0002,
    DW_LANG_Ada83 = 0x0003,
    DW_LANG_C_plus_plus = 0x0004,
    DW_LANG_Cobol74 = 0x0005,
    DW_LANG_Cobol85 = 0x0006,
    DW_LANG_Fortran77 = 0x0007,
    DW_LANG_Fortran90 = 0x0008,
    DW_LANG_Pascal83 = 0x0009,
    DW_LANG_Modula2 = 0x000a,

    DW_LANG_Java = 0x000b,
    DW_LANG_C99 = 0x000c,
    DW_LANG_Ada95 = 0x000d,
    DW_LANG_Fortran95 = 0x000e,
    DW_LANG_PLI = 0x000f,
    DW_LANG_ObjC = 0x0010,
    DW_LANG_ObjC_plus_plus = 0x0011,
    DW_LANG_UPC = 0x0012,
    DW_LANG_D = 0x0013,

    DW_LANG_Python = 0x0014,

    DW_LANG_OpenCL = 0x0015,
    DW_LANG_Go = 0x0016,
    DW_LANG_Modula3 = 0x0017,
    DW_LANG_Haskell = 0x0018,
    DW_LANG_C_plus_plus_03 = 0x0019,
    DW_LANG_C_plus_plus_11 = 0x001a,
    DW_LANG_OCaml = 0x001b,
    DW_LANG_Rust = 0x001c,
    DW_LANG_C11 = 0x001d,
    DW_LANG_Swift = 0x001e,
    DW_LANG_Julia = 0x001f,
    DW_LANG_Dylan = 0x0020,
    DW_LANG_C_plus_plus_14 = 0x0021,
    DW_LANG_Fortran03 = 0x0022,
    DW_LANG_Fortran08 = 0x0023,
    DW_LANG_RenderScript = 0x0024,

    DW_LANG_lo_user = 0x8000,
    DW_LANG_hi_user = 0xffff,


    DW_LANG_Mips_Assembler = 0x8001,

    DW_LANG_Upc = 0x8765,

    DW_LANG_HP_Bliss = 0x8003,
    DW_LANG_HP_Basic91 = 0x8004,
    DW_LANG_HP_Pascal91 = 0x8005,
    DW_LANG_HP_IMacro = 0x8006,
    DW_LANG_HP_Assembler = 0x8007,


    DW_LANG_Rust_old = 0x9000
  };


enum dwarf_macinfo_record_type
  {
    DW_MACINFO_define = 1,
    DW_MACINFO_undef = 2,
    DW_MACINFO_start_file = 3,
    DW_MACINFO_end_file = 4,
    DW_MACINFO_vendor_ext = 255
  };


enum dwarf_defaulted_attribute
  {
    DW_DEFAULTED_no = 0x00,
    DW_DEFAULTED_in_class = 0x01,
    DW_DEFAULTED_out_of_class = 0x02
  };


enum dwarf_macro_record_type
  {
    DW_MACRO_define = 0x01,
    DW_MACRO_undef = 0x02,
    DW_MACRO_start_file = 0x03,
    DW_MACRO_end_file = 0x04,
    DW_MACRO_define_strp = 0x05,
    DW_MACRO_undef_strp = 0x06,
    DW_MACRO_import = 0x07,
    DW_MACRO_define_sup = 0x08,
    DW_MACRO_undef_sup = 0x09,
    DW_MACRO_import_sup = 0x0a,
    DW_MACRO_define_strx = 0x0b,
    DW_MACRO_undef_strx = 0x0c,
    DW_MACRO_lo_user = 0xe0,
    DW_MACRO_hi_user = 0xff,


    DW_MACRO_GNU_define = 0x01,
    DW_MACRO_GNU_undef = 0x02,
    DW_MACRO_GNU_start_file = 0x03,
    DW_MACRO_GNU_end_file = 0x04,
    DW_MACRO_GNU_define_indirect = 0x05,
    DW_MACRO_GNU_undef_indirect = 0x06,
    DW_MACRO_GNU_transparent_include = 0x07,


    DW_MACRO_GNU_define_indirect_alt = 0x08,
    DW_MACRO_GNU_undef_indirect_alt = 0x09,
    DW_MACRO_GNU_transparent_include_alt = 0x0a,
    DW_MACRO_GNU_lo_user = 0xe0,
    DW_MACRO_GNU_hi_user = 0xff
  };


enum dwarf_name_index_attribute
  {
    DW_IDX_compile_unit = 1,
    DW_IDX_type_unit = 2,
    DW_IDX_die_offset = 3,
    DW_IDX_parent = 4,
    DW_IDX_type_hash = 5,
    DW_IDX_lo_user = 0x2000,
    DW_IDX_hi_user = 0x3fff
  };


enum dwarf_range_list_entry
  {
    DW_RLE_end_of_list = 0x00,
    DW_RLE_base_addressx = 0x01,
    DW_RLE_startx_endx = 0x02,
    DW_RLE_startx_length = 0x03,
    DW_RLE_offset_pair = 0x04,
    DW_RLE_base_address = 0x05,
    DW_RLE_start_end = 0x06,
    DW_RLE_start_length = 0x07
  };


enum dwarf_unit_type
  {
    DW_UT_compile = 0x01,
    DW_UT_type = 0x02,
    DW_UT_partial = 0x03,
    DW_UT_skeleton = 0x04,
    DW_UT_split_compile = 0x05,
    DW_UT_split_type = 0x06,
    DW_UT_lo_user = 0x80,
    DW_UT_hi_user = 0xff
  };
# 486 "./../include/dwarf2.h"
enum dwarf_sect
  {
    DW_SECT_INFO = 1,
    DW_SECT_TYPES = 2,
    DW_SECT_ABBREV = 3,
    DW_SECT_LINE = 4,
    DW_SECT_LOC = 5,
    DW_SECT_STR_OFFSETS = 6,
    DW_SECT_MACINFO = 7,
    DW_SECT_MACRO = 8,
    DW_SECT_MAX = 8
  };







extern const char *get_DW_TAG_name (unsigned int tag);



extern const char *get_DW_AT_name (unsigned int attr);



extern const char *get_DW_FORM_name (unsigned int form);



extern const char *get_DW_OP_name (unsigned int op);



extern const char *get_DW_ATE_name (unsigned int enc);



extern const char *get_DW_CFA_name (unsigned int opc);
# 29 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2
# 1 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.h" 1
# 21 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.h"
typedef unsigned long dwarf_vma;
typedef long dwarf_signed_vma;
typedef unsigned long dwarf_size_type;


typedef struct
{
  dwarf_vma li_length;
  unsigned short li_version;
  dwarf_vma li_prologue_length;
  unsigned char li_min_insn_length;
  unsigned char li_max_ops_per_insn;
  unsigned char li_default_is_stmt;
  int li_line_base;
  unsigned char li_line_range;
  unsigned char li_opcode_base;
}
DWARF2_Internal_LineInfo;


typedef struct
{
  dwarf_vma pn_length;
  unsigned short pn_version;
  dwarf_vma pn_offset;
  dwarf_vma pn_size;
}
DWARF2_Internal_PubNames;


typedef struct
{
  dwarf_vma cu_length;
  unsigned short cu_version;
  dwarf_vma cu_abbrev_offset;
  unsigned char cu_pointer_size;
}
DWARF2_Internal_CompUnit;


typedef struct
{
  dwarf_vma ar_length;
  unsigned short ar_version;
  dwarf_vma ar_info_offset;
  unsigned char ar_pointer_size;
  unsigned char ar_segment_size;
}
DWARF2_Internal_ARange;



enum dwarf_section_display_enum
{
  abbrev = 0,
  aranges,
  frame,
  info,
  line,
  pubnames,
  gnu_pubnames,
  eh_frame,
  macinfo,
  macro,
  str,
  loc,
  pubtypes,
  gnu_pubtypes,
  ranges,
  static_func,
  static_vars,
  types,
  weaknames,
  gdb_index,
  trace_info,
  trace_abbrev,
  trace_aranges,
  info_dwo,
  abbrev_dwo,
  types_dwo,
  line_dwo,
  loc_dwo,
  macro_dwo,
  macinfo_dwo,
  str_dwo,
  str_index,
  str_index_dwo,
  debug_addr,
  dwp_cu_index,
  dwp_tu_index,
  max
};

struct dwarf_section
{




  const char *uncompressed_name;
  const char *compressed_name;
  const char *name;
  unsigned char *start;
  dwarf_vma address;
  dwarf_size_type size;
  enum dwarf_section_display_enum abbrev_sec;


  void * reloc_info;
  unsigned long num_relocs;


  void *user_data;
};



struct dwarf_section_display
{
  struct dwarf_section section;
  int (*display) (struct dwarf_section *, void *);
  int *enabled;
  bfd_boolean relocate;
};

extern struct dwarf_section_display debug_displays [];



typedef struct
{
  unsigned int pointer_size;
  unsigned int offset_size;
  int dwarf_version;
  dwarf_vma cu_offset;
  dwarf_vma base_address;


  dwarf_vma addr_base;


  dwarf_vma ranges_base;

  dwarf_vma * loc_offsets;
  int * have_frame_base;
  unsigned int num_loc_offsets;
  unsigned int max_loc_offsets;

  dwarf_vma * range_lists;
  unsigned int num_range_lists;
  unsigned int max_range_lists;
}
debug_info;

extern unsigned int eh_addr_size;

extern int do_debug_info;
extern int do_debug_abbrevs;
extern int do_debug_lines;
extern int do_debug_pubnames;
extern int do_debug_pubtypes;
extern int do_debug_aranges;
extern int do_debug_ranges;
extern int do_debug_frames;
extern int do_debug_frames_interp;
extern int do_debug_macinfo;
extern int do_debug_str;
extern int do_debug_loc;
extern int do_gdb_index;
extern int do_trace_info;
extern int do_trace_abbrevs;
extern int do_trace_aranges;
extern int do_debug_addr;
extern int do_debug_cu_index;
extern int do_wide;

extern int dwarf_cutoff_level;
extern unsigned long dwarf_start_die;

extern int dwarf_check;

extern void init_dwarf_regnames (unsigned int);
extern void init_dwarf_regnames_i386 (void);
extern void init_dwarf_regnames_iamcu (void);
extern void init_dwarf_regnames_x86_64 (void);
extern void init_dwarf_regnames_aarch64 (void);
extern void init_dwarf_regnames_s390 (void);

extern int load_debug_section (enum dwarf_section_display_enum, void *);
extern void free_debug_section (enum dwarf_section_display_enum);

extern void free_debug_memory (void);

extern void dwarf_select_sections_by_names (const char *);
extern void dwarf_select_sections_by_letters (const char *);
extern void dwarf_select_sections_all (void);

extern unsigned int * find_cu_tu_set (void *, unsigned int);

extern void * cmalloc (size_t, size_t);
extern void * xcalloc2 (size_t, size_t);
extern void * xcmalloc (size_t, size_t);
extern void * xcrealloc (void *, size_t, size_t);

extern dwarf_vma read_leb128 (unsigned char *, unsigned int *, bfd_boolean, const unsigned char * const);




extern bfd_boolean reloc_at (struct dwarf_section *, dwarf_vma);
# 30 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2
# 1 "./../include/gdb/gdb-index.h" 1
# 60 "./../include/gdb/gdb-index.h"
typedef enum {

  GDB_INDEX_SYMBOL_KIND_NONE = 0,
  GDB_INDEX_SYMBOL_KIND_TYPE = 1,
  GDB_INDEX_SYMBOL_KIND_VARIABLE = 2,
  GDB_INDEX_SYMBOL_KIND_FUNCTION = 3,
  GDB_INDEX_SYMBOL_KIND_OTHER = 4,


  GDB_INDEX_SYMBOL_KIND_UNUSED5 = 5,
  GDB_INDEX_SYMBOL_KIND_UNUSED6 = 6,
  GDB_INDEX_SYMBOL_KIND_UNUSED7 = 7
} gdb_index_symbol_kind;
# 31 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 2

static const char *regname (unsigned int regno, int row);

static int have_frame_base;
static int need_base_address;

static unsigned int last_pointer_size = 0;
static int warned_about_missing_comp_units = 0;

static unsigned int num_debug_info_entries = 0;
static unsigned int alloc_num_debug_info_entries = 0;
static debug_info *debug_information = 
# 42 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                      ((void *)0)
# 42 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                          ;




unsigned int eh_addr_size;

int do_debug_info;
int do_debug_abbrevs;
int do_debug_lines;
int do_debug_pubnames;
int do_debug_pubtypes;
int do_debug_aranges;
int do_debug_ranges;
int do_debug_frames;
int do_debug_frames_interp;
int do_debug_macinfo;
int do_debug_str;
int do_debug_loc;
int do_gdb_index;
int do_trace_info;
int do_trace_abbrevs;
int do_trace_aranges;
int do_debug_addr;
int do_debug_cu_index;
int do_wide;

int dwarf_cutoff_level = -1;
unsigned long dwarf_start_die;

int dwarf_check = 0;






static int cu_tu_indexes_read = 0;
static unsigned int *shndx_pool = 
# 80 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                 ((void *)0)
# 80 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                     ;
static unsigned int shndx_pool_size = 0;
static unsigned int shndx_pool_used = 0;







struct cu_tu_set
{
  uint64_t signature;
  dwarf_vma section_offsets[DW_SECT_MAX];
  size_t section_sizes[DW_SECT_MAX];
};

static int cu_count = 0;
static int tu_count = 0;
static struct cu_tu_set *cu_sets = 
# 99 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                  ((void *)0)
# 99 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                      ;
static struct cu_tu_set *tu_sets = 
# 100 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                  ((void *)0)
# 100 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                      ;

static void load_cu_tu_indexes (void *file);





static unsigned int
size_of_encoded_value (int encoding)
{
  switch (encoding & 0x7)
    {
    default:
    case 0: return eh_addr_size;
    case 2: return 2;
    case 3: return 4;
    case 4: return 8;
    }
}

static dwarf_vma
get_encoded_value (unsigned char **pdata,
     int encoding,
     struct dwarf_section *section,
     unsigned char * end)
{
  unsigned char * data = * pdata;
  unsigned int size = size_of_encoded_value (encoding);
  dwarf_vma val;

  if (data + size >= end)
    {
      warn (gettext ("Encoded value extends past end of section\n"));
      * pdata = end;
      return 0;
    }


  if (size > 8)
    {
      warn (gettext ("Encoded size of %d is too large to read\n"), size);
      * pdata = end;
      return 0;
    }


  if (size == 0)
    {
      warn (gettext ("Encoded size of 0 is too small to read\n"));
      * pdata = end;
      return 0;
    }

  if (encoding & 0x08)
    val = byte_get_signed (data, size);
  else
    val = byte_get (data, size);

  if ((encoding & 0x70) == 0x10)
    val += section->address + (data - section->start);

  * pdata = data + size;
  return val;
}
# 185 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
static const char *
dwarf_vmatoa_1 (const char *fmtch, dwarf_vma value, unsigned num_bytes)
{



  static int buf_pos = 0;
  static struct dwarf_vmatoa_buf
  {
    char place[64];
  } buf[16];
  char *ret;

  ret = buf[buf_pos++].place;
  buf_pos %= (sizeof (buf) / sizeof ((buf)[0]));

  if (num_bytes)
    {



      snprintf (ret, sizeof (buf[0].place), "%16.16lx", value);
      if (num_bytes > 8)
 num_bytes = 8;
      return ret + (16 - 2 * num_bytes);
    }
  else
    {
      char fmt[32];

      sprintf (fmt, "%%%s%s", "l", fmtch);
      snprintf (ret, sizeof (buf[0].place), fmt, value);
      return ret;
    }
}

static inline const char *
dwarf_vmatoa (const char * fmtch, dwarf_vma value)
{
  return dwarf_vmatoa_1 (fmtch, value, 0);
}





static void
print_dwarf_vma (dwarf_vma value, unsigned num_bytes)
{
  printf ("%s ", dwarf_vmatoa_1 (
# 234 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                ((void *)0)
# 234 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                    , value, num_bytes));
}




static const char *
dwarf_vmatoa64 (dwarf_vma hvalue, dwarf_vma lvalue, char *buf,
  unsigned int buf_len)
{
  int len = 0;

  if (hvalue == 0)
    snprintf (buf, buf_len, "%" "l" "x", lvalue);
  else
    {
      len = snprintf (buf, buf_len, "%" "l" "x", hvalue);
      snprintf (buf + len, buf_len - len,
  "%08" "l" "x", lvalue);
    }

  return buf;
}






dwarf_vma
read_leb128 (unsigned char *data,
      unsigned int *length_return,
      bfd_boolean sign,
      const unsigned char * const end)
{
  dwarf_vma result = 0;
  unsigned int num_read = 0;
  unsigned int shift = 0;
  unsigned char byte = 0;

  while (data < end)
    {
      byte = *data++;
      num_read++;

      result |= ((dwarf_vma) (byte & 0x7f)) << shift;

      shift += 7;
      if ((byte & 0x80) == 0)
 break;



      if (shift >= sizeof (result) * 8)
 break;
    }

  if (length_return != 
# 291 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                      ((void *)0)
# 291 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                          )
    *length_return = num_read;

  if (sign && (shift < 8 * sizeof (result)) && (byte & 0x40))
    result |= -((dwarf_vma) 1 << shift);

  return result;
}


static inline dwarf_signed_vma
read_sleb128 (unsigned char * data,
       unsigned int * length_return,
       const unsigned char * const end)
{
  return (dwarf_signed_vma) read_leb128 (data, length_return, 1, end);
}

static inline dwarf_vma
read_uleb128 (unsigned char * data,
       unsigned int * length_return,
       const unsigned char * const end)
{
  return read_leb128 (data, length_return, 0, end);
}
# 389 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
typedef struct State_Machine_Registers
{
  dwarf_vma address;
  unsigned int file;
  unsigned int line;
  unsigned int column;
  int is_stmt;
  int basic_block;
  unsigned char op_index;
  unsigned char end_sequence;


  unsigned int last_file_entry;
} SMR;

static SMR state_machine_regs;

static void
reset_state_machine (int is_stmt)
{
  state_machine_regs.address = 0;
  state_machine_regs.op_index = 0;
  state_machine_regs.file = 1;
  state_machine_regs.line = 1;
  state_machine_regs.column = 0;
  state_machine_regs.is_stmt = is_stmt;
  state_machine_regs.basic_block = 0;
  state_machine_regs.end_sequence = 0;
  state_machine_regs.last_file_entry = 0;
}




static int
process_extended_line_op (unsigned char * data,
     int is_stmt,
     unsigned char * end)
{
  unsigned char op_code;
  unsigned int bytes_read;
  unsigned int len;
  unsigned char *name;
  unsigned char *orig_data = data;
  dwarf_vma adr;

  len = read_uleb128 (data, & bytes_read, end);
  data += bytes_read;

  if (len == 0 || data == end || len > (uintptr_t) (end - data))
    {
      warn (gettext ("Badly formed extended line op encountered!\n"));
      return bytes_read;
    }

  len += bytes_read;
  op_code = *data++;

  printf (gettext ("  Extended opcode %d: "), op_code);

  switch (op_code)
    {
    case DW_LNE_end_sequence:
      printf (gettext ("End of Sequence\n\n"));
      reset_state_machine (is_stmt);
      break;

    case DW_LNE_set_address:

      if (len - bytes_read - 1 > 8)
 {
   warn (gettext ("Length (%d) of DW_LNE_set_address op is too long\n"),
  len - bytes_read - 1);
   adr = 0;
 }
      else
 do { unsigned int amount = (len - bytes_read - 1); if (sizeof (adr) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (adr)); amount = sizeof (adr); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) adr = 0; else adr = byte_get ((data), amount); } while (0);
      printf (gettext ("set Address to 0x%s\n"), dwarf_vmatoa ("x", adr));
      state_machine_regs.address = adr;
      state_machine_regs.op_index = 0;
      break;

    case DW_LNE_define_file:
      printf (gettext ("define new File Table entry\n"));
      printf (gettext ("  Entry\tDir\tTime\tSize\tName\n"));
      printf ("   %d\t", ++state_machine_regs.last_file_entry);

      name = data;
      data += strnlen ((char *) data, end - data) + 1;
      printf ("%s\t", dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
      data += bytes_read;
      printf ("%s\t", dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
      data += bytes_read;
      printf ("%s\t", dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
      data += bytes_read;
      printf ("%s\n\n", name);

      if (((unsigned int) (data - orig_data) != len) || data == end)
 warn (gettext ("DW_LNE_define_file: Bad opcode length\n"));
      break;

    case DW_LNE_set_discriminator:
      printf (gettext ("set Discriminator to %s\n"),
       dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
      break;


    case DW_LNE_HP_negate_is_UV_update:
      printf ("DW_LNE_HP_negate_is_UV_update\n");
      break;
    case DW_LNE_HP_push_context:
      printf ("DW_LNE_HP_push_context\n");
      break;
    case DW_LNE_HP_pop_context:
      printf ("DW_LNE_HP_pop_context\n");
      break;
    case DW_LNE_HP_set_file_line_column:
      printf ("DW_LNE_HP_set_file_line_column\n");
      break;
    case DW_LNE_HP_set_routine_name:
      printf ("DW_LNE_HP_set_routine_name\n");
      break;
    case DW_LNE_HP_set_sequence:
      printf ("DW_LNE_HP_set_sequence\n");
      break;
    case DW_LNE_HP_negate_post_semantics:
      printf ("DW_LNE_HP_negate_post_semantics\n");
      break;
    case DW_LNE_HP_negate_function_exit:
      printf ("DW_LNE_HP_negate_function_exit\n");
      break;
    case DW_LNE_HP_negate_front_end_logical:
      printf ("DW_LNE_HP_negate_front_end_logical\n");
      break;
    case DW_LNE_HP_define_proc:
      printf ("DW_LNE_HP_define_proc\n");
      break;
    case DW_LNE_HP_source_file_correlation:
      {
 unsigned char *edata = data + len - bytes_read - 1;

 printf ("DW_LNE_HP_source_file_correlation\n");

 while (data < edata)
   {
     unsigned int opc;

     opc = read_uleb128 (data, & bytes_read, edata);
     data += bytes_read;

     switch (opc)
       {
       case DW_LNE_HP_SFC_formfeed:
  printf ("    DW_LNE_HP_SFC_formfeed\n");
  break;
       case DW_LNE_HP_SFC_set_listing_line:
  printf ("    DW_LNE_HP_SFC_set_listing_line (%s)\n",
   dwarf_vmatoa ("u",
          read_uleb128 (data, & bytes_read, edata)));
  data += bytes_read;
  break;
       case DW_LNE_HP_SFC_associate:
  printf ("    DW_LNE_HP_SFC_associate ");
  printf ("(%s",
   dwarf_vmatoa ("u",
          read_uleb128 (data, & bytes_read, edata)));
  data += bytes_read;
  printf (",%s",
   dwarf_vmatoa ("u",
          read_uleb128 (data, & bytes_read, edata)));
  data += bytes_read;
  printf (",%s)\n",
   dwarf_vmatoa ("u",
          read_uleb128 (data, & bytes_read, edata)));
  data += bytes_read;
  break;
       default:
  printf (gettext ("    UNKNOWN DW_LNE_HP_SFC opcode (%u)\n"), opc);
  data = edata;
  break;
       }
   }
      }
      break;

    default:
      {
 unsigned int rlen = len - bytes_read - 1;

 if (op_code >= DW_LNE_lo_user



                                     )
   printf (gettext ("user defined: "));
 else
   printf (gettext ("UNKNOWN: "));
 printf (gettext ("length %d ["), rlen);
 for (; rlen; rlen--)
   printf (" %02x", *data++);
 printf ("]\n");
      }
      break;
    }

  return len;
}

static const unsigned char *
fetch_indirect_string (dwarf_vma offset)
{
  struct dwarf_section *section = &debug_displays [str].section;

  if (section->start == 
# 602 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
# 602 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                           )
    return (const unsigned char *) gettext ("<no .debug_str section>");

  if (offset > section->size)
    {
      warn (gettext ("DW_FORM_strp offset too big: %s\n"),
     dwarf_vmatoa ("x", offset));
      return (const unsigned char *) gettext ("<offset is too big>");
    }

  return (const unsigned char *) section->start + offset;
}

static const char *
fetch_indexed_string (dwarf_vma idx, struct cu_tu_set *this_set,
        dwarf_vma offset_size, int dwo)
{
  enum dwarf_section_display_enum str_sec_idx = dwo ? str_dwo : str;
  enum dwarf_section_display_enum idx_sec_idx = dwo ? str_index_dwo : str_index;
  struct dwarf_section *index_section = &debug_displays [idx_sec_idx].section;
  struct dwarf_section *str_section = &debug_displays [str_sec_idx].section;
  dwarf_vma index_offset = idx * offset_size;
  dwarf_vma str_offset;

  if (index_section->start == 
# 626 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                             ((void *)0)
# 626 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                 )
    return (dwo ? gettext ("<no .debug_str_offsets.dwo section>")
  : gettext ("<no .debug_str_offsets section>"));

  if (this_set != 
# 630 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                 ((void *)0)
# 630 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                     )
    index_offset += this_set->section_offsets [DW_SECT_STR_OFFSETS];
  if (index_offset > index_section->size)
    {
      warn (gettext ("DW_FORM_GNU_str_index offset too big: %s\n"),
     dwarf_vmatoa ("x", index_offset));
      return gettext ("<index offset is too big>");
    }

  if (str_section->start == 
# 639 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                           ((void *)0)
# 639 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                               )
    return (dwo ? gettext ("<no .debug_str.dwo section>")
  : gettext ("<no .debug_str section>"));

  str_offset = byte_get (index_section->start + index_offset, offset_size);
  str_offset -= str_section->address;
  if (str_offset > str_section->size)
    {
      warn (gettext ("DW_FORM_GNU_str_index indirect offset too big: %s\n"),
     dwarf_vmatoa ("x", str_offset));
      return gettext ("<indirect index offset is too big>");
    }

  return (const char *) str_section->start + str_offset;
}

static const char *
fetch_indexed_value (dwarf_vma offset, dwarf_vma bytes)
{
  struct dwarf_section *section = &debug_displays [debug_addr].section;

  if (section->start == 
# 660 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
# 660 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                           )
    return (gettext ("<no .debug_addr section>"));

  if (offset + bytes > section->size)
    {
      warn (gettext ("Offset into section %s too big: %s\n"),
     section->name, dwarf_vmatoa ("x", offset));
      return "<offset too big>";
    }

  return dwarf_vmatoa ("x", byte_get (section->start + offset, bytes));
}





typedef struct abbrev_attr
{
  unsigned long attribute;
  unsigned long form;
  struct abbrev_attr *next;
}
abbrev_attr;

typedef struct abbrev_entry
{
  unsigned long entry;
  unsigned long tag;
  int children;
  struct abbrev_attr *first_attr;
  struct abbrev_attr *last_attr;
  struct abbrev_entry *next;
}
abbrev_entry;

static abbrev_entry *first_abbrev = 
# 696 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                   ((void *)0)
# 696 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                       ;
static abbrev_entry *last_abbrev = 
# 697 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                  ((void *)0)
# 697 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                      ;

static void
free_abbrevs (void)
{
  abbrev_entry *abbrv;

  for (abbrv = first_abbrev; abbrv;)
    {
      abbrev_entry *next_abbrev = abbrv->next;
      abbrev_attr *attr;

      for (attr = abbrv->first_attr; attr;)
 {
   abbrev_attr *next_attr = attr->next;

   free (attr);
   attr = next_attr;
 }

      free (abbrv);
      abbrv = next_abbrev;
    }

  last_abbrev = first_abbrev = 
# 721 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 721 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  ;
}

static void
add_abbrev (unsigned long number, unsigned long tag, int children)
{
  abbrev_entry *entry;

  entry = (abbrev_entry *) malloc (sizeof (*entry));
  if (entry == 
# 730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
              ((void *)0)
# 730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                  )

    return;

  entry->entry = number;
  entry->tag = tag;
  entry->children = children;
  entry->first_attr = 
# 737 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 737 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         ;
  entry->last_attr = 
# 738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         ;
  entry->next = 
# 739 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 739 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         ;

  if (first_abbrev == 
# 741 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 741 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         )
    first_abbrev = entry;
  else
    last_abbrev->next = entry;

  last_abbrev = entry;
}

static void
add_abbrev_attr (unsigned long attribute, unsigned long form)
{
  abbrev_attr *attr;

  attr = (abbrev_attr *) malloc (sizeof (*attr));
  if (attr == 
# 755 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 755 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 )

    return;

  attr->attribute = attribute;
  attr->form = form;
  attr->next = 
# 761 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 761 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       ;

  if (last_abbrev->first_attr == 
# 763 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                ((void *)0)
# 763 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                    )
    last_abbrev->first_attr = attr;
  else
    last_abbrev->last_attr->next = attr;

  last_abbrev->last_attr = attr;
}






static unsigned char *
process_abbrev_section (unsigned char *start, unsigned char *end)
{
  if (first_abbrev != 
# 779 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 779 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         )
    return 
# 780 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 780 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;

  while (start < end)
    {
      unsigned int bytes_read;
      unsigned long entry;
      unsigned long tag;
      unsigned long attribute;
      int children;

      entry = read_uleb128 (start, & bytes_read, end);
      start += bytes_read;




      if (start == end)
 return 
# 797 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 797 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           ;
      if (entry == 0)
 return start;

      tag = read_uleb128 (start, & bytes_read, end);
      start += bytes_read;
      if (start == end)
 return 
# 804 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 804 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           ;

      children = *start++;

      add_abbrev (entry, tag, children);

      do
 {
   unsigned long form;

   attribute = read_uleb128 (start, & bytes_read, end);
   start += bytes_read;
   if (start == end)
     break;

   form = read_uleb128 (start, & bytes_read, end);
   start += bytes_read;
   if (start == end)
     break;

   add_abbrev_attr (attribute, form);
 }
      while (attribute != 0);
    }


  error (gettext (".debug_abbrev section not zero terminated\n"));

  return 
# 832 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
        ((void *)0)
# 832 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
            ;
}

static const char *
get_TAG_name (unsigned long tag)
{
  const char *name = get_DW_TAG_name ((unsigned int)tag);

  if (name == 
# 840 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 840 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 )
    {
      static char buffer[100];

      snprintf (buffer, sizeof (buffer), gettext ("Unknown TAG value: %lx"), tag);
      return buffer;
    }

  return name;
}

static const char *
get_FORM_name (unsigned long form)
{
  const char *name;

  if (form == 0)
    return "DW_FORM value: 0";

  name = get_DW_FORM_name (form);
  if (name == 
# 860 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 860 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 )
    {
      static char buffer[100];

      snprintf (buffer, sizeof (buffer), gettext ("Unknown FORM value: %lx"), form);
      return buffer;
    }

  return name;
}

static unsigned char *
display_block (unsigned char *data,
        dwarf_vma length,
        const unsigned char * const end)
{
  dwarf_vma maxlen;

  printf (gettext (" %s byte block: "), dwarf_vmatoa ("u", length));
  if (data > end)
    return (unsigned char *) end;

  maxlen = (dwarf_vma) (end - data);
  length = length > maxlen ? maxlen : length;

  while (length --)
    printf ("%lx ", (unsigned long) byte_get (data++, 1));

  return data;
}

static int
decode_location_expression (unsigned char * data,
       unsigned int pointer_size,
       unsigned int offset_size,
       int dwarf_version,
       dwarf_vma length,
       dwarf_vma cu_offset,
       struct dwarf_section * section)
{
  unsigned op;
  unsigned int bytes_read;
  dwarf_vma uvalue;
  dwarf_signed_vma svalue;
  unsigned char *end = data + length;
  int need_frame_base = 0;

  while (data < end)
    {
      op = *data++;

      switch (op)
 {
 case DW_OP_addr:
   do { do { unsigned int amount = (pointer_size); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += pointer_size; } while (0);
   printf ("DW_OP_addr: %s", dwarf_vmatoa ("x", uvalue));
   break;
 case DW_OP_deref:
   printf ("DW_OP_deref");
   break;
 case DW_OP_const1u:
   do { do { unsigned int amount = (1); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 1; } while (0);
   printf ("DW_OP_const1u: %lu", (unsigned long) uvalue);
   break;
 case DW_OP_const1s:
   do { do { unsigned int amount = (1); if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount) svalue = byte_get_signed ((data), amount); else svalue = 0; } while (0); data += 1; } while (0);
   printf ("DW_OP_const1s: %ld", (long) svalue);
   break;
 case DW_OP_const2u:
   do { do { unsigned int amount = (2); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 2; } while (0);
   printf ("DW_OP_const2u: %lu", (unsigned long) uvalue);
   break;
 case DW_OP_const2s:
   do { do { unsigned int amount = (2); if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount) svalue = byte_get_signed ((data), amount); else svalue = 0; } while (0); data += 2; } while (0);
   printf ("DW_OP_const2s: %ld", (long) svalue);
   break;
 case DW_OP_const4u:
   do { do { unsigned int amount = (4); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 4; } while (0);
   printf ("DW_OP_const4u: %lu", (unsigned long) uvalue);
   break;
 case DW_OP_const4s:
   do { do { unsigned int amount = (4); if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount) svalue = byte_get_signed ((data), amount); else svalue = 0; } while (0); data += 4; } while (0);
   printf ("DW_OP_const4s: %ld", (long) svalue);
   break;
 case DW_OP_const8u:
   do { do { unsigned int amount = (4); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 4; } while (0);
   printf ("DW_OP_const8u: %lu ", (unsigned long) uvalue);
   do { do { unsigned int amount = (4); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 4; } while (0);
   printf ("%lu", (unsigned long) uvalue);
   break;
 case DW_OP_const8s:
   do { do { unsigned int amount = (4); if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount) svalue = byte_get_signed ((data), amount); else svalue = 0; } while (0); data += 4; } while (0);
   printf ("DW_OP_const8s: %ld ", (long) svalue);
   do { do { unsigned int amount = (4); if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount) svalue = byte_get_signed ((data), amount); else svalue = 0; } while (0); data += 4; } while (0);
   printf ("%ld", (long) svalue);
   break;
 case DW_OP_constu:
   printf ("DW_OP_constu: %s",
    dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
   data += bytes_read;
   break;
 case DW_OP_consts:
   printf ("DW_OP_consts: %s",
    dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read, end)));
   data += bytes_read;
   break;
 case DW_OP_dup:
   printf ("DW_OP_dup");
   break;
 case DW_OP_drop:
   printf ("DW_OP_drop");
   break;
 case DW_OP_over:
   printf ("DW_OP_over");
   break;
 case DW_OP_pick:
   do { do { unsigned int amount = (1); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 1; } while (0);
   printf ("DW_OP_pick: %ld", (unsigned long) uvalue);
   break;
 case DW_OP_swap:
   printf ("DW_OP_swap");
   break;
 case DW_OP_rot:
   printf ("DW_OP_rot");
   break;
 case DW_OP_xderef:
   printf ("DW_OP_xderef");
   break;
 case DW_OP_abs:
   printf ("DW_OP_abs");
   break;
 case DW_OP_and:
   printf ("DW_OP_and");
   break;
 case DW_OP_div:
   printf ("DW_OP_div");
   break;
 case DW_OP_minus:
   printf ("DW_OP_minus");
   break;
 case DW_OP_mod:
   printf ("DW_OP_mod");
   break;
 case DW_OP_mul:
   printf ("DW_OP_mul");
   break;
 case DW_OP_neg:
   printf ("DW_OP_neg");
   break;
 case DW_OP_not:
   printf ("DW_OP_not");
   break;
 case DW_OP_or:
   printf ("DW_OP_or");
   break;
 case DW_OP_plus:
   printf ("DW_OP_plus");
   break;
 case DW_OP_plus_uconst:
   printf ("DW_OP_plus_uconst: %s",
    dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
   data += bytes_read;
   break;
 case DW_OP_shl:
   printf ("DW_OP_shl");
   break;
 case DW_OP_shr:
   printf ("DW_OP_shr");
   break;
 case DW_OP_shra:
   printf ("DW_OP_shra");
   break;
 case DW_OP_xor:
   printf ("DW_OP_xor");
   break;
 case DW_OP_bra:
   do { do { unsigned int amount = (2); if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount) svalue = byte_get_signed ((data), amount); else svalue = 0; } while (0); data += 2; } while (0);
   printf ("DW_OP_bra: %ld", (long) svalue);
   break;
 case DW_OP_eq:
   printf ("DW_OP_eq");
   break;
 case DW_OP_ge:
   printf ("DW_OP_ge");
   break;
 case DW_OP_gt:
   printf ("DW_OP_gt");
   break;
 case DW_OP_le:
   printf ("DW_OP_le");
   break;
 case DW_OP_lt:
   printf ("DW_OP_lt");
   break;
 case DW_OP_ne:
   printf ("DW_OP_ne");
   break;
 case DW_OP_skip:
   do { do { unsigned int amount = (2); if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount) svalue = byte_get_signed ((data), amount); else svalue = 0; } while (0); data += 2; } while (0);
   printf ("DW_OP_skip: %ld", (long) svalue);
   break;

 case DW_OP_lit0:
 case DW_OP_lit1:
 case DW_OP_lit2:
 case DW_OP_lit3:
 case DW_OP_lit4:
 case DW_OP_lit5:
 case DW_OP_lit6:
 case DW_OP_lit7:
 case DW_OP_lit8:
 case DW_OP_lit9:
 case DW_OP_lit10:
 case DW_OP_lit11:
 case DW_OP_lit12:
 case DW_OP_lit13:
 case DW_OP_lit14:
 case DW_OP_lit15:
 case DW_OP_lit16:
 case DW_OP_lit17:
 case DW_OP_lit18:
 case DW_OP_lit19:
 case DW_OP_lit20:
 case DW_OP_lit21:
 case DW_OP_lit22:
 case DW_OP_lit23:
 case DW_OP_lit24:
 case DW_OP_lit25:
 case DW_OP_lit26:
 case DW_OP_lit27:
 case DW_OP_lit28:
 case DW_OP_lit29:
 case DW_OP_lit30:
 case DW_OP_lit31:
   printf ("DW_OP_lit%d", op - DW_OP_lit0);
   break;

 case DW_OP_reg0:
 case DW_OP_reg1:
 case DW_OP_reg2:
 case DW_OP_reg3:
 case DW_OP_reg4:
 case DW_OP_reg5:
 case DW_OP_reg6:
 case DW_OP_reg7:
 case DW_OP_reg8:
 case DW_OP_reg9:
 case DW_OP_reg10:
 case DW_OP_reg11:
 case DW_OP_reg12:
 case DW_OP_reg13:
 case DW_OP_reg14:
 case DW_OP_reg15:
 case DW_OP_reg16:
 case DW_OP_reg17:
 case DW_OP_reg18:
 case DW_OP_reg19:
 case DW_OP_reg20:
 case DW_OP_reg21:
 case DW_OP_reg22:
 case DW_OP_reg23:
 case DW_OP_reg24:
 case DW_OP_reg25:
 case DW_OP_reg26:
 case DW_OP_reg27:
 case DW_OP_reg28:
 case DW_OP_reg29:
 case DW_OP_reg30:
 case DW_OP_reg31:
   printf ("DW_OP_reg%d (%s)", op - DW_OP_reg0,
    regname (op - DW_OP_reg0, 1));
   break;

 case DW_OP_breg0:
 case DW_OP_breg1:
 case DW_OP_breg2:
 case DW_OP_breg3:
 case DW_OP_breg4:
 case DW_OP_breg5:
 case DW_OP_breg6:
 case DW_OP_breg7:
 case DW_OP_breg8:
 case DW_OP_breg9:
 case DW_OP_breg10:
 case DW_OP_breg11:
 case DW_OP_breg12:
 case DW_OP_breg13:
 case DW_OP_breg14:
 case DW_OP_breg15:
 case DW_OP_breg16:
 case DW_OP_breg17:
 case DW_OP_breg18:
 case DW_OP_breg19:
 case DW_OP_breg20:
 case DW_OP_breg21:
 case DW_OP_breg22:
 case DW_OP_breg23:
 case DW_OP_breg24:
 case DW_OP_breg25:
 case DW_OP_breg26:
 case DW_OP_breg27:
 case DW_OP_breg28:
 case DW_OP_breg29:
 case DW_OP_breg30:
 case DW_OP_breg31:
   printf ("DW_OP_breg%d (%s): %s",
    op - DW_OP_breg0,
    regname (op - DW_OP_breg0, 1),
    dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read, end)));
   data += bytes_read;
   break;

 case DW_OP_regx:
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf ("DW_OP_regx: %s (%s)",
    dwarf_vmatoa ("u", uvalue), regname (uvalue, 1));
   break;
 case DW_OP_fbreg:
   need_frame_base = 1;
   printf ("DW_OP_fbreg: %s",
    dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read, end)));
   data += bytes_read;
   break;
 case DW_OP_bregx:
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf ("DW_OP_bregx: %s (%s) %s",
    dwarf_vmatoa ("u", uvalue), regname (uvalue, 1),
    dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read, end)));
   data += bytes_read;
   break;
 case DW_OP_piece:
   printf ("DW_OP_piece: %s",
    dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
   data += bytes_read;
   break;
 case DW_OP_deref_size:
   do { do { unsigned int amount = (1); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 1; } while (0);
   printf ("DW_OP_deref_size: %ld", (long) uvalue);
   break;
 case DW_OP_xderef_size:
   do { do { unsigned int amount = (1); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 1; } while (0);
   printf ("DW_OP_xderef_size: %ld", (long) uvalue);
   break;
 case DW_OP_nop:
   printf ("DW_OP_nop");
   break;


 case DW_OP_push_object_address:
   printf ("DW_OP_push_object_address");
   break;
 case DW_OP_call2:


   do { do { unsigned int amount = (2); if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount) svalue = byte_get_signed ((data), amount); else svalue = 0; } while (0); data += 2; } while (0);
   printf ("DW_OP_call2: <0x%s>",
    dwarf_vmatoa ("x", svalue + cu_offset));
   break;
 case DW_OP_call4:


   do { do { unsigned int amount = (4); if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount) svalue = byte_get_signed ((data), amount); else svalue = 0; } while (0); data += 4; } while (0);
   printf ("DW_OP_call4: <0x%s>",
    dwarf_vmatoa ("x", svalue + cu_offset));
   break;
 case DW_OP_call_ref:


   if (dwarf_version == -1)
     {
       printf (gettext ("(DW_OP_call_ref in frame info)"));

       return need_frame_base;
     }
   if (dwarf_version == 2)
     {
       do { do { unsigned int amount = (pointer_size); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += pointer_size; } while (0);
     }
   else
     {
       do { do { unsigned int amount = (offset_size); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += offset_size; } while (0);
     }
   printf ("DW_OP_call_ref: <0x%s>", dwarf_vmatoa ("x", uvalue));
   break;
 case DW_OP_form_tls_address:
   printf ("DW_OP_form_tls_address");
   break;
 case DW_OP_call_frame_cfa:
   printf ("DW_OP_call_frame_cfa");
   break;
 case DW_OP_bit_piece:
   printf ("DW_OP_bit_piece: ");
   printf (gettext ("size: %s "),
    dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
   data += bytes_read;
   printf (gettext ("offset: %s "),
    dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
   data += bytes_read;
   break;


 case DW_OP_stack_value:
   printf ("DW_OP_stack_value");
   break;

 case DW_OP_implicit_value:
   printf ("DW_OP_implicit_value");
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   data = display_block (data, uvalue, end);
   break;


 case DW_OP_GNU_push_tls_address:
   printf (gettext ("DW_OP_GNU_push_tls_address or DW_OP_HP_unknown"));
   break;
 case DW_OP_GNU_uninit:
   printf ("DW_OP_GNU_uninit");

   break;
 case DW_OP_GNU_encoded_addr:
   {
     int encoding = 0;
     dwarf_vma addr;

     if (data < end)
       encoding = *data++;
     addr = get_encoded_value (&data, encoding, section, end);

     printf ("DW_OP_GNU_encoded_addr: fmt:%02x addr:", encoding);
     print_dwarf_vma (addr, pointer_size);
   }
   break;
 case DW_OP_GNU_implicit_pointer:


   if (dwarf_version == -1)
     {
       printf (gettext ("(DW_OP_GNU_implicit_pointer in frame info)"));

       return need_frame_base;
     }
   if (dwarf_version == 2)
     {
       do { do { unsigned int amount = (pointer_size); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += pointer_size; } while (0);
     }
   else
     {
       do { do { unsigned int amount = (offset_size); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += offset_size; } while (0);
     }
   printf ("DW_OP_GNU_implicit_pointer: <0x%s> %s",
    dwarf_vmatoa ("x", uvalue),
    dwarf_vmatoa ("d", read_sleb128 (data,
         &bytes_read, end)));
   data += bytes_read;
   break;
 case DW_OP_GNU_entry_value:
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;

   if (uvalue > (dwarf_vma) (end - data))
     uvalue = end - data;
   printf ("DW_OP_GNU_entry_value: (");
   if (decode_location_expression (data, pointer_size, offset_size,
       dwarf_version, uvalue,
       cu_offset, section))
     need_frame_base = 1;
   putchar (')');
   data += uvalue;
   if (data > end)
     data = end;
   break;
 case DW_OP_GNU_const_type:
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf ("DW_OP_GNU_const_type: <0x%s> ",
    dwarf_vmatoa ("x", cu_offset + uvalue));
   do { do { unsigned int amount = (1); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 1; } while (0);
   data = display_block (data, uvalue, end);
   break;
 case DW_OP_GNU_regval_type:
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf ("DW_OP_GNU_regval_type: %s (%s)",
    dwarf_vmatoa ("u", uvalue), regname (uvalue, 1));
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf (" <0x%s>", dwarf_vmatoa ("x", cu_offset + uvalue));
   break;
 case DW_OP_GNU_deref_type:
   do { do { unsigned int amount = (1); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 1; } while (0);
   printf ("DW_OP_GNU_deref_type: %ld", (long) uvalue);
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf (" <0x%s>", dwarf_vmatoa ("x", cu_offset + uvalue));
   break;
 case DW_OP_GNU_convert:
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf ("DW_OP_GNU_convert <0x%s>",
    dwarf_vmatoa ("x", uvalue ? cu_offset + uvalue : 0));
   break;
 case DW_OP_GNU_reinterpret:
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf ("DW_OP_GNU_reinterpret <0x%s>",
    dwarf_vmatoa ("x", uvalue ? cu_offset + uvalue : 0));
   break;
 case DW_OP_GNU_parameter_ref:
   do { do { unsigned int amount = (4); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 4; } while (0);
   printf ("DW_OP_GNU_parameter_ref: <0x%s>",
    dwarf_vmatoa ("x", cu_offset + uvalue));
   break;
 case DW_OP_GNU_addr_index:
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf ("DW_OP_GNU_addr_index <0x%s>", dwarf_vmatoa ("x", uvalue));
   break;
 case DW_OP_GNU_const_index:
   uvalue = read_uleb128 (data, &bytes_read, end);
   data += bytes_read;
   printf ("DW_OP_GNU_const_index <0x%s>", dwarf_vmatoa ("x", uvalue));
   break;


 case DW_OP_HP_is_value:
   printf ("DW_OP_HP_is_value");

   break;
 case DW_OP_HP_fltconst4:
   printf ("DW_OP_HP_fltconst4");

   break;
 case DW_OP_HP_fltconst8:
   printf ("DW_OP_HP_fltconst8");

   break;
 case DW_OP_HP_mod_range:
   printf ("DW_OP_HP_mod_range");

   break;
 case DW_OP_HP_unmod_range:
   printf ("DW_OP_HP_unmod_range");

   break;
 case DW_OP_HP_tls:
   printf ("DW_OP_HP_tls");

   break;


 case DW_OP_PGI_omp_thread_num:




   printf ("DW_OP_PGI_omp_thread_num");
   break;

 default:
   if (op >= DW_OP_lo_user
       && op <= DW_OP_hi_user)
     printf (gettext ("(User defined location op)"));
   else
     printf (gettext ("(Unknown location op)"));

   return need_frame_base;
 }


      if (data < end)
 printf ("; ");
    }

  return need_frame_base;
}




static struct cu_tu_set *
find_cu_tu_set_v2 (dwarf_vma cu_offset, int do_types)
{
  struct cu_tu_set *p;
  unsigned int nsets;
  unsigned int dw_sect;

  if (do_types)
    {
      p = tu_sets;
      nsets = tu_count;
      dw_sect = DW_SECT_TYPES;
    }
  else
    {
      p = cu_sets;
      nsets = cu_count;
      dw_sect = DW_SECT_INFO;
    }
  while (nsets > 0)
    {
      if (p->section_offsets [dw_sect] == cu_offset)
 return p;
      p++;
      nsets--;
    }
  return 
# 1468 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
        ((void *)0)
# 1468 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
            ;
}


static void
add64 (dwarf_vma * high_bits, dwarf_vma * low_bits, dwarf_vma inc)
{
  dwarf_vma tmp = * low_bits;

  tmp += inc;







  if (tmp < * low_bits)
    {
      ++ * high_bits;
    }
  else if (sizeof (tmp) > 8
    && (tmp >> 31) > 1)
    {
      ++ * high_bits;
      tmp &= 0xFFFFFFFF;
    }

  * low_bits = tmp;
}

static unsigned char *
read_and_display_attr_value (unsigned long attribute,
        unsigned long form,
        unsigned char * data,
        unsigned char * end,
        dwarf_vma cu_offset,
        dwarf_vma pointer_size,
        dwarf_vma offset_size,
        int dwarf_version,
        debug_info * debug_info_p,
        int do_loc,
        struct dwarf_section * section,
        struct cu_tu_set * this_set)
{
  dwarf_vma uvalue = 0;
  unsigned char *block_start = 
# 1514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 1514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  ;
  unsigned char * orig_data = data;
  unsigned int bytes_read;

  if (data > end || (data == end && form != DW_FORM_flag_present))
    {
      warn (gettext ("Corrupt attribute\n"));
      return data;
    }

  switch (form)
    {
    default:
      break;

    case DW_FORM_ref_addr:
      if (dwarf_version == 2)
 do { do { unsigned int amount = (pointer_size); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += pointer_size; } while (0);
      else if (dwarf_version == 3 || dwarf_version == 4)
 do { do { unsigned int amount = (offset_size); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += offset_size; } while (0);
      else
 error (gettext ("Internal error: DWARF version is not 2, 3 or 4.\n"));

      break;

    case DW_FORM_addr:
      do { do { unsigned int amount = (pointer_size); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += pointer_size; } while (0);
      break;

    case DW_FORM_strp:
    case DW_FORM_sec_offset:
    case DW_FORM_GNU_ref_alt:
    case DW_FORM_GNU_strp_alt:
      do { do { unsigned int amount = (offset_size); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += offset_size; } while (0);
      break;

    case DW_FORM_flag_present:
      uvalue = 1;
      break;

    case DW_FORM_ref1:
    case DW_FORM_flag:
    case DW_FORM_data1:
      do { do { unsigned int amount = (1); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 1; } while (0);
      break;

    case DW_FORM_ref2:
    case DW_FORM_data2:
      do { do { unsigned int amount = (2); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 2; } while (0);
      break;

    case DW_FORM_ref4:
    case DW_FORM_data4:
      do { do { unsigned int amount = (4); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0); data += 4; } while (0);
      break;

    case DW_FORM_sdata:
      uvalue = read_sleb128 (data, & bytes_read, end);
      data += bytes_read;
      break;

    case DW_FORM_GNU_str_index:
      uvalue = read_uleb128 (data, & bytes_read, end);
      data += bytes_read;
      break;

    case DW_FORM_ref_udata:
    case DW_FORM_udata:
      uvalue = read_uleb128 (data, & bytes_read, end);
      data += bytes_read;
      break;

    case DW_FORM_indirect:
      form = read_uleb128 (data, & bytes_read, end);
      data += bytes_read;
      if (!do_loc)
 printf (" %s", get_FORM_name (form));
      return read_and_display_attr_value (attribute, form, data, end,
       cu_offset, pointer_size,
       offset_size, dwarf_version,
       debug_info_p, do_loc,
       section, this_set);
    case DW_FORM_GNU_addr_index:
      uvalue = read_uleb128 (data, & bytes_read, end);
      data += bytes_read;
      break;
    }

  switch (form)
    {
    case DW_FORM_ref_addr:
      if (!do_loc)
 printf (" <0x%s>", dwarf_vmatoa ("x",uvalue));
      break;

    case DW_FORM_GNU_ref_alt:
      if (!do_loc)
 printf (" <alt 0x%s>", dwarf_vmatoa ("x",uvalue));
      break;

    case DW_FORM_ref1:
    case DW_FORM_ref2:
    case DW_FORM_ref4:
    case DW_FORM_ref_udata:
      if (!do_loc)
 printf (" <0x%s>", dwarf_vmatoa ("x", uvalue + cu_offset));
      break;

    case DW_FORM_data4:
    case DW_FORM_addr:
    case DW_FORM_sec_offset:
      if (!do_loc)
 printf (" 0x%s", dwarf_vmatoa ("x", uvalue));
      break;

    case DW_FORM_flag_present:
    case DW_FORM_flag:
    case DW_FORM_data1:
    case DW_FORM_data2:
    case DW_FORM_sdata:
    case DW_FORM_udata:
      if (!do_loc)
 printf (" %s", dwarf_vmatoa ("d", uvalue));
      break;

    case DW_FORM_ref8:
    case DW_FORM_data8:
      if (!do_loc)
 {
   dwarf_vma high_bits;
   dwarf_vma utmp;
   char buf[64];

   do { if (((data) + 8) <= (end)) { byte_get_64 ((data), (&high_bits), (&uvalue)); } else { * (&uvalue) = * (&high_bits) = 0; } } while (0);
   utmp = uvalue;
   if (form == DW_FORM_ref8)
     add64 (& high_bits, & utmp, cu_offset);
   printf (" 0x%s",
    dwarf_vmatoa64 (high_bits, utmp, buf, sizeof (buf)));
 }

      if ((do_loc || do_debug_loc || do_debug_ranges)
   && num_debug_info_entries == 0)
 {
   if (sizeof (uvalue) == 8)
     do { unsigned int amount = (8); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0);
   else
     error (gettext ("DW_FORM_data8 is unsupported when sizeof (dwarf_vma) != 8\n"));
 }

      data += 8;
      break;

    case DW_FORM_string:
      if (!do_loc)
 printf (" %.*s", (int) (end - data), data);
      data += strnlen ((char *) data, end - data) + 1;
      break;

    case DW_FORM_block:
    case DW_FORM_exprloc:
      uvalue = read_uleb128 (data, & bytes_read, end);
      block_start = data + bytes_read;
      if (block_start >= end)
 {
   warn (gettext ("Block ends prematurely\n"));
   uvalue = 0;
   block_start = end;
 }



      data = block_start + uvalue;

      if (block_start + uvalue > end || data < block_start)
 {
   warn (gettext ("Corrupt attribute block length: %lx\n"), (long) uvalue);
   uvalue = end - block_start;
 }
      if (do_loc)
 data = block_start + uvalue;
      else
 data = display_block (block_start, uvalue, end);
      break;

    case DW_FORM_block1:
      do { unsigned int amount = (1); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0);
      block_start = data + 1;
      if (block_start >= end)
 {
   warn (gettext ("Block ends prematurely\n"));
   uvalue = 0;
   block_start = end;
 }
      data = block_start + uvalue;
      if (block_start + uvalue > end || data < block_start)
 {
   warn (gettext ("Corrupt attribute block length: %lx\n"), (long) uvalue);
   uvalue = end - block_start;
 }
      if (do_loc)
 data = block_start + uvalue;
      else
 data = display_block (block_start, uvalue, end);
      break;

    case DW_FORM_block2:
      do { unsigned int amount = (2); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0);
      block_start = data + 2;
      if (block_start >= end)
 {
   warn (gettext ("Block ends prematurely\n"));
   uvalue = 0;
   block_start = end;
 }
      data = block_start + uvalue;
      if (block_start + uvalue > end || data < block_start)
 {
   warn (gettext ("Corrupt attribute block length: %lx\n"), (long) uvalue);
   uvalue = end - block_start;
 }
      if (do_loc)
 data = block_start + uvalue;
      else
 data = display_block (block_start, uvalue, end);
      break;

    case DW_FORM_block4:
      do { unsigned int amount = (4); if (sizeof (uvalue) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uvalue)); amount = sizeof (uvalue); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uvalue = 0; else uvalue = byte_get ((data), amount); } while (0);
      block_start = data + 4;

      if (block_start >= end)
 {
   warn (gettext ("Block ends prematurely\n"));
   uvalue = 0;
   block_start = end;
 }
      data = block_start + uvalue;
      if (block_start + uvalue > end

   || data < block_start)
 {
   warn (gettext ("Corrupt attribute block length: %lx\n"), (long) uvalue);
   uvalue = end - block_start;
 }
      if (do_loc)
 data = block_start + uvalue;
      else
 data = display_block (block_start, uvalue, end);
      break;

    case DW_FORM_strp:
      if (!do_loc)
 printf (gettext (" (indirect string, offset: 0x%s): %s"),
  dwarf_vmatoa ("x", uvalue),
  fetch_indirect_string (uvalue));
      break;

    case DW_FORM_GNU_str_index:
      if (!do_loc)
 {
   const char *suffix = strrchr (section->name, '.');
   int dwo = (suffix && strcmp (suffix, ".dwo") == 0) ? 1 : 0;

   printf (gettext (" (indexed string: 0x%s): %s"),
    dwarf_vmatoa ("x", uvalue),
    fetch_indexed_string (uvalue, this_set, offset_size, dwo));
 }
      break;

    case DW_FORM_GNU_strp_alt:
      if (!do_loc)
 printf (gettext (" (alt indirect string, offset: 0x%s)"),
  dwarf_vmatoa ("x", uvalue));
      break;

    case DW_FORM_indirect:

      break;

    case DW_FORM_ref_sig8:
      if (!do_loc)
 {
   dwarf_vma high_bits;
   char buf[64];

   do { if (((data) + 8) <= (end)) { byte_get_64 ((data), (&high_bits), (&uvalue)); } else { * (&uvalue) = * (&high_bits) = 0; } } while (0);
   printf (" signature: 0x%s",
    dwarf_vmatoa64 (high_bits, uvalue, buf, sizeof (buf)));
 }
      data += 8;
      break;

    case DW_FORM_GNU_addr_index:
      if (!do_loc)
 printf (gettext (" (addr_index: 0x%s): %s"),
  dwarf_vmatoa ("x", uvalue),
  fetch_indexed_value (uvalue * pointer_size, pointer_size));
      break;

    default:
      warn (gettext ("Unrecognized form: %lu\n"), form);
      break;
    }

  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0
      && debug_info_p != 
# 1821 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                        ((void *)0)
# 1821 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                            )
    {
      switch (attribute)
 {
 case DW_AT_frame_base:
   have_frame_base = 1;

 case DW_AT_location:
 case DW_AT_string_length:
 case DW_AT_return_addr:
 case DW_AT_data_member_location:
 case DW_AT_vtable_elem_location:
 case DW_AT_segment:
 case DW_AT_static_link:
 case DW_AT_use_location:
 case DW_AT_GNU_call_site_value:
 case DW_AT_GNU_call_site_data_value:
 case DW_AT_GNU_call_site_target:
 case DW_AT_GNU_call_site_target_clobbered:
   if ((dwarf_version < 4
        && (form == DW_FORM_data4 || form == DW_FORM_data8))
       || form == DW_FORM_sec_offset)
     {

       unsigned int lmax = debug_info_p->max_loc_offsets;
       unsigned int num = debug_info_p->num_loc_offsets;

       if (lmax == 0 || num >= lmax)
  {
    lmax += 1024;
    debug_info_p->loc_offsets = (dwarf_vma *)
      xcrealloc (debug_info_p->loc_offsets,
          lmax, sizeof (*debug_info_p->loc_offsets));
    debug_info_p->have_frame_base = (int *)
      xcrealloc (debug_info_p->have_frame_base,
          lmax, sizeof (*debug_info_p->have_frame_base));
    debug_info_p->max_loc_offsets = lmax;
  }
       if (this_set != 
# 1859 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                      ((void *)0)
# 1859 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                          )
  uvalue += this_set->section_offsets [DW_SECT_LOC];
       debug_info_p->loc_offsets [num] = uvalue;
       debug_info_p->have_frame_base [num] = have_frame_base;
       debug_info_p->num_loc_offsets++;
     }
   break;

 case DW_AT_low_pc:
   if (need_base_address)
     debug_info_p->base_address = uvalue;
   break;

 case DW_AT_GNU_addr_base:
   debug_info_p->addr_base = uvalue;
   break;

 case DW_AT_GNU_ranges_base:
   debug_info_p->ranges_base = uvalue;
   break;

 case DW_AT_ranges:
   if ((dwarf_version < 4
        && (form == DW_FORM_data4 || form == DW_FORM_data8))
       || form == DW_FORM_sec_offset)
     {

       unsigned int lmax = debug_info_p->max_range_lists;
       unsigned int num = debug_info_p->num_range_lists;

       if (lmax == 0 || num >= lmax)
  {
    lmax += 1024;
    debug_info_p->range_lists = (dwarf_vma *)
      xcrealloc (debug_info_p->range_lists,
          lmax, sizeof (*debug_info_p->range_lists));
    debug_info_p->max_range_lists = lmax;
  }
       debug_info_p->range_lists [num] = uvalue;
       debug_info_p->num_range_lists++;
     }
   break;

 default:
   break;
 }
    }

  if (do_loc || attribute == 0)
    return data;


  switch (attribute)
    {
    case DW_AT_inline:
      printf ("\t");
      switch (uvalue)
 {
 case DW_INL_not_inlined:
   printf (gettext ("(not inlined)"));
   break;
 case DW_INL_inlined:
   printf (gettext ("(inlined)"));
   break;
 case DW_INL_declared_not_inlined:
   printf (gettext ("(declared as inline but ignored)"));
   break;
 case DW_INL_declared_inlined:
   printf (gettext ("(declared as inline and inlined)"));
   break;
 default:
   printf (gettext ("  (Unknown inline attribute value: %s)"),
    dwarf_vmatoa ("x", uvalue));
   break;
 }
      break;

    case DW_AT_language:
      printf ("\t");
      switch (uvalue)
 {

 case DW_LANG_C89: printf ("(ANSI C)"); break;
 case DW_LANG_C: printf ("(non-ANSI C)"); break;
 case DW_LANG_Ada83: printf ("(Ada)"); break;
 case DW_LANG_C_plus_plus: printf ("(C++)"); break;
 case DW_LANG_Cobol74: printf ("(Cobol 74)"); break;
 case DW_LANG_Cobol85: printf ("(Cobol 85)"); break;
 case DW_LANG_Fortran77: printf ("(FORTRAN 77)"); break;
 case DW_LANG_Fortran90: printf ("(Fortran 90)"); break;
 case DW_LANG_Pascal83: printf ("(ANSI Pascal)"); break;
 case DW_LANG_Modula2: printf ("(Modula 2)"); break;

 case DW_LANG_Java: printf ("(Java)"); break;
 case DW_LANG_C99: printf ("(ANSI C99)"); break;
 case DW_LANG_Ada95: printf ("(ADA 95)"); break;
 case DW_LANG_Fortran95: printf ("(Fortran 95)"); break;

 case DW_LANG_PLI: printf ("(PLI)"); break;
 case DW_LANG_ObjC: printf ("(Objective C)"); break;
 case DW_LANG_ObjC_plus_plus: printf ("(Objective C++)"); break;
 case DW_LANG_UPC: printf ("(Unified Parallel C)"); break;
 case DW_LANG_D: printf ("(D)"); break;

 case DW_LANG_Python: printf ("(Python)"); break;

 case DW_LANG_Go: printf ("(Go)"); break;
 case DW_LANG_C_plus_plus_11: printf ("(C++11)"); break;
 case DW_LANG_C11: printf ("(C11)"); break;
 case DW_LANG_C_plus_plus_14: printf ("(C++14)"); break;
 case DW_LANG_Fortran03: printf ("(Fortran 03)"); break;
 case DW_LANG_Fortran08: printf ("(Fortran 08)"); break;

 case DW_LANG_Mips_Assembler: printf ("(MIPS assembler)"); break;

 case DW_LANG_Upc: printf ("(Unified Parallel C)"); break;
 default:
   if (uvalue >= DW_LANG_lo_user && uvalue <= DW_LANG_hi_user)
     printf (gettext ("(implementation defined: %s)"),
      dwarf_vmatoa ("x", uvalue));
   else
     printf (gettext ("(Unknown: %s)"), dwarf_vmatoa ("x", uvalue));
   break;
 }
      break;

    case DW_AT_encoding:
      printf ("\t");
      switch (uvalue)
 {
 case DW_ATE_void: printf ("(void)"); break;
 case DW_ATE_address: printf ("(machine address)"); break;
 case DW_ATE_boolean: printf ("(boolean)"); break;
 case DW_ATE_complex_float: printf ("(complex float)"); break;
 case DW_ATE_float: printf ("(float)"); break;
 case DW_ATE_signed: printf ("(signed)"); break;
 case DW_ATE_signed_char: printf ("(signed char)"); break;
 case DW_ATE_unsigned: printf ("(unsigned)"); break;
 case DW_ATE_unsigned_char: printf ("(unsigned char)"); break;

 case DW_ATE_imaginary_float: printf ("(imaginary float)"); break;
 case DW_ATE_decimal_float: printf ("(decimal float)"); break;

 case DW_ATE_packed_decimal: printf ("(packed_decimal)"); break;
 case DW_ATE_numeric_string: printf ("(numeric_string)"); break;
 case DW_ATE_edited: printf ("(edited)"); break;
 case DW_ATE_signed_fixed: printf ("(signed_fixed)"); break;
 case DW_ATE_unsigned_fixed: printf ("(unsigned_fixed)"); break;

 case DW_ATE_HP_float80: printf ("(HP_float80)"); break;
 case DW_ATE_HP_complex_float80: printf ("(HP_complex_float80)"); break;
 case DW_ATE_HP_float128: printf ("(HP_float128)"); break;
 case DW_ATE_HP_complex_float128:printf ("(HP_complex_float128)"); break;
 case DW_ATE_HP_floathpintel: printf ("(HP_floathpintel)"); break;
 case DW_ATE_HP_imaginary_float80: printf ("(HP_imaginary_float80)"); break;
 case DW_ATE_HP_imaginary_float128: printf ("(HP_imaginary_float128)"); break;

 case DW_ATE_UTF: printf ("(unicode string)"); break;

 default:
   if (uvalue >= DW_ATE_lo_user
       && uvalue <= DW_ATE_hi_user)
     printf (gettext ("(user defined type)"));
   else
     printf (gettext ("(unknown type)"));
   break;
 }
      break;

    case DW_AT_accessibility:
      printf ("\t");
      switch (uvalue)
 {
 case DW_ACCESS_public: printf ("(public)"); break;
 case DW_ACCESS_protected: printf ("(protected)"); break;
 case DW_ACCESS_private: printf ("(private)"); break;
 default:
   printf (gettext ("(unknown accessibility)"));
   break;
 }
      break;

    case DW_AT_visibility:
      printf ("\t");
      switch (uvalue)
 {
 case DW_VIS_local: printf ("(local)"); break;
 case DW_VIS_exported: printf ("(exported)"); break;
 case DW_VIS_qualified: printf ("(qualified)"); break;
 default: printf (gettext ("(unknown visibility)")); break;
 }
      break;

    case DW_AT_virtuality:
      printf ("\t");
      switch (uvalue)
 {
 case DW_VIRTUALITY_none: printf ("(none)"); break;
 case DW_VIRTUALITY_virtual: printf ("(virtual)"); break;
 case DW_VIRTUALITY_pure_virtual:printf ("(pure_virtual)"); break;
 default: printf (gettext ("(unknown virtuality)")); break;
 }
      break;

    case DW_AT_identifier_case:
      printf ("\t");
      switch (uvalue)
 {
 case DW_ID_case_sensitive: printf ("(case_sensitive)"); break;
 case DW_ID_up_case: printf ("(up_case)"); break;
 case DW_ID_down_case: printf ("(down_case)"); break;
 case DW_ID_case_insensitive: printf ("(case_insensitive)"); break;
 default: printf (gettext ("(unknown case)")); break;
 }
      break;

    case DW_AT_calling_convention:
      printf ("\t");
      switch (uvalue)
 {
 case DW_CC_normal: printf ("(normal)"); break;
 case DW_CC_program: printf ("(program)"); break;
 case DW_CC_nocall: printf ("(nocall)"); break;
 default:
   if (uvalue >= DW_CC_lo_user
       && uvalue <= DW_CC_hi_user)
     printf (gettext ("(user defined)"));
   else
     printf (gettext ("(unknown convention)"));
 }
      break;

    case DW_AT_ordering:
      printf ("\t");
      switch (uvalue)
 {
 case -1: printf (gettext ("(undefined)")); break;
 case 0: printf ("(row major)"); break;
 case 1: printf ("(column major)"); break;
 }
      break;

    case DW_AT_frame_base:
      have_frame_base = 1;

    case DW_AT_location:
    case DW_AT_string_length:
    case DW_AT_return_addr:
    case DW_AT_data_member_location:
    case DW_AT_vtable_elem_location:
    case DW_AT_segment:
    case DW_AT_static_link:
    case DW_AT_use_location:
    case DW_AT_GNU_call_site_value:
    case DW_AT_GNU_call_site_data_value:
    case DW_AT_GNU_call_site_target:
    case DW_AT_GNU_call_site_target_clobbered:
      if ((dwarf_version < 4
    && (form == DW_FORM_data4 || form == DW_FORM_data8))
   || form == DW_FORM_sec_offset)
 printf (gettext (" (location list)"));

    case DW_AT_allocated:
    case DW_AT_associated:
    case DW_AT_data_location:
    case DW_AT_byte_stride:
    case DW_AT_upper_bound:
    case DW_AT_lower_bound:
      if (block_start)
 {
   int need_frame_base;

   printf ("\t(");
   need_frame_base = decode_location_expression (block_start,
       pointer_size,
       offset_size,
       dwarf_version,
       uvalue,
       cu_offset, section);
   printf (")");
   if (need_frame_base && !have_frame_base)
     printf (gettext (" [without DW_AT_frame_base]"));
 }
      break;

    case DW_AT_import:
      {
 if (form == DW_FORM_ref_sig8
     || form == DW_FORM_GNU_ref_alt)
   break;

 if (form == DW_FORM_ref1
     || form == DW_FORM_ref2
     || form == DW_FORM_ref4
     || form == DW_FORM_ref_udata)
   uvalue += cu_offset;

 if (uvalue >= section->size)
   warn (gettext ("Offset %s used as value for DW_AT_import attribute of DIE at offset 0x%lx is too big.\n"),
  dwarf_vmatoa ("x", uvalue),
  (unsigned long) (orig_data - section->start));
 else
   {
     unsigned long abbrev_number;
     abbrev_entry * entry;

     abbrev_number = read_uleb128 (section->start + uvalue, 
# 2165 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                           ((void *)0)
# 2165 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                               , end);

     printf (gettext ("\t[Abbrev Number: %ld"), abbrev_number);



     if (form != DW_FORM_ref_addr)
       {
  for (entry = first_abbrev; entry != 
# 2173 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 2173 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         ; entry = entry->next)
    if (entry->entry == abbrev_number)
      break;
  if (entry != 
# 2176 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
              ((void *)0)
# 2176 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                  )
    printf (" (%s)", get_TAG_name (entry->tag));
       }
     printf ("]");
   }
      }
      break;

    default:
      break;
    }

  return data;
}

static const char *
get_AT_name (unsigned long attribute)
{
  const char *name;

  if (attribute == 0)
    return "DW_AT value: 0";


  if (attribute == DW_AT_MIPS_fde)
    return "DW_AT_MIPS_fde or DW_AT_HP_unmodifiable";

  name = get_DW_AT_name (attribute);

  if (name == 
# 2205 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 2205 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 )
    {
      static char buffer[100];

      snprintf (buffer, sizeof (buffer), gettext ("Unknown AT value: %lx"),
  attribute);
      return buffer;
    }

  return name;
}

static unsigned char *
read_and_display_attr (unsigned long attribute,
         unsigned long form,
         unsigned char * data,
         unsigned char * end,
         dwarf_vma cu_offset,
         dwarf_vma pointer_size,
         dwarf_vma offset_size,
         int dwarf_version,
         debug_info * debug_info_p,
         int do_loc,
         struct dwarf_section * section,
         struct cu_tu_set * this_set)
{
  if (!do_loc)
    printf ("   %-18s:", get_AT_name (attribute));
  data = read_and_display_attr_value (attribute, form, data, end,
          cu_offset, pointer_size, offset_size,
          dwarf_version, debug_info_p,
          do_loc, section, this_set);
  if (!do_loc)
    printf ("\n");
  return data;
}






static int
process_debug_info (struct dwarf_section *section,
      void *file,
      enum dwarf_section_display_enum abbrev_sec,
      int do_loc,
      int do_types)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *section_begin;
  unsigned int unit;
  unsigned int num_units = 0;

  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0
      && ! do_types)
    {
      dwarf_vma length;


      for (section_begin = start, num_units = 0; section_begin < end;
    num_units ++)
 {



   do { unsigned int amount = (4); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((section_begin) + amount) >= (end)) { if ((section_begin) < (end)) amount = (end) - (section_begin); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((section_begin), amount); } while (0);

   if (length == 0xffffffff)
     {
       do { unsigned int amount = (8); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((section_begin + 4) + amount) >= (end)) { if ((section_begin + 4) < (end)) amount = (end) - (section_begin + 4); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((section_begin + 4), amount); } while (0);
       section_begin += length + 12;
     }
   else if (length >= 0xfffffff0 && length < 0xffffffff)
     {
       warn (gettext ("Reserved length value (0x%s) found in section %s\n"),
      dwarf_vmatoa ("x", length), section->name);
       return 0;
     }
   else
     section_begin += length + 4;




   if ((signed long) length <= 0 || section_begin < start)
     {
       warn (gettext ("Corrupt unit length (0x%s) found in section %s\n"),
      dwarf_vmatoa ("x", length), section->name);
       return 0;
     }
 }

      if (num_units == 0)
 {
   error (gettext ("No comp units in %s section ?\n"), section->name);
   return 0;
 }


      debug_information = (debug_info *) cmalloc (num_units,
        sizeof (* debug_information));
      if (debug_information == 
# 2309 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 2309 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  )
 {
   error (gettext ("Not enough memory for a debug info array of %u entries\n"),
   num_units);
   alloc_num_debug_info_entries = num_debug_info_entries = 0;
   return 0;
 }





      memset (debug_information, 0, num_units * sizeof (*debug_information));

      alloc_num_debug_info_entries = num_units;
    }

  if (!do_loc)
    {
      if (dwarf_start_die == 0)
 printf (gettext ("Contents of the %s section:\n\n"), section->name);

      load_debug_section (str, file);
      load_debug_section (str_dwo, file);
      load_debug_section (str_index, file);
      load_debug_section (str_index_dwo, file);
      load_debug_section (debug_addr, file);
    }

  load_debug_section (abbrev_sec, file);
  if (debug_displays [abbrev_sec].section.start == 
# 2339 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 2339 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      )
    {
      warn (gettext ("Unable to locate %s section!\n"),
     debug_displays [abbrev_sec].section.name);
      return 0;
    }

  for (section_begin = start, unit = 0; start < end; unit++)
    {
      DWARF2_Internal_CompUnit compunit;
      unsigned char *hdrptr;
      unsigned char *tags;
      int level, last_level, saved_level;
      dwarf_vma cu_offset;
      unsigned int offset_size;
      int initial_length_size;
      dwarf_vma signature_high = 0;
      dwarf_vma signature_low = 0;
      dwarf_vma type_offset = 0;
      struct cu_tu_set *this_set;
      dwarf_vma abbrev_base;
      size_t abbrev_size;

      hdrptr = start;

      do { do { unsigned int amount = (4); if (sizeof (compunit.cu_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (compunit.cu_length)); amount = sizeof (compunit.cu_length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) compunit.cu_length = 0; else compunit.cu_length = byte_get ((hdrptr), amount); } while (0); hdrptr += 4; } while (0);

      if (compunit.cu_length == 0xffffffff)
 {
   do { do { unsigned int amount = (8); if (sizeof (compunit.cu_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (compunit.cu_length)); amount = sizeof (compunit.cu_length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) compunit.cu_length = 0; else compunit.cu_length = byte_get ((hdrptr), amount); } while (0); hdrptr += 8; } while (0);
   offset_size = 8;
   initial_length_size = 12;
 }
      else
 {
   offset_size = 4;
   initial_length_size = 4;
 }

      do { do { unsigned int amount = (2); if (sizeof (compunit.cu_version) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (compunit.cu_version)); amount = sizeof (compunit.cu_version); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) compunit.cu_version = 0; else compunit.cu_version = byte_get ((hdrptr), amount); } while (0); hdrptr += 2; } while (0);

      cu_offset = start - section_begin;

      this_set = find_cu_tu_set_v2 (cu_offset, do_types);

      do { do { unsigned int amount = (offset_size); if (sizeof (compunit.cu_abbrev_offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (compunit.cu_abbrev_offset)); amount = sizeof (compunit.cu_abbrev_offset); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) compunit.cu_abbrev_offset = 0; else compunit.cu_abbrev_offset = byte_get ((hdrptr), amount); } while (0); hdrptr += offset_size; } while (0);

      if (this_set == 
# 2386 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 2386 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         )
 {
   abbrev_base = 0;
   abbrev_size = debug_displays [abbrev_sec].section.size;
 }
      else
 {
   abbrev_base = this_set->section_offsets [DW_SECT_ABBREV];
   abbrev_size = this_set->section_sizes [DW_SECT_ABBREV];
 }

      do { do { unsigned int amount = (1); if (sizeof (compunit.cu_pointer_size) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (compunit.cu_pointer_size)); amount = sizeof (compunit.cu_pointer_size); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) compunit.cu_pointer_size = 0; else compunit.cu_pointer_size = byte_get ((hdrptr), amount); } while (0); hdrptr += 1; } while (0);

      if (compunit.cu_pointer_size < 2 || compunit.cu_pointer_size > 8)
 {
   warn (gettext ("Invalid pointer size (%d) in compunit header, using %d instead\n"),
  compunit.cu_pointer_size, offset_size);
   compunit.cu_pointer_size = offset_size;
 }

      if (do_types)
 {
   do { if (((hdrptr) + 8) <= (end)) { byte_get_64 ((hdrptr), (&signature_high), (&signature_low)); } else { * (&signature_low) = * (&signature_high) = 0; } } while (0);
   hdrptr += 8;
   do { do { unsigned int amount = (offset_size); if (sizeof (type_offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (type_offset)); amount = sizeof (type_offset); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) type_offset = 0; else type_offset = byte_get ((hdrptr), amount); } while (0); hdrptr += offset_size; } while (0);
 }

      if ((do_loc || do_debug_loc || do_debug_ranges)
   && num_debug_info_entries == 0
   && ! do_types)
 {
   debug_information [unit].cu_offset = cu_offset;
   debug_information [unit].pointer_size
     = compunit.cu_pointer_size;
   debug_information [unit].offset_size = offset_size;
   debug_information [unit].dwarf_version = compunit.cu_version;
   debug_information [unit].base_address = 0;
   debug_information [unit].addr_base = (unsigned int) -1;
   debug_information [unit].ranges_base = (unsigned int) -1;
   debug_information [unit].loc_offsets = 
# 2425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                         ((void *)0)
# 2425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                             ;
   debug_information [unit].have_frame_base = 
# 2426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                             ((void *)0)
# 2426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                 ;
   debug_information [unit].max_loc_offsets = 0;
   debug_information [unit].num_loc_offsets = 0;
   debug_information [unit].range_lists = 
# 2429 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                         ((void *)0)
# 2429 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                             ;
   debug_information [unit].max_range_lists= 0;
   debug_information [unit].num_range_lists = 0;
 }

      if (!do_loc && dwarf_start_die == 0)
 {
   printf (gettext ("  Compilation Unit @ offset 0x%s:\n"),
    dwarf_vmatoa ("x", cu_offset));
   printf (gettext ("   Length:        0x%s (%s)\n"),
    dwarf_vmatoa ("x", compunit.cu_length),
    offset_size == 8 ? "64-bit" : "32-bit");
   printf (gettext ("   Version:       %d\n"), compunit.cu_version);
   printf (gettext ("   Abbrev Offset: 0x%s\n"),
    dwarf_vmatoa ("x", compunit.cu_abbrev_offset));
   printf (gettext ("   Pointer Size:  %d\n"), compunit.cu_pointer_size);
   if (do_types)
     {
       char buf[64];

       printf (gettext ("   Signature:     0x%s\n"),
        dwarf_vmatoa64 (signature_high, signature_low,
          buf, sizeof (buf)));
       printf (gettext ("   Type Offset:   0x%s\n"),
        dwarf_vmatoa ("x", type_offset));
     }
   if (this_set != 
# 2455 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 2455 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      )
     {
       dwarf_vma *offsets = this_set->section_offsets;
       size_t *sizes = this_set->section_sizes;

       printf (gettext ("   Section contributions:\n"));
       printf (gettext ("    .debug_abbrev.dwo:       0x%s  0x%s\n"),
        dwarf_vmatoa ("x", offsets [DW_SECT_ABBREV]),
        dwarf_vmatoa ("x", sizes [DW_SECT_ABBREV]));
       printf (gettext ("    .debug_line.dwo:         0x%s  0x%s\n"),
        dwarf_vmatoa ("x", offsets [DW_SECT_LINE]),
        dwarf_vmatoa ("x", sizes [DW_SECT_LINE]));
       printf (gettext ("    .debug_loc.dwo:          0x%s  0x%s\n"),
        dwarf_vmatoa ("x", offsets [DW_SECT_LOC]),
        dwarf_vmatoa ("x", sizes [DW_SECT_LOC]));
       printf (gettext ("    .debug_str_offsets.dwo:  0x%s  0x%s\n"),
        dwarf_vmatoa ("x", offsets [DW_SECT_STR_OFFSETS]),
        dwarf_vmatoa ("x", sizes [DW_SECT_STR_OFFSETS]));
     }
 }

      if (cu_offset + compunit.cu_length + initial_length_size
   > section->size)
 {
   warn (gettext ("Debug info is corrupted, length of CU at %s" " extends beyond end of section (length = %s)\n")
                                                     ,
  dwarf_vmatoa ("x", cu_offset),
  dwarf_vmatoa ("x", compunit.cu_length));
   num_units = unit;
   break;
 }
      tags = hdrptr;
      start += compunit.cu_length + initial_length_size;

      if (start > end)
 {
   warn (gettext ("Debug info is corrupt.  CU at %s extends beyond end of section"),
  dwarf_vmatoa ("x", cu_offset));
   start = end;
 }

      if (compunit.cu_version != 2
   && compunit.cu_version != 3
   && compunit.cu_version != 4)
 {
   warn (gettext ("CU at offset %s contains corrupt or " "unsupported version number: %d.\n")
                                        ,
  dwarf_vmatoa ("x", cu_offset), compunit.cu_version);
   continue;
 }

      free_abbrevs ();


      if (compunit.cu_abbrev_offset >= abbrev_size)
 warn (gettext ("Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n"),
       (unsigned long) compunit.cu_abbrev_offset,
       (unsigned long) abbrev_size);

      else if ((abbrev_base + abbrev_size)
        > debug_displays [abbrev_sec].section.size)
 warn (gettext ("Debug info is corrupted, abbrev size (%lx) is larger than abbrev section size (%lx)\n"),
       (unsigned long) abbrev_base + abbrev_size,
       (unsigned long) debug_displays [abbrev_sec].section.size);
      else
 process_abbrev_section
   (((unsigned char *) debug_displays [abbrev_sec].section.start
     + abbrev_base + compunit.cu_abbrev_offset),
    ((unsigned char *) debug_displays [abbrev_sec].section.start
     + abbrev_base + abbrev_size));

      level = 0;
      last_level = level;
      saved_level = -1;
      while (tags < start)
 {
   unsigned int bytes_read;
   unsigned long abbrev_number;
   unsigned long die_offset;
   abbrev_entry *entry;
   abbrev_attr *attr;
   int do_printing = 1;

   die_offset = tags - section_begin;

   abbrev_number = read_uleb128 (tags, & bytes_read, start);
   tags += bytes_read;



   if (abbrev_number == 0)
     {

       if (level == 0 && start == end)
  {
    unsigned char *chk;

    for (chk = tags; chk < start; chk++)
      if (*chk != 0)
        break;
    if (chk == start)
      break;
  }

       if (!do_loc && die_offset >= dwarf_start_die
    && (dwarf_cutoff_level == -1
        || level < dwarf_cutoff_level))
  printf (gettext (" <%d><%lx>: Abbrev Number: 0\n"),
   level, die_offset);

       --level;
       if (level < 0)
  {
    static unsigned num_bogus_warns = 0;

    if (num_bogus_warns < 3)
      {
        warn (gettext ("Bogus end-of-siblings marker detected at offset %lx in %s section\n"),
       die_offset, section->name);
        num_bogus_warns ++;
        if (num_bogus_warns == 3)
   warn (gettext ("Further warnings about bogus end-of-sibling markers suppressed\n"));
      }
  }
       if (dwarf_start_die != 0 && level < saved_level)
  return 1;
       continue;
     }

   if (!do_loc)
     {
       if (dwarf_start_die != 0 && die_offset < dwarf_start_die)
  do_printing = 0;
       else
  {
    if (dwarf_start_die != 0 && die_offset == dwarf_start_die)
      saved_level = level;
    do_printing = (dwarf_cutoff_level == -1
     || level < dwarf_cutoff_level);
    if (do_printing)
      printf (gettext (" <%d><%lx>: Abbrev Number: %lu"),
       level, die_offset, abbrev_number);
    else if (dwarf_cutoff_level == -1
      || last_level < dwarf_cutoff_level)
      printf (gettext (" <%d><%lx>: ...\n"), level, die_offset);
    last_level = level;
  }
     }



   for (entry = first_abbrev;
        entry && entry->entry != abbrev_number;
        entry = entry->next)
     continue;

   if (entry == 
# 2611 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
               ((void *)0)
# 2611 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                   )
     {
       if (!do_loc && do_printing)
  {
    printf ("\n");
    fflush (
# 2616 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
           stdout
# 2616 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 );
  }
       warn (gettext ("DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\n"),
      die_offset, abbrev_number);
       return 0;
     }

   if (!do_loc && do_printing)
     printf (" (%s)\n", get_TAG_name (entry->tag));

   switch (entry->tag)
     {
     default:
       need_base_address = 0;
       break;
     case DW_TAG_compile_unit:
       need_base_address = 1;
       break;
     case DW_TAG_entry_point:
     case DW_TAG_subprogram:
       need_base_address = 0;

       have_frame_base = 0;
       break;
     }

   for (attr = entry->first_attr;
        attr && attr->attribute;
        attr = attr->next)
     {
       debug_info *arg;

       if (! do_loc && do_printing)

  printf ("    <%lx>", (unsigned long)(tags - section_begin));

       if (debug_information && unit < alloc_num_debug_info_entries)
  arg = debug_information + unit;
       else
  arg = 
# 2655 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 2655 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           ;

       tags = read_and_display_attr (attr->attribute,
         attr->form,
         tags,
         end,
         cu_offset,
         compunit.cu_pointer_size,
         offset_size,
         compunit.cu_version,
         arg,
         do_loc || ! do_printing,
         section,
         this_set);
     }

   if (entry->children)
     ++level;
 }
    }



  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0
      && ! do_types)
    {
      if (num_units > alloc_num_debug_info_entries)
 num_debug_info_entries = alloc_num_debug_info_entries;
      else
 num_debug_info_entries = num_units;
    }

  if (!do_loc)
    printf ("\n");

  return 1;
}







static unsigned int
load_debug_info (void * file)
{


  last_pointer_size = 0;
  warned_about_missing_comp_units = 0;



  if (num_debug_info_entries == (unsigned int) -1)
    return 0;


  if (num_debug_info_entries > 0)
    return num_debug_info_entries;


  load_cu_tu_indexes (file);

  if (load_debug_section (info, file)
      && process_debug_info (&debug_displays [info].section, file, abbrev, 1, 0))
    return num_debug_info_entries;

  if (load_debug_section (info_dwo, file)
      && process_debug_info (&debug_displays [info_dwo].section, file,
        abbrev_dwo, 1, 0))
    return num_debug_info_entries;

  num_debug_info_entries = (unsigned int) -1;
  return 0;
}






static unsigned char *
read_debug_line_header (struct dwarf_section * section,
   unsigned char * data,
   unsigned char * end,
   DWARF2_Internal_LineInfo * linfo,
   unsigned char ** end_of_sequence)
{
  unsigned char *hdrptr;
  unsigned int offset_size;
  unsigned int initial_length_size;



  hdrptr = data;


  do { do { unsigned int amount = (4); if (sizeof (linfo->li_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (linfo->li_length)); amount = sizeof (linfo->li_length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) linfo->li_length = 0; else linfo->li_length = byte_get ((hdrptr), amount); } while (0); hdrptr += 4; } while (0);

  if (linfo->li_length == 0xffffffff)
    {

      do { do { unsigned int amount = (8); if (sizeof (linfo->li_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (linfo->li_length)); amount = sizeof (linfo->li_length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) linfo->li_length = 0; else linfo->li_length = byte_get ((hdrptr), amount); } while (0); hdrptr += 8; } while (0);
      offset_size = 8;
      initial_length_size = 12;
    }
  else
    {
      offset_size = 4;
      initial_length_size = 4;
    }

  if (linfo->li_length + initial_length_size > section->size)
    {






      if (reloc_at (section, (hdrptr - section->start) - offset_size))
 {
   linfo->li_length = (end - data) - initial_length_size;
 }
      else
 {
   warn (gettext ("The length field (0x%lx) in the debug_line header is wrong - the section is too small\n"),
  (long) linfo->li_length);
   return 
# 2785 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
         ((void *)0)
# 2785 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
             ;
 }
    }


  do { do { unsigned int amount = (2); if (sizeof (linfo->li_version) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (linfo->li_version)); amount = sizeof (linfo->li_version); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) linfo->li_version = 0; else linfo->li_version = byte_get ((hdrptr), amount); } while (0); hdrptr += 2; } while (0);

  if (linfo->li_version != 2
      && linfo->li_version != 3
      && linfo->li_version != 4)
    {
      warn (gettext ("Only DWARF version 2, 3 and 4 line info is currently supported.\n"));
      return 
# 2797 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
            ((void *)0)
# 2797 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                ;
    }

  do { do { unsigned int amount = (offset_size); if (sizeof (linfo->li_prologue_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (linfo->li_prologue_length)); amount = sizeof (linfo->li_prologue_length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) linfo->li_prologue_length = 0; else linfo->li_prologue_length = byte_get ((hdrptr), amount); } while (0); hdrptr += offset_size; } while (0);
  do { do { unsigned int amount = (1); if (sizeof (linfo->li_min_insn_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (linfo->li_min_insn_length)); amount = sizeof (linfo->li_min_insn_length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) linfo->li_min_insn_length = 0; else linfo->li_min_insn_length = byte_get ((hdrptr), amount); } while (0); hdrptr += 1; } while (0);

  if (linfo->li_version >= 4)
    {
      do { do { unsigned int amount = (1); if (sizeof (linfo->li_max_ops_per_insn) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (linfo->li_max_ops_per_insn)); amount = sizeof (linfo->li_max_ops_per_insn); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) linfo->li_max_ops_per_insn = 0; else linfo->li_max_ops_per_insn = byte_get ((hdrptr), amount); } while (0); hdrptr += 1; } while (0);

      if (linfo->li_max_ops_per_insn == 0)
 {
   warn (gettext ("Invalid maximum operations per insn.\n"));
   return 
# 2810 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
         ((void *)0)
# 2810 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
             ;
 }
    }
  else
    linfo->li_max_ops_per_insn = 1;

  do { do { unsigned int amount = (1); if (sizeof (linfo->li_default_is_stmt) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (linfo->li_default_is_stmt)); amount = sizeof (linfo->li_default_is_stmt); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) linfo->li_default_is_stmt = 0; else linfo->li_default_is_stmt = byte_get ((hdrptr), amount); } while (0); hdrptr += 1; } while (0);
  do { do { unsigned int amount = (1); if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount) linfo->li_line_base = byte_get_signed ((hdrptr), amount); else linfo->li_line_base = 0; } while (0); hdrptr += 1; } while (0);
  do { do { unsigned int amount = (1); if (sizeof (linfo->li_line_range) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (linfo->li_line_range)); amount = sizeof (linfo->li_line_range); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) linfo->li_line_range = 0; else linfo->li_line_range = byte_get ((hdrptr), amount); } while (0); hdrptr += 1; } while (0);
  do { do { unsigned int amount = (1); if (sizeof (linfo->li_opcode_base) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (linfo->li_opcode_base)); amount = sizeof (linfo->li_opcode_base); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) linfo->li_opcode_base = 0; else linfo->li_opcode_base = byte_get ((hdrptr), amount); } while (0); hdrptr += 1; } while (0);

  * end_of_sequence = data + linfo->li_length + initial_length_size;

  if (* end_of_sequence > end)
    {
      warn (gettext ("Line length %s extends beyond end of section\n"),
     dwarf_vmatoa ("u", linfo->li_length));
      * end_of_sequence = end;
      return 
# 2828 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
            ((void *)0)
# 2828 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                ;
    }

  return hdrptr;
}

static int
display_debug_lines_raw (struct dwarf_section *section,
    unsigned char *data,
    unsigned char *end)
{
  unsigned char *start = section->start;

  printf (gettext ("Raw dump of debug contents of section %s:\n\n"),
   section->name);

  while (data < end)
    {
      static DWARF2_Internal_LineInfo saved_linfo;
      DWARF2_Internal_LineInfo linfo;
      unsigned char *standard_opcodes;
      unsigned char *end_of_sequence;
      unsigned int last_dir_entry = 0;
      int i;

      if ((strncmp ((section->name), (".debug_line."), sizeof (".debug_line.") - 1) == 0)


   && strcmp (section->name, ".debug_line.dwo") != 0)
 {
# 2868 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
   end_of_sequence = end;
   standard_opcodes = 
# 2869 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 2869 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         ;
   linfo = saved_linfo;

   if (linfo.li_line_range == 0)
     {
       warn (gettext ("Partial .debug_line. section encountered without a prior full .debug_line section\n"));
       return 0;
     }
   reset_state_machine (linfo.li_default_is_stmt);
 }
      else
 {
   unsigned char * hdrptr;

   if ((hdrptr = read_debug_line_header (section, data, end, & linfo,
      & end_of_sequence)) == 
# 2884 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                            ((void *)0)
# 2884 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                )
     return 0;

   printf (gettext ("  Offset:                      0x%lx\n"), (long)(data - start));
   printf (gettext ("  Length:                      %ld\n"), (long) linfo.li_length);
   printf (gettext ("  DWARF Version:               %d\n"), linfo.li_version);
   printf (gettext ("  Prologue Length:             %d\n"), (int) linfo.li_prologue_length);
   printf (gettext ("  Minimum Instruction Length:  %d\n"), linfo.li_min_insn_length);
   if (linfo.li_version >= 4)
     printf (gettext ("  Maximum Ops per Instruction: %d\n"), linfo.li_max_ops_per_insn);
   printf (gettext ("  Initial value of 'is_stmt':  %d\n"), linfo.li_default_is_stmt);
   printf (gettext ("  Line Base:                   %d\n"), linfo.li_line_base);
   printf (gettext ("  Line Range:                  %d\n"), linfo.li_line_range);
   printf (gettext ("  Opcode Base:                 %d\n"), linfo.li_opcode_base);


   if (linfo.li_line_range == 0)
     {
       warn (gettext ("Line range of 0 is invalid, using 1 instead\n"));
       linfo.li_line_range = 1;
     }

   reset_state_machine (linfo.li_default_is_stmt);


   standard_opcodes = hdrptr;


   if (standard_opcodes + linfo.li_opcode_base >= end)
     {
       warn (gettext ("Line Base extends beyond end of section\n"));
       return 0;
     }

   printf (gettext ("\n Opcodes:\n"));

   for (i = 1; i < linfo.li_opcode_base; i++)
     printf (gettext ("  Opcode %d has %d args\n"), i, standard_opcodes[i - 1]);


   data = standard_opcodes + linfo.li_opcode_base - 1;

   if (*data == 0)
     printf (gettext ("\n The Directory Table is empty.\n"));
   else
     {
       printf (gettext ("\n The Directory Table (offset 0x%lx):\n"),
        (long)(data - start));

       while (data < end && *data != 0)
  {
    printf ("  %d\t%.*s\n", ++last_dir_entry, (int) (end - data), data);

    data += strnlen ((char *) data, end - data) + 1;
  }


       if (data >= end - 1)
  break;
     }


   data++;


   if (*data == 0)
     printf (gettext ("\n The File Name Table is empty.\n"));
   else
     {
       printf (gettext ("\n The File Name Table (offset 0x%lx):\n"),
        (long)(data - start));
       printf (gettext ("  Entry\tDir\tTime\tSize\tName\n"));

       while (data < end && *data != 0)
  {
    unsigned char *name;
    unsigned int bytes_read;

    printf ("  %d\t", ++state_machine_regs.last_file_entry);
    name = data;
    data += strnlen ((char *) data, end - data) + 1;

    printf ("%s\t",
     dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
    data += bytes_read;
    printf ("%s\t",
     dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
    data += bytes_read;
    printf ("%s\t",
     dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
    data += bytes_read;
    printf ("%.*s\n", (int)(end - name), name);

    if (data == end)
      {
        warn (gettext ("Corrupt file name table entry\n"));
        break;
      }
  }
     }


   data++;
   putchar ('\n');
   saved_linfo = linfo;
 }


      if (data >= end_of_sequence)
 printf (gettext (" No Line Number Statements.\n"));
      else
 {
   printf (gettext (" Line Number Statements:\n"));

   while (data < end_of_sequence)
     {
       unsigned char op_code;
       dwarf_signed_vma adv;
       dwarf_vma uladv;
       unsigned int bytes_read;

       printf ("  [0x%08lx]", (long)(data - start));

       op_code = *data++;

       if (op_code >= linfo.li_opcode_base)
  {
    op_code -= linfo.li_opcode_base;
    uladv = (op_code / linfo.li_line_range);
    if (linfo.li_max_ops_per_insn == 1)
      {
        uladv *= linfo.li_min_insn_length;
        state_machine_regs.address += uladv;
        printf (gettext ("  Special opcode %d: " "advance Address by %s to 0x%s")
                                    ,
         op_code, dwarf_vmatoa ("u", uladv),
         dwarf_vmatoa ("x", state_machine_regs.address));
      }
    else
      {
        state_machine_regs.address
   += ((state_machine_regs.op_index + uladv)
       / linfo.li_max_ops_per_insn)
   * linfo.li_min_insn_length;
        state_machine_regs.op_index
   = (state_machine_regs.op_index + uladv)
   % linfo.li_max_ops_per_insn;
        printf (gettext ("  Special opcode %d: " "advance Address by %s to 0x%s[%d]")
                                        ,
         op_code, dwarf_vmatoa ("u", uladv),
         dwarf_vmatoa ("x", state_machine_regs.address),
         state_machine_regs.op_index);
      }
    adv = (op_code % linfo.li_line_range) + linfo.li_line_base;
    state_machine_regs.line += adv;
    printf (gettext (" and Line by %s to %d\n"),
     dwarf_vmatoa ("d", adv), state_machine_regs.line);
  }
       else switch (op_code)
       {
       case DW_LNS_extended_op:
         data += process_extended_line_op (data, linfo.li_default_is_stmt, end);
         break;

       case DW_LNS_copy:
         printf (gettext ("  Copy\n"));
         break;

       case DW_LNS_advance_pc:
         uladv = read_uleb128 (data, & bytes_read, end);
         data += bytes_read;
         if (linfo.li_max_ops_per_insn == 1)
    {
      uladv *= linfo.li_min_insn_length;
      state_machine_regs.address += uladv;
      printf (gettext ("  Advance PC by %s to 0x%s\n"),
       dwarf_vmatoa ("u", uladv),
       dwarf_vmatoa ("x", state_machine_regs.address));
    }
         else
    {
      state_machine_regs.address
        += ((state_machine_regs.op_index + uladv)
     / linfo.li_max_ops_per_insn)
        * linfo.li_min_insn_length;
      state_machine_regs.op_index
        = (state_machine_regs.op_index + uladv)
        % linfo.li_max_ops_per_insn;
      printf (gettext ("  Advance PC by %s to 0x%s[%d]\n"),
       dwarf_vmatoa ("u", uladv),
       dwarf_vmatoa ("x", state_machine_regs.address),
       state_machine_regs.op_index);
    }
         break;

       case DW_LNS_advance_line:
         adv = read_sleb128 (data, & bytes_read, end);
         data += bytes_read;
         state_machine_regs.line += adv;
         printf (gettext ("  Advance Line by %s to %d\n"),
          dwarf_vmatoa ("d", adv),
          state_machine_regs.line);
         break;

       case DW_LNS_set_file:
         adv = read_uleb128 (data, & bytes_read, end);
         data += bytes_read;
         printf (gettext ("  Set File Name to entry %s in the File Name Table\n"),
          dwarf_vmatoa ("d", adv));
         state_machine_regs.file = adv;
         break;

       case DW_LNS_set_column:
         uladv = read_uleb128 (data, & bytes_read, end);
         data += bytes_read;
         printf (gettext ("  Set column to %s\n"),
          dwarf_vmatoa ("u", uladv));
         state_machine_regs.column = uladv;
         break;

       case DW_LNS_negate_stmt:
         adv = state_machine_regs.is_stmt;
         adv = ! adv;
         printf (gettext ("  Set is_stmt to %s\n"), dwarf_vmatoa ("d", adv));
         state_machine_regs.is_stmt = adv;
         break;

       case DW_LNS_set_basic_block:
         printf (gettext ("  Set basic block\n"));
         state_machine_regs.basic_block = 1;
         break;

       case DW_LNS_const_add_pc:
         uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);
         if (linfo.li_max_ops_per_insn)
    {
      uladv *= linfo.li_min_insn_length;
      state_machine_regs.address += uladv;
      printf (gettext ("  Advance PC by constant %s to 0x%s\n"),
       dwarf_vmatoa ("u", uladv),
       dwarf_vmatoa ("x", state_machine_regs.address));
    }
         else
    {
      state_machine_regs.address
        += ((state_machine_regs.op_index + uladv)
     / linfo.li_max_ops_per_insn)
        * linfo.li_min_insn_length;
      state_machine_regs.op_index
        = (state_machine_regs.op_index + uladv)
        % linfo.li_max_ops_per_insn;
      printf (gettext ("  Advance PC by constant %s to 0x%s[%d]\n"),
       dwarf_vmatoa ("u", uladv),
       dwarf_vmatoa ("x", state_machine_regs.address),
       state_machine_regs.op_index);
    }
         break;

       case DW_LNS_fixed_advance_pc:
         do { do { unsigned int amount = (2); if (sizeof (uladv) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uladv)); amount = sizeof (uladv); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uladv = 0; else uladv = byte_get ((data), amount); } while (0); data += 2; } while (0);
         state_machine_regs.address += uladv;
         state_machine_regs.op_index = 0;
         printf (gettext ("  Advance PC by fixed size amount %s to 0x%s\n"),
          dwarf_vmatoa ("u", uladv),
          dwarf_vmatoa ("x", state_machine_regs.address));
         break;

       case DW_LNS_set_prologue_end:
         printf (gettext ("  Set prologue_end to true\n"));
         break;

       case DW_LNS_set_epilogue_begin:
         printf (gettext ("  Set epilogue_begin to true\n"));
         break;

       case DW_LNS_set_isa:
         uladv = read_uleb128 (data, & bytes_read, end);
         data += bytes_read;
         printf (gettext ("  Set ISA to %s\n"), dwarf_vmatoa ("u", uladv));
         break;

       default:
         printf (gettext ("  Unknown opcode %d with operands: "), op_code);

         if (standard_opcodes != 
# 3168 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                ((void *)0)
# 3168 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                    )
    for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)
      {
        printf ("0x%s%s", dwarf_vmatoa ("x", read_uleb128 (data,
          &bytes_read, end)),
         i == 1 ? "" : ", ");
        data += bytes_read;
      }
         putchar ('\n');
         break;
       }
     }
   putchar ('\n');
 }
    }

  return 1;
}

typedef struct
{
  unsigned char *name;
  unsigned int directory_index;
  unsigned int modification_date;
  unsigned int length;
} File_Entry;



static int
display_debug_lines_decoded (struct dwarf_section *section,
        unsigned char *data,
        unsigned char *end)
{
  static DWARF2_Internal_LineInfo saved_linfo;

  printf (gettext ("Decoded dump of debug contents of section %s:\n\n"),
   section->name);

  while (data < end)
    {

      DWARF2_Internal_LineInfo linfo;
      unsigned char *standard_opcodes;
      unsigned char *end_of_sequence;
      int i;
      File_Entry *file_table = 
# 3214 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 3214 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  ;
      unsigned int n_files = 0;
      unsigned char **directory_table = 
# 3216 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                       ((void *)0)
# 3216 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                           ;
      unsigned int n_directories = 0;

      if ((strncmp ((section->name), (".debug_line."), sizeof (".debug_line.") - 1) == 0)


   && strcmp (section->name, ".debug_line.dwo") != 0)
 {

   end_of_sequence = end;
   standard_opcodes = 
# 3226 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 3226 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         ;
   linfo = saved_linfo;

   if (linfo.li_line_range == 0)
     {
       warn (gettext ("Partial .debug_line. section encountered without a prior full .debug_line section\n"));
       return 0;
     }
   reset_state_machine (linfo.li_default_is_stmt);
 }
      else
 {
   unsigned char *hdrptr;

   if ((hdrptr = read_debug_line_header (section, data, end, & linfo,
      & end_of_sequence)) == 
# 3241 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                            ((void *)0)
# 3241 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                )
       return 0;


   if (linfo.li_line_range == 0)
     {
       warn (gettext ("Line range of 0 is invalid, using 1 instead\n"));
       linfo.li_line_range = 1;
     }
   reset_state_machine (linfo.li_default_is_stmt);


   standard_opcodes = hdrptr;


   data = standard_opcodes + linfo.li_opcode_base - 1;

   if (data >= end)
     {
       warn (gettext ("opcode base of %d extends beyond end of section\n"),
      linfo.li_opcode_base);
       return 0;
     }

   if (*data != 0)
     {
       unsigned char *ptr_directory_table = data;

       while (data < end && *data != 0)
  {
    data += strnlen ((char *) data, end - data) + 1;
    n_directories++;
  }


       if (data >= end)
  {
    warn (gettext ("directory table ends unexpectedly\n"));
    n_directories = 0;
    break;
  }


       directory_table = (unsigned char **)
  xmalloc (n_directories * sizeof (unsigned char *));

       i = 0;
       while (*ptr_directory_table != 0)
  {
    directory_table[i] = ptr_directory_table;
    ptr_directory_table += strnlen ((char *) ptr_directory_table,
        ptr_directory_table - end) + 1;
    i++;
  }
     }

   data++;


   if (data < end && *data != 0)
     {
       unsigned char *ptr_file_name_table = data;

       while (data < end && *data != 0)
  {
    unsigned int bytes_read;



    data += strnlen ((char *) data, end - data) + 1;
    read_uleb128 (data, & bytes_read, end);
    data += bytes_read;
    read_uleb128 (data, & bytes_read, end);
    data += bytes_read;
    read_uleb128 (data, & bytes_read, end);
    data += bytes_read;

    n_files++;
  }

       if (data >= end)
  {
    warn (gettext ("file table ends unexpectedly\n"));
    n_files = 0;
    break;
  }


       file_table = (File_Entry *) xmalloc (n_files * sizeof (File_Entry));

       i = 0;
       while (*ptr_file_name_table != 0)
  {
    unsigned int bytes_read;

    file_table[i].name = ptr_file_name_table;
    ptr_file_name_table += strnlen ((char *) ptr_file_name_table,
        end - ptr_file_name_table) + 1;


    file_table[i].directory_index = read_uleb128 (ptr_file_name_table,
        & bytes_read, end);
    ptr_file_name_table += bytes_read;
    file_table[i].modification_date = read_uleb128 (ptr_file_name_table,
          & bytes_read, end);
    ptr_file_name_table += bytes_read;
    file_table[i].length = read_uleb128 (ptr_file_name_table, & bytes_read, end);
    ptr_file_name_table += bytes_read;
    i++;
  }
       i = 0;


       if (directory_table == 
# 3354 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                             ((void *)0)
# 3354 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                 )
  {
    printf (gettext ("CU: %s:\n"), file_table[0].name);
    printf (gettext ("File name                            Line number    Starting address\n"));
  }
       else
  {
    unsigned int ix = file_table[0].directory_index;
    const char *directory;

    if (ix == 0)
      directory = ".";

    else if (n_directories == 0)
      directory = gettext ("<unknown>");
    else if (ix > n_directories)
      {
        warn (gettext ("directory index %u > number of directories %u\n"), ix, n_directories);
        directory = gettext ("<corrupt>");
      }
    else
      directory = (char *) directory_table[ix - 1];

    if (do_wide || strlen (directory) < 76)
      printf (gettext ("CU: %s/%s:\n"), directory, file_table[0].name);
    else
      printf ("%s:\n", file_table[0].name);

    printf (gettext ("File name                            Line number    Starting address\n"));
  }
     }


   data++;

   saved_linfo = linfo;
 }


      while (data < end_of_sequence)
 {
   unsigned char op_code;
   int adv;
   unsigned long int uladv;
   unsigned int bytes_read;
   int is_special_opcode = 0;

   op_code = *data++;

   if (op_code >= linfo.li_opcode_base)
     {
       op_code -= linfo.li_opcode_base;
       uladv = (op_code / linfo.li_line_range);
       if (linfo.li_max_ops_per_insn == 1)
  {
    uladv *= linfo.li_min_insn_length;
    state_machine_regs.address += uladv;
  }
       else
  {
    state_machine_regs.address
      += ((state_machine_regs.op_index + uladv)
   / linfo.li_max_ops_per_insn)
      * linfo.li_min_insn_length;
    state_machine_regs.op_index
      = (state_machine_regs.op_index + uladv)
      % linfo.li_max_ops_per_insn;
  }

       adv = (op_code % linfo.li_line_range) + linfo.li_line_base;
       state_machine_regs.line += adv;
       is_special_opcode = 1;
     }
   else switch (op_code)
   {
   case DW_LNS_extended_op:
     {
       unsigned int ext_op_code_len;
       unsigned char ext_op_code;
       unsigned char *op_code_data = data;

       ext_op_code_len = read_uleb128 (op_code_data, &bytes_read,
           end_of_sequence);
       op_code_data += bytes_read;

       if (ext_op_code_len == 0)
         {
    warn (gettext ("Badly formed extended line op encountered!\n"));
    break;
         }
       ext_op_code_len += bytes_read;
       ext_op_code = *op_code_data++;

       switch (ext_op_code)
         {
         case DW_LNE_end_sequence:
    reset_state_machine (linfo.li_default_is_stmt);
    break;
         case DW_LNE_set_address:
    do { do { unsigned int amount = (ext_op_code_len - bytes_read - 1); if (sizeof (state_machine_regs.address) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (state_machine_regs.address)); amount = sizeof (state_machine_regs.address); } if (((op_code_data) + amount) >= (end)) { if ((op_code_data) < (end)) amount = (end) - (op_code_data); else amount = 0; } if (amount == 0 || amount > 8) state_machine_regs.address = 0; else state_machine_regs.address = byte_get ((op_code_data), amount); } while (0); op_code_data += ext_op_code_len - bytes_read - 1; } while (0)


          ;
    state_machine_regs.op_index = 0;
    break;
         case DW_LNE_define_file:
    {
      file_table = (File_Entry *) xrealloc
        (file_table, (n_files + 1) * sizeof (File_Entry));

      ++state_machine_regs.last_file_entry;

      file_table[n_files].name = op_code_data;
      op_code_data += strlen ((char *) op_code_data) + 1;

      file_table[n_files].directory_index =
        read_uleb128 (op_code_data, & bytes_read,
        end_of_sequence);
      op_code_data += bytes_read;

      file_table[n_files].modification_date =
        read_uleb128 (op_code_data, & bytes_read,
        end_of_sequence);
      op_code_data += bytes_read;

      file_table[n_files].length =
        read_uleb128 (op_code_data, & bytes_read,
        end_of_sequence);

      n_files++;
      break;
    }
         case DW_LNE_set_discriminator:
         case DW_LNE_HP_set_sequence:

    break;

         default:
    printf (gettext ("UNKNOWN (%u): length %d\n"),
     ext_op_code, ext_op_code_len - bytes_read);
    break;
         }
       data += ext_op_code_len;
       break;
     }
   case DW_LNS_copy:
     break;

   case DW_LNS_advance_pc:
     uladv = read_uleb128 (data, & bytes_read, end);
     data += bytes_read;
     if (linfo.li_max_ops_per_insn == 1)
       {
         uladv *= linfo.li_min_insn_length;
         state_machine_regs.address += uladv;
       }
     else
       {
         state_machine_regs.address
    += ((state_machine_regs.op_index + uladv)
        / linfo.li_max_ops_per_insn)
    * linfo.li_min_insn_length;
         state_machine_regs.op_index
    = (state_machine_regs.op_index + uladv)
    % linfo.li_max_ops_per_insn;
       }
     break;

   case DW_LNS_advance_line:
     adv = read_sleb128 (data, & bytes_read, end);
     data += bytes_read;
     state_machine_regs.line += adv;
     break;

   case DW_LNS_set_file:
     adv = read_uleb128 (data, & bytes_read, end);
     data += bytes_read;
     state_machine_regs.file = adv;

     {
       unsigned file = state_machine_regs.file - 1;
       unsigned dir;

       if (file_table == 
# 3537 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                        ((void *)0) 
# 3537 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             || n_files == 0)
         printf (gettext ("\n [Use file table entry %d]\n"), file);

       else if (file >= n_files)
         {
    warn (gettext ("file index %u > number of files %u\n"), file + 1, n_files);
    printf (gettext ("\n <over large file table index %u>"), file);
         }
       else if ((dir = file_table[file].directory_index) == 0)

         printf ("\n./%s:[++]\n", file_table[file].name);
       else if (directory_table == 
# 3548 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                  ((void *)0) 
# 3548 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                       || n_directories == 0)
         printf (gettext ("\n [Use file %s in directory table entry %d]\n"),
          file_table[file].name, dir);

       else if (dir > n_directories)
         {
    warn (gettext ("directory index %u > number of directories %u\n"), dir, n_directories);
    printf (gettext ("\n <over large directory table entry %u>\n"), dir);
         }
       else
         printf ("\n%s/%s:\n",

          directory_table[dir - 1], file_table[file].name);
     }
     break;

   case DW_LNS_set_column:
     uladv = read_uleb128 (data, & bytes_read, end);
     data += bytes_read;
     state_machine_regs.column = uladv;
     break;

   case DW_LNS_negate_stmt:
     adv = state_machine_regs.is_stmt;
     adv = ! adv;
     state_machine_regs.is_stmt = adv;
     break;

   case DW_LNS_set_basic_block:
     state_machine_regs.basic_block = 1;
     break;

   case DW_LNS_const_add_pc:
     uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);
     if (linfo.li_max_ops_per_insn == 1)
       {
         uladv *= linfo.li_min_insn_length;
         state_machine_regs.address += uladv;
       }
     else
       {
         state_machine_regs.address
    += ((state_machine_regs.op_index + uladv)
        / linfo.li_max_ops_per_insn)
    * linfo.li_min_insn_length;
         state_machine_regs.op_index
    = (state_machine_regs.op_index + uladv)
    % linfo.li_max_ops_per_insn;
       }
     break;

   case DW_LNS_fixed_advance_pc:
     do { do { unsigned int amount = (2); if (sizeof (uladv) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (uladv)); amount = sizeof (uladv); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) uladv = 0; else uladv = byte_get ((data), amount); } while (0); data += 2; } while (0);
     state_machine_regs.address += uladv;
     state_machine_regs.op_index = 0;
     break;

   case DW_LNS_set_prologue_end:
     break;

   case DW_LNS_set_epilogue_begin:
     break;

   case DW_LNS_set_isa:
     uladv = read_uleb128 (data, & bytes_read, end);
     data += bytes_read;
     printf (gettext ("  Set ISA to %lu\n"), uladv);
     break;

   default:
     printf (gettext ("  Unknown opcode %d with operands: "), op_code);

     if (standard_opcodes != 
# 3620 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                            ((void *)0)
# 3620 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                )
       for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)
         {
    printf ("0x%s%s", dwarf_vmatoa ("x", read_uleb128 (data,
             &bytes_read, end)),
     i == 1 ? "" : ", ");
    data += bytes_read;
         }
     putchar ('\n');
     break;
   }



   if ((is_special_opcode) || (op_code == DW_LNE_end_sequence)
       || (op_code == DW_LNS_copy))
     {
       const unsigned int MAX_FILENAME_LENGTH = 35;
       char *fileName;
       char *newFileName = 
# 3639 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                          ((void *)0)
# 3639 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                              ;
       size_t fileNameLength;

       if (file_table)
  {
    unsigned indx = state_machine_regs.file - 1;

    if (indx >= n_files)
      {
        warn (gettext ("corrupt file index %u encountered\n"), indx);
        fileName = gettext ("<corrupt>");
      }
    else
      fileName = (char *) file_table[indx].name;
  }
       else
  fileName = gettext ("<unknown>");

       fileNameLength = strlen (fileName);

       if ((fileNameLength > MAX_FILENAME_LENGTH) && (!do_wide))
  {
    newFileName = (char *) xmalloc (MAX_FILENAME_LENGTH + 1);

    strncpy (newFileName,
      fileName + fileNameLength - MAX_FILENAME_LENGTH,
      MAX_FILENAME_LENGTH + 1);
  }
       else
  {
    newFileName = (char *) xmalloc (fileNameLength + 1);
    strncpy (newFileName, fileName, fileNameLength + 1);
  }

       if (!do_wide || (fileNameLength <= MAX_FILENAME_LENGTH))
  {
    if (linfo.li_max_ops_per_insn == 1)
      printf ("%-35s  %11d  %#18" "l" "x\n",
       newFileName, state_machine_regs.line,
       state_machine_regs.address);
    else
      printf ("%-35s  %11d  %#18" "l" "x[%d]\n",
       newFileName, state_machine_regs.line,
       state_machine_regs.address,
       state_machine_regs.op_index);
  }
       else
  {
    if (linfo.li_max_ops_per_insn == 1)
      printf ("%s  %11d  %#18" "l" "x\n",
       newFileName, state_machine_regs.line,
       state_machine_regs.address);
    else
      printf ("%s  %11d  %#18" "l" "x[%d]\n",
       newFileName, state_machine_regs.line,
       state_machine_regs.address,
       state_machine_regs.op_index);
  }

       if (op_code == DW_LNE_end_sequence)
  printf ("\n");

       free (newFileName);
     }
 }

      if (file_table)
 {
   free (file_table);
   file_table = 
# 3708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
               ((void *)0)
# 3708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                   ;
   n_files = 0;
 }

      if (directory_table)
 {
   free (directory_table);
   directory_table = 
# 3715 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                    ((void *)0)
# 3715 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                        ;
   n_directories = 0;
 }

      putchar ('\n');
    }

  return 1;
}

static int
display_debug_lines (struct dwarf_section *section, void *file __attribute__ ((__unused__)))
{
  unsigned char *data = section->start;
  unsigned char *end = data + section->size;
  int retValRaw = 1;
  int retValDecoded = 1;

  if (do_debug_lines == 0)
    do_debug_lines |= 1;

  if (do_debug_lines & 1)
    retValRaw = display_debug_lines_raw (section, data, end);

  if (do_debug_lines & 2)
    retValDecoded = display_debug_lines_decoded (section, data, end);

  if (!retValRaw || !retValDecoded)
    return 0;

  return 1;
}

static debug_info *
find_debug_info_for_offset (unsigned long offset)
{
  unsigned int i;

  if (num_debug_info_entries == (unsigned int) -1)
    return 
# 3754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 3754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;

  for (i = 0; i < num_debug_info_entries; i++)
    if (debug_information[i].cu_offset == offset)
      return debug_information + i;

  return 
# 3760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
        ((void *)0)
# 3760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
            ;
}

static const char *
get_gdb_index_symbol_kind_name (gdb_index_symbol_kind kind)
{

  static const char * const kinds[] =
  {
    ("no info"),
    ("type"),
    ("variable"),
    ("function"),
    ("other"),
    ("unused5"),
    ("unused6"),
    ("unused7")
  };

  return gettext (kinds[kind]);
}

static int
display_debug_pubnames_worker (struct dwarf_section *section,
          void *file __attribute__ ((__unused__)),
          int is_gnu)
{
  DWARF2_Internal_PubNames names;
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;



  load_debug_info (file);

  printf (gettext ("Contents of the %s section:\n\n"), section->name);

  while (start < end)
    {
      unsigned char *data;
      unsigned char *adr;
      dwarf_vma offset;
      unsigned int offset_size, initial_length_size;

      data = start;

      do { do { unsigned int amount = (4); if (sizeof (names.pn_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (names.pn_length)); amount = sizeof (names.pn_length); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) names.pn_length = 0; else names.pn_length = byte_get ((data), amount); } while (0); data += 4; } while (0);
      if (names.pn_length == 0xffffffff)
 {
   do { do { unsigned int amount = (8); if (sizeof (names.pn_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (names.pn_length)); amount = sizeof (names.pn_length); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) names.pn_length = 0; else names.pn_length = byte_get ((data), amount); } while (0); data += 8; } while (0);
   offset_size = 8;
   initial_length_size = 12;
 }
      else
 {
   offset_size = 4;
   initial_length_size = 4;
 }

      do { do { unsigned int amount = (2); if (sizeof (names.pn_version) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (names.pn_version)); amount = sizeof (names.pn_version); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) names.pn_version = 0; else names.pn_version = byte_get ((data), amount); } while (0); data += 2; } while (0);
      do { do { unsigned int amount = (offset_size); if (sizeof (names.pn_offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (names.pn_offset)); amount = sizeof (names.pn_offset); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) names.pn_offset = 0; else names.pn_offset = byte_get ((data), amount); } while (0); data += offset_size; } while (0);

      if (num_debug_info_entries != (unsigned int) -1
   && num_debug_info_entries > 0
   && find_debug_info_for_offset (names.pn_offset) == 
# 3824 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                     ((void *)0)
# 3824 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                         )
 warn (gettext (".debug_info offset of 0x%lx in %s section does not point to a CU header.\n"),
       (unsigned long) names.pn_offset, section->name);

      do { do { unsigned int amount = (offset_size); if (sizeof (names.pn_size) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (names.pn_size)); amount = sizeof (names.pn_size); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) names.pn_size = 0; else names.pn_size = byte_get ((data), amount); } while (0); data += offset_size; } while (0);

      adr = start + names.pn_length + initial_length_size;

      if ((dwarf_signed_vma) names.pn_length < 0

   || adr < start)
 {
   warn (gettext ("Negative length for public name: 0x%lx\n"), (long) names.pn_length);
   start = end;
 }
      else
 start = adr;

      printf (gettext ("  Length:                              %ld\n"),
       (long) names.pn_length);
      printf (gettext ("  Version:                             %d\n"),
       names.pn_version);
      printf (gettext ("  Offset into .debug_info section:     0x%lx\n"),
       (unsigned long) names.pn_offset);
      printf (gettext ("  Size of area in .debug_info section: %ld\n"),
       (long) names.pn_size);

      if (names.pn_version != 2 && names.pn_version != 3)
 {
   static int warned = 0;

   if (! warned)
     {
       warn (gettext ("Only DWARF 2 and 3 pubnames are currently supported\n"));
       warned = 1;
     }

   continue;
 }

      if (is_gnu)
 printf (gettext ("\n    Offset  Kind          Name\n"));
      else
 printf (gettext ("\n    Offset\tName\n"));

      do
 {
   bfd_size_type maxprint;

   do { unsigned int amount = (offset_size); if (sizeof (offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (offset)); amount = sizeof (offset); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) offset = 0; else offset = byte_get ((data), amount); } while (0);

   if (offset != 0)
     {
       data += offset_size;
       if (data >= end)
  break;
       maxprint = (end - data) - 1;

       if (is_gnu)
  {
    unsigned int kind_data;
    gdb_index_symbol_kind kind;
    const char *kind_name;
    int is_static;

    do { unsigned int amount = (1); if (sizeof (kind_data) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (kind_data)); amount = sizeof (kind_data); } if (((data) + amount) >= (end)) { if ((data) < (end)) amount = (end) - (data); else amount = 0; } if (amount == 0 || amount > 8) kind_data = 0; else kind_data = byte_get ((data), amount); } while (0);
    data++;
    maxprint --;




    kind_data <<= 24;
    kind = ((gdb_index_symbol_kind) (((kind_data) >> 28) & 7));
    kind_name = get_gdb_index_symbol_kind_name (kind);
    is_static = (((kind_data) >> 31) & 1);
    printf ("    %-6lx  %s,%-10s  %.*s\n",
     (unsigned long) offset, is_static ? gettext ("s") : gettext ("g"),
     kind_name, (int) maxprint, data);
  }
       else
  printf ("    %-6lx\t%.*s\n",
   (unsigned long) offset, (int) maxprint, data);

       data += strnlen ((char *) data, maxprint) + 1;
       if (data >= end)
  break;
     }
 }
      while (offset != 0);
    }

  printf ("\n");
  return 1;
}

static int
display_debug_pubnames (struct dwarf_section *section, void *file)
{
  return display_debug_pubnames_worker (section, file, 0);
}

static int
display_debug_gnu_pubnames (struct dwarf_section *section, void *file)
{
  return display_debug_pubnames_worker (section, file, 1);
}

static int
display_debug_macinfo (struct dwarf_section *section,
         void *file __attribute__ ((__unused__)))
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *curr = start;
  unsigned int bytes_read;
  enum dwarf_macinfo_record_type op;

  printf (gettext ("Contents of the %s section:\n\n"), section->name);

  while (curr < end)
    {
      unsigned int lineno;
      const unsigned char *string;

      op = (enum dwarf_macinfo_record_type) *curr;
      curr++;

      switch (op)
 {
 case DW_MACINFO_start_file:
   {
     unsigned int filenum;

     lineno = read_uleb128 (curr, & bytes_read, end);
     curr += bytes_read;
     filenum = read_uleb128 (curr, & bytes_read, end);
     curr += bytes_read;

     printf (gettext (" DW_MACINFO_start_file - lineno: %d filenum: %d\n"),
      lineno, filenum);
   }
   break;

 case DW_MACINFO_end_file:
   printf (gettext (" DW_MACINFO_end_file\n"));
   break;

 case DW_MACINFO_define:
   lineno = read_uleb128 (curr, & bytes_read, end);
   curr += bytes_read;
   string = curr;
   curr += strnlen ((char *) string, end - string) + 1;
   printf (gettext (" DW_MACINFO_define - lineno : %d macro : %s\n"),
    lineno, string);
   break;

 case DW_MACINFO_undef:
   lineno = read_uleb128 (curr, & bytes_read, end);
   curr += bytes_read;
   string = curr;
   curr += strnlen ((char *) string, end - string) + 1;
   printf (gettext (" DW_MACINFO_undef - lineno : %d macro : %s\n"),
    lineno, string);
   break;

 case DW_MACINFO_vendor_ext:
   {
     unsigned int constant;

     constant = read_uleb128 (curr, & bytes_read, end);
     curr += bytes_read;
     string = curr;
     curr += strnlen ((char *) string, end - string) + 1;
     printf (gettext (" DW_MACINFO_vendor_ext - constant : %d string : %s\n"),
      constant, string);
   }
   break;
 }
    }

  return 1;
}





static unsigned char *
get_line_filename_and_dirname (dwarf_vma line_offset,
          dwarf_vma fileidx,
          unsigned char **dir_name)
{
  struct dwarf_section *section = &debug_displays [line].section;
  unsigned char *hdrptr, *dirtable, *file_name;
  unsigned int offset_size, initial_length_size;
  unsigned int version, opcode_base, bytes_read;
  dwarf_vma length, diridx;
  const unsigned char * end;

  *dir_name = 
# 4024 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 4024 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 ;
  if (section->start == 
# 4025 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
      
# 4026 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     || line_offset >= section->size
      || fileidx == 0)
    return 
# 4028 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 4028 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;

  hdrptr = section->start + line_offset;
  end = section->start + section->size;

  do { do { unsigned int amount = (4); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((hdrptr), amount); } while (0); hdrptr += 4; } while (0);
  if (length == 0xffffffff)
    {

      do { do { unsigned int amount = (8); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((hdrptr), amount); } while (0); hdrptr += 8; } while (0);
      offset_size = 8;
      initial_length_size = 12;
    }
  else
    {
      offset_size = 4;
      initial_length_size = 4;
    }
  if (length + initial_length_size > section->size)
    return 
# 4047 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 4047 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;

  do { do { unsigned int amount = (2); if (sizeof (version) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (version)); amount = sizeof (version); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) version = 0; else version = byte_get ((hdrptr), amount); } while (0); hdrptr += 2; } while (0);
  if (version != 2 && version != 3 && version != 4)
    return 
# 4051 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 4051 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;
  hdrptr += offset_size + 1;
  if (version >= 4)
    hdrptr++;
  hdrptr += 3;

  do { do { unsigned int amount = (1); if (sizeof (opcode_base) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (opcode_base)); amount = sizeof (opcode_base); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) opcode_base = 0; else opcode_base = byte_get ((hdrptr), amount); } while (0); hdrptr += 1; } while (0);
  if (opcode_base == 0)
    return 
# 4059 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 4059 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;

  hdrptr += opcode_base - 1;
  dirtable = hdrptr;

  while (*hdrptr != '\0')
    hdrptr += strnlen ((char *) hdrptr, end - hdrptr) + 1;
  hdrptr++;

  for (; *hdrptr != '\0' && fileidx > 1; fileidx--)
    {
      hdrptr += strnlen ((char *) hdrptr, end - hdrptr) + 1;
      read_uleb128 (hdrptr, &bytes_read, end);
      hdrptr += bytes_read;
      read_uleb128 (hdrptr, &bytes_read, end);
      hdrptr += bytes_read;
      read_uleb128 (hdrptr, &bytes_read, end);
      hdrptr += bytes_read;
    }
  if (hdrptr == end || *hdrptr == '\0')
    return 
# 4079 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 4079 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;
  file_name = hdrptr;
  hdrptr += strnlen ((char *) hdrptr, end - hdrptr) + 1;
  diridx = read_uleb128 (hdrptr, &bytes_read, end);
  if (diridx == 0)
    return file_name;
  for (; *dirtable != '\0' && diridx > 1; diridx--)
    dirtable += strnlen ((char *) dirtable, end - dirtable) + 1;
  if (*dirtable == '\0')
    return 
# 4088 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 4088 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;
  *dir_name = dirtable;
  return file_name;
}

static int
display_debug_macro (struct dwarf_section *section,
       void *file)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *curr = start;
  unsigned char *extended_op_buf[256];
  unsigned int bytes_read;

  load_debug_section (str, file);
  load_debug_section (line, file);

  printf (gettext ("Contents of the %s section:\n\n"), section->name);

  while (curr < end)
    {
      unsigned int lineno, version, flags;
      unsigned int offset_size = 4;
      const unsigned char *string;
      dwarf_vma line_offset = 0, sec_offset = curr - start, offset;
      unsigned char **extended_ops = 
# 4114 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                    ((void *)0)
# 4114 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                        ;

      do { do { unsigned int amount = (2); if (sizeof (version) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (version)); amount = sizeof (version); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) version = 0; else version = byte_get ((curr), amount); } while (0); curr += 2; } while (0);
      if (version != 4)
 {
   error (gettext ("Only GNU extension to DWARF 4 of %s is currently supported.\n"),
   section->name);
   return 0;
 }

      do { do { unsigned int amount = (1); if (sizeof (flags) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (flags)); amount = sizeof (flags); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) flags = 0; else flags = byte_get ((curr), amount); } while (0); curr += 1; } while (0);
      if (flags & 1)
 offset_size = 8;
      printf (gettext ("  Offset:                      0x%lx\n"),
       (unsigned long) sec_offset);
      printf (gettext ("  Version:                     %d\n"), version);
      printf (gettext ("  Offset size:                 %d\n"), offset_size);
      if (flags & 2)
 {
   do { do { unsigned int amount = (offset_size); if (sizeof (line_offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (line_offset)); amount = sizeof (line_offset); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) line_offset = 0; else line_offset = byte_get ((curr), amount); } while (0); curr += offset_size; } while (0);
   printf (gettext ("  Offset into .debug_line:     0x%lx\n"),
    (unsigned long) line_offset);
 }
      if (flags & 4)
 {
   unsigned int i, count, op;
   dwarf_vma nargs, n;

   do { do { unsigned int amount = (1); if (sizeof (count) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (count)); amount = sizeof (count); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) count = 0; else count = byte_get ((curr), amount); } while (0); curr += 1; } while (0);

   memset (extended_op_buf, 0, sizeof (extended_op_buf));
   extended_ops = extended_op_buf;
   if (count)
     {
       printf (gettext ("  Extension opcode arguments:\n"));
       for (i = 0; i < count; i++)
  {
    do { do { unsigned int amount = (1); if (sizeof (op) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (op)); amount = sizeof (op); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) op = 0; else op = byte_get ((curr), amount); } while (0); curr += 1; } while (0);
    extended_ops[op] = curr;
    nargs = read_uleb128 (curr, &bytes_read, end);
    curr += bytes_read;
    if (nargs == 0)
      printf (gettext ("    DW_MACRO_GNU_%02x has no arguments\n"), op);
    else
      {
        printf (gettext ("    DW_MACRO_GNU_%02x arguments: "), op);
        for (n = 0; n < nargs; n++)
   {
     unsigned int form;

     do { do { unsigned int amount = (1); if (sizeof (form) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (form)); amount = sizeof (form); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) form = 0; else form = byte_get ((curr), amount); } while (0); curr += 1; } while (0);
     printf ("%s%s", get_FORM_name (form),
      n == nargs - 1 ? "\n" : ", ");
     switch (form)
       {
       case DW_FORM_data1:
       case DW_FORM_data2:
       case DW_FORM_data4:
       case DW_FORM_data8:
       case DW_FORM_sdata:
       case DW_FORM_udata:
       case DW_FORM_block:
       case DW_FORM_block1:
       case DW_FORM_block2:
       case DW_FORM_block4:
       case DW_FORM_flag:
       case DW_FORM_string:
       case DW_FORM_strp:
       case DW_FORM_sec_offset:
         break;
       default:
         error (gettext ("Invalid extension opcode form %s\n"),
         get_FORM_name (form));
         return 0;
       }
   }
      }
  }
     }
 }
      printf ("\n");

      while (1)
 {
   unsigned int op;

   if (curr >= end)
     {
       error (gettext (".debug_macro section not zero terminated\n"));
       return 0;
     }

   do { do { unsigned int amount = (1); if (sizeof (op) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (op)); amount = sizeof (op); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) op = 0; else op = byte_get ((curr), amount); } while (0); curr += 1; } while (0);
   if (op == 0)
     break;

   switch (op)
     {
     case DW_MACRO_GNU_start_file:
       {
  unsigned int filenum;
  unsigned char *file_name = 
# 4215 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                            ((void *)0)
# 4215 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                , *dir_name = 
# 4215 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                              ((void *)0)
# 4215 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                  ;

  lineno = read_uleb128 (curr, &bytes_read, end);
  curr += bytes_read;
  filenum = read_uleb128 (curr, &bytes_read, end);
  curr += bytes_read;

  if ((flags & 2) == 0)
    error (gettext ("DW_MACRO_GNU_start_file used, but no .debug_line offset provided.\n"));
  else
    file_name
      = get_line_filename_and_dirname (line_offset, filenum,
           &dir_name);
  if (file_name == 
# 4228 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 4228 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      )
    printf (gettext (" DW_MACRO_GNU_start_file - lineno: %d filenum: %d\n"),
     lineno, filenum);
  else
    printf (gettext (" DW_MACRO_GNU_start_file - lineno: %d filenum: %d filename: %s%s%s\n"),
     lineno, filenum,
     dir_name != 
# 4234 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                ((void *)0) 
# 4234 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                     ? (const char *) dir_name : "",
     dir_name != 
# 4235 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                ((void *)0) 
# 4235 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                     ? "/" : "", file_name);
       }
       break;

     case DW_MACRO_GNU_end_file:
       printf (gettext (" DW_MACRO_GNU_end_file\n"));
       break;

     case DW_MACRO_GNU_define:
       lineno = read_uleb128 (curr, &bytes_read, end);
       curr += bytes_read;
       string = curr;
       curr += strnlen ((char *) string, end - string) + 1;
       printf (gettext (" DW_MACRO_GNU_define - lineno : %d macro : %s\n"),
        lineno, string);
       break;

     case DW_MACRO_GNU_undef:
       lineno = read_uleb128 (curr, &bytes_read, end);
       curr += bytes_read;
       string = curr;
       curr += strnlen ((char *) string, end - string) + 1;
       printf (gettext (" DW_MACRO_GNU_undef - lineno : %d macro : %s\n"),
        lineno, string);
       break;

     case DW_MACRO_GNU_define_indirect:
       lineno = read_uleb128 (curr, &bytes_read, end);
       curr += bytes_read;
       do { do { unsigned int amount = (offset_size); if (sizeof (offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (offset)); amount = sizeof (offset); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) offset = 0; else offset = byte_get ((curr), amount); } while (0); curr += offset_size; } while (0);
       string = fetch_indirect_string (offset);
       printf (gettext (" DW_MACRO_GNU_define_indirect - lineno : %d macro : %s\n"),
        lineno, string);
       break;

     case DW_MACRO_GNU_undef_indirect:
       lineno = read_uleb128 (curr, &bytes_read, end);
       curr += bytes_read;
       do { do { unsigned int amount = (offset_size); if (sizeof (offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (offset)); amount = sizeof (offset); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) offset = 0; else offset = byte_get ((curr), amount); } while (0); curr += offset_size; } while (0);
       string = fetch_indirect_string (offset);
       printf (gettext (" DW_MACRO_GNU_undef_indirect - lineno : %d macro : %s\n"),
        lineno, string);
       break;

     case DW_MACRO_GNU_transparent_include:
       do { do { unsigned int amount = (offset_size); if (sizeof (offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (offset)); amount = sizeof (offset); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) offset = 0; else offset = byte_get ((curr), amount); } while (0); curr += offset_size; } while (0);
       printf (gettext (" DW_MACRO_GNU_transparent_include - offset : 0x%lx\n"),
        (unsigned long) offset);
       break;

     case DW_MACRO_GNU_define_indirect_alt:
       lineno = read_uleb128 (curr, &bytes_read, end);
       curr += bytes_read;
       do { do { unsigned int amount = (offset_size); if (sizeof (offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (offset)); amount = sizeof (offset); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) offset = 0; else offset = byte_get ((curr), amount); } while (0); curr += offset_size; } while (0);
       printf (gettext (" DW_MACRO_GNU_define_indirect_alt - lineno : %d macro offset : 0x%lx\n"),
        lineno, (unsigned long) offset);
       break;

     case DW_MACRO_GNU_undef_indirect_alt:
       lineno = read_uleb128 (curr, &bytes_read, end);
       curr += bytes_read;
       do { do { unsigned int amount = (offset_size); if (sizeof (offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (offset)); amount = sizeof (offset); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) offset = 0; else offset = byte_get ((curr), amount); } while (0); curr += offset_size; } while (0);
       printf (gettext (" DW_MACRO_GNU_undef_indirect_alt - lineno : %d macro offset : 0x%lx\n"),
        lineno, (unsigned long) offset);
       break;

     case DW_MACRO_GNU_transparent_include_alt:
       do { do { unsigned int amount = (offset_size); if (sizeof (offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (offset)); amount = sizeof (offset); } if (((curr) + amount) >= (end)) { if ((curr) < (end)) amount = (end) - (curr); else amount = 0; } if (amount == 0 || amount > 8) offset = 0; else offset = byte_get ((curr), amount); } while (0); curr += offset_size; } while (0);
       printf (gettext (" DW_MACRO_GNU_transparent_include_alt - offset : 0x%lx\n"),
        (unsigned long) offset);
       break;

     default:
       if (extended_ops == 
# 4308 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                          ((void *)0) 
# 4308 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                               || extended_ops[op] == 
# 4308 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                      ((void *)0)
# 4308 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                          )
  {
    error (gettext (" Unknown macro opcode %02x seen\n"), op);
    return 0;
  }
       else
  {

    dwarf_vma nargs, n;
    unsigned char *desc = extended_ops[op];
    nargs = read_uleb128 (desc, &bytes_read, end);
    desc += bytes_read;
    if (nargs == 0)
      {
        printf (gettext (" DW_MACRO_GNU_%02x\n"), op);
        break;
      }
    printf (gettext (" DW_MACRO_GNU_%02x -"), op);
    for (n = 0; n < nargs; n++)
      {
        int val;

        do { do { unsigned int amount = (1); if (sizeof (val) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (val)); amount = sizeof (val); } if (((desc) + amount) >= (end)) { if ((desc) < (end)) amount = (end) - (desc); else amount = 0; } if (amount == 0 || amount > 8) val = 0; else val = byte_get ((desc), amount); } while (0); desc += 1; } while (0);
        curr
   = read_and_display_attr_value (0, val,
             curr, end, 0, 0, offset_size,
             version, 
# 4334 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 4334 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         , 0, 
# 4334 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 4334 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  ,
             
# 4335 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
            ((void *)0)
# 4335 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                );
        if (n != nargs - 1)
   printf (",");
      }
    printf ("\n");
  }
       break;
     }
 }

      printf ("\n");
    }

  return 1;
}

static int
display_debug_abbrev (struct dwarf_section *section,
        void *file __attribute__ ((__unused__)))
{
  abbrev_entry *entry;
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;

  printf (gettext ("Contents of the %s section:\n\n"), section->name);

  do
    {
      unsigned char *last;

      free_abbrevs ();

      last = start;
      start = process_abbrev_section (start, end);

      if (first_abbrev == 
# 4370 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 4370 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             )
 continue;

      printf (gettext ("  Number TAG (0x%lx)\n"), (long) (last - section->start));

      for (entry = first_abbrev; entry; entry = entry->next)
 {
   abbrev_attr *attr;

   printf ("   %ld      %s    [%s]\n",
    entry->entry,
    get_TAG_name (entry->tag),
    entry->children ? gettext ("has children") : gettext ("no children"));

   for (attr = entry->first_attr; attr; attr = attr->next)
     printf ("    %-18s %s\n",
      get_AT_name (attr->attribute),
      get_FORM_name (attr->form));
 }
    }
  while (start);

  printf ("\n");

  return 1;
}




static bfd_boolean
is_max_address (dwarf_vma addr, unsigned int pointer_size)
{
  dwarf_vma mask = ~(~(dwarf_vma) 1 << (pointer_size * 8 - 1));
  return ((addr & mask) == mask);
}



static void
display_loc_list (struct dwarf_section *section,
    unsigned char **start_ptr,
    unsigned int debug_info_entry,
    unsigned long offset,
    unsigned long base_address,
    int has_frame_base)
{
  unsigned char *start = *start_ptr;
  unsigned char *section_end = section->start + section->size;
  unsigned long cu_offset;
  unsigned int pointer_size;
  unsigned int offset_size;
  int dwarf_version;

  dwarf_vma begin;
  dwarf_vma end;
  unsigned short length;
  int need_frame_base;

  if (debug_info_entry >= num_debug_info_entries)
    {
      warn (gettext ("No debug information available for loc lists of entry: %u\n"),
     debug_info_entry);
      return;
    }

  cu_offset = debug_information [debug_info_entry].cu_offset;
  pointer_size = debug_information [debug_info_entry].pointer_size;
  offset_size = debug_information [debug_info_entry].offset_size;
  dwarf_version = debug_information [debug_info_entry].dwarf_version;

  if (pointer_size < 2 || pointer_size > 8)
    {
      warn (gettext ("Invalid pointer size (%d) in debug info for entry %d\n"),
     pointer_size, debug_info_entry);
      return;
    }

  while (1)
    {
      unsigned long off = offset + (start - *start_ptr);

      if (start + 2 * pointer_size > section_end)
 {
   warn (gettext ("Location list starting at offset 0x%lx is not terminated.\n"),
  offset);
   break;
 }

      printf ("    %8.8lx ", off);

      do { do { unsigned int amount = (pointer_size); if (sizeof (begin) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (begin)); amount = sizeof (begin); } if (((start) + amount) >= (section_end)) { if ((start) < (section_end)) amount = (section_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) begin = 0; else begin = byte_get ((start), amount); } while (0); start += pointer_size; } while (0);
      do { do { unsigned int amount = (pointer_size); if (sizeof (end) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (end)); amount = sizeof (end); } if (((start) + amount) >= (section_end)) { if ((start) < (section_end)) amount = (section_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) end = 0; else end = byte_get ((start), amount); } while (0); start += pointer_size; } while (0);

      if (begin == 0 && end == 0)
 {






   if (! reloc_at (section, off)
       && ! reloc_at (section, off + pointer_size))
     {
       printf (gettext ("<End of list>\n"));
       break;
     }
 }


      if (is_max_address (begin, pointer_size)
          && !is_max_address (end, pointer_size))
 {
   base_address = end;
   print_dwarf_vma (begin, pointer_size);
   print_dwarf_vma (end, pointer_size);
   printf (gettext ("(base address)\n"));
   continue;
 }

      if (start + 2 > section_end)
 {
   warn (gettext ("Location list starting at offset 0x%lx is not terminated.\n"),
  offset);
   break;
 }

      do { do { unsigned int amount = (2); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((start) + amount) >= (section_end)) { if ((start) < (section_end)) amount = (section_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((start), amount); } while (0); start += 2; } while (0);

      if (start + length > section_end)
 {
   warn (gettext ("Location list starting at offset 0x%lx is not terminated.\n"),
  offset);
   break;
 }

      print_dwarf_vma (begin + base_address, pointer_size);
      print_dwarf_vma (end + base_address, pointer_size);

      putchar ('(');
      need_frame_base = decode_location_expression (start,
          pointer_size,
          offset_size,
          dwarf_version,
          length,
          cu_offset, section);
      putchar (')');

      if (need_frame_base && !has_frame_base)
 printf (gettext (" [without DW_AT_frame_base]"));

      if (begin == end)
 fputs (gettext (" (start == end)"), 
# 4523 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                             stdout
# 4523 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   );
      else if (begin > end)
 fputs (gettext (" (start > end)"), 
# 4525 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                            stdout
# 4525 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  );

      putchar ('\n');

      start += length;
    }

  *start_ptr = start;
}




static void
print_addr_index (unsigned int idx, unsigned int len)
{
  static char buf[15];
  snprintf (buf, sizeof (buf), "[%d]", idx);
  printf ("%*s ", len, buf);
}





static void
display_loc_list_dwo (struct dwarf_section *section,
        unsigned char **start_ptr,
        unsigned int debug_info_entry,
        unsigned long offset,
        int has_frame_base)
{
  unsigned char *start = *start_ptr;
  unsigned char *section_end = section->start + section->size;
  unsigned long cu_offset;
  unsigned int pointer_size;
  unsigned int offset_size;
  int dwarf_version;
  int entry_type;
  unsigned short length;
  int need_frame_base;
  unsigned int idx;
  unsigned int bytes_read;

  if (debug_info_entry >= num_debug_info_entries)
    {
      warn (gettext ("No debug information for loc lists of entry: %u\n"),
     debug_info_entry);
      return;
    }

  cu_offset = debug_information [debug_info_entry].cu_offset;
  pointer_size = debug_information [debug_info_entry].pointer_size;
  offset_size = debug_information [debug_info_entry].offset_size;
  dwarf_version = debug_information [debug_info_entry].dwarf_version;

  if (pointer_size < 2 || pointer_size > 8)
    {
      warn (gettext ("Invalid pointer size (%d) in debug info for entry %d\n"),
     pointer_size, debug_info_entry);
      return;
    }

  while (1)
    {
      printf ("    %8.8lx ", offset + (start - *start_ptr));

      if (start >= section_end)
 {
   warn (gettext ("Location list starting at offset 0x%lx is not terminated.\n"),
  offset);
   break;
 }

      do { do { unsigned int amount = (1); if (sizeof (entry_type) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (entry_type)); amount = sizeof (entry_type); } if (((start) + amount) >= (section_end)) { if ((start) < (section_end)) amount = (section_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) entry_type = 0; else entry_type = byte_get ((start), amount); } while (0); start += 1; } while (0);
      switch (entry_type)
 {
 case 0:
   *start_ptr = start;
   printf (gettext ("<End of list>\n"));
   return;
 case 1:
   idx = read_uleb128 (start, &bytes_read, section_end);
   start += bytes_read;
   print_addr_index (idx, 8);
   printf ("         ");
   printf (gettext ("(base address selection entry)\n"));
   continue;
 case 2:
   idx = read_uleb128 (start, &bytes_read, section_end);
   start += bytes_read;
   print_addr_index (idx, 8);
   idx = read_uleb128 (start, &bytes_read, section_end);
   start += bytes_read;
   print_addr_index (idx, 8);
   break;
 case 3:
   idx = read_uleb128 (start, &bytes_read, section_end);
   start += bytes_read;
   print_addr_index (idx, 8);
   do { do { unsigned int amount = (4); if (sizeof (idx) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (idx)); amount = sizeof (idx); } if (((start) + amount) >= (section_end)) { if ((start) < (section_end)) amount = (section_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) idx = 0; else idx = byte_get ((start), amount); } while (0); start += 4; } while (0);
   printf ("%08x ", idx);
   break;
 case 4:
   do { do { unsigned int amount = (4); if (sizeof (idx) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (idx)); amount = sizeof (idx); } if (((start) + amount) >= (section_end)) { if ((start) < (section_end)) amount = (section_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) idx = 0; else idx = byte_get ((start), amount); } while (0); start += 4; } while (0);
   printf ("%08x ", idx);
   do { do { unsigned int amount = (4); if (sizeof (idx) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (idx)); amount = sizeof (idx); } if (((start) + amount) >= (section_end)) { if ((start) < (section_end)) amount = (section_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) idx = 0; else idx = byte_get ((start), amount); } while (0); start += 4; } while (0);
   printf ("%08x ", idx);
   break;
 default:
   warn (gettext ("Unknown location list entry type 0x%x.\n"), entry_type);
   *start_ptr = start;
   return;
 }

      if (start + 2 > section_end)
 {
   warn (gettext ("Location list starting at offset 0x%lx is not terminated.\n"),
  offset);
   break;
 }

      do { do { unsigned int amount = (2); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((start) + amount) >= (section_end)) { if ((start) < (section_end)) amount = (section_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((start), amount); } while (0); start += 2; } while (0);
      if (start + length > section_end)
 {
   warn (gettext ("Location list starting at offset 0x%lx is not terminated.\n"),
  offset);
   break;
 }

      putchar ('(');
      need_frame_base = decode_location_expression (start,
          pointer_size,
          offset_size,
          dwarf_version,
          length,
          cu_offset, section);
      putchar (')');

      if (need_frame_base && !has_frame_base)
 printf (gettext (" [without DW_AT_frame_base]"));

      putchar ('\n');

      start += length;
    }

  *start_ptr = start;
}



static dwarf_vma *loc_offsets;

static int
loc_offsets_compar (const void *ap, const void *bp)
{
  dwarf_vma a = loc_offsets[*(const unsigned int *) ap];
  dwarf_vma b = loc_offsets[*(const unsigned int *) bp];

  return (a > b) - (b > a);
}

static int
display_debug_loc (struct dwarf_section *section, void *file)
{
  unsigned char *start = section->start;
  unsigned long bytes;
  unsigned char *section_begin = start;
  unsigned int num_loc_list = 0;
  unsigned long last_offset = 0;
  unsigned int first = 0;
  unsigned int i;
  unsigned int j;
  int seen_first_offset = 0;
  int locs_sorted = 1;
  unsigned char *next;
  unsigned int *array = 
# 4702 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
# 4702 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                           ;
  const char *suffix = strrchr (section->name, '.');
  int is_dwo = 0;

  if (suffix && strcmp (suffix, ".dwo") == 0)
    is_dwo = 1;

  bytes = section->size;

  if (bytes == 0)
    {
      printf (gettext ("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  if (load_debug_info (file) == 0)
    {
      warn (gettext ("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"),
     section->name);
      return 0;
    }




  for (i = 0; i < num_debug_info_entries; i++)
    {
      unsigned int num;

      num = debug_information [i].num_loc_offsets;
      if (num > num_loc_list)
 num_loc_list = num;


      if (locs_sorted && num != 0)
 {
   if (!seen_first_offset)
     {

       last_offset = debug_information [i].loc_offsets [0];
       first = i;
       seen_first_offset = 1;
       j = 1;
     }
   else
     j = 0;

   for (; j < num; j++)
     {
       if (last_offset >
    debug_information [i].loc_offsets [j])
  {
    locs_sorted = 0;
    break;
  }
       last_offset = debug_information [i].loc_offsets [j];
     }
 }
    }

  if (!seen_first_offset)
    error (gettext ("No location lists in .debug_info section!\n"));

  if (debug_information [first].num_loc_offsets > 0
      && debug_information [first].loc_offsets [0] != 0)
    warn (gettext ("Location lists in %s section start at 0x%s\n"),
   section->name,
   dwarf_vmatoa ("x", debug_information [first].loc_offsets [0]));

  if (!locs_sorted)
    array = (unsigned int *) xcmalloc (num_loc_list, sizeof (unsigned int));
  printf (gettext ("Contents of the %s section:\n\n"), section->name);
  if (reloc_at (section, 0))
    printf (gettext (" Warning: This section has relocations - addresses seen here may not be accurate.\n\n"));
  printf (gettext ("    Offset   Begin            End              Expression\n"));

  seen_first_offset = 0;
  for (i = first; i < num_debug_info_entries; i++)
    {
      unsigned long offset;
      unsigned long base_address;
      unsigned int k;
      int has_frame_base;

      if (!locs_sorted)
 {
   for (k = 0; k < debug_information [i].num_loc_offsets; k++)
     array[k] = k;
   loc_offsets = debug_information [i].loc_offsets;
   qsort (array, debug_information [i].num_loc_offsets,
   sizeof (*array), loc_offsets_compar);
 }

      for (k = 0; k < debug_information [i].num_loc_offsets; k++)
 {
   j = locs_sorted ? k : array[k];
   if (k
       && debug_information [i].loc_offsets [locs_sorted
          ? k - 1 : array [k - 1]]
   == debug_information [i].loc_offsets [j])
     continue;
   has_frame_base = debug_information [i].have_frame_base [j];
   offset = debug_information [i].loc_offsets [j];
   next = section_begin + offset;
   base_address = debug_information [i].base_address;

   if (!seen_first_offset)
     seen_first_offset = 1;
   else
     {
       if (start < next)
  warn (gettext ("There is a hole [0x%lx - 0x%lx] in .debug_loc section.\n"),
        (unsigned long) (start - section_begin),
        (unsigned long) offset);
       else if (start > next)
  warn (gettext ("There is an overlap [0x%lx - 0x%lx] in .debug_loc section.\n"),
        (unsigned long) (start - section_begin),
        (unsigned long) offset);
     }
   start = next;

   if (offset >= bytes)
     {
       warn (gettext ("Offset 0x%lx is bigger than .debug_loc section size.\n"),
      offset);
       continue;
     }

   if (is_dwo)
     display_loc_list_dwo (section, &start, i, offset, has_frame_base);
   else
     display_loc_list (section, &start, i, offset, base_address,
         has_frame_base);
 }
    }

  if (start < section->start + section->size)
    warn (gettext ("There are %ld unused bytes at the end of section %s\n"),
   (long) (section->start + section->size - start), section->name);
  putchar ('\n');
  free (array);
  return 1;
}

static int
display_debug_str (struct dwarf_section *section,
     void *file __attribute__ ((__unused__)))
{
  unsigned char *start = section->start;
  unsigned long bytes = section->size;
  dwarf_vma addr = section->address;

  if (bytes == 0)
    {
      printf (gettext ("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  printf (gettext ("Contents of the %s section:\n\n"), section->name);

  while (bytes)
    {
      int j;
      int k;
      int lbytes;

      lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8lx ", (unsigned long) addr);

      for (j = 0; j < 16; j++)
 {
   if (j < lbytes)
     printf ("%2.2x", start[j]);
   else
     printf ("  ");

   if ((j & 3) == 3)
     printf (" ");
 }

      for (j = 0; j < lbytes; j++)
 {
   k = start[j];
   if (k >= ' ' && k < 0x80)
     printf ("%c", k);
   else
     printf (".");
 }

      putchar ('\n');

      start += lbytes;
      addr += lbytes;
      bytes -= lbytes;
    }

  putchar ('\n');

  return 1;
}

static int
display_debug_info (struct dwarf_section *section, void *file)
{
  return process_debug_info (section, file, section->abbrev_sec, 0, 0);
}

static int
display_debug_types (struct dwarf_section *section, void *file)
{
  return process_debug_info (section, file, section->abbrev_sec, 0, 1);
}

static int
display_trace_info (struct dwarf_section *section, void *file)
{
  return process_debug_info (section, file, section->abbrev_sec, 0, 0);
}

static int
display_debug_aranges (struct dwarf_section *section,
         void *file __attribute__ ((__unused__)))
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;

  printf (gettext ("Contents of the %s section:\n\n"), section->name);



  load_debug_info (file);

  while (start < end)
    {
      unsigned char *hdrptr;
      DWARF2_Internal_ARange arange;
      unsigned char *addr_ranges;
      dwarf_vma length;
      dwarf_vma address;
      unsigned char address_size;
      int excess;
      unsigned int offset_size;
      unsigned int initial_length_size;

      hdrptr = start;

      do { do { unsigned int amount = (4); if (sizeof (arange.ar_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (arange.ar_length)); amount = sizeof (arange.ar_length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) arange.ar_length = 0; else arange.ar_length = byte_get ((hdrptr), amount); } while (0); hdrptr += 4; } while (0);
      if (arange.ar_length == 0xffffffff)
 {
   do { do { unsigned int amount = (8); if (sizeof (arange.ar_length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (arange.ar_length)); amount = sizeof (arange.ar_length); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) arange.ar_length = 0; else arange.ar_length = byte_get ((hdrptr), amount); } while (0); hdrptr += 8; } while (0);
   offset_size = 8;
   initial_length_size = 12;
 }
      else
 {
   offset_size = 4;
   initial_length_size = 4;
 }

      do { do { unsigned int amount = (2); if (sizeof (arange.ar_version) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (arange.ar_version)); amount = sizeof (arange.ar_version); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) arange.ar_version = 0; else arange.ar_version = byte_get ((hdrptr), amount); } while (0); hdrptr += 2; } while (0);
      do { do { unsigned int amount = (offset_size); if (sizeof (arange.ar_info_offset) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (arange.ar_info_offset)); amount = sizeof (arange.ar_info_offset); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) arange.ar_info_offset = 0; else arange.ar_info_offset = byte_get ((hdrptr), amount); } while (0); hdrptr += offset_size; } while (0);

      if (num_debug_info_entries != (unsigned int) -1
   && num_debug_info_entries > 0
   && find_debug_info_for_offset (arange.ar_info_offset) == 
# 4967 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                           ((void *)0)
# 4967 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                               )
 warn (gettext (".debug_info offset of 0x%lx in %s section does not point to a CU header.\n"),
       (unsigned long) arange.ar_info_offset, section->name);

      do { do { unsigned int amount = (1); if (sizeof (arange.ar_pointer_size) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (arange.ar_pointer_size)); amount = sizeof (arange.ar_pointer_size); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) arange.ar_pointer_size = 0; else arange.ar_pointer_size = byte_get ((hdrptr), amount); } while (0); hdrptr += 1; } while (0);
      do { do { unsigned int amount = (1); if (sizeof (arange.ar_segment_size) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (arange.ar_segment_size)); amount = sizeof (arange.ar_segment_size); } if (((hdrptr) + amount) >= (end)) { if ((hdrptr) < (end)) amount = (end) - (hdrptr); else amount = 0; } if (amount == 0 || amount > 8) arange.ar_segment_size = 0; else arange.ar_segment_size = byte_get ((hdrptr), amount); } while (0); hdrptr += 1; } while (0);

      if (arange.ar_version != 2 && arange.ar_version != 3)
 {




   if (arange.ar_version)
     warn (gettext ("Only DWARF 2 and 3 aranges are currently supported.\n"));
   break;
 }

      printf (gettext ("  Length:                   %ld\n"),
       (long) arange.ar_length);
      printf (gettext ("  Version:                  %d\n"), arange.ar_version);
      printf (gettext ("  Offset into .debug_info:  0x%lx\n"),
       (unsigned long) arange.ar_info_offset);
      printf (gettext ("  Pointer Size:             %d\n"), arange.ar_pointer_size);
      printf (gettext ("  Segment Size:             %d\n"), arange.ar_segment_size);

      address_size = arange.ar_pointer_size + arange.ar_segment_size;


      if (address_size == 0 || address_size > 8)
 {
   error (gettext ("Invalid address size in %s section!\n"),
   section->name);
   break;
 }




      if ((address_size & (address_size - 1)) != 0)
 {
   warn (gettext ("Pointer size + Segment size is not a power of two.\n"));
   break;
 }

      if (address_size > 4)
 printf (gettext ("\n    Address            Length\n"));
      else
 printf (gettext ("\n    Address    Length\n"));

      addr_ranges = hdrptr;


      excess = (hdrptr - start) % (2 * address_size);
      if (excess)
 addr_ranges += (2 * address_size) - excess;

      hdrptr = start + arange.ar_length + initial_length_size;
      if (hdrptr < start || hdrptr > end)
 {
   error (gettext ("Excessive header length: %lx\n"), (long) arange.ar_length);
   break;
 }
      start = hdrptr;

      while (addr_ranges + 2 * address_size <= start)
 {
   do { do { unsigned int amount = (address_size); if (sizeof (address) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (address)); amount = sizeof (address); } if (((addr_ranges) + amount) >= (end)) { if ((addr_ranges) < (end)) amount = (end) - (addr_ranges); else amount = 0; } if (amount == 0 || amount > 8) address = 0; else address = byte_get ((addr_ranges), amount); } while (0); addr_ranges += address_size; } while (0);
   do { do { unsigned int amount = (address_size); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((addr_ranges) + amount) >= (end)) { if ((addr_ranges) < (end)) amount = (end) - (addr_ranges); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((addr_ranges), amount); } while (0); addr_ranges += address_size; } while (0);

   printf ("    ");
   print_dwarf_vma (address, address_size);
   print_dwarf_vma (length, address_size);
   putchar ('\n');
 }
    }

  printf ("\n");

  return 1;
}


static int
comp_addr_base (const void * v0, const void * v1)
{
  debug_info * info0 = (debug_info *) v0;
  debug_info * info1 = (debug_info *) v1;
  return info0->addr_base - info1->addr_base;
}


static int
display_debug_addr (struct dwarf_section *section,
      void *file)
{
  debug_info **debug_addr_info;
  unsigned char *entry;
  unsigned char *end;
  unsigned int i;
  unsigned int count;

  if (section->size == 0)
    {
      printf (gettext ("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  if (load_debug_info (file) == 0)
    {
      warn (gettext ("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"),
     section->name);
      return 0;
    }

  printf (gettext ("Contents of the %s section:\n\n"), section->name);





  debug_addr_info = (debug_info **) xcalloc ((num_debug_info_entries + 1),
          sizeof (debug_info *));

  count = 0;
  for (i = 0; i < num_debug_info_entries; i++)
    if (debug_information [i].addr_base != (unsigned int) -1)
      {

 if (debug_information[i].addr_base >= section->size)
   warn (gettext ("Corrupt address base (%lx) found in debug section %u\n"),
  (unsigned long) debug_information[i].addr_base, i);
 else
   debug_addr_info [count++] = debug_information + i;
      }


  debug_addr_info [count] = (debug_info *) xmalloc (sizeof (debug_info));
  debug_addr_info [count]->addr_base = section->size;
  qsort (debug_addr_info, count, sizeof (debug_info *), comp_addr_base);

  for (i = 0; i < count; i++)
    {
      unsigned int idx;
      unsigned int address_size = debug_addr_info [i]->pointer_size;

      printf (gettext ("  For compilation unit at offset 0x%s:\n"),
       dwarf_vmatoa ("x", debug_addr_info [i]->cu_offset));

      printf (gettext ("\tIndex\tAddress\n"));
      entry = section->start + debug_addr_info [i]->addr_base;
      end = section->start + debug_addr_info [i + 1]->addr_base;
      idx = 0;
      while (entry < end)
 {
   dwarf_vma base = byte_get (entry, address_size);
   printf (gettext ("\t%d:\t"), idx);
   print_dwarf_vma (base, address_size);
   printf ("\n");
   entry += address_size;
   idx++;
 }
    }
  printf ("\n");

  free (debug_addr_info);
  return 1;
}


static int
display_debug_str_offsets (struct dwarf_section *section,
      void *file __attribute__ ((__unused__)))
{
  if (section->size == 0)
    {
      printf (gettext ("\nThe %s section is empty.\n"), section->name);
      return 0;
    }


  return 1;
}




struct range_entry
{

  unsigned long ranges_offset;


  debug_info *debug_info_p;
};



static int
range_entry_compar (const void *ap, const void *bp)
{
  const struct range_entry *a_re = (const struct range_entry *) ap;
  const struct range_entry *b_re = (const struct range_entry *) bp;
  const unsigned long a = a_re->ranges_offset;
  const unsigned long b = b_re->ranges_offset;

  return (a > b) - (b > a);
}

static int
display_debug_ranges (struct dwarf_section *section,
        void *file __attribute__ ((__unused__)))
{
  unsigned char *start = section->start;
  unsigned char *last_start = start;
  unsigned long bytes = section->size;
  unsigned char *section_begin = start;
  unsigned char *finish = start + bytes;
  unsigned int num_range_list, i;
  struct range_entry *range_entries, *range_entry_fill;

  if (bytes == 0)
    {
      printf (gettext ("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  if (load_debug_info (file) == 0)
    {
      warn (gettext ("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"),
     section->name);
      return 0;
    }

  num_range_list = 0;
  for (i = 0; i < num_debug_info_entries; i++)
    num_range_list += debug_information [i].num_range_lists;

  if (num_range_list == 0)
    {


      printf (gettext ("No range lists in .debug_info section.\n"));
      return 1;
    }

  range_entries = (struct range_entry *)
      xmalloc (sizeof (*range_entries) * num_range_list);
  range_entry_fill = range_entries;

  for (i = 0; i < num_debug_info_entries; i++)
    {
      debug_info *debug_info_p = &debug_information[i];
      unsigned int j;

      for (j = 0; j < debug_info_p->num_range_lists; j++)
 {
   range_entry_fill->ranges_offset = debug_info_p->range_lists[j];
   range_entry_fill->debug_info_p = debug_info_p;
   range_entry_fill++;
 }
    }

  qsort (range_entries, num_range_list, sizeof (*range_entries),
  range_entry_compar);

  if (dwarf_check != 0 && range_entries[0].ranges_offset != 0)
    warn (gettext ("Range lists in %s section start at 0x%lx\n"),
   section->name, range_entries[0].ranges_offset);

  printf (gettext ("Contents of the %s section:\n\n"), section->name);
  printf (gettext ("    Offset   Begin    End\n"));

  for (i = 0; i < num_range_list; i++)
    {
      struct range_entry *range_entry = &range_entries[i];
      debug_info *debug_info_p = range_entry->debug_info_p;
      unsigned int pointer_size;
      unsigned long offset;
      unsigned char *next;
      unsigned long base_address;

      pointer_size = debug_info_p->pointer_size;
      offset = range_entry->ranges_offset;
      next = section_begin + offset;
      base_address = debug_info_p->base_address;


      if (pointer_size < 2 || pointer_size > 8)
 {
   warn (gettext ("Corrupt pointer size (%d) in debug entry at offset %8.8lx\n"),
  pointer_size, offset);
   continue;
 }

      if (dwarf_check != 0 && i > 0)
 {
   if (start < next)
     warn (gettext ("There is a hole [0x%lx - 0x%lx] in %s section.\n"),
    (unsigned long) (start - section_begin),
    (unsigned long) (next - section_begin), section->name);
   else if (start > next)
     {
       if (next == last_start)
  continue;
       warn (gettext ("There is an overlap [0x%lx - 0x%lx] in %s section.\n"),
      (unsigned long) (start - section_begin),
      (unsigned long) (next - section_begin), section->name);
     }
 }
      start = next;
      last_start = next;

      while (start < finish)
 {
   dwarf_vma begin;
   dwarf_vma end;

   do { do { unsigned int amount = (pointer_size); if (sizeof (begin) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (begin)); amount = sizeof (begin); } if (((start) + amount) >= (finish)) { if ((start) < (finish)) amount = (finish) - (start); else amount = 0; } if (amount == 0 || amount > 8) begin = 0; else begin = byte_get ((start), amount); } while (0); start += pointer_size; } while (0);
   if (start >= finish)
     break;
   do { do { unsigned int amount = (pointer_size); if (((start) + amount) >= (finish)) { if ((start) < (finish)) amount = (finish) - (start); else amount = 0; } if (amount) end = byte_get_signed ((start), amount); else end = 0; } while (0); start += pointer_size; } while (0);

   printf ("    %8.8lx ", offset);

   if (begin == 0 && end == 0)
     {
       printf (gettext ("<End of list>\n"));
       break;
     }


          if (is_max_address (begin, pointer_size)
              && !is_max_address (end, pointer_size))
     {
       base_address = end;
       print_dwarf_vma (begin, pointer_size);
       print_dwarf_vma (end, pointer_size);
       printf ("(base address)\n");
       continue;
     }

   print_dwarf_vma (begin + base_address, pointer_size);
   print_dwarf_vma (end + base_address, pointer_size);

   if (begin == end)
     fputs (gettext ("(start == end)"), 
# 5313 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                stdout
# 5313 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                      );
   else if (begin > end)
     fputs (gettext ("(start > end)"), 
# 5315 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               stdout
# 5315 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                     );

   putchar ('\n');
 }
    }
  putchar ('\n');

  free (range_entries);

  return 1;
}

typedef struct Frame_Chunk
{
  struct Frame_Chunk *next;
  unsigned char *chunk_start;
  unsigned int ncols;

  short int *col_type;
  int *col_offset;
  char *augmentation;
  unsigned int code_factor;
  int data_factor;
  dwarf_vma pc_begin;
  dwarf_vma pc_range;
  int cfa_reg;
  dwarf_vma cfa_offset;
  unsigned int ra;
  unsigned char fde_encoding;
  unsigned char cfa_exp;
  unsigned char ptr_size;
  unsigned char segment_size;
}
Frame_Chunk;

static const char *const *dwarf_regnames;
static unsigned int dwarf_regnames_count;
# 5360 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
static int
frame_need_space (Frame_Chunk *fc, unsigned int reg)
{
  unsigned int prev = fc->ncols;

  if (reg < (unsigned int) fc->ncols)
    return 0;

  if (dwarf_regnames_count
      && reg > dwarf_regnames_count)
    return -1;

  fc->ncols = reg + 1;


  if (fc->ncols == 0)
    return -1;


  if (fc->ncols > 1024)
    {
      error (gettext ("Unfeasibly large register number: %u\n"), reg);
      fc->ncols = 0;


      return -1;
    }

  fc->col_type = (short int *) xcrealloc (fc->col_type, fc->ncols,
       sizeof (short int));
  fc->col_offset = (int *) xcrealloc (fc->col_offset, fc->ncols, sizeof (int));

  if (fc->col_type == 
# 5392 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0) 
# 5392 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                          || fc->col_offset == 
# 5392 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                               ((void *)0)
# 5392 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                   )
    {
      error (gettext ("Out of memory allocating %u columns in dwarf frame arrays\n"),
      fc->ncols);
      fc->ncols = 0;
      return -1;
    }

  while (prev < fc->ncols)
    {
      fc->col_type[prev] = (-1);
      fc->col_offset[prev] = 0;
      prev++;
    }
  return 1;
}

static const char *const dwarf_regnames_i386[] =
{
  "eax", "ecx", "edx", "ebx",
  "esp", "ebp", "esi", "edi",
  "eip", "eflags", 
# 5413 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 5413 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      ,
  "st0", "st1", "st2", "st3",
  "st4", "st5", "st6", "st7",
  
# 5416 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5416 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5416 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5416 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           ,
  "xmm0", "xmm1", "xmm2", "xmm3",
  "xmm4", "xmm5", "xmm6", "xmm7",
  "mm0", "mm1", "mm2", "mm3",
  "mm4", "mm5", "mm6", "mm7",
  "fcw", "fsw", "mxcsr",
  "es", "cs", "ss", "ds", "fs", "gs", 
# 5422 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5422 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5422 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5422 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  "tr", "ldtr",
  
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5424 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5425 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5426 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5427 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5428 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5429 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5429 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5429 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5429 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5429 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5429 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 ,
  "k0", "k1", "k2", "k3", "k4", "k5", "k6", "k7"
};

static const char *const dwarf_regnames_iamcu[] =
{
  "eax", "ecx", "edx", "ebx",
  "esp", "ebp", "esi", "edi",
  "eip", "eflags", 
# 5437 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 5437 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      ,
  
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5438 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5439 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5439 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5439 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5439 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           ,
  
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5440 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5441 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5442 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5442 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5442 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5442 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5442 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5442 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 ,
  "es", "cs", "ss", "ds", "fs", "gs", 
# 5443 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5443 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5443 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5443 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  "tr", "ldtr",
  
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5445 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5446 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5447 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5449 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5450 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5450 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5450 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5450 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5450 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5450 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 ,
  
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5451 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)

# 5452 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
};

void
init_dwarf_regnames_i386 (void)
{
  dwarf_regnames = dwarf_regnames_i386;
  dwarf_regnames_count = (sizeof (dwarf_regnames_i386) / sizeof ((dwarf_regnames_i386)[0]));
}

void
init_dwarf_regnames_iamcu (void)
{
  dwarf_regnames = dwarf_regnames_iamcu;
  dwarf_regnames_count = (sizeof (dwarf_regnames_iamcu) / sizeof ((dwarf_regnames_iamcu)[0]));
}

static const char *const dwarf_regnames_x86_64[] =
{
  "rax", "rdx", "rcx", "rbx",
  "rsi", "rdi", "rbp", "rsp",
  "r8", "r9", "r10", "r11",
  "r12", "r13", "r14", "r15",
  "rip",
  "xmm0", "xmm1", "xmm2", "xmm3",
  "xmm4", "xmm5", "xmm6", "xmm7",
  "xmm8", "xmm9", "xmm10", "xmm11",
  "xmm12", "xmm13", "xmm14", "xmm15",
  "st0", "st1", "st2", "st3",
  "st4", "st5", "st6", "st7",
  "mm0", "mm1", "mm2", "mm3",
  "mm4", "mm5", "mm6", "mm7",
  "rflags",
  "es", "cs", "ss", "ds", "fs", "gs", 
# 5484 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5484 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5484 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5484 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  "fs.base", "gs.base", 
# 5485 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
# 5485 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                           , 
# 5485 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                             ((void *)0)
# 5485 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                 ,
  "tr", "ldtr",
  "mxcsr", "fcw", "fsw",
  "xmm16", "xmm17", "xmm18", "xmm19",
  "xmm20", "xmm21", "xmm22", "xmm23",
  "xmm24", "xmm25", "xmm26", "xmm27",
  "xmm28", "xmm29", "xmm30", "xmm31",
  
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5492 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5493 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5494 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , 
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             , 
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                               ((void *)0)
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                   , 
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5495 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               ,
  
# 5496 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5496 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5496 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5496 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 5496 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5496 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 ,
  "k0", "k1", "k2", "k3", "k4", "k5", "k6", "k7"
};

void
init_dwarf_regnames_x86_64 (void)
{
  dwarf_regnames = dwarf_regnames_x86_64;
  dwarf_regnames_count = (sizeof (dwarf_regnames_x86_64) / sizeof ((dwarf_regnames_x86_64)[0]));
}

static const char *const dwarf_regnames_aarch64[] =
{
   "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7",
   "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
  "x16", "x17", "x18", "x19", "x20", "x21", "x22", "x23",
  "x24", "x25", "x26", "x27", "x28", "x29", "x30", "sp",
   
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
  ((void *)0)
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
      , "elr", 
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                ((void *)0)
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                    , 
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                           , 
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  , 
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                   ((void *)0)
# 5513 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                       ,
   
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
  ((void *)0)
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
      , 
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
         ((void *)0)
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
             , 
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                ((void *)0)
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                    , 
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                           , 
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  , 
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                   ((void *)0)
# 5514 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                       ,
   
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
  ((void *)0)
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
      , 
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
         ((void *)0)
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
             , 
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                ((void *)0)
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                    , 
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                           , 
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  , 
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                   ((void *)0)
# 5515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                       ,
   
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
  ((void *)0)
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
      , 
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
         ((void *)0)
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
             , 
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                ((void *)0)
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                    , 
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                           , 
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  , 
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                     ((void *)0)
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                         , 
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                   ((void *)0)
# 5516 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                       ,
   "v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7",
   "v8", "v9", "v10", "v11", "v12", "v13", "v14", "v15",
  "v16", "v17", "v18", "v19", "v20", "v21", "v22", "v23",
  "v24", "v25", "v26", "v27", "v28", "v29", "v30", "v31",
};

void
init_dwarf_regnames_aarch64 (void)
{
  dwarf_regnames = dwarf_regnames_aarch64;
  dwarf_regnames_count = (sizeof (dwarf_regnames_aarch64) / sizeof ((dwarf_regnames_aarch64)[0]));
}

static const char *const dwarf_regnames_s390[] =
{

  
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
        ((void *)0)
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
            , 
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
               ((void *)0)
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                   , 
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                      ((void *)0)
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                          , 
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                             ((void *)0)
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                 , 
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                    ((void *)0)
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                        , 
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               , 
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 5533 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      ,
  
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
        ((void *)0)
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
            , 
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
               ((void *)0)
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                   , 
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                      ((void *)0)
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                          , 
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                             ((void *)0)
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                 , 
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                    ((void *)0)
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                        , 
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                           ((void *)0)
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                               , 
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 5534 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      ,
  "f0", "f2", "f4", "f6", "f1", "f3", "f5", "f7",
  "f8", "f10", "f12", "f14", "f9", "f11", "f13", "f15",
  "cr0", "cr1", "cr2", "cr3", "cr4", "cr5", "cr6", "cr7",
  "cr8", "cr9", "cr10", "cr11", "cr12", "cr13", "cr14", "cr15",
  "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7",
  "a8", "a9", "a10", "a11", "a12", "a13", "a14", "a15",
  "pswm", "pswa",
  
# 5542 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
 ((void *)0)
# 5542 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
     , 
# 5542 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 5542 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           ,
  "v16", "v18", "v20", "v22", "v17", "v19", "v21", "v23",
  "v24", "v26", "v28", "v30", "v25", "v27", "v29", "v31",
};

void
init_dwarf_regnames_s390 (void)
{
  dwarf_regnames = dwarf_regnames_s390;
  dwarf_regnames_count = (sizeof (dwarf_regnames_s390) / sizeof ((dwarf_regnames_s390)[0]));
}

void
init_dwarf_regnames (unsigned int e_machine)
{
  switch (e_machine)
    {
    case 3:
      init_dwarf_regnames_i386 ();
      break;

    case 6:
      init_dwarf_regnames_iamcu ();
      break;

    case 62:
    case 180:
    case 181:
      init_dwarf_regnames_x86_64 ();
      break;

    case 183:
      init_dwarf_regnames_aarch64 ();
      break;

    case 22:
      init_dwarf_regnames_s390 ();
      break;

    default:
      break;
    }
}

static const char *
regname (unsigned int regno, int row)
{
  static char reg[64];
  if (dwarf_regnames
      && regno < dwarf_regnames_count
      && dwarf_regnames [regno] != 
# 5592 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                  ((void *)0)
# 5592 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                      )
    {
      if (row)
 return dwarf_regnames [regno];
      snprintf (reg, sizeof (reg), "r%d (%s)", regno,
  dwarf_regnames [regno]);
    }
  else
    snprintf (reg, sizeof (reg), "r%d", regno);
  return reg;
}

static void
frame_display_row (Frame_Chunk *fc, int *need_col_headers, unsigned int *max_regs)
{
  unsigned int r;
  char tmp[100];

  if (*max_regs != fc->ncols)
    *max_regs = fc->ncols;

  if (*need_col_headers)
    {
      static const char *sloc = "   LOC";

      *need_col_headers = 0;

      printf ("%-*s CFA      ", eh_addr_size * 2, sloc);

      for (r = 0; r < *max_regs; r++)
 if (fc->col_type[r] != (-1))
   {
     if (r == fc->ra)
       printf ("ra    ");
     else
       printf ("%-5s ", regname (r, 1));
   }

      printf ("\n");
    }

  print_dwarf_vma (fc->pc_begin, eh_addr_size);
  if (fc->cfa_exp)
    strcpy (tmp, "exp");
  else
    sprintf (tmp, "%s%+d", regname (fc->cfa_reg, 1), (int) fc->cfa_offset);
  printf ("%-8s ", tmp);

  for (r = 0; r < fc->ncols; r++)
    {
      if (fc->col_type[r] != (-1))
 {
   switch (fc->col_type[r])
     {
     case DW_CFA_undefined:
       strcpy (tmp, "u");
       break;
     case DW_CFA_same_value:
       strcpy (tmp, "s");
       break;
     case DW_CFA_offset:
       sprintf (tmp, "c%+d", fc->col_offset[r]);
       break;
     case DW_CFA_val_offset:
       sprintf (tmp, "v%+d", fc->col_offset[r]);
       break;
     case DW_CFA_register:
       sprintf (tmp, "%s", regname (fc->col_offset[r], 0));
       break;
     case DW_CFA_expression:
       strcpy (tmp, "exp");
       break;
     case DW_CFA_val_expression:
       strcpy (tmp, "vexp");
       break;
     default:
       strcpy (tmp, "n/a");
       break;
     }
   printf ("%-5s ", tmp);
 }
    }
  printf ("\n");
}





static unsigned char *
read_cie (unsigned char *start, unsigned char *end,
   Frame_Chunk **p_cie, int *p_version,
   unsigned long *p_aug_len, unsigned char **p_aug)
{
  int version;
  Frame_Chunk *fc;
  unsigned int length_return;
  unsigned char *augmentation_data = 
# 5689 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                    ((void *)0)
# 5689 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                        ;
  unsigned long augmentation_data_len = 0;

  * p_cie = 
# 5692 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
           ((void *)0)
# 5692 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
               ;

  if (start >= end)
    return end;

  fc = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
  memset (fc, 0, sizeof (Frame_Chunk));

  fc->col_type = (short int *) xmalloc (sizeof (short int));
  fc->col_offset = (int *) xmalloc (sizeof (int));

  version = *start++;

  fc->augmentation = (char *) start;


  while (start < end)
    if (* start ++ == '\0')
      break;
  if (start == end)
    {
      warn (gettext ("No terminator for augmentation name\n"));
      return start;
    }

  if (strcmp (fc->augmentation, "eh") == 0)
    start += eh_addr_size;

  if (version >= 4)
    {
      do { do { unsigned int amount = (1); if (sizeof (fc->ptr_size) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (fc->ptr_size)); amount = sizeof (fc->ptr_size); } if (((start) + amount) >= (end)) { if ((start) < (end)) amount = (end) - (start); else amount = 0; } if (amount == 0 || amount > 8) fc->ptr_size = 0; else fc->ptr_size = byte_get ((start), amount); } while (0); start += 1; } while (0);
      if (fc->ptr_size < 1 || fc->ptr_size > 8)
 {
   warn (gettext ("Invalid pointer size (%d) in CIE data\n"), fc->ptr_size);
   return end;
 }

      do { do { unsigned int amount = (1); if (sizeof (fc->segment_size) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (fc->segment_size)); amount = sizeof (fc->segment_size); } if (((start) + amount) >= (end)) { if ((start) < (end)) amount = (end) - (start); else amount = 0; } if (amount == 0 || amount > 8) fc->segment_size = 0; else fc->segment_size = byte_get ((start), amount); } while (0); start += 1; } while (0);

      if (fc->segment_size > 8 || fc->segment_size + fc->ptr_size > 8)
 {
   warn (gettext ("Invalid segment size (%d) in CIE data\n"), fc->segment_size);
   return end;
 }

      eh_addr_size = fc->ptr_size;
    }
  else
    {
      fc->ptr_size = eh_addr_size;
      fc->segment_size = 0;
    }
  fc->code_factor = read_uleb128 (start, & length_return, end); start += length_return;
  fc->data_factor = read_sleb128 (start, & length_return, end); start += length_return;
  if (version == 1)
    {
      do { do { unsigned int amount = (1); if (sizeof (fc->ra) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (fc->ra)); amount = sizeof (fc->ra); } if (((start) + amount) >= (end)) { if ((start) < (end)) amount = (end) - (start); else amount = 0; } if (amount == 0 || amount > 8) fc->ra = 0; else fc->ra = byte_get ((start), amount); } while (0); start += 1; } while (0);
    }
  else
    {
      fc->ra = read_uleb128 (start, & length_return, end); start += length_return;
    }

  if (fc->augmentation[0] == 'z')
    {
      augmentation_data_len = read_uleb128 (start, & length_return, end); start += length_return;
      augmentation_data = start;
      start += augmentation_data_len;

      if (start > end)
 {
   warn (gettext ("Augmentation data too long: 0x%lx\n"), augmentation_data_len);
   return end;
 }
    }

  if (augmentation_data_len)
    {
      unsigned char *p;
      unsigned char *q;
      unsigned char *qend;

      p = (unsigned char *) fc->augmentation + 1;
      q = augmentation_data;
      qend = q + augmentation_data_len;


      if (qend < q)
 {
   warn (gettext ("Negative augmentation data length: 0x%lx"), augmentation_data_len);
   augmentation_data_len = 0;
 }

      while (p < end && q < augmentation_data + augmentation_data_len)
 {
   if (*p == 'L')
     q++;
   else if (*p == 'P')
     q += 1 + size_of_encoded_value (*q);
   else if (*p == 'R')
     fc->fde_encoding = *q++;
   else if (*p == 'S')
     ;
   else
     break;
   p++;
 }


    }

  *p_cie = fc;
  if (p_version)
    *p_version = version;
  if (p_aug_len)
    {
      *p_aug_len = augmentation_data_len;
      *p_aug = augmentation_data;
    }
  return start;
}

static int
display_debug_frames (struct dwarf_section *section,
        void *file __attribute__ ((__unused__)))
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *section_start = start;
  Frame_Chunk *chunks = 0, *forward_refs = 0;
  Frame_Chunk *remembered_state = 0;
  Frame_Chunk *rs;
  int is_eh = strcmp (section->name, ".eh_frame") == 0;
  unsigned int length_return;
  unsigned int max_regs = 0;
  const char *bad_reg = gettext ("bad register: ");
  unsigned int saved_eh_addr_size = eh_addr_size;

  printf (gettext ("Contents of the %s section:\n"), section->name);

  while (start < end)
    {
      unsigned char *saved_start;
      unsigned char *block_end;
      dwarf_vma length;
      dwarf_vma cie_id;
      Frame_Chunk *fc;
      Frame_Chunk *cie;
      int need_col_headers = 1;
      unsigned char *augmentation_data = 
# 5841 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                        ((void *)0)
# 5841 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                            ;
      unsigned long augmentation_data_len = 0;
      unsigned int encoded_ptr_size = saved_eh_addr_size;
      unsigned int offset_size;
      unsigned int initial_length_size;
      bfd_boolean all_nops;

      saved_start = start;

      do { do { unsigned int amount = (4); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((start) + amount) >= (end)) { if ((start) < (end)) amount = (end) - (start); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((start), amount); } while (0); start += 4; } while (0);

      if (length == 0)
 {
   printf ("\n%08lx ZERO terminator\n\n",
      (unsigned long)(saved_start - section_start));




   while (start < end && * start == 0)
     ++ start;
   continue;
 }

      if (length == 0xffffffff)
 {
   do { do { unsigned int amount = (8); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((start) + amount) >= (end)) { if ((start) < (end)) amount = (end) - (start); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((start), amount); } while (0); start += 8; } while (0);
   offset_size = 8;
   initial_length_size = 12;
 }
      else
 {
   offset_size = 4;
   initial_length_size = 4;
 }

      block_end = saved_start + length + initial_length_size;
      if (block_end > end || block_end < start)
 {
   warn ("Invalid length 0x%s in FDE at %#08lx\n",
  dwarf_vmatoa_1 (
# 5881 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                 ((void *)0)
# 5881 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                     , length, offset_size),
  (unsigned long) (saved_start - section_start));
   block_end = end;
 }

      do { do { unsigned int amount = (offset_size); if (sizeof (cie_id) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (cie_id)); amount = sizeof (cie_id); } if (((start) + amount) >= (end)) { if ((start) < (end)) amount = (end) - (start); else amount = 0; } if (amount == 0 || amount > 8) cie_id = 0; else cie_id = byte_get ((start), amount); } while (0); start += offset_size; } while (0);

      if (is_eh ? (cie_id == 0) : ((offset_size == 4 && cie_id == 0xffffffff)
       || (offset_size == 8 && cie_id == 0xffffffffffffffffULL)))
 {
   int version;
   unsigned int mreg;

   start = read_cie (start, end, &cie, &version,
       &augmentation_data_len, &augmentation_data);

   if (cie == 
# 5897 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 5897 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 )
     break;

   fc = cie;
   fc->next = chunks;
   chunks = fc;
   fc->chunk_start = saved_start;
   mreg = max_regs > 0 ? max_regs - 1 : 0;
   if (mreg < fc->ra)
     mreg = fc->ra;
   if (frame_need_space (fc, mreg) < 0)
     break;
   if (fc->fde_encoding)
     encoded_ptr_size = size_of_encoded_value (fc->fde_encoding);

   printf ("\n%08lx ", (unsigned long) (saved_start - section_start));
   print_dwarf_vma (length, fc->ptr_size);
   print_dwarf_vma (cie_id, offset_size);

   if (do_debug_frames_interp)
     {
       printf ("CIE \"%s\" cf=%d df=%d ra=%d\n", fc->augmentation,
        fc->code_factor, fc->data_factor, fc->ra);
     }
   else
     {
       printf ("CIE\n");
       printf ("  Version:               %d\n", version);
       printf ("  Augmentation:          \"%s\"\n", fc->augmentation);
       if (version >= 4)
  {
    printf ("  Pointer Size:          %u\n", fc->ptr_size);
    printf ("  Segment Size:          %u\n", fc->segment_size);
  }
       printf ("  Code alignment factor: %u\n", fc->code_factor);
       printf ("  Data alignment factor: %d\n", fc->data_factor);
       printf ("  Return address column: %d\n", fc->ra);

       if (augmentation_data_len)
  {
    unsigned long i;

    printf ("  Augmentation data:    ");
    for (i = 0; i < augmentation_data_len; ++i)


      printf (" %02x", augmentation_data[i]);
    putchar ('\n');
  }
       putchar ('\n');
     }
 }
      else
 {
   unsigned char *look_for;
   static Frame_Chunk fde_fc;
   unsigned long segment_selector;

   if (is_eh)
     {
       dwarf_vma sign = (dwarf_vma) 1 << (offset_size * 8 - 1);
       look_for = start - 4 - ((cie_id ^ sign) - sign);
     }
   else
     look_for = section_start + cie_id;

   if (look_for <= saved_start)
     {
       for (cie = chunks; cie ; cie = cie->next)
  if (cie->chunk_start == look_for)
    break;
     }
   else
     {
       for (cie = forward_refs; cie ; cie = cie->next)
  if (cie->chunk_start == look_for)
    break;
       if (!cie)
  {
    unsigned int off_size;
    unsigned char *cie_scan;

    cie_scan = look_for;
    off_size = 4;
    do { do { unsigned int amount = (4); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((cie_scan) + amount) >= (end)) { if ((cie_scan) < (end)) amount = (end) - (cie_scan); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((cie_scan), amount); } while (0); cie_scan += 4; } while (0);
    if (length == 0xffffffff)
      {
        do { do { unsigned int amount = (8); if (sizeof (length) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (length)); amount = sizeof (length); } if (((cie_scan) + amount) >= (end)) { if ((cie_scan) < (end)) amount = (end) - (cie_scan); else amount = 0; } if (amount == 0 || amount > 8) length = 0; else length = byte_get ((cie_scan), amount); } while (0); cie_scan += 8; } while (0);
        off_size = 8;
      }
    if (length != 0)
      {
        dwarf_vma c_id;

        do { do { unsigned int amount = (off_size); if (sizeof (c_id) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (c_id)); amount = sizeof (c_id); } if (((cie_scan) + amount) >= (end)) { if ((cie_scan) < (end)) amount = (end) - (cie_scan); else amount = 0; } if (amount == 0 || amount > 8) c_id = 0; else c_id = byte_get ((cie_scan), amount); } while (0); cie_scan += off_size; } while (0);
        if (is_eh
     ? c_id == 0
     : ((off_size == 4 && c_id == 0xffffffff)
        || (off_size == 8 && c_id == 0xffffffffffffffffULL)))
   {
     int version;
     unsigned int mreg;

     read_cie (cie_scan, end, &cie, &version,
        &augmentation_data_len, &augmentation_data);

     if (cie == 
# 6003 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
               ((void *)0)
# 6003 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                   )
       {
         warn (gettext ("Failed to read CIE information\n"));
         break;
       }
     cie->next = forward_refs;
     forward_refs = cie;
     cie->chunk_start = look_for;
     mreg = max_regs > 0 ? max_regs - 1 : 0;
     if (mreg < cie->ra)
       mreg = cie->ra;
     if (frame_need_space (cie, mreg) < 0)
       {
         warn (gettext ("Invalid max register\n"));
         break;
       }
     if (cie->fde_encoding)
       encoded_ptr_size
         = size_of_encoded_value (cie->fde_encoding);
   }
      }
  }
     }

   fc = &fde_fc;
   memset (fc, 0, sizeof (Frame_Chunk));

   if (!cie)
     {
       warn ("Invalid CIE pointer 0x%s in FDE at %#08lx\n",
      dwarf_vmatoa_1 (
# 6033 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                     ((void *)0)
# 6033 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                         , cie_id, offset_size),
      (unsigned long) (saved_start - section_start));
       fc->ncols = 0;
       fc->col_type = (short int *) xmalloc (sizeof (short int));
       fc->col_offset = (int *) xmalloc (sizeof (int));
       if (frame_need_space (fc, max_regs > 0 ? max_regs - 1 : 0) < 0)
  {
    warn (gettext ("Invalid max register\n"));
    break;
  }
       cie = fc;
       fc->augmentation = "";
       fc->fde_encoding = 0;
       fc->ptr_size = eh_addr_size;
       fc->segment_size = 0;
     }
   else
     {
       fc->ncols = cie->ncols;
       fc->col_type = (short int *) xcmalloc (fc->ncols, sizeof (short int));
       fc->col_offset = (int *) xcmalloc (fc->ncols, sizeof (int));
       memcpy (fc->col_type, cie->col_type, fc->ncols * sizeof (short int));
       memcpy (fc->col_offset, cie->col_offset, fc->ncols * sizeof (int));
       fc->augmentation = cie->augmentation;
       fc->ptr_size = cie->ptr_size;
       eh_addr_size = cie->ptr_size;
       fc->segment_size = cie->segment_size;
       fc->code_factor = cie->code_factor;
       fc->data_factor = cie->data_factor;
       fc->cfa_reg = cie->cfa_reg;
       fc->cfa_offset = cie->cfa_offset;
       fc->ra = cie->ra;
       if (frame_need_space (fc, max_regs > 0 ? max_regs - 1: 0) < 0)
  {
    warn (gettext ("Invalid max register\n"));
    break;
  }
       fc->fde_encoding = cie->fde_encoding;
     }

   if (fc->fde_encoding)
     encoded_ptr_size = size_of_encoded_value (fc->fde_encoding);

   segment_selector = 0;
   if (fc->segment_size)
     {
       if (fc->segment_size > sizeof (segment_selector))
  {

    warn (gettext ("Probably corrupt segment size: %d - using 4 instead\n"), fc->segment_size);
    fc->segment_size = 4;
  }
       do { do { unsigned int amount = (fc->segment_size); if (sizeof (segment_selector) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (segment_selector)); amount = sizeof (segment_selector); } if (((start) + amount) >= (end)) { if ((start) < (end)) amount = (end) - (start); else amount = 0; } if (amount == 0 || amount > 8) segment_selector = 0; else segment_selector = byte_get ((start), amount); } while (0); start += fc->segment_size; } while (0);
     }

   fc->pc_begin = get_encoded_value (&start, fc->fde_encoding, section, end);





   do { do { unsigned int amount = (encoded_ptr_size); if (sizeof (fc->pc_range) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (fc->pc_range)); amount = sizeof (fc->pc_range); } if (((start) + amount) >= (end)) { if ((start) < (end)) amount = (end) - (start); else amount = 0; } if (amount == 0 || amount > 8) fc->pc_range = 0; else fc->pc_range = byte_get ((start), amount); } while (0); start += encoded_ptr_size; } while (0);

   if (cie->augmentation[0] == 'z')
     {
       augmentation_data_len = read_uleb128 (start, & length_return, end); start += length_return;
       augmentation_data = start;
       start += augmentation_data_len;

       if (start >= end || ((signed long) augmentation_data_len) < 0)
  {
    warn (gettext ("Corrupt augmentation data length: %lx\n"),
   augmentation_data_len);
    start = end;
    augmentation_data = 
# 6107 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                       ((void *)0)
# 6107 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                           ;
    augmentation_data_len = 0;
  }
     }

   printf ("\n%08lx %s %s FDE cie=%08lx pc=",
    (unsigned long)(saved_start - section_start),
    dwarf_vmatoa_1 (
# 6114 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 6114 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , length, fc->ptr_size),
    dwarf_vmatoa_1 (
# 6115 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 6115 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , cie_id, offset_size),
    (unsigned long)(cie->chunk_start - section_start));

   if (fc->segment_size)
     printf ("%04lx:", segment_selector);

   printf ("%s..%s\n",
    dwarf_vmatoa_1 (
# 6122 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 6122 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , fc->pc_begin, fc->ptr_size),
    dwarf_vmatoa_1 (
# 6123 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 6123 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       , fc->pc_begin + fc->pc_range, fc->ptr_size));

   if (! do_debug_frames_interp && augmentation_data_len)
     {
       unsigned long i;

       printf ("  Augmentation data:    ");
       for (i = 0; i < augmentation_data_len; ++i)
  printf (" %02x", augmentation_data[i]);
       putchar ('\n');
       putchar ('\n');
     }
 }
# 6144 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
      if (1 || do_debug_frames_interp)
 {


   unsigned char *tmp = start;

   while (start < block_end)
     {
       unsigned int reg, op, opa;
       unsigned long temp;
       unsigned char * new_start;

       op = *start++;
       opa = op & 0x3f;
       if (op & 0xc0)
  op &= 0xc0;



       switch (op)
  {
  case DW_CFA_advance_loc:
    break;
  case DW_CFA_offset:
    read_uleb128 (start, & length_return, end); start += length_return;
    if (frame_need_space (fc, opa) >= 0)
      fc->col_type[opa] = DW_CFA_undefined;
    break;
  case DW_CFA_restore:
    if (frame_need_space (fc, opa) >= 0)
      fc->col_type[opa] = DW_CFA_undefined;
    break;
  case DW_CFA_set_loc:
    start += encoded_ptr_size;
    break;
  case DW_CFA_advance_loc1:
    start += 1;
    break;
  case DW_CFA_advance_loc2:
    start += 2;
    break;
  case DW_CFA_advance_loc4:
    start += 4;
    break;
  case DW_CFA_offset_extended:
  case DW_CFA_val_offset:
    reg = read_uleb128 (start, & length_return, end); start += length_return; read_uleb128 (start, & length_return, end); start += length_return;
    if (frame_need_space (fc, reg) >= 0)
      fc->col_type[reg] = DW_CFA_undefined;
    break;
  case DW_CFA_restore_extended:
    reg = read_uleb128 (start, & length_return, end); start += length_return;
    if (frame_need_space (fc, reg) >= 0)
      fc->col_type[reg] = DW_CFA_undefined;
    break;
  case DW_CFA_undefined:
    reg = read_uleb128 (start, & length_return, end); start += length_return;
    if (frame_need_space (fc, reg) >= 0)
      fc->col_type[reg] = DW_CFA_undefined;
    break;
  case DW_CFA_same_value:
    reg = read_uleb128 (start, & length_return, end); start += length_return;
    if (frame_need_space (fc, reg) >= 0)
      fc->col_type[reg] = DW_CFA_undefined;
    break;
  case DW_CFA_register:
    reg = read_uleb128 (start, & length_return, end); start += length_return; read_uleb128 (start, & length_return, end); start += length_return;
    if (frame_need_space (fc, reg) >= 0)
      fc->col_type[reg] = DW_CFA_undefined;
    break;
  case DW_CFA_def_cfa:
    read_uleb128 (start, & length_return, end); start += length_return; read_uleb128 (start, & length_return, end); start += length_return;
    break;
  case DW_CFA_def_cfa_register:
    read_uleb128 (start, & length_return, end); start += length_return;
    break;
  case DW_CFA_def_cfa_offset:
    read_uleb128 (start, & length_return, end); start += length_return;
    break;
  case DW_CFA_def_cfa_expression:
    temp = read_uleb128 (start, & length_return, end); start += length_return;
    new_start = start + temp;
    if (new_start < start)
      {
        warn (gettext ("Corrupt CFA_def expression value: %lu\n"), temp);
        start = block_end;
      }
    else
      start = new_start;
    break;
  case DW_CFA_expression:
  case DW_CFA_val_expression:
    reg = read_uleb128 (start, & length_return, end); start += length_return;
    temp = read_uleb128 (start, & length_return, end); start += length_return;
    new_start = start + temp;
    if (new_start < start)
      {

        warn (gettext ("Corrupt CFA expression value: %lu\n"), temp);
        start = block_end;
      }
    else
      start = new_start;
    if (frame_need_space (fc, reg) >= 0)
      fc->col_type[reg] = DW_CFA_undefined;
    break;
  case DW_CFA_offset_extended_sf:
  case DW_CFA_val_offset_sf:
    reg = read_uleb128 (start, & length_return, end); start += length_return; read_sleb128 (start, & length_return, end); start += length_return;
    if (frame_need_space (fc, reg) >= 0)
      fc->col_type[reg] = DW_CFA_undefined;
    break;
  case DW_CFA_def_cfa_sf:
    read_uleb128 (start, & length_return, end); start += length_return; read_sleb128 (start, & length_return, end); start += length_return;
    break;
  case DW_CFA_def_cfa_offset_sf:
    read_sleb128 (start, & length_return, end); start += length_return;
    break;
  case DW_CFA_MIPS_advance_loc8:
    start += 8;
    break;
  case DW_CFA_GNU_args_size:
    read_uleb128 (start, & length_return, end); start += length_return;
    break;
  case DW_CFA_GNU_negative_offset_extended:
    reg = read_uleb128 (start, & length_return, end); start += length_return; read_uleb128 (start, & length_return, end); start += length_return;
    if (frame_need_space (fc, reg) >= 0)
      fc->col_type[reg] = DW_CFA_undefined;
    break;
  default:
    break;
  }
     }
   start = tmp;
 }

      all_nops = 1;




      while (start < block_end)
 {
   unsigned char * tmp;
   unsigned op, opa;
   unsigned long ul, reg, roffs;
   dwarf_vma l;
   dwarf_vma ofs;
   dwarf_vma vma;
   const char *reg_prefix = "";

   op = *start++;
   opa = op & 0x3f;
   if (op & 0xc0)
     op &= 0xc0;


   if (op != DW_CFA_nop)
     all_nops = 0;



   switch (op)
     {
     case DW_CFA_advance_loc:
       if (do_debug_frames_interp)
  frame_display_row (fc, &need_col_headers, &max_regs);
       else
  printf ("  DW_CFA_advance_loc: %d to %s\n",
   opa * fc->code_factor,
   dwarf_vmatoa_1 (
# 6314 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 6314 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      ,
     fc->pc_begin + opa * fc->code_factor,
     fc->ptr_size));
       fc->pc_begin += opa * fc->code_factor;
       break;

     case DW_CFA_offset:
       roffs = read_uleb128 (start, & length_return, end); start += length_return;
       if (opa >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_offset: %s%s at cfa%+ld\n",
   reg_prefix, regname (opa, 0),
   roffs * fc->data_factor);
       if (*reg_prefix == '\0')
  {
    fc->col_type[opa] = DW_CFA_offset;
    fc->col_offset[opa] = roffs * fc->data_factor;
  }
       break;

     case DW_CFA_restore:
       if (opa >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_restore: %s%s\n",
   reg_prefix, regname (opa, 0));
       if (*reg_prefix != '\0')
  break;

       if (opa >= (unsigned int) cie->ncols
    || (do_debug_frames_interp
        && cie->col_type[opa] == (-1)))
  {
    fc->col_type[opa] = DW_CFA_undefined;
    fc->col_offset[opa] = 0;
  }
       else
  {
    fc->col_type[opa] = cie->col_type[opa];
    fc->col_offset[opa] = cie->col_offset[opa];
  }
       break;

     case DW_CFA_set_loc:
       vma = get_encoded_value (&start, fc->fde_encoding, section, block_end);
       if (do_debug_frames_interp)
  frame_display_row (fc, &need_col_headers, &max_regs);
       else
  printf ("  DW_CFA_set_loc: %s\n",
   dwarf_vmatoa_1 (
# 6364 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 6364 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      , vma, fc->ptr_size));
       fc->pc_begin = vma;
       break;

     case DW_CFA_advance_loc1:
       do { do { unsigned int amount = (1); if (sizeof (ofs) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (ofs)); amount = sizeof (ofs); } if (((start) + amount) >= (end)) { if ((start) < (end)) amount = (end) - (start); else amount = 0; } if (amount == 0 || amount > 8) ofs = 0; else ofs = byte_get ((start), amount); } while (0); start += 1; } while (0);
       if (do_debug_frames_interp)
  frame_display_row (fc, &need_col_headers, &max_regs);
       else
  printf ("  DW_CFA_advance_loc1: %ld to %s\n",
   (unsigned long) (ofs * fc->code_factor),
   dwarf_vmatoa_1 (
# 6375 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 6375 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      ,
     fc->pc_begin + ofs * fc->code_factor,
     fc->ptr_size));
       fc->pc_begin += ofs * fc->code_factor;
       break;

     case DW_CFA_advance_loc2:
       do { do { unsigned int amount = (2); if (sizeof (ofs) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (ofs)); amount = sizeof (ofs); } if (((start) + amount) >= (block_end)) { if ((start) < (block_end)) amount = (block_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) ofs = 0; else ofs = byte_get ((start), amount); } while (0); start += 2; } while (0);
       if (do_debug_frames_interp)
  frame_display_row (fc, &need_col_headers, &max_regs);
       else
  printf ("  DW_CFA_advance_loc2: %ld to %s\n",
   (unsigned long) (ofs * fc->code_factor),
   dwarf_vmatoa_1 (
# 6388 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 6388 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      ,
     fc->pc_begin + ofs * fc->code_factor,
     fc->ptr_size));
       fc->pc_begin += ofs * fc->code_factor;
       break;

     case DW_CFA_advance_loc4:
       do { do { unsigned int amount = (4); if (sizeof (ofs) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (ofs)); amount = sizeof (ofs); } if (((start) + amount) >= (block_end)) { if ((start) < (block_end)) amount = (block_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) ofs = 0; else ofs = byte_get ((start), amount); } while (0); start += 4; } while (0);
       if (do_debug_frames_interp)
  frame_display_row (fc, &need_col_headers, &max_regs);
       else
  printf ("  DW_CFA_advance_loc4: %ld to %s\n",
   (unsigned long) (ofs * fc->code_factor),
   dwarf_vmatoa_1 (
# 6401 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 6401 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      ,
     fc->pc_begin + ofs * fc->code_factor,
     fc->ptr_size));
       fc->pc_begin += ofs * fc->code_factor;
       break;

     case DW_CFA_offset_extended:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       roffs = read_uleb128 (start, & length_return, end); start += length_return;
       if (reg >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_offset_extended: %s%s at cfa%+ld\n",
   reg_prefix, regname (reg, 0),
   roffs * fc->data_factor);
       if (*reg_prefix == '\0')
  {
    fc->col_type[reg] = DW_CFA_offset;
    fc->col_offset[reg] = roffs * fc->data_factor;
  }
       break;

     case DW_CFA_val_offset:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       roffs = read_uleb128 (start, & length_return, end); start += length_return;
       if (reg >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_val_offset: %s%s is cfa%+ld\n",
   reg_prefix, regname (reg, 0),
   roffs * fc->data_factor);
       if (*reg_prefix == '\0')
  {
    fc->col_type[reg] = DW_CFA_val_offset;
    fc->col_offset[reg] = roffs * fc->data_factor;
  }
       break;

     case DW_CFA_restore_extended:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       if (reg >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_restore_extended: %s%s\n",
   reg_prefix, regname (reg, 0));
       if (*reg_prefix != '\0')
  break;

       if (reg >= (unsigned int) cie->ncols)
  {
    fc->col_type[reg] = DW_CFA_undefined;
    fc->col_offset[reg] = 0;
  }
       else
  {
    fc->col_type[reg] = cie->col_type[reg];
    fc->col_offset[reg] = cie->col_offset[reg];
  }
       break;

     case DW_CFA_undefined:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       if (reg >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_undefined: %s%s\n",
   reg_prefix, regname (reg, 0));
       if (*reg_prefix == '\0')
  {
    fc->col_type[reg] = DW_CFA_undefined;
    fc->col_offset[reg] = 0;
  }
       break;

     case DW_CFA_same_value:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       if (reg >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_same_value: %s%s\n",
   reg_prefix, regname (reg, 0));
       if (*reg_prefix == '\0')
  {
    fc->col_type[reg] = DW_CFA_same_value;
    fc->col_offset[reg] = 0;
  }
       break;

     case DW_CFA_register:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       roffs = read_uleb128 (start, & length_return, end); start += length_return;
       if (reg >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  {
    printf ("  DW_CFA_register: %s%s in ",
     reg_prefix, regname (reg, 0));
    puts (regname (roffs, 0));
  }
       if (*reg_prefix == '\0')
  {
    fc->col_type[reg] = DW_CFA_register;
    fc->col_offset[reg] = roffs;
  }
       break;

     case DW_CFA_remember_state:
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_remember_state\n");
       rs = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
       rs->cfa_offset = fc->cfa_offset;
       rs->cfa_reg = fc->cfa_reg;
       rs->ra = fc->ra;
       rs->cfa_exp = fc->cfa_exp;
       rs->ncols = fc->ncols;
       rs->col_type = (short int *) xcmalloc (rs->ncols,
           sizeof (* rs->col_type));
       rs->col_offset = (int *) xcmalloc (rs->ncols, sizeof (* rs->col_offset));
       memcpy (rs->col_type, fc->col_type, rs->ncols * sizeof (* fc->col_type));
       memcpy (rs->col_offset, fc->col_offset, rs->ncols * sizeof (* fc->col_offset));
       rs->next = remembered_state;
       remembered_state = rs;
       break;

     case DW_CFA_restore_state:
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_restore_state\n");
       rs = remembered_state;
       if (rs)
  {
    remembered_state = rs->next;
    fc->cfa_offset = rs->cfa_offset;
    fc->cfa_reg = rs->cfa_reg;
    fc->ra = rs->ra;
    fc->cfa_exp = rs->cfa_exp;
    if (frame_need_space (fc, rs->ncols - 1) < 0)
      {
        warn (gettext ("Invalid column number in saved frame state\n"));
        fc->ncols = 0;
        break;
      }
    memcpy (fc->col_type, rs->col_type, rs->ncols * sizeof (* rs->col_type));
    memcpy (fc->col_offset, rs->col_offset,
     rs->ncols * sizeof (* rs->col_offset));
    free (rs->col_type);
    free (rs->col_offset);
    free (rs);
  }
       else if (do_debug_frames_interp)
  printf ("Mismatched DW_CFA_restore_state\n");
       break;

     case DW_CFA_def_cfa:
       fc->cfa_reg = read_uleb128 (start, & length_return, end); start += length_return;
       fc->cfa_offset = read_uleb128 (start, & length_return, end); start += length_return;
       fc->cfa_exp = 0;
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_def_cfa: %s ofs %d\n",
   regname (fc->cfa_reg, 0), (int) fc->cfa_offset);
       break;

     case DW_CFA_def_cfa_register:
       fc->cfa_reg = read_uleb128 (start, & length_return, end); start += length_return;
       fc->cfa_exp = 0;
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_def_cfa_register: %s\n",
   regname (fc->cfa_reg, 0));
       break;

     case DW_CFA_def_cfa_offset:
       fc->cfa_offset = read_uleb128 (start, & length_return, end); start += length_return;
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_def_cfa_offset: %d\n", (int) fc->cfa_offset);
       break;

     case DW_CFA_nop:
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_nop\n");
       break;

     case DW_CFA_def_cfa_expression:
       ul = read_uleb128 (start, & length_return, end); start += length_return;
       if (start >= block_end || ul > (unsigned long) (block_end - start))
  {
    printf (gettext ("  DW_CFA_def_cfa_expression: <corrupt len %lu>\n"), ul);
    break;
  }
       if (! do_debug_frames_interp)
  {
    printf ("  DW_CFA_def_cfa_expression (");
    decode_location_expression (start, eh_addr_size, 0, -1,
           ul, 0, section);
    printf (")\n");
  }
       fc->cfa_exp = 1;
       start += ul;
       break;

     case DW_CFA_expression:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       ul = read_uleb128 (start, & length_return, end); start += length_return;
       if (reg >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;


       tmp = start + ul;
       if (start >= block_end || tmp > block_end || tmp < start)
  {
    printf (gettext ("  DW_CFA_expression: <corrupt len %lu>\n"), ul);
    break;
  }
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  {
    printf ("  DW_CFA_expression: %s%s (",
     reg_prefix, regname (reg, 0));
    decode_location_expression (start, eh_addr_size, 0, -1,
           ul, 0, section);
    printf (")\n");
  }
       if (*reg_prefix == '\0')
  fc->col_type[reg] = DW_CFA_expression;
       start = tmp;
       break;

     case DW_CFA_val_expression:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       ul = read_uleb128 (start, & length_return, end); start += length_return;
       if (reg >= (unsigned int) fc->ncols)
  reg_prefix = bad_reg;
       tmp = start + ul;
       if (start >= block_end || tmp > block_end || tmp < start)
  {
    printf ("  DW_CFA_val_expression: <corrupt len %lu>\n", ul);
    break;
  }
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  {
    printf ("  DW_CFA_val_expression: %s%s (",
     reg_prefix, regname (reg, 0));
    decode_location_expression (start, eh_addr_size, 0, -1,
           ul, 0, section);
    printf (")\n");
  }
       if (*reg_prefix == '\0')
  fc->col_type[reg] = DW_CFA_val_expression;
       start = tmp;
       break;

     case DW_CFA_offset_extended_sf:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       l = read_sleb128 (start, & length_return, end); start += length_return;
       if (frame_need_space (fc, reg) < 0)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_offset_extended_sf: %s%s at cfa%+ld\n",
   reg_prefix, regname (reg, 0),
   (long)(l * fc->data_factor));
       if (*reg_prefix == '\0')
  {
    fc->col_type[reg] = DW_CFA_offset;
    fc->col_offset[reg] = l * fc->data_factor;
  }
       break;

     case DW_CFA_val_offset_sf:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       l = read_sleb128 (start, & length_return, end); start += length_return;
       if (frame_need_space (fc, reg) < 0)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_val_offset_sf: %s%s is cfa%+ld\n",
   reg_prefix, regname (reg, 0),
   (long)(l * fc->data_factor));
       if (*reg_prefix == '\0')
  {
    fc->col_type[reg] = DW_CFA_val_offset;
    fc->col_offset[reg] = l * fc->data_factor;
  }
       break;

     case DW_CFA_def_cfa_sf:
       fc->cfa_reg = read_uleb128 (start, & length_return, end); start += length_return;
       fc->cfa_offset = read_sleb128 (start, & length_return, end); start += length_return;
       fc->cfa_offset = fc->cfa_offset * fc->data_factor;
       fc->cfa_exp = 0;
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_def_cfa_sf: %s ofs %d\n",
   regname (fc->cfa_reg, 0), (int) fc->cfa_offset);
       break;

     case DW_CFA_def_cfa_offset_sf:
       fc->cfa_offset = read_sleb128 (start, & length_return, end); start += length_return;
       fc->cfa_offset *= fc->data_factor;
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_def_cfa_offset_sf: %d\n", (int) fc->cfa_offset);
       break;

     case DW_CFA_MIPS_advance_loc8:
       do { do { unsigned int amount = (8); if (sizeof (ofs) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (ofs)); amount = sizeof (ofs); } if (((start) + amount) >= (block_end)) { if ((start) < (block_end)) amount = (block_end) - (start); else amount = 0; } if (amount == 0 || amount > 8) ofs = 0; else ofs = byte_get ((start), amount); } while (0); start += 8; } while (0);
       if (do_debug_frames_interp)
  frame_display_row (fc, &need_col_headers, &max_regs);
       else
  printf ("  DW_CFA_MIPS_advance_loc8: %ld to %s\n",
   (unsigned long) (ofs * fc->code_factor),
   dwarf_vmatoa_1 (
# 6705 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                  ((void *)0)
# 6705 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                      ,
     fc->pc_begin + ofs * fc->code_factor,
     fc->ptr_size));
       fc->pc_begin += ofs * fc->code_factor;
       break;

     case DW_CFA_GNU_window_save:
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_GNU_window_save\n");
       break;

     case DW_CFA_GNU_args_size:
       ul = read_uleb128 (start, & length_return, end); start += length_return;
       if (! do_debug_frames_interp)
  printf ("  DW_CFA_GNU_args_size: %ld\n", ul);
       break;

     case DW_CFA_GNU_negative_offset_extended:
       reg = read_uleb128 (start, & length_return, end); start += length_return;
       l = - read_uleb128 (start, & length_return, end); start += length_return;
       if (frame_need_space (fc, reg) < 0)
  reg_prefix = bad_reg;
       if (! do_debug_frames_interp || *reg_prefix != '\0')
  printf ("  DW_CFA_GNU_negative_offset_extended: %s%s at cfa%+ld\n",
   reg_prefix, regname (reg, 0),
   (long)(l * fc->data_factor));
       if (*reg_prefix == '\0')
  {
    fc->col_type[reg] = DW_CFA_offset;
    fc->col_offset[reg] = l * fc->data_factor;
  }
       break;

     default:
       if (op >= DW_CFA_lo_user && op <= DW_CFA_hi_user)
  printf (gettext ("  DW_CFA_??? (User defined call frame op: %#x)\n"), op);
       else
  warn (gettext ("Unsupported or unknown Dwarf Call Frame Instruction number: %#x\n"), op);
       start = block_end;
     }
 }


      if (do_debug_frames_interp && ! all_nops)
 frame_display_row (fc, &need_col_headers, &max_regs);

      start = block_end;
      eh_addr_size = saved_eh_addr_size;
    }

  printf ("\n");

  return 1;
}





static int
display_gdb_index (struct dwarf_section *section,
     void *file __attribute__ ((__unused__)))
{
  unsigned char *start = section->start;
  uint32_t version;
  uint32_t cu_list_offset, tu_list_offset;
  uint32_t address_table_offset, symbol_table_offset, constant_pool_offset;
  unsigned int cu_list_elements, tu_list_elements;
  unsigned int address_table_size, symbol_table_slots;
  unsigned char *cu_list, *tu_list;
  unsigned char *address_table, *symbol_table, *constant_pool;
  unsigned int i;



  printf (gettext ("Contents of the %s section:\n"), section->name);

  if (section->size < 6 * sizeof (uint32_t))
    {
      warn (gettext ("Truncated header in the %s section.\n"), section->name);
      return 0;
    }

  version = byte_get_little_endian (start, 4);
  printf (gettext ("Version %ld\n"), (long) version);



  if (version < 3 || version > 8)
    {
      warn (gettext ("Unsupported version %lu.\n"), (unsigned long) version);
      return 0;
    }
  if (version < 4)
    warn (gettext ("The address table data in version 3 may be wrong.\n"));
  if (version < 5)
    warn (gettext ("Version 4 does not support case insensitive lookups.\n"));
  if (version < 6)
    warn (gettext ("Version 5 does not include inlined functions.\n"));
  if (version < 7)
      warn (gettext ("Version 6 does not include symbol attributes.\n"));





  cu_list_offset = byte_get_little_endian (start + 4, 4);
  tu_list_offset = byte_get_little_endian (start + 8, 4);
  address_table_offset = byte_get_little_endian (start + 12, 4);
  symbol_table_offset = byte_get_little_endian (start + 16, 4);
  constant_pool_offset = byte_get_little_endian (start + 20, 4);

  if (cu_list_offset > section->size
      || tu_list_offset > section->size
      || address_table_offset > section->size
      || symbol_table_offset > section->size
      || constant_pool_offset > section->size)
    {
      warn (gettext ("Corrupt header in the %s section.\n"), section->name);
      return 0;
    }


  if (tu_list_offset < cu_list_offset)
    {
      warn (gettext ("TU offset (%x) is less than CU offset (%x)\n"),
     tu_list_offset, cu_list_offset);
      return 0;
    }

  cu_list_elements = (tu_list_offset - cu_list_offset) / 8;

  if (address_table_offset < tu_list_offset)
    {
      warn (gettext ("Address table offset (%x) is less than TU offset (%x)\n"),
     address_table_offset, tu_list_offset);
      return 0;
    }

  tu_list_elements = (address_table_offset - tu_list_offset) / 8;


  if (symbol_table_offset < address_table_offset)
    {
      warn (gettext ("Symbol table offset (%xl) is less then Address table offset (%x)\n"),
     symbol_table_offset, address_table_offset);
      return 0;
    }

  address_table_size = symbol_table_offset - address_table_offset;

  if (constant_pool_offset < symbol_table_offset)
    {
      warn (gettext ("Constant pool offset (%x) is less than symbol table offset (%x)\n"),
     constant_pool_offset, symbol_table_offset);
      return 0;
    }

  symbol_table_slots = (constant_pool_offset - symbol_table_offset) / 8;

  cu_list = start + cu_list_offset;
  tu_list = start + tu_list_offset;
  address_table = start + address_table_offset;
  symbol_table = start + symbol_table_offset;
  constant_pool = start + constant_pool_offset;

  if (address_table + address_table_size * (2 + 8 + 4) > section->start + section->size)
    {
      warn (gettext ("Address table extends beyond end of section.\n"));
      return 0;
    }

  printf (gettext ("\nCU table:\n"));
  for (i = 0; i < cu_list_elements; i += 2)
    {
      uint64_t cu_offset = byte_get_little_endian (cu_list + i * 8, 8);
      uint64_t cu_length = byte_get_little_endian (cu_list + i * 8 + 8, 8);

      printf (gettext ("[%3u] 0x%lx - 0x%lx\n"), i / 2,
       (unsigned long) cu_offset,
       (unsigned long) (cu_offset + cu_length - 1));
    }

  printf (gettext ("\nTU table:\n"));
  for (i = 0; i < tu_list_elements; i += 3)
    {
      uint64_t tu_offset = byte_get_little_endian (tu_list + i * 8, 8);
      uint64_t type_offset = byte_get_little_endian (tu_list + i * 8 + 8, 8);
      uint64_t signature = byte_get_little_endian (tu_list + i * 8 + 16, 8);

      printf (gettext ("[%3u] 0x%lx 0x%lx "), i / 3,
       (unsigned long) tu_offset,
       (unsigned long) type_offset);
      print_dwarf_vma (signature, 8);
      printf ("\n");
    }

  printf (gettext ("\nAddress table:\n"));
  for (i = 0; i < address_table_size && i <= address_table_size - (2 * 8 + 4);
       i += 2 * 8 + 4)
    {
      uint64_t low = byte_get_little_endian (address_table + i, 8);
      uint64_t high = byte_get_little_endian (address_table + i + 8, 8);
      uint32_t cu_index = byte_get_little_endian (address_table + i + 16, 4);

      print_dwarf_vma (low, 8);
      print_dwarf_vma (high, 8);
      printf (gettext ("%lu\n"), (unsigned long) cu_index);
    }

  printf (gettext ("\nSymbol table:\n"));
  for (i = 0; i < symbol_table_slots; ++i)
    {
      uint32_t name_offset = byte_get_little_endian (symbol_table + i * 8, 4);
      uint32_t cu_vector_offset = byte_get_little_endian (symbol_table + i * 8 + 4, 4);
      uint32_t num_cus, cu;

      if (name_offset != 0
   || cu_vector_offset != 0)
 {
   unsigned int j;
   unsigned char * adr;

   adr = constant_pool + name_offset;

   if (adr < constant_pool || adr >= section->start + section->size)
     {
       printf (gettext ("[%3u] <corrupt offset: %x>"), i, name_offset);
       warn (gettext ("Corrupt name offset of 0x%x found for symbol table slot %d\n"),
      name_offset, i);
     }
   else
     printf ("[%3u] %.*s:", i,
      (int) (section->size - (constant_pool_offset + name_offset)),
      constant_pool + name_offset);

   adr = constant_pool + cu_vector_offset;
   if (adr < constant_pool || adr >= section->start + section->size - 3)
     {
       printf (gettext ("<invalid CU vector offset: %x>\n"), cu_vector_offset);
       warn (gettext ("Corrupt CU vector offset of 0x%x found for symbol table slot %d\n"),
      cu_vector_offset, i);
       continue;
     }

   num_cus = byte_get_little_endian (adr, 4);

   adr = constant_pool + cu_vector_offset + 4 + num_cus * 4;
   if (num_cus * 4 < num_cus
       || adr >= section->start + section->size
       || adr < constant_pool)
     {
       printf ("<invalid number of CUs: %d>\n", num_cus);
       warn (gettext ("Invalid number of CUs (0x%x) for symbol table slot %d\n"),
      num_cus, i);
       continue;
     }

   if (num_cus > 1)
     printf ("\n");

   for (j = 0; j < num_cus; ++j)
     {
       int is_static;
       gdb_index_symbol_kind kind;

       cu = byte_get_little_endian (constant_pool + cu_vector_offset + 4 + j * 4, 4);
       is_static = (((cu) >> 31) & 1);
       kind = ((gdb_index_symbol_kind) (((cu) >> 28) & 7));
       cu = ((cu) & ((1 << 24) - 1));

       if (cu >= cu_list_elements / 2)
  printf ("%cT%lu", num_cus > 1 ? '\t' : ' ',
   (unsigned long) (cu - cu_list_elements / 2));
       else
  printf ("%c%lu", num_cus > 1 ? '\t' : ' ', (unsigned long) cu);

       printf (" [%s, %s]",
        is_static ? gettext ("static") : gettext ("global"),
        get_gdb_index_symbol_kind_name (kind));
       if (num_cus > 1)
  printf ("\n");
     }
   if (num_cus <= 1)
     printf ("\n");
 }
    }

  return 1;
}



static void
prealloc_cu_tu_list (unsigned int nshndx)
{
  if (shndx_pool == 
# 7001 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                   ((void *)0)
# 7001 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                       )
    {
      shndx_pool_size = nshndx;
      shndx_pool_used = 0;
      shndx_pool = (unsigned int *) xcmalloc (shndx_pool_size,
           sizeof (unsigned int));
    }
  else
    {
      shndx_pool_size = shndx_pool_used + nshndx;
      shndx_pool = (unsigned int *) xcrealloc (shndx_pool, shndx_pool_size,
            sizeof (unsigned int));
    }
}

static void
add_shndx_to_cu_tu_entry (unsigned int shndx)
{
  if (shndx_pool_used >= shndx_pool_size)
    {
      error (gettext ("Internal error: out of space in the shndx pool.\n"));
      return;
    }
  shndx_pool [shndx_pool_used++] = shndx;
}

static void
end_cu_tu_entry (void)
{
  if (shndx_pool_used >= shndx_pool_size)
    {
      error (gettext ("Internal error: out of space in the shndx pool.\n"));
      return;
    }
  shndx_pool [shndx_pool_used++] = 0;
}



static const char *
get_DW_SECT_short_name (unsigned int dw_sect)
{
  static char buf[16];

  switch (dw_sect)
    {
      case DW_SECT_INFO:
 return "info";
      case DW_SECT_TYPES:
 return "types";
      case DW_SECT_ABBREV:
 return "abbrev";
      case DW_SECT_LINE:
 return "line";
      case DW_SECT_LOC:
 return "loc";
      case DW_SECT_STR_OFFSETS:
 return "str_off";
      case DW_SECT_MACINFO:
 return "macinfo";
      case DW_SECT_MACRO:
 return "macro";
      default:
 break;
    }

  snprintf (buf, sizeof (buf), "%d", dw_sect);
  return buf;
}





static int
process_cu_tu_index (struct dwarf_section *section, int do_display)
{
  unsigned char *phdr = section->start;
  unsigned char *limit = phdr + section->size;
  unsigned char *phash;
  unsigned char *pindex;
  unsigned char *ppool;
  unsigned int version;
  unsigned int ncols = 0;
  unsigned int nused;
  unsigned int nslots;
  unsigned int i;
  unsigned int j;
  dwarf_vma signature_high;
  dwarf_vma signature_low;
  char buf[64];


  if (phdr == 
# 7094 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 7094 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 )
    {
      warn (gettext ("Section %s is empty\n"), section->name);
      return 0;
    }

  if (section->size < 24)
    {
      warn (gettext ("Section %s is too small to contain a CU/TU header\n"),
     section->name);
      return 0;
    }

  do { unsigned int amount = (4); if (sizeof (version) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (version)); amount = sizeof (version); } if (((phdr) + amount) >= (limit)) { if ((phdr) < (limit)) amount = (limit) - (phdr); else amount = 0; } if (amount == 0 || amount > 8) version = 0; else version = byte_get ((phdr), amount); } while (0);
  if (version >= 2)
    do { unsigned int amount = (4); if (sizeof (ncols) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (ncols)); amount = sizeof (ncols); } if (((phdr + 4) + amount) >= (limit)) { if ((phdr + 4) < (limit)) amount = (limit) - (phdr + 4); else amount = 0; } if (amount == 0 || amount > 8) ncols = 0; else ncols = byte_get ((phdr + 4), amount); } while (0);
  do { unsigned int amount = (4); if (sizeof (nused) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (nused)); amount = sizeof (nused); } if (((phdr + 8) + amount) >= (limit)) { if ((phdr + 8) < (limit)) amount = (limit) - (phdr + 8); else amount = 0; } if (amount == 0 || amount > 8) nused = 0; else nused = byte_get ((phdr + 8), amount); } while (0);
  do { unsigned int amount = (4); if (sizeof (nslots) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (nslots)); amount = sizeof (nslots); } if (((phdr + 12) + amount) >= (limit)) { if ((phdr + 12) < (limit)) amount = (limit) - (phdr + 12); else amount = 0; } if (amount == 0 || amount > 8) nslots = 0; else nslots = byte_get ((phdr + 12), amount); } while (0);

  phash = phdr + 16;
  pindex = phash + nslots * 8;
  ppool = pindex + nslots * 4;


  if (pindex < phash || ppool < phdr || (pindex == phash && nslots != 0))
    {
      warn (gettext ("Section %s is too small for %d slots\n"),
     section->name, nslots);
      return 0;
    }

  if (do_display)
    {
      printf (gettext ("Contents of the %s section:\n\n"), section->name);
      printf (gettext ("  Version:                 %d\n"), version);
      if (version >= 2)
 printf (gettext ("  Number of columns:       %d\n"), ncols);
      printf (gettext ("  Number of used entries:  %d\n"), nused);
      printf (gettext ("  Number of slots:         %d\n\n"), nslots);
    }

  if (ppool > limit || ppool < phdr)
    {
      warn (gettext ("Section %s too small for %d hash table entries\n"),
     section->name, nslots);
      return 0;
    }

  if (version == 1)
    {
      if (!do_display)
 prealloc_cu_tu_list ((limit - ppool) / 4);
      for (i = 0; i < nslots; i++)
 {
   unsigned char *shndx_list;
   unsigned int shndx;

   do { if (((phash) + 8) <= (limit)) { byte_get_64 ((phash), (&signature_high), (&signature_low)); } else { * (&signature_low) = * (&signature_high) = 0; } } while (0);
   if (signature_high != 0 || signature_low != 0)
     {
       do { unsigned int amount = (4); if (sizeof (j) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (j)); amount = sizeof (j); } if (((pindex) + amount) >= (limit)) { if ((pindex) < (limit)) amount = (limit) - (pindex); else amount = 0; } if (amount == 0 || amount > 8) j = 0; else j = byte_get ((pindex), amount); } while (0);
       shndx_list = ppool + j * 4;

       if (shndx_list < ppool)
  {
    warn (gettext ("Section index pool located before start of section\n"));
    return 0;
  }

       if (do_display)
  printf (gettext ("  [%3d] Signature:  0x%s  Sections: "),
   i, dwarf_vmatoa64 (signature_high, signature_low,
        buf, sizeof (buf)));
       for (;;)
  {
    if (shndx_list >= limit)
      {
        warn (gettext ("Section %s too small for shndx pool\n"),
       section->name);
        return 0;
      }
    do { unsigned int amount = (4); if (sizeof (shndx) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (shndx)); amount = sizeof (shndx); } if (((shndx_list) + amount) >= (limit)) { if ((shndx_list) < (limit)) amount = (limit) - (shndx_list); else amount = 0; } if (amount == 0 || amount > 8) shndx = 0; else shndx = byte_get ((shndx_list), amount); } while (0);
    if (shndx == 0)
      break;
    if (do_display)
      printf (" %d", shndx);
    else
      add_shndx_to_cu_tu_entry (shndx);
    shndx_list += 4;
  }
       if (do_display)
  printf ("\n");
       else
  end_cu_tu_entry ();
     }
   phash += 8;
   pindex += 4;
 }
    }
  else if (version == 2)
    {
      unsigned int val;
      unsigned int dw_sect;
      unsigned char *ph = phash;
      unsigned char *pi = pindex;
      unsigned char *poffsets = ppool + ncols * 4;
      unsigned char *psizes = poffsets + nused * ncols * 4;
      unsigned char *pend = psizes + nused * ncols * 4;
      bfd_boolean is_tu_index;
      struct cu_tu_set *this_set = 
# 7203 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                  ((void *)0)
# 7203 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                      ;
      unsigned int row;
      unsigned char *prow;

      is_tu_index = strcmp (section->name, ".debug_tu_index") == 0;



      if (poffsets < ppool || (unsigned int) ((poffsets - ppool) / 4) != ncols)
 {
   warn (gettext ("Overlarge number of columns: %x\n"), ncols);
   return 0;
 }

      if (pend > limit)
 {
   warn (gettext ("Section %s too small for offset and size tables\n"),
  section->name);
   return 0;
 }

      if (do_display)
 {
   printf (gettext ("  Offset table\n"));
   printf ("  slot  %-16s  ",
   is_tu_index ? gettext ("signature") : gettext ("dwo_id"));
 }
      else
 {
   if (is_tu_index)
     {
       tu_count = nused;
       tu_sets = xcalloc2 (nused, sizeof (struct cu_tu_set));
       this_set = tu_sets;
     }
   else
     {
       cu_count = nused;
       cu_sets = xcalloc2 (nused, sizeof (struct cu_tu_set));
       this_set = cu_sets;
     }
 }

      if (do_display)
 {
   for (j = 0; j < ncols; j++)
     {
       do { unsigned int amount = (4); if (sizeof (dw_sect) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (dw_sect)); amount = sizeof (dw_sect); } if (((ppool + j * 4) + amount) >= (limit)) { if ((ppool + j * 4) < (limit)) amount = (limit) - (ppool + j * 4); else amount = 0; } if (amount == 0 || amount > 8) dw_sect = 0; else dw_sect = byte_get ((ppool + j * 4), amount); } while (0);
       printf (" %8s", get_DW_SECT_short_name (dw_sect));
     }
   printf ("\n");
 }

      for (i = 0; i < nslots; i++)
 {
   do { if (((ph) + 8) <= (limit)) { byte_get_64 ((ph), (&signature_high), (&signature_low)); } else { * (&signature_low) = * (&signature_high) = 0; } } while (0);

   do { unsigned int amount = (4); if (sizeof (row) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (row)); amount = sizeof (row); } if (((pi) + amount) >= (limit)) { if ((pi) < (limit)) amount = (limit) - (pi); else amount = 0; } if (amount == 0 || amount > 8) row = 0; else row = byte_get ((pi), amount); } while (0);
   if (row != 0)
     {

       if (row > nused)
  {
    warn (gettext ("Row index (%u) is larger than number of used entries (%u)\n"),
   row, nused);
    return 0;
  }

       if (!do_display)
  memcpy (&this_set[row - 1].signature, ph, sizeof (uint64_t));

       prow = poffsets + (row - 1) * ncols * 4;

       if (prow < poffsets || prow > limit)
  {
    warn (gettext ("Row index (%u) * num columns (%u) > space remaining in section\n"),
   row, ncols);
    return 0;
  }

       if (do_display)
  printf (gettext ("  [%3d] 0x%s"),
   i, dwarf_vmatoa64 (signature_high, signature_low,
        buf, sizeof (buf)));
       for (j = 0; j < ncols; j++)
  {
    do { unsigned int amount = (4); if (sizeof (val) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (val)); amount = sizeof (val); } if (((prow + j * 4) + amount) >= (limit)) { if ((prow + j * 4) < (limit)) amount = (limit) - (prow + j * 4); else amount = 0; } if (amount == 0 || amount > 8) val = 0; else val = byte_get ((prow + j * 4), amount); } while (0);
    if (do_display)
      printf (" %8d", val);
    else
      {
        do { unsigned int amount = (4); if (sizeof (dw_sect) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (dw_sect)); amount = sizeof (dw_sect); } if (((ppool + j * 4) + amount) >= (limit)) { if ((ppool + j * 4) < (limit)) amount = (limit) - (ppool + j * 4); else amount = 0; } if (amount == 0 || amount > 8) dw_sect = 0; else dw_sect = byte_get ((ppool + j * 4), amount); } while (0);


        if (dw_sect >= DW_SECT_MAX)
   warn (gettext ("Overlarge Dwarf section index detected: %u\n"), dw_sect);
        else
   this_set [row - 1].section_offsets [dw_sect] = val;
      }
  }

       if (do_display)
  printf ("\n");
     }
   ph += 8;
   pi += 4;
 }

      ph = phash;
      pi = pindex;
      if (do_display)
 {
   printf ("\n");
   printf (gettext ("  Size table\n"));
   printf ("  slot  %-16s  ",
   is_tu_index ? gettext ("signature") : gettext ("dwo_id"));
 }

      for (j = 0; j < ncols; j++)
 {
   do { unsigned int amount = (4); if (sizeof (val) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (val)); amount = sizeof (val); } if (((ppool + j * 4) + amount) >= (limit)) { if ((ppool + j * 4) < (limit)) amount = (limit) - (ppool + j * 4); else amount = 0; } if (amount == 0 || amount > 8) val = 0; else val = byte_get ((ppool + j * 4), amount); } while (0);
   if (do_display)
     printf (" %8s", get_DW_SECT_short_name (val));
 }

      if (do_display)
 printf ("\n");

      for (i = 0; i < nslots; i++)
 {
   do { if (((ph) + 8) <= (limit)) { byte_get_64 ((ph), (&signature_high), (&signature_low)); } else { * (&signature_low) = * (&signature_high) = 0; } } while (0);

   do { unsigned int amount = (4); if (sizeof (row) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (row)); amount = sizeof (row); } if (((pi) + amount) >= (limit)) { if ((pi) < (limit)) amount = (limit) - (pi); else amount = 0; } if (amount == 0 || amount > 8) row = 0; else row = byte_get ((pi), amount); } while (0);
   if (row != 0)
     {
       prow = psizes + (row - 1) * ncols * 4;

       if (do_display)
  printf (gettext ("  [%3d] 0x%s"),
   i, dwarf_vmatoa64 (signature_high, signature_low,
        buf, sizeof (buf)));

       for (j = 0; j < ncols; j++)
  {
    do { unsigned int amount = (4); if (sizeof (val) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (val)); amount = sizeof (val); } if (((prow + j * 4) + amount) >= (limit)) { if ((prow + j * 4) < (limit)) amount = (limit) - (prow + j * 4); else amount = 0; } if (amount == 0 || amount > 8) val = 0; else val = byte_get ((prow + j * 4), amount); } while (0);
    if (do_display)
      printf (" %8d", val);
    else
      {
        do { unsigned int amount = (4); if (sizeof (dw_sect) < amount) { error (gettext ("internal error: attempt to read %d bytes of data in to %d sized variable"), amount, (int) sizeof (dw_sect)); amount = sizeof (dw_sect); } if (((ppool + j * 4) + amount) >= (limit)) { if ((ppool + j * 4) < (limit)) amount = (limit) - (ppool + j * 4); else amount = 0; } if (amount == 0 || amount > 8) dw_sect = 0; else dw_sect = byte_get ((ppool + j * 4), amount); } while (0);
        if (dw_sect >= DW_SECT_MAX)
   warn (gettext ("Overlarge Dwarf section index detected: %u\n"), dw_sect);
        else
        this_set [row - 1].section_sizes [dw_sect] = val;
      }
  }

       if (do_display)
  printf ("\n");
     }

   ph += 8;
   pi += 4;
 }
    }
  else if (do_display)
    printf (gettext ("  Unsupported version (%d)\n"), version);

  if (do_display)
      printf ("\n");

  return 1;
}





static void
load_cu_tu_indexes (void *file)
{


  if (cu_tu_indexes_read)
    return;

  if (load_debug_section (dwp_cu_index, file))
    process_cu_tu_index (&debug_displays [dwp_cu_index].section, 0);

  if (load_debug_section (dwp_tu_index, file))
    process_cu_tu_index (&debug_displays [dwp_tu_index].section, 0);

  cu_tu_indexes_read = 1;
}



unsigned int *
find_cu_tu_set (void *file, unsigned int shndx)
{
  unsigned int i;

  load_cu_tu_indexes (file);


  for (i = 0; i < shndx_pool_used; i++)
    if (shndx_pool [i] == shndx)
      break;

  if (i >= shndx_pool_used)
    return 
# 7413 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 7413 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;


  while (i > 0 && shndx_pool [i - 1] != 0)
    i--;

  return shndx_pool + i;
}



static int
display_cu_index (struct dwarf_section *section, void *file __attribute__ ((__unused__)))
{
  return process_cu_tu_index (section, 1);
}

static int
display_debug_not_supported (struct dwarf_section *section,
        void *file __attribute__ ((__unused__)))
{
  printf (gettext ("Displaying the debug contents of section %s is not yet supported.\n"),
     section->name);

  return 1;
}




void *
cmalloc (size_t nmemb, size_t size)
{

  if (nmemb >= ~(size_t) 0 / size)
    return 
# 7448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
          ((void *)0)
# 7448 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
              ;

  return xmalloc (nmemb * size);
}




void *
xcmalloc (size_t nmemb, size_t size)
{

  if (nmemb >= ~(size_t) 0 / size)
    {
      fprintf (
# 7462 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
              stderr
# 7462 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                    ,
        gettext ("Attempt to allocate an array with an excessive number of elements: 0x%lx\n"),
        (long) nmemb);
      xexit (1);
    }

  return xmalloc (nmemb * size);
}




void *
xcrealloc (void *ptr, size_t nmemb, size_t size)
{

  if (nmemb >= ~(size_t) 0 / size)
    {
      fprintf (
# 7480 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
              stderr
# 7480 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                    ,
        gettext ("Attempt to re-allocate an array with an excessive number of elements: 0x%lx\n"),
        (long) nmemb);
      xexit (1);
    }

  return xrealloc (ptr, nmemb * size);
}


void *
xcalloc2 (size_t nmemb, size_t size)
{

  if (nmemb >= ~(size_t) 0 / size)
    {
      fprintf (
# 7496 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
              stderr
# 7496 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                    ,
        gettext ("Attempt to allocate a zero'ed array with an excessive number of elements: 0x%lx\n"),
        (long) nmemb);
      xexit (1);
    }

  return xcalloc (nmemb, size);
}

void
free_debug_memory (void)
{
  unsigned int i;

  free_abbrevs ();

  for (i = 0; i < max; i++)
    free_debug_section ((enum dwarf_section_display_enum) i);

  if (debug_information != 
# 7515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                          ((void *)0)
# 7515 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                              )
    {
      if (num_debug_info_entries != (unsigned int) -1)
 {
   for (i = 0; i < num_debug_info_entries; i++)
     {
       if (!debug_information [i].max_loc_offsets)
  {
    free (debug_information [i].loc_offsets);
    free (debug_information [i].have_frame_base);
  }
       if (!debug_information [i].max_range_lists)
  free (debug_information [i].range_lists);
     }
 }
      free (debug_information);
      debug_information = 
# 7531 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                         ((void *)0)
# 7531 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                             ;
      alloc_num_debug_info_entries = num_debug_info_entries = 0;
    }
}

void
dwarf_select_sections_by_names (const char *names)
{
  typedef struct
  {
    const char * option;
    int * variable;
    int val;
  }
  debug_dump_long_opts;

  static const debug_dump_long_opts opts_table [] =
    {

      { "Ranges", & do_debug_ranges, 1 },
      { "abbrev", & do_debug_abbrevs, 1 },
      { "addr", & do_debug_addr, 1 },
      { "aranges", & do_debug_aranges, 1 },
      { "cu_index", & do_debug_cu_index, 1 },
      { "decodedline", & do_debug_lines, 2 },
      { "frames", & do_debug_frames, 1 },
      { "frames-interp", & do_debug_frames_interp, 1 },

      { "gdb_index", & do_gdb_index, 1 },
      { "info", & do_debug_info, 1 },
      { "line", & do_debug_lines, 1 },
      { "loc", & do_debug_loc, 1 },
      { "macro", & do_debug_macinfo, 1 },
      { "pubnames", & do_debug_pubnames, 1 },
      { "pubtypes", & do_debug_pubtypes, 1 },


      { "ranges", & do_debug_aranges, 1 },
      { "rawline", & do_debug_lines, 1 },
      { "str", & do_debug_str, 1 },

      { "trace_abbrev", & do_trace_abbrevs, 1 },
      { "trace_aranges", & do_trace_aranges, 1 },
      { "trace_info", & do_trace_info, 1 },
      { 
# 7575 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
       ((void *)0)
# 7575 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
           , 
# 7575 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
             ((void *)0)
# 7575 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                 , 0 }
    };

  const char *p;

  p = names;
  while (*p)
    {
      const debug_dump_long_opts * entry;

      for (entry = opts_table; entry->option; entry++)
 {
   size_t len = strlen (entry->option);

   if (strncmp (p, entry->option, len) == 0
       && (p[len] == ',' || p[len] == '\0'))
     {
       * entry->variable |= entry->val;



       if (do_debug_frames_interp)
  do_debug_frames = 1;

       p += len;
       break;
     }
 }

      if (entry->option == 
# 7604 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                          ((void *)0)
# 7604 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                              )
 {
   warn (gettext ("Unrecognized debug option '%s'\n"), p);
   p = strchr (p, ',');
   if (p == 
# 7608 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
           ((void *)0)
# 7608 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
               )
     break;
 }

      if (*p == ',')
 p++;
    }
}

void
dwarf_select_sections_by_letters (const char *letters)
{
  unsigned int lindex = 0;

  while (letters[lindex])
    switch (letters[lindex++])
      {
      case 'i':
 do_debug_info = 1;
 break;

      case 'a':
 do_debug_abbrevs = 1;
 break;

      case 'l':
 do_debug_lines |= 1;
 break;

      case 'L':
 do_debug_lines |= 2;
 break;

      case 'p':
 do_debug_pubnames = 1;
 break;

      case 't':
 do_debug_pubtypes = 1;
 break;

      case 'r':
 do_debug_aranges = 1;
 break;

      case 'R':
 do_debug_ranges = 1;
 break;

      case 'F':
 do_debug_frames_interp = 1;

      case 'f':
 do_debug_frames = 1;
 break;

      case 'm':
 do_debug_macinfo = 1;
 break;

      case 's':
 do_debug_str = 1;
 break;

      case 'o':
 do_debug_loc = 1;
 break;

      default:
 warn (gettext ("Unrecognized debug option '%s'\n"), letters);
 break;
      }
}

void
dwarf_select_sections_all (void)
{
  do_debug_info = 1;
  do_debug_abbrevs = 1;
  do_debug_lines = 1;
  do_debug_pubnames = 1;
  do_debug_pubtypes = 1;
  do_debug_aranges = 1;
  do_debug_ranges = 1;
  do_debug_frames = 1;
  do_debug_macinfo = 1;
  do_debug_str = 1;
  do_debug_loc = 1;
  do_gdb_index = 1;
  do_trace_info = 1;
  do_trace_abbrevs = 1;
  do_trace_aranges = 1;
  do_debug_addr = 1;
  do_debug_cu_index = 1;
}

struct dwarf_section_display debug_displays[] =
{
  { { ".debug_abbrev", ".zdebug_abbrev", 
# 7706 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 7706 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 
# 7706 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 7706 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      , 0, 0, 0, 
# 7706 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                 ((void *)0)
# 7706 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                     , 0, 
# 7706 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                          ((void *)0) 
# 7706 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                               },
    display_debug_abbrev, &do_debug_abbrevs, 0 },
  { { ".debug_aranges", ".zdebug_aranges", 
# 7708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                              ((void *)0)
# 7708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                  , 
# 7708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                    ((void *)0)
# 7708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                        , 0, 0, 0, 
# 7708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                   ((void *)0)
# 7708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                       , 0, 
# 7708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                            ((void *)0) 
# 7708 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                 },
    display_debug_aranges, &do_debug_aranges, 1 },
  { { ".debug_frame", ".zdebug_frame", 
# 7710 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 7710 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 
# 7710 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 7710 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      , 0, 0, 0, 
# 7710 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                 ((void *)0)
# 7710 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                     , 0, 
# 7710 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                          ((void *)0) 
# 7710 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                               },
    display_debug_frames, &do_debug_frames, 1 },
  { { ".debug_info", ".zdebug_info", 
# 7712 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                        ((void *)0)
# 7712 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                            , 
# 7712 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                              ((void *)0)
# 7712 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                  , 0, 0, abbrev, 
# 7712 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                  ((void *)0)
# 7712 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                      , 0, 
# 7712 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                           ((void *)0) 
# 7712 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                },
    display_debug_info, &do_debug_info, 1 },
  { { ".debug_line", ".zdebug_line", 
# 7714 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                        ((void *)0)
# 7714 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                            , 
# 7714 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                              ((void *)0)
# 7714 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                  , 0, 0, 0, 
# 7714 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                             ((void *)0)
# 7714 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                 , 0, 
# 7714 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                      ((void *)0) 
# 7714 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                           },
    display_debug_lines, &do_debug_lines, 1 },
  { { ".debug_pubnames", ".zdebug_pubnames", 
# 7716 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                               ((void *)0)
# 7716 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                   , 
# 7716 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                     ((void *)0)
# 7716 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                         , 0, 0, 0, 
# 7716 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                    ((void *)0)
# 7716 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                        , 0, 
# 7716 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                             ((void *)0) 
# 7716 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                  },
    display_debug_pubnames, &do_debug_pubnames, 0 },
  { { ".debug_gnu_pubnames", ".zdebug_gnu_pubnames", 
# 7718 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                    ((void *)0)
# 7718 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                        , 
# 7718 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                          ((void *)0)
# 7718 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                              , 0, 0, 0, 
# 7718 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                         ((void *)0)
# 7718 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                             , 0, 
# 7718 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                                  ((void *)0) 
# 7718 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                       },
    display_debug_gnu_pubnames, &do_debug_pubnames, 0 },
  { { ".eh_frame", "", 
# 7720 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                            ((void *)0)
# 7720 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                , 
# 7720 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                  ((void *)0)
# 7720 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                      , 0, 0, 0, 
# 7720 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                 ((void *)0)
# 7720 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                     , 0, 
# 7720 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                          ((void *)0) 
# 7720 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                               },
    display_debug_frames, &do_debug_frames, 1 },
  { { ".debug_macinfo", ".zdebug_macinfo", 
# 7722 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                              ((void *)0)
# 7722 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                  , 
# 7722 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                    ((void *)0)
# 7722 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                        , 0, 0, 0, 
# 7722 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                   ((void *)0)
# 7722 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                       , 0, 
# 7722 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                            ((void *)0) 
# 7722 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                 },
    display_debug_macinfo, &do_debug_macinfo, 0 },
  { { ".debug_macro", ".zdebug_macro", 
# 7724 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                          ((void *)0)
# 7724 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                              , 
# 7724 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                ((void *)0)
# 7724 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                    , 0, 0, 0, 
# 7724 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                               ((void *)0)
# 7724 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                   , 0, 
# 7724 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                        ((void *)0) 
# 7724 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                             },
    display_debug_macro, &do_debug_macinfo, 1 },
  { { ".debug_str", ".zdebug_str", 
# 7726 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                      ((void *)0)
# 7726 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                          , 
# 7726 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 7726 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 0, 0, 0, 
# 7726 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                           ((void *)0)
# 7726 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                               , 0, 
# 7726 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                    ((void *)0) 
# 7726 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                         },
    display_debug_str, &do_debug_str, 0 },
  { { ".debug_loc", ".zdebug_loc", 
# 7728 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                      ((void *)0)
# 7728 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                          , 
# 7728 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 7728 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 0, 0, 0, 
# 7728 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                           ((void *)0)
# 7728 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                               , 0, 
# 7728 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                    ((void *)0) 
# 7728 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                         },
    display_debug_loc, &do_debug_loc, 1 },
  { { ".debug_pubtypes", ".zdebug_pubtypes", 
# 7730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                               ((void *)0)
# 7730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                   , 
# 7730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                     ((void *)0)
# 7730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                         , 0, 0, 0, 
# 7730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                    ((void *)0)
# 7730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                        , 0, 
# 7730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                             ((void *)0) 
# 7730 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                  },
    display_debug_pubnames, &do_debug_pubtypes, 0 },
  { { ".debug_gnu_pubtypes", ".zdebug_gnu_pubtypes", 
# 7732 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                    ((void *)0)
# 7732 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                        , 
# 7732 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                          ((void *)0)
# 7732 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                              , 0, 0, 0, 
# 7732 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                         ((void *)0)
# 7732 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                             , 0, 
# 7732 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                                  ((void *)0) 
# 7732 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                       },
    display_debug_gnu_pubnames, &do_debug_pubtypes, 0 },
  { { ".debug_ranges", ".zdebug_ranges", 
# 7734 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 7734 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 
# 7734 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 7734 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      , 0, 0, 0, 
# 7734 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                 ((void *)0)
# 7734 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                     , 0, 
# 7734 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                          ((void *)0) 
# 7734 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                               },
    display_debug_ranges, &do_debug_ranges, 1 },
  { { ".debug_static_func", ".zdebug_static_func", 
# 7736 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 7736 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      , 
# 7736 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                        ((void *)0)
# 7736 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                            , 0, 0, 0, 
# 7736 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                       ((void *)0)
# 7736 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                           , 0, 
# 7736 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                                ((void *)0) 
# 7736 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                     },
    display_debug_not_supported, 
# 7737 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                ((void *)0)
# 7737 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                    , 0 },
  { { ".debug_static_vars", ".zdebug_static_vars", 
# 7738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 7738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      , 
# 7738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                        ((void *)0)
# 7738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                            , 0, 0, 0, 
# 7738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                       ((void *)0)
# 7738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                           , 0, 
# 7738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                                ((void *)0) 
# 7738 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                     },
    display_debug_not_supported, 
# 7739 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                ((void *)0)
# 7739 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                    , 0 },
  { { ".debug_types", ".zdebug_types", 
# 7740 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                          ((void *)0)
# 7740 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                              , 
# 7740 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                ((void *)0)
# 7740 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                    , 0, 0, abbrev, 
# 7740 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                    ((void *)0)
# 7740 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                        , 0, 
# 7740 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                             ((void *)0) 
# 7740 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                  },
    display_debug_types, &do_debug_info, 1 },
  { { ".debug_weaknames", ".zdebug_weaknames", 
# 7742 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                ((void *)0)
# 7742 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                    , 
# 7742 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                      ((void *)0)
# 7742 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                          , 0, 0, 0, 
# 7742 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                     ((void *)0)
# 7742 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                         , 0, 
# 7742 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                              ((void *)0) 
# 7742 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                   },
    display_debug_not_supported, 
# 7743 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                ((void *)0)
# 7743 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                    , 0 },
  { { ".gdb_index", "", 
# 7744 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                             ((void *)0)
# 7744 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                 , 
# 7744 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                   ((void *)0)
# 7744 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                       , 0, 0, 0, 
# 7744 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 7744 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      , 0, 
# 7744 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                           ((void *)0) 
# 7744 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                },
    display_gdb_index, &do_gdb_index, 0 },
  { { ".trace_info", "", 
# 7746 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 7746 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  , 
# 7746 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                    ((void *)0)
# 7746 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                        , 0, 0, trace_abbrev, 
# 7746 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                              ((void *)0)
# 7746 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                  , 0, 
# 7746 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                       ((void *)0) 
# 7746 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                            },
    display_trace_info, &do_trace_info, 1 },
  { { ".trace_abbrev", "", 
# 7748 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                ((void *)0)
# 7748 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                    , 
# 7748 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                      ((void *)0)
# 7748 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                          , 0, 0, 0, 
# 7748 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                     ((void *)0)
# 7748 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                         , 0, 
# 7748 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                              ((void *)0) 
# 7748 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                   },
    display_debug_abbrev, &do_trace_abbrevs, 0 },
  { { ".trace_aranges", "", 
# 7750 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                 ((void *)0)
# 7750 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                     , 
# 7750 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                       ((void *)0)
# 7750 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                           , 0, 0, 0, 
# 7750 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                      ((void *)0)
# 7750 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                          , 0, 
# 7750 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                               ((void *)0) 
# 7750 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                    },
    display_debug_aranges, &do_trace_aranges, 0 },
  { { ".debug_info.dwo", ".zdebug_info.dwo", 
# 7752 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                               ((void *)0)
# 7752 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                   , 
# 7752 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                     ((void *)0)
# 7752 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                         , 0, 0, abbrev_dwo, 
# 7752 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                             ((void *)0)
# 7752 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                 , 0, 
# 7752 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                                      ((void *)0) 
# 7752 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                           },
    display_debug_info, &do_debug_info, 1 },
  { { ".debug_abbrev.dwo", ".zdebug_abbrev.dwo", 
# 7754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                 ((void *)0)
# 7754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                     , 
# 7754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                       ((void *)0)
# 7754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                           , 0, 0, 0, 
# 7754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                      ((void *)0)
# 7754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                          , 0, 
# 7754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                               ((void *)0) 
# 7754 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                    },
    display_debug_abbrev, &do_debug_abbrevs, 0 },
  { { ".debug_types.dwo", ".zdebug_types.dwo", 
# 7756 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                ((void *)0)
# 7756 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                    , 
# 7756 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                      ((void *)0)
# 7756 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                          , 0, 0, abbrev_dwo, 
# 7756 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                              ((void *)0)
# 7756 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                  , 0, 
# 7756 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                                       ((void *)0) 
# 7756 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                            },
    display_debug_types, &do_debug_info, 1 },
  { { ".debug_line.dwo", ".zdebug_line.dwo", 
# 7758 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                               ((void *)0)
# 7758 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                   , 
# 7758 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                     ((void *)0)
# 7758 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                         , 0, 0, 0, 
# 7758 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                    ((void *)0)
# 7758 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                        , 0, 
# 7758 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                             ((void *)0) 
# 7758 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                  },
    display_debug_lines, &do_debug_lines, 1 },
  { { ".debug_loc.dwo", ".zdebug_loc.dwo", 
# 7760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                              ((void *)0)
# 7760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                  , 
# 7760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                    ((void *)0)
# 7760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                        , 0, 0, 0, 
# 7760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                   ((void *)0)
# 7760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                       , 0, 
# 7760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                            ((void *)0) 
# 7760 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                 },
    display_debug_loc, &do_debug_loc, 1 },
  { { ".debug_macro.dwo", ".zdebug_macro.dwo", 
# 7762 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                ((void *)0)
# 7762 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                    , 
# 7762 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                      ((void *)0)
# 7762 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                          , 0, 0, 0, 
# 7762 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                     ((void *)0)
# 7762 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                         , 0, 
# 7762 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                              ((void *)0) 
# 7762 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                   },
    display_debug_macro, &do_debug_macinfo, 1 },
  { { ".debug_macinfo.dwo", ".zdebug_macinfo.dwo", 
# 7764 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 7764 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      , 
# 7764 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                        ((void *)0)
# 7764 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                            , 0, 0, 0, 
# 7764 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                       ((void *)0)
# 7764 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                           , 0, 
# 7764 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                                ((void *)0) 
# 7764 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                     },
    display_debug_macinfo, &do_debug_macinfo, 0 },
  { { ".debug_str.dwo", ".zdebug_str.dwo", 
# 7766 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                               ((void *)0)
# 7766 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                   , 
# 7766 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                     ((void *)0)
# 7766 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                         , 0, 0, 0, 
# 7766 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                    ((void *)0)
# 7766 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                        , 0, 
# 7766 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                             ((void *)0) 
# 7766 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                  },
    display_debug_str, &do_debug_str, 1 },
  { { ".debug_str_offsets", ".zdebug_str_offsets", 
# 7768 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 7768 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      , 
# 7768 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                        ((void *)0)
# 7768 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                            , 0, 0, 0, 
# 7768 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                       ((void *)0)
# 7768 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                           , 0, 
# 7768 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                                ((void *)0) 
# 7768 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                     },
    display_debug_str_offsets, 
# 7769 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 7769 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  , 0 },
  { { ".debug_str_offsets.dwo", ".zdebug_str_offsets.dwo", 
# 7770 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                          ((void *)0)
# 7770 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                              , 
# 7770 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                ((void *)0)
# 7770 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                    , 0, 0, 0, 
# 7770 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                               ((void *)0)
# 7770 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                   , 0, 
# 7770 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                                        ((void *)0) 
# 7770 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                                             },
    display_debug_str_offsets, 
# 7771 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                              ((void *)0)
# 7771 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                  , 0 },
  { { ".debug_addr", ".zdebug_addr", 
# 7772 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                            ((void *)0)
# 7772 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                , 
# 7772 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                  ((void *)0)
# 7772 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                      , 0, 0, 0, 
# 7772 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                 ((void *)0)
# 7772 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                     , 0, 
# 7772 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                                          ((void *)0) 
# 7772 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                               },
    display_debug_addr, &do_debug_addr, 1 },
  { { ".debug_cu_index", "", 
# 7774 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                 ((void *)0)
# 7774 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                     , 
# 7774 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                       ((void *)0)
# 7774 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                           , 0, 0, 0, 
# 7774 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                      ((void *)0)
# 7774 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                          , 0, 
# 7774 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                               ((void *)0) 
# 7774 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                    },
    display_cu_index, &do_debug_cu_index, 0 },
  { { ".debug_tu_index", "", 
# 7776 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                 ((void *)0)
# 7776 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                     , 
# 7776 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                       ((void *)0)
# 7776 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                           , 0, 0, 0, 
# 7776 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                      ((void *)0)
# 7776 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                          , 0, 
# 7776 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c" 3 4
                                                               ((void *)0) 
# 7776 "/doner/binutils/binutils-53f7e8e/binutils/dwarf.c"
                                                                    },
    display_cu_index, &do_debug_cu_index, 0 },
};
