# 1 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
# 1 "/doner/binutils/binutils-7a31b38/bfd//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
# 37 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
# 1 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 1
# 29 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h"
# 1 "/doner/binutils/binutils-7a31b38/bfd/config.h" 1
# 30 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2

# 1 "./../include/ansidecl.h" 1
# 32 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4

# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;
# 35 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 873 "/usr/include/stdio.h" 3 4

# 38 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 39 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));


# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4



int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 5)));


# 39 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 447 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 534 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4

# 40 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2

# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4




# 42 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2





# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 104 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 115 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 154 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 266 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 360 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 499 "/usr/include/string.h" 3 4

# 48 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2
# 63 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 401 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1014 "/usr/include/stdlib.h" 2 3 4
# 1023 "/usr/include/stdlib.h" 3 4

# 64 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2



# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4

# 52 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };
# 66 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    void *__restrict __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;






extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 187 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4

# 68 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4




extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 69 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2
# 78 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 870 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 991 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1003 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1014 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1024 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1035 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1056 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1079 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1089 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1107 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1124 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1161 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;
# 1170 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));
# 1171 "/usr/include/unistd.h" 2 3 4


# 79 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2



# 1 "/usr/include/x86_64-linux-gnu/sys/resource.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/resource.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
enum __rlimit_resource
{

  RLIMIT_CPU = 0,



  RLIMIT_FSIZE = 1,



  RLIMIT_DATA = 2,



  RLIMIT_STACK = 3,



  RLIMIT_CORE = 4,






  __RLIMIT_RSS = 5,



  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,




  RLIMIT_AS = 9,



  __RLIMIT_NPROC = 6,



  __RLIMIT_MEMLOCK = 8,



  __RLIMIT_LOCKS = 10,



  __RLIMIT_SIGPENDING = 11,



  __RLIMIT_MSGQUEUE = 12,





  __RLIMIT_NICE = 13,




  __RLIMIT_RTPRIO = 14,





  __RLIMIT_RTTIME = 15,


  __RLIMIT_NLIMITS = 16,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS


};
# 131 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
typedef __rlim_t rlim_t;




typedef __rlim64_t rlim64_t;


struct rlimit
  {

    rlim_t rlim_cur;

    rlim_t rlim_max;
  };


struct rlimit64
  {

    rlim64_t rlim_cur;

    rlim64_t rlim_max;
 };



enum __rusage_who
{

  RUSAGE_SELF = 0,



  RUSAGE_CHILDREN = -1



  ,

  RUSAGE_THREAD = 1




};


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h" 3 4
struct rusage
  {

    struct timeval ru_utime;

    struct timeval ru_stime;

    __extension__ union
      {
 long int ru_maxrss;
 __syscall_slong_t __ru_maxrss_word;
      };


    __extension__ union
      {
 long int ru_ixrss;
 __syscall_slong_t __ru_ixrss_word;
      };

    __extension__ union
      {
 long int ru_idrss;
 __syscall_slong_t __ru_idrss_word;
      };

    __extension__ union
      {
 long int ru_isrss;
  __syscall_slong_t __ru_isrss_word;
      };


    __extension__ union
      {
 long int ru_minflt;
 __syscall_slong_t __ru_minflt_word;
      };

    __extension__ union
      {
 long int ru_majflt;
 __syscall_slong_t __ru_majflt_word;
      };

    __extension__ union
      {
 long int ru_nswap;
 __syscall_slong_t __ru_nswap_word;
      };


    __extension__ union
      {
 long int ru_inblock;
 __syscall_slong_t __ru_inblock_word;
      };

    __extension__ union
      {
 long int ru_oublock;
 __syscall_slong_t __ru_oublock_word;
      };

    __extension__ union
      {
 long int ru_msgsnd;
 __syscall_slong_t __ru_msgsnd_word;
      };

    __extension__ union
      {
 long int ru_msgrcv;
 __syscall_slong_t __ru_msgrcv_word;
      };

    __extension__ union
      {
 long int ru_nsignals;
 __syscall_slong_t __ru_nsignals_word;
      };



    __extension__ union
      {
 long int ru_nvcsw;
 __syscall_slong_t __ru_nvcsw_word;
      };


    __extension__ union
      {
 long int ru_nivcsw;
 __syscall_slong_t __ru_nivcsw_word;
      };
  };
# 180 "/usr/include/x86_64-linux-gnu/bits/resource.h" 2 3 4







enum __priority_which
{
  PRIO_PROCESS = 0,

  PRIO_PGRP = 1,

  PRIO_USER = 2

};







extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
      const struct rlimit *__new_limit,
      struct rlimit *__old_limit) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/x86_64-linux-gnu/bits/resource.h" 3 4
extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
        const struct rlimit64 *__new_limit,
        struct rlimit64 *__old_limit) __attribute__ ((__nothrow__ , __leaf__));




# 25 "/usr/include/x86_64-linux-gnu/sys/resource.h" 2 3 4













typedef enum __rlimit_resource __rlimit_resource_t;
typedef enum __rusage_who __rusage_who_t;
typedef enum __priority_which __priority_which_t;
# 50 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int getrlimit (__rlimit_resource_t __resource,
        struct rlimit *__rlimits) __attribute__ ((__nothrow__ , __leaf__));
# 61 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int getrlimit64 (__rlimit_resource_t __resource,
   struct rlimit64 *__rlimits) __attribute__ ((__nothrow__ , __leaf__));






extern int setrlimit (__rlimit_resource_t __resource,
        const struct rlimit *__rlimits) __attribute__ ((__nothrow__ , __leaf__));
# 81 "/usr/include/x86_64-linux-gnu/sys/resource.h" 3 4
extern int setrlimit64 (__rlimit_resource_t __resource,
   const struct rlimit64 *__rlimits) __attribute__ ((__nothrow__ , __leaf__));




extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __attribute__ ((__nothrow__ , __leaf__));





extern int getpriority (__priority_which_t __which, id_t __who) __attribute__ ((__nothrow__ , __leaf__));



extern int setpriority (__priority_which_t __which, id_t __who, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));


# 83 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2





# 1 "./../include/fopen-same.h" 1
# 89 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2



# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 353 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 392 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 447 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 148 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 168 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 178 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 293 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 304 "/usr/include/fcntl.h" 3 4

# 93 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2
# 119 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h"
# 1 "./../include/filenames.h" 1
# 29 "./../include/filenames.h"
# 1 "./../include/hashtab.h" 1
# 39 "./../include/hashtab.h"
# 1 "./../include/ansidecl.h" 1
# 40 "./../include/hashtab.h" 2



# 42 "./../include/hashtab.h"
typedef unsigned int hashval_t;




typedef hashval_t (*htab_hash) (const void *);






typedef int (*htab_eq) (const void *, const void *);



typedef void (*htab_del) (void *);





typedef int (*htab_trav) (void **, void *);





typedef void *(*htab_alloc) (size_t, size_t);


typedef void (*htab_free) (void *);



typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);
typedef void (*htab_free_with_arg) (void *, void *);
# 95 "./../include/hashtab.h"
struct htab {

  htab_hash hash_f;


  htab_eq eq_f;


  htab_del del_f;


  void **entries;


  size_t size;


  size_t n_elements;


  size_t n_deleted;



  unsigned int searches;



  unsigned int collisions;


  htab_alloc alloc_f;
  htab_free free_f;


  void *alloc_arg;
  htab_alloc_with_arg alloc_with_arg_f;
  htab_free_with_arg free_with_arg_f;



  unsigned int size_prime_index;
};

typedef struct htab *htab_t;


enum insert_option {NO_INSERT, INSERT};



extern htab_t htab_create_alloc (size_t, htab_hash,
                                    htab_eq, htab_del,
                                    htab_alloc, htab_free);

extern htab_t htab_create_alloc_ex (size_t, htab_hash,
                                      htab_eq, htab_del,
                                      void *, htab_alloc_with_arg,
                                      htab_free_with_arg);

extern htab_t htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,
     htab_alloc, htab_alloc, htab_free);


extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);
extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);

extern void htab_set_functions_ex (htab_t, htab_hash,
                                       htab_eq, htab_del,
                                       void *, htab_alloc_with_arg,
                                       htab_free_with_arg);

extern void htab_delete (htab_t);
extern void htab_empty (htab_t);

extern void * htab_find (htab_t, const void *);
extern void ** htab_find_slot (htab_t, const void *, enum insert_option);
extern void * htab_find_with_hash (htab_t, const void *, hashval_t);
extern void ** htab_find_slot_with_hash (htab_t, const void *,
       hashval_t, enum insert_option);
extern void htab_clear_slot (htab_t, void **);
extern void htab_remove_elt (htab_t, void *);
extern void htab_remove_elt_with_hash (htab_t, void *, hashval_t);

extern void htab_traverse (htab_t, htab_trav, void *);
extern void htab_traverse_noresize (htab_t, htab_trav, void *);

extern size_t htab_size (htab_t);
extern size_t htab_elements (htab_t);
extern double htab_collisions (htab_t);


extern htab_hash htab_hash_pointer;


extern htab_eq htab_eq_pointer;


extern hashval_t htab_hash_string (const void *);


extern hashval_t iterative_hash (const void *, size_t, hashval_t);
# 30 "./../include/filenames.h" 2
# 83 "./../include/filenames.h"
extern int filename_cmp (const char *s1, const char *s2);


extern int filename_ncmp (const char *s1, const char *s2,
     size_t n);

extern hashval_t filename_hash (const void *s);

extern int filename_eq (const void *s1, const void *s2);

extern int canonical_filename_eq (const char *a, const char *b);
# 120 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2
# 184 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h"
# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4






# 39 "/usr/include/libintl.h" 3 4
extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/libintl.h" 3 4

# 185 "/doner/binutils/binutils-7a31b38/bfd/sysdep.h" 2
# 38 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 2
# 1 "/doner/binutils/binutils-7a31b38/bfd/bfd.h" 1
# 43 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
# 1 "./../include/symcat.h" 1
# 44 "/doner/binutils/binutils-7a31b38/bfd/bfd.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 45 "/doner/binutils/binutils-7a31b38/bfd/bfd.h" 2
# 97 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"

# 97 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
typedef long bfd_int64_t;
typedef unsigned long bfd_uint64_t;
# 115 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
typedef unsigned long bfd_hostptr_t;


typedef struct bfd bfd;
# 129 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
typedef int bfd_boolean;
# 141 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
typedef unsigned long bfd_vma;
typedef long bfd_signed_vma;
typedef unsigned long bfd_size_type;
typedef unsigned long symvalue;
# 196 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
typedef long file_ptr;
typedef unsigned long ufile_ptr;

extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);




typedef unsigned int flagword;
typedef unsigned char bfd_byte;



typedef enum bfd_format
{
  bfd_unknown = 0,
  bfd_object,
  bfd_archive,
  bfd_core,
  bfd_type_end
}
bfd_format;




typedef unsigned long symindex;


typedef const struct reloc_howto_struct reloc_howto_type;
# 248 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
typedef struct carsym
{
  char *name;
  file_ptr file_offset;
}
carsym;



struct orl
{
  char **name;
  union
  {
    file_ptr pos;
    bfd *abfd;
  } u;
  int namidx;
};


typedef struct lineno_cache_entry
{
  unsigned int line_number;
  union
  {
    struct bfd_symbol *sym;
    bfd_vma offset;
  } u;
}
alent;


typedef struct bfd_section *sec_ptr;
# 326 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
typedef enum bfd_print_symbol
{
  bfd_print_symbol_name,
  bfd_print_symbol_more,
  bfd_print_symbol_all
} bfd_print_symbol_type;



typedef struct _symbol_info
{
  symvalue value;
  char type;
  const char *name;
  unsigned char stab_type;
  char stab_other;
  short stab_desc;
  const char *stab_name;
} symbol_info;



extern const char *bfd_get_stab_name (int);






struct bfd_hash_entry
{

  struct bfd_hash_entry *next;

  const char *string;


  unsigned long hash;
};



struct bfd_hash_table
{

  struct bfd_hash_entry **table;







  struct bfd_hash_entry *(*newfunc)
    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


  void *memory;

  unsigned int size;

  unsigned int count;

  unsigned int entsize;

  unsigned int frozen:1;
};


extern bfd_boolean bfd_hash_table_init
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int);


extern bfd_boolean bfd_hash_table_init_n
  (struct bfd_hash_table *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int, unsigned int);


extern void bfd_hash_table_free
  (struct bfd_hash_table *);





extern struct bfd_hash_entry *bfd_hash_lookup
  (struct bfd_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy);


extern struct bfd_hash_entry *bfd_hash_insert
  (struct bfd_hash_table *, const char *, unsigned long);


extern void bfd_hash_rename
  (struct bfd_hash_table *, const char *, struct bfd_hash_entry *);


extern void bfd_hash_replace
  (struct bfd_hash_table *, struct bfd_hash_entry *old,
   struct bfd_hash_entry *nw);


extern struct bfd_hash_entry *bfd_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


extern void *bfd_hash_allocate
  (struct bfd_hash_table *, unsigned int);




extern void bfd_hash_traverse
  (struct bfd_hash_table *,
   bfd_boolean (*) (struct bfd_hash_entry *, void *),
   void *info);




extern unsigned long bfd_hash_set_default_size (unsigned long);



enum compressed_debug_section_type
{
  COMPRESS_DEBUG_NONE = 0,
  COMPRESS_DEBUG = 1 << 0,
  COMPRESS_DEBUG_GNU_ZLIB = COMPRESS_DEBUG | 1 << 1,
  COMPRESS_DEBUG_GABI_ZLIB = COMPRESS_DEBUG | 1 << 2
};




struct stab_info
{

  struct bfd_strtab_hash *strings;

  struct bfd_hash_table includes;

  struct bfd_section *stabstr;
};
# 486 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
extern int bfd_seek (bfd *, file_ptr, int);
extern file_ptr bfd_tell (bfd *);
extern int bfd_flush (bfd *);
extern int bfd_stat (bfd *, struct stat *);
# 509 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
extern void _bfd_warn_deprecated (const char *, const char *, int, const char *);
# 545 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
extern bfd_boolean bfd_cache_close
  (bfd *abfd);


extern bfd_boolean bfd_cache_close_all (void);

extern bfd_boolean bfd_record_phdr
  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);



bfd_uint64_t bfd_getb64 (const void *);
bfd_uint64_t bfd_getl64 (const void *);
bfd_int64_t bfd_getb_signed_64 (const void *);
bfd_int64_t bfd_getl_signed_64 (const void *);
bfd_vma bfd_getb32 (const void *);
bfd_vma bfd_getl32 (const void *);
bfd_signed_vma bfd_getb_signed_32 (const void *);
bfd_signed_vma bfd_getl_signed_32 (const void *);
bfd_vma bfd_getb16 (const void *);
bfd_vma bfd_getl16 (const void *);
bfd_signed_vma bfd_getb_signed_16 (const void *);
bfd_signed_vma bfd_getl_signed_16 (const void *);
void bfd_putb64 (bfd_uint64_t, void *);
void bfd_putl64 (bfd_uint64_t, void *);
void bfd_putb32 (bfd_vma, void *);
void bfd_putl32 (bfd_vma, void *);
void bfd_putb16 (bfd_vma, void *);
void bfd_putl16 (bfd_vma, void *);



bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);


struct ecoff_debug_info;
struct ecoff_debug_swap;
struct ecoff_extr;
struct bfd_symbol;
struct bfd_link_info;
struct bfd_link_hash_entry;
struct bfd_section_already_linked;
struct bfd_elf_version_tree;


extern bfd_boolean bfd_section_already_linked_table_init (void);
extern void bfd_section_already_linked_table_free (void);
extern bfd_boolean _bfd_handle_already_linked
  (struct bfd_section *, struct bfd_section_already_linked *,
   struct bfd_link_info *);



extern bfd_vma bfd_ecoff_get_gp_value
  (bfd * abfd);
extern bfd_boolean bfd_ecoff_set_gp_value
  (bfd *abfd, bfd_vma gp_value);
extern bfd_boolean bfd_ecoff_set_regmasks
  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
   unsigned long *cprmask);
extern void *bfd_ecoff_debug_init
  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern void bfd_ecoff_debug_free
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct ecoff_debug_info *input_debug,
   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_accumulate_other
  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
   struct bfd_link_info *);
extern bfd_boolean bfd_ecoff_debug_externals
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
   void (*set_index) (struct bfd_symbol *, bfd_size_type));
extern bfd_boolean bfd_ecoff_debug_one_external
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, const char *name,
   struct ecoff_extr *esym);
extern bfd_size_type bfd_ecoff_debug_size
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap);
extern bfd_boolean bfd_ecoff_write_debug
  (bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap, file_ptr where);
extern bfd_boolean bfd_ecoff_write_accumulated_debug
  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
   const struct ecoff_debug_swap *swap,
   struct bfd_link_info *info, file_ptr where);



struct bfd_link_needed_list
{
  struct bfd_link_needed_list *next;
  bfd *by;
  const char *name;
};

enum dynamic_lib_link_class {
  DYN_NORMAL = 0,
  DYN_AS_NEEDED = 1,
  DYN_DT_NEEDED = 2,
  DYN_NO_ADD_NEEDED = 4,
  DYN_NO_NEEDED = 8
};

enum notice_asneeded_action {
  notice_as_needed,
  notice_not_needed,
  notice_needed
};

extern bfd_boolean bfd_elf_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
   bfd_boolean);
extern struct bfd_link_needed_list *bfd_elf_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_elf_get_bfd_needed_list
  (bfd *, struct bfd_link_needed_list **);
extern bfd_boolean bfd_elf_stack_segment_size (bfd *, struct bfd_link_info *,
            const char *, bfd_vma);
extern bfd_boolean bfd_elf_size_dynamic_sections
  (bfd *, const char *, const char *, const char *, const char *, const char *,
   const char * const *, struct bfd_link_info *, struct bfd_section **);
extern bfd_boolean bfd_elf_size_dynsym_hash_dynstr
  (bfd *, struct bfd_link_info *);
extern void bfd_elf_set_dt_needed_name
  (bfd *, const char *);
extern const char *bfd_elf_get_dt_soname
  (bfd *);
extern void bfd_elf_set_dyn_lib_class
  (bfd *, enum dynamic_lib_link_class);
extern int bfd_elf_get_dyn_lib_class
  (bfd *);
extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
  (bfd *, struct bfd_link_info *);
extern int bfd_elf_discard_info
  (bfd *, struct bfd_link_info *);
extern unsigned int _bfd_elf_default_action_discarded
  (struct bfd_section *);




extern long bfd_get_elf_phdr_upper_bound
  (bfd *abfd);
# 707 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
extern int bfd_get_elf_phdrs
  (bfd *abfd, void *phdrs);
# 724 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
extern bfd *bfd_elf_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr,
         bfd_size_type len));

extern struct bfd_section *_bfd_elf_tls_setup
  (bfd *, struct bfd_link_info *);

extern struct bfd_section *
_bfd_nearby_section (bfd *, struct bfd_section *, bfd_vma);

extern void _bfd_fix_excluded_sec_syms
  (bfd *, struct bfd_link_info *);

extern unsigned bfd_m68k_mach_to_features (int);

extern int bfd_m68k_features_to_mach (unsigned);

extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);

extern void bfd_elf_m68k_set_target_options (struct bfd_link_info *, int);

extern bfd_boolean bfd_bfin_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);

extern bfd_boolean bfd_cr16_elf32_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
   char **);



extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sunos_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_sunos_size_dynamic_sections
  (bfd *, struct bfd_link_info *, struct bfd_section **,
   struct bfd_section **, struct bfd_section **);



extern bfd_boolean bfd_i386linux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_m68klinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean bfd_sparclinux_size_dynamic_sections
  (bfd *, struct bfd_link_info *);



struct _bfd_window_internal;
typedef struct _bfd_window_internal bfd_window_internal;

typedef struct _bfd_window
{

  void *data;
  bfd_size_type size;






  struct _bfd_window_internal *i;
}
bfd_window;

extern void bfd_init_window
  (bfd_window *);
extern void bfd_free_window
  (bfd_window *);
extern bfd_boolean bfd_get_file_window
  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);



extern bfd_boolean bfd_xcoff_split_import_path
  (bfd *, const char *, const char **, const char **);
extern bfd_boolean bfd_xcoff_set_archive_import_path
  (struct bfd_link_info *, bfd *, const char *);
extern bfd_boolean bfd_xcoff_link_record_set
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
extern bfd_boolean bfd_xcoff_import_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
   const char *, const char *, const char *, unsigned int);
extern bfd_boolean bfd_xcoff_export_symbol
  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
extern bfd_boolean bfd_xcoff_link_count_reloc
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_record_link_assignment
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_xcoff_size_dynamic_sections
  (bfd *, struct bfd_link_info *, const char *, const char *,
   unsigned long, unsigned long, unsigned long, bfd_boolean,
   int, bfd_boolean, unsigned int, struct bfd_section **, bfd_boolean);
extern bfd_boolean bfd_xcoff_link_generate_rtinit
  (bfd *, const char *, const char *, bfd_boolean);


extern bfd_boolean bfd_xcoff_ar_archive_set_magic
  (bfd *, char *);




struct internal_syment;
union internal_auxent;


extern bfd_boolean bfd_coff_set_symbol_class
  (bfd *, struct bfd_symbol *, unsigned int);

extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);


typedef enum
{
  BFD_ARM_VFP11_FIX_DEFAULT,
  BFD_ARM_VFP11_FIX_NONE,
  BFD_ARM_VFP11_FIX_SCALAR,
  BFD_ARM_VFP11_FIX_VECTOR
} bfd_arm_vfp11_fix;

extern void bfd_elf32_arm_init_maps
  (bfd *);

extern void bfd_elf32_arm_set_vfp11_fix
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_set_cortex_a8_fix
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_vfp11_erratum_scan
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_vfp11_fix_veneer_locations
  (bfd *, struct bfd_link_info *);


typedef enum
{
  BFD_ARM_STM32L4XX_FIX_NONE,
  BFD_ARM_STM32L4XX_FIX_DEFAULT,
  BFD_ARM_STM32L4XX_FIX_ALL
} bfd_arm_stm32l4xx_fix;

extern void bfd_elf32_arm_set_stm32l4xx_fix
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_stm32l4xx_erratum_scan
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_stm32l4xx_fix_veneer_locations
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_arm_pe_process_before_allocation
  (bfd *, struct bfd_link_info *, int);

extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);


extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
  (struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_process_before_allocation
  (bfd *, struct bfd_link_info *);

struct elf32_arm_params {
  char *thumb_entry_symbol;
  int byteswap_code;
  int target1_is_rel;
  char * target2_type;
  int fix_v4bx;
  int use_blx;
  bfd_arm_vfp11_fix vfp11_denorm_fix;
  bfd_arm_stm32l4xx_fix stm32l4xx_fix;
  int no_enum_size_warning;
  int no_wchar_size_warning;
  int pic_veneer;
  int fix_cortex_a8;
  int fix_arm1176;
  int merge_exidx_entries;
  int cmse_implib;
  bfd *in_implib_bfd;
};

void bfd_elf32_arm_set_target_params
  (bfd *, struct bfd_link_info *, struct elf32_arm_params *);

extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
  (bfd *, struct bfd_link_info *);

extern void bfd_elf32_arm_keep_private_stub_output_sections
  (struct bfd_link_info *);







extern bfd_boolean bfd_is_arm_special_symbol_name
  (const char *, int);

extern void bfd_elf32_arm_set_byteswap_code
  (struct bfd_link_info *, int);

extern void bfd_elf32_arm_use_long_plt (void);


extern bfd_boolean bfd_arm_merge_machines
  (bfd *, bfd *);

extern bfd_boolean bfd_arm_update_notes
  (bfd *, const char *);

extern unsigned int bfd_arm_get_mach_from_notes
  (bfd *, const char *);


extern int elf32_arm_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf32_arm_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf32_arm_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *,
        struct bfd_section *, unsigned int),
   void (*) (void));
extern bfd_boolean elf32_arm_build_stubs
  (struct bfd_link_info *);


extern bfd_boolean elf32_arm_fix_exidx_coverage
(struct bfd_section **, unsigned int, struct bfd_link_info *, bfd_boolean);


extern bfd_boolean elf32_tic6x_fix_exidx_coverage
(struct bfd_section **, unsigned int, struct bfd_link_info *, bfd_boolean);

extern void bfd_elf64_aarch64_init_maps
  (bfd *);

extern void bfd_elf32_aarch64_init_maps
  (bfd *);

extern void bfd_elf64_aarch64_set_options
  (bfd *, struct bfd_link_info *, int, int, int, int, int, int);

extern void bfd_elf32_aarch64_set_options
  (bfd *, struct bfd_link_info *, int, int, int, int, int, int);






extern bfd_boolean bfd_is_aarch64_special_symbol_name
  (const char * name, int type);


extern int elf64_aarch64_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf64_aarch64_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf64_aarch64_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *),
   void (*) (void));
extern bfd_boolean elf64_aarch64_build_stubs
  (struct bfd_link_info *);

extern int elf32_aarch64_setup_section_lists
  (bfd *, struct bfd_link_info *);
extern void elf32_aarch64_next_input_section
  (struct bfd_link_info *, struct bfd_section *);
extern bfd_boolean elf32_aarch64_size_stubs
  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
   struct bfd_section * (*) (const char *, struct bfd_section *),
   void (*) (void));
extern bfd_boolean elf32_aarch64_build_stubs
  (struct bfd_link_info *);



extern void bfd_ticoff_set_section_load_page
  (struct bfd_section *, int);

extern int bfd_ticoff_get_section_load_page
  (struct bfd_section *);


extern bfd_vma bfd_h8300_pad_address
  (bfd *, bfd_vma);


extern void bfd_elf32_ia64_after_parse
  (int);

extern void bfd_elf64_ia64_after_parse
  (int);


extern bfd_boolean v850_elf_create_sections
  (struct bfd_link_info *);

extern bfd_boolean v850_elf_set_note
  (bfd *, unsigned int, unsigned int);


struct elf_internal_abiflags_v0;
extern struct elf_internal_abiflags_v0 *bfd_mips_elf_get_abiflags (bfd *);

void bfd_init (void);



extern unsigned int bfd_use_reserved_id;
bfd *bfd_fopen (const char *filename, const char *target,
    const char *mode, int fd);

bfd *bfd_openr (const char *filename, const char *target);

bfd *bfd_fdopenr (const char *filename, const char *target, int fd);

bfd *bfd_openstreamr (const char * filename, const char * target,
    void * stream);

bfd *bfd_openr_iovec (const char *filename, const char *target,
    void *(*open_func) (struct bfd *nbfd,
    void *open_closure),
    void *open_closure,
    file_ptr (*pread_func) (struct bfd *nbfd,
    void *stream,
    void *buf,
    file_ptr nbytes,
    file_ptr offset),
    int (*close_func) (struct bfd *nbfd,
    void *stream),
    int (*stat_func) (struct bfd *abfd,
    void *stream,
    struct stat *sb));

bfd *bfd_openw (const char *filename, const char *target);

bfd_boolean bfd_close (bfd *abfd);

bfd_boolean bfd_close_all_done (bfd *);

bfd *bfd_create (const char *filename, bfd *templ);

bfd_boolean bfd_make_writable (bfd *abfd);

bfd_boolean bfd_make_readable (bfd *abfd);

void *bfd_alloc (bfd *abfd, bfd_size_type wanted);

void *bfd_zalloc (bfd *abfd, bfd_size_type wanted);

unsigned long bfd_calc_gnu_debuglink_crc32
   (unsigned long crc, const unsigned char *buf, bfd_size_type len);

char *bfd_get_debug_link_info (bfd *abfd, unsigned long *crc32_out);

char *bfd_get_alt_debug_link_info (bfd * abfd,
    bfd_size_type *buildid_len,
    bfd_byte **buildid_out);

char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);

char *bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir);

struct bfd_section *bfd_create_gnu_debuglink_section
   (bfd *abfd, const char *filename);

bfd_boolean bfd_fill_in_gnu_debuglink_section
   (bfd *abfd, struct bfd_section *sect, const char *filename);

char *bfd_follow_build_id_debuglink (bfd *abfd, const char *dir);
# 1241 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
long bfd_get_mtime (bfd *abfd);

ufile_ptr bfd_get_size (bfd *abfd);

ufile_ptr bfd_get_file_size (bfd *abfd);

void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
    int prot, int flags, file_ptr offset,
    void **map_addr, bfd_size_type *map_len);




typedef struct bfd_section
{


  const char *name;


  unsigned int id;


  unsigned int index;


  struct bfd_section *next;


  struct bfd_section *prev;




  flagword flags;
# 1475 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  unsigned int user_set_vma : 1;


  unsigned int linker_mark : 1;



  unsigned int linker_has_input : 1;


  unsigned int gc_mark : 1;


  unsigned int compress_status : 2;







  unsigned int segment_mark : 1;


  unsigned int sec_info_type:3;
# 1509 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  unsigned int use_rela_p:1;




  unsigned int sec_flg0:1;
  unsigned int sec_flg1:1;
  unsigned int sec_flg2:1;
  unsigned int sec_flg3:1;
  unsigned int sec_flg4:1;
  unsigned int sec_flg5:1;
# 1529 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_vma vma;




  bfd_vma lma;




  bfd_size_type size;
# 1549 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_size_type rawsize;


  bfd_size_type compressed_size;


  struct relax_table *relax;


  int relax_count;
# 1568 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_vma output_offset;


  struct bfd_section *output_section;



  unsigned int alignment_power;



  struct reloc_cache_entry *relocation;



  struct reloc_cache_entry **orelocation;


  unsigned reloc_count;





  file_ptr filepos;


  file_ptr rel_filepos;


  file_ptr line_filepos;


  void *userdata;



  unsigned char *contents;


  alent *lineno;


  unsigned int lineno_count;


  unsigned int entsize;



  struct bfd_section *kept_section;



  file_ptr moving_line_filepos;


  int target_index;

  void *used_by_bfd;



  struct relent_chain *constructor_chain;


  bfd *owner;


  struct bfd_symbol *symbol;
  struct bfd_symbol **symbol_ptr_ptr;





  union {
    struct bfd_link_order *link_order;
    struct bfd_section *s;
  } map_head, map_tail;
} asection;




struct relax_table {

  bfd_vma addr;


  int size;
};





static inline bfd_boolean
bfd_set_section_userdata (bfd * abfd __attribute__ ((__unused__)), asection * ptr, void * val)
{
  ptr->userdata = val;
  return 1;
}

static inline bfd_boolean
bfd_set_section_vma (bfd * abfd __attribute__ ((__unused__)), asection * ptr, bfd_vma val)
{
  ptr->vma = ptr->lma = val;
  ptr->user_set_vma = 1;
  return 1;
}

static inline bfd_boolean
bfd_set_section_alignment (bfd * abfd __attribute__ ((__unused__)), asection * ptr, unsigned int val)
{
  ptr->alignment_power = val;
  return 1;
}




extern asection _bfd_std_section[4];
# 1856 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
void bfd_section_list_clear (bfd *);

asection *bfd_get_section_by_name (bfd *abfd, const char *name);

asection *bfd_get_next_section_by_name (bfd *ibfd, asection *sec);

asection *bfd_get_linker_section (bfd *abfd, const char *name);

asection *bfd_get_section_by_name_if
   (bfd *abfd,
    const char *name,
    bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

char *bfd_get_unique_section_name
   (bfd *abfd, const char *templat, int *count);

asection *bfd_make_section_old_way (bfd *abfd, const char *name);

asection *bfd_make_section_anyway_with_flags
   (bfd *abfd, const char *name, flagword flags);

asection *bfd_make_section_anyway (bfd *abfd, const char *name);

asection *bfd_make_section_with_flags
   (bfd *, const char *name, flagword flags);

asection *bfd_make_section (bfd *, const char *name);

int bfd_get_next_section_id (void);

bfd_boolean bfd_set_section_flags
   (bfd *abfd, asection *sec, flagword flags);

void bfd_rename_section
   (bfd *abfd, asection *sec, const char *newname);

void bfd_map_over_sections
   (bfd *abfd,
    void (*func) (bfd *abfd, asection *sect, void *obj),
    void *obj);

asection *bfd_sections_find_if
   (bfd *abfd,
    bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
    void *obj);

bfd_boolean bfd_set_section_size
   (bfd *abfd, asection *sec, bfd_size_type val);

bfd_boolean bfd_set_section_contents
   (bfd *abfd, asection *section, const void *data,
    file_ptr offset, bfd_size_type count);

bfd_boolean bfd_get_section_contents
   (bfd *abfd, asection *section, void *location, file_ptr offset,
    bfd_size_type count);

bfd_boolean bfd_malloc_and_get_section
   (bfd *abfd, asection *section, bfd_byte **buf);

bfd_boolean bfd_copy_private_section_data
   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);




bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);

bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);


enum bfd_architecture
{
  bfd_arch_unknown,
  bfd_arch_obscure,
  bfd_arch_m68k,
# 1964 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_vax,
  bfd_arch_i960,
# 1983 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_or1k,



  bfd_arch_sparc,
# 2025 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_spu,

  bfd_arch_mips,
# 2074 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_i386,
# 2083 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_l1om,


  bfd_arch_k1om,






  bfd_arch_iamcu,



  bfd_arch_we32k,
  bfd_arch_tahoe,
  bfd_arch_i860,
  bfd_arch_i370,
  bfd_arch_romp,
  bfd_arch_convex,
  bfd_arch_m88k,
  bfd_arch_m98k,
  bfd_arch_pyramid,
  bfd_arch_h8300,







  bfd_arch_pdp11,
  bfd_arch_plugin,
  bfd_arch_powerpc,
# 2143 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_rs6000,




  bfd_arch_hppa,




  bfd_arch_d10v,



  bfd_arch_d30v,
  bfd_arch_dlx,
  bfd_arch_m68hc11,
  bfd_arch_m68hc12,



  bfd_arch_m9s12x,
  bfd_arch_m9s12xg,
  bfd_arch_z8k,


  bfd_arch_h8500,
  bfd_arch_sh,
# 2192 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_alpha,



  bfd_arch_arm,
# 2211 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_nds32,





  bfd_arch_ns32k,
  bfd_arch_w65,
  bfd_arch_tic30,
  bfd_arch_tic4x,


  bfd_arch_tic54x,
  bfd_arch_tic6x,
  bfd_arch_tic80,
  bfd_arch_v850,
  bfd_arch_v850_rh850,






  bfd_arch_arc,






 bfd_arch_m32c,


  bfd_arch_m32r,



  bfd_arch_mn10200,
  bfd_arch_mn10300,



  bfd_arch_fr30,

  bfd_arch_frv,
# 2264 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_moxie,

  bfd_arch_ft32,

  bfd_arch_mcore,
  bfd_arch_mep,



  bfd_arch_metag,

  bfd_arch_ia64,


  bfd_arch_ip2k,


 bfd_arch_iq2000,


  bfd_arch_epiphany,


  bfd_arch_mt,



  bfd_arch_pj,
  bfd_arch_avr,
# 2311 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_bfin,

  bfd_arch_cr16,

  bfd_arch_cr16c,

  bfd_arch_crx,

  bfd_arch_cris,



  bfd_arch_riscv,


  bfd_arch_rl78,

  bfd_arch_rx,

  bfd_arch_s390,


  bfd_arch_score,


  bfd_arch_mmix,
  bfd_arch_xstormy16,

  bfd_arch_msp430,
# 2364 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_arch_xc16x,



  bfd_arch_xgate,

  bfd_arch_xtensa,

  bfd_arch_z80,




  bfd_arch_lm32,

  bfd_arch_microblaze,
  bfd_arch_tilepro,
  bfd_arch_tilegx,



  bfd_arch_aarch64,


  bfd_arch_nios2,



  bfd_arch_visium,

  bfd_arch_wasm32,

  bfd_arch_pru,

  bfd_arch_last
  };

typedef struct bfd_arch_info
{
  int bits_per_word;
  int bits_per_address;
  int bits_per_byte;
  enum bfd_architecture arch;
  unsigned long mach;
  const char *arch_name;
  const char *printable_name;
  unsigned int section_align_power;



  bfd_boolean the_default;
  const struct bfd_arch_info * (*compatible)
    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);

  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);




  void *(*fill) (bfd_size_type count, bfd_boolean is_bigendian,
                 bfd_boolean code);

  const struct bfd_arch_info *next;
}
bfd_arch_info_type;

const char *bfd_printable_name (bfd *abfd);

const bfd_arch_info_type *bfd_scan_arch (const char *string);

const char **bfd_arch_list (void);

const bfd_arch_info_type *bfd_arch_get_compatible
   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);

void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);

bfd_boolean bfd_default_set_arch_mach
   (bfd *abfd, enum bfd_architecture arch, unsigned long mach);

enum bfd_architecture bfd_get_arch (bfd *abfd);

unsigned long bfd_get_mach (bfd *abfd);

unsigned int bfd_arch_bits_per_byte (bfd *abfd);

unsigned int bfd_arch_bits_per_address (bfd *abfd);

const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);

const bfd_arch_info_type *bfd_lookup_arch
   (enum bfd_architecture arch, unsigned long machine);

const char *bfd_printable_arch_mach
   (enum bfd_architecture arch, unsigned long machine);

unsigned int bfd_octets_per_byte (bfd *abfd);

unsigned int bfd_arch_mach_octets_per_byte
   (enum bfd_architecture arch, unsigned long machine);



typedef enum bfd_reloc_status
{

  bfd_reloc_ok,


  bfd_reloc_overflow,


  bfd_reloc_outofrange,


  bfd_reloc_continue,


  bfd_reloc_notsupported,


  bfd_reloc_other,


  bfd_reloc_undefined,





  bfd_reloc_dangerous
 }
 bfd_reloc_status_type;


typedef struct reloc_cache_entry
{

  struct bfd_symbol **sym_ptr_ptr;


  bfd_size_type address;


  bfd_vma addend;


  reloc_howto_type *howto;

}
arelent;


enum complain_overflow
{

  complain_overflow_dont,




  complain_overflow_bitfield,



  complain_overflow_signed,



  complain_overflow_unsigned
};
struct bfd_symbol;

struct reloc_howto_struct
{






  unsigned int type;



  unsigned int rightshift;




  int size;



  unsigned int bitsize;


  bfd_boolean pc_relative;



  unsigned int bitpos;



  enum complain_overflow complain_on_overflow;





  bfd_reloc_status_type (*special_function)
    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
     bfd *, char **);


  char *name;
# 2597 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_boolean partial_inplace;
# 2607 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_vma src_mask;



  bfd_vma dst_mask;







  bfd_boolean pcrel_offset;
};
# 2647 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
unsigned int bfd_get_reloc_size (reloc_howto_type *);

typedef struct relent_chain
{
  arelent relent;
  struct relent_chain *next;
}
arelent_chain;

bfd_reloc_status_type bfd_check_overflow
   (enum complain_overflow how,
    unsigned int bitsize,
    unsigned int rightshift,
    unsigned int addrsize,
    bfd_vma relocation);

bfd_reloc_status_type bfd_perform_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data,
    asection *input_section,
    bfd *output_bfd,
    char **error_message);

bfd_reloc_status_type bfd_install_relocation
   (bfd *abfd,
    arelent *reloc_entry,
    void *data, bfd_vma data_start,
    asection *input_section,
    char **error_message);

enum bfd_reloc_code_real {
  _dummy_first_bfd_reloc_code_real,



  BFD_RELOC_64,
  BFD_RELOC_32,
  BFD_RELOC_26,
  BFD_RELOC_24,
  BFD_RELOC_16,
  BFD_RELOC_14,
  BFD_RELOC_8,






  BFD_RELOC_64_PCREL,
  BFD_RELOC_32_PCREL,
  BFD_RELOC_24_PCREL,
  BFD_RELOC_16_PCREL,
  BFD_RELOC_12_PCREL,
  BFD_RELOC_8_PCREL,


  BFD_RELOC_32_SECREL,


  BFD_RELOC_32_GOT_PCREL,
  BFD_RELOC_16_GOT_PCREL,
  BFD_RELOC_8_GOT_PCREL,
  BFD_RELOC_32_GOTOFF,
  BFD_RELOC_16_GOTOFF,
  BFD_RELOC_LO16_GOTOFF,
  BFD_RELOC_HI16_GOTOFF,
  BFD_RELOC_HI16_S_GOTOFF,
  BFD_RELOC_8_GOTOFF,
  BFD_RELOC_64_PLT_PCREL,
  BFD_RELOC_32_PLT_PCREL,
  BFD_RELOC_24_PLT_PCREL,
  BFD_RELOC_16_PLT_PCREL,
  BFD_RELOC_8_PLT_PCREL,
  BFD_RELOC_64_PLTOFF,
  BFD_RELOC_32_PLTOFF,
  BFD_RELOC_16_PLTOFF,
  BFD_RELOC_LO16_PLTOFF,
  BFD_RELOC_HI16_PLTOFF,
  BFD_RELOC_HI16_S_PLTOFF,
  BFD_RELOC_8_PLTOFF,


  BFD_RELOC_SIZE32,
  BFD_RELOC_SIZE64,


  BFD_RELOC_68K_GLOB_DAT,
  BFD_RELOC_68K_JMP_SLOT,
  BFD_RELOC_68K_RELATIVE,
  BFD_RELOC_68K_TLS_GD32,
  BFD_RELOC_68K_TLS_GD16,
  BFD_RELOC_68K_TLS_GD8,
  BFD_RELOC_68K_TLS_LDM32,
  BFD_RELOC_68K_TLS_LDM16,
  BFD_RELOC_68K_TLS_LDM8,
  BFD_RELOC_68K_TLS_LDO32,
  BFD_RELOC_68K_TLS_LDO16,
  BFD_RELOC_68K_TLS_LDO8,
  BFD_RELOC_68K_TLS_IE32,
  BFD_RELOC_68K_TLS_IE16,
  BFD_RELOC_68K_TLS_IE8,
  BFD_RELOC_68K_TLS_LE32,
  BFD_RELOC_68K_TLS_LE16,
  BFD_RELOC_68K_TLS_LE8,


  BFD_RELOC_32_BASEREL,
  BFD_RELOC_16_BASEREL,
  BFD_RELOC_LO16_BASEREL,
  BFD_RELOC_HI16_BASEREL,
  BFD_RELOC_HI16_S_BASEREL,
  BFD_RELOC_8_BASEREL,
  BFD_RELOC_RVA,


  BFD_RELOC_8_FFnn,







  BFD_RELOC_32_PCREL_S2,
  BFD_RELOC_16_PCREL_S2,
  BFD_RELOC_23_PCREL_S2,



  BFD_RELOC_HI22,
  BFD_RELOC_LO10,





  BFD_RELOC_GPREL16,
  BFD_RELOC_GPREL32,


  BFD_RELOC_I960_CALLJ,



  BFD_RELOC_NONE,
  BFD_RELOC_SPARC_WDISP22,
  BFD_RELOC_SPARC22,
  BFD_RELOC_SPARC13,
  BFD_RELOC_SPARC_GOT10,
  BFD_RELOC_SPARC_GOT13,
  BFD_RELOC_SPARC_GOT22,
  BFD_RELOC_SPARC_PC10,
  BFD_RELOC_SPARC_PC22,
  BFD_RELOC_SPARC_WPLT30,
  BFD_RELOC_SPARC_COPY,
  BFD_RELOC_SPARC_GLOB_DAT,
  BFD_RELOC_SPARC_JMP_SLOT,
  BFD_RELOC_SPARC_RELATIVE,
  BFD_RELOC_SPARC_UA16,
  BFD_RELOC_SPARC_UA32,
  BFD_RELOC_SPARC_UA64,
  BFD_RELOC_SPARC_GOTDATA_HIX22,
  BFD_RELOC_SPARC_GOTDATA_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP_HIX22,
  BFD_RELOC_SPARC_GOTDATA_OP_LOX10,
  BFD_RELOC_SPARC_GOTDATA_OP,
  BFD_RELOC_SPARC_JMP_IREL,
  BFD_RELOC_SPARC_IRELATIVE,


  BFD_RELOC_SPARC_BASE13,
  BFD_RELOC_SPARC_BASE22,



  BFD_RELOC_SPARC_10,
  BFD_RELOC_SPARC_11,
  BFD_RELOC_SPARC_OLO10,
  BFD_RELOC_SPARC_HH22,
  BFD_RELOC_SPARC_HM10,
  BFD_RELOC_SPARC_LM22,
  BFD_RELOC_SPARC_PC_HH22,
  BFD_RELOC_SPARC_PC_HM10,
  BFD_RELOC_SPARC_PC_LM22,
  BFD_RELOC_SPARC_WDISP16,
  BFD_RELOC_SPARC_WDISP19,
  BFD_RELOC_SPARC_7,
  BFD_RELOC_SPARC_6,
  BFD_RELOC_SPARC_5,

  BFD_RELOC_SPARC_PLT32,
  BFD_RELOC_SPARC_PLT64,
  BFD_RELOC_SPARC_HIX22,
  BFD_RELOC_SPARC_LOX10,
  BFD_RELOC_SPARC_H44,
  BFD_RELOC_SPARC_M44,
  BFD_RELOC_SPARC_L44,
  BFD_RELOC_SPARC_REGISTER,
  BFD_RELOC_SPARC_H34,
  BFD_RELOC_SPARC_SIZE32,
  BFD_RELOC_SPARC_SIZE64,
  BFD_RELOC_SPARC_WDISP10,


  BFD_RELOC_SPARC_REV32,


  BFD_RELOC_SPARC_TLS_GD_HI22,
  BFD_RELOC_SPARC_TLS_GD_LO10,
  BFD_RELOC_SPARC_TLS_GD_ADD,
  BFD_RELOC_SPARC_TLS_GD_CALL,
  BFD_RELOC_SPARC_TLS_LDM_HI22,
  BFD_RELOC_SPARC_TLS_LDM_LO10,
  BFD_RELOC_SPARC_TLS_LDM_ADD,
  BFD_RELOC_SPARC_TLS_LDM_CALL,
  BFD_RELOC_SPARC_TLS_LDO_HIX22,
  BFD_RELOC_SPARC_TLS_LDO_LOX10,
  BFD_RELOC_SPARC_TLS_LDO_ADD,
  BFD_RELOC_SPARC_TLS_IE_HI22,
  BFD_RELOC_SPARC_TLS_IE_LO10,
  BFD_RELOC_SPARC_TLS_IE_LD,
  BFD_RELOC_SPARC_TLS_IE_LDX,
  BFD_RELOC_SPARC_TLS_IE_ADD,
  BFD_RELOC_SPARC_TLS_LE_HIX22,
  BFD_RELOC_SPARC_TLS_LE_LOX10,
  BFD_RELOC_SPARC_TLS_DTPMOD32,
  BFD_RELOC_SPARC_TLS_DTPMOD64,
  BFD_RELOC_SPARC_TLS_DTPOFF32,
  BFD_RELOC_SPARC_TLS_DTPOFF64,
  BFD_RELOC_SPARC_TLS_TPOFF32,
  BFD_RELOC_SPARC_TLS_TPOFF64,


  BFD_RELOC_SPU_IMM7,
  BFD_RELOC_SPU_IMM8,
  BFD_RELOC_SPU_IMM10,
  BFD_RELOC_SPU_IMM10W,
  BFD_RELOC_SPU_IMM16,
  BFD_RELOC_SPU_IMM16W,
  BFD_RELOC_SPU_IMM18,
  BFD_RELOC_SPU_PCREL9a,
  BFD_RELOC_SPU_PCREL9b,
  BFD_RELOC_SPU_PCREL16,
  BFD_RELOC_SPU_LO16,
  BFD_RELOC_SPU_HI16,
  BFD_RELOC_SPU_PPU32,
  BFD_RELOC_SPU_PPU64,
  BFD_RELOC_SPU_ADD_PIC,







  BFD_RELOC_ALPHA_GPDISP_HI16,





  BFD_RELOC_ALPHA_GPDISP_LO16,




  BFD_RELOC_ALPHA_GPDISP,
# 2939 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  BFD_RELOC_ALPHA_LITERAL,
  BFD_RELOC_ALPHA_ELF_LITERAL,
  BFD_RELOC_ALPHA_LITUSE,




  BFD_RELOC_ALPHA_HINT,



  BFD_RELOC_ALPHA_LINKAGE,



  BFD_RELOC_ALPHA_CODEADDR,



  BFD_RELOC_ALPHA_GPREL_HI16,
  BFD_RELOC_ALPHA_GPREL_LO16,




  BFD_RELOC_ALPHA_BRSGP,



  BFD_RELOC_ALPHA_NOP,



  BFD_RELOC_ALPHA_BSR,



  BFD_RELOC_ALPHA_LDA,



  BFD_RELOC_ALPHA_BOH,


  BFD_RELOC_ALPHA_TLSGD,
  BFD_RELOC_ALPHA_TLSLDM,
  BFD_RELOC_ALPHA_DTPMOD64,
  BFD_RELOC_ALPHA_GOTDTPREL16,
  BFD_RELOC_ALPHA_DTPREL64,
  BFD_RELOC_ALPHA_DTPREL_HI16,
  BFD_RELOC_ALPHA_DTPREL_LO16,
  BFD_RELOC_ALPHA_DTPREL16,
  BFD_RELOC_ALPHA_GOTTPREL16,
  BFD_RELOC_ALPHA_TPREL64,
  BFD_RELOC_ALPHA_TPREL_HI16,
  BFD_RELOC_ALPHA_TPREL_LO16,
  BFD_RELOC_ALPHA_TPREL16,


  BFD_RELOC_MIPS_JMP,
  BFD_RELOC_MICROMIPS_JMP,


  BFD_RELOC_MIPS16_JMP,


  BFD_RELOC_MIPS16_GPREL,


  BFD_RELOC_HI16,





  BFD_RELOC_HI16_S,


  BFD_RELOC_LO16,


  BFD_RELOC_HI16_PCREL,


  BFD_RELOC_HI16_S_PCREL,


  BFD_RELOC_LO16_PCREL,



  BFD_RELOC_MIPS16_GOT16,
  BFD_RELOC_MIPS16_CALL16,


  BFD_RELOC_MIPS16_HI16,





  BFD_RELOC_MIPS16_HI16_S,


  BFD_RELOC_MIPS16_LO16,


  BFD_RELOC_MIPS16_TLS_GD,
  BFD_RELOC_MIPS16_TLS_LDM,
  BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS16_TLS_GOTTPREL,
  BFD_RELOC_MIPS16_TLS_TPREL_HI16,
  BFD_RELOC_MIPS16_TLS_TPREL_LO16,


  BFD_RELOC_MIPS_LITERAL,
  BFD_RELOC_MICROMIPS_LITERAL,


  BFD_RELOC_MICROMIPS_7_PCREL_S1,
  BFD_RELOC_MICROMIPS_10_PCREL_S1,
  BFD_RELOC_MICROMIPS_16_PCREL_S1,


  BFD_RELOC_MIPS16_16_PCREL_S1,


  BFD_RELOC_MIPS_21_PCREL_S2,
  BFD_RELOC_MIPS_26_PCREL_S2,
  BFD_RELOC_MIPS_18_PCREL_S3,
  BFD_RELOC_MIPS_19_PCREL_S2,


  BFD_RELOC_MICROMIPS_GPREL16,
  BFD_RELOC_MICROMIPS_HI16,
  BFD_RELOC_MICROMIPS_HI16_S,
  BFD_RELOC_MICROMIPS_LO16,


  BFD_RELOC_MIPS_GOT16,
  BFD_RELOC_MICROMIPS_GOT16,
  BFD_RELOC_MIPS_CALL16,
  BFD_RELOC_MICROMIPS_CALL16,
  BFD_RELOC_MIPS_GOT_HI16,
  BFD_RELOC_MICROMIPS_GOT_HI16,
  BFD_RELOC_MIPS_GOT_LO16,
  BFD_RELOC_MICROMIPS_GOT_LO16,
  BFD_RELOC_MIPS_CALL_HI16,
  BFD_RELOC_MICROMIPS_CALL_HI16,
  BFD_RELOC_MIPS_CALL_LO16,
  BFD_RELOC_MICROMIPS_CALL_LO16,
  BFD_RELOC_MIPS_SUB,
  BFD_RELOC_MICROMIPS_SUB,
  BFD_RELOC_MIPS_GOT_PAGE,
  BFD_RELOC_MICROMIPS_GOT_PAGE,
  BFD_RELOC_MIPS_GOT_OFST,
  BFD_RELOC_MICROMIPS_GOT_OFST,
  BFD_RELOC_MIPS_GOT_DISP,
  BFD_RELOC_MICROMIPS_GOT_DISP,
  BFD_RELOC_MIPS_SHIFT5,
  BFD_RELOC_MIPS_SHIFT6,
  BFD_RELOC_MIPS_INSERT_A,
  BFD_RELOC_MIPS_INSERT_B,
  BFD_RELOC_MIPS_DELETE,
  BFD_RELOC_MIPS_HIGHEST,
  BFD_RELOC_MICROMIPS_HIGHEST,
  BFD_RELOC_MIPS_HIGHER,
  BFD_RELOC_MICROMIPS_HIGHER,
  BFD_RELOC_MIPS_SCN_DISP,
  BFD_RELOC_MICROMIPS_SCN_DISP,
  BFD_RELOC_MIPS_REL16,
  BFD_RELOC_MIPS_RELGOT,
  BFD_RELOC_MIPS_JALR,
  BFD_RELOC_MICROMIPS_JALR,
  BFD_RELOC_MIPS_TLS_DTPMOD32,
  BFD_RELOC_MIPS_TLS_DTPREL32,
  BFD_RELOC_MIPS_TLS_DTPMOD64,
  BFD_RELOC_MIPS_TLS_DTPREL64,
  BFD_RELOC_MIPS_TLS_GD,
  BFD_RELOC_MICROMIPS_TLS_GD,
  BFD_RELOC_MIPS_TLS_LDM,
  BFD_RELOC_MICROMIPS_TLS_LDM,
  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16,
  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16,
  BFD_RELOC_MIPS_TLS_GOTTPREL,
  BFD_RELOC_MICROMIPS_TLS_GOTTPREL,
  BFD_RELOC_MIPS_TLS_TPREL32,
  BFD_RELOC_MIPS_TLS_TPREL64,
  BFD_RELOC_MIPS_TLS_TPREL_HI16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_HI16,
  BFD_RELOC_MIPS_TLS_TPREL_LO16,
  BFD_RELOC_MICROMIPS_TLS_TPREL_LO16,
  BFD_RELOC_MIPS_EH,



  BFD_RELOC_MIPS_COPY,
  BFD_RELOC_MIPS_JUMP_SLOT,



  BFD_RELOC_MOXIE_10_PCREL,



  BFD_RELOC_FT32_10,
  BFD_RELOC_FT32_20,
  BFD_RELOC_FT32_17,
  BFD_RELOC_FT32_18,



  BFD_RELOC_FRV_LABEL16,
  BFD_RELOC_FRV_LABEL24,
  BFD_RELOC_FRV_LO16,
  BFD_RELOC_FRV_HI16,
  BFD_RELOC_FRV_GPREL12,
  BFD_RELOC_FRV_GPRELU12,
  BFD_RELOC_FRV_GPREL32,
  BFD_RELOC_FRV_GPRELHI,
  BFD_RELOC_FRV_GPRELLO,
  BFD_RELOC_FRV_GOT12,
  BFD_RELOC_FRV_GOTHI,
  BFD_RELOC_FRV_GOTLO,
  BFD_RELOC_FRV_FUNCDESC,
  BFD_RELOC_FRV_FUNCDESC_GOT12,
  BFD_RELOC_FRV_FUNCDESC_GOTHI,
  BFD_RELOC_FRV_FUNCDESC_GOTLO,
  BFD_RELOC_FRV_FUNCDESC_VALUE,
  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
  BFD_RELOC_FRV_GOTOFF12,
  BFD_RELOC_FRV_GOTOFFHI,
  BFD_RELOC_FRV_GOTOFFLO,
  BFD_RELOC_FRV_GETTLSOFF,
  BFD_RELOC_FRV_TLSDESC_VALUE,
  BFD_RELOC_FRV_GOTTLSDESC12,
  BFD_RELOC_FRV_GOTTLSDESCHI,
  BFD_RELOC_FRV_GOTTLSDESCLO,
  BFD_RELOC_FRV_TLSMOFF12,
  BFD_RELOC_FRV_TLSMOFFHI,
  BFD_RELOC_FRV_TLSMOFFLO,
  BFD_RELOC_FRV_GOTTLSOFF12,
  BFD_RELOC_FRV_GOTTLSOFFHI,
  BFD_RELOC_FRV_GOTTLSOFFLO,
  BFD_RELOC_FRV_TLSOFF,
  BFD_RELOC_FRV_TLSDESC_RELAX,
  BFD_RELOC_FRV_GETTLSOFF_RELAX,
  BFD_RELOC_FRV_TLSOFF_RELAX,
  BFD_RELOC_FRV_TLSMOFF,



  BFD_RELOC_MN10300_GOTOFF24,



  BFD_RELOC_MN10300_GOT32,



  BFD_RELOC_MN10300_GOT24,



  BFD_RELOC_MN10300_GOT16,


  BFD_RELOC_MN10300_COPY,


  BFD_RELOC_MN10300_GLOB_DAT,


  BFD_RELOC_MN10300_JMP_SLOT,


  BFD_RELOC_MN10300_RELATIVE,




  BFD_RELOC_MN10300_SYM_DIFF,




  BFD_RELOC_MN10300_ALIGN,


  BFD_RELOC_MN10300_TLS_GD,
  BFD_RELOC_MN10300_TLS_LD,
  BFD_RELOC_MN10300_TLS_LDO,
  BFD_RELOC_MN10300_TLS_GOTIE,
  BFD_RELOC_MN10300_TLS_IE,
  BFD_RELOC_MN10300_TLS_LE,
  BFD_RELOC_MN10300_TLS_DTPMOD,
  BFD_RELOC_MN10300_TLS_DTPOFF,
  BFD_RELOC_MN10300_TLS_TPOFF,



  BFD_RELOC_MN10300_32_PCREL,



  BFD_RELOC_MN10300_16_PCREL,



  BFD_RELOC_386_GOT32,
  BFD_RELOC_386_PLT32,
  BFD_RELOC_386_COPY,
  BFD_RELOC_386_GLOB_DAT,
  BFD_RELOC_386_JUMP_SLOT,
  BFD_RELOC_386_RELATIVE,
  BFD_RELOC_386_GOTOFF,
  BFD_RELOC_386_GOTPC,
  BFD_RELOC_386_TLS_TPOFF,
  BFD_RELOC_386_TLS_IE,
  BFD_RELOC_386_TLS_GOTIE,
  BFD_RELOC_386_TLS_LE,
  BFD_RELOC_386_TLS_GD,
  BFD_RELOC_386_TLS_LDM,
  BFD_RELOC_386_TLS_LDO_32,
  BFD_RELOC_386_TLS_IE_32,
  BFD_RELOC_386_TLS_LE_32,
  BFD_RELOC_386_TLS_DTPMOD32,
  BFD_RELOC_386_TLS_DTPOFF32,
  BFD_RELOC_386_TLS_TPOFF32,
  BFD_RELOC_386_TLS_GOTDESC,
  BFD_RELOC_386_TLS_DESC_CALL,
  BFD_RELOC_386_TLS_DESC,
  BFD_RELOC_386_IRELATIVE,
  BFD_RELOC_386_GOT32X,


  BFD_RELOC_X86_64_GOT32,
  BFD_RELOC_X86_64_PLT32,
  BFD_RELOC_X86_64_COPY,
  BFD_RELOC_X86_64_GLOB_DAT,
  BFD_RELOC_X86_64_JUMP_SLOT,
  BFD_RELOC_X86_64_RELATIVE,
  BFD_RELOC_X86_64_GOTPCREL,
  BFD_RELOC_X86_64_32S,
  BFD_RELOC_X86_64_DTPMOD64,
  BFD_RELOC_X86_64_DTPOFF64,
  BFD_RELOC_X86_64_TPOFF64,
  BFD_RELOC_X86_64_TLSGD,
  BFD_RELOC_X86_64_TLSLD,
  BFD_RELOC_X86_64_DTPOFF32,
  BFD_RELOC_X86_64_GOTTPOFF,
  BFD_RELOC_X86_64_TPOFF32,
  BFD_RELOC_X86_64_GOTOFF64,
  BFD_RELOC_X86_64_GOTPC32,
  BFD_RELOC_X86_64_GOT64,
  BFD_RELOC_X86_64_GOTPCREL64,
  BFD_RELOC_X86_64_GOTPC64,
  BFD_RELOC_X86_64_GOTPLT64,
  BFD_RELOC_X86_64_PLTOFF64,
  BFD_RELOC_X86_64_GOTPC32_TLSDESC,
  BFD_RELOC_X86_64_TLSDESC_CALL,
  BFD_RELOC_X86_64_TLSDESC,
  BFD_RELOC_X86_64_IRELATIVE,
  BFD_RELOC_X86_64_PC32_BND,
  BFD_RELOC_X86_64_PLT32_BND,
  BFD_RELOC_X86_64_GOTPCRELX,
  BFD_RELOC_X86_64_REX_GOTPCRELX,


  BFD_RELOC_NS32K_IMM_8,
  BFD_RELOC_NS32K_IMM_16,
  BFD_RELOC_NS32K_IMM_32,
  BFD_RELOC_NS32K_IMM_8_PCREL,
  BFD_RELOC_NS32K_IMM_16_PCREL,
  BFD_RELOC_NS32K_IMM_32_PCREL,
  BFD_RELOC_NS32K_DISP_8,
  BFD_RELOC_NS32K_DISP_16,
  BFD_RELOC_NS32K_DISP_32,
  BFD_RELOC_NS32K_DISP_8_PCREL,
  BFD_RELOC_NS32K_DISP_16_PCREL,
  BFD_RELOC_NS32K_DISP_32_PCREL,


  BFD_RELOC_PDP11_DISP_8_PCREL,
  BFD_RELOC_PDP11_DISP_6_PCREL,


  BFD_RELOC_PJ_CODE_HI16,
  BFD_RELOC_PJ_CODE_LO16,
  BFD_RELOC_PJ_CODE_DIR16,
  BFD_RELOC_PJ_CODE_DIR32,
  BFD_RELOC_PJ_CODE_REL16,
  BFD_RELOC_PJ_CODE_REL32,


  BFD_RELOC_PPC_B26,
  BFD_RELOC_PPC_BA26,
  BFD_RELOC_PPC_TOC16,
  BFD_RELOC_PPC_B16,
  BFD_RELOC_PPC_B16_BRTAKEN,
  BFD_RELOC_PPC_B16_BRNTAKEN,
  BFD_RELOC_PPC_BA16,
  BFD_RELOC_PPC_BA16_BRTAKEN,
  BFD_RELOC_PPC_BA16_BRNTAKEN,
  BFD_RELOC_PPC_COPY,
  BFD_RELOC_PPC_GLOB_DAT,
  BFD_RELOC_PPC_JMP_SLOT,
  BFD_RELOC_PPC_RELATIVE,
  BFD_RELOC_PPC_LOCAL24PC,
  BFD_RELOC_PPC_EMB_NADDR32,
  BFD_RELOC_PPC_EMB_NADDR16,
  BFD_RELOC_PPC_EMB_NADDR16_LO,
  BFD_RELOC_PPC_EMB_NADDR16_HI,
  BFD_RELOC_PPC_EMB_NADDR16_HA,
  BFD_RELOC_PPC_EMB_SDAI16,
  BFD_RELOC_PPC_EMB_SDA2I16,
  BFD_RELOC_PPC_EMB_SDA2REL,
  BFD_RELOC_PPC_EMB_SDA21,
  BFD_RELOC_PPC_EMB_MRKREF,
  BFD_RELOC_PPC_EMB_RELSEC16,
  BFD_RELOC_PPC_EMB_RELST_LO,
  BFD_RELOC_PPC_EMB_RELST_HI,
  BFD_RELOC_PPC_EMB_RELST_HA,
  BFD_RELOC_PPC_EMB_BIT_FLD,
  BFD_RELOC_PPC_EMB_RELSDA,
  BFD_RELOC_PPC_VLE_REL8,
  BFD_RELOC_PPC_VLE_REL15,
  BFD_RELOC_PPC_VLE_REL24,
  BFD_RELOC_PPC_VLE_LO16A,
  BFD_RELOC_PPC_VLE_LO16D,
  BFD_RELOC_PPC_VLE_HI16A,
  BFD_RELOC_PPC_VLE_HI16D,
  BFD_RELOC_PPC_VLE_HA16A,
  BFD_RELOC_PPC_VLE_HA16D,
  BFD_RELOC_PPC_VLE_SDA21,
  BFD_RELOC_PPC_VLE_SDA21_LO,
  BFD_RELOC_PPC_VLE_SDAREL_LO16A,
  BFD_RELOC_PPC_VLE_SDAREL_LO16D,
  BFD_RELOC_PPC_VLE_SDAREL_HI16A,
  BFD_RELOC_PPC_VLE_SDAREL_HI16D,
  BFD_RELOC_PPC_VLE_SDAREL_HA16A,
  BFD_RELOC_PPC_VLE_SDAREL_HA16D,
  BFD_RELOC_PPC_16DX_HA,
  BFD_RELOC_PPC_REL16DX_HA,
  BFD_RELOC_PPC64_HIGHER,
  BFD_RELOC_PPC64_HIGHER_S,
  BFD_RELOC_PPC64_HIGHEST,
  BFD_RELOC_PPC64_HIGHEST_S,
  BFD_RELOC_PPC64_TOC16_LO,
  BFD_RELOC_PPC64_TOC16_HI,
  BFD_RELOC_PPC64_TOC16_HA,
  BFD_RELOC_PPC64_TOC,
  BFD_RELOC_PPC64_PLTGOT16,
  BFD_RELOC_PPC64_PLTGOT16_LO,
  BFD_RELOC_PPC64_PLTGOT16_HI,
  BFD_RELOC_PPC64_PLTGOT16_HA,
  BFD_RELOC_PPC64_ADDR16_DS,
  BFD_RELOC_PPC64_ADDR16_LO_DS,
  BFD_RELOC_PPC64_GOT16_DS,
  BFD_RELOC_PPC64_GOT16_LO_DS,
  BFD_RELOC_PPC64_PLT16_LO_DS,
  BFD_RELOC_PPC64_SECTOFF_DS,
  BFD_RELOC_PPC64_SECTOFF_LO_DS,
  BFD_RELOC_PPC64_TOC16_DS,
  BFD_RELOC_PPC64_TOC16_LO_DS,
  BFD_RELOC_PPC64_PLTGOT16_DS,
  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
  BFD_RELOC_PPC64_ADDR16_HIGH,
  BFD_RELOC_PPC64_ADDR16_HIGHA,
  BFD_RELOC_PPC64_ADDR64_LOCAL,
  BFD_RELOC_PPC64_ENTRY,


  BFD_RELOC_PPC_TLS,
  BFD_RELOC_PPC_TLSGD,
  BFD_RELOC_PPC_TLSLD,
  BFD_RELOC_PPC_DTPMOD,
  BFD_RELOC_PPC_TPREL16,
  BFD_RELOC_PPC_TPREL16_LO,
  BFD_RELOC_PPC_TPREL16_HI,
  BFD_RELOC_PPC_TPREL16_HA,
  BFD_RELOC_PPC_TPREL,
  BFD_RELOC_PPC_DTPREL16,
  BFD_RELOC_PPC_DTPREL16_LO,
  BFD_RELOC_PPC_DTPREL16_HI,
  BFD_RELOC_PPC_DTPREL16_HA,
  BFD_RELOC_PPC_DTPREL,
  BFD_RELOC_PPC_GOT_TLSGD16,
  BFD_RELOC_PPC_GOT_TLSGD16_LO,
  BFD_RELOC_PPC_GOT_TLSGD16_HI,
  BFD_RELOC_PPC_GOT_TLSGD16_HA,
  BFD_RELOC_PPC_GOT_TLSLD16,
  BFD_RELOC_PPC_GOT_TLSLD16_LO,
  BFD_RELOC_PPC_GOT_TLSLD16_HI,
  BFD_RELOC_PPC_GOT_TLSLD16_HA,
  BFD_RELOC_PPC_GOT_TPREL16,
  BFD_RELOC_PPC_GOT_TPREL16_LO,
  BFD_RELOC_PPC_GOT_TPREL16_HI,
  BFD_RELOC_PPC_GOT_TPREL16_HA,
  BFD_RELOC_PPC_GOT_DTPREL16,
  BFD_RELOC_PPC_GOT_DTPREL16_LO,
  BFD_RELOC_PPC_GOT_DTPREL16_HI,
  BFD_RELOC_PPC_GOT_DTPREL16_HA,
  BFD_RELOC_PPC64_TPREL16_DS,
  BFD_RELOC_PPC64_TPREL16_LO_DS,
  BFD_RELOC_PPC64_TPREL16_HIGHER,
  BFD_RELOC_PPC64_TPREL16_HIGHERA,
  BFD_RELOC_PPC64_TPREL16_HIGHEST,
  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
  BFD_RELOC_PPC64_DTPREL16_DS,
  BFD_RELOC_PPC64_DTPREL16_LO_DS,
  BFD_RELOC_PPC64_DTPREL16_HIGHER,
  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
  BFD_RELOC_PPC64_TPREL16_HIGH,
  BFD_RELOC_PPC64_TPREL16_HIGHA,
  BFD_RELOC_PPC64_DTPREL16_HIGH,
  BFD_RELOC_PPC64_DTPREL16_HIGHA,


  BFD_RELOC_I370_D12,




  BFD_RELOC_CTOR,



  BFD_RELOC_ARM_PCREL_BRANCH,




  BFD_RELOC_ARM_PCREL_BLX,




  BFD_RELOC_THUMB_PCREL_BLX,


  BFD_RELOC_ARM_PCREL_CALL,


  BFD_RELOC_ARM_PCREL_JUMP,






  BFD_RELOC_THUMB_PCREL_BRANCH7,
  BFD_RELOC_THUMB_PCREL_BRANCH9,
  BFD_RELOC_THUMB_PCREL_BRANCH12,
  BFD_RELOC_THUMB_PCREL_BRANCH20,
  BFD_RELOC_THUMB_PCREL_BRANCH23,
  BFD_RELOC_THUMB_PCREL_BRANCH25,


  BFD_RELOC_ARM_OFFSET_IMM,


  BFD_RELOC_ARM_THUMB_OFFSET,



  BFD_RELOC_ARM_TARGET1,


  BFD_RELOC_ARM_ROSEGREL32,


  BFD_RELOC_ARM_SBREL32,




  BFD_RELOC_ARM_TARGET2,


  BFD_RELOC_ARM_PREL31,


  BFD_RELOC_ARM_MOVW,
  BFD_RELOC_ARM_MOVT,
  BFD_RELOC_ARM_MOVW_PCREL,
  BFD_RELOC_ARM_MOVT_PCREL,
  BFD_RELOC_ARM_THUMB_MOVW,
  BFD_RELOC_ARM_THUMB_MOVT,
  BFD_RELOC_ARM_THUMB_MOVW_PCREL,
  BFD_RELOC_ARM_THUMB_MOVT_PCREL,


  BFD_RELOC_ARM_JUMP_SLOT,
  BFD_RELOC_ARM_GLOB_DAT,
  BFD_RELOC_ARM_GOT32,
  BFD_RELOC_ARM_PLT32,
  BFD_RELOC_ARM_RELATIVE,
  BFD_RELOC_ARM_GOTOFF,
  BFD_RELOC_ARM_GOTPC,
  BFD_RELOC_ARM_GOT_PREL,


  BFD_RELOC_ARM_TLS_GD32,
  BFD_RELOC_ARM_TLS_LDO32,
  BFD_RELOC_ARM_TLS_LDM32,
  BFD_RELOC_ARM_TLS_DTPOFF32,
  BFD_RELOC_ARM_TLS_DTPMOD32,
  BFD_RELOC_ARM_TLS_TPOFF32,
  BFD_RELOC_ARM_TLS_IE32,
  BFD_RELOC_ARM_TLS_LE32,
  BFD_RELOC_ARM_TLS_GOTDESC,
  BFD_RELOC_ARM_TLS_CALL,
  BFD_RELOC_ARM_THM_TLS_CALL,
  BFD_RELOC_ARM_TLS_DESCSEQ,
  BFD_RELOC_ARM_THM_TLS_DESCSEQ,
  BFD_RELOC_ARM_TLS_DESC,


  BFD_RELOC_ARM_ALU_PC_G0_NC,
  BFD_RELOC_ARM_ALU_PC_G0,
  BFD_RELOC_ARM_ALU_PC_G1_NC,
  BFD_RELOC_ARM_ALU_PC_G1,
  BFD_RELOC_ARM_ALU_PC_G2,
  BFD_RELOC_ARM_LDR_PC_G0,
  BFD_RELOC_ARM_LDR_PC_G1,
  BFD_RELOC_ARM_LDR_PC_G2,
  BFD_RELOC_ARM_LDRS_PC_G0,
  BFD_RELOC_ARM_LDRS_PC_G1,
  BFD_RELOC_ARM_LDRS_PC_G2,
  BFD_RELOC_ARM_LDC_PC_G0,
  BFD_RELOC_ARM_LDC_PC_G1,
  BFD_RELOC_ARM_LDC_PC_G2,
  BFD_RELOC_ARM_ALU_SB_G0_NC,
  BFD_RELOC_ARM_ALU_SB_G0,
  BFD_RELOC_ARM_ALU_SB_G1_NC,
  BFD_RELOC_ARM_ALU_SB_G1,
  BFD_RELOC_ARM_ALU_SB_G2,
  BFD_RELOC_ARM_LDR_SB_G0,
  BFD_RELOC_ARM_LDR_SB_G1,
  BFD_RELOC_ARM_LDR_SB_G2,
  BFD_RELOC_ARM_LDRS_SB_G0,
  BFD_RELOC_ARM_LDRS_SB_G1,
  BFD_RELOC_ARM_LDRS_SB_G2,
  BFD_RELOC_ARM_LDC_SB_G0,
  BFD_RELOC_ARM_LDC_SB_G1,
  BFD_RELOC_ARM_LDC_SB_G2,


  BFD_RELOC_ARM_V4BX,


  BFD_RELOC_ARM_IRELATIVE,


  BFD_RELOC_ARM_THUMB_ALU_ABS_G0_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G1_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G2_NC,
  BFD_RELOC_ARM_THUMB_ALU_ABS_G3_NC,



  BFD_RELOC_ARM_IMMEDIATE,
  BFD_RELOC_ARM_ADRL_IMMEDIATE,
  BFD_RELOC_ARM_T32_IMMEDIATE,
  BFD_RELOC_ARM_T32_ADD_IMM,
  BFD_RELOC_ARM_T32_IMM12,
  BFD_RELOC_ARM_T32_ADD_PC12,
  BFD_RELOC_ARM_SHIFT_IMM,
  BFD_RELOC_ARM_SMC,
  BFD_RELOC_ARM_HVC,
  BFD_RELOC_ARM_SWI,
  BFD_RELOC_ARM_MULTI,
  BFD_RELOC_ARM_CP_OFF_IMM,
  BFD_RELOC_ARM_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_T32_CP_OFF_IMM,
  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
  BFD_RELOC_ARM_ADR_IMM,
  BFD_RELOC_ARM_LDR_IMM,
  BFD_RELOC_ARM_LITERAL,
  BFD_RELOC_ARM_IN_POOL,
  BFD_RELOC_ARM_OFFSET_IMM8,
  BFD_RELOC_ARM_T32_OFFSET_U8,
  BFD_RELOC_ARM_T32_OFFSET_IMM,
  BFD_RELOC_ARM_HWLITERAL,
  BFD_RELOC_ARM_THUMB_ADD,
  BFD_RELOC_ARM_THUMB_IMM,
  BFD_RELOC_ARM_THUMB_SHIFT,


  BFD_RELOC_SH_PCDISP8BY2,
  BFD_RELOC_SH_PCDISP12BY2,
  BFD_RELOC_SH_IMM3,
  BFD_RELOC_SH_IMM3U,
  BFD_RELOC_SH_DISP12,
  BFD_RELOC_SH_DISP12BY2,
  BFD_RELOC_SH_DISP12BY4,
  BFD_RELOC_SH_DISP12BY8,
  BFD_RELOC_SH_DISP20,
  BFD_RELOC_SH_DISP20BY8,
  BFD_RELOC_SH_IMM4,
  BFD_RELOC_SH_IMM4BY2,
  BFD_RELOC_SH_IMM4BY4,
  BFD_RELOC_SH_IMM8,
  BFD_RELOC_SH_IMM8BY2,
  BFD_RELOC_SH_IMM8BY4,
  BFD_RELOC_SH_PCRELIMM8BY2,
  BFD_RELOC_SH_PCRELIMM8BY4,
  BFD_RELOC_SH_SWITCH16,
  BFD_RELOC_SH_SWITCH32,
  BFD_RELOC_SH_USES,
  BFD_RELOC_SH_COUNT,
  BFD_RELOC_SH_ALIGN,
  BFD_RELOC_SH_CODE,
  BFD_RELOC_SH_DATA,
  BFD_RELOC_SH_LABEL,
  BFD_RELOC_SH_LOOP_START,
  BFD_RELOC_SH_LOOP_END,
  BFD_RELOC_SH_COPY,
  BFD_RELOC_SH_GLOB_DAT,
  BFD_RELOC_SH_JMP_SLOT,
  BFD_RELOC_SH_RELATIVE,
  BFD_RELOC_SH_GOTPC,
  BFD_RELOC_SH_GOT_LOW16,
  BFD_RELOC_SH_GOT_MEDLOW16,
  BFD_RELOC_SH_GOT_MEDHI16,
  BFD_RELOC_SH_GOT_HI16,
  BFD_RELOC_SH_GOTPLT_LOW16,
  BFD_RELOC_SH_GOTPLT_MEDLOW16,
  BFD_RELOC_SH_GOTPLT_MEDHI16,
  BFD_RELOC_SH_GOTPLT_HI16,
  BFD_RELOC_SH_PLT_LOW16,
  BFD_RELOC_SH_PLT_MEDLOW16,
  BFD_RELOC_SH_PLT_MEDHI16,
  BFD_RELOC_SH_PLT_HI16,
  BFD_RELOC_SH_GOTOFF_LOW16,
  BFD_RELOC_SH_GOTOFF_MEDLOW16,
  BFD_RELOC_SH_GOTOFF_MEDHI16,
  BFD_RELOC_SH_GOTOFF_HI16,
  BFD_RELOC_SH_GOTPC_LOW16,
  BFD_RELOC_SH_GOTPC_MEDLOW16,
  BFD_RELOC_SH_GOTPC_MEDHI16,
  BFD_RELOC_SH_GOTPC_HI16,
  BFD_RELOC_SH_COPY64,
  BFD_RELOC_SH_GLOB_DAT64,
  BFD_RELOC_SH_JMP_SLOT64,
  BFD_RELOC_SH_RELATIVE64,
  BFD_RELOC_SH_GOT10BY4,
  BFD_RELOC_SH_GOT10BY8,
  BFD_RELOC_SH_GOTPLT10BY4,
  BFD_RELOC_SH_GOTPLT10BY8,
  BFD_RELOC_SH_GOTPLT32,
  BFD_RELOC_SH_SHMEDIA_CODE,
  BFD_RELOC_SH_IMMU5,
  BFD_RELOC_SH_IMMS6,
  BFD_RELOC_SH_IMMS6BY32,
  BFD_RELOC_SH_IMMU6,
  BFD_RELOC_SH_IMMS10,
  BFD_RELOC_SH_IMMS10BY2,
  BFD_RELOC_SH_IMMS10BY4,
  BFD_RELOC_SH_IMMS10BY8,
  BFD_RELOC_SH_IMMS16,
  BFD_RELOC_SH_IMMU16,
  BFD_RELOC_SH_IMM_LOW16,
  BFD_RELOC_SH_IMM_LOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDLOW16,
  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
  BFD_RELOC_SH_IMM_MEDHI16,
  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
  BFD_RELOC_SH_IMM_HI16,
  BFD_RELOC_SH_IMM_HI16_PCREL,
  BFD_RELOC_SH_PT_16,
  BFD_RELOC_SH_TLS_GD_32,
  BFD_RELOC_SH_TLS_LD_32,
  BFD_RELOC_SH_TLS_LDO_32,
  BFD_RELOC_SH_TLS_IE_32,
  BFD_RELOC_SH_TLS_LE_32,
  BFD_RELOC_SH_TLS_DTPMOD32,
  BFD_RELOC_SH_TLS_DTPOFF32,
  BFD_RELOC_SH_TLS_TPOFF32,
  BFD_RELOC_SH_GOT20,
  BFD_RELOC_SH_GOTOFF20,
  BFD_RELOC_SH_GOTFUNCDESC,
  BFD_RELOC_SH_GOTFUNCDESC20,
  BFD_RELOC_SH_GOTOFFFUNCDESC,
  BFD_RELOC_SH_GOTOFFFUNCDESC20,
  BFD_RELOC_SH_FUNCDESC,


  BFD_RELOC_ARC_NONE,
  BFD_RELOC_ARC_8,
  BFD_RELOC_ARC_16,
  BFD_RELOC_ARC_24,
  BFD_RELOC_ARC_32,
  BFD_RELOC_ARC_N8,
  BFD_RELOC_ARC_N16,
  BFD_RELOC_ARC_N24,
  BFD_RELOC_ARC_N32,
  BFD_RELOC_ARC_SDA,
  BFD_RELOC_ARC_SECTOFF,
  BFD_RELOC_ARC_S21H_PCREL,
  BFD_RELOC_ARC_S21W_PCREL,
  BFD_RELOC_ARC_S25H_PCREL,
  BFD_RELOC_ARC_S25W_PCREL,
  BFD_RELOC_ARC_SDA32,
  BFD_RELOC_ARC_SDA_LDST,
  BFD_RELOC_ARC_SDA_LDST1,
  BFD_RELOC_ARC_SDA_LDST2,
  BFD_RELOC_ARC_SDA16_LD,
  BFD_RELOC_ARC_SDA16_LD1,
  BFD_RELOC_ARC_SDA16_LD2,
  BFD_RELOC_ARC_S13_PCREL,
  BFD_RELOC_ARC_W,
  BFD_RELOC_ARC_32_ME,
  BFD_RELOC_ARC_32_ME_S,
  BFD_RELOC_ARC_N32_ME,
  BFD_RELOC_ARC_SECTOFF_ME,
  BFD_RELOC_ARC_SDA32_ME,
  BFD_RELOC_ARC_W_ME,
  BFD_RELOC_AC_SECTOFF_U8,
  BFD_RELOC_AC_SECTOFF_U8_1,
  BFD_RELOC_AC_SECTOFF_U8_2,
  BFD_RELOC_AC_SECTOFF_S9,
  BFD_RELOC_AC_SECTOFF_S9_1,
  BFD_RELOC_AC_SECTOFF_S9_2,
  BFD_RELOC_ARC_SECTOFF_ME_1,
  BFD_RELOC_ARC_SECTOFF_ME_2,
  BFD_RELOC_ARC_SECTOFF_1,
  BFD_RELOC_ARC_SECTOFF_2,
  BFD_RELOC_ARC_SDA_12,
  BFD_RELOC_ARC_SDA16_ST2,
  BFD_RELOC_ARC_32_PCREL,
  BFD_RELOC_ARC_PC32,
  BFD_RELOC_ARC_GOT32,
  BFD_RELOC_ARC_GOTPC32,
  BFD_RELOC_ARC_PLT32,
  BFD_RELOC_ARC_COPY,
  BFD_RELOC_ARC_GLOB_DAT,
  BFD_RELOC_ARC_JMP_SLOT,
  BFD_RELOC_ARC_RELATIVE,
  BFD_RELOC_ARC_GOTOFF,
  BFD_RELOC_ARC_GOTPC,
  BFD_RELOC_ARC_S21W_PCREL_PLT,
  BFD_RELOC_ARC_S25H_PCREL_PLT,
  BFD_RELOC_ARC_TLS_DTPMOD,
  BFD_RELOC_ARC_TLS_TPOFF,
  BFD_RELOC_ARC_TLS_GD_GOT,
  BFD_RELOC_ARC_TLS_GD_LD,
  BFD_RELOC_ARC_TLS_GD_CALL,
  BFD_RELOC_ARC_TLS_IE_GOT,
  BFD_RELOC_ARC_TLS_DTPOFF,
  BFD_RELOC_ARC_TLS_DTPOFF_S9,
  BFD_RELOC_ARC_TLS_LE_S9,
  BFD_RELOC_ARC_TLS_LE_32,
  BFD_RELOC_ARC_S25W_PCREL_PLT,
  BFD_RELOC_ARC_S21H_PCREL_PLT,
  BFD_RELOC_ARC_NPS_CMEM16,


  BFD_RELOC_BFIN_16_IMM,


  BFD_RELOC_BFIN_16_HIGH,


  BFD_RELOC_BFIN_4_PCREL,


  BFD_RELOC_BFIN_5_PCREL,


  BFD_RELOC_BFIN_16_LOW,


  BFD_RELOC_BFIN_10_PCREL,


  BFD_RELOC_BFIN_11_PCREL,


  BFD_RELOC_BFIN_12_PCREL_JUMP,


  BFD_RELOC_BFIN_12_PCREL_JUMP_S,


  BFD_RELOC_BFIN_24_PCREL_CALL_X,


  BFD_RELOC_BFIN_24_PCREL_JUMP_L,


  BFD_RELOC_BFIN_GOT17M4,
  BFD_RELOC_BFIN_GOTHI,
  BFD_RELOC_BFIN_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC,
  BFD_RELOC_BFIN_FUNCDESC_GOT17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTLO,
  BFD_RELOC_BFIN_FUNCDESC_VALUE,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
  BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO,
  BFD_RELOC_BFIN_GOTOFF17M4,
  BFD_RELOC_BFIN_GOTOFFHI,
  BFD_RELOC_BFIN_GOTOFFLO,


  BFD_RELOC_BFIN_GOT,


  BFD_RELOC_BFIN_PLTPC,


  BFD_ARELOC_BFIN_PUSH,


  BFD_ARELOC_BFIN_CONST,


  BFD_ARELOC_BFIN_ADD,


  BFD_ARELOC_BFIN_SUB,


  BFD_ARELOC_BFIN_MULT,


  BFD_ARELOC_BFIN_DIV,


  BFD_ARELOC_BFIN_MOD,


  BFD_ARELOC_BFIN_LSHIFT,


  BFD_ARELOC_BFIN_RSHIFT,


  BFD_ARELOC_BFIN_AND,


  BFD_ARELOC_BFIN_OR,


  BFD_ARELOC_BFIN_XOR,


  BFD_ARELOC_BFIN_LAND,


  BFD_ARELOC_BFIN_LOR,


  BFD_ARELOC_BFIN_LEN,


  BFD_ARELOC_BFIN_NEG,


  BFD_ARELOC_BFIN_COMP,


  BFD_ARELOC_BFIN_PAGE,


  BFD_ARELOC_BFIN_HWPAGE,


  BFD_ARELOC_BFIN_ADDR,




  BFD_RELOC_D10V_10_PCREL_R,






  BFD_RELOC_D10V_10_PCREL_L,



  BFD_RELOC_D10V_18,



  BFD_RELOC_D10V_18_PCREL,



  BFD_RELOC_D30V_6,



  BFD_RELOC_D30V_9_PCREL,





  BFD_RELOC_D30V_9_PCREL_R,



  BFD_RELOC_D30V_15,



  BFD_RELOC_D30V_15_PCREL,





  BFD_RELOC_D30V_15_PCREL_R,



  BFD_RELOC_D30V_21,



  BFD_RELOC_D30V_21_PCREL,





  BFD_RELOC_D30V_21_PCREL_R,


  BFD_RELOC_D30V_32,


  BFD_RELOC_D30V_32_PCREL,


  BFD_RELOC_DLX_HI16_S,


  BFD_RELOC_DLX_LO16,


  BFD_RELOC_DLX_JMP26,


  BFD_RELOC_M32C_HI8,
  BFD_RELOC_M32C_RL_JUMP,
  BFD_RELOC_M32C_RL_1ADDR,
  BFD_RELOC_M32C_RL_2ADDR,



  BFD_RELOC_M32R_24,


  BFD_RELOC_M32R_10_PCREL,


  BFD_RELOC_M32R_18_PCREL,


  BFD_RELOC_M32R_26_PCREL,



  BFD_RELOC_M32R_HI16_ULO,



  BFD_RELOC_M32R_HI16_SLO,


  BFD_RELOC_M32R_LO16,



  BFD_RELOC_M32R_SDA16,


  BFD_RELOC_M32R_GOT24,
  BFD_RELOC_M32R_26_PLTREL,
  BFD_RELOC_M32R_COPY,
  BFD_RELOC_M32R_GLOB_DAT,
  BFD_RELOC_M32R_JMP_SLOT,
  BFD_RELOC_M32R_RELATIVE,
  BFD_RELOC_M32R_GOTOFF,
  BFD_RELOC_M32R_GOTOFF_HI_ULO,
  BFD_RELOC_M32R_GOTOFF_HI_SLO,
  BFD_RELOC_M32R_GOTOFF_LO,
  BFD_RELOC_M32R_GOTPC24,
  BFD_RELOC_M32R_GOT16_HI_ULO,
  BFD_RELOC_M32R_GOT16_HI_SLO,
  BFD_RELOC_M32R_GOT16_LO,
  BFD_RELOC_M32R_GOTPC_HI_ULO,
  BFD_RELOC_M32R_GOTPC_HI_SLO,
  BFD_RELOC_M32R_GOTPC_LO,



  BFD_RELOC_NDS32_20,


  BFD_RELOC_NDS32_9_PCREL,


  BFD_RELOC_NDS32_WORD_9_PCREL,


  BFD_RELOC_NDS32_15_PCREL,


  BFD_RELOC_NDS32_17_PCREL,


  BFD_RELOC_NDS32_25_PCREL,



  BFD_RELOC_NDS32_HI20,



  BFD_RELOC_NDS32_LO12S3,



  BFD_RELOC_NDS32_LO12S2,



  BFD_RELOC_NDS32_LO12S1,



  BFD_RELOC_NDS32_LO12S0,



  BFD_RELOC_NDS32_LO12S0_ORI,



  BFD_RELOC_NDS32_SDA15S3,



  BFD_RELOC_NDS32_SDA15S2,



  BFD_RELOC_NDS32_SDA15S1,



  BFD_RELOC_NDS32_SDA15S0,



  BFD_RELOC_NDS32_SDA16S3,



  BFD_RELOC_NDS32_SDA17S2,



  BFD_RELOC_NDS32_SDA18S1,



  BFD_RELOC_NDS32_SDA19S0,


  BFD_RELOC_NDS32_GOT20,
  BFD_RELOC_NDS32_9_PLTREL,
  BFD_RELOC_NDS32_25_PLTREL,
  BFD_RELOC_NDS32_COPY,
  BFD_RELOC_NDS32_GLOB_DAT,
  BFD_RELOC_NDS32_JMP_SLOT,
  BFD_RELOC_NDS32_RELATIVE,
  BFD_RELOC_NDS32_GOTOFF,
  BFD_RELOC_NDS32_GOTOFF_HI20,
  BFD_RELOC_NDS32_GOTOFF_LO12,
  BFD_RELOC_NDS32_GOTPC20,
  BFD_RELOC_NDS32_GOT_HI20,
  BFD_RELOC_NDS32_GOT_LO12,
  BFD_RELOC_NDS32_GOTPC_HI20,
  BFD_RELOC_NDS32_GOTPC_LO12,


  BFD_RELOC_NDS32_INSN16,
  BFD_RELOC_NDS32_LABEL,
  BFD_RELOC_NDS32_LONGCALL1,
  BFD_RELOC_NDS32_LONGCALL2,
  BFD_RELOC_NDS32_LONGCALL3,
  BFD_RELOC_NDS32_LONGJUMP1,
  BFD_RELOC_NDS32_LONGJUMP2,
  BFD_RELOC_NDS32_LONGJUMP3,
  BFD_RELOC_NDS32_LOADSTORE,
  BFD_RELOC_NDS32_9_FIXED,
  BFD_RELOC_NDS32_15_FIXED,
  BFD_RELOC_NDS32_17_FIXED,
  BFD_RELOC_NDS32_25_FIXED,
  BFD_RELOC_NDS32_LONGCALL4,
  BFD_RELOC_NDS32_LONGCALL5,
  BFD_RELOC_NDS32_LONGCALL6,
  BFD_RELOC_NDS32_LONGJUMP4,
  BFD_RELOC_NDS32_LONGJUMP5,
  BFD_RELOC_NDS32_LONGJUMP6,
  BFD_RELOC_NDS32_LONGJUMP7,


  BFD_RELOC_NDS32_PLTREL_HI20,
  BFD_RELOC_NDS32_PLTREL_LO12,
  BFD_RELOC_NDS32_PLT_GOTREL_HI20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO12,


  BFD_RELOC_NDS32_SDA12S2_DP,
  BFD_RELOC_NDS32_SDA12S2_SP,
  BFD_RELOC_NDS32_LO12S2_DP,
  BFD_RELOC_NDS32_LO12S2_SP,


  BFD_RELOC_NDS32_DWARF2_OP1,
  BFD_RELOC_NDS32_DWARF2_OP2,
  BFD_RELOC_NDS32_DWARF2_LEB,


  BFD_RELOC_NDS32_UPDATE_TA,


  BFD_RELOC_NDS32_PLT_GOTREL_LO20,
  BFD_RELOC_NDS32_PLT_GOTREL_LO15,
  BFD_RELOC_NDS32_PLT_GOTREL_LO19,
  BFD_RELOC_NDS32_GOT_LO15,
  BFD_RELOC_NDS32_GOT_LO19,
  BFD_RELOC_NDS32_GOTOFF_LO15,
  BFD_RELOC_NDS32_GOTOFF_LO19,
  BFD_RELOC_NDS32_GOT15S2,
  BFD_RELOC_NDS32_GOT17S2,



  BFD_RELOC_NDS32_5,


  BFD_RELOC_NDS32_10_UPCREL,


  BFD_RELOC_NDS32_SDA_FP7U2_RELA,


  BFD_RELOC_NDS32_RELAX_ENTRY,
  BFD_RELOC_NDS32_GOT_SUFF,
  BFD_RELOC_NDS32_GOTOFF_SUFF,
  BFD_RELOC_NDS32_PLT_GOT_SUFF,
  BFD_RELOC_NDS32_MULCALL_SUFF,
  BFD_RELOC_NDS32_PTR,
  BFD_RELOC_NDS32_PTR_COUNT,
  BFD_RELOC_NDS32_PTR_RESOLVED,
  BFD_RELOC_NDS32_PLTBLOCK,
  BFD_RELOC_NDS32_RELAX_REGION_BEGIN,
  BFD_RELOC_NDS32_RELAX_REGION_END,
  BFD_RELOC_NDS32_MINUEND,
  BFD_RELOC_NDS32_SUBTRAHEND,
  BFD_RELOC_NDS32_DIFF8,
  BFD_RELOC_NDS32_DIFF16,
  BFD_RELOC_NDS32_DIFF32,
  BFD_RELOC_NDS32_DIFF_ULEB128,
  BFD_RELOC_NDS32_EMPTY,


  BFD_RELOC_NDS32_25_ABS,


  BFD_RELOC_NDS32_DATA,
  BFD_RELOC_NDS32_TRAN,
  BFD_RELOC_NDS32_17IFC_PCREL,
  BFD_RELOC_NDS32_10IFCU_PCREL,


  BFD_RELOC_NDS32_TPOFF,
  BFD_RELOC_NDS32_TLS_LE_HI20,
  BFD_RELOC_NDS32_TLS_LE_LO12,
  BFD_RELOC_NDS32_TLS_LE_ADD,
  BFD_RELOC_NDS32_TLS_LE_LS,
  BFD_RELOC_NDS32_GOTTPOFF,
  BFD_RELOC_NDS32_TLS_IE_HI20,
  BFD_RELOC_NDS32_TLS_IE_LO12S2,
  BFD_RELOC_NDS32_TLS_TPOFF,
  BFD_RELOC_NDS32_TLS_LE_20,
  BFD_RELOC_NDS32_TLS_LE_15S0,
  BFD_RELOC_NDS32_TLS_LE_15S1,
  BFD_RELOC_NDS32_TLS_LE_15S2,


  BFD_RELOC_V850_9_PCREL,


  BFD_RELOC_V850_22_PCREL,


  BFD_RELOC_V850_SDA_16_16_OFFSET,



  BFD_RELOC_V850_SDA_15_16_OFFSET,


  BFD_RELOC_V850_ZDA_16_16_OFFSET,



  BFD_RELOC_V850_ZDA_15_16_OFFSET,



  BFD_RELOC_V850_TDA_6_8_OFFSET,



  BFD_RELOC_V850_TDA_7_8_OFFSET,


  BFD_RELOC_V850_TDA_7_7_OFFSET,


  BFD_RELOC_V850_TDA_16_16_OFFSET,



  BFD_RELOC_V850_TDA_4_5_OFFSET,


  BFD_RELOC_V850_TDA_4_4_OFFSET,



  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,



  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,


  BFD_RELOC_V850_CALLT_6_7_OFFSET,


  BFD_RELOC_V850_CALLT_16_16_OFFSET,


  BFD_RELOC_V850_LONGCALL,


  BFD_RELOC_V850_LONGJUMP,


  BFD_RELOC_V850_ALIGN,



  BFD_RELOC_V850_LO16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_PCREL,


  BFD_RELOC_V850_17_PCREL,


  BFD_RELOC_V850_23,


  BFD_RELOC_V850_32_PCREL,


  BFD_RELOC_V850_32_ABS,


  BFD_RELOC_V850_16_SPLIT_OFFSET,


  BFD_RELOC_V850_16_S1,


  BFD_RELOC_V850_LO16_S1,


  BFD_RELOC_V850_CALLT_15_16_OFFSET,


  BFD_RELOC_V850_32_GOTPCREL,


  BFD_RELOC_V850_16_GOT,


  BFD_RELOC_V850_32_GOT,


  BFD_RELOC_V850_22_PLT_PCREL,


  BFD_RELOC_V850_32_PLT_PCREL,


  BFD_RELOC_V850_COPY,


  BFD_RELOC_V850_GLOB_DAT,


  BFD_RELOC_V850_JMP_SLOT,


  BFD_RELOC_V850_RELATIVE,


  BFD_RELOC_V850_16_GOTOFF,


  BFD_RELOC_V850_32_GOTOFF,


  BFD_RELOC_V850_CODE,


  BFD_RELOC_V850_DATA,




  BFD_RELOC_TIC30_LDP,




  BFD_RELOC_TIC54X_PARTLS7,




  BFD_RELOC_TIC54X_PARTMS9,


  BFD_RELOC_TIC54X_23,




  BFD_RELOC_TIC54X_16_OF_23,




  BFD_RELOC_TIC54X_MS7_OF_23,


  BFD_RELOC_C6000_PCR_S21,
  BFD_RELOC_C6000_PCR_S12,
  BFD_RELOC_C6000_PCR_S10,
  BFD_RELOC_C6000_PCR_S7,
  BFD_RELOC_C6000_ABS_S16,
  BFD_RELOC_C6000_ABS_L16,
  BFD_RELOC_C6000_ABS_H16,
  BFD_RELOC_C6000_SBR_U15_B,
  BFD_RELOC_C6000_SBR_U15_H,
  BFD_RELOC_C6000_SBR_U15_W,
  BFD_RELOC_C6000_SBR_S16,
  BFD_RELOC_C6000_SBR_L16_B,
  BFD_RELOC_C6000_SBR_L16_H,
  BFD_RELOC_C6000_SBR_L16_W,
  BFD_RELOC_C6000_SBR_H16_B,
  BFD_RELOC_C6000_SBR_H16_H,
  BFD_RELOC_C6000_SBR_H16_W,
  BFD_RELOC_C6000_SBR_GOT_U15_W,
  BFD_RELOC_C6000_SBR_GOT_L16_W,
  BFD_RELOC_C6000_SBR_GOT_H16_W,
  BFD_RELOC_C6000_DSBT_INDEX,
  BFD_RELOC_C6000_PREL31,
  BFD_RELOC_C6000_COPY,
  BFD_RELOC_C6000_JUMP_SLOT,
  BFD_RELOC_C6000_EHTYPE,
  BFD_RELOC_C6000_PCR_H16,
  BFD_RELOC_C6000_PCR_L16,
  BFD_RELOC_C6000_ALIGN,
  BFD_RELOC_C6000_FPHEAD,
  BFD_RELOC_C6000_NOCMP,


  BFD_RELOC_FR30_48,



  BFD_RELOC_FR30_20,



  BFD_RELOC_FR30_6_IN_4,



  BFD_RELOC_FR30_8_IN_8,



  BFD_RELOC_FR30_9_IN_8,



  BFD_RELOC_FR30_10_IN_8,



  BFD_RELOC_FR30_9_PCREL,



  BFD_RELOC_FR30_12_PCREL,


  BFD_RELOC_MCORE_PCREL_IMM8BY4,
  BFD_RELOC_MCORE_PCREL_IMM11BY2,
  BFD_RELOC_MCORE_PCREL_IMM4BY2,
  BFD_RELOC_MCORE_PCREL_32,
  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
  BFD_RELOC_MCORE_RVA,


  BFD_RELOC_MEP_8,
  BFD_RELOC_MEP_16,
  BFD_RELOC_MEP_32,
  BFD_RELOC_MEP_PCREL8A2,
  BFD_RELOC_MEP_PCREL12A2,
  BFD_RELOC_MEP_PCREL17A2,
  BFD_RELOC_MEP_PCREL24A2,
  BFD_RELOC_MEP_PCABS24A2,
  BFD_RELOC_MEP_LOW16,
  BFD_RELOC_MEP_HI16U,
  BFD_RELOC_MEP_HI16S,
  BFD_RELOC_MEP_GPREL,
  BFD_RELOC_MEP_TPREL,
  BFD_RELOC_MEP_TPREL7,
  BFD_RELOC_MEP_TPREL7A2,
  BFD_RELOC_MEP_TPREL7A4,
  BFD_RELOC_MEP_UIMM24,
  BFD_RELOC_MEP_ADDR24A4,
  BFD_RELOC_MEP_GNU_VTINHERIT,
  BFD_RELOC_MEP_GNU_VTENTRY,



  BFD_RELOC_METAG_HIADDR16,
  BFD_RELOC_METAG_LOADDR16,
  BFD_RELOC_METAG_RELBRANCH,
  BFD_RELOC_METAG_GETSETOFF,
  BFD_RELOC_METAG_HIOG,
  BFD_RELOC_METAG_LOOG,
  BFD_RELOC_METAG_REL8,
  BFD_RELOC_METAG_REL16,
  BFD_RELOC_METAG_HI16_GOTOFF,
  BFD_RELOC_METAG_LO16_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOTOFF,
  BFD_RELOC_METAG_GETSET_GOT,
  BFD_RELOC_METAG_HI16_GOTPC,
  BFD_RELOC_METAG_LO16_GOTPC,
  BFD_RELOC_METAG_HI16_PLT,
  BFD_RELOC_METAG_LO16_PLT,
  BFD_RELOC_METAG_RELBRANCH_PLT,
  BFD_RELOC_METAG_GOTOFF,
  BFD_RELOC_METAG_PLT,
  BFD_RELOC_METAG_COPY,
  BFD_RELOC_METAG_JMP_SLOT,
  BFD_RELOC_METAG_RELATIVE,
  BFD_RELOC_METAG_GLOB_DAT,
  BFD_RELOC_METAG_TLS_GD,
  BFD_RELOC_METAG_TLS_LDM,
  BFD_RELOC_METAG_TLS_LDO_HI16,
  BFD_RELOC_METAG_TLS_LDO_LO16,
  BFD_RELOC_METAG_TLS_LDO,
  BFD_RELOC_METAG_TLS_IE,
  BFD_RELOC_METAG_TLS_IENONPIC,
  BFD_RELOC_METAG_TLS_IENONPIC_HI16,
  BFD_RELOC_METAG_TLS_IENONPIC_LO16,
  BFD_RELOC_METAG_TLS_TPOFF,
  BFD_RELOC_METAG_TLS_DTPMOD,
  BFD_RELOC_METAG_TLS_DTPOFF,
  BFD_RELOC_METAG_TLS_LE,
  BFD_RELOC_METAG_TLS_LE_HI16,
  BFD_RELOC_METAG_TLS_LE_LO16,


  BFD_RELOC_MMIX_GETA,
  BFD_RELOC_MMIX_GETA_1,
  BFD_RELOC_MMIX_GETA_2,
  BFD_RELOC_MMIX_GETA_3,


  BFD_RELOC_MMIX_CBRANCH,
  BFD_RELOC_MMIX_CBRANCH_J,
  BFD_RELOC_MMIX_CBRANCH_1,
  BFD_RELOC_MMIX_CBRANCH_2,
  BFD_RELOC_MMIX_CBRANCH_3,


  BFD_RELOC_MMIX_PUSHJ,
  BFD_RELOC_MMIX_PUSHJ_1,
  BFD_RELOC_MMIX_PUSHJ_2,
  BFD_RELOC_MMIX_PUSHJ_3,
  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,


  BFD_RELOC_MMIX_JMP,
  BFD_RELOC_MMIX_JMP_1,
  BFD_RELOC_MMIX_JMP_2,
  BFD_RELOC_MMIX_JMP_3,



  BFD_RELOC_MMIX_ADDR19,


  BFD_RELOC_MMIX_ADDR27,



  BFD_RELOC_MMIX_REG_OR_BYTE,



  BFD_RELOC_MMIX_REG,



  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,



  BFD_RELOC_MMIX_LOCAL,



  BFD_RELOC_AVR_7_PCREL,



  BFD_RELOC_AVR_13_PCREL,



  BFD_RELOC_AVR_16_PM,



  BFD_RELOC_AVR_LO8_LDI,



  BFD_RELOC_AVR_HI8_LDI,



  BFD_RELOC_AVR_HH8_LDI,



  BFD_RELOC_AVR_MS8_LDI,



  BFD_RELOC_AVR_LO8_LDI_NEG,




  BFD_RELOC_AVR_HI8_LDI_NEG,




  BFD_RELOC_AVR_HH8_LDI_NEG,



  BFD_RELOC_AVR_MS8_LDI_NEG,



  BFD_RELOC_AVR_LO8_LDI_PM,





  BFD_RELOC_AVR_LO8_LDI_GS,



  BFD_RELOC_AVR_HI8_LDI_PM,





  BFD_RELOC_AVR_HI8_LDI_GS,



  BFD_RELOC_AVR_HH8_LDI_PM,



  BFD_RELOC_AVR_LO8_LDI_PM_NEG,




  BFD_RELOC_AVR_HI8_LDI_PM_NEG,




  BFD_RELOC_AVR_HH8_LDI_PM_NEG,



  BFD_RELOC_AVR_CALL,



  BFD_RELOC_AVR_LDI,



  BFD_RELOC_AVR_6,



  BFD_RELOC_AVR_6_ADIW,



  BFD_RELOC_AVR_8_LO,



  BFD_RELOC_AVR_8_HI,



  BFD_RELOC_AVR_8_HLO,







  BFD_RELOC_AVR_DIFF8,
  BFD_RELOC_AVR_DIFF16,
  BFD_RELOC_AVR_DIFF32,



  BFD_RELOC_AVR_LDS_STS_16,



  BFD_RELOC_AVR_PORT6,



  BFD_RELOC_AVR_PORT5,


  BFD_RELOC_RISCV_HI20,
  BFD_RELOC_RISCV_PCREL_HI20,
  BFD_RELOC_RISCV_PCREL_LO12_I,
  BFD_RELOC_RISCV_PCREL_LO12_S,
  BFD_RELOC_RISCV_LO12_I,
  BFD_RELOC_RISCV_LO12_S,
  BFD_RELOC_RISCV_GPREL12_I,
  BFD_RELOC_RISCV_GPREL12_S,
  BFD_RELOC_RISCV_TPREL_HI20,
  BFD_RELOC_RISCV_TPREL_LO12_I,
  BFD_RELOC_RISCV_TPREL_LO12_S,
  BFD_RELOC_RISCV_TPREL_ADD,
  BFD_RELOC_RISCV_CALL,
  BFD_RELOC_RISCV_CALL_PLT,
  BFD_RELOC_RISCV_ADD8,
  BFD_RELOC_RISCV_ADD16,
  BFD_RELOC_RISCV_ADD32,
  BFD_RELOC_RISCV_ADD64,
  BFD_RELOC_RISCV_SUB8,
  BFD_RELOC_RISCV_SUB16,
  BFD_RELOC_RISCV_SUB32,
  BFD_RELOC_RISCV_SUB64,
  BFD_RELOC_RISCV_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GOT_HI20,
  BFD_RELOC_RISCV_TLS_GD_HI20,
  BFD_RELOC_RISCV_JMP,
  BFD_RELOC_RISCV_TLS_DTPMOD32,
  BFD_RELOC_RISCV_TLS_DTPREL32,
  BFD_RELOC_RISCV_TLS_DTPMOD64,
  BFD_RELOC_RISCV_TLS_DTPREL64,
  BFD_RELOC_RISCV_TLS_TPREL32,
  BFD_RELOC_RISCV_TLS_TPREL64,
  BFD_RELOC_RISCV_ALIGN,
  BFD_RELOC_RISCV_RVC_BRANCH,
  BFD_RELOC_RISCV_RVC_JUMP,
  BFD_RELOC_RISCV_RVC_LUI,
  BFD_RELOC_RISCV_GPREL_I,
  BFD_RELOC_RISCV_GPREL_S,
  BFD_RELOC_RISCV_TPREL_I,
  BFD_RELOC_RISCV_TPREL_S,
  BFD_RELOC_RISCV_RELAX,
  BFD_RELOC_RISCV_CFA,
  BFD_RELOC_RISCV_SUB6,
  BFD_RELOC_RISCV_SET6,
  BFD_RELOC_RISCV_SET8,
  BFD_RELOC_RISCV_SET16,
  BFD_RELOC_RISCV_SET32,
  BFD_RELOC_RISCV_32_PCREL,


  BFD_RELOC_RL78_NEG8,
  BFD_RELOC_RL78_NEG16,
  BFD_RELOC_RL78_NEG24,
  BFD_RELOC_RL78_NEG32,
  BFD_RELOC_RL78_16_OP,
  BFD_RELOC_RL78_24_OP,
  BFD_RELOC_RL78_32_OP,
  BFD_RELOC_RL78_8U,
  BFD_RELOC_RL78_16U,
  BFD_RELOC_RL78_24U,
  BFD_RELOC_RL78_DIR3U_PCREL,
  BFD_RELOC_RL78_DIFF,
  BFD_RELOC_RL78_GPRELB,
  BFD_RELOC_RL78_GPRELW,
  BFD_RELOC_RL78_GPRELL,
  BFD_RELOC_RL78_SYM,
  BFD_RELOC_RL78_OP_SUBTRACT,
  BFD_RELOC_RL78_OP_NEG,
  BFD_RELOC_RL78_OP_AND,
  BFD_RELOC_RL78_OP_SHRA,
  BFD_RELOC_RL78_ABS8,
  BFD_RELOC_RL78_ABS16,
  BFD_RELOC_RL78_ABS16_REV,
  BFD_RELOC_RL78_ABS32,
  BFD_RELOC_RL78_ABS32_REV,
  BFD_RELOC_RL78_ABS16U,
  BFD_RELOC_RL78_ABS16UW,
  BFD_RELOC_RL78_ABS16UL,
  BFD_RELOC_RL78_RELAX,
  BFD_RELOC_RL78_HI16,
  BFD_RELOC_RL78_HI8,
  BFD_RELOC_RL78_LO16,
  BFD_RELOC_RL78_CODE,
  BFD_RELOC_RL78_SADDR,


  BFD_RELOC_RX_NEG8,
  BFD_RELOC_RX_NEG16,
  BFD_RELOC_RX_NEG24,
  BFD_RELOC_RX_NEG32,
  BFD_RELOC_RX_16_OP,
  BFD_RELOC_RX_24_OP,
  BFD_RELOC_RX_32_OP,
  BFD_RELOC_RX_8U,
  BFD_RELOC_RX_16U,
  BFD_RELOC_RX_24U,
  BFD_RELOC_RX_DIR3U_PCREL,
  BFD_RELOC_RX_DIFF,
  BFD_RELOC_RX_GPRELB,
  BFD_RELOC_RX_GPRELW,
  BFD_RELOC_RX_GPRELL,
  BFD_RELOC_RX_SYM,
  BFD_RELOC_RX_OP_SUBTRACT,
  BFD_RELOC_RX_OP_NEG,
  BFD_RELOC_RX_ABS8,
  BFD_RELOC_RX_ABS16,
  BFD_RELOC_RX_ABS16_REV,
  BFD_RELOC_RX_ABS32,
  BFD_RELOC_RX_ABS32_REV,
  BFD_RELOC_RX_ABS16U,
  BFD_RELOC_RX_ABS16UW,
  BFD_RELOC_RX_ABS16UL,
  BFD_RELOC_RX_RELAX,


  BFD_RELOC_390_12,


  BFD_RELOC_390_GOT12,


  BFD_RELOC_390_PLT32,


  BFD_RELOC_390_COPY,


  BFD_RELOC_390_GLOB_DAT,


  BFD_RELOC_390_JMP_SLOT,


  BFD_RELOC_390_RELATIVE,


  BFD_RELOC_390_GOTPC,


  BFD_RELOC_390_GOT16,


  BFD_RELOC_390_PC12DBL,


  BFD_RELOC_390_PLT12DBL,


  BFD_RELOC_390_PC16DBL,


  BFD_RELOC_390_PLT16DBL,


  BFD_RELOC_390_PC24DBL,


  BFD_RELOC_390_PLT24DBL,


  BFD_RELOC_390_PC32DBL,


  BFD_RELOC_390_PLT32DBL,


  BFD_RELOC_390_GOTPCDBL,


  BFD_RELOC_390_GOT64,


  BFD_RELOC_390_PLT64,


  BFD_RELOC_390_GOTENT,


  BFD_RELOC_390_GOTOFF64,


  BFD_RELOC_390_GOTPLT12,


  BFD_RELOC_390_GOTPLT16,


  BFD_RELOC_390_GOTPLT32,


  BFD_RELOC_390_GOTPLT64,


  BFD_RELOC_390_GOTPLTENT,


  BFD_RELOC_390_PLTOFF16,


  BFD_RELOC_390_PLTOFF32,


  BFD_RELOC_390_PLTOFF64,


  BFD_RELOC_390_TLS_LOAD,
  BFD_RELOC_390_TLS_GDCALL,
  BFD_RELOC_390_TLS_LDCALL,
  BFD_RELOC_390_TLS_GD32,
  BFD_RELOC_390_TLS_GD64,
  BFD_RELOC_390_TLS_GOTIE12,
  BFD_RELOC_390_TLS_GOTIE32,
  BFD_RELOC_390_TLS_GOTIE64,
  BFD_RELOC_390_TLS_LDM32,
  BFD_RELOC_390_TLS_LDM64,
  BFD_RELOC_390_TLS_IE32,
  BFD_RELOC_390_TLS_IE64,
  BFD_RELOC_390_TLS_IEENT,
  BFD_RELOC_390_TLS_LE32,
  BFD_RELOC_390_TLS_LE64,
  BFD_RELOC_390_TLS_LDO32,
  BFD_RELOC_390_TLS_LDO64,
  BFD_RELOC_390_TLS_DTPMOD,
  BFD_RELOC_390_TLS_DTPOFF,
  BFD_RELOC_390_TLS_TPOFF,


  BFD_RELOC_390_20,
  BFD_RELOC_390_GOT20,
  BFD_RELOC_390_GOTPLT20,
  BFD_RELOC_390_TLS_GOTIE20,


  BFD_RELOC_390_IRELATIVE,



  BFD_RELOC_SCORE_GPREL15,


  BFD_RELOC_SCORE_DUMMY2,
  BFD_RELOC_SCORE_JMP,


  BFD_RELOC_SCORE_BRANCH,


  BFD_RELOC_SCORE_IMM30,


  BFD_RELOC_SCORE_IMM32,


  BFD_RELOC_SCORE16_JMP,


  BFD_RELOC_SCORE16_BRANCH,


  BFD_RELOC_SCORE_BCMP,


  BFD_RELOC_SCORE_GOT15,
  BFD_RELOC_SCORE_GOT_LO16,
  BFD_RELOC_SCORE_CALL15,
  BFD_RELOC_SCORE_DUMMY_HI16,


  BFD_RELOC_IP2K_FR9,


  BFD_RELOC_IP2K_BANK,


  BFD_RELOC_IP2K_ADDR16CJP,


  BFD_RELOC_IP2K_PAGE3,


  BFD_RELOC_IP2K_LO8DATA,
  BFD_RELOC_IP2K_HI8DATA,
  BFD_RELOC_IP2K_EX8DATA,


  BFD_RELOC_IP2K_LO8INSN,
  BFD_RELOC_IP2K_HI8INSN,


  BFD_RELOC_IP2K_PC_SKIP,


  BFD_RELOC_IP2K_TEXT,


  BFD_RELOC_IP2K_FR_OFFSET,


  BFD_RELOC_VPE4KMATH_DATA,
  BFD_RELOC_VPE4KMATH_INSN,
# 5046 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  BFD_RELOC_VTABLE_INHERIT,
  BFD_RELOC_VTABLE_ENTRY,


  BFD_RELOC_IA64_IMM14,
  BFD_RELOC_IA64_IMM22,
  BFD_RELOC_IA64_IMM64,
  BFD_RELOC_IA64_DIR32MSB,
  BFD_RELOC_IA64_DIR32LSB,
  BFD_RELOC_IA64_DIR64MSB,
  BFD_RELOC_IA64_DIR64LSB,
  BFD_RELOC_IA64_GPREL22,
  BFD_RELOC_IA64_GPREL64I,
  BFD_RELOC_IA64_GPREL32MSB,
  BFD_RELOC_IA64_GPREL32LSB,
  BFD_RELOC_IA64_GPREL64MSB,
  BFD_RELOC_IA64_GPREL64LSB,
  BFD_RELOC_IA64_LTOFF22,
  BFD_RELOC_IA64_LTOFF64I,
  BFD_RELOC_IA64_PLTOFF22,
  BFD_RELOC_IA64_PLTOFF64I,
  BFD_RELOC_IA64_PLTOFF64MSB,
  BFD_RELOC_IA64_PLTOFF64LSB,
  BFD_RELOC_IA64_FPTR64I,
  BFD_RELOC_IA64_FPTR32MSB,
  BFD_RELOC_IA64_FPTR32LSB,
  BFD_RELOC_IA64_FPTR64MSB,
  BFD_RELOC_IA64_FPTR64LSB,
  BFD_RELOC_IA64_PCREL21B,
  BFD_RELOC_IA64_PCREL21BI,
  BFD_RELOC_IA64_PCREL21M,
  BFD_RELOC_IA64_PCREL21F,
  BFD_RELOC_IA64_PCREL22,
  BFD_RELOC_IA64_PCREL60B,
  BFD_RELOC_IA64_PCREL64I,
  BFD_RELOC_IA64_PCREL32MSB,
  BFD_RELOC_IA64_PCREL32LSB,
  BFD_RELOC_IA64_PCREL64MSB,
  BFD_RELOC_IA64_PCREL64LSB,
  BFD_RELOC_IA64_LTOFF_FPTR22,
  BFD_RELOC_IA64_LTOFF_FPTR64I,
  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
  BFD_RELOC_IA64_SEGREL32MSB,
  BFD_RELOC_IA64_SEGREL32LSB,
  BFD_RELOC_IA64_SEGREL64MSB,
  BFD_RELOC_IA64_SEGREL64LSB,
  BFD_RELOC_IA64_SECREL32MSB,
  BFD_RELOC_IA64_SECREL32LSB,
  BFD_RELOC_IA64_SECREL64MSB,
  BFD_RELOC_IA64_SECREL64LSB,
  BFD_RELOC_IA64_REL32MSB,
  BFD_RELOC_IA64_REL32LSB,
  BFD_RELOC_IA64_REL64MSB,
  BFD_RELOC_IA64_REL64LSB,
  BFD_RELOC_IA64_LTV32MSB,
  BFD_RELOC_IA64_LTV32LSB,
  BFD_RELOC_IA64_LTV64MSB,
  BFD_RELOC_IA64_LTV64LSB,
  BFD_RELOC_IA64_IPLTMSB,
  BFD_RELOC_IA64_IPLTLSB,
  BFD_RELOC_IA64_COPY,
  BFD_RELOC_IA64_LTOFF22X,
  BFD_RELOC_IA64_LDXMOV,
  BFD_RELOC_IA64_TPREL14,
  BFD_RELOC_IA64_TPREL22,
  BFD_RELOC_IA64_TPREL64I,
  BFD_RELOC_IA64_TPREL64MSB,
  BFD_RELOC_IA64_TPREL64LSB,
  BFD_RELOC_IA64_LTOFF_TPREL22,
  BFD_RELOC_IA64_DTPMOD64MSB,
  BFD_RELOC_IA64_DTPMOD64LSB,
  BFD_RELOC_IA64_LTOFF_DTPMOD22,
  BFD_RELOC_IA64_DTPREL14,
  BFD_RELOC_IA64_DTPREL22,
  BFD_RELOC_IA64_DTPREL64I,
  BFD_RELOC_IA64_DTPREL32MSB,
  BFD_RELOC_IA64_DTPREL32LSB,
  BFD_RELOC_IA64_DTPREL64MSB,
  BFD_RELOC_IA64_DTPREL64LSB,
  BFD_RELOC_IA64_LTOFF_DTPREL22,



  BFD_RELOC_M68HC11_HI8,



  BFD_RELOC_M68HC11_LO8,



  BFD_RELOC_M68HC11_3B,






  BFD_RELOC_M68HC11_RL_JUMP,





  BFD_RELOC_M68HC11_RL_GROUP,





  BFD_RELOC_M68HC11_LO16,





  BFD_RELOC_M68HC11_PAGE,





  BFD_RELOC_M68HC11_24,



  BFD_RELOC_M68HC12_5B,



  BFD_RELOC_XGATE_RL_JUMP,





  BFD_RELOC_XGATE_RL_GROUP,




  BFD_RELOC_XGATE_LO16,


  BFD_RELOC_XGATE_GPAGE,


  BFD_RELOC_XGATE_24,



  BFD_RELOC_XGATE_PCREL_9,



  BFD_RELOC_XGATE_PCREL_10,




  BFD_RELOC_XGATE_IMM8_LO,




  BFD_RELOC_XGATE_IMM8_HI,



  BFD_RELOC_XGATE_IMM3,



  BFD_RELOC_XGATE_IMM4,



  BFD_RELOC_XGATE_IMM5,



  BFD_RELOC_M68HC12_9B,



  BFD_RELOC_M68HC12_16B,



  BFD_RELOC_M68HC12_9_PCREL,



  BFD_RELOC_M68HC12_10_PCREL,




  BFD_RELOC_M68HC12_LO8XG,




  BFD_RELOC_M68HC12_HI8XG,


  BFD_RELOC_16C_NUM08,
  BFD_RELOC_16C_NUM08_C,
  BFD_RELOC_16C_NUM16,
  BFD_RELOC_16C_NUM16_C,
  BFD_RELOC_16C_NUM32,
  BFD_RELOC_16C_NUM32_C,
  BFD_RELOC_16C_DISP04,
  BFD_RELOC_16C_DISP04_C,
  BFD_RELOC_16C_DISP08,
  BFD_RELOC_16C_DISP08_C,
  BFD_RELOC_16C_DISP16,
  BFD_RELOC_16C_DISP16_C,
  BFD_RELOC_16C_DISP24,
  BFD_RELOC_16C_DISP24_C,
  BFD_RELOC_16C_DISP24a,
  BFD_RELOC_16C_DISP24a_C,
  BFD_RELOC_16C_REG04,
  BFD_RELOC_16C_REG04_C,
  BFD_RELOC_16C_REG04a,
  BFD_RELOC_16C_REG04a_C,
  BFD_RELOC_16C_REG14,
  BFD_RELOC_16C_REG14_C,
  BFD_RELOC_16C_REG16,
  BFD_RELOC_16C_REG16_C,
  BFD_RELOC_16C_REG20,
  BFD_RELOC_16C_REG20_C,
  BFD_RELOC_16C_ABS20,
  BFD_RELOC_16C_ABS20_C,
  BFD_RELOC_16C_ABS24,
  BFD_RELOC_16C_ABS24_C,
  BFD_RELOC_16C_IMM04,
  BFD_RELOC_16C_IMM04_C,
  BFD_RELOC_16C_IMM16,
  BFD_RELOC_16C_IMM16_C,
  BFD_RELOC_16C_IMM20,
  BFD_RELOC_16C_IMM20_C,
  BFD_RELOC_16C_IMM24,
  BFD_RELOC_16C_IMM24_C,
  BFD_RELOC_16C_IMM32,
  BFD_RELOC_16C_IMM32_C,


  BFD_RELOC_CR16_NUM8,
  BFD_RELOC_CR16_NUM16,
  BFD_RELOC_CR16_NUM32,
  BFD_RELOC_CR16_NUM32a,
  BFD_RELOC_CR16_REGREL0,
  BFD_RELOC_CR16_REGREL4,
  BFD_RELOC_CR16_REGREL4a,
  BFD_RELOC_CR16_REGREL14,
  BFD_RELOC_CR16_REGREL14a,
  BFD_RELOC_CR16_REGREL16,
  BFD_RELOC_CR16_REGREL20,
  BFD_RELOC_CR16_REGREL20a,
  BFD_RELOC_CR16_ABS20,
  BFD_RELOC_CR16_ABS24,
  BFD_RELOC_CR16_IMM4,
  BFD_RELOC_CR16_IMM8,
  BFD_RELOC_CR16_IMM16,
  BFD_RELOC_CR16_IMM20,
  BFD_RELOC_CR16_IMM24,
  BFD_RELOC_CR16_IMM32,
  BFD_RELOC_CR16_IMM32a,
  BFD_RELOC_CR16_DISP4,
  BFD_RELOC_CR16_DISP8,
  BFD_RELOC_CR16_DISP16,
  BFD_RELOC_CR16_DISP20,
  BFD_RELOC_CR16_DISP24,
  BFD_RELOC_CR16_DISP24a,
  BFD_RELOC_CR16_SWITCH8,
  BFD_RELOC_CR16_SWITCH16,
  BFD_RELOC_CR16_SWITCH32,
  BFD_RELOC_CR16_GOT_REGREL20,
  BFD_RELOC_CR16_GOTC_REGREL20,
  BFD_RELOC_CR16_GLOB_DAT,


  BFD_RELOC_CRX_REL4,
  BFD_RELOC_CRX_REL8,
  BFD_RELOC_CRX_REL8_CMP,
  BFD_RELOC_CRX_REL16,
  BFD_RELOC_CRX_REL24,
  BFD_RELOC_CRX_REL32,
  BFD_RELOC_CRX_REGREL12,
  BFD_RELOC_CRX_REGREL22,
  BFD_RELOC_CRX_REGREL28,
  BFD_RELOC_CRX_REGREL32,
  BFD_RELOC_CRX_ABS16,
  BFD_RELOC_CRX_ABS32,
  BFD_RELOC_CRX_NUM8,
  BFD_RELOC_CRX_NUM16,
  BFD_RELOC_CRX_NUM32,
  BFD_RELOC_CRX_IMM16,
  BFD_RELOC_CRX_IMM32,
  BFD_RELOC_CRX_SWITCH8,
  BFD_RELOC_CRX_SWITCH16,
  BFD_RELOC_CRX_SWITCH32,



  BFD_RELOC_CRIS_BDISP8,
  BFD_RELOC_CRIS_UNSIGNED_5,
  BFD_RELOC_CRIS_SIGNED_6,
  BFD_RELOC_CRIS_UNSIGNED_6,
  BFD_RELOC_CRIS_SIGNED_8,
  BFD_RELOC_CRIS_UNSIGNED_8,
  BFD_RELOC_CRIS_SIGNED_16,
  BFD_RELOC_CRIS_UNSIGNED_16,
  BFD_RELOC_CRIS_LAPCQ_OFFSET,
  BFD_RELOC_CRIS_UNSIGNED_4,


  BFD_RELOC_CRIS_COPY,
  BFD_RELOC_CRIS_GLOB_DAT,
  BFD_RELOC_CRIS_JUMP_SLOT,
  BFD_RELOC_CRIS_RELATIVE,


  BFD_RELOC_CRIS_32_GOT,


  BFD_RELOC_CRIS_16_GOT,


  BFD_RELOC_CRIS_32_GOTPLT,


  BFD_RELOC_CRIS_16_GOTPLT,


  BFD_RELOC_CRIS_32_GOTREL,


  BFD_RELOC_CRIS_32_PLT_GOTREL,


  BFD_RELOC_CRIS_32_PLT_PCREL,


  BFD_RELOC_CRIS_32_GOT_GD,
  BFD_RELOC_CRIS_16_GOT_GD,
  BFD_RELOC_CRIS_32_GD,
  BFD_RELOC_CRIS_DTP,
  BFD_RELOC_CRIS_32_DTPREL,
  BFD_RELOC_CRIS_16_DTPREL,
  BFD_RELOC_CRIS_32_GOT_TPREL,
  BFD_RELOC_CRIS_16_GOT_TPREL,
  BFD_RELOC_CRIS_32_TPREL,
  BFD_RELOC_CRIS_16_TPREL,
  BFD_RELOC_CRIS_DTPMOD,
  BFD_RELOC_CRIS_32_IE,


  BFD_RELOC_860_COPY,
  BFD_RELOC_860_GLOB_DAT,
  BFD_RELOC_860_JUMP_SLOT,
  BFD_RELOC_860_RELATIVE,
  BFD_RELOC_860_PC26,
  BFD_RELOC_860_PLT26,
  BFD_RELOC_860_PC16,
  BFD_RELOC_860_LOW0,
  BFD_RELOC_860_SPLIT0,
  BFD_RELOC_860_LOW1,
  BFD_RELOC_860_SPLIT1,
  BFD_RELOC_860_LOW2,
  BFD_RELOC_860_SPLIT2,
  BFD_RELOC_860_LOW3,
  BFD_RELOC_860_LOGOT0,
  BFD_RELOC_860_SPGOT0,
  BFD_RELOC_860_LOGOT1,
  BFD_RELOC_860_SPGOT1,
  BFD_RELOC_860_LOGOTOFF0,
  BFD_RELOC_860_SPGOTOFF0,
  BFD_RELOC_860_LOGOTOFF1,
  BFD_RELOC_860_SPGOTOFF1,
  BFD_RELOC_860_LOGOTOFF2,
  BFD_RELOC_860_LOGOTOFF3,
  BFD_RELOC_860_LOPC,
  BFD_RELOC_860_HIGHADJ,
  BFD_RELOC_860_HAGOT,
  BFD_RELOC_860_HAGOTOFF,
  BFD_RELOC_860_HAPC,
  BFD_RELOC_860_HIGH,
  BFD_RELOC_860_HIGOT,
  BFD_RELOC_860_HIGOTOFF,


  BFD_RELOC_OR1K_REL_26,
  BFD_RELOC_OR1K_GOTPC_HI16,
  BFD_RELOC_OR1K_GOTPC_LO16,
  BFD_RELOC_OR1K_GOT16,
  BFD_RELOC_OR1K_PLT26,
  BFD_RELOC_OR1K_GOTOFF_HI16,
  BFD_RELOC_OR1K_GOTOFF_LO16,
  BFD_RELOC_OR1K_COPY,
  BFD_RELOC_OR1K_GLOB_DAT,
  BFD_RELOC_OR1K_JMP_SLOT,
  BFD_RELOC_OR1K_RELATIVE,
  BFD_RELOC_OR1K_TLS_GD_HI16,
  BFD_RELOC_OR1K_TLS_GD_LO16,
  BFD_RELOC_OR1K_TLS_LDM_HI16,
  BFD_RELOC_OR1K_TLS_LDM_LO16,
  BFD_RELOC_OR1K_TLS_LDO_HI16,
  BFD_RELOC_OR1K_TLS_LDO_LO16,
  BFD_RELOC_OR1K_TLS_IE_HI16,
  BFD_RELOC_OR1K_TLS_IE_LO16,
  BFD_RELOC_OR1K_TLS_LE_HI16,
  BFD_RELOC_OR1K_TLS_LE_LO16,
  BFD_RELOC_OR1K_TLS_TPOFF,
  BFD_RELOC_OR1K_TLS_DTPOFF,
  BFD_RELOC_OR1K_TLS_DTPMOD,


  BFD_RELOC_H8_DIR16A8,
  BFD_RELOC_H8_DIR16R8,
  BFD_RELOC_H8_DIR24A8,
  BFD_RELOC_H8_DIR24R8,
  BFD_RELOC_H8_DIR32A16,
  BFD_RELOC_H8_DISP32A16,


  BFD_RELOC_XSTORMY16_REL_12,
  BFD_RELOC_XSTORMY16_12,
  BFD_RELOC_XSTORMY16_24,
  BFD_RELOC_XSTORMY16_FPTR16,


  BFD_RELOC_RELC,



  BFD_RELOC_XC16X_PAG,
  BFD_RELOC_XC16X_POF,
  BFD_RELOC_XC16X_SEG,
  BFD_RELOC_XC16X_SOF,


  BFD_RELOC_VAX_GLOB_DAT,
  BFD_RELOC_VAX_JMP_SLOT,
  BFD_RELOC_VAX_RELATIVE,


  BFD_RELOC_MT_PC16,


  BFD_RELOC_MT_HI16,


  BFD_RELOC_MT_LO16,


  BFD_RELOC_MT_GNU_VTINHERIT,


  BFD_RELOC_MT_GNU_VTENTRY,


  BFD_RELOC_MT_PCINSN8,


  BFD_RELOC_MSP430_10_PCREL,
  BFD_RELOC_MSP430_16_PCREL,
  BFD_RELOC_MSP430_16,
  BFD_RELOC_MSP430_16_PCREL_BYTE,
  BFD_RELOC_MSP430_16_BYTE,
  BFD_RELOC_MSP430_2X_PCREL,
  BFD_RELOC_MSP430_RL_PCREL,
  BFD_RELOC_MSP430_ABS8,
  BFD_RELOC_MSP430X_PCR20_EXT_SRC,
  BFD_RELOC_MSP430X_PCR20_EXT_DST,
  BFD_RELOC_MSP430X_PCR20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_EXT_SRC,
  BFD_RELOC_MSP430X_ABS20_EXT_DST,
  BFD_RELOC_MSP430X_ABS20_EXT_ODST,
  BFD_RELOC_MSP430X_ABS20_ADR_SRC,
  BFD_RELOC_MSP430X_ABS20_ADR_DST,
  BFD_RELOC_MSP430X_PCR16,
  BFD_RELOC_MSP430X_PCR20_CALL,
  BFD_RELOC_MSP430X_ABS16,
  BFD_RELOC_MSP430_ABS_HI16,
  BFD_RELOC_MSP430_PREL31,
  BFD_RELOC_MSP430_SYM_DIFF,


  BFD_RELOC_NIOS2_S16,
  BFD_RELOC_NIOS2_U16,
  BFD_RELOC_NIOS2_CALL26,
  BFD_RELOC_NIOS2_IMM5,
  BFD_RELOC_NIOS2_CACHE_OPX,
  BFD_RELOC_NIOS2_IMM6,
  BFD_RELOC_NIOS2_IMM8,
  BFD_RELOC_NIOS2_HI16,
  BFD_RELOC_NIOS2_LO16,
  BFD_RELOC_NIOS2_HIADJ16,
  BFD_RELOC_NIOS2_GPREL,
  BFD_RELOC_NIOS2_UJMP,
  BFD_RELOC_NIOS2_CJMP,
  BFD_RELOC_NIOS2_CALLR,
  BFD_RELOC_NIOS2_ALIGN,
  BFD_RELOC_NIOS2_GOT16,
  BFD_RELOC_NIOS2_CALL16,
  BFD_RELOC_NIOS2_GOTOFF_LO,
  BFD_RELOC_NIOS2_GOTOFF_HA,
  BFD_RELOC_NIOS2_PCREL_LO,
  BFD_RELOC_NIOS2_PCREL_HA,
  BFD_RELOC_NIOS2_TLS_GD16,
  BFD_RELOC_NIOS2_TLS_LDM16,
  BFD_RELOC_NIOS2_TLS_LDO16,
  BFD_RELOC_NIOS2_TLS_IE16,
  BFD_RELOC_NIOS2_TLS_LE16,
  BFD_RELOC_NIOS2_TLS_DTPMOD,
  BFD_RELOC_NIOS2_TLS_DTPREL,
  BFD_RELOC_NIOS2_TLS_TPREL,
  BFD_RELOC_NIOS2_COPY,
  BFD_RELOC_NIOS2_GLOB_DAT,
  BFD_RELOC_NIOS2_JUMP_SLOT,
  BFD_RELOC_NIOS2_RELATIVE,
  BFD_RELOC_NIOS2_GOTOFF,
  BFD_RELOC_NIOS2_CALL26_NOAT,
  BFD_RELOC_NIOS2_GOT_LO,
  BFD_RELOC_NIOS2_GOT_HA,
  BFD_RELOC_NIOS2_CALL_LO,
  BFD_RELOC_NIOS2_CALL_HA,
  BFD_RELOC_NIOS2_R2_S12,
  BFD_RELOC_NIOS2_R2_I10_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_1_PCREL,
  BFD_RELOC_NIOS2_R2_T1I7_2,
  BFD_RELOC_NIOS2_R2_T2I4,
  BFD_RELOC_NIOS2_R2_T2I4_1,
  BFD_RELOC_NIOS2_R2_T2I4_2,
  BFD_RELOC_NIOS2_R2_X1I7_2,
  BFD_RELOC_NIOS2_R2_X2L5,
  BFD_RELOC_NIOS2_R2_F1I5_2,
  BFD_RELOC_NIOS2_R2_L5I4X1,
  BFD_RELOC_NIOS2_R2_T1X1I6,
  BFD_RELOC_NIOS2_R2_T1X1I6_2,


  BFD_RELOC_PRU_U16,


  BFD_RELOC_PRU_U16_PMEMIMM,




  BFD_RELOC_PRU_LDI32,


  BFD_RELOC_PRU_S10_PCREL,


  BFD_RELOC_PRU_U8_PCREL,



  BFD_RELOC_PRU_32_PMEM,
  BFD_RELOC_PRU_16_PMEM,
# 5621 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  BFD_RELOC_PRU_GNU_DIFF8,
  BFD_RELOC_PRU_GNU_DIFF16,
  BFD_RELOC_PRU_GNU_DIFF32,
  BFD_RELOC_PRU_GNU_DIFF16_PMEM,
  BFD_RELOC_PRU_GNU_DIFF32_PMEM,


  BFD_RELOC_IQ2000_OFFSET_16,
  BFD_RELOC_IQ2000_OFFSET_21,
  BFD_RELOC_IQ2000_UHI16,




  BFD_RELOC_XTENSA_RTLD,


  BFD_RELOC_XTENSA_GLOB_DAT,
  BFD_RELOC_XTENSA_JMP_SLOT,
  BFD_RELOC_XTENSA_RELATIVE,



  BFD_RELOC_XTENSA_PLT,







  BFD_RELOC_XTENSA_DIFF8,
  BFD_RELOC_XTENSA_DIFF16,
  BFD_RELOC_XTENSA_DIFF32,





  BFD_RELOC_XTENSA_SLOT0_OP,
  BFD_RELOC_XTENSA_SLOT1_OP,
  BFD_RELOC_XTENSA_SLOT2_OP,
  BFD_RELOC_XTENSA_SLOT3_OP,
  BFD_RELOC_XTENSA_SLOT4_OP,
  BFD_RELOC_XTENSA_SLOT5_OP,
  BFD_RELOC_XTENSA_SLOT6_OP,
  BFD_RELOC_XTENSA_SLOT7_OP,
  BFD_RELOC_XTENSA_SLOT8_OP,
  BFD_RELOC_XTENSA_SLOT9_OP,
  BFD_RELOC_XTENSA_SLOT10_OP,
  BFD_RELOC_XTENSA_SLOT11_OP,
  BFD_RELOC_XTENSA_SLOT12_OP,
  BFD_RELOC_XTENSA_SLOT13_OP,
  BFD_RELOC_XTENSA_SLOT14_OP,



  BFD_RELOC_XTENSA_SLOT0_ALT,
  BFD_RELOC_XTENSA_SLOT1_ALT,
  BFD_RELOC_XTENSA_SLOT2_ALT,
  BFD_RELOC_XTENSA_SLOT3_ALT,
  BFD_RELOC_XTENSA_SLOT4_ALT,
  BFD_RELOC_XTENSA_SLOT5_ALT,
  BFD_RELOC_XTENSA_SLOT6_ALT,
  BFD_RELOC_XTENSA_SLOT7_ALT,
  BFD_RELOC_XTENSA_SLOT8_ALT,
  BFD_RELOC_XTENSA_SLOT9_ALT,
  BFD_RELOC_XTENSA_SLOT10_ALT,
  BFD_RELOC_XTENSA_SLOT11_ALT,
  BFD_RELOC_XTENSA_SLOT12_ALT,
  BFD_RELOC_XTENSA_SLOT13_ALT,
  BFD_RELOC_XTENSA_SLOT14_ALT,



  BFD_RELOC_XTENSA_OP0,
  BFD_RELOC_XTENSA_OP1,
  BFD_RELOC_XTENSA_OP2,




  BFD_RELOC_XTENSA_ASM_EXPAND,





  BFD_RELOC_XTENSA_ASM_SIMPLIFY,


  BFD_RELOC_XTENSA_TLSDESC_FN,
  BFD_RELOC_XTENSA_TLSDESC_ARG,
  BFD_RELOC_XTENSA_TLS_DTPOFF,
  BFD_RELOC_XTENSA_TLS_TPOFF,
  BFD_RELOC_XTENSA_TLS_FUNC,
  BFD_RELOC_XTENSA_TLS_ARG,
  BFD_RELOC_XTENSA_TLS_CALL,


  BFD_RELOC_Z80_DISP8,


  BFD_RELOC_Z8K_DISP7,


  BFD_RELOC_Z8K_CALLR,


  BFD_RELOC_Z8K_IMM4L,


  BFD_RELOC_LM32_CALL,
  BFD_RELOC_LM32_BRANCH,
  BFD_RELOC_LM32_16_GOT,
  BFD_RELOC_LM32_GOTOFF_HI16,
  BFD_RELOC_LM32_GOTOFF_LO16,
  BFD_RELOC_LM32_COPY,
  BFD_RELOC_LM32_GLOB_DAT,
  BFD_RELOC_LM32_JMP_SLOT,
  BFD_RELOC_LM32_RELATIVE,



  BFD_RELOC_MACH_O_SECTDIFF,


  BFD_RELOC_MACH_O_LOCAL_SECTDIFF,


  BFD_RELOC_MACH_O_PAIR,


  BFD_RELOC_MACH_O_SUBTRACTOR32,


  BFD_RELOC_MACH_O_SUBTRACTOR64,



  BFD_RELOC_MACH_O_X86_64_BRANCH32,
  BFD_RELOC_MACH_O_X86_64_BRANCH8,


  BFD_RELOC_MACH_O_X86_64_GOT,



  BFD_RELOC_MACH_O_X86_64_GOT_LOAD,


  BFD_RELOC_MACH_O_X86_64_PCREL32_1,


  BFD_RELOC_MACH_O_X86_64_PCREL32_2,


  BFD_RELOC_MACH_O_X86_64_PCREL32_4,


  BFD_RELOC_MACH_O_ARM64_ADDEND,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGE21,


  BFD_RELOC_MACH_O_ARM64_GOT_LOAD_PAGEOFF12,


  BFD_RELOC_MACH_O_ARM64_POINTER_TO_GOT,



  BFD_RELOC_MICROBLAZE_32_LO,



  BFD_RELOC_MICROBLAZE_32_LO_PCREL,



  BFD_RELOC_MICROBLAZE_32_ROSDA,



  BFD_RELOC_MICROBLAZE_32_RWSDA,



  BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM,




  BFD_RELOC_MICROBLAZE_64_NONE,




  BFD_RELOC_MICROBLAZE_64_GOTPC,




  BFD_RELOC_MICROBLAZE_64_GOT,




  BFD_RELOC_MICROBLAZE_64_PLT,




  BFD_RELOC_MICROBLAZE_64_GOTOFF,



  BFD_RELOC_MICROBLAZE_32_GOTOFF,



  BFD_RELOC_MICROBLAZE_COPY,


  BFD_RELOC_MICROBLAZE_64_TLS,




  BFD_RELOC_MICROBLAZE_64_TLSGD,




  BFD_RELOC_MICROBLAZE_64_TLSLD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPMOD,


  BFD_RELOC_MICROBLAZE_32_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSDTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL,



  BFD_RELOC_MICROBLAZE_64_TLSTPREL,





  BFD_RELOC_AARCH64_RELOC_START,


  BFD_RELOC_AARCH64_NULL,


  BFD_RELOC_AARCH64_NONE,




  BFD_RELOC_AARCH64_64,
  BFD_RELOC_AARCH64_32,
  BFD_RELOC_AARCH64_16,



  BFD_RELOC_AARCH64_64_PCREL,
  BFD_RELOC_AARCH64_32_PCREL,
  BFD_RELOC_AARCH64_16_PCREL,



  BFD_RELOC_AARCH64_MOVW_G0,



  BFD_RELOC_AARCH64_MOVW_G0_NC,



  BFD_RELOC_AARCH64_MOVW_G1,



  BFD_RELOC_AARCH64_MOVW_G1_NC,



  BFD_RELOC_AARCH64_MOVW_G2,



  BFD_RELOC_AARCH64_MOVW_G2_NC,



  BFD_RELOC_AARCH64_MOVW_G3,




  BFD_RELOC_AARCH64_MOVW_G0_S,




  BFD_RELOC_AARCH64_MOVW_G1_S,




  BFD_RELOC_AARCH64_MOVW_G2_S,




  BFD_RELOC_AARCH64_LD_LO19_PCREL,


  BFD_RELOC_AARCH64_ADR_LO21_PCREL,



  BFD_RELOC_AARCH64_ADR_HI21_PCREL,




  BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL,



  BFD_RELOC_AARCH64_ADD_LO12,



  BFD_RELOC_AARCH64_LDST8_LO12,




  BFD_RELOC_AARCH64_TSTBR14,




  BFD_RELOC_AARCH64_BRANCH19,




  BFD_RELOC_AARCH64_JUMP26,




  BFD_RELOC_AARCH64_CALL26,



  BFD_RELOC_AARCH64_LDST16_LO12,



  BFD_RELOC_AARCH64_LDST32_LO12,



  BFD_RELOC_AARCH64_LDST64_LO12,



  BFD_RELOC_AARCH64_LDST128_LO12,






  BFD_RELOC_AARCH64_GOT_LD_PREL19,




  BFD_RELOC_AARCH64_ADR_GOT_PAGE,




  BFD_RELOC_AARCH64_LD64_GOT_LO12_NC,




  BFD_RELOC_AARCH64_LD32_GOT_LO12_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G0_NC,



  BFD_RELOC_AARCH64_MOVW_GOTOFF_G1,



  BFD_RELOC_AARCH64_LD64_GOTOFF_LO15,


  BFD_RELOC_AARCH64_LD32_GOTPAGE_LO14,


  BFD_RELOC_AARCH64_LD64_GOTPAGE_LO15,





  BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSGD_ADR_PREL21,




  BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G0_NC,


  BFD_RELOC_AARCH64_TLSGD_MOVW_G1,


  BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21,


  BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD32_GOTTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_HI12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_ADD_DTPREL_LO12_NC,




  BFD_RELOC_AARCH64_TLSLD_ADD_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSLD_ADR_PREL21,



  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLD_MOVW_DTPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0,


  BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12,


  BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_LD_PREL19,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21,


  BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE21,


  BFD_RELOC_AARCH64_TLSDESC_LD64_LO12,


  BFD_RELOC_AARCH64_TLSDESC_LD32_LO12_NC,


  BFD_RELOC_AARCH64_TLSDESC_ADD_LO12,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G1,


  BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC,


  BFD_RELOC_AARCH64_TLSDESC_LDR,


  BFD_RELOC_AARCH64_TLSDESC_ADD,


  BFD_RELOC_AARCH64_TLSDESC_CALL,


  BFD_RELOC_AARCH64_COPY,


  BFD_RELOC_AARCH64_GLOB_DAT,


  BFD_RELOC_AARCH64_JUMP_SLOT,


  BFD_RELOC_AARCH64_RELATIVE,


  BFD_RELOC_AARCH64_TLS_DTPMOD,


  BFD_RELOC_AARCH64_TLS_DTPREL,


  BFD_RELOC_AARCH64_TLS_TPREL,


  BFD_RELOC_AARCH64_TLSDESC,


  BFD_RELOC_AARCH64_IRELATIVE,






  BFD_RELOC_AARCH64_RELOC_END,



  BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP,



  BFD_RELOC_AARCH64_LDST_LO12,




  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12,


  BFD_RELOC_AARCH64_TLSLD_LDST_DTPREL_LO12_NC,



  BFD_RELOC_AARCH64_LD_GOT_LO12_NC,



  BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_LO12_NC,



  BFD_RELOC_AARCH64_TLSDESC_LD_LO12_NC,


  BFD_RELOC_TILEPRO_COPY,
  BFD_RELOC_TILEPRO_GLOB_DAT,
  BFD_RELOC_TILEPRO_JMP_SLOT,
  BFD_RELOC_TILEPRO_RELATIVE,
  BFD_RELOC_TILEPRO_BROFF_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1,
  BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT,
  BFD_RELOC_TILEPRO_IMM8_X0,
  BFD_RELOC_TILEPRO_IMM8_Y0,
  BFD_RELOC_TILEPRO_IMM8_X1,
  BFD_RELOC_TILEPRO_IMM8_Y1,
  BFD_RELOC_TILEPRO_DEST_IMM8_X1,
  BFD_RELOC_TILEPRO_MT_IMM15_X1,
  BFD_RELOC_TILEPRO_MF_IMM15_X1,
  BFD_RELOC_TILEPRO_IMM16_X0,
  BFD_RELOC_TILEPRO_IMM16_X1,
  BFD_RELOC_TILEPRO_IMM16_X0_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA,
  BFD_RELOC_TILEPRO_MMSTART_X0,
  BFD_RELOC_TILEPRO_MMEND_X0,
  BFD_RELOC_TILEPRO_MMSTART_X1,
  BFD_RELOC_TILEPRO_MMEND_X1,
  BFD_RELOC_TILEPRO_SHAMT_X0,
  BFD_RELOC_TILEPRO_SHAMT_X1,
  BFD_RELOC_TILEPRO_SHAMT_Y0,
  BFD_RELOC_TILEPRO_SHAMT_Y1,
  BFD_RELOC_TILEPRO_TLS_GD_CALL,
  BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEPRO_TLS_IE_LOAD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA,
  BFD_RELOC_TILEPRO_TLS_DTPMOD32,
  BFD_RELOC_TILEPRO_TLS_DTPOFF32,
  BFD_RELOC_TILEPRO_TLS_TPOFF32,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI,
  BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA,
  BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA,


  BFD_RELOC_TILEGX_HW0,
  BFD_RELOC_TILEGX_HW1,
  BFD_RELOC_TILEGX_HW2,
  BFD_RELOC_TILEGX_HW3,
  BFD_RELOC_TILEGX_HW0_LAST,
  BFD_RELOC_TILEGX_HW1_LAST,
  BFD_RELOC_TILEGX_HW2_LAST,
  BFD_RELOC_TILEGX_COPY,
  BFD_RELOC_TILEGX_GLOB_DAT,
  BFD_RELOC_TILEGX_JMP_SLOT,
  BFD_RELOC_TILEGX_RELATIVE,
  BFD_RELOC_TILEGX_BROFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1,
  BFD_RELOC_TILEGX_JUMPOFF_X1_PLT,
  BFD_RELOC_TILEGX_IMM8_X0,
  BFD_RELOC_TILEGX_IMM8_Y0,
  BFD_RELOC_TILEGX_IMM8_X1,
  BFD_RELOC_TILEGX_IMM8_Y1,
  BFD_RELOC_TILEGX_DEST_IMM8_X1,
  BFD_RELOC_TILEGX_MT_IMM14_X1,
  BFD_RELOC_TILEGX_MF_IMM14_X1,
  BFD_RELOC_TILEGX_MMSTART_X0,
  BFD_RELOC_TILEGX_MMEND_X0,
  BFD_RELOC_TILEGX_SHAMT_X0,
  BFD_RELOC_TILEGX_SHAMT_X1,
  BFD_RELOC_TILEGX_SHAMT_Y0,
  BFD_RELOC_TILEGX_SHAMT_Y1,
  BFD_RELOC_TILEGX_IMM16_X0_HW0,
  BFD_RELOC_TILEGX_IMM16_X1_HW0,
  BFD_RELOC_TILEGX_IMM16_X0_HW1,
  BFD_RELOC_TILEGX_IMM16_X1_HW1,
  BFD_RELOC_TILEGX_IMM16_X0_HW2,
  BFD_RELOC_TILEGX_IMM16_X1_HW2,
  BFD_RELOC_TILEGX_IMM16_X0_HW3,
  BFD_RELOC_TILEGX_IMM16_X1_HW3,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT,
  BFD_RELOC_TILEGX_IMM16_X0_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW3_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PLT_PCREL,
  BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE,
  BFD_RELOC_TILEGX_TLS_DTPMOD64,
  BFD_RELOC_TILEGX_TLS_DTPOFF64,
  BFD_RELOC_TILEGX_TLS_TPOFF64,
  BFD_RELOC_TILEGX_TLS_DTPMOD32,
  BFD_RELOC_TILEGX_TLS_DTPOFF32,
  BFD_RELOC_TILEGX_TLS_TPOFF32,
  BFD_RELOC_TILEGX_TLS_GD_CALL,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD,
  BFD_RELOC_TILEGX_TLS_IE_LOAD,
  BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD,
  BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD,


  BFD_RELOC_EPIPHANY_SIMM8,


  BFD_RELOC_EPIPHANY_SIMM24,


  BFD_RELOC_EPIPHANY_HIGH,


  BFD_RELOC_EPIPHANY_LOW,


  BFD_RELOC_EPIPHANY_SIMM11,


  BFD_RELOC_EPIPHANY_IMM11,


  BFD_RELOC_EPIPHANY_IMM8,


  BFD_RELOC_VISIUM_HI16,
  BFD_RELOC_VISIUM_LO16,
  BFD_RELOC_VISIUM_IM16,
  BFD_RELOC_VISIUM_REL16,
  BFD_RELOC_VISIUM_HI16_PCREL,
  BFD_RELOC_VISIUM_LO16_PCREL,
  BFD_RELOC_VISIUM_IM16_PCREL,


  BFD_RELOC_WASM32_LEB128,
  BFD_RELOC_WASM32_LEB128_GOT,
  BFD_RELOC_WASM32_LEB128_GOT_CODE,
  BFD_RELOC_WASM32_LEB128_PLT,
  BFD_RELOC_WASM32_PLT_INDEX,
  BFD_RELOC_WASM32_ABS32_CODE,
  BFD_RELOC_WASM32_COPY,
  BFD_RELOC_WASM32_CODE_POINTER,
  BFD_RELOC_WASM32_INDEX,
  BFD_RELOC_WASM32_PLT_SIG,
  BFD_RELOC_UNUSED };

typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
reloc_howto_type *bfd_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code);
reloc_howto_type *bfd_reloc_name_lookup
   (bfd *abfd, const char *reloc_name);

const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);



typedef struct bfd_symbol
{
# 6522 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  struct bfd *the_bfd;



  const char *name;




  symvalue value;
# 6637 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  flagword flags;




  struct bfd_section *section;


  union
    {
      void *p;
      bfd_vma i;
    }
  udata;
}
asymbol;




bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);

bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);




bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);







bfd_boolean bfd_set_symtab
   (bfd *abfd, asymbol **location, unsigned int count);

void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);




asymbol *_bfd_generic_make_empty_symbol (bfd *);




int bfd_decode_symclass (asymbol *symbol);

bfd_boolean bfd_is_undefined_symclass (int symclass);

void bfd_symbol_info (asymbol *symbol, symbol_info *ret);

bfd_boolean bfd_copy_private_symbol_data
   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);







enum bfd_direction
  {
    no_direction = 0,
    read_direction = 1,
    write_direction = 2,
    both_direction = 3
  };

enum bfd_plugin_format
  {
    bfd_plugin_unknown = 0,
    bfd_plugin_yes = 1,
    bfd_plugin_no = 2
  };

struct bfd_build_id
  {
    bfd_size_type size;
    bfd_byte data[1];
  };

struct bfd
{

  const char *filename;


  const struct bfd_target *xvec;



  void *iostream;
  const struct bfd_iovec *iovec;



  struct bfd *lru_prev, *lru_next;



  ufile_ptr where;


  long mtime;


  unsigned int id;


  __extension__ enum bfd_format format : 3;


  __extension__ enum bfd_direction direction : 2;


  flagword flags : 20;
# 6856 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  unsigned int cacheable : 1;




  unsigned int target_defaulted : 1;


  unsigned int opened_once : 1;



  unsigned int mtime_set : 1;


  unsigned int no_export : 1;



  unsigned int output_has_begun : 1;


  unsigned int has_armap : 1;


  unsigned int is_thin_archive : 1;



  unsigned int selective_search : 1;


  unsigned int is_linker_output : 1;


  unsigned int is_linker_input : 1;


  __extension__ enum bfd_plugin_format plugin_format : 2;


  unsigned int lto_output : 1;



  bfd *plugin_dummy_bfd;




  ufile_ptr origin;






  ufile_ptr proxy_origin;


  struct bfd_hash_table section_htab;


  struct bfd_section *sections;


  struct bfd_section *section_last;


  unsigned int section_count;



  int archive_pass;



  bfd_vma start_address;



  struct bfd_symbol **outsymbols;


  unsigned int symcount;


  unsigned int dynsymcount;


  const struct bfd_arch_info *arch_info;


  void *arelt_data;
  struct bfd *my_archive;
  struct bfd *archive_next;
  struct bfd *archive_head;
  struct bfd *nested_archives;


  union {

    struct bfd *next;

    struct bfd_link_hash_table *hash;
  } link;


  union
    {
      struct aout_data_struct *aout_data;
      struct artdata *aout_ar_data;
      struct _oasys_data *oasys_obj_data;
      struct _oasys_ar_data *oasys_ar_data;
      struct coff_tdata *coff_obj_data;
      struct pe_tdata *pe_obj_data;
      struct xcoff_tdata *xcoff_obj_data;
      struct ecoff_tdata *ecoff_obj_data;
      struct ieee_data_struct *ieee_data;
      struct ieee_ar_data_struct *ieee_ar_data;
      struct srec_data_struct *srec_data;
      struct verilog_data_struct *verilog_data;
      struct ihex_data_struct *ihex_data;
      struct tekhex_data_struct *tekhex_data;
      struct elf_obj_tdata *elf_obj_data;
      struct nlm_obj_tdata *nlm_obj_data;
      struct bout_data_struct *bout_data;
      struct mmo_data_struct *mmo_data;
      struct sun_core_struct *sun_core_data;
      struct sco5_core_struct *sco5_core_data;
      struct trad_core_struct *trad_core_data;
      struct som_data_struct *som_data;
      struct hpux_core_struct *hpux_core_data;
      struct hppabsd_core_struct *hppabsd_core_data;
      struct sgi_core_struct *sgi_core_data;
      struct lynx_core_struct *lynx_core_data;
      struct osf_core_struct *osf_core_data;
      struct cisco_core_struct *cisco_core_data;
      struct versados_data_struct *versados_data;
      struct netbsd_core_struct *netbsd_core_data;
      struct mach_o_data_struct *mach_o_data;
      struct mach_o_fat_data_struct *mach_o_fat_data;
      struct plugin_data_struct *plugin_data;
      struct bfd_pef_data_struct *pef_data;
      struct bfd_pef_xlib_data_struct *pef_xlib_data;
      struct bfd_sym_data_struct *sym_data;
      void *any;
    }
  tdata;


  void *usrdata;




  void *memory;


  const struct bfd_build_id *build_id;
};


static inline bfd_boolean
bfd_set_cacheable (bfd * abfd, bfd_boolean val)
{
  abfd->cacheable = val;
  return 1;
}


typedef enum bfd_error
{
  bfd_error_no_error = 0,
  bfd_error_system_call,
  bfd_error_invalid_target,
  bfd_error_wrong_format,
  bfd_error_wrong_object_format,
  bfd_error_invalid_operation,
  bfd_error_no_memory,
  bfd_error_no_symbols,
  bfd_error_no_armap,
  bfd_error_no_more_archived_files,
  bfd_error_malformed_archive,
  bfd_error_missing_dso,
  bfd_error_file_not_recognized,
  bfd_error_file_ambiguously_recognized,
  bfd_error_no_contents,
  bfd_error_nonrepresentable_section,
  bfd_error_no_debug_section,
  bfd_error_bad_value,
  bfd_error_file_truncated,
  bfd_error_file_too_big,
  bfd_error_on_input,
  bfd_error_invalid_error_code
}
bfd_error_type;

bfd_error_type bfd_get_error (void);

void bfd_set_error (bfd_error_type error_tag, ...);

const char *bfd_errmsg (bfd_error_type error_tag);

void bfd_perror (const char *message);


typedef void (*bfd_error_handler_type) (const char *, va_list);

bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);

void bfd_set_error_program_name (const char *);


typedef void (*bfd_assert_handler_type) (const char *bfd_formatmsg,
                                         const char *bfd_version,
                                         const char *bfd_file,
                                         int bfd_line);

bfd_assert_handler_type bfd_set_assert_handler (bfd_assert_handler_type);

long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);

long bfd_canonicalize_reloc
   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);

void bfd_set_reloc
   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);



bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);

int bfd_get_arch_size (bfd *abfd);

int bfd_get_sign_extend_vma (bfd *abfd);

bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);

unsigned int bfd_get_gp_size (bfd *abfd);

void bfd_set_gp_size (bfd *abfd, unsigned int i);

bfd_vma bfd_scan_vma (const char *string, const char **end, int base);

bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);




bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);




bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
# 7205 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
extern bfd_byte *bfd_get_relocated_section_contents
  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
   bfd_boolean, asymbol **);

bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);

bfd_vma bfd_emul_get_maxpagesize (const char *);

void bfd_emul_set_maxpagesize (const char *, bfd_vma);

bfd_vma bfd_emul_get_commonpagesize (const char *);

void bfd_emul_set_commonpagesize (const char *, bfd_vma);

char *bfd_demangle (bfd *, const char *, int);

void bfd_update_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec);

bfd_boolean bfd_check_compression_header
   (bfd *abfd, bfd_byte *contents, asection *sec,
    bfd_size_type *uncompressed_size);

int bfd_get_compression_header_size (bfd *abfd, asection *sec);

bfd_size_type bfd_convert_section_size
   (bfd *ibfd, asection *isec, bfd *obfd, bfd_size_type size);

bfd_boolean bfd_convert_section_contents
   (bfd *ibfd, asection *isec, bfd *obfd,
    bfd_byte **ptr, bfd_size_type *ptr_size);


symindex bfd_get_next_mapent
   (bfd *abfd, symindex previous, carsym **sym);

bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);

bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);


const char *bfd_core_file_failing_command (bfd *abfd);

int bfd_core_file_failing_signal (bfd *abfd);

int bfd_core_file_pid (bfd *abfd);

bfd_boolean core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);

bfd_boolean generic_core_file_matches_executable_p
   (bfd *core_bfd, bfd *exec_bfd);
# 7280 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
enum bfd_flavour
{

  bfd_target_unknown_flavour,
  bfd_target_aout_flavour,
  bfd_target_coff_flavour,
  bfd_target_ecoff_flavour,
  bfd_target_xcoff_flavour,
  bfd_target_elf_flavour,
  bfd_target_ieee_flavour,
  bfd_target_nlm_flavour,
  bfd_target_oasys_flavour,
  bfd_target_tekhex_flavour,
  bfd_target_srec_flavour,
  bfd_target_verilog_flavour,
  bfd_target_ihex_flavour,
  bfd_target_som_flavour,
  bfd_target_os9k_flavour,
  bfd_target_versados_flavour,
  bfd_target_msdos_flavour,
  bfd_target_ovax_flavour,
  bfd_target_evax_flavour,
  bfd_target_mmo_flavour,
  bfd_target_mach_o_flavour,
  bfd_target_pef_flavour,
  bfd_target_pef_xlib_flavour,
  bfd_target_sym_flavour
};

enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };


typedef struct bfd_link_info _bfd_link_info;


typedef struct flag_info flag_info;

typedef struct bfd_target
{

  char *name;



  enum bfd_flavour flavour;


  enum bfd_endian byteorder;


  enum bfd_endian header_byteorder;



  flagword object_flags;



  flagword section_flags;



  char symbol_leading_char;


  char ar_pad_char;


  unsigned char ar_max_namelen;



  unsigned char match_priority;




  bfd_uint64_t (*bfd_getx64) (const void *);
  bfd_int64_t (*bfd_getx_signed_64) (const void *);
  void (*bfd_putx64) (bfd_uint64_t, void *);
  bfd_vma (*bfd_getx32) (const void *);
  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
  void (*bfd_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_getx16) (const void *);
  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
  void (*bfd_putx16) (bfd_vma, void *);


  bfd_uint64_t (*bfd_h_getx64) (const void *);
  bfd_int64_t (*bfd_h_getx_signed_64) (const void *);
  void (*bfd_h_putx64) (bfd_uint64_t, void *);
  bfd_vma (*bfd_h_getx32) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
  void (*bfd_h_putx32) (bfd_vma, void *);
  bfd_vma (*bfd_h_getx16) (const void *);
  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
  void (*bfd_h_putx16) (bfd_vma, void *);





  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);


  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);


  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
# 7400 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_boolean (*_close_and_cleanup) (bfd *);

  bfd_boolean (*_bfd_free_cached_info) (bfd *);

  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);

  bfd_boolean (*_bfd_get_section_contents)
    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
  bfd_boolean (*_bfd_get_section_contents_in_window)
    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
# 7424 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);


  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, struct bfd_link_info *);




  bfd_boolean (*_bfd_init_private_section_data)
    (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);


  bfd_boolean (*_bfd_copy_private_section_data)
    (bfd *, sec_ptr, bfd *, sec_ptr);


  bfd_boolean (*_bfd_copy_private_symbol_data)
    (bfd *, asymbol *, bfd *, asymbol *);


  bfd_boolean (*_bfd_copy_private_header_data)
    (bfd *, bfd *);

  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);


  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
# 7459 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  char * (*_core_file_failing_command) (bfd *);
  int (*_core_file_failing_signal) (bfd *);
  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
  int (*_core_file_pid) (bfd *);
# 7478 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  bfd_boolean (*_bfd_slurp_armap) (bfd *);
  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
  bfd_boolean (*_bfd_construct_extended_name_table)
    (bfd *, char **, bfd_size_type *, const char **);
  void (*_bfd_truncate_arname) (bfd *, const char *, char *);
  bfd_boolean (*write_armap)
    (bfd *, unsigned int, struct orl *, unsigned int, int);
  void * (*_bfd_read_ar_hdr_fn) (bfd *);
  bfd_boolean (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);
  bfd * (*openr_next_archived_file) (bfd *, bfd *);

  bfd * (*_bfd_get_elt_at_index) (bfd *, symindex);
  int (*_bfd_stat_arch_elt) (bfd *, struct stat *);
  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
# 7511 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  long (*_bfd_get_symtab_upper_bound) (bfd *);
  long (*_bfd_canonicalize_symtab)
    (bfd *, struct bfd_symbol **);
  struct bfd_symbol *
              (*_bfd_make_empty_symbol) (bfd *);
  void (*_bfd_print_symbol)
    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);

  void (*_bfd_get_symbol_info)
    (bfd *, struct bfd_symbol *, symbol_info *);

  const char *(*_bfd_get_symbol_version_string)
    (bfd *, struct bfd_symbol *, bfd_boolean *);

  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
  alent * (*_get_lineno) (bfd *, struct bfd_symbol *);
  bfd_boolean (*_bfd_find_nearest_line)
    (bfd *, struct bfd_symbol **, struct bfd_section *, bfd_vma,
     const char **, const char **, unsigned int *, unsigned int *);
  bfd_boolean (*_bfd_find_line)
    (bfd *, struct bfd_symbol **, struct bfd_symbol *,
     const char **, unsigned int *);
  bfd_boolean (*_bfd_find_inliner_info)
    (bfd *, const char **, const char **, unsigned int *);



  asymbol * (*_bfd_make_debug_symbol)
    (bfd *, void *, unsigned long size);


  long (*_read_minisymbols)
    (bfd *, bfd_boolean, void **, unsigned int *);


  asymbol * (*_minisymbol_to_symbol)
    (bfd *, bfd_boolean, const void *, asymbol *);
# 7558 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  long (*_get_reloc_upper_bound) (bfd *, sec_ptr);
  long (*_bfd_canonicalize_reloc)
    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
  void (*_bfd_set_reloc)
    (bfd *, sec_ptr, arelent **, unsigned int);

  reloc_howto_type *
              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
  reloc_howto_type *
              (*reloc_name_lookup) (bfd *, const char *);







  bfd_boolean (*_bfd_set_arch_mach)
    (bfd *, enum bfd_architecture, unsigned long);
  bfd_boolean (*_bfd_set_section_contents)
    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
# 7601 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  int (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
  bfd_byte * (*_bfd_get_relocated_section_contents)
    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
     bfd_byte *, bfd_boolean, struct bfd_symbol **);

  bfd_boolean (*_bfd_relax_section)
    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);



  struct bfd_link_hash_table *
              (*_bfd_link_hash_table_create) (bfd *);


  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);


  void (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);





  void (*_bfd_copy_link_hash_symbol_type)
    (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);



  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);


  bfd_boolean (* _bfd_link_check_relocs)(bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_lookup_section_flags) (struct bfd_link_info *,
                                            struct flag_info *,
                                            asection *);


  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);


  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);


  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);



  bfd_boolean (*_section_already_linked) (bfd *, asection *,
                                          struct bfd_link_info *);


  bfd_boolean (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,
                                            struct bfd_link_hash_entry *);


  struct bfd_link_hash_entry *(*_bfd_define_start_stop) (struct bfd_link_info *,
                                                         const char *,
                                                         asection *);
# 7677 "/doner/binutils/binutils-7a31b38/bfd/bfd.h"
  long (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_symtab)
    (bfd *, struct bfd_symbol **);

  long (*_bfd_get_synthetic_symtab)
    (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
     struct bfd_symbol **);

  long (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);

  long (*_bfd_canonicalize_dynamic_reloc)
    (bfd *, arelent **, struct bfd_symbol **);


  const struct bfd_target * alternative_target;



  const void *backend_data;

} bfd_target;

bfd_boolean bfd_set_default_target (const char *name);

const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);

const bfd_target *bfd_get_target_info (const char *target_name,
    bfd *abfd,
    bfd_boolean *is_bigendian,
    int *underscoring,
    const char **def_target_arch);
const char ** bfd_target_list (void);

const bfd_target *bfd_iterate_over_targets
   (int (*func) (const bfd_target *, void *),
    void *data);

const char *bfd_flavour_name (enum bfd_flavour flavour);


bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);

bfd_boolean bfd_check_format_matches
   (bfd *abfd, bfd_format format, char ***matching);

bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);

const char *bfd_format_string (bfd_format format);


bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);




bfd_boolean bfd_section_already_linked (bfd *abfd,
    asection *sec,
    struct bfd_link_info *info);




bfd_boolean bfd_generic_define_common_symbol
   (bfd *output_bfd, struct bfd_link_info *info,
    struct bfd_link_hash_entry *h);




struct bfd_link_hash_entry *bfd_generic_define_start_stop
   (struct bfd_link_info *info,
    const char *symbol, asection *sec);




struct bfd_elf_version_tree * bfd_find_version_for_sym
   (struct bfd_elf_version_tree *verdefs,
    const char *sym_name, bfd_boolean *hide);

bfd_boolean bfd_hide_sym_by_version
   (struct bfd_elf_version_tree *verdefs, const char *sym_name);

bfd_boolean bfd_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);

bfd_boolean _bfd_generic_link_check_relocs
   (bfd *abfd, struct bfd_link_info *info);

bfd_boolean bfd_merge_private_bfd_data
   (bfd *ibfd, struct bfd_link_info *info);





bfd_byte *bfd_simple_get_relocated_section_contents
   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);


bfd_boolean bfd_get_full_section_contents
   (bfd *abfd, asection *section, bfd_byte **ptr);

void bfd_cache_section_contents
   (asection *sec, void *contents);

bfd_boolean bfd_is_section_compressed_with_header
   (bfd *abfd, asection *section,
    int *compression_header_size_p,
    bfd_size_type *uncompressed_size_p);

bfd_boolean bfd_is_section_compressed
   (bfd *abfd, asection *section);

bfd_boolean bfd_init_section_decompress_status
   (bfd *abfd, asection *section);

bfd_boolean bfd_init_section_compress_status
   (bfd *abfd, asection *section);

bfd_boolean bfd_compress_section
   (bfd *abfd, asection *section, bfd_byte *uncompressed_buffer);
# 39 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 2
# 1 "./../include/bfdlink.h" 1
# 26 "./../include/bfdlink.h"
enum bfd_link_strip
{
  strip_none,
  strip_debugger,
  strip_some,
  strip_all
};



enum bfd_link_discard
{
  discard_sec_merge,

  discard_none,
  discard_l,
  discard_all
};



enum bfd_link_elf_stt_common
{
  unchanged,
  elf_stt_common,
  no_elf_stt_common
};




enum bfd_link_hash_table_type
  {
    bfd_link_generic_hash_table,
    bfd_link_elf_hash_table
  };




enum bfd_link_hash_type
{
  bfd_link_hash_new,
  bfd_link_hash_undefined,
  bfd_link_hash_undefweak,
  bfd_link_hash_defined,
  bfd_link_hash_defweak,
  bfd_link_hash_common,
  bfd_link_hash_indirect,
  bfd_link_hash_warning
};

enum bfd_link_common_skip_ar_symbols
{
  bfd_link_common_skip_none,
  bfd_link_common_skip_text,
  bfd_link_common_skip_data,
  bfd_link_common_skip_all
};

struct bfd_link_hash_common_entry
  {
    unsigned int alignment_power;
    asection *section;
  };




struct bfd_link_hash_entry
{

  struct bfd_hash_entry root;


  __extension__ enum bfd_link_hash_type type : 8;



  unsigned int non_ir_ref_regular : 1;



  unsigned int non_ir_ref_dynamic : 1;



  unsigned int linker_def : 1;


  unsigned int ldscript_def : 1;


  union
    {


      struct
 {
# 144 "./../include/bfdlink.h"
   struct bfd_link_hash_entry *next;

   bfd *abfd;
 } undef;

      struct
 {
   struct bfd_link_hash_entry *next;

   asection *section;

   bfd_vma value;
 } def;

      struct
 {
   struct bfd_link_hash_entry *next;

   struct bfd_link_hash_entry *link;

   const char *warning;
 } i;

      struct
 {
   struct bfd_link_hash_entry *next;
# 179 "./../include/bfdlink.h"
   struct bfd_link_hash_common_entry *p;

   bfd_size_type size;
 } c;
    } u;
};




struct bfd_link_hash_table
{

  struct bfd_hash_table table;


  struct bfd_link_hash_entry *undefs;

  struct bfd_link_hash_entry *undefs_tail;

  void (*hash_table_free) (bfd *);

  enum bfd_link_hash_table_type type;
};




extern struct bfd_link_hash_entry *bfd_link_hash_lookup
  (struct bfd_link_hash_table *, const char *, bfd_boolean create,
   bfd_boolean copy, bfd_boolean follow);





extern struct bfd_link_hash_entry *bfd_wrapped_link_hash_lookup
  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
   bfd_boolean, bfd_boolean);




extern struct bfd_link_hash_entry *unwrap_hash_lookup
  (struct bfd_link_info *, bfd *, struct bfd_link_hash_entry *);


extern void bfd_link_hash_traverse
  (struct bfd_link_hash_table *,
    bfd_boolean (*) (struct bfd_link_hash_entry *, void *),
    void *);


extern void bfd_link_add_undef
  (struct bfd_link_hash_table *, struct bfd_link_hash_entry *);


extern void bfd_link_repair_undef_list
  (struct bfd_link_hash_table *table);


extern bfd_boolean bfd_generic_link_read_symbols (bfd *);




extern bfd_boolean bfd_link_check_relocs (bfd *,struct bfd_link_info *);

struct bfd_sym_chain
{
  struct bfd_sym_chain *next;
  const char *name;
};



enum report_method
{



  RM_NOT_YET_SET = 0,
  RM_IGNORE,
  RM_GENERATE_WARNING,
  RM_GENERATE_ERROR
};

typedef enum {with_flags, without_flags} flag_type;


struct flag_info_list
{
  flag_type with;
  const char *name;
  bfd_boolean valid;
  struct flag_info_list *next;
};


struct flag_info
{
  flagword only_with_flags;
  flagword not_with_flags;
  struct flag_info_list *flag_list;
  bfd_boolean flags_initialized;
};

struct bfd_elf_dynamic_list;
struct bfd_elf_version_tree;



enum output_type
{
  type_pde,
  type_pie,
  type_relocatable,
  type_dll,
};
# 309 "./../include/bfdlink.h"
struct bfd_link_info
{

  __extension__ enum output_type type : 2;


  unsigned int symbolic: 1;



  unsigned int nocopyreloc: 1;



  unsigned int export_dynamic: 1;



  unsigned int create_default_symver: 1;


  unsigned int gc_sections: 1;


  unsigned int gc_keep_exported: 1;



  unsigned int notice_all: 1;


  unsigned int lto_plugin_active: 1;


  unsigned int strip_discarded: 1;


  unsigned int dynamic_data: 1;


  unsigned int resolve_section_groups: 1;


  __extension__ enum bfd_link_strip strip : 2;


  __extension__ enum bfd_link_discard discard : 2;


  __extension__ enum bfd_link_elf_stt_common elf_stt_common : 2;



  __extension__ enum bfd_link_common_skip_ar_symbols common_skip_ar_symbols : 2;






  __extension__ enum report_method unresolved_syms_in_objects : 2;



  __extension__ enum report_method unresolved_syms_in_shared_libs : 2;


  unsigned int static_link: 1;



  unsigned int keep_memory: 1;



  unsigned int emitrelocations: 1;


  unsigned int relro: 1;



  unsigned int eh_frame_hdr_type: 2;


  unsigned int warn_shared_textrel: 1;


  unsigned int error_textrel: 1;


  unsigned int emit_hash: 1;


  unsigned int emit_gnu_hash: 1;




  unsigned int reduce_memory_overheads: 1;





  unsigned int traditional_format: 1;



  unsigned int combreloc: 1;



  unsigned int default_imported_symver: 1;


  unsigned int new_dtags: 1;



  unsigned int no_ld_generated_unwind_info: 1;




  unsigned int task_link: 1;


  unsigned int allow_multiple_definition: 1;


  unsigned int allow_undefined_version: 1;



  unsigned int dynamic: 1;



  unsigned int execstack: 1;



  unsigned int noexecstack: 1;



  unsigned int optimize: 1;


  unsigned int print_gc_sections: 1;


  unsigned int warn_alternate_em: 1;


  unsigned int user_phdrs: 1;



  unsigned int check_relocs_after_open_input: 1;


  unsigned int bndplt: 1;


  unsigned int ibtplt: 1;


  unsigned int ibt: 1;


  unsigned int shstk: 1;


  unsigned int nointerp: 1;


  unsigned int no_reloc_overflow_check: 1;


  unsigned int call_nop_as_suffix : 1;


  char call_nop_byte;




  char wrap_char;


  char path_separator;


  enum compressed_debug_section_type compress_debug;



  bfd_signed_vma stacksize;
# 526 "./../include/bfdlink.h"
  signed int disable_target_specific_optimizations;


  const struct bfd_link_callbacks *callbacks;


  struct bfd_link_hash_table *hash;



  struct bfd_hash_table *keep_hash;




  struct bfd_hash_table *notice_hash;



  struct bfd_hash_table *wrap_hash;



  struct bfd_hash_table *ignore_hash;


  bfd *output_bfd;


  bfd *out_implib_bfd;



  bfd *input_bfds;
  bfd **input_bfds_tail;






  asection *create_object_symbols_section;



  struct bfd_sym_chain *gc_sym_list;


  void *base_file;



  const char *init_function;



  const char *fini_function;





  int relax_pass;




  int relax_trip;




  int extern_protected_data;




  int dynamic_undefined_weak;




  int pei386_auto_import;




  int pei386_runtime_pseudo_reloc;


  unsigned int spare_dynamic_tags;


  bfd_vma flags;


  bfd_vma flags_1;


  bfd_vma relro_start, relro_end;


  struct bfd_elf_dynamic_list *dynamic_list;


  struct bfd_elf_version_tree *version_info;
};




struct bfd_link_callbacks
{







  bfd_boolean (*add_archive_element)
    (struct bfd_link_info *, bfd *abfd, const char *name, bfd **subsbfd);




  void (*multiple_definition)
    (struct bfd_link_info *, struct bfd_link_hash_entry *h,
     bfd *nbfd, asection *nsec, bfd_vma nval);






  void (*multiple_common)
    (struct bfd_link_info *, struct bfd_link_hash_entry *h,
     bfd *nbfd, enum bfd_link_hash_type ntype, bfd_vma nsize);






  void (*add_to_set)
    (struct bfd_link_info *, struct bfd_link_hash_entry *entry,
     bfd_reloc_code_real_type reloc, bfd *abfd, asection *sec, bfd_vma value);






  void (*constructor)
    (struct bfd_link_info *, bfd_boolean constructor, const char *name,
     bfd *abfd, asection *sec, bfd_vma value);







  void (*warning)
    (struct bfd_link_info *, const char *warning, const char *symbol,
     bfd *abfd, asection *section, bfd_vma address);





  void (*undefined_symbol)
    (struct bfd_link_info *, const char *name, bfd *abfd,
     asection *section, bfd_vma address, bfd_boolean is_fatal);
# 708 "./../include/bfdlink.h"
  void (*reloc_overflow)
    (struct bfd_link_info *, struct bfd_link_hash_entry *entry,
     const char *name, const char *reloc_name, bfd_vma addend,
     bfd *abfd, asection *section, bfd_vma address);






  void (*reloc_dangerous)
    (struct bfd_link_info *, const char *message,
     bfd *abfd, asection *section, bfd_vma address);






  void (*unattached_reloc)
    (struct bfd_link_info *, const char *name,
     bfd *abfd, asection *section, bfd_vma address);





  bfd_boolean (*notice)
    (struct bfd_link_info *, struct bfd_link_hash_entry *h,
     struct bfd_link_hash_entry *inh,
     bfd *abfd, asection *section, bfd_vma address, flagword flags);

  void (*einfo)
    (const char *fmt, ...);

  void (*info)
    (const char *fmt, ...);

  void (*minfo)
    (const char *fmt, ...);



  bfd_boolean (*override_segment_assignment)
    (struct bfd_link_info *, bfd * abfd,
     asection * current_section, asection * previous_section,
     bfd_boolean new_segment);
};






enum bfd_link_order_type
{
  bfd_undefined_link_order,
  bfd_indirect_link_order,
  bfd_data_link_order,
  bfd_section_reloc_link_order,
  bfd_symbol_reloc_link_order
};




struct bfd_link_order
{

  struct bfd_link_order *next;

  enum bfd_link_order_type type;

  bfd_vma offset;

  bfd_size_type size;

  union
    {
      struct
 {






   asection *section;
 } indirect;
      struct
 {




   unsigned int size;

   bfd_byte *contents;
 } data;
      struct
 {



   struct bfd_link_order_reloc *p;
 } reloc;
    } u;
};
# 829 "./../include/bfdlink.h"
struct bfd_link_order_reloc
{

  bfd_reloc_code_real_type reloc;

  union
    {



      asection *section;


      const char *name;
    } u;






  bfd_vma addend;
};


extern struct bfd_link_order *bfd_new_link_order (bfd *, asection *);
# 863 "./../include/bfdlink.h"
struct bfd_elf_version_expr
{

  struct bfd_elf_version_expr *next;

  const char *pattern;

  unsigned int literal : 1;

  unsigned int symver : 1;

  unsigned int script : 1;




  unsigned int mask : 3;
};

struct bfd_elf_version_expr_head
{

  struct bfd_elf_version_expr *list;

  void *htab;

  struct bfd_elf_version_expr *remaining;

  unsigned int mask;
};



struct bfd_elf_version_deps
{

  struct bfd_elf_version_deps *next;

  struct bfd_elf_version_tree *version_needed;
};



struct bfd_elf_version_tree
{

  struct bfd_elf_version_tree *next;

  const char *name;

  unsigned int vernum;

  struct bfd_elf_version_expr_head globals;

  struct bfd_elf_version_expr_head locals;

  struct bfd_elf_version_deps *deps;

  unsigned int name_indx;

  int used;

  struct bfd_elf_version_expr *(*match)
    (struct bfd_elf_version_expr_head *head,
     struct bfd_elf_version_expr *prev, const char *sym);
};

struct bfd_elf_dynamic_list
{
  struct bfd_elf_version_expr_head head;
  struct bfd_elf_version_expr *(*match)
    (struct bfd_elf_version_expr_head *head,
     struct bfd_elf_version_expr *prev, const char *sym);
};
# 40 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 2
# 1 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h" 1
# 30 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
# 1 "./../include/hashtab.h" 1
# 31 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h" 2
# 47 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
struct bfd_in_memory
{

  bfd_size_type size;

  bfd_byte *buffer;
};

struct section_hash_entry
{
  struct bfd_hash_entry root;
  asection section;
};




struct artdata
{
  file_ptr first_file_filepos;

  htab_t cache;
  bfd *archive_head;
  carsym *symdefs;
  symindex symdef_count;
  char *extended_names;
  bfd_size_type extended_names_size;

  long armap_timestamp;





  file_ptr armap_datepos;

  void *tdata;
};




struct areltdata
{
  char * arch_header;
  bfd_size_type parsed_size;
  bfd_size_type extra_size;
  char *filename;
  file_ptr origin;
  void *parent_cache;
  file_ptr key;
};



extern void *bfd_malloc
  (bfd_size_type);
extern void *bfd_realloc
  (void *, bfd_size_type);
extern void *bfd_realloc_or_free
  (void *, bfd_size_type);
extern void *bfd_zmalloc
  (bfd_size_type);
extern void *bfd_malloc2
  (bfd_size_type, bfd_size_type);
extern void *bfd_realloc2
  (void *, bfd_size_type, bfd_size_type);
extern void *bfd_zmalloc2
  (bfd_size_type, bfd_size_type);

extern void _bfd_error_handler (const char *s, ...);



extern void *bfd_alloc2
  (bfd *, bfd_size_type, bfd_size_type);
extern void *bfd_zalloc2
  (bfd *, bfd_size_type, bfd_size_type);
extern void bfd_release
  (bfd *, void *);

bfd * _bfd_create_empty_archive_element_shell
  (bfd *obfd);
bfd * _bfd_look_for_bfd_in_cache
  (bfd *, file_ptr);
bfd_boolean _bfd_add_bfd_to_archive_cache
  (bfd *, file_ptr, bfd *);
bfd_boolean _bfd_generic_mkarchive
  (bfd *abfd);
char *_bfd_append_relative_path
  (bfd *arch, char *elt_name);
const bfd_target *bfd_generic_archive_p
  (bfd *abfd);
bfd_boolean bfd_slurp_armap
  (bfd *abfd);
bfd_boolean bfd_slurp_bsd_armap_f2
  (bfd *abfd);


bfd_boolean _bfd_archive_64_bit_slurp_armap
  (bfd *);
bfd_boolean _bfd_archive_64_bit_write_armap
  (bfd *, unsigned int, struct orl *, unsigned int, int);
# 169 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
bfd_boolean _bfd_slurp_extended_name_table
  (bfd *abfd);
extern bfd_boolean _bfd_construct_extended_name_table
  (bfd *, bfd_boolean, char **, bfd_size_type *);
bfd_boolean _bfd_write_archive_contents
  (bfd *abfd);
bfd_boolean _bfd_compute_and_write_armap
  (bfd *, unsigned int elength);
bfd *_bfd_get_elt_at_filepos
  (bfd *archive, file_ptr filepos);
extern bfd *_bfd_generic_get_elt_at_index
  (bfd *, symindex);
bfd * _bfd_new_bfd
  (void);
bfd_boolean _bfd_free_cached_info
  (bfd *);

bfd_boolean bfd_false
  (bfd *ignore);
bfd_boolean bfd_true
  (bfd *ignore);
void *bfd_nullvoidptr
  (bfd *ignore);
int bfd_0
  (bfd *ignore);
unsigned int bfd_0u
  (bfd *ignore);
long bfd_0l
  (bfd *ignore);
long _bfd_n1
  (bfd *ignore);
void bfd_void
  (bfd *ignore);

bfd *_bfd_new_bfd_contained_in
  (bfd *);
const bfd_target *_bfd_dummy_target
  (bfd *abfd);

void bfd_dont_truncate_arname
  (bfd *abfd, const char *filename, char *hdr);
void bfd_bsd_truncate_arname
  (bfd *abfd, const char *filename, char *hdr);
void bfd_gnu_truncate_arname
  (bfd *abfd, const char *filename, char *hdr);

bfd_boolean _bfd_bsd_write_armap
  (bfd *arch, unsigned int elength, struct orl *map, unsigned int orl_count,
   int stridx);

bfd_boolean _bfd_coff_write_armap
  (bfd *arch, unsigned int elength, struct orl *map, unsigned int orl_count,
   int stridx);

extern void *_bfd_generic_read_ar_hdr
  (bfd *);
extern void _bfd_ar_spacepad
  (char *, size_t, const char *, long);
extern bfd_boolean _bfd_ar_sizepad
  (char *, size_t, bfd_size_type);

extern void *_bfd_generic_read_ar_hdr_mag
  (bfd *, const char *);

extern bfd_boolean _bfd_generic_write_ar_hdr
  (bfd *, bfd *);

extern bfd_boolean _bfd_bsd44_write_ar_hdr
  (bfd *, bfd *);

bfd * bfd_generic_openr_next_archived_file
  (bfd *archive, bfd *last_file);

int bfd_generic_stat_arch_elt
  (bfd *, struct stat *);
# 254 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern bfd_boolean _bfd_archive_close_and_cleanup
  (bfd *);

extern bfd_boolean _bfd_generic_new_section_hook
  (bfd *, asection *);
extern bfd_boolean _bfd_generic_get_section_contents
  (bfd *, asection *, void *, file_ptr, bfd_size_type);
extern bfd_boolean _bfd_generic_get_section_contents_in_window
  (bfd *, asection *, bfd_window *, file_ptr, bfd_size_type);
# 282 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern bfd_boolean _bfd_generic_init_private_section_data
  (bfd *, asection *, bfd *, asection *, struct bfd_link_info *);




extern char *_bfd_nocore_core_file_failing_command
  (bfd *);
extern int _bfd_nocore_core_file_failing_signal
  (bfd *);
extern bfd_boolean _bfd_nocore_core_file_matches_executable_p
  (bfd *, bfd *);
extern int _bfd_nocore_core_file_pid
  (bfd *);
# 326 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern bfd_boolean _bfd_archive_bsd_construct_extended_name_table
  (bfd *, char **, bfd_size_type *, const char **);
# 337 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern bfd_boolean _bfd_archive_bsd_update_armap_timestamp
  (bfd *);







extern bfd_boolean _bfd_archive_coff_construct_extended_name_table
  (bfd *, char **, bfd_size_type *, const char **);
# 365 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern bfd_boolean _bfd_archive_bsd44_construct_extended_name_table
  (bfd *, char **, bfd_size_type *, const char **);
# 383 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern bfd_boolean _bfd_vms_lib_write_archive_contents (bfd *arch);
# 393 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern bfd *_bfd_vms_lib_openr_next_archived_file (bfd *, bfd *);
extern bfd *_bfd_vms_lib_get_elt_at_index (bfd *, symindex);
extern int _bfd_vms_lib_generic_stat_arch_elt (bfd *, struct stat *);




extern symindex _bfd_vms_lib_find_symbol (bfd *, const char *);
extern bfd *_bfd_vms_lib_get_imagelib_file (bfd *);
extern const bfd_target *_bfd_vms_lib_alpha_archive_p (bfd *abfd);
extern const bfd_target *_bfd_vms_lib_ia64_archive_p (bfd *abfd);
extern bfd_boolean _bfd_vms_lib_alpha_mkarchive (bfd *abfd);
extern bfd_boolean _bfd_vms_lib_ia64_mkarchive (bfd *abfd);
# 449 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern long _bfd_norelocs_get_reloc_upper_bound (bfd *, asection *);
extern long _bfd_norelocs_canonicalize_reloc (bfd *, asection *,
           arelent **, asymbol **);
extern void _bfd_norelocs_set_reloc (bfd *, asection *,
                                     arelent **, unsigned int);
# 473 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern bfd_boolean _bfd_generic_set_section_contents
  (bfd *, asection *, const void *, file_ptr, bfd_size_type);
# 544 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern bfd_boolean bfd_generic_is_local_label_name
  (bfd *, const char *);


extern long _bfd_generic_read_minisymbols
  (bfd *, bfd_boolean, void **, unsigned int *);
extern asymbol *_bfd_generic_minisymbol_to_symbol
  (bfd *, bfd_boolean, const void *, asymbol *);


extern bfd_boolean _bfd_stab_section_find_nearest_line
  (bfd *, asymbol **, asection *, bfd_vma, bfd_boolean *,
   const char **, const char **, unsigned int *, void **);


extern bfd_boolean _bfd_dwarf1_find_nearest_line
  (bfd *, asymbol **, asection *, bfd_vma,
   const char **, const char **, unsigned int *);

struct dwarf_debug_section
{
  const char *uncompressed_name;
  const char *compressed_name;
};




extern const struct dwarf_debug_section dwarf_debug_sections[];


extern bfd_boolean _bfd_dwarf2_find_nearest_line
  (bfd *, asymbol **, asymbol *, asection *, bfd_vma,
   const char **, const char **, unsigned int *, unsigned int *,
   const struct dwarf_debug_section *, unsigned int, void **);


extern bfd_signed_vma _bfd_dwarf2_find_symbol_bias
  (asymbol **, void **);


extern bfd_boolean _bfd_dwarf2_find_inliner_info
  (bfd *, const char **, const char **, unsigned int *, void **);


extern bfd_boolean _bfd_dwarf2_slurp_debug_info
  (bfd *, bfd *, const struct dwarf_debug_section *, asymbol **, void **,
   bfd_boolean);


extern void _bfd_dwarf2_cleanup_debug_info
  (bfd *, void **);


extern struct bfd_hash_entry *bfd_section_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);


extern struct bfd_hash_entry *_bfd_link_hash_newfunc
  (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
   const char *string);


extern bfd_boolean _bfd_link_hash_table_init
  (struct bfd_link_hash_table *, bfd *,
   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
          struct bfd_hash_table *,
          const char *),
   unsigned int);


extern struct bfd_link_hash_table *_bfd_generic_link_hash_table_create
  (bfd *);


extern void _bfd_generic_link_hash_table_free
  (bfd *);


extern bfd_boolean _bfd_generic_link_add_symbols
  (bfd *, struct bfd_link_info *);


extern bfd_boolean _bfd_generic_link_add_archive_symbols
  (bfd *, struct bfd_link_info *,
   bfd_boolean (*) (bfd *, struct bfd_link_info *,
      struct bfd_link_hash_entry *, const char *,
      bfd_boolean *));


typedef struct bfd_link_hash_entry _bfd_link_hash_entry;


extern bfd_boolean _bfd_generic_link_add_one_symbol
  (struct bfd_link_info *, bfd *, const char *name, flagword,
   asection *, bfd_vma, const char *, bfd_boolean copy,
   bfd_boolean constructor, struct bfd_link_hash_entry **);


extern void _bfd_generic_link_just_syms
  (asection *, struct bfd_link_info *);


extern void _bfd_generic_copy_link_hash_symbol_type
  (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);


extern bfd_boolean _bfd_generic_final_link
  (bfd *, struct bfd_link_info *);

extern bfd_boolean _bfd_generic_link_split_section
  (bfd *, struct bfd_section *);

extern bfd_boolean _bfd_generic_section_already_linked
  (bfd *, asection *, struct bfd_link_info *);


extern bfd_boolean _bfd_generic_reloc_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);


extern bfd_boolean _bfd_default_link_order
  (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *);


extern unsigned int _bfd_count_link_order_relocs
  (struct bfd_link_order *);


extern bfd_reloc_status_type _bfd_final_link_relocate
  (reloc_howto_type *, bfd *, asection *, bfd_byte *,
   bfd_vma, bfd_vma, bfd_vma);


extern bfd_reloc_status_type _bfd_relocate_contents
  (reloc_howto_type *, bfd *, bfd_vma, bfd_byte *);


extern void _bfd_clear_contents (reloc_howto_type *howto, bfd *input_bfd,
     asection *input_section, bfd_byte *location);



extern bfd_boolean _bfd_link_section_stabs
  (bfd *, struct stab_info *, asection *, asection *, void **,
   bfd_size_type *);


extern bfd_boolean _bfd_discard_section_stabs
  (bfd *, asection *, void *, bfd_boolean (*) (bfd_vma, void *), void *);



extern bfd_boolean _bfd_write_section_stabs
  (bfd *, struct stab_info *, asection *, void **, bfd_byte *);



extern bfd_boolean _bfd_write_stab_strings
  (bfd *, struct stab_info *);




extern bfd_vma _bfd_stab_section_offset
  (asection *, void *, bfd_vma);



extern bfd_boolean _bfd_add_merge_section
  (bfd *, void **, asection *, void **);



extern bfd_boolean _bfd_merge_sections
  (bfd *, struct bfd_link_info *, void *, void (*) (bfd *, asection *));



extern bfd_boolean _bfd_write_merged_section
  (bfd *, asection *, void *);



extern bfd_vma _bfd_merged_section_offset
  (bfd *, asection **, void *, bfd_vma);



extern void _bfd_merge_sections_free (void *);


extern struct bfd_strtab_hash *_bfd_stringtab_init
  (void);


extern struct bfd_strtab_hash *_bfd_xcoff_stringtab_init
  (void);


extern void _bfd_stringtab_free
  (struct bfd_strtab_hash *);


extern bfd_size_type _bfd_stringtab_size
  (struct bfd_strtab_hash *);


extern bfd_size_type _bfd_stringtab_add
  (struct bfd_strtab_hash *, const char *, bfd_boolean hash, bfd_boolean copy);


extern bfd_boolean _bfd_stringtab_emit
  (bfd *, struct bfd_strtab_hash *);
# 773 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
void bfd_assert
  (const char*,int);







extern void _bfd_abort
  (const char *, int, const char *) __attribute__ ((__noreturn__));
# 795 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
extern file_ptr _bfd_real_ftell (FILE *file);
extern int _bfd_real_fseek (FILE *file, file_ptr offset, int whence);
extern FILE *_bfd_real_fopen (const char *filename, const char *modes);



extern const bfd_target * const *bfd_target_vector;
extern const bfd_target *bfd_default_vector[];


extern const bfd_target * const *bfd_associated_vector;





struct ecoff_find_line;


extern bfd_boolean _bfd_ecoff_locate_line
  (bfd *, asection *, bfd_vma, struct ecoff_debug_info * const,
   const struct ecoff_debug_swap * const, struct ecoff_find_line *,
   const char **, const char **, unsigned int *);
extern bfd_boolean _bfd_ecoff_get_accumulated_pdr
  (void *, bfd_byte *);
extern bfd_boolean _bfd_ecoff_get_accumulated_sym
  (void *, bfd_byte *);
extern bfd_boolean _bfd_ecoff_get_accumulated_ss
  (void *, bfd_byte *);

extern bfd_vma _bfd_get_gp_value
  (bfd *);
extern void _bfd_set_gp_value
  (bfd *, bfd_vma);





extern bfd_boolean _bfd_sh_align_load_span
  (bfd *, asection *, bfd_byte *,
   bfd_boolean (*) (bfd *, asection *, void *, bfd_byte *, bfd_vma),
   void *, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bfd_boolean *);






struct bfd_section_already_linked_hash_entry
{
  struct bfd_hash_entry root;
  struct bfd_section_already_linked *entry;
};

struct bfd_section_already_linked
{
  struct bfd_section_already_linked *next;
  asection *sec;
};

extern struct bfd_section_already_linked_hash_entry *
  bfd_section_already_linked_table_lookup (const char *);
extern bfd_boolean bfd_section_already_linked_table_insert
  (struct bfd_section_already_linked_hash_entry *, asection *);
extern void bfd_section_already_linked_table_traverse
  (bfd_boolean (*) (struct bfd_section_already_linked_hash_entry *,
      void *), void *);

extern bfd_vma _bfd_read_unsigned_leb128 (bfd *, bfd_byte *, unsigned int *);
extern bfd_signed_vma _bfd_read_signed_leb128 (bfd *, bfd_byte *, unsigned int *);
extern bfd_vma _bfd_safe_read_leb128 (bfd *, bfd_byte *, unsigned int *,
          bfd_boolean, const bfd_byte * const);

bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);

unsigned int bfd_log2 (bfd_vma x);


struct bfd_iovec
{






  file_ptr (*bread) (struct bfd *abfd, void *ptr, file_ptr nbytes);
  file_ptr (*bwrite) (struct bfd *abfd, const void *ptr,
                      file_ptr nbytes);


  file_ptr (*btell) (struct bfd *abfd);


  int (*bseek) (struct bfd *abfd, file_ptr offset, int whence);
  int (*bclose) (struct bfd *abfd);
  int (*bflush) (struct bfd *abfd);
  int (*bstat) (struct bfd *abfd, struct stat *sb);






  void *(*bmmap) (struct bfd *abfd, void *addr, bfd_size_type len,
                  int prot, int flags, file_ptr offset,
                  void **map_addr, bfd_size_type *map_len);
};
extern const struct bfd_iovec _bfd_memory_iovec;

struct _bfd_window_internal {
  struct _bfd_window_internal *next;
  void *data;
  bfd_size_type size;
  int refcount : 31;
  unsigned mapped : 1;
};

bfd_boolean bfd_cache_init (bfd *abfd);

bfd_boolean bfd_cache_close (bfd *abfd);

FILE* bfd_open_file (bfd *abfd);
# 3189 "/doner/binutils/binutils-7a31b38/bfd/libbfd.h"
reloc_howto_type *bfd_default_reloc_type_lookup
   (bfd *abfd, bfd_reloc_code_real_type code);

bfd_boolean bfd_generic_relax_section
   (bfd *abfd,
    asection *section,
    struct bfd_link_info *,
    bfd_boolean *);

bfd_boolean bfd_generic_gc_sections
   (bfd *, struct bfd_link_info *);

bfd_boolean bfd_generic_lookup_section_flags
   (struct bfd_link_info *, struct flag_info *, asection *);

bfd_boolean bfd_generic_merge_sections
   (bfd *, struct bfd_link_info *);

bfd_byte *bfd_generic_get_relocated_section_contents
   (bfd *abfd,
    struct bfd_link_info *link_info,
    struct bfd_link_order *link_order,
    bfd_byte *data,
    bfd_boolean relocatable,
    asymbol **symbols);

void _bfd_generic_set_reloc
   (bfd *abfd,
    sec_ptr section,
    arelent **relptr,
    unsigned int count);


extern const bfd_arch_info_type bfd_default_arch_struct;
const bfd_arch_info_type *bfd_default_compatible
   (const bfd_arch_info_type *a, const bfd_arch_info_type *b);

bfd_boolean bfd_default_scan
   (const struct bfd_arch_info *info, const char *string);

void *bfd_arch_default_fill (bfd_size_type count,
    bfd_boolean is_bigendian,
    bfd_boolean code);


bfd_boolean _bfd_generic_verify_endian_match
   (bfd *ibfd, struct bfd_link_info *info);
# 41 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 2

# 1 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h" 1
# 25 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
# 1 "./../include/elf/common.h" 1
# 26 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h" 2
# 1 "./../include/elf/external.h" 1
# 52 "./../include/elf/external.h"
typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[4];
  unsigned char e_phoff[4];
  unsigned char e_shoff[4];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf32_External_Ehdr;

typedef struct {
  unsigned char e_ident[16];
  unsigned char e_type[2];
  unsigned char e_machine[2];
  unsigned char e_version[4];
  unsigned char e_entry[8];
  unsigned char e_phoff[8];
  unsigned char e_shoff[8];
  unsigned char e_flags[4];
  unsigned char e_ehsize[2];
  unsigned char e_phentsize[2];
  unsigned char e_phnum[2];
  unsigned char e_shentsize[2];
  unsigned char e_shnum[2];
  unsigned char e_shstrndx[2];
} Elf64_External_Ehdr;



typedef struct {
  unsigned char p_type[4];
  unsigned char p_offset[4];
  unsigned char p_vaddr[4];
  unsigned char p_paddr[4];
  unsigned char p_filesz[4];
  unsigned char p_memsz[4];
  unsigned char p_flags[4];
  unsigned char p_align[4];
} Elf32_External_Phdr;

typedef struct {
  unsigned char p_type[4];
  unsigned char p_flags[4];
  unsigned char p_offset[8];
  unsigned char p_vaddr[8];
  unsigned char p_paddr[8];
  unsigned char p_filesz[8];
  unsigned char p_memsz[8];
  unsigned char p_align[8];
} Elf64_External_Phdr;



typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[4];
  unsigned char sh_addr[4];
  unsigned char sh_offset[4];
  unsigned char sh_size[4];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[4];
  unsigned char sh_entsize[4];
} Elf32_External_Shdr;

typedef struct {
  unsigned char sh_name[4];
  unsigned char sh_type[4];
  unsigned char sh_flags[8];
  unsigned char sh_addr[8];
  unsigned char sh_offset[8];
  unsigned char sh_size[8];
  unsigned char sh_link[4];
  unsigned char sh_info[4];
  unsigned char sh_addralign[8];
  unsigned char sh_entsize[8];
} Elf64_External_Shdr;



typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_size[4];
  unsigned char ch_addralign[4];
} Elf32_External_Chdr;

typedef struct {
  unsigned char ch_type[4];
  unsigned char ch_reserved[4];
  unsigned char ch_size[8];
  unsigned char ch_addralign[8];
} Elf64_External_Chdr;



typedef struct {
  unsigned char st_name[4];
  unsigned char st_value[4];
  unsigned char st_size[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
} Elf32_External_Sym;

typedef struct {
  unsigned char st_name[4];
  unsigned char st_info[1];
  unsigned char st_other[1];
  unsigned char st_shndx[2];
  unsigned char st_value[8];
  unsigned char st_size[8];
} Elf64_External_Sym;

typedef struct {
  unsigned char est_shndx[4];
} Elf_External_Sym_Shndx;



typedef struct {
  unsigned char namesz[4];
  unsigned char descsz[4];
  unsigned char type[4];
  char name[1];
} Elf_External_Note;


typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
} Elf32_External_Rel;

typedef struct {
  unsigned char r_offset[4];
  unsigned char r_info[4];
  unsigned char r_addend[4];
} Elf32_External_Rela;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
} Elf64_External_Rel;

typedef struct {
  unsigned char r_offset[8];
  unsigned char r_info[8];
  unsigned char r_addend[8];
} Elf64_External_Rela;



typedef struct {
  unsigned char d_tag[4];
  union {
    unsigned char d_val[4];
    unsigned char d_ptr[4];
  } d_un;
} Elf32_External_Dyn;

typedef struct {
  unsigned char d_tag[8];
  union {
    unsigned char d_val[8];
    unsigned char d_ptr[8];
  } d_un;
} Elf64_External_Dyn;







typedef struct {
  unsigned char vd_version[2];
  unsigned char vd_flags[2];
  unsigned char vd_ndx[2];
  unsigned char vd_cnt[2];
  unsigned char vd_hash[4];
  unsigned char vd_aux[4];
  unsigned char vd_next[4];
} Elf_External_Verdef;



typedef struct {
  unsigned char vda_name[4];
  unsigned char vda_next[4];
} Elf_External_Verdaux;



typedef struct {
  unsigned char vn_version[2];
  unsigned char vn_cnt[2];
  unsigned char vn_file[4];
  unsigned char vn_aux[4];
  unsigned char vn_next[4];
} Elf_External_Verneed;



typedef struct {
  unsigned char vna_hash[4];
  unsigned char vna_flags[2];
  unsigned char vna_other[2];
  unsigned char vna_name[4];
  unsigned char vna_next[4];
} Elf_External_Vernaux;




typedef struct {
  unsigned char vs_vers[2];
} __attribute__ ((packed)) Elf_External_Versym;


typedef struct
{
  unsigned char si_boundto[2];
  unsigned char si_flags[2];
} Elf_External_Syminfo;



typedef struct
{
  unsigned char a_type[4];
  unsigned char a_val[4];
} Elf32_External_Auxv;

typedef struct
{
  unsigned char a_type[8];
  unsigned char a_val[8];
} Elf64_External_Auxv;
# 27 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h" 2
# 1 "./../include/elf/internal.h" 1
# 67 "./../include/elf/internal.h"
typedef struct elf_internal_ehdr {
  unsigned char e_ident[16];
  bfd_vma e_entry;
  bfd_size_type e_phoff;
  bfd_size_type e_shoff;
  unsigned long e_version;
  unsigned long e_flags;
  unsigned short e_type;
  unsigned short e_machine;
  unsigned int e_ehsize;
  unsigned int e_phentsize;
  unsigned int e_phnum;
  unsigned int e_shentsize;
  unsigned int e_shnum;
  unsigned int e_shstrndx;
} Elf_Internal_Ehdr;



struct elf_internal_phdr {
  unsigned long p_type;
  unsigned long p_flags;
  bfd_vma p_offset;
  bfd_vma p_vaddr;
  bfd_vma p_paddr;
  bfd_vma p_filesz;
  bfd_vma p_memsz;
  bfd_vma p_align;
};

typedef struct elf_internal_phdr Elf_Internal_Phdr;



typedef struct elf_internal_shdr {
  unsigned int sh_name;
  unsigned int sh_type;
  bfd_vma sh_flags;
  bfd_vma sh_addr;
  file_ptr sh_offset;
  bfd_size_type sh_size;
  unsigned int sh_link;
  unsigned int sh_info;
  bfd_vma sh_addralign;
  bfd_size_type sh_entsize;


  asection * bfd_section;
  unsigned char *contents;
} Elf_Internal_Shdr;



typedef struct elf_internal_chdr {
  unsigned int ch_type;
  bfd_size_type ch_size;
  bfd_vma ch_addralign;
} Elf_Internal_Chdr;



struct elf_internal_sym {
  bfd_vma st_value;
  bfd_vma st_size;
  unsigned long st_name;
  unsigned char st_info;
  unsigned char st_other;
  unsigned char st_target_internal;
  unsigned int st_shndx;
};

typedef struct elf_internal_sym Elf_Internal_Sym;



typedef struct elf_internal_note {
  unsigned long namesz;
  unsigned long descsz;
  unsigned long type;
  char * namedata;
  char * descdata;
  bfd_vma descpos;
} Elf_Internal_Note;



typedef struct elf_internal_rela {
  bfd_vma r_offset;
  bfd_vma r_info;
  bfd_vma r_addend;
} Elf_Internal_Rela;



typedef struct elf_internal_dyn {

  bfd_vma d_tag;
  union {

    bfd_vma d_val;
    bfd_vma d_ptr;
  } d_un;
} Elf_Internal_Dyn;



typedef struct elf_internal_verdef {
  unsigned short vd_version;
  unsigned short vd_flags;
  unsigned short vd_ndx;
  unsigned short vd_cnt;
  unsigned long vd_hash;
  unsigned long vd_aux;
  unsigned long vd_next;



  bfd *vd_bfd;
  const char *vd_nodename;
  struct elf_internal_verdef *vd_nextdef;
  struct elf_internal_verdaux *vd_auxptr;
  unsigned int vd_exp_refno;
} Elf_Internal_Verdef;



typedef struct elf_internal_verdaux {
  unsigned long vda_name;
  unsigned long vda_next;



  const char *vda_nodename;
  struct elf_internal_verdaux *vda_nextptr;
} Elf_Internal_Verdaux;



typedef struct elf_internal_verneed {
  unsigned short vn_version;
  unsigned short vn_cnt;
  unsigned long vn_file;
  unsigned long vn_aux;
  unsigned long vn_next;



  bfd *vn_bfd;
  const char *vn_filename;
  struct elf_internal_vernaux *vn_auxptr;
  struct elf_internal_verneed *vn_nextref;
} Elf_Internal_Verneed;



typedef struct elf_internal_vernaux {
  unsigned long vna_hash;
  unsigned short vna_flags;
  unsigned short vna_other;
  unsigned long vna_name;
  unsigned long vna_next;



  const char *vna_nodename;
  struct elf_internal_vernaux *vna_nextptr;
} Elf_Internal_Vernaux;




typedef struct elf_internal_versym {
  unsigned short vs_vers;
} Elf_Internal_Versym;


typedef struct
{
  unsigned short int si_boundto;
  unsigned short int si_flags;
} Elf_Internal_Syminfo;


typedef struct
{
  bfd_vma a_type;
  bfd_vma a_val;
} Elf_Internal_Auxv;





struct elf_segment_map
{

  struct elf_segment_map *next;

  unsigned long p_type;

  unsigned long p_flags;

  bfd_vma p_paddr;

  bfd_vma p_vaddr_offset;

  bfd_vma p_align;

  bfd_vma p_size;

  bfd_vma header_size;


  unsigned int p_flags_valid : 1;


  unsigned int p_paddr_valid : 1;


  unsigned int p_align_valid : 1;


  unsigned int p_size_valid : 1;

  unsigned int includes_filehdr : 1;

  unsigned int includes_phdrs : 1;

  unsigned int count;

  asection *sections[1];
};
# 28 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h" 2
# 64 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
typedef struct
{

  asymbol symbol;

  Elf_Internal_Sym internal_elf_sym;

  union
    {
      unsigned int hppa_arg_reloc;
      void *mips_extr;
      void *any;
    }
  tc_data;




  unsigned short version;

} elf_symbol_type;

struct elf_strtab_hash;
struct got_entry;
struct plt_entry;

union gotplt_union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
    struct got_entry *glist;
    struct plt_entry *plist;
  };

struct elf_link_virtual_table_entry
  {




    size_t size;
    bfd_boolean *used;


    struct elf_link_hash_entry *parent;
  };


enum elf_symbol_version
  {
    unknown = 0,
    unversioned,
    versioned,
    versioned_hidden
  };



struct elf_link_hash_entry
{
  struct bfd_link_hash_entry root;




  long indx;
# 143 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  long dynindx;
# 154 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  union gotplt_union got;


  union gotplt_union plt;


  bfd_size_type size;


  unsigned int type : 8;


  unsigned int other : 8;


  unsigned int target_internal : 8;



  unsigned int ref_regular : 1;

  unsigned int def_regular : 1;

  unsigned int ref_dynamic : 1;

  unsigned int def_dynamic : 1;


  unsigned int ref_regular_nonweak : 1;

  unsigned int dynamic_adjusted : 1;

  unsigned int needs_copy : 1;

  unsigned int needs_plt : 1;

  unsigned int non_elf : 1;

  __extension__ enum elf_symbol_version versioned : 2;

  unsigned int forced_local : 1;

  unsigned int dynamic : 1;

  unsigned int mark : 1;


  unsigned int non_got_ref : 1;



  unsigned int dynamic_def : 1;

  unsigned int ref_dynamic_nonweak : 1;


  unsigned int pointer_equality_needed : 1;

  unsigned int unique_global : 1;


  unsigned int protected_def : 1;


  unsigned int start_stop : 1;


  unsigned long dynstr_index;

  union
  {



    struct elf_link_hash_entry *weakdef;




    unsigned long elf_hash_value;
  } u;


  union
  {



    Elf_Internal_Verdef *verdef;



    struct bfd_elf_version_tree *vertree;
  } verinfo;

  union
  {


    asection *start_stop_section;


    struct elf_link_virtual_table_entry *vtable;
  } u2;
};
# 279 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
struct elf_link_local_dynamic_entry
{
  struct elf_link_local_dynamic_entry *next;


  bfd *input_bfd;


  long input_indx;


  long dynindx;


  Elf_Internal_Sym isym;
};

struct elf_link_loaded_list
{
  struct elf_link_loaded_list *next;
  bfd *abfd;
};


struct eh_cie_fde
{
  union {
    struct {
# 315 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
      struct eh_cie_fde *cie_inf;
      struct eh_cie_fde *next_for_section;
    } fde;
    struct {
# 330 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
      union {
 struct cie *full_cie;
  struct eh_cie_fde *merged_with;
  asection *sec;
      } u;



      unsigned int personality_offset : 8;




      unsigned int aug_str_len : 3;
      unsigned int aug_data_len : 5;


      unsigned int gc_mark : 1;



      unsigned int make_lsda_relative : 1;



      unsigned int make_per_encoding_relative : 1;




      unsigned int per_encoding_relative : 1;



      unsigned int per_encoding_aligned8 : 1;



      unsigned int add_fde_encoding : 1;


      unsigned int merged : 1;


      unsigned int pad1 : 9;
    } cie;
  } u;
  unsigned int reloc_index;
  unsigned int size;
  unsigned int offset;
  unsigned int new_offset;
  unsigned int fde_encoding : 8;
  unsigned int lsda_encoding : 8;
  unsigned int lsda_offset : 8;


  unsigned int cie : 1;


  unsigned int removed : 1;



  unsigned int add_augmentation_size : 1;




  unsigned int make_relative : 1;


  unsigned int pad1 : 4;

  unsigned int *set_loc;
};

struct eh_frame_sec_info
{
  unsigned int count;
  struct cie *cies;
  struct eh_cie_fde entry[1];
};

struct eh_frame_array_ent
{
  bfd_vma initial_loc;
  bfd_size_type range;
  bfd_vma fde;
};

struct htab;







struct dwarf_eh_frame_hdr_info
{
  struct htab *cies;
  unsigned int fde_count;



  bfd_boolean table;
  struct eh_frame_array_ent *array;
};

struct compact_eh_frame_hdr_info
{
  unsigned int allocated_entries;

  asection **entries;
};

struct eh_frame_hdr_info
{
  asection *hdr_sec;
  unsigned int array_count;
  bfd_boolean frame_hdr_is_compact;
  union
    {
      struct dwarf_eh_frame_hdr_info dwarf;
      struct compact_eh_frame_hdr_info compact;
    }
  u;
};






enum elf_target_id
{
  AARCH64_ELF_DATA = 1,
  ALPHA_ELF_DATA,
  ARC_ELF_DATA,
  ARM_ELF_DATA,
  AVR_ELF_DATA,
  BFIN_ELF_DATA,
  CRIS_ELF_DATA,
  FRV_ELF_DATA,
  HPPA32_ELF_DATA,
  HPPA64_ELF_DATA,
  I386_ELF_DATA,
  IA64_ELF_DATA,
  LM32_ELF_DATA,
  M32R_ELF_DATA,
  M68HC11_ELF_DATA,
  M68K_ELF_DATA,
  METAG_ELF_DATA,
  MICROBLAZE_ELF_DATA,
  MIPS_ELF_DATA,
  MN10300_ELF_DATA,
  NDS32_ELF_DATA,
  NIOS2_ELF_DATA,
  OR1K_ELF_DATA,
  PPC32_ELF_DATA,
  PPC64_ELF_DATA,
  PRU_ELF_DATA,
  S390_ELF_DATA,
  SH_ELF_DATA,
  SPARC_ELF_DATA,
  SPU_ELF_DATA,
  TIC6X_ELF_DATA,
  X86_64_ELF_DATA,
  XTENSA_ELF_DATA,
  XGATE_ELF_DATA,
  TILEGX_ELF_DATA,
  TILEPRO_ELF_DATA,
  RISCV_ELF_DATA,
  GENERIC_ELF_DATA
};

struct elf_sym_strtab
{
  Elf_Internal_Sym sym;
  unsigned long dest_index;
  unsigned long destshndx_index;
};



struct elf_link_hash_table
{
  struct bfd_link_hash_table root;



  enum elf_target_id hash_table_id;



  bfd_boolean dynamic_sections_created;



  bfd_boolean is_relocatable_executable;




  bfd *dynobj;





  union gotplt_union init_got_refcount;
  union gotplt_union init_plt_refcount;



  union gotplt_union init_got_offset;
  union gotplt_union init_plt_offset;



  bfd_size_type dynsymcount;
  bfd_size_type local_dynsymcount;



  struct elf_strtab_hash *dynstr;



  bfd_size_type strtabcount;



  bfd_size_type strtabsize;


  struct elf_sym_strtab *strtab;



  bfd_size_type bucketcount;



  struct bfd_link_needed_list *needed;




  asection *text_index_section;
  asection *data_index_section;


  struct elf_link_hash_entry *hgot;


  struct elf_link_hash_entry *hplt;


  struct elf_link_hash_entry *hdynamic;


  void *merge_info;


  struct stab_info stab_info;


  struct eh_frame_hdr_info eh_info;


  struct elf_link_local_dynamic_entry *dynlocal;



  struct bfd_link_needed_list *runpath;


  asection *tls_sec;
  bfd_size_type tls_size;


  struct elf_link_loaded_list *loaded;


  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;
  asection *sdynrelro;
  asection *sreldynrelro;
  asection *igotplt;
  asection *iplt;
  asection *irelplt;
  asection *irelifunc;
  asection *dynsym;
};
# 659 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
struct sym_cache
{
  bfd *abfd;
  unsigned long indx[32];
  Elf_Internal_Sym sym[32];
};



struct elf_size_info {
  unsigned char sizeof_ehdr, sizeof_phdr, sizeof_shdr;
  unsigned char sizeof_rel, sizeof_rela, sizeof_sym, sizeof_dyn, sizeof_note;


  unsigned char sizeof_hash_entry;



  unsigned char int_rels_per_ext_rel;




  unsigned char arch_size, log_file_align;
  unsigned char elfclass, ev_current;
  int (*write_out_phdrs)
    (bfd *, const Elf_Internal_Phdr *, unsigned int);
  bfd_boolean
    (*write_shdrs_and_ehdr) (bfd *);
  bfd_boolean (*checksum_contents)
    (bfd * , void (*) (const void *, size_t, void *), void *);
  void (*write_relocs)
    (bfd *, asection *, void *);
  bfd_boolean (*swap_symbol_in)
    (bfd *, const void *, const void *, Elf_Internal_Sym *);
  void (*swap_symbol_out)
    (bfd *, const Elf_Internal_Sym *, void *, void *);
  bfd_boolean (*slurp_reloc_table)
    (bfd *, asection *, asymbol **, bfd_boolean);
  long (*slurp_symbol_table)
    (bfd *, asymbol **, bfd_boolean);
  void (*swap_dyn_in)
    (bfd *, const void *, Elf_Internal_Dyn *);
  void (*swap_dyn_out)
    (bfd *, const Elf_Internal_Dyn *, void *);




  void (*swap_reloc_in)
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);


  void (*swap_reloc_out)
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);




  void (*swap_reloca_in)
    (bfd *, const bfd_byte *, Elf_Internal_Rela *);


  void (*swap_reloca_out)
    (bfd *, const Elf_Internal_Rela *, bfd_byte *);
};







enum elf_reloc_type_class {
  reloc_class_normal,
  reloc_class_relative,
  reloc_class_copy,
  reloc_class_ifunc,
  reloc_class_plt
};

struct elf_reloc_cookie
{
  Elf_Internal_Rela *rels, *rel, *relend;
  Elf_Internal_Sym *locsyms;
  bfd *abfd;
  size_t locsymcount;
  size_t extsymoff;
  struct elf_link_hash_entry **sym_hashes;
  int r_sym_shift;
  bfd_boolean bad_symtab;
};



typedef enum {
  ict_none,
  ict_irix5,
  ict_irix6
} irix_compat_t;


struct bfd_elf_special_section
{
  const char *prefix;
  unsigned int prefix_length;






  signed int suffix_length;
  unsigned int type;
  bfd_vma attr;
};

enum action_discarded
  {
    COMPLAIN = 1,
    PRETEND = 2
  };

typedef asection * (*elf_gc_mark_hook_fn)
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

enum elf_property_kind
 {

    property_unknown = 0,

    property_ignored,

    property_corrupt,

    property_remove,

    property_number
 };

typedef struct elf_property
{
  unsigned int pr_type;
  unsigned int pr_datasz;
  union
    {

      bfd_vma number;

    } u;
  enum elf_property_kind pr_kind;
} elf_property;

typedef struct elf_property_list
{
  struct elf_property_list *next;
  struct elf_property property;
} elf_property_list;

struct bfd_elf_section_reloc_data;

struct elf_backend_data
{

  enum bfd_architecture arch;



  enum elf_target_id target_id;


  int elf_machine_code;


  int elf_osabi;


  bfd_vma maxpagesize;




  bfd_vma minpagesize;


  bfd_vma commonpagesize;


  flagword dynamic_sec_flags;



  const void *arch_data;



  void (*elf_info_to_howto)
    (bfd *, arelent *, Elf_Internal_Rela *);



  void (*elf_info_to_howto_rel)
    (bfd *, arelent *, Elf_Internal_Rela *);






  bfd_boolean (*elf_backend_sym_is_global)
    (bfd *, asymbol *);
# 881 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_object_p)
    (bfd *);




  void (*elf_backend_symbol_processing)
    (bfd *, asymbol *);



  bfd_boolean (*elf_backend_symbol_table_processing)
    (bfd *, elf_symbol_type *, unsigned int);



  int (*elf_backend_get_symbol_type)
    (Elf_Internal_Sym *, int);



  struct elf_link_hash_entry * (*elf_backend_archive_symbol_lookup)
    (bfd *, struct bfd_link_info *, const char *);



  bfd_boolean (*elf_backend_name_local_section_symbols)
    (bfd *);





  bfd_boolean (*elf_backend_section_processing)
    (bfd *, Elf_Internal_Shdr *);



  bfd_boolean (*elf_backend_section_from_shdr)
    (bfd *, Elf_Internal_Shdr *, const char *, int);



  bfd_boolean (*elf_backend_section_flags)
    (flagword *, const Elf_Internal_Shdr *);



  const struct bfd_elf_special_section * (*get_sec_type_attr)
    (bfd *, asection *);



  bfd_boolean (*elf_backend_section_from_phdr)
    (bfd *, Elf_Internal_Phdr *, int, const char *);




  bfd_boolean (*elf_backend_fake_sections)
    (bfd *, Elf_Internal_Shdr *, asection *);





  bfd_boolean (*elf_backend_section_from_bfd_section)
    (bfd *, asection *, int *retval);
# 958 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  bfd_boolean (*elf_add_symbol_hook)
    (bfd *abfd, struct bfd_link_info *info, Elf_Internal_Sym *,
     const char **name, flagword *flags, asection **sec, bfd_vma *value);





  int (*elf_backend_link_output_symbol_hook)
    (struct bfd_link_info *info, const char *, Elf_Internal_Sym *,
     asection *, struct elf_link_hash_entry *);
# 978 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_create_dynamic_sections)
    (bfd *abfd, struct bfd_link_info *info);



  bfd_boolean (*elf_backend_omit_section_dynsym)
    (bfd *output_bfd, struct bfd_link_info *info, asection *osec);



  bfd_boolean (*relocs_compatible) (const bfd_target *, const bfd_target *);
# 1000 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  bfd_boolean (*check_relocs)
    (bfd *abfd, struct bfd_link_info *info, asection *o,
     const Elf_Internal_Rela *relocs);





  bfd_boolean (*check_directives)
    (bfd *abfd, struct bfd_link_info *info);





  bfd_boolean (*notice_as_needed)
    (bfd *abfd, struct bfd_link_info *info, enum notice_asneeded_action act);
# 1030 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_adjust_dynamic_symbol)
    (struct bfd_link_info *info, struct elf_link_hash_entry *h);





  bfd_boolean (*elf_backend_always_size_sections)
    (bfd *output_bfd, struct bfd_link_info *info);
# 1050 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_size_dynamic_sections)
    (bfd *output_bfd, struct bfd_link_info *info);



  void (*elf_backend_init_index_section)
    (bfd *output_bfd, struct bfd_link_info *info);
# 1089 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  int (*elf_backend_relocate_section)
    (bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd,
     asection *input_section, bfd_byte *contents, Elf_Internal_Rela *relocs,
     Elf_Internal_Sym *local_syms, asection **local_sections);
# 1101 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  bfd_boolean (*elf_backend_finish_dynamic_symbol)
    (bfd *output_bfd, struct bfd_link_info *info,
     struct elf_link_hash_entry *h, Elf_Internal_Sym *sym);





  bfd_boolean (*elf_backend_finish_dynamic_sections)
    (bfd *output_bfd, struct bfd_link_info *info);



  void (*elf_backend_begin_write_processing)
    (bfd *, struct bfd_link_info *);




  void (*elf_backend_final_write_processing)
    (bfd *, bfd_boolean linker);




  int (*elf_backend_additional_program_headers)
    (bfd *, struct bfd_link_info *);



  bfd_boolean (*elf_backend_modify_segment_map)
    (bfd *, struct bfd_link_info *);



  bfd_boolean (*elf_backend_modify_program_headers)
    (bfd *, struct bfd_link_info *);



  bfd_boolean (*elf_backend_allow_non_load_phdr)
    (bfd *, const Elf_Internal_Phdr *, unsigned);



  void (*gc_keep)
    (struct bfd_link_info *);



  bfd_boolean (*gc_mark_dynamic_ref)
    (struct elf_link_hash_entry *, void *);



  elf_gc_mark_hook_fn gc_mark_hook;



  bfd_boolean (*gc_mark_extra_sections)
    (struct bfd_link_info *, elf_gc_mark_hook_fn);




  bfd_boolean (*gc_sweep_hook)
    (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);




  void (*elf_backend_post_process_headers)
    (bfd *, struct bfd_link_info *);




  const char *(*elf_backend_print_symbol_all)
    (bfd *, void *, asymbol *);





  bfd_boolean (*elf_backend_output_arch_local_syms)
    (bfd *, struct bfd_link_info *, void *,
     bfd_boolean (*) (void *, const char *, Elf_Internal_Sym *, asection *,
        struct elf_link_hash_entry *));




  bfd_boolean (*elf_backend_output_arch_syms)
    (bfd *, struct bfd_link_info *, void *,
     bfd_boolean (*) (void *, const char *, Elf_Internal_Sym *, asection *,
        struct elf_link_hash_entry *));



  unsigned int (*elf_backend_filter_implib_symbols)
    (bfd *, struct bfd_link_info *, asymbol **, long);






  void (*elf_backend_copy_indirect_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *,
     struct elf_link_hash_entry *);



  void (*elf_backend_hide_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean);



  bfd_boolean (*elf_backend_fixup_symbol)
    (struct bfd_link_info *, struct elf_link_hash_entry *);


  void (*elf_backend_merge_symbol_attribute)
    (struct elf_link_hash_entry *, const Elf_Internal_Sym *, bfd_boolean,
     bfd_boolean);



  char *(*elf_backend_get_target_dtag)
    (bfd_vma);



  bfd_boolean (*elf_backend_ignore_undef_symbol)
    (struct elf_link_hash_entry *);



  bfd_boolean (*elf_backend_emit_relocs)
    (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *,
     struct elf_link_hash_entry **);



  void (*elf_backend_update_relocs)
    (asection *, struct bfd_elf_section_reloc_data *);



  unsigned int (*elf_backend_count_relocs)
    (struct bfd_link_info *, asection *);



  unsigned int (*elf_backend_count_additional_relocs)
    (asection *);



  bfd_boolean (*sort_relocs_p)
    (asection *);



  bfd_boolean (*elf_backend_grok_prstatus)
    (bfd *, Elf_Internal_Note *);



  bfd_boolean (*elf_backend_grok_psinfo)
    (bfd *, Elf_Internal_Note *);


  char *(*elf_backend_write_core_note)
    (bfd *abfd, char *buf, int *bufsiz, int note_type, ...);



  flagword (*elf_backend_lookup_section_flags_hook)
    (char *);


  enum elf_reloc_type_class (*elf_backend_reloc_type_class)
  (const struct bfd_link_info *, const asection *, const Elf_Internal_Rela *);



  bfd_boolean (*elf_backend_discard_info)
    (bfd *, struct elf_reloc_cookie *, struct bfd_link_info *);



  bfd_boolean (*elf_backend_ignore_discarded_relocs)
    (asection *);



  unsigned int (*action_discarded)
    (asection *);




  unsigned int (*elf_backend_eh_frame_address_size)
    (bfd *, const asection *);




  bfd_boolean (*elf_backend_can_make_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);
  bfd_boolean (*elf_backend_can_make_lsda_relative_eh_frame)
     (bfd *, struct bfd_link_info *, asection *);





  bfd_byte (*elf_backend_encode_eh_address)
     (bfd *abfd, struct bfd_link_info *info,
      asection *osec, bfd_vma offset,
      asection *loc_sec, bfd_vma loc_offset,
      bfd_vma *encoded);



  bfd_boolean (*elf_backend_write_section)
    (bfd *, struct bfd_link_info *, asection *, bfd_byte *);



  irix_compat_t (*elf_backend_mips_irix_compat)
    (bfd *);

  reloc_howto_type *(*elf_backend_mips_rtype_to_howto)
    (unsigned int, bfd_boolean);



  const struct ecoff_debug_swap *elf_backend_ecoff_debug_swap;



  bfd *(*elf_backend_bfd_from_remote_memory)
    (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
     int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr,
    bfd_size_type len));



  bfd_vma (*plt_sym_val) (bfd_vma, const asection *, const arelent *);


  bfd_boolean (*common_definition) (Elf_Internal_Sym *);


  unsigned int (*common_section_index) (asection *);


  asection *(*common_section) (asection *);


  bfd_boolean (*merge_symbol) (struct elf_link_hash_entry *,
          const Elf_Internal_Sym *, asection **,
          bfd_boolean, bfd_boolean,
          bfd *, const asection *);


  bfd_boolean (*elf_hash_symbol) (struct elf_link_hash_entry *);


  bfd_boolean (*is_function_type) (unsigned int type);




  bfd_size_type (*maybe_function_sym) (const asymbol *sym, asection *sec,
           bfd_vma *code_off);




  asection *(*get_reloc_section) (bfd *abfd, const char *name);







  bfd_boolean (*elf_backend_copy_special_section_fields)
    (const bfd *ibfd, bfd *obfd, const Elf_Internal_Shdr *isection,
     Elf_Internal_Shdr *osection);


  void (*link_order_error_handler) (const char *, ...);


  const char *relplt_name;


  int elf_machine_alt1;
  int elf_machine_alt2;

  const struct elf_size_info *s;


  const struct bfd_elf_special_section *special_sections;



  bfd_vma got_header_size;



  bfd_vma (*got_elt_size) (bfd *, struct bfd_link_info *,
      struct elf_link_hash_entry *h,
      bfd *ibfd, unsigned long symndx);


  const char *obj_attrs_vendor;


  const char *obj_attrs_section;



  int (*obj_attrs_arg_type) (int);


  unsigned int obj_attrs_section_type;






  int (*obj_attrs_order) (int);



  bfd_boolean (*obj_attrs_handle_unknown) (bfd *, int);



  enum elf_property_kind (*parse_gnu_properties) (bfd *, unsigned int,
        bfd_byte *,
        unsigned int);


  bfd_boolean (*merge_gnu_properties) (struct bfd_link_info *, bfd *,
           elf_property *, elf_property *);


  bfd *(*setup_gnu_properties) (struct bfd_link_info *);


  int (*compact_eh_encoding) (struct bfd_link_info *);


  int (*cant_unwind_opcode) (struct bfd_link_info *);


  unsigned static_tls_alignment;


  unsigned stack_align;


  unsigned long elf_strtab_flags;





  unsigned collect : 1;





  unsigned type_change_ok : 1;




  unsigned may_use_rel_p : 1;




  unsigned may_use_rela_p : 1;






  unsigned default_use_rela_p : 1;


  unsigned rela_plts_and_copies_p : 1;




  unsigned rela_normal : 1;



  unsigned dtrel_excludes_plt : 1;



  unsigned sign_extend_vma : 1;

  unsigned want_got_plt : 1;
  unsigned plt_readonly : 1;
  unsigned want_plt_sym : 1;
  unsigned plt_not_loaded : 1;
  unsigned plt_alignment : 4;
  unsigned can_gc_sections : 1;
  unsigned can_refcount : 1;
  unsigned want_got_sym : 1;
  unsigned want_dynbss : 1;
  unsigned want_dynrelro : 1;




  unsigned want_p_paddr_set_to_zero : 1;



  unsigned no_page_alias : 1;





  unsigned default_execstack : 1;




  unsigned caches_rawsize : 1;



  unsigned extern_protected_data : 1;



  unsigned always_renumber_dynsyms : 1;
};



struct bfd_elf_section_reloc_data
{


  Elf_Internal_Shdr *hdr;

  unsigned int count;


  int idx;


  struct elf_link_hash_entry **hashes;
};




struct bfd_elf_section_data
{

  Elf_Internal_Shdr this_hdr;


  struct flag_info *section_flag_info;



  struct bfd_elf_section_reloc_data rel, rela;


  int this_idx;





  int dynindx;


  asection *linked_to;




  Elf_Internal_Rela *relocs;



  void *local_dynrel;


  asection *sreloc;

  union {

    const char *name;


    struct bfd_symbol *id;
  } group;



  asection *sec_group;



  asection *next_in_group;



  struct eh_cie_fde *fde_list;


  asection *eh_frame_entry;


  void *sec_info;
};
# 1670 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
typedef struct obj_attribute
{
# 1680 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  int type;
  unsigned int i;
  char *s;
} obj_attribute;

typedef struct obj_attribute_list
{
  struct obj_attribute_list *next;
  unsigned int tag;
  obj_attribute attr;
} obj_attribute_list;
# 1702 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
enum
{
  Tag_NULL = 0,
  Tag_File = 1,
  Tag_Section = 2,
  Tag_Symbol = 3,
  Tag_compatibility = 32
};



struct sdt_note
{
  struct sdt_note *next;
  bfd_size_type size;
  bfd_byte data[1];
};


struct core_elf_obj_tdata
{
  int signal;
  int pid;
  int lwpid;
  char* program;
  char* command;
};


struct output_elf_obj_tdata
{
  struct elf_segment_map *seg_map;
  struct elf_strtab_hash *strtab_ptr;


  asymbol **section_syms;



  asection *eh_frame_hdr;


  struct
  {
    bfd_boolean (*after_write_object_contents) (bfd *);
    const char *style;
    asection *sec;
  } build_id;


  bfd_size_type program_header_size;


  file_ptr next_file_pos;

  int num_section_syms;
  unsigned int shstrtab_section, strtab_section;


  unsigned int stack_flags;



  bfd_boolean linker;


  bfd_boolean flags_init;
};




enum elf_gnu_symbols
{
  elf_gnu_symbol_none = 0,
  elf_gnu_symbol_any = 1 << 0,
  elf_gnu_symbol_ifunc = (elf_gnu_symbol_any | 1 << 1),
  elf_gnu_symbol_unique = (elf_gnu_symbol_any | 1 << 2),
  elf_gnu_symbol_all = (elf_gnu_symbol_ifunc | elf_gnu_symbol_unique)
};

typedef struct elf_section_list
{
  Elf_Internal_Shdr hdr;
  unsigned int ndx;
  struct elf_section_list * next;
} elf_section_list;




struct elf_obj_tdata
{
  Elf_Internal_Ehdr elf_header[1];
  Elf_Internal_Shdr **elf_sect_ptr;
  Elf_Internal_Phdr *phdr;
  Elf_Internal_Shdr symtab_hdr;
  Elf_Internal_Shdr shstrtab_hdr;
  Elf_Internal_Shdr strtab_hdr;
  Elf_Internal_Shdr dynsymtab_hdr;
  Elf_Internal_Shdr dynstrtab_hdr;
  Elf_Internal_Shdr dynversym_hdr;
  Elf_Internal_Shdr dynverref_hdr;
  Elf_Internal_Shdr dynverdef_hdr;
  elf_section_list * symtab_shndx_list;
  bfd_vma gp;
  unsigned int gp_size;
  unsigned int num_elf_sections;




  struct elf_link_hash_entry **sym_hashes;




  union
    {
      bfd_signed_vma *refcounts;
      bfd_vma *offsets;
      struct got_entry **ents;
    } local_got;
# 1834 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
  const char *dt_name;



  const char *dt_audit;


  void *line_info;


  struct dwarf1_debug *dwarf1_find_line_info;


  void *dwarf2_find_line_info;


  void *elf_find_function_cache;


  unsigned int cverdefs;


  unsigned int cverrefs;


  Elf_Internal_Verdef *verdef;


  Elf_Internal_Verneed *verref;


  asection *eh_frame_section;


  void *symbuf;



  elf_property_list *properties;

  obj_attribute known_obj_attributes[2][71];
  obj_attribute_list *other_obj_attributes[2];




  struct sdt_note *sdt_note_head;

  Elf_Internal_Shdr **group_sect_ptr;
  int num_group;

  unsigned int symtab_section, dynsymtab_section;
  unsigned int dynversym_section, dynverdef_section, dynverref_section;



  enum elf_target_id object_id;




  enum dynamic_lib_link_class dyn_lib_class;






  bfd_boolean bad_symtab;

  enum elf_gnu_symbols has_gnu_symbols;


  struct core_elf_obj_tdata *core;


  struct output_elf_obj_tdata *o;
};
# 1960 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
extern void _bfd_elf_swap_verdef_in
  (bfd *, const Elf_External_Verdef *, Elf_Internal_Verdef *);
extern void _bfd_elf_swap_verdef_out
  (bfd *, const Elf_Internal_Verdef *, Elf_External_Verdef *);
extern void _bfd_elf_swap_verdaux_in
  (bfd *, const Elf_External_Verdaux *, Elf_Internal_Verdaux *);
extern void _bfd_elf_swap_verdaux_out
  (bfd *, const Elf_Internal_Verdaux *, Elf_External_Verdaux *);
extern void _bfd_elf_swap_verneed_in
  (bfd *, const Elf_External_Verneed *, Elf_Internal_Verneed *);
extern void _bfd_elf_swap_verneed_out
  (bfd *, const Elf_Internal_Verneed *, Elf_External_Verneed *);
extern void _bfd_elf_swap_vernaux_in
  (bfd *, const Elf_External_Vernaux *, Elf_Internal_Vernaux *);
extern void _bfd_elf_swap_vernaux_out
  (bfd *, const Elf_Internal_Vernaux *, Elf_External_Vernaux *);
extern void _bfd_elf_swap_versym_in
  (bfd *, const Elf_External_Versym *, Elf_Internal_Versym *);
extern void _bfd_elf_swap_versym_out
  (bfd *, const Elf_Internal_Versym *, Elf_External_Versym *);

extern unsigned int _bfd_elf_section_from_bfd_section
  (bfd *, asection *);
extern char *bfd_elf_string_from_elf_section
  (bfd *, unsigned, unsigned);
extern Elf_Internal_Sym *bfd_elf_get_elf_syms
  (bfd *, Elf_Internal_Shdr *, size_t, size_t, Elf_Internal_Sym *, void *,
   Elf_External_Sym_Shndx *);
extern const char *bfd_elf_sym_name
  (bfd *, Elf_Internal_Shdr *, Elf_Internal_Sym *, asection *);

extern bfd_boolean _bfd_elf_copy_private_bfd_data
  (bfd *, bfd *);
extern bfd_boolean _bfd_elf_print_private_bfd_data
  (bfd *, void *);
const char * _bfd_elf_get_symbol_version_string
  (bfd *, asymbol *, bfd_boolean *);
extern void bfd_elf_print_symbol
  (bfd *, void *, asymbol *, bfd_print_symbol_type);

extern unsigned int _bfd_elf_eh_frame_address_size
  (bfd *, const asection *);
extern bfd_byte _bfd_elf_encode_eh_address
  (bfd *abfd, struct bfd_link_info *info, asection *osec, bfd_vma offset,
   asection *loc_sec, bfd_vma loc_offset, bfd_vma *encoded);
extern bfd_boolean _bfd_elf_can_make_relative
  (bfd *input_bfd, struct bfd_link_info *info, asection *eh_frame_section);

extern enum elf_reloc_type_class _bfd_elf_reloc_type_class
  (const struct bfd_link_info *, const asection *,
   const Elf_Internal_Rela *);
extern bfd_vma _bfd_elf_rela_local_sym
  (bfd *, Elf_Internal_Sym *, asection **, Elf_Internal_Rela *);
extern bfd_vma _bfd_elf_rel_local_sym
  (bfd *, Elf_Internal_Sym *, asection **, bfd_vma);
extern bfd_vma _bfd_elf_section_offset
  (bfd *, struct bfd_link_info *, asection *, bfd_vma);

extern unsigned long bfd_elf_hash
  (const char *);
extern unsigned long bfd_elf_gnu_hash
  (const char *);

extern bfd_reloc_status_type bfd_elf_generic_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
extern bfd_boolean bfd_elf_allocate_object
  (bfd *, size_t, enum elf_target_id);
extern bfd_boolean bfd_elf_make_object
  (bfd *);
extern bfd_boolean bfd_elf_mkcorefile
  (bfd *);
extern bfd_boolean _bfd_elf_make_section_from_shdr
  (bfd *, Elf_Internal_Shdr *, const char *, int);
extern bfd_boolean _bfd_elf_make_section_from_phdr
  (bfd *, Elf_Internal_Phdr *, int, const char *);
extern struct bfd_hash_entry *_bfd_elf_link_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
extern struct bfd_link_hash_table *_bfd_elf_link_hash_table_create
  (bfd *);
extern void _bfd_elf_link_hash_table_free
  (bfd *);
extern void _bfd_elf_link_hash_copy_indirect
  (struct bfd_link_info *, struct elf_link_hash_entry *,
   struct elf_link_hash_entry *);
extern void _bfd_elf_link_hash_hide_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *, bfd_boolean);
extern bfd_boolean _bfd_elf_link_hash_fixup_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);
extern bfd_boolean _bfd_elf_link_hash_table_init
  (struct elf_link_hash_table *, bfd *,
   struct bfd_hash_entry *(*)
     (struct bfd_hash_entry *, struct bfd_hash_table *, const char *),
   unsigned int, enum elf_target_id);
extern bfd_boolean _bfd_elf_slurp_version_tables
  (bfd *, bfd_boolean);
extern bfd_boolean _bfd_elf_merge_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_match_sections_by_type
  (bfd *, const asection *, bfd *, const asection *);
extern bfd_boolean bfd_elf_is_group_section
  (bfd *, const struct bfd_section *);
extern bfd_boolean _bfd_elf_section_already_linked
  (bfd *, asection *, struct bfd_link_info *);
extern void bfd_elf_set_group_contents
  (bfd *, asection *, void *);
extern unsigned int _bfd_elf_filter_global_symbols
  (bfd *, struct bfd_link_info *, asymbol **, long);
extern asection *_bfd_elf_check_kept_section
  (asection *, struct bfd_link_info *);

extern void _bfd_elf_copy_link_hash_symbol_type
  (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
extern bfd_boolean _bfd_elf_size_group_sections
  (struct bfd_link_info *);
extern bfd_boolean _bfd_elf_fixup_group_sections
(bfd *, asection *);
extern bfd_boolean _bfd_elf_copy_private_header_data
  (bfd *, bfd *);
extern bfd_boolean _bfd_elf_copy_private_symbol_data
  (bfd *, asymbol *, bfd *, asymbol *);


extern bfd_boolean _bfd_elf_init_private_section_data
  (bfd *, asection *, bfd *, asection *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_copy_private_section_data
  (bfd *, asection *, bfd *, asection *);
extern bfd_boolean _bfd_elf_write_object_contents
  (bfd *);
extern bfd_boolean _bfd_elf_write_corefile_contents
  (bfd *);
extern bfd_boolean _bfd_elf_set_section_contents
  (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
extern long _bfd_elf_get_symtab_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_symtab
  (bfd *, asymbol **);
extern long _bfd_elf_get_dynamic_symtab_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_dynamic_symtab
  (bfd *, asymbol **);
extern long _bfd_elf_get_synthetic_symtab
  (bfd *, long, asymbol **, long, asymbol **, asymbol **);
extern long _bfd_elf_get_reloc_upper_bound
  (bfd *, sec_ptr);
extern long _bfd_elf_canonicalize_reloc
  (bfd *, sec_ptr, arelent **, asymbol **);
extern asection * _bfd_elf_get_dynamic_reloc_section
  (bfd *, asection *, bfd_boolean);
extern asection * _bfd_elf_make_dynamic_reloc_section
  (asection *, bfd *, unsigned int, bfd *, bfd_boolean);
extern long _bfd_elf_get_dynamic_reloc_upper_bound
  (bfd *);
extern long _bfd_elf_canonicalize_dynamic_reloc
  (bfd *, arelent **, asymbol **);
extern asymbol *_bfd_elf_make_empty_symbol
  (bfd *);
extern void _bfd_elf_get_symbol_info
  (bfd *, asymbol *, symbol_info *);
extern bfd_boolean _bfd_elf_is_local_label_name
  (bfd *, const char *);
extern alent *_bfd_elf_get_lineno
  (bfd *, asymbol *);
extern bfd_boolean _bfd_elf_set_arch_mach
  (bfd *, enum bfd_architecture, unsigned long);
extern bfd_boolean _bfd_elf_find_nearest_line
  (bfd *, asymbol **, asection *, bfd_vma,
   const char **, const char **, unsigned int *, unsigned int *);
extern bfd_boolean _bfd_elf_find_line
  (bfd *, asymbol **, asymbol *, const char **, unsigned int *);
extern bfd_boolean _bfd_elf_find_inliner_info
  (bfd *, const char **, const char **, unsigned int *);
extern asymbol *_bfd_elf_find_function
  (bfd *, asymbol **, asection *, bfd_vma, const char **, const char **);


extern int _bfd_elf_sizeof_headers
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_new_section_hook
  (bfd *, asection *);
extern const struct bfd_elf_special_section *_bfd_elf_get_special_section
  (const char *, const struct bfd_elf_special_section *, unsigned int);
extern const struct bfd_elf_special_section *_bfd_elf_get_sec_type_attr
  (bfd *, asection *);


extern void _bfd_elf_no_info_to_howto
  (bfd *, arelent *, Elf_Internal_Rela *);

extern bfd_boolean bfd_section_from_shdr
  (bfd *, unsigned int shindex);
extern bfd_boolean bfd_section_from_phdr
  (bfd *, Elf_Internal_Phdr *, int);

extern int _bfd_elf_symbol_from_bfd_symbol
  (bfd *, asymbol **);

extern Elf_Internal_Sym *bfd_sym_from_r_symndx
  (struct sym_cache *, bfd *, unsigned long);
extern asection *bfd_section_from_elf_index
  (bfd *, unsigned int);

extern struct elf_strtab_hash * _bfd_elf_strtab_init
  (void);
extern void _bfd_elf_strtab_free
  (struct elf_strtab_hash *);
extern size_t _bfd_elf_strtab_add
  (struct elf_strtab_hash *, const char *, bfd_boolean);
extern void _bfd_elf_strtab_addref
  (struct elf_strtab_hash *, size_t);
extern void _bfd_elf_strtab_delref
  (struct elf_strtab_hash *, size_t);
extern unsigned int _bfd_elf_strtab_refcount
  (struct elf_strtab_hash *, size_t);
extern void _bfd_elf_strtab_clear_all_refs
  (struct elf_strtab_hash *);
extern void *_bfd_elf_strtab_save
  (struct elf_strtab_hash *);
extern void _bfd_elf_strtab_restore
  (struct elf_strtab_hash *, void *);
extern bfd_size_type _bfd_elf_strtab_size
  (struct elf_strtab_hash *);
extern bfd_size_type _bfd_elf_strtab_offset
  (struct elf_strtab_hash *, size_t);
extern bfd_boolean _bfd_elf_strtab_emit
  (bfd *, struct elf_strtab_hash *);
extern void _bfd_elf_strtab_finalize
  (struct elf_strtab_hash *);

extern bfd_boolean bfd_elf_parse_eh_frame_entries
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_parse_eh_frame_entry
  (struct bfd_link_info *, asection *, struct elf_reloc_cookie *);
extern void _bfd_elf_parse_eh_frame
  (bfd *, struct bfd_link_info *, asection *, struct elf_reloc_cookie *);
extern bfd_boolean _bfd_elf_end_eh_frame_parsing
  (struct bfd_link_info *info);

extern bfd_boolean _bfd_elf_discard_section_eh_frame
  (bfd *, struct bfd_link_info *, asection *,
   bfd_boolean (*) (bfd_vma, void *), struct elf_reloc_cookie *);
extern bfd_boolean _bfd_elf_adjust_eh_frame_global_symbol
  (struct elf_link_hash_entry *, void *);
extern bfd_boolean _bfd_elf_discard_section_eh_frame_hdr
  (bfd *, struct bfd_link_info *);
extern bfd_vma _bfd_elf_eh_frame_section_offset
  (bfd *, struct bfd_link_info *, asection *, bfd_vma);
extern bfd_boolean _bfd_elf_write_section_eh_frame
  (bfd *, struct bfd_link_info *, asection *, bfd_byte *);
bfd_boolean _bfd_elf_write_section_eh_frame_entry
  (bfd *, struct bfd_link_info *, asection *, bfd_byte *);
extern bfd_boolean _bfd_elf_fixup_eh_frame_hdr (struct bfd_link_info *);
extern bfd_boolean _bfd_elf_write_section_eh_frame_hdr
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_eh_frame_present
  (struct bfd_link_info *);
extern bfd_boolean _bfd_elf_eh_frame_entry_present
  (struct bfd_link_info *);
extern bfd_boolean _bfd_elf_maybe_strip_eh_frame_hdr
  (struct bfd_link_info *);

extern bfd_boolean _bfd_elf_hash_symbol (struct elf_link_hash_entry *);

extern long _bfd_elf_link_lookup_local_dynindx
  (struct bfd_link_info *, bfd *, long);
extern bfd_boolean _bfd_elf_compute_section_file_positions
  (bfd *, struct bfd_link_info *);
extern file_ptr _bfd_elf_assign_file_position_for_section
  (Elf_Internal_Shdr *, file_ptr, bfd_boolean);

extern bfd_boolean _bfd_elf_validate_reloc
  (bfd *, arelent *);

extern bfd_boolean _bfd_elf_link_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_link_omit_section_dynsym
  (bfd *, struct bfd_link_info *, asection *);
extern bfd_boolean _bfd_elf_create_dynamic_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_create_got_section
  (bfd *, struct bfd_link_info *);
extern asection *_bfd_elf_section_for_symbol
  (struct elf_reloc_cookie *, unsigned long, bfd_boolean);
extern struct elf_link_hash_entry *_bfd_elf_define_linkage_sym
  (bfd *, struct bfd_link_info *, asection *, const char *);
extern void _bfd_elf_init_1_index_section
  (bfd *, struct bfd_link_info *);
extern void _bfd_elf_init_2_index_sections
  (bfd *, struct bfd_link_info *);

extern bfd_boolean _bfd_elfcore_make_pseudosection
  (bfd *, char *, size_t, ufile_ptr);
extern char *_bfd_elfcore_strndup
  (bfd *, char *, size_t);

extern Elf_Internal_Rela *_bfd_elf_link_read_relocs
  (bfd *, asection *, void *, Elf_Internal_Rela *, bfd_boolean);

extern bfd_boolean _bfd_elf_link_output_relocs
  (bfd *, asection *, Elf_Internal_Shdr *, Elf_Internal_Rela *,
   struct elf_link_hash_entry **);

extern bfd_boolean _bfd_elf_adjust_dynamic_copy
  (struct bfd_link_info *, struct elf_link_hash_entry *, asection *);

extern bfd_boolean _bfd_elf_dynamic_symbol_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, bfd_boolean);

extern bfd_boolean _bfd_elf_symbol_refs_local_p
  (struct elf_link_hash_entry *, struct bfd_link_info *, bfd_boolean);

extern bfd_reloc_status_type bfd_elf_perform_complex_relocation
  (bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, bfd_vma);

extern bfd_boolean _bfd_elf_setup_sections
  (bfd *);

extern struct bfd_link_hash_entry *bfd_elf_define_start_stop
  (struct bfd_link_info *, const char *, asection *);

extern void _bfd_elf_post_process_headers (bfd * , struct bfd_link_info *);

extern const bfd_target *bfd_elf32_object_p
  (bfd *);
extern const bfd_target *bfd_elf32_core_file_p
  (bfd *);
extern char *bfd_elf32_core_file_failing_command
  (bfd *);
extern int bfd_elf32_core_file_failing_signal
  (bfd *);
extern bfd_boolean bfd_elf32_core_file_matches_executable_p
  (bfd *, bfd *);
extern int bfd_elf32_core_file_pid
  (bfd *);

extern bfd_boolean bfd_elf32_swap_symbol_in
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
extern void bfd_elf32_swap_symbol_out
  (bfd *, const Elf_Internal_Sym *, void *, void *);
extern void bfd_elf32_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf32_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf32_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf32_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf32_swap_phdr_in
  (bfd *, const Elf32_External_Phdr *, Elf_Internal_Phdr *);
extern void bfd_elf32_swap_phdr_out
  (bfd *, const Elf_Internal_Phdr *, Elf32_External_Phdr *);
extern void bfd_elf32_swap_dyn_in
  (bfd *, const void *, Elf_Internal_Dyn *);
extern void bfd_elf32_swap_dyn_out
  (bfd *, const Elf_Internal_Dyn *, void *);
extern long bfd_elf32_slurp_symbol_table
  (bfd *, asymbol **, bfd_boolean);
extern bfd_boolean bfd_elf32_write_shdrs_and_ehdr
  (bfd *);
extern int bfd_elf32_write_out_phdrs
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
extern bfd_boolean bfd_elf32_checksum_contents
  (bfd * , void (*) (const void *, size_t, void *), void *);
extern void bfd_elf32_write_relocs
  (bfd *, asection *, void *);
extern bfd_boolean bfd_elf32_slurp_reloc_table
  (bfd *, asection *, asymbol **, bfd_boolean);

extern const bfd_target *bfd_elf64_object_p
  (bfd *);
extern const bfd_target *bfd_elf64_core_file_p
  (bfd *);
extern char *bfd_elf64_core_file_failing_command
  (bfd *);
extern int bfd_elf64_core_file_failing_signal
  (bfd *);
extern bfd_boolean bfd_elf64_core_file_matches_executable_p
  (bfd *, bfd *);
extern int bfd_elf64_core_file_pid
  (bfd *);

extern bfd_boolean bfd_elf64_swap_symbol_in
  (bfd *, const void *, const void *, Elf_Internal_Sym *);
extern void bfd_elf64_swap_symbol_out
  (bfd *, const Elf_Internal_Sym *, void *, void *);
extern void bfd_elf64_swap_reloc_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf64_swap_reloc_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf64_swap_reloca_in
  (bfd *, const bfd_byte *, Elf_Internal_Rela *);
extern void bfd_elf64_swap_reloca_out
  (bfd *, const Elf_Internal_Rela *, bfd_byte *);
extern void bfd_elf64_swap_phdr_in
  (bfd *, const Elf64_External_Phdr *, Elf_Internal_Phdr *);
extern void bfd_elf64_swap_phdr_out
  (bfd *, const Elf_Internal_Phdr *, Elf64_External_Phdr *);
extern void bfd_elf64_swap_dyn_in
  (bfd *, const void *, Elf_Internal_Dyn *);
extern void bfd_elf64_swap_dyn_out
  (bfd *, const Elf_Internal_Dyn *, void *);
extern long bfd_elf64_slurp_symbol_table
  (bfd *, asymbol **, bfd_boolean);
extern bfd_boolean bfd_elf64_write_shdrs_and_ehdr
  (bfd *);
extern int bfd_elf64_write_out_phdrs
  (bfd *, const Elf_Internal_Phdr *, unsigned int);
extern bfd_boolean bfd_elf64_checksum_contents
  (bfd * , void (*) (const void *, size_t, void *), void *);
extern void bfd_elf64_write_relocs
  (bfd *, asection *, void *);
extern bfd_boolean bfd_elf64_slurp_reloc_table
  (bfd *, asection *, asymbol **, bfd_boolean);

extern bfd_boolean _bfd_elf_default_relocs_compatible
  (const bfd_target *, const bfd_target *);

extern bfd_boolean _bfd_elf_relocs_compatible
  (const bfd_target *, const bfd_target *);
extern bfd_boolean _bfd_elf_notice_as_needed
  (bfd *, struct bfd_link_info *, enum notice_asneeded_action);

extern struct elf_link_hash_entry *_bfd_elf_archive_symbol_lookup
  (bfd *, struct bfd_link_info *, const char *);
extern bfd_boolean bfd_elf_link_add_symbols
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_add_dynamic_entry
  (struct bfd_link_info *, bfd_vma, bfd_vma);
extern bfd_boolean _bfd_elf_link_check_relocs
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_link_record_dynamic_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);

extern int bfd_elf_link_record_local_dynamic_symbol
  (struct bfd_link_info *, bfd *, long);

extern bfd_boolean _bfd_elf_close_and_cleanup
  (bfd *);

extern bfd_boolean _bfd_elf_common_definition
  (Elf_Internal_Sym *);

extern unsigned int _bfd_elf_common_section_index
  (asection *);

extern asection *_bfd_elf_common_section
  (asection *);

extern bfd_vma _bfd_elf_default_got_elt_size
(bfd *, struct bfd_link_info *, struct elf_link_hash_entry *, bfd *,
 unsigned long);

extern bfd_reloc_status_type _bfd_elf_rel_vtable_reloc_fn
  (bfd *, arelent *, struct bfd_symbol *, void *,
   asection *, bfd *, char **);

extern bfd_boolean bfd_elf_final_link
  (bfd *, struct bfd_link_info *);

extern void _bfd_elf_gc_keep
  (struct bfd_link_info *info);

extern bfd_boolean bfd_elf_gc_mark_dynamic_ref_symbol
  (struct elf_link_hash_entry *h, void *inf);

extern bfd_boolean bfd_elf_gc_sections
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_record_vtinherit
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);

extern bfd_boolean bfd_elf_gc_record_vtentry
  (bfd *, asection *, struct elf_link_hash_entry *, bfd_vma);

extern asection *_bfd_elf_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

extern asection *_bfd_elf_gc_mark_rsec
  (struct bfd_link_info *, asection *, elf_gc_mark_hook_fn,
   struct elf_reloc_cookie *, bfd_boolean *);

extern bfd_boolean _bfd_elf_gc_mark_reloc
  (struct bfd_link_info *, asection *, elf_gc_mark_hook_fn,
   struct elf_reloc_cookie *);

extern bfd_boolean _bfd_elf_gc_mark_fdes
  (struct bfd_link_info *, asection *, asection *, elf_gc_mark_hook_fn,
   struct elf_reloc_cookie *);

extern bfd_boolean _bfd_elf_gc_mark
  (struct bfd_link_info *, asection *, elf_gc_mark_hook_fn);

extern bfd_boolean _bfd_elf_gc_mark_extra_sections
  (struct bfd_link_info *, elf_gc_mark_hook_fn);

extern bfd_boolean bfd_elf_gc_common_finalize_got_offsets
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_gc_common_final_link
  (bfd *, struct bfd_link_info *);

extern bfd_boolean bfd_elf_reloc_symbol_deleted_p
  (bfd_vma, void *);

extern struct elf_segment_map * _bfd_elf_make_dynamic_segment
  (bfd *, asection *);

extern bfd_boolean _bfd_elf_map_sections_to_segments
  (bfd *, struct bfd_link_info *);

extern bfd_boolean _bfd_elf_is_function_type (unsigned int);

extern bfd_size_type _bfd_elf_maybe_function_sym (const asymbol *, asection *,
        bfd_vma *);

extern asection *_bfd_elf_plt_get_reloc_section (bfd *, const char *);

extern int bfd_elf_get_default_section_type (flagword);

extern bfd_boolean bfd_elf_lookup_section_flags
  (struct bfd_link_info *, struct flag_info *, asection *);

extern Elf_Internal_Phdr * _bfd_elf_find_segment_containing_section
  (bfd * abfd, asection * section);


extern unsigned int _bfd_elf_ppc_at_tls_transform
  (unsigned int, unsigned int);

extern unsigned int _bfd_elf_ppc_at_tprel_transform
  (unsigned int, unsigned int);

extern bfd_boolean _bfd_elf_ppc_set_arch (bfd *);

extern void _bfd_elf_ppc_merge_fp_attributes (bfd *, struct bfd_link_info *);


extern char *elfcore_write_note
  (bfd *, char *, int *, const char *, int, const void *, int);
extern char *elfcore_write_prpsinfo
  (bfd *, char *, int *, const char *, const char *);
extern char *elfcore_write_prstatus
  (bfd *, char *, int *, long, int, const void *);
extern char * elfcore_write_pstatus
  (bfd *, char *, int *, long, int, const void *);
extern char *elfcore_write_prfpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_prxfpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_xstatereg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_vmx
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_ppc_vsx
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_timer
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_todcmp
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_todpreg
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_ctrs
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_prefix
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_last_break
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_system_call
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_tdb
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_vxrs_low
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_vxrs_high
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_gs_cb
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_s390_gs_bc
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_arm_vfp
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_tls
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_hw_break
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_aarch_hw_watch
  (bfd *, char *, int *, const void *, int);
extern char *elfcore_write_lwpstatus
  (bfd *, char *, int *, long, int, const void *);
extern char *elfcore_write_register_note
  (bfd *, char *, int *, const char *, const void *, int);
# 2563 "/doner/binutils/binutils-7a31b38/bfd/elf-bfd.h"
struct elf_internal_linux_prpsinfo
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    unsigned long pr_flag;
    unsigned int pr_uid;
    unsigned int pr_gid;
    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
    char pr_fname[16 + 1];
    char pr_psargs[80 + 1];
  };


extern char *elfcore_write_linux_prpsinfo32
  (bfd *, char *, int *, const struct elf_internal_linux_prpsinfo *);


extern char *elfcore_write_linux_prpsinfo64
  (bfd *, char *, int *, const struct elf_internal_linux_prpsinfo *);


extern char *elfcore_write_ppc_linux_prpsinfo32
  (bfd *, char *, int *, const struct elf_internal_linux_prpsinfo *);

extern bfd *_bfd_elf32_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type));
extern bfd *_bfd_elf64_bfd_from_remote_memory
  (bfd *templ, bfd_vma ehdr_vma, bfd_size_type size, bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type));

extern bfd_vma bfd_elf_obj_attr_size (bfd *);
extern void bfd_elf_set_obj_attr_contents (bfd *, bfd_byte *, bfd_vma);
extern int bfd_elf_get_obj_attr_int (bfd *, int, unsigned int);
extern void bfd_elf_add_obj_attr_int (bfd *, int, unsigned int, unsigned int);


extern void bfd_elf_add_obj_attr_string (bfd *, int, unsigned int, const char *);


extern void bfd_elf_add_obj_attr_int_string (bfd *, int, unsigned int,
          unsigned int, const char *);




extern char *_bfd_elf_attr_strdup (bfd *, const char *);
extern void _bfd_elf_copy_obj_attributes (bfd *, bfd *);
extern int _bfd_elf_obj_attrs_arg_type (bfd *, int, unsigned int);
extern void _bfd_elf_parse_attributes (bfd *, Elf_Internal_Shdr *);
extern bfd_boolean _bfd_elf_merge_object_attributes
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_merge_unknown_attribute_low (bfd *, bfd *, int);
extern bfd_boolean _bfd_elf_merge_unknown_attribute_list (bfd *, bfd *);
extern Elf_Internal_Shdr *_bfd_elf_single_rel_hdr (asection *sec);

extern bfd_boolean _bfd_elf_parse_gnu_properties
  (bfd *, Elf_Internal_Note *);
extern elf_property * _bfd_elf_get_property
  (bfd *, unsigned int, unsigned int);
extern bfd *_bfd_elf_link_setup_gnu_properties
  (struct bfd_link_info *);







struct elf_dyn_relocs
{
  struct elf_dyn_relocs *next;


  asection *sec;


  bfd_size_type count;


  bfd_size_type pc_count;
};

extern bfd_boolean _bfd_elf_create_ifunc_sections
  (bfd *, struct bfd_link_info *);
extern bfd_boolean _bfd_elf_allocate_ifunc_dyn_relocs
  (struct bfd_link_info *, struct elf_link_hash_entry *,
   struct elf_dyn_relocs **, bfd_boolean *, unsigned int,
   unsigned int, unsigned int, bfd_boolean);
extern long _bfd_elf_ifunc_get_synthetic_symtab
  (bfd *, long, asymbol **, long, asymbol **, asymbol **, asection *,
   bfd_vma *(*) (bfd *, asymbol **, asection *, asection *));

extern void elf_append_rela (bfd *, asection *, Elf_Internal_Rela *);
extern void elf_append_rel (bfd *, asection *, Elf_Internal_Rela *);

extern bfd_vma elf64_r_info (bfd_vma, bfd_vma);
extern bfd_vma elf64_r_sym (bfd_vma);
extern bfd_vma elf32_r_info (bfd_vma, bfd_vma);
extern bfd_vma elf32_r_sym (bfd_vma);


extern asection _bfd_elf_large_com_section;
# 43 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 2
# 1 "./../include/libiberty.h" 1
# 45 "./../include/libiberty.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 46 "./../include/libiberty.h" 2
# 55 "./../include/libiberty.h"
extern void unlock_stream (FILE *);





extern void unlock_std_streams (void);





extern FILE *fopen_unlocked (const char *, const char *);
extern FILE *fdopen_unlocked (int, const char *);
extern FILE *freopen_unlocked (const char *, const char *, FILE *);




extern char **buildargv (const char *) __attribute__ ((__malloc__));



extern void freeargv (char **);




extern char **dupargv (char * const *) __attribute__ ((__malloc__));



extern void expandargv (int *, char ***);



extern int writeargv (char * const *, FILE *);



extern int countargv (char * const *);
# 123 "./../include/libiberty.h"
extern const char *lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));




extern const char *dos_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));





extern const char *unix_lbasename (const char *) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1)));



extern char *lrealpath (const char *);





extern char *concat (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));
# 153 "./../include/libiberty.h"
extern char *reconcat (char *, const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));





extern unsigned long concat_length (const char *, ...) __attribute__ ((__sentinel__));






extern char *concat_copy (char *, const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__sentinel__));






extern char *concat_copy2 (const char *, ...) __attribute__ ((__returns_nonnull__)) __attribute__ ((__sentinel__));



extern char *libiberty_concat_ptr;
# 189 "./../include/libiberty.h"
extern int fdmatch (int fd1, int fd2);
# 201 "./../include/libiberty.h"
extern char * getpwd (void);
# 214 "./../include/libiberty.h"
extern long get_run_time (void);




extern char *make_relative_prefix (const char *, const char *,
                                   const char *) __attribute__ ((__malloc__));





extern char *make_relative_prefix_ignore_links (const char *, const char *,
      const char *) __attribute__ ((__malloc__));




extern const char *choose_tmpdir (void) __attribute__ ((__returns_nonnull__));



extern char *choose_temp_base (void) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *make_temp_file (const char *) __attribute__ ((__malloc__));



extern int unlink_if_ordinary (const char *);



extern const char *spaces (int count);




extern int errno_max (void);




extern const char *strerrno (int);



extern int strtoerrno (const char *);



extern char *xstrerror (int) __attribute__ ((__returns_nonnull__));




extern int signo_max (void);
# 283 "./../include/libiberty.h"
extern const char *strsigno (int);



extern int strtosigno (const char *);



extern int xatexit (void (*fn) (void));



extern void xexit (int status) __attribute__ ((__noreturn__));



extern void xmalloc_set_program_name (const char *);


extern void xmalloc_failed (size_t) __attribute__ ((__noreturn__));





extern void *xmalloc (size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));





extern void *xrealloc (void *, size_t) __attribute__ ((__returns_nonnull__));




extern void *xcalloc (size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *xstrdup (const char *) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern char *xstrndup (const char *, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));



extern void *xmemdup (const void *, size_t, size_t) __attribute__ ((__malloc__)) __attribute__ ((__returns_nonnull__));


extern double physmem_total (void);
extern double physmem_available (void);


extern unsigned int xcrc32 (const unsigned char *, int, unsigned int);
# 382 "./../include/libiberty.h"
extern const unsigned char _hex_value[256];
extern void hex_init (void);
# 419 "./../include/libiberty.h"
extern struct pex_obj *pex_init (int flags, const char *pname,
     const char *tempbase) __attribute__ ((__returns_nonnull__));
# 519 "./../include/libiberty.h"
extern const char *pex_run (struct pex_obj *obj, int flags,
       const char *executable, char * const *argv,
       const char *outname, const char *errname,
       int *err);
# 534 "./../include/libiberty.h"
extern const char *pex_run_in_environment (struct pex_obj *obj, int flags,
                      const char *executable,
                                           char * const *argv,
                                           char * const *env,
                              const char *outname,
        const char *errname, int *err);





extern FILE *pex_input_file (struct pex_obj *obj, int flags,
                             const char *in_name);






extern FILE *pex_input_pipe (struct pex_obj *obj, int binary);







extern FILE *pex_read_output (struct pex_obj *, int binary);







extern FILE *pex_read_err (struct pex_obj *, int binary);





extern int pex_get_status (struct pex_obj *, int count, int *vector);






struct pex_time
{
  unsigned long user_seconds;
  unsigned long user_microseconds;
  unsigned long system_seconds;
  unsigned long system_microseconds;
};

extern int pex_get_times (struct pex_obj *, int count,
     struct pex_time *vector);




extern void pex_free (struct pex_obj *);
# 609 "./../include/libiberty.h"
extern const char *pex_one (int flags, const char *executable,
       char * const *argv, const char *pname,
       const char *outname, const char *errname,
       int *status, int *err);
# 628 "./../include/libiberty.h"
extern int pexecute (const char *, char * const *, const char *,
                     const char *, char **, char **, int);



extern int pwait (int, int *, int);
# 645 "./../include/libiberty.h"
extern char *xasprintf (const char *, ...) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 2))) __attribute__ ((__nonnull__ (1)));
# 657 "./../include/libiberty.h"
extern char *xvasprintf (const char *, va_list) __attribute__ ((__malloc__)) __attribute__ ((__format__ (__printf__, 1, 0))) __attribute__ ((__nonnull__ (1)));
# 706 "./../include/libiberty.h"
extern void setproctitle (const char *name, ...);


extern void stack_limit_increase (unsigned long);
# 719 "./../include/libiberty.h"
extern void *C_alloca (size_t) __attribute__ ((__malloc__));
# 44 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 2
# 1 "./../include/safe-ctype.h" 1
# 57 "./../include/safe-ctype.h"
enum {

  _sch_isblank = 0x0001,
  _sch_iscntrl = 0x0002,
  _sch_isdigit = 0x0004,
  _sch_islower = 0x0008,
  _sch_isprint = 0x0010,
  _sch_ispunct = 0x0020,
  _sch_isspace = 0x0040,
  _sch_isupper = 0x0080,
  _sch_isxdigit = 0x0100,


  _sch_isidst = 0x0200,
  _sch_isvsp = 0x0400,
  _sch_isnvsp = 0x0800,


  _sch_isalpha = _sch_isupper|_sch_islower,
  _sch_isalnum = _sch_isalpha|_sch_isdigit,
  _sch_isidnum = _sch_isidst|_sch_isdigit,
  _sch_isgraph = _sch_isalnum|_sch_ispunct,
  _sch_iscppsp = _sch_isvsp|_sch_isnvsp,
  _sch_isbasic = _sch_isprint|_sch_iscppsp

};


extern const unsigned short _sch_istable[256];
# 110 "./../include/safe-ctype.h"
extern const unsigned char _sch_toupper[256];
extern const unsigned char _sch_tolower[256];
# 122 "./../include/safe-ctype.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 123 "./../include/safe-ctype.h" 2
# 45 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 2
# 1 "/doner/binutils/binutils-7a31b38/bfd/elf-linux-core.h" 1
# 35 "/doner/binutils/binutils-7a31b38/bfd/elf-linux-core.h"

# 35 "/doner/binutils/binutils-7a31b38/bfd/elf-linux-core.h"
struct elf_external_linux_prpsinfo32
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    char pr_flag[4];
    char pr_uid[2];
    char pr_gid[2];
    char pr_pid[4];
    char pr_ppid[4];
    char pr_pgrp[4];
    char pr_sid[4];
    char pr_fname[16];
    char pr_psargs[80];
  };




static inline void
swap_linux_prpsinfo32_out (bfd *obfd,
      const struct elf_internal_linux_prpsinfo *from,
      struct elf_external_linux_prpsinfo32 *to)
{
  ((void) (*((unsigned char *) (&to->pr_state)) = (from->pr_state) & 0xff));
  ((void) (*((unsigned char *) (&to->pr_sname)) = (from->pr_sname) & 0xff));
  ((void) (*((unsigned char *) (&to->pr_zomb)) = (from->pr_zomb) & 0xff));
  ((void) (*((unsigned char *) (&to->pr_nice)) = (from->pr_nice) & 0xff));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_flag),(to->pr_flag)));
  ((*((obfd)->xvec->bfd_putx16)) ((from->pr_uid),(to->pr_uid)));
  ((*((obfd)->xvec->bfd_putx16)) ((from->pr_gid),(to->pr_gid)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_pid),(to->pr_pid)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_ppid),(to->pr_ppid)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_pgrp),(to->pr_pgrp)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_sid),(to->pr_sid)));
  strncpy (to->pr_fname, from->pr_fname, sizeof (to->pr_fname));
  strncpy (to->pr_psargs, from->pr_psargs, sizeof (to->pr_psargs));
}
# 82 "/doner/binutils/binutils-7a31b38/bfd/elf-linux-core.h"
struct elf_external_linux_prpsinfo64
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    char pr_flag[8];
    char gap[4];
    char pr_uid[4];
    char pr_gid[4];
    char pr_pid[4];
    char pr_ppid[4];
    char pr_pgrp[4];
    char pr_sid[4];
    char pr_fname[16];
    char pr_psargs[80];
  };




static inline void
swap_linux_prpsinfo64_out (bfd *obfd,
      const struct elf_internal_linux_prpsinfo *from,
      struct elf_external_linux_prpsinfo64 *to)
{
  ((void) (*((unsigned char *) (&to->pr_state)) = (from->pr_state) & 0xff));
  ((void) (*((unsigned char *) (&to->pr_sname)) = (from->pr_sname) & 0xff));
  ((void) (*((unsigned char *) (&to->pr_zomb)) = (from->pr_zomb) & 0xff));
  ((void) (*((unsigned char *) (&to->pr_nice)) = (from->pr_nice) & 0xff));
  ((*((obfd)->xvec->bfd_putx64)) ((from->pr_flag), (to->pr_flag)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_uid),(to->pr_uid)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_gid),(to->pr_gid)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_pid),(to->pr_pid)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_ppid),(to->pr_ppid)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_pgrp),(to->pr_pgrp)));
  ((*((obfd)->xvec->bfd_putx32)) ((from->pr_sid),(to->pr_sid)));
  strncpy (to->pr_fname, from->pr_fname, sizeof (to->pr_fname));
  strncpy (to->pr_psargs, from->pr_psargs, sizeof (to->pr_psargs));
}
# 46 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 2


# 1 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h" 1
# 33 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/procfs.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/sys/procfs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/user.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/user.h" 3 4

# 27 "/usr/include/x86_64-linux-gnu/sys/user.h" 3 4
struct user_fpregs_struct
{
  unsigned short int cwd;
  unsigned short int swd;
  unsigned short int ftw;
  unsigned short int fop;
  __extension__ unsigned long long int rip;
  __extension__ unsigned long long int rdp;
  unsigned int mxcsr;
  unsigned int mxcr_mask;
  unsigned int st_space[32];
  unsigned int xmm_space[64];
  unsigned int padding[24];
};

struct user_regs_struct
{
  __extension__ unsigned long long int r15;
  __extension__ unsigned long long int r14;
  __extension__ unsigned long long int r13;
  __extension__ unsigned long long int r12;
  __extension__ unsigned long long int rbp;
  __extension__ unsigned long long int rbx;
  __extension__ unsigned long long int r11;
  __extension__ unsigned long long int r10;
  __extension__ unsigned long long int r9;
  __extension__ unsigned long long int r8;
  __extension__ unsigned long long int rax;
  __extension__ unsigned long long int rcx;
  __extension__ unsigned long long int rdx;
  __extension__ unsigned long long int rsi;
  __extension__ unsigned long long int rdi;
  __extension__ unsigned long long int orig_rax;
  __extension__ unsigned long long int rip;
  __extension__ unsigned long long int cs;
  __extension__ unsigned long long int eflags;
  __extension__ unsigned long long int rsp;
  __extension__ unsigned long long int ss;
  __extension__ unsigned long long int fs_base;
  __extension__ unsigned long long int gs_base;
  __extension__ unsigned long long int ds;
  __extension__ unsigned long long int es;
  __extension__ unsigned long long int fs;
  __extension__ unsigned long long int gs;
};

struct user
{
  struct user_regs_struct regs;
  int u_fpvalid;
  struct user_fpregs_struct i387;
  __extension__ unsigned long long int u_tsize;
  __extension__ unsigned long long int u_dsize;
  __extension__ unsigned long long int u_ssize;
  __extension__ unsigned long long int start_code;
  __extension__ unsigned long long int start_stack;
  __extension__ long long int signal;
  int reserved;
  __extension__ union
    {
      struct user_regs_struct* u_ar0;
      __extension__ unsigned long long int __u_ar0_word;
    };
  __extension__ union
    {
      struct user_fpregs_struct* u_fpstate;
      __extension__ unsigned long long int __u_fpstate_word;
    };
  __extension__ unsigned long long int magic;
  char u_comm [32];
  __extension__ unsigned long long int u_debugreg [8];
};
# 36 "/usr/include/x86_64-linux-gnu/sys/procfs.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/procfs.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/procfs.h" 3 4
__extension__ typedef unsigned long long elf_greg_t;
# 35 "/usr/include/x86_64-linux-gnu/bits/procfs.h" 3 4
typedef elf_greg_t elf_gregset_t[(sizeof (struct user_regs_struct) / sizeof (elf_greg_t))];
# 49 "/usr/include/x86_64-linux-gnu/bits/procfs.h" 3 4
typedef struct user_fpregs_struct elf_fpregset_t;
# 41 "/usr/include/x86_64-linux-gnu/sys/procfs.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/procfs-id.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/procfs-id.h" 3 4
typedef unsigned int __pr_uid_t;
typedef unsigned int __pr_gid_t;
# 45 "/usr/include/x86_64-linux-gnu/sys/procfs.h" 2 3 4




struct elf_siginfo
  {
    int si_signo;
    int si_code;
    int si_errno;
  };
# 63 "/usr/include/x86_64-linux-gnu/sys/procfs.h" 3 4
struct elf_prstatus
  {
    struct elf_siginfo pr_info;
    short int pr_cursig;
    unsigned long int pr_sigpend;
    unsigned long int pr_sighold;
    __pid_t pr_pid;
    __pid_t pr_ppid;
    __pid_t pr_pgrp;
    __pid_t pr_sid;
    struct timeval pr_utime;
    struct timeval pr_stime;
    struct timeval pr_cutime;
    struct timeval pr_cstime;
    elf_gregset_t pr_reg;
    int pr_fpvalid;
  };




struct elf_prpsinfo
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    unsigned long int pr_flag;
    __pr_uid_t pr_uid;
    __pr_gid_t pr_gid;
    int pr_pid, pr_ppid, pr_pgrp, pr_sid;

    char pr_fname[16];
    char pr_psargs[(80)];
  };






typedef void *psaddr_t;

# 1 "/usr/include/x86_64-linux-gnu/bits/procfs-prregset.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/procfs-prregset.h" 3 4
typedef elf_gregset_t __prgregset_t;
typedef elf_fpregset_t __prfpregset_t;
# 107 "/usr/include/x86_64-linux-gnu/sys/procfs.h" 2 3 4


typedef __prgregset_t prgregset_t;
typedef __prfpregset_t prfpregset_t;



typedef __pid_t lwpid_t;


typedef struct elf_prstatus prstatus_t;
typedef struct elf_prpsinfo prpsinfo_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/procfs-extra.h" 1 3 4
# 125 "/usr/include/x86_64-linux-gnu/sys/procfs.h" 2 3 4
# 34 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 2 3 4
# 37 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h" 2







# 43 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h"
typedef uint64_t __attribute__ ((__aligned__ (8))) a8_uint64_t;
# 55 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h"
struct user_regs32_struct
{
  int32_t ebx;
  int32_t ecx;
  int32_t edx;
  int32_t esi;
  int32_t edi;
  int32_t ebp;
  int32_t eax;
  int32_t xds;
  int32_t xes;
  int32_t xfs;
  int32_t xgs;
  int32_t orig_eax;
  int32_t eip;
  int32_t xcs;
  int32_t eflags;
  int32_t esp;
  int32_t xss;
};

struct user_regs64_struct
{
  a8_uint64_t r15;
  a8_uint64_t r14;
  a8_uint64_t r13;
  a8_uint64_t r12;
  a8_uint64_t rbp;
  a8_uint64_t rbx;
  a8_uint64_t r11;
  a8_uint64_t r10;
  a8_uint64_t r9;
  a8_uint64_t r8;
  a8_uint64_t rax;
  a8_uint64_t rcx;
  a8_uint64_t rdx;
  a8_uint64_t rsi;
  a8_uint64_t rdi;
  a8_uint64_t orig_rax;
  a8_uint64_t rip;
  a8_uint64_t cs;
  a8_uint64_t eflags;
  a8_uint64_t rsp;
  a8_uint64_t ss;
  a8_uint64_t fs_base;
  a8_uint64_t gs_base;
  a8_uint64_t ds;
  a8_uint64_t es;
  a8_uint64_t fs;
  a8_uint64_t gs;
};


typedef uint32_t elf_greg32_t;
typedef a8_uint64_t elf_greg64_t;






typedef elf_greg32_t elf_gregset32_t[(sizeof (struct user_regs32_struct) / sizeof(elf_greg32_t))];

typedef elf_greg64_t elf_gregset64_t[(sizeof (struct user_regs64_struct) / sizeof(elf_greg64_t))];
# 127 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h"
struct prstatus32_timeval
  {
    int tv_sec;
    int tv_usec;
  };

struct prstatus64_timeval
  {
    a8_uint64_t tv_sec;
    a8_uint64_t tv_usec;
  };

struct elf_prstatus32
  {
    struct elf_siginfo pr_info;
    short int pr_cursig;
    unsigned int pr_sigpend;
    unsigned int pr_sighold;
    pid_t pr_pid;
    pid_t pr_ppid;
    pid_t pr_pgrp;
    pid_t pr_sid;
    struct prstatus32_timeval pr_utime;
    struct prstatus32_timeval pr_stime;
    struct prstatus32_timeval pr_cutime;
    struct prstatus32_timeval pr_cstime;
    elf_gregset32_t pr_reg;
    int pr_fpvalid;
  };

struct elf_prstatusx32
  {
    struct elf_siginfo pr_info;
    short int pr_cursig;
    unsigned int pr_sigpend;
    unsigned int pr_sighold;
    pid_t pr_pid;
    pid_t pr_ppid;
    pid_t pr_pgrp;
    pid_t pr_sid;
    struct prstatus32_timeval pr_utime;
    struct prstatus32_timeval pr_stime;
    struct prstatus32_timeval pr_cutime;
    struct prstatus32_timeval pr_cstime;
    elf_gregset64_t pr_reg;
    int pr_fpvalid;
  };

struct elf_prstatus64
  {
    struct elf_siginfo pr_info;
    short int pr_cursig;
    a8_uint64_t pr_sigpend;
    a8_uint64_t pr_sighold;
    pid_t pr_pid;
    pid_t pr_ppid;
    pid_t pr_pgrp;
    pid_t pr_sid;
    struct prstatus64_timeval pr_utime;
    struct prstatus64_timeval pr_stime;
    struct prstatus64_timeval pr_cutime;
    struct prstatus64_timeval pr_cstime;
    elf_gregset64_t pr_reg;
    int pr_fpvalid;
  };

struct elf_prpsinfo32
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    unsigned int pr_flag;
    unsigned short int pr_uid;
    unsigned short int pr_gid;
    int pr_pid, pr_ppid, pr_pgrp, pr_sid;

    char pr_fname[16];
    char pr_psargs[
# 205 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h" 3 4
                  (80)
# 205 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h"
                             ];
  };

struct elf_prpsinfo64
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    a8_uint64_t pr_flag;
    unsigned int pr_uid;
    unsigned int pr_gid;
    int pr_pid, pr_ppid, pr_pgrp, pr_sid;

    char pr_fname[16];
    char pr_psargs[
# 220 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h" 3 4
                  (80)
# 220 "/doner/binutils/binutils-7a31b38/bfd/hosts/x86-64linux.h"
                             ];
  };






typedef struct elf_prstatus32 prstatus32_t;
typedef struct elf_prstatusx32 prstatusx32_t;
typedef struct elf_prstatus64 prstatus64_t;
typedef struct elf_prpsinfo32 prpsinfo32_t;
typedef struct elf_prpsinfo64 prpsinfo64_t;
# 49 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 2


static int elf_sort_sections (const void *, const void *);
static bfd_boolean assign_file_positions_except_relocs (bfd *, struct bfd_link_info *);
static bfd_boolean prep_headers (bfd *);
static bfd_boolean swap_out_syms (bfd *, struct elf_strtab_hash **, int) ;
static bfd_boolean elf_read_notes (bfd *, file_ptr, bfd_size_type) ;
static bfd_boolean elf_parse_notes (bfd *abfd, char *buf, size_t size,
        file_ptr offset);







void
_bfd_elf_swap_verdef_in (bfd *abfd,
    const Elf_External_Verdef *src,
    Elf_Internal_Verdef *dst)
{
  dst->vd_version = ((*((abfd)->xvec->bfd_h_getx16)) (src->vd_version));
  dst->vd_flags = ((*((abfd)->xvec->bfd_h_getx16)) (src->vd_flags));
  dst->vd_ndx = ((*((abfd)->xvec->bfd_h_getx16)) (src->vd_ndx));
  dst->vd_cnt = ((*((abfd)->xvec->bfd_h_getx16)) (src->vd_cnt));
  dst->vd_hash = ((*((abfd)->xvec->bfd_h_getx32)) (src->vd_hash));
  dst->vd_aux = ((*((abfd)->xvec->bfd_h_getx32)) (src->vd_aux));
  dst->vd_next = ((*((abfd)->xvec->bfd_h_getx32)) (src->vd_next));
}



void
_bfd_elf_swap_verdef_out (bfd *abfd,
     const Elf_Internal_Verdef *src,
     Elf_External_Verdef *dst)
{
  ((*((abfd)->xvec->bfd_h_putx16)) (src->vd_version, dst->vd_version));
  ((*((abfd)->xvec->bfd_h_putx16)) (src->vd_flags, dst->vd_flags));
  ((*((abfd)->xvec->bfd_h_putx16)) (src->vd_ndx, dst->vd_ndx));
  ((*((abfd)->xvec->bfd_h_putx16)) (src->vd_cnt, dst->vd_cnt));
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vd_hash, dst->vd_hash));
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vd_aux, dst->vd_aux));
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vd_next, dst->vd_next));
}



void
_bfd_elf_swap_verdaux_in (bfd *abfd,
     const Elf_External_Verdaux *src,
     Elf_Internal_Verdaux *dst)
{
  dst->vda_name = ((*((abfd)->xvec->bfd_h_getx32)) (src->vda_name));
  dst->vda_next = ((*((abfd)->xvec->bfd_h_getx32)) (src->vda_next));
}



void
_bfd_elf_swap_verdaux_out (bfd *abfd,
      const Elf_Internal_Verdaux *src,
      Elf_External_Verdaux *dst)
{
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vda_name, dst->vda_name));
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vda_next, dst->vda_next));
}



void
_bfd_elf_swap_verneed_in (bfd *abfd,
     const Elf_External_Verneed *src,
     Elf_Internal_Verneed *dst)
{
  dst->vn_version = ((*((abfd)->xvec->bfd_h_getx16)) (src->vn_version));
  dst->vn_cnt = ((*((abfd)->xvec->bfd_h_getx16)) (src->vn_cnt));
  dst->vn_file = ((*((abfd)->xvec->bfd_h_getx32)) (src->vn_file));
  dst->vn_aux = ((*((abfd)->xvec->bfd_h_getx32)) (src->vn_aux));
  dst->vn_next = ((*((abfd)->xvec->bfd_h_getx32)) (src->vn_next));
}



void
_bfd_elf_swap_verneed_out (bfd *abfd,
      const Elf_Internal_Verneed *src,
      Elf_External_Verneed *dst)
{
  ((*((abfd)->xvec->bfd_h_putx16)) (src->vn_version, dst->vn_version));
  ((*((abfd)->xvec->bfd_h_putx16)) (src->vn_cnt, dst->vn_cnt));
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vn_file, dst->vn_file));
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vn_aux, dst->vn_aux));
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vn_next, dst->vn_next));
}



void
_bfd_elf_swap_vernaux_in (bfd *abfd,
     const Elf_External_Vernaux *src,
     Elf_Internal_Vernaux *dst)
{
  dst->vna_hash = ((*((abfd)->xvec->bfd_h_getx32)) (src->vna_hash));
  dst->vna_flags = ((*((abfd)->xvec->bfd_h_getx16)) (src->vna_flags));
  dst->vna_other = ((*((abfd)->xvec->bfd_h_getx16)) (src->vna_other));
  dst->vna_name = ((*((abfd)->xvec->bfd_h_getx32)) (src->vna_name));
  dst->vna_next = ((*((abfd)->xvec->bfd_h_getx32)) (src->vna_next));
}



void
_bfd_elf_swap_vernaux_out (bfd *abfd,
      const Elf_Internal_Vernaux *src,
      Elf_External_Vernaux *dst)
{
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vna_hash, dst->vna_hash));
  ((*((abfd)->xvec->bfd_h_putx16)) (src->vna_flags, dst->vna_flags));
  ((*((abfd)->xvec->bfd_h_putx16)) (src->vna_other, dst->vna_other));
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vna_name, dst->vna_name));
  ((*((abfd)->xvec->bfd_h_putx32)) (src->vna_next, dst->vna_next));
}



void
_bfd_elf_swap_versym_in (bfd *abfd,
    const Elf_External_Versym *src,
    Elf_Internal_Versym *dst)
{
  dst->vs_vers = ((*((abfd)->xvec->bfd_h_getx16)) (src->vs_vers));
}



void
_bfd_elf_swap_versym_out (bfd *abfd,
     const Elf_Internal_Versym *src,
     Elf_External_Versym *dst)
{
  ((*((abfd)->xvec->bfd_h_putx16)) (src->vs_vers, dst->vs_vers));
}




unsigned long
bfd_elf_hash (const char *namearg)
{
  const unsigned char *name = (const unsigned char *) namearg;
  unsigned long h = 0;
  unsigned long g;
  int ch;

  while ((ch = *name++) != '\0')
    {
      h = (h << 4) + ch;
      if ((g = (h & 0xf0000000)) != 0)
 {
   h ^= g >> 24;


   h ^= g;
 }
    }
  return h & 0xffffffff;
}




unsigned long
bfd_elf_gnu_hash (const char *namearg)
{
  const unsigned char *name = (const unsigned char *) namearg;
  unsigned long h = 5381;
  unsigned char ch;

  while ((ch = *name++) != '\0')
    h = (h << 5) + h + ch;
  return h & 0xffffffff;
}



bfd_boolean
bfd_elf_allocate_object (bfd *abfd,
    size_t object_size,
    enum elf_target_id object_id)
{
  do { if (!(object_size >= sizeof (struct elf_obj_tdata))) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",240); } while (0);
  abfd->tdata.any = bfd_zalloc (abfd, object_size);
  if (abfd->tdata.any == 
# 242 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                        ((void *)0)
# 242 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                            )
    return 0;

  (((abfd) -> tdata.elf_obj_data) -> object_id) = object_id;
  if (abfd->direction != read_direction)
    {
      struct output_elf_obj_tdata *o = bfd_zalloc (abfd, sizeof *o);
      if (o == 
# 249 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 249 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  )
 return 0;
      ((abfd) -> tdata.elf_obj_data)->o = o;
      (((abfd) -> tdata.elf_obj_data) -> o->program_header_size) = (bfd_size_type) -1;
    }
  return 1;
}


bfd_boolean
bfd_elf_make_object (bfd *abfd)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  return bfd_elf_allocate_object (abfd, sizeof (struct elf_obj_tdata),
      bed->target_id);
}

bfd_boolean
bfd_elf_mkcorefile (bfd *abfd)
{

  if (!abfd->xvec->_bfd_set_format[(int) bfd_object] (abfd))
    return 0;
  ((abfd) -> tdata.elf_obj_data)->core = bfd_zalloc (abfd, sizeof (*((abfd) -> tdata.elf_obj_data)->core));
  return ((abfd) -> tdata.elf_obj_data)->core != 
# 273 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                  ((void *)0)
# 273 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                      ;
}

static char *
bfd_elf_get_str_section (bfd *abfd, unsigned int shindex)
{
  Elf_Internal_Shdr **i_shdrp;
  bfd_byte *shstrtab = 
# 280 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 280 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          ;
  file_ptr offset;
  bfd_size_type shstrtabsize;

  i_shdrp = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr);
  if (i_shdrp == 0
      || shindex >= (((abfd) -> tdata.elf_obj_data) -> num_elf_sections)
      || i_shdrp[shindex] == 0)
    return 
# 288 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 288 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;

  shstrtab = i_shdrp[shindex]->contents;
  if (shstrtab == 
# 291 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 291 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
    {

      offset = i_shdrp[shindex]->sh_offset;
      shstrtabsize = i_shdrp[shindex]->sh_size;



      if (shstrtabsize + 1 <= 1
   || bfd_seek (abfd, offset, 
# 300 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             0
# 300 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                     ) != 0
   || (shstrtab = (bfd_byte *) bfd_alloc (abfd, shstrtabsize + 1)) == 
# 301 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                                     ((void *)0)
# 301 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                         )
 shstrtab = 
# 302 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 302 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               ;
      else if (bfd_bread (shstrtab, shstrtabsize, abfd) != shstrtabsize)
 {
   if (bfd_get_error () != bfd_error_system_call)
     bfd_set_error (bfd_error_file_truncated);
   bfd_release (abfd, shstrtab);
   shstrtab = 
# 308 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 308 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 ;



   i_shdrp[shindex]->sh_size = 0;
 }
      else
 shstrtab[shstrtabsize] = '\0';
      i_shdrp[shindex]->contents = shstrtab;
    }
  return (char *) shstrtab;
}

char *
bfd_elf_string_from_elf_section (bfd *abfd,
     unsigned int shindex,
     unsigned int strindex)
{
  Elf_Internal_Shdr *hdr;

  if (strindex == 0)
    return "";

  if ((((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr) == 
# 331 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0) 
# 331 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                    || shindex >= (((abfd) -> tdata.elf_obj_data) -> num_elf_sections))
    return 
# 332 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 332 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;

  hdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[shindex];

  if (hdr->contents == 
# 336 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 336 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          )
    {
      if (hdr->sh_type != 3 && hdr->sh_type < 0x60000000)
 {


   _bfd_error_handler (dgettext ("bfd", "%B: attempt to load strings from" " a non-string section (number %d)")
                                        ,
         abfd, shindex);
   return 
# 345 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
         ((void *)0)
# 345 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
             ;
 }

      if (bfd_elf_get_str_section (abfd, shindex) == 
# 348 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                    ((void *)0)
# 348 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                        )
 return 
# 349 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
       ((void *)0)
# 349 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
           ;
    }

  if (strindex >= hdr->sh_size)
    {
      unsigned int shstrndx = (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_shstrndx;
      _bfd_error_handler

 (dgettext ("bfd", "%B: invalid string offset %u >= %lu for section `%s'"),
  abfd, strindex, (unsigned long) hdr->sh_size,
  (shindex == shstrndx && strindex == hdr->sh_name
   ? ".shstrtab"
   : bfd_elf_string_from_elf_section (abfd, shstrndx, hdr->sh_name)));
      return 
# 362 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 362 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                ;
    }

  return ((char *) hdr->contents) + strindex;
}
# 376 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
Elf_Internal_Sym *
bfd_elf_get_elf_syms (bfd *ibfd,
        Elf_Internal_Shdr *symtab_hdr,
        size_t symcount,
        size_t symoffset,
        Elf_Internal_Sym *intsym_buf,
        void *extsym_buf,
        Elf_External_Sym_Shndx *extshndx_buf)
{
  Elf_Internal_Shdr *shndx_hdr;
  void *alloc_ext;
  const bfd_byte *esym;
  Elf_External_Sym_Shndx *alloc_extshndx;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *alloc_intsym;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  const struct elf_backend_data *bed;
  size_t extsym_size;
  bfd_size_type amt;
  file_ptr pos;

  if (((ibfd)->xvec->flavour) != bfd_target_elf_flavour)
    _bfd_abort ("/doner/binutils/binutils-7a31b38/bfd/elf.c", 399, __PRETTY_FUNCTION__);

  if (symcount == 0)
    return intsym_buf;


  shndx_hdr = 
# 405 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 405 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 ;
  if ((((ibfd) -> tdata.elf_obj_data) -> symtab_shndx_list) != 
# 406 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                     ((void *)0)
# 406 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                         )
    {
      elf_section_list * entry;
      Elf_Internal_Shdr **sections = (((ibfd) -> tdata.elf_obj_data) -> elf_sect_ptr);


      for (entry = (((ibfd) -> tdata.elf_obj_data) -> symtab_shndx_list); entry != 
# 412 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                         ((void *)0)
# 412 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                             ; entry = entry->next)
 {

   if (entry->hdr.sh_link >= (((ibfd) -> tdata.elf_obj_data) -> num_elf_sections))
     continue;

   if (sections[entry->hdr.sh_link] == symtab_hdr)
     {
       shndx_hdr = & entry->hdr;
       break;
     };
 }

      if (shndx_hdr == 
# 425 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 425 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          )
 {
   if (symtab_hdr == & (((ibfd) -> tdata.elf_obj_data) -> symtab_hdr))

     shndx_hdr = & (((ibfd) -> tdata.elf_obj_data) -> symtab_shndx_list)->hdr;


 }
    }


  alloc_ext = 
# 436 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 436 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 ;
  alloc_extshndx = 
# 437 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 437 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      ;
  alloc_intsym = 
# 438 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 438 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    ;
  bed = ((const struct elf_backend_data *) ((ibfd)->xvec)->backend_data);
  extsym_size = bed->s->sizeof_sym;
  amt = (bfd_size_type) symcount * extsym_size;
  pos = symtab_hdr->sh_offset + symoffset * extsym_size;
  if (extsym_buf == 
# 443 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 443 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       )
    {
      alloc_ext = bfd_malloc2 (symcount, extsym_size);
      extsym_buf = alloc_ext;
    }
  if (extsym_buf == 
# 448 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
      
# 449 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     || bfd_seek (ibfd, pos, 
# 449 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             0
# 449 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                     ) != 0
      || bfd_bread (extsym_buf, amt, ibfd) != amt)
    {
      intsym_buf = 
# 452 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 452 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      ;
      goto out;
    }

  if (shndx_hdr == 
# 456 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0) 
# 456 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       || shndx_hdr->sh_size == 0)
    extshndx_buf = 
# 457 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 457 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      ;
  else
    {
      amt = (bfd_size_type) symcount * sizeof (Elf_External_Sym_Shndx);
      pos = shndx_hdr->sh_offset + symoffset * sizeof (Elf_External_Sym_Shndx);
      if (extshndx_buf == 
# 462 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
# 462 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                             )
 {
   alloc_extshndx = (Elf_External_Sym_Shndx *)
              bfd_malloc2 (symcount, sizeof (Elf_External_Sym_Shndx));
   extshndx_buf = alloc_extshndx;
 }
      if (extshndx_buf == 
# 468 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
   
# 469 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  || bfd_seek (ibfd, pos, 
# 469 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          0
# 469 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  ) != 0
   || bfd_bread (extshndx_buf, amt, ibfd) != amt)
 {
   intsym_buf = 
# 472 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 472 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   ;
   goto out;
 }
    }

  if (intsym_buf == 
# 477 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 477 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       )
    {
      alloc_intsym = (Elf_Internal_Sym *)
          bfd_malloc2 (symcount, sizeof (Elf_Internal_Sym));
      intsym_buf = alloc_intsym;
      if (intsym_buf == 
# 482 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                       ((void *)0)
# 482 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                           )
 goto out;
    }


  isymend = intsym_buf + symcount;
  for (esym = (const bfd_byte *) extsym_buf, isym = intsym_buf,
           shndx = extshndx_buf;
       isym < isymend;
       esym += extsym_size, isym++, shndx = shndx != 
# 491 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                    ((void *)0) 
# 491 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                         ? shndx + 1 : 
# 491 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                                       ((void *)0)
# 491 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                           )
    if (!(*bed->s->swap_symbol_in) (ibfd, esym, shndx, isym))
      {
 symoffset += (esym - (bfd_byte *) extsym_buf) / extsym_size;

 _bfd_error_handler (dgettext ("bfd", "%B symbol number %lu references" " nonexistent SHT_SYMTAB_SHNDX section")
                                                 ,
       ibfd, (unsigned long) symoffset);
 if (alloc_intsym != 
# 499 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                    ((void *)0)
# 499 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                        )
   free (alloc_intsym);
 intsym_buf = 
# 501 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 501 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 ;
 goto out;
      }

 out:
  if (alloc_ext != 
# 506 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 506 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      )
    free (alloc_ext);
  if (alloc_extshndx != 
# 508 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                       ((void *)0)
# 508 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                           )
    free (alloc_extshndx);

  return intsym_buf;
}


const char *
bfd_elf_sym_name (bfd *abfd,
    Elf_Internal_Shdr *symtab_hdr,
    Elf_Internal_Sym *isym,
    asection *sym_sec)
{
  const char *name;
  unsigned int iname = isym->st_name;
  unsigned int shindex = symtab_hdr->sh_link;

  if (iname == 0 && ((isym->st_info) & 0xF) == 3

      && isym->st_shndx < (((abfd) -> tdata.elf_obj_data) -> num_elf_sections))
    {
      iname = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[isym->st_shndx]->sh_name;
      shindex = (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_shstrndx;
    }

  name = bfd_elf_string_from_elf_section (abfd, shindex, iname);
  if (name == 
# 534 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 534 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    name = "(null)";
  else if (sym_sec && *name == '\0')
    name = ((sym_sec)->name);

  return name;
}





typedef union elf_internal_group {
  Elf_Internal_Shdr *shdr;
  unsigned int flags;
} Elf_Internal_Group;




static const char *
group_signature (bfd *abfd, Elf_Internal_Shdr *ghdr)
{
  Elf_Internal_Shdr *hdr;
  unsigned char esym[sizeof (Elf64_External_Sym)];
  Elf_External_Sym_Shndx eshndx;
  Elf_Internal_Sym isym;



  if (ghdr->sh_link >= (((abfd) -> tdata.elf_obj_data) -> num_elf_sections))
    return 
# 565 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 565 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;
  hdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr) [ghdr->sh_link];
  if (hdr->sh_type != 2
      || ! bfd_section_from_shdr (abfd, ghdr->sh_link))
    return 
# 569 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 569 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;


  hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;
  if (bfd_elf_get_elf_syms (abfd, hdr, 1, ghdr->sh_info,
       &isym, esym, &eshndx) == 
# 574 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 574 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   )
    return 
# 575 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 575 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;

  return bfd_elf_sym_name (abfd, hdr, &isym, 
# 577 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                            ((void *)0)
# 577 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                );
}



static bfd_boolean
setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)
{
  unsigned int num_group = ((abfd) -> tdata.elf_obj_data)->num_group;



  if (num_group == 0)
    {
      unsigned int i, shnum;



      shnum = (((abfd) -> tdata.elf_obj_data) -> num_elf_sections);
      num_group = 0;







      for (i = 0; i < shnum; i++)
 {
   Elf_Internal_Shdr *shdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[i];

   if (( (shdr)->sh_type == 17 && (shdr)->sh_size >= 2 * 4 && (shdr)->sh_entsize == 4 && ((shdr)->sh_size % 4) == 0))
     num_group += 1;
 }

      if (num_group == 0)
 {
   num_group = (unsigned) -1;
   ((abfd) -> tdata.elf_obj_data)->num_group = num_group;
   ((abfd) -> tdata.elf_obj_data)->group_sect_ptr = 
# 616 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                     ((void *)0)
# 616 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                         ;
 }
      else
 {


   bfd_size_type amt;

   ((abfd) -> tdata.elf_obj_data)->num_group = num_group;
   ((abfd) -> tdata.elf_obj_data)->group_sect_ptr = (Elf_Internal_Shdr **)
              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));
   if (((abfd) -> tdata.elf_obj_data)->group_sect_ptr == 
# 627 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                          ((void *)0)
# 627 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                              )
     return 0;
   memset (((abfd) -> tdata.elf_obj_data)->group_sect_ptr, 0, num_group * sizeof (Elf_Internal_Shdr *));
   num_group = 0;

   for (i = 0; i < shnum; i++)
     {
       Elf_Internal_Shdr *shdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[i];

       if (( (shdr)->sh_type == 17 && (shdr)->sh_size >= 2 * 4 && (shdr)->sh_entsize == 4 && ((shdr)->sh_size % 4) == 0))
  {
    unsigned char *src;
    Elf_Internal_Group *dest;



                  if (!bfd_section_from_shdr (abfd, i))
                    return 0;


    ((abfd) -> tdata.elf_obj_data)->group_sect_ptr[num_group] = shdr;
    num_group += 1;


    do { if (!(sizeof (*dest) >= 4)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",651); } while (0);
    amt = shdr->sh_size * sizeof (*dest) / 4;
    shdr->contents = (unsigned char *)
                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);

    if (shdr->contents == 
# 656 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
# 656 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                             )
      {
        _bfd_error_handler

   (dgettext ("bfd", "%B: corrupt size field in group section" " header: %#Lx")
                      , abfd, shdr->sh_size);
        bfd_set_error (bfd_error_bad_value);
        -- num_group;
        continue;
      }

    memset (shdr->contents, 0, amt);

    if (bfd_seek (abfd, shdr->sh_offset, 
# 669 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                        0
# 669 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                ) != 0
        || (bfd_bread (shdr->contents, shdr->sh_size, abfd)
     != shdr->sh_size))
      {
        _bfd_error_handler

   (dgettext ("bfd", "%B: invalid size field in group section" " header: %#Lx")
                      , abfd, shdr->sh_size);
        bfd_set_error (bfd_error_bad_value);
        -- num_group;



        memset (shdr->contents, 0, amt);
        continue;
      }





    src = shdr->contents + shdr->sh_size;
    dest = (Elf_Internal_Group *) (shdr->contents + amt);

    while (1)
      {
        unsigned int idx;

        src -= 4;
        --dest;
        idx = ((*((abfd)->xvec->bfd_h_getx32)) (src));
        if (src == shdr->contents)
   {
     dest->flags = idx;
     if (shdr->bfd_section != 
# 703 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             ((void *)0) 
# 703 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  && (idx & 0x1))
       shdr->bfd_section->flags
         |= 0x20000 | 0x0;
     break;
   }
        if (idx >= shnum)
   {
     _bfd_error_handler
       (dgettext ("bfd", "%B: invalid SHT_GROUP entry"), abfd);
     idx = 0;
   }
        dest->shdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[idx];
      }
  }
     }


   if (num_group != (unsigned) ((abfd) -> tdata.elf_obj_data)->num_group)
     {
       ((abfd) -> tdata.elf_obj_data)->num_group = num_group;


       if (num_group == 0)
  {
    ((abfd) -> tdata.elf_obj_data)->group_sect_ptr = 
# 727 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                      ((void *)0)
# 727 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                          ;
    ((abfd) -> tdata.elf_obj_data)->num_group = num_group = -1;
    _bfd_error_handler
      (dgettext ("bfd", "%B: no valid group sections found"), abfd);
    bfd_set_error (bfd_error_bad_value);
  }
     }
 }
    }

  if (num_group != (unsigned) -1)
    {
      unsigned int i;

      for (i = 0; i < num_group; i++)
 {
   Elf_Internal_Shdr *shdr = ((abfd) -> tdata.elf_obj_data)->group_sect_ptr[i];
   Elf_Internal_Group *idx;
   bfd_size_type n_elt;

   if (shdr == 
# 747 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 747 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  )
     continue;

   idx = (Elf_Internal_Group *) shdr->contents;
   if (idx == 
# 751 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0) 
# 751 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  || shdr->sh_size < 4)
     {


       _bfd_error_handler (dgettext ("bfd", "%B: group section '%A' has no contents"),
      abfd, shdr->bfd_section);
       ((abfd) -> tdata.elf_obj_data)->group_sect_ptr[i] = 
# 757 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                            ((void *)0)
# 757 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                ;
       bfd_set_error (bfd_error_bad_value);
       return 0;
     }
   n_elt = shdr->sh_size / 4;



   while (--n_elt != 0)
     if ((++idx)->shdr == hdr)
       {
  asection *s = 
# 768 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 768 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   ;




  idx = (Elf_Internal_Group *) shdr->contents;
  n_elt = shdr->sh_size / 4;
  while (--n_elt != 0)
    if ((s = (++idx)->shdr->bfd_section) != 
# 776 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                           ((void *)0)
        
# 777 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       && (((struct bfd_elf_section_data*)(s)->used_by_bfd)->next_in_group) != 
# 777 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                   ((void *)0)
# 777 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                       )
      break;
  if (n_elt != 0)
    {


      (((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->group.name) = (((struct bfd_elf_section_data*)(s)->used_by_bfd)->group.name);
      (((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->next_in_group) = (((struct bfd_elf_section_data*)(s)->used_by_bfd)->next_in_group);
      (((struct bfd_elf_section_data*)(s)->used_by_bfd)->next_in_group) = newsect;
    }
  else
    {
      const char *gname;

      gname = group_signature (abfd, shdr);
      if (gname == 
# 792 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 792 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      )
        return 0;
      (((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->group.name) = gname;


      (((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->next_in_group) = newsect;
    }



  if (shdr->bfd_section != 
# 802 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          ((void *)0)
# 802 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                              )
    (((struct bfd_elf_section_data*)(shdr->bfd_section)->used_by_bfd)->next_in_group) = newsect;

  i = num_group - 1;
  break;
       }
 }
    }

  if ((((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->group.name) == 
# 811 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                 ((void *)0)
# 811 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                     )
    {

      _bfd_error_handler (dgettext ("bfd", "%B: no group info for section %A"),
     abfd, newsect);
      return 0;
    }
  return 1;
}

bfd_boolean
_bfd_elf_setup_sections (bfd *abfd)
{
  unsigned int i;
  unsigned int num_group = ((abfd) -> tdata.elf_obj_data)->num_group;
  bfd_boolean result = 1;
  asection *s;


  for (s = abfd->sections; s != 
# 830 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 830 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   ; s = s->next)
    {
      Elf_Internal_Shdr *this_hdr = &((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr;
      if ((this_hdr->sh_flags & (1 << 7)) != 0)
 {
   unsigned int elfsec = this_hdr->sh_link;



   if (elfsec == 0)
     {
       const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
       if (bed->link_order_error_handler)
  bed->link_order_error_handler

    (dgettext ("bfd", "%B: warning: sh_link not set for section `%A'"),
     abfd, s);
     }
   else
     {
       asection *linksec = 
# 850 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          ((void *)0)
# 850 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                              ;

       if (elfsec < (((abfd) -> tdata.elf_obj_data) -> num_elf_sections))
  {
    this_hdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[elfsec];
    linksec = this_hdr->bfd_section;
  }




       if (linksec == 
# 861 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
# 861 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                         )
  {
    _bfd_error_handler

      (dgettext ("bfd", "%B: sh_link [%d] in section `%A' is incorrect"),
       s->owner, elfsec, s);
    result = 0;
  }

       (((struct bfd_elf_section_data*)(s)->used_by_bfd)->linked_to) = linksec;
     }
 }
      else if (this_hdr->sh_type == 17
        && (((struct bfd_elf_section_data*)(s)->used_by_bfd)->next_in_group) == 
# 874 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                   ((void *)0)
# 874 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                       )
 {
   _bfd_error_handler

     (dgettext ("bfd", "%B: SHT_GROUP section [index %d] has no SHF_GROUP sections"),
      abfd, ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_idx);
   result = 0;
 }
    }


  if (num_group == (unsigned) -1)
    return result;

  for (i = 0; i < num_group; i++)
    {
      Elf_Internal_Shdr *shdr = ((abfd) -> tdata.elf_obj_data)->group_sect_ptr[i];
      Elf_Internal_Group *idx;
      unsigned int n_elt;


      if (shdr == 
# 895 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0) 
# 895 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      || shdr->bfd_section == 
# 895 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                              ((void *)0) 
# 895 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                   || shdr->contents == 
# 895 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                                        ((void *)0)
# 895 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                            )
 {
   _bfd_error_handler

     (dgettext ("bfd", "%B: section group entry number %u is corrupt"),
      abfd, i);
   result = 0;
   continue;
 }

      idx = (Elf_Internal_Group *) shdr->contents;
      n_elt = shdr->sh_size / 4;

      while (--n_elt != 0)
 {
   ++ idx;

   if (idx->shdr == 
# 912 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 912 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       )
     continue;
   else if (idx->shdr->bfd_section)
     (((struct bfd_elf_section_data*)(idx->shdr->bfd_section)->used_by_bfd)->sec_group) = shdr->bfd_section;
   else if (idx->shdr->sh_type == 4
     || idx->shdr->sh_type == 9)





     shdr->bfd_section->size -= 4;
   else
     {

       _bfd_error_handler

  (dgettext ("bfd", "%B: unknown type [%#x] section `%s' in group [%A]"),
   abfd,
   idx->shdr->sh_type,
   bfd_elf_string_from_elf_section (abfd,
        ((((abfd) -> tdata.elf_obj_data) -> elf_header)
         ->e_shstrndx),
        idx->shdr->sh_name),
   shdr->bfd_section);
       result = 0;
     }
 }
    }

  return result;
}

bfd_boolean
bfd_elf_is_group_section (bfd *abfd __attribute__ ((__unused__)), const asection *sec)
{
  return (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->next_in_group) != 
# 948 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                   ((void *)0)
# 948 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                       ;
}

static char *
convert_debug_to_zdebug (bfd *abfd, const char *name)
{
  unsigned int len = strlen (name);
  char *new_name = bfd_alloc (abfd, len + 2);
  if (new_name == 
# 956 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 956 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
    return 
# 957 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 957 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;
  new_name[0] = '.';
  new_name[1] = 'z';
  memcpy (new_name + 2, name + 1, len);
  return new_name;
}

static char *
convert_zdebug_to_debug (bfd *abfd, const char *name)
{
  unsigned int len = strlen (name);
  char *new_name = bfd_alloc (abfd, len);
  if (new_name == 
# 969 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 969 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
    return 
# 970 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 970 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;
  new_name[0] = '.';
  memcpy (new_name + 1, name + 2, len - 1);
  return new_name;
}




bfd_boolean
_bfd_elf_make_section_from_shdr (bfd *abfd,
     Elf_Internal_Shdr *hdr,
     const char *name,
     int shindex)
{
  asection *newsect;
  flagword flags;
  const struct elf_backend_data *bed;

  if (hdr->bfd_section != 
# 989 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
# 989 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                             )
    return 1;

  newsect = bfd_make_section_anyway (abfd, name);
  if (newsect == 
# 993 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 993 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    )
    return 0;

  hdr->bfd_section = newsect;
  ((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->this_hdr = *hdr;
  ((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->this_idx = shindex;


  (((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->this_hdr.sh_type) = hdr->sh_type;
  (((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->this_hdr.sh_flags) = hdr->sh_flags;

  newsect->filepos = hdr->sh_offset;

  if (! bfd_set_section_vma (abfd, newsect, hdr->sh_addr)
      || ! bfd_set_section_size (abfd, newsect, hdr->sh_size)
      || ! bfd_set_section_alignment (abfd, newsect,
          bfd_log2 (hdr->sh_addralign)))
    return 0;

  flags = 0x000;
  if (hdr->sh_type != 8)
    flags |= 0x100;
  if (hdr->sh_type == 17)
    flags |= 0x2000000;
  if ((hdr->sh_flags & (1 << 1)) != 0)
    {
      flags |= 0x001;
      if (hdr->sh_type != 8)
 flags |= 0x002;
    }
  if ((hdr->sh_flags & (1 << 0)) == 0)
    flags |= 0x008;
  if ((hdr->sh_flags & (1 << 2)) != 0)
    flags |= 0x010;
  else if ((flags & 0x002) != 0)
    flags |= 0x020;
  if ((hdr->sh_flags & (1 << 4)) != 0)
    {
      flags |= 0x800000;
      newsect->entsize = hdr->sh_entsize;
    }
  if ((hdr->sh_flags & (1 << 5)) != 0)
    flags |= 0x1000000;
  if (hdr->sh_flags & (1 << 9))
    if (!setup_group (abfd, hdr, newsect))
      return 0;
  if ((hdr->sh_flags & (1 << 10)) != 0)
    flags |= 0x400;
  if ((hdr->sh_flags & 0x80000000) != 0)
    flags |= 0x8000;

  if ((flags & 0x001) == 0)
    {


      if (name [0] == '.')
 {
   const char *p;
   int n;
   if (name[1] == 'd')
     p = ".debug", n = 6;
   else if (name[1] == 'g' && name[2] == 'n')
     p = ".gnu.linkonce.wi.", n = 17;
   else if (name[1] == 'g' && name[2] == 'd')
     p = ".gdb_index", n = 11;
   else if (name[1] == 'l')
     p = ".line", n = 5;
   else if (name[1] == 's')
     p = ".stab", n = 5;
   else if (name[1] == 'z')
     p = ".zdebug", n = 7;
   else
     p = 
# 1065 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
        ((void *)0)
# 1065 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
            , n = 0;
   if (p != 
# 1066 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0) 
# 1066 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                && strncmp (name, p, n) == 0)
     flags |= 0x2000;
 }
    }







  if ((strncmp ((name), (".gnu.linkonce"), sizeof (".gnu.linkonce") - 1) == 0)
      && (((struct bfd_elf_section_data*)(newsect)->used_by_bfd)->next_in_group) == 
# 1078 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                       ((void *)0)
# 1078 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                           )
    flags |= 0x20000 | 0x0;

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  if (bed->elf_backend_section_flags)
    if (! bed->elf_backend_section_flags (&flags, hdr))
      return 0;

  if (! bfd_set_section_flags (abfd, newsect, flags))
    return 0;




  if (hdr->sh_type == 7)
    {
      bfd_byte *contents;

      if (!bfd_malloc_and_get_section (abfd, newsect, &contents))
 return 0;

      elf_parse_notes (abfd, (char *) contents, hdr->sh_size, hdr->sh_offset);
      free (contents);
    }

  if ((flags & 0x001) != 0)
    {
      Elf_Internal_Phdr *phdr;
      unsigned int i, nload;





      phdr = ((abfd) -> tdata.elf_obj_data)->phdr;
      for (nload = 0, i = 0; i < (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum; i++, phdr++)
 if (phdr->p_paddr != 0)
   break;
 else if (phdr->p_type == 1 && phdr->p_memsz != 0)
   ++nload;
      if (i >= (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum && nload > 1)
 return 1;

      phdr = ((abfd) -> tdata.elf_obj_data)->phdr;
      for (i = 0; i < (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum; i++, phdr++)
 {
   if (((phdr->p_type == 1
  && (hdr->sh_flags & (1 << 10)) == 0)
        || phdr->p_type == 7)
       && ((( ((((hdr)->sh_flags & (1 << 10)) != 0) && ((phdr)->p_type == 7 || (phdr)->p_type == (0x60000000 + 0x474e552) || (phdr)->p_type == 1)) || (((hdr)->sh_flags & (1 << 10)) == 0 && (phdr)->p_type != 7 && (phdr)->p_type != 6)) && !(((hdr)->sh_flags & (1 << 1)) == 0 && ((phdr)->p_type == 1 || (phdr)->p_type == 2 || (phdr)->p_type == (0x60000000 + 0x474e550) || (phdr)->p_type == (0x60000000 + 0x474e552) || (phdr)->p_type == (0x60000000 + 0x474e551))) && ((hdr)->sh_type == 8 || ((bfd_vma) (hdr)->sh_offset >= (phdr)->p_offset && (!(0) || ((hdr)->sh_offset - (phdr)->p_offset <= (phdr)->p_filesz - 1)) && (((hdr)->sh_offset - (phdr)->p_offset + ((((hdr)->sh_flags & (1 << 10)) != 0 && (hdr)->sh_type == 8 && (phdr)->p_type != 7) ? 0 : (hdr)->sh_size)) <= (phdr)->p_filesz))) && (!(1) || ((hdr)->sh_flags & (1 << 1)) == 0 || ((hdr)->sh_addr >= (phdr)->p_vaddr && (!(0) || ((hdr)->sh_addr - (phdr)->p_vaddr <= (phdr)->p_memsz - 1)) && (((hdr)->sh_addr - (phdr)->p_vaddr + ((((hdr)->sh_flags & (1 << 10)) != 0 && (hdr)->sh_type == 8 && (phdr)->p_type != 7) ? 0 : (hdr)->sh_size)) <= (phdr)->p_memsz))) && ((phdr)->p_type != 2 || (hdr)->sh_size != 0 || (phdr)->p_memsz == 0 || (((hdr)->sh_type == 8 || ((bfd_vma) (hdr)->sh_offset > (phdr)->p_offset && ((hdr)->sh_offset - (phdr)->p_offset < (phdr)->p_filesz))) && (((hdr)->sh_flags & (1 << 1)) == 0 || ((hdr)->sh_addr > (phdr)->p_vaddr && ((hdr)->sh_addr - (phdr)->p_vaddr < (phdr)->p_memsz))))))))
     {
       if ((flags & 0x002) == 0)
  newsect->lma = (phdr->p_paddr
    + hdr->sh_addr - phdr->p_vaddr);
       else







  newsect->lma = (phdr->p_paddr
    + hdr->sh_offset - phdr->p_offset);





       if (hdr->sh_addr >= phdr->p_vaddr
    && (hdr->sh_addr + hdr->sh_size
        <= phdr->p_vaddr + phdr->p_memsz))
  break;
     }
 }
    }



  if ((flags & 0x2000)
      && ((name[1] == 'd' && name[6] == '_')
   || (name[1] == 'z' && name[7] == '_')))
    {
      enum { nothing, compress, decompress } action = nothing;
      int compression_header_size;
      bfd_size_type uncompressed_size;
      bfd_boolean compressed
 = bfd_is_section_compressed_with_header (abfd, newsect,
       &compression_header_size,
       &uncompressed_size);

      if (compressed)
 {

   if ((abfd->flags & 0x8000))
     action = decompress;
 }



      if (action == nothing)
 {
   if (newsect->size != 0
       && (abfd->flags & 0x4000)
       && compression_header_size >= 0
       && uncompressed_size > 0
       && (!compressed
    || ((compression_header_size > 0)
        != ((abfd->flags & 0x20000) != 0))))
     action = compress;
   else
     return 1;
 }

      if (action == compress)
 {
   if (!bfd_init_section_compress_status (abfd, newsect))
     {
       _bfd_error_handler

  (dgettext ("bfd", "%B: unable to initialize compress status for section %s"),
   abfd, name);
       return 0;
     }
 }
      else
 {
   if (!bfd_init_section_decompress_status (abfd, newsect))
     {
       _bfd_error_handler

  (dgettext ("bfd", "%B: unable to initialize decompress status for section %s"),
   abfd, name);
       return 0;
     }
 }

      if (abfd->is_linker_input)
 {
   if (name[1] == 'z'
       && (action == decompress
    || (action == compress
        && (abfd->flags & 0x20000) != 0)))
     {



       char *new_name = convert_zdebug_to_debug (abfd, name);
       if (new_name == 
# 1226 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 1226 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          )
  return 0;
       bfd_rename_section (abfd, newsect, new_name);
     }
 }
      else


 newsect->flags |= 0x10000000;
    }

  return 1;
}

const char *const bfd_elf_section_type_names[] =
{
  "SHT_NULL", "SHT_PROGBITS", "SHT_SYMTAB", "SHT_STRTAB",
  "SHT_RELA", "SHT_HASH", "SHT_DYNAMIC", "SHT_NOTE",
  "SHT_NOBITS", "SHT_REL", "SHT_SHLIB", "SHT_DYNSYM",
};
# 1257 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
bfd_reloc_status_type
bfd_elf_generic_reloc (bfd *abfd __attribute__ ((__unused__)),
         arelent *reloc_entry,
         asymbol *symbol,
         void *data __attribute__ ((__unused__)),
         asection *input_section,
         bfd *output_bfd,
         char **error_message __attribute__ ((__unused__)))
{
  if (output_bfd != 
# 1266 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
      
# 1267 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     && (symbol->flags & (1 << 8)) == 0
      && (! reloc_entry->howto->partial_inplace
   || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  return bfd_reloc_continue;
}





static bfd_boolean
section_match (const Elf_Internal_Shdr * a,
        const Elf_Internal_Shdr * b)
{
  return
    a->sh_type == b->sh_type
    && (a->sh_flags & ~ (1 << 6))
    == (b->sh_flags & ~ (1 << 6))
    && a->sh_addralign == b->sh_addralign
    && a->sh_size == b->sh_size
    && a->sh_entsize == b->sh_entsize

    ;
}






static unsigned int
find_link (const bfd *obfd, const Elf_Internal_Shdr *iheader,
    const unsigned int hint)
{
  Elf_Internal_Shdr ** oheaders = (((obfd) -> tdata.elf_obj_data) -> elf_sect_ptr);
  unsigned int i;

  do { if (!(iheader != 
# 1309 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 1309 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
 )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",1309); } while (0);


  if (hint < (((obfd) -> tdata.elf_obj_data) -> num_elf_sections)
      && oheaders[hint] != 
# 1313 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          ((void *)0)
      
# 1314 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     && section_match (oheaders[hint], iheader))
    return hint;

  for (i = 1; i < (((obfd) -> tdata.elf_obj_data) -> num_elf_sections); i++)
    {
      Elf_Internal_Shdr * oheader = oheaders[i];

      if (oheader == 
# 1321 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                    ((void *)0)
# 1321 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                        )
 continue;
      if (section_match (oheader, iheader))


 return i;
    }

  return 0;
}





static bfd_boolean
copy_special_section_fields (const bfd *ibfd,
        bfd *obfd,
        const Elf_Internal_Shdr *iheader,
        Elf_Internal_Shdr *oheader,
        const unsigned int secnum)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((obfd)->xvec)->backend_data);
  const Elf_Internal_Shdr **iheaders = (const Elf_Internal_Shdr **) (((ibfd) -> tdata.elf_obj_data) -> elf_sect_ptr);
  bfd_boolean changed = 0;
  unsigned int sh_link;

  if (oheader->sh_type == 8)
    {
# 1366 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      if (oheader->sh_link == 0)
 oheader->sh_link = iheader->sh_link;
      if (oheader->sh_info == 0)
 oheader->sh_info = iheader->sh_info;
      return 1;
    }


  if (bed->elf_backend_copy_special_section_fields != 
# 1374 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                     ((void *)0)
      
# 1375 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     && bed->elf_backend_copy_special_section_fields
      (ibfd, obfd, iheader, oheader))
    return 1;





  if (iheader->sh_link != 0)
    {

      if (iheader->sh_link >= (((ibfd) -> tdata.elf_obj_data) -> num_elf_sections))
 {
   _bfd_error_handler

     (dgettext ("bfd", "%B: Invalid sh_link field (%d) in section number %d"),
      ibfd, iheader->sh_link, secnum);
   return 0;
 }

      sh_link = find_link (obfd, iheaders[iheader->sh_link], iheader->sh_link);
      if (sh_link != 0)
 {
   oheader->sh_link = sh_link;
   changed = 1;
 }
      else


 _bfd_error_handler

   (dgettext ("bfd", "%B: Failed to find link section for section %d"), obfd, secnum);
    }

  if (iheader->sh_info)
    {



      if (iheader->sh_flags & (1 << 6))
 {
   sh_link = find_link (obfd, iheaders[iheader->sh_info],
          iheader->sh_info);
   if (sh_link != 0)
     oheader->sh_flags |= (1 << 6);
 }
      else

 sh_link = iheader->sh_info;

      if (sh_link != 0)
 {
   oheader->sh_info = sh_link;
   changed = 1;
 }
      else
 _bfd_error_handler

   (dgettext ("bfd", "%B: Failed to find info section for section %d"), obfd, secnum);
    }

  return changed;
}




bfd_boolean
_bfd_elf_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  const Elf_Internal_Shdr **iheaders = (const Elf_Internal_Shdr **) (((ibfd) -> tdata.elf_obj_data) -> elf_sect_ptr);
  Elf_Internal_Shdr **oheaders = (((obfd) -> tdata.elf_obj_data) -> elf_sect_ptr);
  const struct elf_backend_data *bed;
  unsigned int i;

  if (((ibfd)->xvec->flavour) != bfd_target_elf_flavour
    || ((obfd)->xvec->flavour) != bfd_target_elf_flavour)
    return 1;

  if (!(((obfd) -> tdata.elf_obj_data) -> o->flags_init))
    {
      (((obfd) -> tdata.elf_obj_data) -> elf_header)->e_flags = (((ibfd) -> tdata.elf_obj_data) -> elf_header)->e_flags;
      (((obfd) -> tdata.elf_obj_data) -> o->flags_init) = 1;
    }

  (((obfd) -> tdata.elf_obj_data) -> gp) = (((ibfd) -> tdata.elf_obj_data) -> gp);


  (((obfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[7] =
    (((ibfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[7];


  if ((((ibfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[8])
    (((obfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[8]
      = (((ibfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[8];


  _bfd_elf_copy_obj_attributes (ibfd, obfd);

  if (iheaders == 
# 1474 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0) 
# 1474 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      || oheaders == 
# 1474 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                     ((void *)0)
# 1474 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                         )
    return 1;

  bed = ((const struct elf_backend_data *) ((obfd)->xvec)->backend_data);


  for (i = 1; i < (((obfd) -> tdata.elf_obj_data) -> num_elf_sections); i++)
    {
      unsigned int j;
      Elf_Internal_Shdr * oheader = oheaders[i];




      if (oheader == 
# 1488 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                    ((void *)0)
   
# 1489 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  || (oheader->sh_type != 8
       && oheader->sh_type < 0x60000000))
 continue;



      if (oheader->sh_size == 0
   || (oheader->sh_info != 0 && oheader->sh_link != 0))
 continue;



      for (j = 1; j < (((ibfd) -> tdata.elf_obj_data) -> num_elf_sections); j++)
 {
   const Elf_Internal_Shdr * iheader = iheaders[j];

   if (iheader == 
# 1505 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 1505 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
     continue;

   if (oheader->bfd_section != 
# 1508 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                              ((void *)0)
       
# 1509 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && iheader->bfd_section != 
# 1509 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                 ((void *)0)
       
# 1510 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && iheader->bfd_section->output_section != 
# 1510 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                 ((void *)0)
       
# 1511 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && iheader->bfd_section->output_section == oheader->bfd_section)
     {




       if (! copy_special_section_fields (ibfd, obfd, iheader, oheader, i))
  j = (((ibfd) -> tdata.elf_obj_data) -> num_elf_sections);
       break;
     }
 }

      if (j < (((ibfd) -> tdata.elf_obj_data) -> num_elf_sections))
 continue;




      for (j = 1; j < (((ibfd) -> tdata.elf_obj_data) -> num_elf_sections); j++)
 {
   const Elf_Internal_Shdr * iheader = iheaders[j];

   if (iheader == 
# 1533 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 1533 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
     continue;





   if ((oheader->sh_type == 8
        || iheader->sh_type == oheader->sh_type)
       && (iheader->sh_flags & ~ (1 << 6))
       == (oheader->sh_flags & ~ (1 << 6))
       && iheader->sh_addralign == oheader->sh_addralign
       && iheader->sh_entsize == oheader->sh_entsize
       && iheader->sh_size == oheader->sh_size
       && iheader->sh_addr == oheader->sh_addr
       && (iheader->sh_info != oheader->sh_info
    || iheader->sh_link != oheader->sh_link))
     {
       if (copy_special_section_fields (ibfd, obfd, iheader, oheader, i))
  break;
     }
 }

      if (j == (((ibfd) -> tdata.elf_obj_data) -> num_elf_sections) && oheader->sh_type >= 0x60000000)
 {


   if (bed->elf_backend_copy_special_section_fields != 
# 1560 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                      ((void *)0)
# 1560 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                          )
     bed->elf_backend_copy_special_section_fields (ibfd, obfd, 
# 1561 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                              ((void *)0)
# 1561 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                  , oheader);
 }
    }

  return 1;
}

static const char *
get_segment_type (unsigned int p_type)
{
  const char *pt;
  switch (p_type)
    {
    case 0: pt = "NULL"; break;
    case 1: pt = "LOAD"; break;
    case 2: pt = "DYNAMIC"; break;
    case 3: pt = "INTERP"; break;
    case 4: pt = "NOTE"; break;
    case 5: pt = "SHLIB"; break;
    case 6: pt = "PHDR"; break;
    case 7: pt = "TLS"; break;
    case (0x60000000 + 0x474e550): pt = "EH_FRAME"; break;
    case (0x60000000 + 0x474e551): pt = "STACK"; break;
    case (0x60000000 + 0x474e552): pt = "RELRO"; break;
    default: pt = 
# 1585 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 1585 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     ; break;
    }
  return pt;
}



bfd_boolean
_bfd_elf_print_private_bfd_data (bfd *abfd, void *farg)
{
  FILE *f = (FILE *) farg;
  Elf_Internal_Phdr *p;
  asection *s;
  bfd_byte *dynbuf = 
# 1598 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                    ((void *)0)
# 1598 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                        ;

  p = ((abfd) -> tdata.elf_obj_data)->phdr;
  if (p != 
# 1601 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 1601 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              )
    {
      unsigned int i, c;

      fprintf (f, dgettext ("bfd", "\nProgram Header:\n"));
      c = (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum;
      for (i = 0; i < c; i++, p++)
 {
   const char *pt = get_segment_type (p->p_type);
   char buf[20];

   if (pt == 
# 1612 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 1612 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
     {
       sprintf (buf, "0x%lx", p->p_type);
       pt = buf;
     }
   fprintf (f, "%8s off    0x", pt);
   bfd_fprintf_vma (abfd, f, p->p_offset);
   fprintf (f, " vaddr 0x");
   bfd_fprintf_vma (abfd, f, p->p_vaddr);
   fprintf (f, " paddr 0x");
   bfd_fprintf_vma (abfd, f, p->p_paddr);
   fprintf (f, " align 2**%u\n", bfd_log2 (p->p_align));
   fprintf (f, "         filesz 0x");
   bfd_fprintf_vma (abfd, f, p->p_filesz);
   fprintf (f, " memsz 0x");
   bfd_fprintf_vma (abfd, f, p->p_memsz);
   fprintf (f, " flags %c%c%c",
     (p->p_flags & (1 << 2)) != 0 ? 'r' : '-',
     (p->p_flags & (1 << 1)) != 0 ? 'w' : '-',
     (p->p_flags & (1 << 0)) != 0 ? 'x' : '-');
   if ((p->p_flags &~ (unsigned) ((1 << 2) | (1 << 1) | (1 << 0))) != 0)
     fprintf (f, " %lx", p->p_flags &~ (unsigned) ((1 << 2) | (1 << 1) | (1 << 0)));
   fprintf (f, "\n");
 }
    }

  s = bfd_get_section_by_name (abfd, ".dynamic");
  if (s != 
# 1639 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 1639 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              )
    {
      unsigned int elfsec;
      unsigned long shlink;
      bfd_byte *extdyn, *extdynend;
      size_t extdynsize;
      void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);

      fprintf (f, dgettext ("bfd", "\nDynamic Section:\n"));

      if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))
 goto error_return;

      elfsec = _bfd_elf_section_from_bfd_section (abfd, s);
      if (elfsec == (-0x101u))
 goto error_return;
      shlink = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[elfsec]->sh_link;

      extdynsize = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->s->sizeof_dyn;
      swap_dyn_in = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->s->swap_dyn_in;

      extdyn = dynbuf;

      if (s->size < extdynsize)
 goto error_return;
      extdynend = extdyn + s->size;


      for (; extdyn <= (extdynend - extdynsize); extdyn += extdynsize)
 {
   Elf_Internal_Dyn dyn;
   const char *name = "";
   char ab[20];
   bfd_boolean stringp;
   const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

   (*swap_dyn_in) (abfd, extdyn, &dyn);

   if (dyn.d_tag == 0)
     break;

   stringp = 0;
   switch (dyn.d_tag)
     {
     default:
       if (bed->elf_backend_get_target_dtag)
  name = (*bed->elf_backend_get_target_dtag) (dyn.d_tag);

       if (!strcmp (name, ""))
  {
    sprintf (ab, "%#" "l" "x", dyn.d_tag);
    name = ab;
  }
       break;

     case 1: name = "NEEDED"; stringp = 1; break;
     case 2: name = "PLTRELSZ"; break;
     case 3: name = "PLTGOT"; break;
     case 4: name = "HASH"; break;
     case 5: name = "STRTAB"; break;
     case 6: name = "SYMTAB"; break;
     case 7: name = "RELA"; break;
     case 8: name = "RELASZ"; break;
     case 9: name = "RELAENT"; break;
     case 10: name = "STRSZ"; break;
     case 11: name = "SYMENT"; break;
     case 12: name = "INIT"; break;
     case 13: name = "FINI"; break;
     case 14: name = "SONAME"; stringp = 1; break;
     case 15: name = "RPATH"; stringp = 1; break;
     case 16: name = "SYMBOLIC"; break;
     case 17: name = "REL"; break;
     case 18: name = "RELSZ"; break;
     case 19: name = "RELENT"; break;
     case 20: name = "PLTREL"; break;
     case 21: name = "DEBUG"; break;
     case 22: name = "TEXTREL"; break;
     case 23: name = "JMPREL"; break;
     case 24: name = "BIND_NOW"; break;
     case 25: name = "INIT_ARRAY"; break;
     case 26: name = "FINI_ARRAY"; break;
     case 27: name = "INIT_ARRAYSZ"; break;
     case 28: name = "FINI_ARRAYSZ"; break;
     case 29: name = "RUNPATH"; stringp = 1; break;
     case 30: name = "FLAGS"; break;
     case 32: name = "PREINIT_ARRAY"; break;
     case 33: name = "PREINIT_ARRAYSZ"; break;
     case 0x6ffffdf8: name = "CHECKSUM"; break;
     case 0x6ffffdf9: name = "PLTPADSZ"; break;
     case 0x6ffffdfa: name = "MOVEENT"; break;
     case 0x6ffffdfb: name = "MOVESZ"; break;
     case 0x6ffffdfc: name = "FEATURE"; break;
     case 0x6ffffdfd: name = "POSFLAG_1"; break;
     case 0x6ffffdfe: name = "SYMINSZ"; break;
     case 0x6ffffdff: name = "SYMINENT"; break;
     case 0x6ffffefa: name = "CONFIG"; stringp = 1; break;
     case 0x6ffffefb: name = "DEPAUDIT"; stringp = 1; break;
     case 0x6ffffefc: name = "AUDIT"; stringp = 1; break;
     case 0x6ffffefd: name = "PLTPAD"; break;
     case 0x6ffffefe: name = "MOVETAB"; break;
     case 0x6ffffeff: name = "SYMINFO"; break;
     case 0x6ffffff9: name = "RELACOUNT"; break;
     case 0x6ffffffa: name = "RELCOUNT"; break;
     case 0x6ffffffb: name = "FLAGS_1"; break;
     case 0x6ffffff0: name = "VERSYM"; break;
     case 0x6ffffffc: name = "VERDEF"; break;
     case 0x6ffffffd: name = "VERDEFNUM"; break;
     case 0x6ffffffe: name = "VERNEED"; break;
     case 0x6fffffff: name = "VERNEEDNUM"; break;
     case 0x7ffffffd: name = "AUXILIARY"; stringp = 1; break;
     case 0x7ffffffe: name = "USED"; break;
     case 0x7fffffff: name = "FILTER"; stringp = 1; break;
     case 0x6ffffef5: name = "GNU_HASH"; break;
     }

   fprintf (f, "  %-20s ", name);
   if (! stringp)
     {
       fprintf (f, "0x");
       bfd_fprintf_vma (abfd, f, dyn.d_un.d_val);
     }
   else
     {
       const char *string;
       unsigned int tagv = dyn.d_un.d_val;

       string = bfd_elf_string_from_elf_section (abfd, shlink, tagv);
       if (string == 
# 1766 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                    ((void *)0)
# 1766 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                        )
  goto error_return;
       fprintf (f, "%s", string);
     }
   fprintf (f, "\n");
 }

      free (dynbuf);
      dynbuf = 
# 1774 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 1774 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  ;
    }

  if (((((abfd) -> tdata.elf_obj_data) -> dynverdef_section) != 0 && ((abfd) -> tdata.elf_obj_data)->verdef == 
# 1777 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                               ((void *)0)
# 1777 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                   )
      || ((((abfd) -> tdata.elf_obj_data) -> dynverref_section) != 0 && ((abfd) -> tdata.elf_obj_data)->verref == 
# 1778 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                                  ((void *)0)
# 1778 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                      ))
    {
      if (! _bfd_elf_slurp_version_tables (abfd, 0))
 return 0;
    }

  if ((((abfd) -> tdata.elf_obj_data) -> dynverdef_section) != 0)
    {
      Elf_Internal_Verdef *t;

      fprintf (f, dgettext ("bfd", "\nVersion definitions:\n"));
      for (t = ((abfd) -> tdata.elf_obj_data)->verdef; t != 
# 1789 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                             ((void *)0)
# 1789 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                 ; t = t->vd_nextdef)
 {
   fprintf (f, "%d 0x%2.2x 0x%8.8lx %s\n", t->vd_ndx,
     t->vd_flags, t->vd_hash,
     t->vd_nodename ? t->vd_nodename : "<corrupt>");
   if (t->vd_auxptr != 
# 1794 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0) 
# 1794 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                           && t->vd_auxptr->vda_nextptr != 
# 1794 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                           ((void *)0)
# 1794 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                               )
     {
       Elf_Internal_Verdaux *a;

       fprintf (f, "\t");
       for (a = t->vd_auxptr->vda_nextptr;
     a != 
# 1800 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
         ((void *)0)
# 1800 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
             ;
     a = a->vda_nextptr)
  fprintf (f, "%s ",
    a->vda_nodename ? a->vda_nodename : "<corrupt>");
       fprintf (f, "\n");
     }
 }
    }

  if ((((abfd) -> tdata.elf_obj_data) -> dynverref_section) != 0)
    {
      Elf_Internal_Verneed *t;

      fprintf (f, dgettext ("bfd", "\nVersion References:\n"));
      for (t = ((abfd) -> tdata.elf_obj_data)->verref; t != 
# 1814 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                             ((void *)0)
# 1814 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                 ; t = t->vn_nextref)
 {
   Elf_Internal_Vernaux *a;

   fprintf (f, dgettext ("bfd", "  required from %s:\n"),
     t->vn_filename ? t->vn_filename : "<corrupt>");
   for (a = t->vn_auxptr; a != 
# 1820 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                              ((void *)0)
# 1820 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  ; a = a->vna_nextptr)
     fprintf (f, "    0x%8.8lx 0x%2.2x %2.2d %s\n", a->vna_hash,
       a->vna_flags, a->vna_other,
       a->vna_nodename ? a->vna_nodename : "<corrupt>");
 }
    }

  return 1;

 error_return:
  if (dynbuf != 
# 1830 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 1830 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   )
    free (dynbuf);
  return 0;
}



const char *
_bfd_elf_get_symbol_version_string (bfd *abfd, asymbol *symbol,
        bfd_boolean *hidden)
{
  const char *version_string = 
# 1841 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                              ((void *)0)
# 1841 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  ;
  if ((((abfd) -> tdata.elf_obj_data) -> dynversym_section) != 0
      && ((((abfd) -> tdata.elf_obj_data) -> dynverdef_section) != 0 || (((abfd) -> tdata.elf_obj_data) -> dynverref_section) != 0))
    {
      unsigned int vernum = ((elf_symbol_type *) symbol)->version;

      *hidden = (vernum & 0x8000) != 0;
      vernum &= 0x7fff;

      if (vernum == 0)
 version_string = "";
      else if (vernum == 1)
 version_string = "Base";
      else if (vernum <= ((abfd) -> tdata.elf_obj_data)->cverdefs)
 version_string =
   ((abfd) -> tdata.elf_obj_data)->verdef[vernum - 1].vd_nodename;
      else
 {
   Elf_Internal_Verneed *t;

   version_string = "";
   for (t = ((abfd) -> tdata.elf_obj_data)->verref;
        t != 
# 1863 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 1863 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                ;
        t = t->vn_nextref)
     {
       Elf_Internal_Vernaux *a;

       for (a = t->vn_auxptr; a != 
# 1868 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                  ((void *)0)
# 1868 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                      ; a = a->vna_nextptr)
  {
    if (a->vna_other == vernum)
      {
        version_string = a->vna_nodename;
        break;
      }
  }
     }
 }
    }
  return version_string;
}



void
bfd_elf_print_symbol (bfd *abfd,
        void *filep,
        asymbol *symbol,
        bfd_print_symbol_type how)
{
  FILE *file = (FILE *) filep;
  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_more:
      fprintf (file, "elf ");
      bfd_fprintf_vma (abfd, file, symbol->value);
      fprintf (file, " %x", symbol->flags);
      break;
    case bfd_print_symbol_all:
      {
 const char *section_name;
 const char *name = 
# 1904 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 1904 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       ;
 const struct elf_backend_data *bed;
 unsigned char st_other;
 bfd_vma val;
 const char *version_string;
 bfd_boolean hidden;

 section_name = symbol->section ? symbol->section->name : "(*none*)";

 bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
 if (bed->elf_backend_print_symbol_all)
   name = (*bed->elf_backend_print_symbol_all) (abfd, filep, symbol);

 if (name == 
# 1917 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 1917 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
   {
     name = symbol->name;
     bfd_print_symbol_vandf (abfd, file, symbol);
   }

 fprintf (file, " %s\t", section_name);




 if (symbol->section && (((symbol->section)->flags & 0x1000) != 0))
   val = ((elf_symbol_type *) symbol)->internal_elf_sym.st_value;
 else
   val = ((elf_symbol_type *) symbol)->internal_elf_sym.st_size;
 bfd_fprintf_vma (abfd, file, val);


 version_string = _bfd_elf_get_symbol_version_string (abfd,
            symbol,
            &hidden);
 if (version_string)
   {
     if (!hidden)
       fprintf (file, "  %-11s", version_string);
     else
       {
  int i;

  fprintf (file, " (%s)", version_string);
  for (i = 10 - strlen (version_string); i > 0; --i)
    putc (' ', file);
       }
   }


 st_other = ((elf_symbol_type *) symbol)->internal_elf_sym.st_other;

 switch (st_other)
   {
   case 0: break;
   case 1: fprintf (file, " .internal"); break;
   case 2: fprintf (file, " .hidden"); break;
   case 3: fprintf (file, " .protected"); break;
   default:


     fprintf (file, " 0x%02x", (unsigned int) st_other);
   }

 fprintf (file, " %s", name);
      }
      break;
    }
}





bfd_boolean
bfd_section_from_shdr (bfd *abfd, unsigned int shindex)
{
  Elf_Internal_Shdr *hdr;
  Elf_Internal_Ehdr *ehdr;
  const struct elf_backend_data *bed;
  const char *name;
  bfd_boolean ret = 1;
  static bfd_boolean * sections_being_created = 
# 1985 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                               ((void *)0)
# 1985 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                   ;
  static bfd * sections_being_created_abfd = 
# 1986 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                            ((void *)0)
# 1986 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                ;
  static unsigned int nesting = 0;

  if (shindex >= (((abfd) -> tdata.elf_obj_data) -> num_elf_sections))
    return 0;

  if (++ nesting > 3)
    {
# 2004 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      if (sections_being_created_abfd != abfd)
 sections_being_created = 
# 2005 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
# 2005 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                             ;
      if (sections_being_created == 
# 2006 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                   ((void *)0)
# 2006 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                       )
 {

   sections_being_created = (bfd_boolean *)
     bfd_zalloc (abfd, (((abfd) -> tdata.elf_obj_data) -> num_elf_sections) * sizeof (bfd_boolean));
   sections_being_created_abfd = abfd;
 }
      if (sections_being_created [shindex])
 {
   _bfd_error_handler
     (dgettext ("bfd", "%B: warning: loop in section dependencies detected"), abfd);
   return 0;
 }
      sections_being_created [shindex] = 1;
    }

  hdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[shindex];
  ehdr = (((abfd) -> tdata.elf_obj_data) -> elf_header);
  name = bfd_elf_string_from_elf_section (abfd, ehdr->e_shstrndx,
       hdr->sh_name);
  if (name == 
# 2026 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 2026 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    goto fail;

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  switch (hdr->sh_type)
    {
    case 0:

      goto success;

    case 1:
    case 8:
    case 5:
    case 7:
    case 14:
    case 15:
    case 16:
    case 0x6ffffff7:
    case 0x6ffffff6:
      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
      goto success;

    case 6:
      if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
 goto fail;

      if (hdr->sh_link > (((abfd) -> tdata.elf_obj_data) -> num_elf_sections))
 {


   switch (bfd_get_arch (abfd))
     {
     case bfd_arch_i386:
     case bfd_arch_sparc:
       if (hdr->sh_link == ((-0x100u) & 0xffff)
    || hdr->sh_link == (((-0x100u) + 1) & 0xffff) )
  break;

     default:
       goto fail;
     }
 }
      else if ((((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[hdr->sh_link] == 
# 2068 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                      ((void *)0)
# 2068 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                          )
 goto fail;
      else if ((((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[hdr->sh_link]->sh_type != 3)
 {
   Elf_Internal_Shdr *dynsymhdr;




   if ((((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) != 0)
     {
       dynsymhdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[(((abfd) -> tdata.elf_obj_data) -> dynsymtab_section)];
       hdr->sh_link = dynsymhdr->sh_link;
     }
   else
     {
       unsigned int i, num_sec;

       num_sec = (((abfd) -> tdata.elf_obj_data) -> num_elf_sections);
       for (i = 1; i < num_sec; i++)
  {
    dynsymhdr = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[i];
    if (dynsymhdr->sh_type == 11)
      {
        hdr->sh_link = dynsymhdr->sh_link;
        break;
      }
  }
     }
 }
      goto success;

    case 2:
      if ((((abfd) -> tdata.elf_obj_data) -> symtab_section) == shindex)
 goto success;

      if (hdr->sh_entsize != bed->s->sizeof_sym)
 goto fail;

      if (hdr->sh_info * hdr->sh_entsize > hdr->sh_size)
 {
   if (hdr->sh_size != 0)
     goto fail;



   hdr->sh_info = 0;
   goto success;
 }



      if ((((abfd) -> tdata.elf_obj_data) -> symtab_section) != 0)
 {
   _bfd_error_handler

     (dgettext ("bfd", "%B: warning: multiple symbol tables detected" " - ignoring the table in section %u")
                                              ,
      abfd, shindex);
   goto success;
 }
      (((abfd) -> tdata.elf_obj_data) -> symtab_section) = shindex;
      (((abfd) -> tdata.elf_obj_data) -> symtab_hdr) = *hdr;
      (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[shindex] = hdr = & (((abfd) -> tdata.elf_obj_data) -> symtab_hdr);
      abfd->flags |= 0x10;







      if ((hdr->sh_flags & (1 << 1)) != 0
   && (abfd->flags & 0x40) != 0
   && ! _bfd_elf_make_section_from_shdr (abfd, hdr, name,
      shindex))
 goto fail;




      {
 elf_section_list * entry;
 unsigned int i, num_sec;

 for (entry = (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list); entry != 
# 2153 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                    ((void *)0)
# 2153 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                        ; entry = entry->next)
   if (entry->hdr.sh_link == shindex)
     goto success;

 num_sec = (((abfd) -> tdata.elf_obj_data) -> num_elf_sections);
 for (i = shindex + 1; i < num_sec; i++)
   {
     Elf_Internal_Shdr *hdr2 = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[i];

     if (hdr2->sh_type == 18
  && hdr2->sh_link == shindex)
       break;
   }

 if (i == num_sec)
   for (i = 1; i < shindex; i++)
     {
       Elf_Internal_Shdr *hdr2 = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[i];

       if (hdr2->sh_type == 18
    && hdr2->sh_link == shindex)
  break;
     }

 if (i != shindex)
   ret = bfd_section_from_shdr (abfd, i);

 goto success;
      }

    case 11:
      if ((((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) == shindex)
 goto success;

      if (hdr->sh_entsize != bed->s->sizeof_sym)
 goto fail;

      if (hdr->sh_info * hdr->sh_entsize > hdr->sh_size)
 {
   if (hdr->sh_size != 0)
     goto fail;




   hdr->sh_info = 0;
   goto success;
 }



      if ((((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) != 0)
 {
   _bfd_error_handler

     (dgettext ("bfd", "%B: warning: multiple dynamic symbol tables detected" " - ignoring the table in section %u")
                                              ,
      abfd, shindex);
   goto success;
 }
      (((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) = shindex;
      ((abfd) -> tdata.elf_obj_data)->dynsymtab_hdr = *hdr;
      (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[shindex] = hdr = &((abfd) -> tdata.elf_obj_data)->dynsymtab_hdr;
      abfd->flags |= 0x10;



      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
      goto success;

    case 18:
      {
 elf_section_list * entry;

 for (entry = (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list); entry != 
# 2227 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                    ((void *)0)
# 2227 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                        ; entry = entry->next)
   if (entry->ndx == shindex)
     goto success;

 entry = bfd_alloc (abfd, sizeof * entry);
 if (entry == 
# 2232 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 2232 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
   goto fail;
 entry->ndx = shindex;
 entry->hdr = * hdr;
 entry->next = (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list);
 (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list) = entry;
 (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[shindex] = & entry->hdr;
 goto success;
      }

    case 3:
      if (hdr->bfd_section != 
# 2243 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             ((void *)0)
# 2243 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                 )
 goto success;

      if (ehdr->e_shstrndx == shindex)
 {
   ((abfd) -> tdata.elf_obj_data)->shstrtab_hdr = *hdr;
   (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[shindex] = &((abfd) -> tdata.elf_obj_data)->shstrtab_hdr;
   goto success;
 }

      if ((((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[(((abfd) -> tdata.elf_obj_data) -> symtab_section)]->sh_link == shindex)
 {
 symtab_strtab:
   ((abfd) -> tdata.elf_obj_data)->strtab_hdr = *hdr;
   (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[shindex] = &((abfd) -> tdata.elf_obj_data)->strtab_hdr;
   goto success;
 }

      if ((((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[(((abfd) -> tdata.elf_obj_data) -> dynsymtab_section)]->sh_link == shindex)
 {
 dynsymtab_strtab:
   ((abfd) -> tdata.elf_obj_data)->dynstrtab_hdr = *hdr;
   hdr = &((abfd) -> tdata.elf_obj_data)->dynstrtab_hdr;
   (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[shindex] = hdr;


   ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,
       shindex);
   goto success;
 }




      if ((((abfd) -> tdata.elf_obj_data) -> symtab_section) == 0 || (((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) == 0)
 {
   unsigned int i, num_sec;

   num_sec = (((abfd) -> tdata.elf_obj_data) -> num_elf_sections);
   for (i = 1; i < num_sec; i++)
     {
       Elf_Internal_Shdr *hdr2 = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[i];
       if (hdr2->sh_link == shindex)
  {

    if (i == shindex)
      goto fail;
    if (! bfd_section_from_shdr (abfd, i))
      goto fail;
    if ((((abfd) -> tdata.elf_obj_data) -> symtab_section) == i)
      goto symtab_strtab;
    if ((((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) == i)
      goto dynsymtab_strtab;
  }
     }
 }
      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
      goto success;

    case 9:
    case 4:

      {
 asection *target_sect;
 Elf_Internal_Shdr *hdr2, **p_hdr;
 unsigned int num_sec = (((abfd) -> tdata.elf_obj_data) -> num_elf_sections);
 struct bfd_elf_section_data *esdt;

 if (hdr->sh_entsize
     != (bfd_size_type) (hdr->sh_type == 9
    ? bed->s->sizeof_rel : bed->s->sizeof_rela))
   goto fail;


 if (hdr->sh_link >= num_sec)
   {
     _bfd_error_handler

       (dgettext ("bfd", "%B: invalid link %u for reloc section %s (index %u)"),
        abfd, hdr->sh_link, name, shindex);
     ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,
         shindex);
     goto success;
   }
# 2337 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
 if ((abfd->flags & (0x40 | 0x02)) == 0
     && (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[hdr->sh_link]->sh_type != 2
     && (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[hdr->sh_link]->sh_type != 11)
   {
     unsigned int scan;
     int found;

     found = 0;
     for (scan = 1; scan < num_sec; scan++)
       {
  if ((((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[scan]->sh_type == 2
      || (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[scan]->sh_type == 11)
    {
      if (found != 0)
        {
   found = 0;
   break;
        }
      found = scan;
    }
       }
     if (found != 0)
       hdr->sh_link = found;
   }


 if (((((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[hdr->sh_link]->sh_type == 2
      || (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[hdr->sh_link]->sh_type == 11)
     && ! bfd_section_from_shdr (abfd, hdr->sh_link))
   goto fail;
# 2375 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
 if (hdr->sh_link != (((abfd) -> tdata.elf_obj_data) -> symtab_section)
     || hdr->sh_link == 0
     || hdr->sh_info == 0
     || hdr->sh_info >= num_sec
     || (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[hdr->sh_info]->sh_type == 9
     || (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[hdr->sh_info]->sh_type == 4)
   {
     ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,
         shindex);
     goto success;
   }

 if (! bfd_section_from_shdr (abfd, hdr->sh_info))
   goto fail;

 target_sect = bfd_section_from_elf_index (abfd, hdr->sh_info);
 if (target_sect == 
# 2391 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 2391 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       )
   goto fail;

 esdt = ((struct bfd_elf_section_data*)(target_sect)->used_by_bfd);
 if (hdr->sh_type == 4)
   p_hdr = &esdt->rela.hdr;
 else
   p_hdr = &esdt->rel.hdr;


 if (*p_hdr != 
# 2401 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 2401 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  )
   goto fail;
 hdr2 = (Elf_Internal_Shdr *) bfd_alloc (abfd, sizeof (*hdr2));
 if (hdr2 == 
# 2404 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 2404 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
   goto fail;
 *hdr2 = *hdr;
 *p_hdr = hdr2;
 (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[shindex] = hdr2;
 target_sect->reloc_count += (((hdr)->sh_entsize > 0 ? (hdr)->sh_size / (hdr)->sh_entsize : 0)
         * bed->s->int_rels_per_ext_rel);
 target_sect->flags |= 0x004;
 target_sect->relocation = 
# 2412 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          ((void *)0)
# 2412 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                              ;
 target_sect->rel_filepos = hdr->sh_offset;


 if (hdr->sh_size != 0)
   {
     if (hdr->sh_type == 4)
       target_sect->use_rela_p = 1;
   }
 abfd->flags |= 0x01;
 goto success;
      }

    case 0x6ffffffd:
      (((abfd) -> tdata.elf_obj_data) -> dynverdef_section) = shindex;
      ((abfd) -> tdata.elf_obj_data)->dynverdef_hdr = *hdr;
      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
      goto success;

    case 0x6fffffff:
      if (hdr->sh_entsize != sizeof (Elf_External_Versym))
 goto fail;

      (((abfd) -> tdata.elf_obj_data) -> dynversym_section) = shindex;
      ((abfd) -> tdata.elf_obj_data)->dynversym_hdr = *hdr;
      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
      goto success;

    case 0x6ffffffe:
      (((abfd) -> tdata.elf_obj_data) -> dynverref_section) = shindex;
      ((abfd) -> tdata.elf_obj_data)->dynverref_hdr = *hdr;
      ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
      goto success;

    case 10:
      goto success;

    case 17:
      if (! ( (hdr)->sh_type == 17 && (hdr)->sh_size >= 4 && (hdr)->sh_entsize == 4 && ((hdr)->sh_size % 4) == 0))
 goto fail;

      if (!_bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
 goto fail;

      goto success;

    default:

      if (hdr->sh_type == 0x6ffffff5
   || hdr->sh_type == bed->obj_attrs_section_type)
 {
   if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
     goto fail;
   _bfd_elf_parse_attributes (abfd, hdr);
   goto success;
 }


      if (bed->elf_backend_section_from_shdr (abfd, hdr, name, shindex))
 goto success;

      if (hdr->sh_type >= 0x80000000 && hdr->sh_type <= 0xFFFFFFFF)
 {
   if ((hdr->sh_flags & (1 << 1)) != 0)


     _bfd_error_handler

       (dgettext ("bfd", "%B: unknown type [%#x] section `%s'"),
        abfd, hdr->sh_type, name);
   else
     {

       ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name,
           shindex);
       goto success;
     }
 }
      else if (hdr->sh_type >= 0x70000000
        && hdr->sh_type <= 0x7FFFFFFF)

 _bfd_error_handler

   (dgettext ("bfd", "%B: unknown type [%#x] section `%s'"),
    abfd, hdr->sh_type, name);
      else if (hdr->sh_type >= 0x60000000 && hdr->sh_type <= 0x6fffffff)
 {

   if ((hdr->sh_flags & (1 << 8)) != 0)



     _bfd_error_handler

       (dgettext ("bfd", "%B: unknown type [%#x] section `%s'"),
        abfd, hdr->sh_type, name);
   else
     {

       ret = _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex);
       goto success;
     }
 }
      else

 _bfd_error_handler

   (dgettext ("bfd", "%B: unknown type [%#x] section `%s'"),
    abfd, hdr->sh_type, name);

      goto fail;
    }

 fail:
  ret = 0;
 success:
  if (sections_being_created && sections_being_created_abfd == abfd)
    sections_being_created [shindex] = 0;
  if (-- nesting == 0)
    {
      sections_being_created = 
# 2532 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                              ((void *)0)
# 2532 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  ;
      sections_being_created_abfd = abfd;
    }
  return ret;
}



Elf_Internal_Sym *
bfd_sym_from_r_symndx (struct sym_cache *cache,
         bfd *abfd,
         unsigned long r_symndx)
{
  unsigned int ent = r_symndx % 32;

  if (cache->abfd != abfd || cache->indx[ent] != r_symndx)
    {
      Elf_Internal_Shdr *symtab_hdr;
      unsigned char esym[sizeof (Elf64_External_Sym)];
      Elf_External_Sym_Shndx eshndx;

      symtab_hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;
      if (bfd_elf_get_elf_syms (abfd, symtab_hdr, 1, r_symndx,
    &cache->sym[ent], esym, &eshndx) == 
# 2555 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                       ((void *)0)
# 2555 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                           )
 return 
# 2556 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
       ((void *)0)
# 2556 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
           ;

      if (cache->abfd != abfd)
 {
   memset (cache->indx, -1, sizeof (cache->indx));
   cache->abfd = abfd;
 }
      cache->indx[ent] = r_symndx;
    }

  return &cache->sym[ent];
}




asection *
bfd_section_from_elf_index (bfd *abfd, unsigned int sec_index)
{
  if (sec_index >= (((abfd) -> tdata.elf_obj_data) -> num_elf_sections))
    return 
# 2576 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 2576 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;
  return (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr)[sec_index]->bfd_section;
}

static const struct bfd_elf_special_section special_sections_b[] =
{
  { (".bss"), (sizeof (".bss") - 1), -2, 8, (1 << 1) + (1 << 0) },
  { 
# 2583 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2583 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_c[] =
{
  { (".comment"), (sizeof (".comment") - 1), 0, 1, 0 },
  { 
# 2589 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2589 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_d[] =
{
  { (".data"), (sizeof (".data") - 1), -2, 1, (1 << 1) + (1 << 0) },
  { (".data1"), (sizeof (".data1") - 1), 0, 1, (1 << 1) + (1 << 0) },



  { (".debug"), (sizeof (".debug") - 1), 0, 1, 0 },
  { (".debug_line"), (sizeof (".debug_line") - 1), 0, 1, 0 },
  { (".debug_info"), (sizeof (".debug_info") - 1), 0, 1, 0 },
  { (".debug_abbrev"), (sizeof (".debug_abbrev") - 1), 0, 1, 0 },
  { (".debug_aranges"), (sizeof (".debug_aranges") - 1), 0, 1, 0 },
  { (".dynamic"), (sizeof (".dynamic") - 1), 0, 6, (1 << 1) },
  { (".dynstr"), (sizeof (".dynstr") - 1), 0, 3, (1 << 1) },
  { (".dynsym"), (sizeof (".dynsym") - 1), 0, 11, (1 << 1) },
  { 
# 2607 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2607 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_f[] =
{
  { (".fini"), (sizeof (".fini") - 1), 0, 1, (1 << 1) + (1 << 2) },
  { (".fini_array"), (sizeof (".fini_array") - 1), -2, 15, (1 << 1) + (1 << 0) },
  { 
# 2614 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2614 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0 , 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_g[] =
{
  { (".gnu.linkonce.b"), (sizeof (".gnu.linkonce.b") - 1), -2, 8, (1 << 1) + (1 << 0) },
  { (".gnu.lto_"), (sizeof (".gnu.lto_") - 1), -1, 1, 0x80000000 },
  { (".got"), (sizeof (".got") - 1), 0, 1, (1 << 1) + (1 << 0) },
  { (".gnu.version"), (sizeof (".gnu.version") - 1), 0, 0x6fffffff, 0 },
  { (".gnu.version_d"), (sizeof (".gnu.version_d") - 1), 0, 0x6ffffffd, 0 },
  { (".gnu.version_r"), (sizeof (".gnu.version_r") - 1), 0, 0x6ffffffe, 0 },
  { (".gnu.liblist"), (sizeof (".gnu.liblist") - 1), 0, 0x6ffffff7, (1 << 1) },
  { (".gnu.conflict"), (sizeof (".gnu.conflict") - 1), 0, 4, (1 << 1) },
  { (".gnu.hash"), (sizeof (".gnu.hash") - 1), 0, 0x6ffffff6, (1 << 1) },
  { 
# 2628 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2628 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_h[] =
{
  { (".hash"), (sizeof (".hash") - 1), 0, 5, (1 << 1) },
  { 
# 2634 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2634 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_i[] =
{
  { (".init"), (sizeof (".init") - 1), 0, 1, (1 << 1) + (1 << 2) },
  { (".init_array"), (sizeof (".init_array") - 1), -2, 14, (1 << 1) + (1 << 0) },
  { (".interp"), (sizeof (".interp") - 1), 0, 1, 0 },
  { 
# 2642 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2642 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_l[] =
{
  { (".line"), (sizeof (".line") - 1), 0, 1, 0 },
  { 
# 2648 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2648 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_n[] =
{
  { (".note.GNU-stack"), (sizeof (".note.GNU-stack") - 1), 0, 1, 0 },
  { (".note"), (sizeof (".note") - 1), -1, 7, 0 },
  { 
# 2655 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2655 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_p[] =
{
  { (".preinit_array"), (sizeof (".preinit_array") - 1), -2, 16, (1 << 1) + (1 << 0) },
  { (".plt"), (sizeof (".plt") - 1), 0, 1, (1 << 1) + (1 << 2) },
  { 
# 2662 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2662 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_r[] =
{
  { (".rodata"), (sizeof (".rodata") - 1), -2, 1, (1 << 1) },
  { (".rodata1"), (sizeof (".rodata1") - 1), 0, 1, (1 << 1) },
  { (".rela"), (sizeof (".rela") - 1), -1, 4, 0 },
  { (".rel"), (sizeof (".rel") - 1), -1, 9, 0 },
  { 
# 2671 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2671 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_s[] =
{
  { (".shstrtab"), (sizeof (".shstrtab") - 1), 0, 3, 0 },
  { (".strtab"), (sizeof (".strtab") - 1), 0, 3, 0 },
  { (".symtab"), (sizeof (".symtab") - 1), 0, 2, 0 },


  { ".stabstr", 5, 3, 3, 0 },
  { 
# 2682 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2682 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_t[] =
{
  { (".text"), (sizeof (".text") - 1), -2, 1, (1 << 1) + (1 << 2) },
  { (".tbss"), (sizeof (".tbss") - 1), -2, 8, (1 << 1) + (1 << 0) + (1 << 10) },
  { (".tdata"), (sizeof (".tdata") - 1), -2, 1, (1 << 1) + (1 << 0) + (1 << 10) },
  { 
# 2690 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2690 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section special_sections_z[] =
{
  { (".zdebug_line"), (sizeof (".zdebug_line") - 1), 0, 1, 0 },
  { (".zdebug_info"), (sizeof (".zdebug_info") - 1), 0, 1, 0 },
  { (".zdebug_abbrev"), (sizeof (".zdebug_abbrev") - 1), 0, 1, 0 },
  { (".zdebug_aranges"), (sizeof (".zdebug_aranges") - 1), 0, 1, 0 },
  { 
# 2699 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 2699 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       , 0, 0, 0, 0 }
};

static const struct bfd_elf_special_section * const special_sections[] =
{
  special_sections_b,
  special_sections_c,
  special_sections_d,
  
# 2707 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2707 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  special_sections_f,
  special_sections_g,
  special_sections_h,
  special_sections_i,
  
# 2712 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2712 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  
# 2713 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2713 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  special_sections_l,
  
# 2715 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2715 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  special_sections_n,
  
# 2717 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2717 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  special_sections_p,
  
# 2719 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2719 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  special_sections_r,
  special_sections_s,
  special_sections_t,
  
# 2723 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2723 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  
# 2724 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2724 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  
# 2725 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2725 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  
# 2726 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2726 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  
# 2727 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 2727 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     ,
  special_sections_z
};

const struct bfd_elf_special_section *
_bfd_elf_get_special_section (const char *name,
         const struct bfd_elf_special_section *spec,
         unsigned int rela)
{
  int i;
  int len;

  len = strlen (name);

  for (i = 0; spec[i].prefix != 
# 2741 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 2741 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   ; i++)
    {
      int suffix_len;
      int prefix_len = spec[i].prefix_length;

      if (len < prefix_len)
 continue;
      if (memcmp (name, spec[i].prefix, prefix_len) != 0)
 continue;

      suffix_len = spec[i].suffix_length;
      if (suffix_len <= 0)
 {
   if (name[prefix_len] != 0)
     {
       if (suffix_len == 0)
  continue;
       if (name[prefix_len] != '.'
    && (suffix_len == -2
        || (rela && spec[i].type == 9)))
  continue;
     }
 }
      else
 {
   if (len < prefix_len + suffix_len)
     continue;
   if (memcmp (name + len - suffix_len,
        spec[i].prefix + prefix_len,
        suffix_len) != 0)
     continue;
 }
      return &spec[i];
    }

  return 
# 2776 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
        ((void *)0)
# 2776 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
            ;
}

const struct bfd_elf_special_section *
_bfd_elf_get_sec_type_attr (bfd *abfd, asection *sec)
{
  int i;
  const struct bfd_elf_special_section *spec;
  const struct elf_backend_data *bed;


  if (sec->name == 
# 2787 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 2787 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      )
    return 
# 2788 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 2788 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  spec = bed->special_sections;
  if (spec)
    {
      spec = _bfd_elf_get_special_section (sec->name,
        bed->special_sections,
        sec->use_rela_p);
      if (spec != 
# 2797 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 2797 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
 return spec;
    }

  if (sec->name[0] != '.')
    return 
# 2802 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 2802 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;

  i = sec->name[1] - 'b';
  if (i < 0 || i > 'z' - 'b')
    return 
# 2806 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 2806 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;

  spec = special_sections[i];

  if (spec == 
# 2810 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 2810 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 
# 2811 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 2811 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;

  return _bfd_elf_get_special_section (sec->name, spec, sec->use_rela_p);
}

bfd_boolean
_bfd_elf_new_section_hook (bfd *abfd, asection *sec)
{
  struct bfd_elf_section_data *sdata;
  const struct elf_backend_data *bed;
  const struct bfd_elf_special_section *ssect;

  sdata = (struct bfd_elf_section_data *) sec->used_by_bfd;
  if (sdata == 
# 2824 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 2824 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  )
    {
      sdata = (struct bfd_elf_section_data *) bfd_zalloc (abfd,
                                                          sizeof (*sdata));
      if (sdata == 
# 2828 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 2828 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      )
 return 0;
      sec->used_by_bfd = sdata;
    }


  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  sec->use_rela_p = bed->default_use_rela_p;
# 2846 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  if (abfd->direction != read_direction
      || (sec->flags & 0x100000) != 0)
    {
      ssect = (*bed->get_sec_type_attr) (abfd, sec);
      if (ssect != 
# 2850 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
   
# 2851 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  && (!sec->flags
       || (sec->flags & 0x100000) != 0
       || ssect->type == 14
       || ssect->type == 15))
 {
   (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->this_hdr.sh_type) = ssect->type;
   (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->this_hdr.sh_flags) = ssect->attr;
 }
    }

  return _bfd_generic_new_section_hook (abfd, sec);
}
# 2886 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
bfd_boolean
_bfd_elf_make_section_from_phdr (bfd *abfd,
     Elf_Internal_Phdr *hdr,
     int hdr_index,
     const char *type_name)
{
  asection *newsect;
  char *name;
  char namebuf[64];
  size_t len;
  int split;

  split = ((hdr->p_memsz > 0)
     && (hdr->p_filesz > 0)
     && (hdr->p_memsz > hdr->p_filesz));

  if (hdr->p_filesz > 0)
    {
      sprintf (namebuf, "%s%d%s", type_name, hdr_index, split ? "a" : "");
      len = strlen (namebuf) + 1;
      name = (char *) bfd_alloc (abfd, len);
      if (!name)
 return 0;
      memcpy (name, namebuf, len);
      newsect = bfd_make_section (abfd, name);
      if (newsect == 
# 2911 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                    ((void *)0)
# 2911 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                        )
 return 0;
      newsect->vma = hdr->p_vaddr;
      newsect->lma = hdr->p_paddr;
      newsect->size = hdr->p_filesz;
      newsect->filepos = hdr->p_offset;
      newsect->flags |= 0x100;
      newsect->alignment_power = bfd_log2 (hdr->p_align);
      if (hdr->p_type == 1)
 {
   newsect->flags |= 0x001;
   newsect->flags |= 0x002;
   if (hdr->p_flags & (1 << 0))
     {


       newsect->flags |= 0x010;
     }
 }
      if (!(hdr->p_flags & (1 << 1)))
 {
   newsect->flags |= 0x008;
 }
    }

  if (hdr->p_memsz > hdr->p_filesz)
    {
      bfd_vma align;

      sprintf (namebuf, "%s%d%s", type_name, hdr_index, split ? "b" : "");
      len = strlen (namebuf) + 1;
      name = (char *) bfd_alloc (abfd, len);
      if (!name)
 return 0;
      memcpy (name, namebuf, len);
      newsect = bfd_make_section (abfd, name);
      if (newsect == 
# 2947 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                    ((void *)0)
# 2947 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                        )
 return 0;
      newsect->vma = hdr->p_vaddr + hdr->p_filesz;
      newsect->lma = hdr->p_paddr + hdr->p_filesz;
      newsect->size = hdr->p_memsz - hdr->p_filesz;
      newsect->filepos = hdr->p_offset + hdr->p_filesz;
      align = newsect->vma & -newsect->vma;
      if (align == 0 || align > hdr->p_align)
 align = hdr->p_align;
      newsect->alignment_power = bfd_log2 (align);
      if (hdr->p_type == 1)
 {






   if (((abfd)->format) == bfd_core)
     newsect->size = 0;
   newsect->flags |= 0x001;
   if (hdr->p_flags & (1 << 0))
     newsect->flags |= 0x010;
 }
      if (!(hdr->p_flags & (1 << 1)))
 newsect->flags |= 0x008;
    }

  return 1;
}

bfd_boolean
bfd_section_from_phdr (bfd *abfd, Elf_Internal_Phdr *hdr, int hdr_index)
{
  const struct elf_backend_data *bed;

  switch (hdr->p_type)
    {
    case 0:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "null");

    case 1:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "load");

    case 2:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "dynamic");

    case 3:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "interp");

    case 4:
      if (! _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "note"))
 return 0;
      if (! elf_read_notes (abfd, hdr->p_offset, hdr->p_filesz))
 return 0;
      return 1;

    case 5:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "shlib");

    case 6:
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "phdr");

    case (0x60000000 + 0x474e550):
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index,
           "eh_frame_hdr");

    case (0x60000000 + 0x474e551):
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "stack");

    case (0x60000000 + 0x474e552):
      return _bfd_elf_make_section_from_phdr (abfd, hdr, hdr_index, "relro");

    default:

      bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
      return bed->elf_backend_section_from_phdr (abfd, hdr, hdr_index, "proc");
    }
}




Elf_Internal_Shdr *
_bfd_elf_single_rel_hdr (asection *sec)
{
  if (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->rel.hdr)
    {
      do { if (!(((struct bfd_elf_section_data*)(sec)->used_by_bfd)->rela.hdr == 
# 3035 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
     ((void *)0)
# 3035 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3035); } while (0);
      return ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->rel.hdr;
    }
  else
    return ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->rela.hdr;
}

static bfd_boolean
_bfd_elf_set_reloc_sh_name (bfd *abfd,
       Elf_Internal_Shdr *rel_hdr,
       const char *sec_name,
       bfd_boolean use_rela_p)
{
  char *name = (char *) bfd_alloc (abfd,
       sizeof ".rela" + strlen (sec_name));
  if (name == 
# 3050 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 3050 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 0;

  sprintf (name, "%s%s", use_rela_p ? ".rela" : ".rel", sec_name);
  rel_hdr->sh_name =
    (unsigned int) _bfd_elf_strtab_add ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr), name,
     0);
  if (rel_hdr->sh_name == (unsigned int) -1)
    return 0;

  return 1;
}






static bfd_boolean
_bfd_elf_init_reloc_shdr (bfd *abfd,
     struct bfd_elf_section_reloc_data *reldata,
     const char *sec_name,
     bfd_boolean use_rela_p,
     bfd_boolean delay_st_name_p)
{
  Elf_Internal_Shdr *rel_hdr;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  do { if (!(reldata->hdr == 
# 3078 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 3078 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
 )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3078); } while (0);
  rel_hdr = bfd_zalloc (abfd, sizeof (*rel_hdr));
  reldata->hdr = rel_hdr;

  if (delay_st_name_p)
    rel_hdr->sh_name = (unsigned int) -1;
  else if (!_bfd_elf_set_reloc_sh_name (abfd, rel_hdr, sec_name,
     use_rela_p))
    return 0;
  rel_hdr->sh_type = use_rela_p ? 4 : 9;
  rel_hdr->sh_entsize = (use_rela_p
    ? bed->s->sizeof_rela
    : bed->s->sizeof_rel);
  rel_hdr->sh_addralign = (bfd_vma) 1 << bed->s->log_file_align;
  rel_hdr->sh_flags = 0;
  rel_hdr->sh_addr = 0;
  rel_hdr->sh_size = 0;
  rel_hdr->sh_offset = 0;

  return 1;
}



int
bfd_elf_get_default_section_type (flagword flags)
{
  if ((flags & 0x001) != 0
      && (flags & (0x002 | 0x100)) == 0)
    return 8;
  return 1;
}

struct fake_section_arg
{
  struct bfd_link_info *link_info;
  bfd_boolean failed;
};



static void
elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)
{
  struct fake_section_arg *arg = (struct fake_section_arg *)fsarg;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  struct bfd_elf_section_data *esd = ((struct bfd_elf_section_data*)(asect)->used_by_bfd);
  Elf_Internal_Shdr *this_hdr;
  unsigned int sh_type;
  const char *name = asect->name;
  bfd_boolean delay_st_name_p = 0;

  if (arg->failed)
    {


      return;
    }

  this_hdr = &esd->this_hdr;

  if (arg->link_info)
    {

      if ((arg->link_info->compress_debug & COMPRESS_DEBUG)
   && (asect->flags & 0x2000)
   && name[1] == 'd'
   && name[6] == '_')
 {


   asect->flags |= 0x8000000;




   delay_st_name_p = 1;
 }
    }
  else if ((asect->flags & 0x10000000))
    {

      if ((abfd->flags & (0x8000 | 0x20000)))
 {



   if (name[1] == 'z')
     {
       char *new_name = convert_zdebug_to_debug (abfd, name);
       if (new_name == 
# 3168 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 3168 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          )
  {
    arg->failed = 1;
    return;
  }
       name = new_name;
     }
 }
      else if (asect->compress_status == 1)
 {




   char *new_name = convert_debug_to_zdebug (abfd, name);
   if (new_name == 
# 3183 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 3183 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      )
     {
       arg->failed = 1;
       return;
     }
   do { if (!(name[1] != 'z')) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3188); } while (0);
   name = new_name;
 }
    }

  if (delay_st_name_p)
    this_hdr->sh_name = (unsigned int) -1;
  else
    {
      this_hdr->sh_name
 = (unsigned int) _bfd_elf_strtab_add ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr),
           name, 0);
      if (this_hdr->sh_name == (unsigned int) -1)
 {
   arg->failed = 1;
   return;
 }
    }



  if ((asect->flags & 0x001) != 0
      || asect->user_set_vma)
    this_hdr->sh_addr = asect->vma;
  else
    this_hdr->sh_addr = 0;

  this_hdr->sh_offset = 0;
  this_hdr->sh_size = asect->size;
  this_hdr->sh_link = 0;

  if (asect->alignment_power >= (sizeof (bfd_vma) * 8) - 1)
    {
      _bfd_error_handler

 (dgettext ("bfd", "%B: error: Alignment power %d of section `%A' is too big"),
  abfd, asect->alignment_power, asect);
      arg->failed = 1;
      return;
    }
  this_hdr->sh_addralign = (bfd_vma) 1 << asect->alignment_power;



  this_hdr->bfd_section = asect;
  this_hdr->contents = 
# 3233 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 3233 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          ;



  if ((asect->flags & 0x2000000) != 0)
    sh_type = 17;
  else
    sh_type = bfd_elf_get_default_section_type (asect->flags);

  if (this_hdr->sh_type == 0)
    this_hdr->sh_type = sh_type;
  else if (this_hdr->sh_type == 8
    && sh_type == 1
    && (asect->flags & 0x001) != 0)
    {




      _bfd_error_handler
 (dgettext ("bfd", "warning: section `%A' type changed to PROGBITS"), asect);
      this_hdr->sh_type = sh_type;
    }

  switch (this_hdr->sh_type)
    {
    default:
      break;

    case 3:
    case 7:
    case 8:
    case 1:
      break;

    case 14:
    case 15:
    case 16:
      this_hdr->sh_entsize = bed->s->arch_size / 8;
      break;

    case 5:
      this_hdr->sh_entsize = bed->s->sizeof_hash_entry;
      break;

    case 11:
      this_hdr->sh_entsize = bed->s->sizeof_sym;
      break;

    case 6:
      this_hdr->sh_entsize = bed->s->sizeof_dyn;
      break;

    case 4:
      if (((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->may_use_rela_p)
 this_hdr->sh_entsize = bed->s->sizeof_rela;
      break;

     case 9:
      if (((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->may_use_rel_p)
 this_hdr->sh_entsize = bed->s->sizeof_rel;
      break;

     case 0x6fffffff:
      this_hdr->sh_entsize = sizeof (Elf_External_Versym);
      break;

     case 0x6ffffffd:
      this_hdr->sh_entsize = 0;



      if (this_hdr->sh_info == 0)
 this_hdr->sh_info = ((abfd) -> tdata.elf_obj_data)->cverdefs;
      else
 do { if (!(((abfd) -> tdata.elf_obj_data)->cverdefs == 0 || this_hdr->sh_info == ((abfd) -> tdata.elf_obj_data)->cverdefs)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3308); } while (0)
                                                         ;
      break;

    case 0x6ffffffe:
      this_hdr->sh_entsize = 0;



      if (this_hdr->sh_info == 0)
 this_hdr->sh_info = ((abfd) -> tdata.elf_obj_data)->cverrefs;
      else
 do { if (!(((abfd) -> tdata.elf_obj_data)->cverrefs == 0 || this_hdr->sh_info == ((abfd) -> tdata.elf_obj_data)->cverrefs)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3320); } while (0)
                                                         ;
      break;

    case 17:
      this_hdr->sh_entsize = 4;
      break;

    case 0x6ffffff6:
      this_hdr->sh_entsize = bed->s->arch_size == 64 ? 0 : 4;
      break;
    }

  if ((asect->flags & 0x001) != 0)
    this_hdr->sh_flags |= (1 << 1);
  if ((asect->flags & 0x008) == 0)
    this_hdr->sh_flags |= (1 << 0);
  if ((asect->flags & 0x010) != 0)
    this_hdr->sh_flags |= (1 << 2);
  if ((asect->flags & 0x800000) != 0)
    {
      this_hdr->sh_flags |= (1 << 4);
      this_hdr->sh_entsize = asect->entsize;
    }
  if ((asect->flags & 0x1000000) != 0)
    this_hdr->sh_flags |= (1 << 5);
  if ((asect->flags & 0x2000000) == 0 && (((struct bfd_elf_section_data*)(asect)->used_by_bfd)->group.name) != 
# 3346 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                                  ((void *)0)
# 3346 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                      )
    this_hdr->sh_flags |= (1 << 9);
  if ((asect->flags & 0x400) != 0)
    {
      this_hdr->sh_flags |= (1 << 10);
      if (asect->size == 0
   && (asect->flags & 0x100) == 0)
 {
   struct bfd_link_order *o = asect->map_tail.link_order;

   this_hdr->sh_size = 0;
   if (o != 
# 3357 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 3357 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     {
       this_hdr->sh_size = o->offset + o->size;
       if (this_hdr->sh_size != 0)
  this_hdr->sh_type = 8;
     }
 }
    }
  if ((asect->flags & (0x2000000 | 0x8000)) == 0x8000)
    this_hdr->sh_flags |= 0x80000000;





  if ((asect->flags & 0x004) != 0)
    {


      if (arg->link_info

   && esd->rel.count + esd->rela.count > 0
   && (((arg->link_info)->type == type_relocatable)
       || arg->link_info->emitrelocations))
 {
   if (esd->rel.count && esd->rel.hdr == 
# 3382 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                        ((void *)0)
       
# 3383 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && !_bfd_elf_init_reloc_shdr (abfd, &esd->rel, name, 0,
         delay_st_name_p))
     {
       arg->failed = 1;
       return;
     }
   if (esd->rela.count && esd->rela.hdr == 
# 3389 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                          ((void *)0)
       
# 3390 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && !_bfd_elf_init_reloc_shdr (abfd, &esd->rela, name, 1,
         delay_st_name_p))
     {
       arg->failed = 1;
       return;
     }
 }
      else if (!_bfd_elf_init_reloc_shdr (abfd,
       (asect->use_rela_p
        ? &esd->rela : &esd->rel),
       name,
       asect->use_rela_p,
       delay_st_name_p))
   arg->failed = 1;
    }


  sh_type = this_hdr->sh_type;
  if (bed->elf_backend_fake_sections
      && !(*bed->elf_backend_fake_sections) (abfd, this_hdr, asect))
    arg->failed = 1;

  if (sh_type == 8 && asect->size != 0)
    {


      this_hdr->sh_type = sh_type;
    }
}






void
bfd_elf_set_group_contents (bfd *abfd, asection *sec, void *failedptrarg)
{
  bfd_boolean *failedptr = (bfd_boolean *) failedptrarg;
  asection *elt, *first;
  unsigned char *loc;
  bfd_boolean gas;



  if (((sec->flags & (0x2000000 | 0x100000)) != 0x2000000)
      || *failedptr)
    return;

  if (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->this_hdr.sh_info == 0)
    {
      unsigned long symindx = 0;



      if ((((struct bfd_elf_section_data*)(sec)->used_by_bfd)->group.id) != 
# 3445 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 3445 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   )
 symindx = (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->group.id)->udata.i;

      if (symindx == 0)
 {


   do { if (!((((abfd) -> tdata.elf_obj_data) -> o->section_syms) != 
# 3452 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
  ((void *)0)
# 3452 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3452); } while (0);
   symindx = (((abfd) -> tdata.elf_obj_data) -> o->section_syms)[sec->index]->udata.i;
 }
      ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->this_hdr.sh_info = symindx;
    }
  else if (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->this_hdr.sh_info == (unsigned int) -2)
    {



      asection *igroup;
      struct bfd_elf_section_data *sec_data;
      unsigned long symndx;
      unsigned long extsymoff;
      struct elf_link_hash_entry *h;




      igroup = (((struct bfd_elf_section_data*)((((struct bfd_elf_section_data*)(sec)->used_by_bfd)->next_in_group))->used_by_bfd)->sec_group);
      sec_data = ((struct bfd_elf_section_data*)(igroup)->used_by_bfd);
      symndx = sec_data->this_hdr.sh_info;
      extsymoff = 0;
      if (!(((igroup->owner) -> tdata.elf_obj_data) -> bad_symtab))
 {
   Elf_Internal_Shdr *symtab_hdr;

   symtab_hdr = &((igroup->owner) -> tdata.elf_obj_data)->symtab_hdr;
   extsymoff = symtab_hdr->sh_info;
 }
      h = (((igroup->owner) -> tdata.elf_obj_data) -> sym_hashes)[symndx - extsymoff];
      while (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
 h = (struct elf_link_hash_entry *) h->root.u.i.link;

      ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->this_hdr.sh_info = h->indx;
    }


  gas = 1;
  if (sec->contents == 
# 3492 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 3492 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          )
    {
      gas = 0;
      sec->contents = (unsigned char *) bfd_alloc (abfd, sec->size);


      ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->this_hdr.contents = sec->contents;
      if (sec->contents == 
# 3499 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          ((void *)0)
# 3499 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                              )
 {
   *failedptr = 1;
   return;
 }
    }

  loc = sec->contents + sec->size;




  first = elt = (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->next_in_group);





  while (elt != 
# 3517 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 3517 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   )
    {
      asection *s;

      s = elt;
      if (!gas)
 s = s->output_section;
      if (s != 
# 3524 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
   
# 3525 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  && !((s) == (&_bfd_std_section[2])))
 {
   unsigned int idx = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_idx;

   loc -= 4;
   ((*((abfd)->xvec->bfd_h_putx32)) (idx, loc));
 }
      elt = (((struct bfd_elf_section_data*)(elt)->used_by_bfd)->next_in_group);
      if (elt == first)
 break;
    }

  loc -= 4;
  do { if (!(loc == sec->contents)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3538); } while (0);

  ((*((abfd)->xvec->bfd_h_putx32)) (sec->flags & 0x20000 ? 0x1 : 0, loc));
}





asection *
_bfd_elf_plt_get_reloc_section (bfd *abfd, const char *name)
{


  if (((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->want_got_plt
      && strcmp (name, ".plt") == 0)
    {
      asection *sec;

      name = ".got.plt";
      sec = bfd_get_section_by_name (abfd, name);
      if (sec != 
# 3559 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 3559 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    )
 return sec;
      name = ".got";
    }

  return bfd_get_section_by_name (abfd, name);
}



static asection *
elf_get_reloc_section (asection *reloc_sec)
{
  const char *name;
  unsigned int type;
  bfd *abfd;
  const struct elf_backend_data *bed;

  type = ((struct bfd_elf_section_data*)(reloc_sec)->used_by_bfd)->this_hdr.sh_type;
  if (type != 9 && type != 4)
    return 
# 3579 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 3579 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;


  name = reloc_sec->name;
  if (strncmp (name, ".rel", 4) != 0)
    return 
# 3584 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 3584 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;
  name += 4;
  if (type == 4 && *name++ != 'a')
    return 
# 3587 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 3587 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;

  abfd = reloc_sec->owner;
  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  return bed->get_reloc_section (abfd, name);
}





static bfd_boolean
assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
{
  struct elf_obj_tdata *t = ((abfd) -> tdata.elf_obj_data);
  asection *sec;
  unsigned int section_number;
  Elf_Internal_Shdr **i_shdrp;
  struct bfd_elf_section_data *d;
  bfd_boolean need_symtab;

  section_number = 1;

  _bfd_elf_strtab_clear_all_refs ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr));


  if (link_info == 
# 3613 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0) 
# 3613 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       || !link_info->resolve_section_groups)
    {
      size_t reloc_count = 0;


      for (sec = abfd->sections; sec != 
# 3618 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                       ((void *)0)
# 3618 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                           ; sec = sec->next)
 {
   d = ((struct bfd_elf_section_data*)(sec)->used_by_bfd);

   if (d->this_hdr.sh_type == 17)
     {
       if (sec->flags & 0x100000)
  {

    do { asection *_s = sec; asection *_next = _s->next; asection *_prev = _s->prev; if (_prev) _prev->next = _next; else (abfd)->sections = _next; if (_next) _next->prev = _prev; else (abfd)->section_last = _prev; } while (0);
    abfd->section_count--;
  }
       else
  d->this_idx = section_number++;
     }


   reloc_count += sec->reloc_count;
 }


      if (reloc_count == 0)
 abfd->flags &= ~0x01;
    }

  for (sec = abfd->sections; sec; sec = sec->next)
    {
      d = ((struct bfd_elf_section_data*)(sec)->used_by_bfd);

      if (d->this_hdr.sh_type != 17)
 d->this_idx = section_number++;
      if (d->this_hdr.sh_name != (unsigned int) -1)
 _bfd_elf_strtab_addref ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr), d->this_hdr.sh_name);
      if (d->rel.hdr)
 {
   d->rel.idx = section_number++;
   if (d->rel.hdr->sh_name != (unsigned int) -1)
     _bfd_elf_strtab_addref ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr), d->rel.hdr->sh_name);
 }
      else
 d->rel.idx = 0;

      if (d->rela.hdr)
 {
   d->rela.idx = section_number++;
   if (d->rela.hdr->sh_name != (unsigned int) -1)
     _bfd_elf_strtab_addref ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr), d->rela.hdr->sh_name);
 }
      else
 d->rela.idx = 0;
    }

  need_symtab = (((abfd)->symcount) > 0
  || (link_info == 
# 3671 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
      
# 3672 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     && ((abfd->flags & (0x02 | 0x40 | 0x01))
   == 0x01)));
  if (need_symtab)
    {
      (((abfd) -> tdata.elf_obj_data) -> symtab_section) = section_number++;
      _bfd_elf_strtab_addref ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr), t->symtab_hdr.sh_name);
      if (section_number > (((-0x100u) - 2) & 0xFFFF))
 {
   elf_section_list * entry;

   do { if (!((((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list) == 
# 3682 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
  ((void *)0)
# 3682 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3682); } while (0);

   entry = bfd_zalloc (abfd, sizeof * entry);
   entry->ndx = section_number++;
   (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list) = entry;
   entry->hdr.sh_name
     = (unsigned int) _bfd_elf_strtab_add ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr),
        ".symtab_shndx", 0);
   if (entry->hdr.sh_name == (unsigned int) -1)
     return 0;
 }
      (((abfd) -> tdata.elf_obj_data) -> o->strtab_section) = section_number++;
      _bfd_elf_strtab_addref ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr), t->strtab_hdr.sh_name);
    }

  (((abfd) -> tdata.elf_obj_data) -> o->shstrtab_section) = section_number++;
  _bfd_elf_strtab_addref ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr), t->shstrtab_hdr.sh_name);
  (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_shstrndx = (((abfd) -> tdata.elf_obj_data) -> o->shstrtab_section);

  if (section_number >= (-0x100u))
    {

      _bfd_error_handler (dgettext ("bfd", "%B: too many sections: %u"),
     abfd, section_number);
      return 0;
    }

  (((abfd) -> tdata.elf_obj_data) -> num_elf_sections) = section_number;
  (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_shnum = section_number;



  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc2 (abfd, section_number,
                                                sizeof (Elf_Internal_Shdr *));
  if (i_shdrp == 
# 3716 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 3716 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    )
    return 0;

  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd,
                                                 sizeof (Elf_Internal_Shdr));
  if (i_shdrp[0] == 
# 3721 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 3721 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       )
    {
      bfd_release (abfd, i_shdrp);
      return 0;
    }

  (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr) = i_shdrp;

  i_shdrp[(((abfd) -> tdata.elf_obj_data) -> o->shstrtab_section)] = &t->shstrtab_hdr;
  if (need_symtab)
    {
      i_shdrp[(((abfd) -> tdata.elf_obj_data) -> symtab_section)] = &t->symtab_hdr;
      if ((((abfd) -> tdata.elf_obj_data) -> num_elf_sections) > ((-0x100u) & 0xFFFF))
 {
   elf_section_list * entry = (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list);
   do { if (!(entry != 
# 3736 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
  ((void *)0)
# 3736 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3736); } while (0);
   i_shdrp[entry->ndx] = & entry->hdr;
   entry->hdr.sh_link = (((abfd) -> tdata.elf_obj_data) -> symtab_section);
 }
      i_shdrp[(((abfd) -> tdata.elf_obj_data) -> o->strtab_section)] = &t->strtab_hdr;
      t->symtab_hdr.sh_link = (((abfd) -> tdata.elf_obj_data) -> o->strtab_section);
    }

  for (sec = abfd->sections; sec; sec = sec->next)
    {
      asection *s;

      d = ((struct bfd_elf_section_data*)(sec)->used_by_bfd);

      i_shdrp[d->this_idx] = &d->this_hdr;
      if (d->rel.idx != 0)
 i_shdrp[d->rel.idx] = d->rel.hdr;
      if (d->rela.idx != 0)
 i_shdrp[d->rela.idx] = d->rela.hdr;






      if (d->rel.idx != 0)
 {
   d->rel.hdr->sh_link = (((abfd) -> tdata.elf_obj_data) -> symtab_section);
   d->rel.hdr->sh_info = d->this_idx;
   d->rel.hdr->sh_flags |= (1 << 6);
 }
      if (d->rela.idx != 0)
 {
   d->rela.hdr->sh_link = (((abfd) -> tdata.elf_obj_data) -> symtab_section);
   d->rela.hdr->sh_info = d->this_idx;
   d->rela.hdr->sh_flags |= (1 << 6);
 }


      if ((d->this_hdr.sh_flags & (1 << 7)) != 0)
 {
   s = (((struct bfd_elf_section_data*)(sec)->used_by_bfd)->linked_to);
   if (s)
     {

       if (link_info != 
# 3781 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                       ((void *)0)
# 3781 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                           )
  {

    if ((!((s) == (&_bfd_std_section[2])) && (((s)->output_section) == (&_bfd_std_section[2])) && (s)->sec_info_type != 2 && (s)->sec_info_type != 4))
      {
        asection *kept;
        _bfd_error_handler

   (dgettext ("bfd", "%B: sh_link of section `%A' points to" " discarded section `%A' of `%B'")
                                        ,
    abfd, d->this_hdr.bfd_section,
    s, s->owner);


        kept = _bfd_elf_check_kept_section (s, link_info);
        if (kept == 
# 3796 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 3796 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       )
   {
     bfd_set_error (bfd_error_bad_value);
     return 0;
   }
        s = kept;
      }

    s = s->output_section;
    do { if (!(s != 
# 3805 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 3805 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",3805); } while (0);
  }
       else
  {

    if (s->output_section == 
# 3810 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                            ((void *)0)
# 3810 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                )
      {
        _bfd_error_handler

   (dgettext ("bfd", "%B: sh_link of section `%A' points to" " removed section `%A' of `%B'")
                                      ,
    abfd, d->this_hdr.bfd_section, s, s->owner);
        bfd_set_error (bfd_error_bad_value);
        return 0;
      }
    s = s->output_section;
  }
       d->this_hdr.sh_link = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_idx;
     }
   else
     {





       const struct elf_backend_data *bed
  = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
       if (bed->link_order_error_handler)
  bed->link_order_error_handler

    (dgettext ("bfd", "%B: warning: sh_link not set for section `%A'"),
     abfd, sec);
     }
 }

      switch (d->this_hdr.sh_type)
 {
 case 9:
 case 4:






   s = bfd_get_section_by_name (abfd, ".dynsym");
   if (s != 
# 3852 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 3852 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     d->this_hdr.sh_link = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_idx;

   s = elf_get_reloc_section (sec);
   if (s != 
# 3856 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 3856 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     {
       d->this_hdr.sh_info = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_idx;
       d->this_hdr.sh_flags |= (1 << 6);
     }
   break;

 case 3:




   if ((strncmp ((sec->name), (".stab"), sizeof (".stab") - 1) == 0)
       && strcmp (sec->name + strlen (sec->name) - 3, "str") == 0)
     {
       size_t len;
       char *alc;

       len = strlen (sec->name);
       alc = (char *) bfd_malloc (len - 2);
       if (alc == 
# 3876 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 3876 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
  return 0;
       memcpy (alc, sec->name, len - 3);
       alc[len - 3] = '\0';
       s = bfd_get_section_by_name (abfd, alc);
       free (alc);
       if (s != 
# 3882 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 3882 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   )
  {
    ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_link = d->this_idx;


    if (((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize == 0)
      ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize
        = 4 + 2 * bfd_get_arch_size (abfd) / 8;
  }
     }
   break;

 case 6:
 case 11:
 case 0x6ffffffe:
 case 0x6ffffffd:



   s = bfd_get_section_by_name (abfd, ".dynstr");
   if (s != 
# 3902 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 3902 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     d->this_hdr.sh_link = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_idx;
   break;

 case 0x6ffffff7:



   s = bfd_get_section_by_name (abfd, (sec->flags & 0x001)
          ? ".dynstr" : ".gnu.libstr");
   if (s != 
# 3912 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 3912 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     d->this_hdr.sh_link = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_idx;
   break;

 case 5:
 case 0x6ffffff6:
 case 0x6fffffff:


   s = bfd_get_section_by_name (abfd, ".dynsym");
   if (s != 
# 3922 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 3922 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     d->this_hdr.sh_link = ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_idx;
   break;

 case 17:
   d->this_hdr.sh_link = (((abfd) -> tdata.elf_obj_data) -> symtab_section);
 }
    }





  return 1;
}

static bfd_boolean
sym_is_global (bfd *abfd, asymbol *sym)
{

  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  if (bed->elf_backend_sym_is_global)
    return (*bed->elf_backend_sym_is_global) (abfd, sym);

  return ((sym->flags & ((1 << 1) | (1 << 7) | (1 << 23))) != 0
   || ((((sym)->section)) == (&_bfd_std_section[1]))
   || (((((sym)->section))->flags & 0x1000) != 0));
}
# 3958 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
unsigned int
_bfd_elf_filter_global_symbols (bfd *abfd, struct bfd_link_info *info,
    asymbol **syms, long symcount)
{
  long src_count, dst_count = 0;

  for (src_count = 0; src_count < symcount; src_count++)
    {
      asymbol *sym = syms[src_count];
      char *name = (char *) ((sym)->name);
      struct bfd_link_hash_entry *h;

      if (!sym_is_global (abfd, sym))
 continue;

      h = bfd_link_hash_lookup (info->hash, name, 0, 0, 0);
      if (h == 
# 3974 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 3974 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  )
 continue;
      if (h->type != bfd_link_hash_defined && h->type != bfd_link_hash_defweak)
 continue;
      if (h->linker_def || h->ldscript_def)
 continue;

      syms[dst_count++] = sym;
    }

  syms[dst_count] = 
# 3984 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 3984 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       ;

  return dst_count;
}




static bfd_boolean
ignore_section_sym (bfd *abfd, asymbol *sym)
{
  elf_symbol_type *type_ptr;

  if ((sym->flags & (1 << 8)) == 0)
    return 0;

  type_ptr = (((sym)->the_bfd->xvec->flavour == bfd_target_elf_flavour && (sym)->the_bfd->tdata.elf_obj_data != 0) ? (elf_symbol_type *) (sym) : 0);
  return ((type_ptr != 
# 4001 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
    
# 4002 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   && type_ptr->internal_elf_sym.st_shndx != 0
    && ((sym->section) == (&_bfd_std_section[2])))
   || !(sym->section->owner == abfd
        || (sym->section->output_section->owner == abfd
     && sym->section->output_offset == 0)
        || ((sym->section) == (&_bfd_std_section[2]))));
}




static bfd_boolean
elf_map_symbols (bfd *abfd, unsigned int *pnum_locals)
{
  unsigned int symcount = ((abfd)->symcount);
  asymbol **syms = ((abfd)->outsymbols);
  asymbol **sect_syms;
  unsigned int num_locals = 0;
  unsigned int num_globals = 0;
  unsigned int num_locals2 = 0;
  unsigned int num_globals2 = 0;
  unsigned int max_index = 0;
  unsigned int idx;
  asection *asect;
  asymbol **new_syms;






  for (asect = abfd->sections; asect; asect = asect->next)
    {
      if (max_index < asect->index)
 max_index = asect->index;
    }

  max_index++;
  sect_syms = (asymbol **) bfd_zalloc2 (abfd, max_index, sizeof (asymbol *));
  if (sect_syms == 
# 4041 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 4041 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      )
    return 0;
  (((abfd) -> tdata.elf_obj_data) -> o->section_syms) = sect_syms;
  (((abfd) -> tdata.elf_obj_data) -> o->num_section_syms) = max_index;



  for (idx = 0; idx < symcount; idx++)
    {
      asymbol *sym = syms[idx];

      if ((sym->flags & (1 << 8)) != 0
   && sym->value == 0
   && !ignore_section_sym (abfd, sym)
   && !((sym->section) == (&_bfd_std_section[2])))
 {
   asection *sec = sym->section;

   if (sec->owner != abfd)
     sec = sec->output_section;

   sect_syms[sec->index] = syms[idx];
 }
    }


  for (idx = 0; idx < symcount; idx++)
    {
      if (sym_is_global (abfd, syms[idx]))
 num_globals++;
      else if (!ignore_section_sym (abfd, syms[idx]))
 num_locals++;
    }





  for (asect = abfd->sections; asect; asect = asect->next)
    {
      if (sect_syms[asect->index] == 
# 4081 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                    ((void *)0)
# 4081 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                        )
 {
   if (!sym_is_global (abfd, asect->symbol))
     num_locals++;
   else
     num_globals++;
 }
    }


  new_syms = (asymbol **) bfd_alloc2 (abfd, num_locals + num_globals,
                                      sizeof (asymbol *));

  if (new_syms == 
# 4094 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 4094 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
    return 0;

  for (idx = 0; idx < symcount; idx++)
    {
      asymbol *sym = syms[idx];
      unsigned int i;

      if (sym_is_global (abfd, sym))
 i = num_locals + num_globals2++;
      else if (!ignore_section_sym (abfd, sym))
 i = num_locals2++;
      else
 continue;
      new_syms[i] = sym;
      sym->udata.i = i + 1;
    }
  for (asect = abfd->sections; asect; asect = asect->next)
    {
      if (sect_syms[asect->index] == 
# 4113 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                    ((void *)0)
# 4113 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                        )
 {
   asymbol *sym = asect->symbol;
   unsigned int i;

   sect_syms[asect->index] = sym;
   if (!sym_is_global (abfd, sym))
     i = num_locals2++;
   else
     i = num_locals + num_globals2++;
   new_syms[i] = sym;
   sym->udata.i = i + 1;
 }
    }

  bfd_set_symtab (abfd, new_syms, num_locals + num_globals);

  *pnum_locals = num_locals;
  return 1;
}




static inline file_ptr
align_file_position (file_ptr off, int align)
{
  return (off + align - 1) & ~(align - 1);
}




file_ptr
_bfd_elf_assign_file_position_for_section (Elf_Internal_Shdr *i_shdrp,
        file_ptr offset,
        bfd_boolean align)
{
  if (align && i_shdrp->sh_addralign > 1)
    offset = ((((bfd_vma) (offset) + (i_shdrp->sh_addralign) - 1) >= (bfd_vma) (offset)) ? (((bfd_vma) (offset) + ((i_shdrp->sh_addralign) - 1)) & ~ (bfd_vma) ((i_shdrp->sh_addralign)-1)) : ~ (bfd_vma) 0);
  i_shdrp->sh_offset = offset;
  if (i_shdrp->bfd_section != 
# 4154 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             ((void *)0)
# 4154 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                 )
    i_shdrp->bfd_section->filepos = offset;
  if (i_shdrp->sh_type != 8)
    offset += i_shdrp->sh_size;
  return offset;
}





bfd_boolean
_bfd_elf_compute_section_file_positions (bfd *abfd,
      struct bfd_link_info *link_info)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  struct fake_section_arg fsargs;
  bfd_boolean failed;
  struct elf_strtab_hash *strtab = 
# 4172 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                  ((void *)0)
# 4172 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                      ;
  Elf_Internal_Shdr *shstrtab_hdr;
  bfd_boolean need_symtab;

  if (abfd->output_has_begun)
    return 1;


  if (bed->elf_backend_begin_write_processing)
    (*bed->elf_backend_begin_write_processing) (abfd, link_info);

  if (! prep_headers (abfd))
    return 0;


  (*bed->elf_backend_post_process_headers) (abfd, link_info);

  fsargs.failed = 0;
  fsargs.link_info = link_info;
  bfd_map_over_sections (abfd, elf_fake_sections, &fsargs);
  if (fsargs.failed)
    return 0;

  if (!assign_section_numbers (abfd, link_info))
    return 0;


  need_symtab = (link_info == 
# 4199 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             ((void *)0)
   
# 4200 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  && (((abfd)->symcount) > 0
       || ((abfd->flags & (0x02 | 0x40 | 0x01))
    == 0x01)));
  if (need_symtab)
    {

      int relocatable_p = ! (abfd->flags & (0x02 | 0x40));

      if (! swap_out_syms (abfd, &strtab, relocatable_p))
 return 0;
    }

  failed = 0;
  if (link_info == 
# 4213 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 4213 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      )
    {
      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);
      if (failed)
 return 0;
    }

  shstrtab_hdr = &((abfd) -> tdata.elf_obj_data)->shstrtab_hdr;

  shstrtab_hdr->sh_type = 3;
  shstrtab_hdr->sh_flags = bed->elf_strtab_flags;
  shstrtab_hdr->sh_addr = 0;

  shstrtab_hdr->sh_entsize = 0;
  shstrtab_hdr->sh_link = 0;
  shstrtab_hdr->sh_info = 0;

  shstrtab_hdr->sh_addralign = 1;

  if (!assign_file_positions_except_relocs (abfd, link_info))
    return 0;

  if (need_symtab)
    {
      file_ptr off;
      Elf_Internal_Shdr *hdr;

      off = (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos);

      hdr = & (((abfd) -> tdata.elf_obj_data) -> symtab_hdr);
      off = _bfd_elf_assign_file_position_for_section (hdr, off, 1);

      if ((((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list) != 
# 4245 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                         ((void *)0)
# 4245 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                             )
 {
   hdr = & (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list)->hdr;
   if (hdr->sh_size != 0)
     off = _bfd_elf_assign_file_position_for_section (hdr, off, 1);

 }

      hdr = &((abfd) -> tdata.elf_obj_data)->strtab_hdr;
      off = _bfd_elf_assign_file_position_for_section (hdr, off, 1);

      (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos) = off;



      if (bfd_seek (abfd, hdr->sh_offset, 
# 4260 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                         0
# 4260 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                 ) != 0
   || ! _bfd_elf_strtab_emit (abfd, strtab))
 return 0;
      _bfd_elf_strtab_free (strtab);
    }

  abfd->output_has_begun = 1;

  return 1;
}




static bfd_size_type
get_program_header_size (bfd *abfd, struct bfd_link_info *info)
{
  size_t segs;
  asection *s;
  const struct elf_backend_data *bed;



  segs = 2;

  s = bfd_get_section_by_name (abfd, ".interp");
  if (s != 
# 4286 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0) 
# 4286 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               && (s->flags & 0x002) != 0)
    {




      segs += 2;
    }

  if (bfd_get_section_by_name (abfd, ".dynamic") != 
# 4295 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                   ((void *)0)
# 4295 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                       )
    {

      ++segs;
    }

  if (info != 
# 4301 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0) 
# 4301 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  && info->relro)
    {

      ++segs;
    }

  if ((((abfd) -> tdata.elf_obj_data) -> o->eh_frame_hdr))
    {

      ++segs;
    }

  if ((((abfd) -> tdata.elf_obj_data) -> o->stack_flags))
    {

      ++segs;
    }

  for (s = abfd->sections; s != 
# 4319 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 4319 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   ; s = s->next)
    {
      if ((s->flags & 0x002) != 0
   && (strncmp ((s->name), (".note"), sizeof (".note") - 1) == 0))
 {

   ++segs;







   if (s->alignment_power == 2)
     while (s->next != 
# 4334 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
     
# 4335 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
    && s->next->alignment_power == 2
     && (s->next->flags & 0x002) != 0
     && (strncmp ((s->next->name), (".note"), sizeof (".note") - 1) == 0))
       s = s->next;
 }
    }

  for (s = abfd->sections; s != 
# 4342 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 4342 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   ; s = s->next)
    {
      if (s->flags & 0x400)
 {

   ++segs;
   break;
 }
    }

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

 if ((abfd->flags & 0x100) != 0)
   {

     unsigned int page_align_power = bfd_log2 (bed->commonpagesize);
     for (s = abfd->sections; s != 
# 4358 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                  ((void *)0)
# 4358 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                      ; s = s->next)
       if ((((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_flags) & 0x01000000)
  {
    if (((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_info
        > 4096)
      {
        _bfd_error_handler

   (dgettext ("bfd", "%B: GNU_MBIN section `%A' has invalid sh_info field: %d"),
       abfd, s, ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_info);
        continue;
      }

    if (s->alignment_power < page_align_power)
      s->alignment_power = page_align_power;
    segs ++;
  }
   }


 if (bed->elf_backend_additional_program_headers)
    {
      int a;

      a = (*bed->elf_backend_additional_program_headers) (abfd, info);
      if (a == -1)
 _bfd_abort ("/doner/binutils/binutils-7a31b38/bfd/elf.c", 4384, __PRETTY_FUNCTION__);
      segs += a;
    }

  return segs * bed->s->sizeof_phdr;
}



Elf_Internal_Phdr *
_bfd_elf_find_segment_containing_section (bfd * abfd, asection * section)
{
  struct elf_segment_map *m;
  Elf_Internal_Phdr *p;

  for (m = (((abfd) -> tdata.elf_obj_data) -> o->seg_map), p = ((abfd) -> tdata.elf_obj_data)->phdr;
       m != 
# 4400 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4400 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               ;
       m = m->next, p++)
    {
      int i;

      for (i = m->count - 1; i >= 0; i--)
 if (m->sections[i] == section)
   return p;
    }

  return 
# 4410 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
        ((void *)0)
# 4410 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
            ;
}



static struct elf_segment_map *
make_mapping (bfd *abfd,
       asection **sections,
       unsigned int from,
       unsigned int to,
       bfd_boolean phdr)
{
  struct elf_segment_map *m;
  unsigned int i;
  asection **hdrpp;
  bfd_size_type amt;

  amt = sizeof (struct elf_segment_map);
  amt += (to - from - 1) * sizeof (asection *);
  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
  if (m == 
# 4430 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 4430 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              )
    return 
# 4431 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 4431 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;
  m->next = 
# 4432 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4432 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               ;
  m->p_type = 1;
  for (i = from, hdrpp = sections + from; i < to; i++, hdrpp++)
    m->sections[i - from] = *hdrpp;
  m->count = to - from;

  if (from == 0 && phdr)
    {

      m->includes_filehdr = 1;
      m->includes_phdrs = 1;
    }

  return m;
}




struct elf_segment_map *
_bfd_elf_make_dynamic_segment (bfd *abfd, asection *dynsec)
{
  struct elf_segment_map *m;

  m = (struct elf_segment_map *) bfd_zalloc (abfd,
                                             sizeof (struct elf_segment_map));
  if (m == 
# 4458 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 4458 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              )
    return 
# 4459 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 4459 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;
  m->next = 
# 4460 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4460 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               ;
  m->p_type = 2;
  m->count = 1;
  m->sections[0] = dynsec;

  return m;
}



static bfd_boolean
elf_modify_segment_map (bfd *abfd,
   struct bfd_link_info *info,
   bfd_boolean remove_empty_load)
{
  struct elf_segment_map **m;
  const struct elf_backend_data *bed;






  m = &(((abfd) -> tdata.elf_obj_data) -> o->seg_map);
  while (*m)
    {
      unsigned int i, new_count;

      for (new_count = 0, i = 0; i < (*m)->count; i++)
 {
   if (((*m)->sections[i]->flags & 0x8000) == 0
       && (((*m)->sections[i]->flags & 0x001) != 0
    || (*m)->p_type != 1))
     {
       (*m)->sections[new_count] = (*m)->sections[i];
       new_count++;
     }
 }
      (*m)->count = new_count;

      if (remove_empty_load
   && (*m)->p_type == 1
   && (*m)->count == 0
   && !(*m)->includes_phdrs)
 *m = (*m)->next;
      else
 m = &(*m)->next;
    }

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  if (bed->elf_backend_modify_segment_map != 
# 4510 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                            ((void *)0)
# 4510 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                )
    {
      if (!(*bed->elf_backend_modify_segment_map) (abfd, info))
 return 0;
    }

  return 1;
}



bfd_boolean
_bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)
{
  unsigned int count;
  struct elf_segment_map *m;
  asection **sections = 
# 4526 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                       ((void *)0)
# 4526 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                           ;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  bfd_boolean no_user_phdrs;

  no_user_phdrs = (((abfd) -> tdata.elf_obj_data) -> o->seg_map) == 
# 4530 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                       ((void *)0)
# 4530 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                           ;

  if (info != 
# 4532 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 4532 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    info->user_phdrs = !no_user_phdrs;

  if (no_user_phdrs && ((abfd)->section_count) != 0)
    {
      asection *s;
      unsigned int i;
      struct elf_segment_map *mfirst;
      struct elf_segment_map **pm;
      asection *last_hdr;
      bfd_vma last_size;
      unsigned int phdr_index;
      bfd_vma maxpagesize;
      asection **hdrpp;
      bfd_boolean phdr_in_segment = 1;
      bfd_boolean writable;
      int tls_count = 0;
      asection *first_tls = 
# 4549 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                           ((void *)0)
# 4549 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                               ;
      asection *first_mbind = 
# 4550 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             ((void *)0)
# 4550 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                 ;
      asection *dynsec, *eh_frame_hdr;
      bfd_size_type amt;
      bfd_vma addr_mask, wrap_to = 0;
      bfd_boolean linker_created_pt_phdr_segment = 0;



      sections = (asection **) bfd_malloc2 (((abfd)->section_count),
                                            sizeof (asection *));
      if (sections == 
# 4560 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
# 4560 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                         )
 goto error_return;




      addr_mask = ((bfd_vma) 1 << (bfd_arch_bits_per_address (abfd) - 1)) - 1;
      addr_mask = (addr_mask << 1) + 1;

      i = 0;
      for (s = abfd->sections; s != 
# 4570 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                   ((void *)0)
# 4570 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                       ; s = s->next)
 {
   if ((s->flags & 0x001) != 0)
     {
       sections[i] = s;
       ++i;

       if (((s->lma + s->size) & addr_mask) < (s->lma & addr_mask))
  wrap_to = (s->lma + s->size) & addr_mask;
     }
 }
      do { if (!(i <= ((abfd)->section_count))) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",4581); } while (0);
      count = i;

      qsort (sections, (size_t) count, sizeof (asection *), elf_sort_sections);



      mfirst = 
# 4588 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 4588 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  ;
      pm = &mfirst;




      s = bfd_get_section_by_name (abfd, ".interp");
      if (s != 
# 4595 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0) 
# 4595 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   && (s->flags & 0x002) != 0)
 {
   amt = sizeof (struct elf_segment_map);
   m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
   if (m == 
# 4599 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4599 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     goto error_return;
   m->next = 
# 4601 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 4601 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                ;
   m->p_type = 6;

   m->p_flags = (1 << 2) | (1 << 0);
   m->p_flags_valid = 1;
   m->includes_phdrs = 1;
   linker_created_pt_phdr_segment = 1;
   *pm = m;
   pm = &m->next;

   amt = sizeof (struct elf_segment_map);
   m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
   if (m == 
# 4613 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4613 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     goto error_return;
   m->next = 
# 4615 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 4615 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                ;
   m->p_type = 3;
   m->count = 1;
   m->sections[0] = s;

   *pm = m;
   pm = &m->next;
 }




      last_hdr = 
# 4627 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 4627 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    ;
      last_size = 0;
      phdr_index = 0;
      maxpagesize = bed->maxpagesize;



      if (maxpagesize == 0)
 maxpagesize = 1;
      writable = 0;
      dynsec = bfd_get_section_by_name (abfd, ".dynamic");
      if (dynsec != 
# 4638 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
   
# 4639 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  && (dynsec->flags & 0x002) == 0)
 dynsec = 
# 4640 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
         ((void *)0)
# 4640 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
             ;





      if (count > 0)
 {
   bfd_size_type phdr_size = (((abfd) -> tdata.elf_obj_data) -> o->program_header_size);

   if (phdr_size == (bfd_size_type) -1)
     phdr_size = get_program_header_size (abfd, info);
   phdr_size += bed->s->sizeof_ehdr;
   if ((abfd->flags & 0x100) == 0
       || (sections[0]->lma & addr_mask) < phdr_size
       || ((sections[0]->lma & addr_mask) % maxpagesize
    < phdr_size % maxpagesize)
       || (sections[0]->lma & addr_mask & -maxpagesize) < wrap_to)
     {






       if ((abfd->flags & 0x100) != 0
    && linker_created_pt_phdr_segment)
  phdr_in_segment = 1;
       else
  phdr_in_segment = 0;
     }
 }

      for (i = 0, hdrpp = sections; i < count; i++, hdrpp++)
 {
   asection *hdr;
   bfd_boolean new_segment;

   hdr = *hdrpp;




   if (last_hdr == 
# 4683 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 4683 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      )
     {


       new_segment = 0;
     }
   else if (last_hdr->lma - last_hdr->vma != hdr->lma - hdr->vma)
     {



       new_segment = 1;
     }
   else if (hdr->lma < last_hdr->lma + last_size
     || last_hdr->lma + last_size < last_hdr->lma)
     {


       new_segment = 1;
     }





   else if ((((((bfd_vma) (last_hdr->lma + last_size) + (maxpagesize) - 1) >= (bfd_vma) (last_hdr->lma + last_size)) ? (((bfd_vma) (last_hdr->lma + last_size) + ((maxpagesize) - 1)) & ~ (bfd_vma) ((maxpagesize)-1)) : ~ (bfd_vma) 0) + maxpagesize
      > last_hdr->lma)
     && (((((bfd_vma) (last_hdr->lma + last_size) + (maxpagesize) - 1) >= (bfd_vma) (last_hdr->lma + last_size)) ? (((bfd_vma) (last_hdr->lma + last_size) + ((maxpagesize) - 1)) & ~ (bfd_vma) ((maxpagesize)-1)) : ~ (bfd_vma) 0) + maxpagesize
         <= hdr->lma))
     {


       new_segment = 1;
     }
   else if ((last_hdr->flags & (0x002 | 0x400)) == 0
     && (hdr->flags & (0x002 | 0x400)) != 0
     && ((abfd->flags & 0x100) == 0
         || (((last_hdr->lma + last_size - 1) & -maxpagesize)
      != (hdr->lma & -maxpagesize))))
     {







       new_segment = 1;
     }
   else if ((abfd->flags & 0x100) == 0)
     {



       new_segment = 0;
     }
   else if (! writable
     && (hdr->flags & 0x008) == 0
     && (((last_hdr->lma + last_size - 1) & -maxpagesize)
         != (hdr->lma & -maxpagesize)))
     {







       new_segment = 1;
     }
   else
     {

       new_segment = 0;
     }


   if (last_hdr != 
# 4760 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
       
# 4761 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && info != 
# 4761 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
       
# 4762 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && info->callbacks->override_segment_assignment != 
# 4762 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                         ((void *)0)
# 4762 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                             )
     new_segment
       = info->callbacks->override_segment_assignment (info, abfd, hdr,
             last_hdr,
             new_segment);

   if (! new_segment)
     {
       if ((hdr->flags & 0x008) == 0)
  writable = 1;
       last_hdr = hdr;

       if ((hdr->flags & (0x400 | 0x002))
    != 0x400)
  last_size = hdr->size;
       else
  last_size = 0;
       continue;
     }




   m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
   if (m == 
# 4786 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4786 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     goto error_return;

   *pm = m;
   pm = &m->next;

   if ((hdr->flags & 0x008) == 0)
     writable = 1;
   else
     writable = 0;

   last_hdr = hdr;

   if ((hdr->flags & (0x400 | 0x002)) != 0x400)
     last_size = hdr->size;
   else
     last_size = 0;
   phdr_index = i;
   phdr_in_segment = 0;
 }



      if (last_hdr != 
# 4809 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
   
# 4810 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  && (i - phdr_index != 1
       || ((last_hdr->flags & (0x400 | 0x002))
    != 0x400)))
 {
   m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);
   if (m == 
# 4815 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4815 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     goto error_return;

   *pm = m;
   pm = &m->next;
 }


      if (dynsec != 
# 4823 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 4823 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       )
 {
   m = _bfd_elf_make_dynamic_segment (abfd, dynsec);
   if (m == 
# 4826 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4826 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     goto error_return;
   *pm = m;
   pm = &m->next;
 }







      for (s = abfd->sections; s != 
# 4838 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                   ((void *)0)
# 4838 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                       ; s = s->next)
 {
   if ((s->flags & 0x002) != 0
       && (strncmp ((s->name), (".note"), sizeof (".note") - 1) == 0))
     {
       asection *s2;

       count = 1;
       amt = sizeof (struct elf_segment_map);
       if (s->alignment_power == 2)
  for (s2 = s; s2->next != 
# 4848 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          ((void *)0)
# 4848 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                              ; s2 = s2->next)
    {
      if (s2->next->alignment_power == 2
   && (s2->next->flags & 0x002) != 0
   && (strncmp ((s2->next->name), (".note"), sizeof (".note") - 1) == 0)
   && (((s2->lma + s2->size) + ((bfd_vma) 1 << (2)) - 1) & (-((bfd_vma) 1 << (2))))
      == s2->next->lma)
        count++;
      else
        break;
    }
       amt += (count - 1) * sizeof (asection *);
       m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
       if (m == 
# 4861 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 4861 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   )
  goto error_return;
       m->next = 
# 4863 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 4863 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    ;
       m->p_type = 4;
       m->count = count;
       while (count > 1)
  {
    m->sections[m->count - count--] = s;
    do { if (!((s->flags & 0x400) == 0)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",4869); } while (0);
    s = s->next;
  }
       m->sections[m->count - 1] = s;
       do { if (!((s->flags & 0x400) == 0)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",4873); } while (0);
       *pm = m;
       pm = &m->next;
     }
   if (s->flags & 0x400)
     {
       if (! tls_count)
  first_tls = s;
       tls_count++;
     }
   if (first_mbind == 
# 4883 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
       
# 4884 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && ((((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_flags) & 0x01000000) != 0)
     first_mbind = s;
 }


      if (tls_count > 0)
 {
   amt = sizeof (struct elf_segment_map);
   amt += (tls_count - 1) * sizeof (asection *);
   m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
   if (m == 
# 4894 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4894 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     goto error_return;
   m->next = 
# 4896 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 4896 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                ;
   m->p_type = 7;
   m->count = tls_count;

   m->p_flags = (1 << 2);
   m->p_flags_valid = 1;
   s = first_tls;
   for (i = 0; i < (unsigned int) tls_count; ++i)
     {
       if ((s->flags & 0x400) == 0)
  {
    _bfd_error_handler
      (dgettext ("bfd", "%B: TLS sections are not adjacent:"), abfd);
    s = first_tls;
    i = 0;
    while (i < (unsigned int) tls_count)
      {
        if ((s->flags & 0x400) != 0)
   {
     _bfd_error_handler (dgettext ("bfd", "	    TLS: %A"), s);
     i++;
   }
        else
   _bfd_error_handler (dgettext ("bfd", "	non-TLS: %A"), s);
        s = s->next;
      }
    bfd_set_error (bfd_error_bad_value);
    goto error_return;
  }
       m->sections[i] = s;
       s = s->next;
     }

   *pm = m;
   pm = &m->next;
 }

      if (first_mbind && (abfd->flags & 0x100) != 0)
 for (s = first_mbind; s != 
# 4934 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                           ((void *)0)
# 4934 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                               ; s = s->next)
   if (((((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_flags) & 0x01000000) != 0
       && (((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_info
    <= 4096))
     {

       unsigned long p_flags = (1 << 2);
       if ((s->flags & 0x008) == 0)
  p_flags |= (1 << 1);
       if ((s->flags & 0x010) != 0)
  p_flags |= (1 << 0);

       amt = sizeof (struct elf_segment_map) + sizeof (asection *);
       m = bfd_zalloc (abfd, amt);
       if (m == 
# 4948 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 4948 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   )
  goto error_return;
       m->next = 
# 4950 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 4950 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    ;
       m->p_type = ((0x60000000 + 0x474e555)
      + ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_info);
       m->count = 1;
       m->p_flags_valid = 1;
       m->sections[0] = s;
       m->p_flags = p_flags;

       *pm = m;
       pm = &m->next;
     }



      eh_frame_hdr = (((abfd) -> tdata.elf_obj_data) -> o->eh_frame_hdr);
      if (eh_frame_hdr != 
# 4965 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
   
# 4966 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  && (eh_frame_hdr->output_section->flags & 0x002) != 0)
 {
   amt = sizeof (struct elf_segment_map);
   m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
   if (m == 
# 4970 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4970 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     goto error_return;
   m->next = 
# 4972 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 4972 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                ;
   m->p_type = (0x60000000 + 0x474e550);
   m->count = 1;
   m->sections[0] = eh_frame_hdr->output_section;

   *pm = m;
   pm = &m->next;
 }

      if ((((abfd) -> tdata.elf_obj_data) -> o->stack_flags))
 {
   amt = sizeof (struct elf_segment_map);
   m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
   if (m == 
# 4985 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 4985 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     goto error_return;
   m->next = 
# 4987 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 4987 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                ;
   m->p_type = (0x60000000 + 0x474e551);
   m->p_flags = (((abfd) -> tdata.elf_obj_data) -> o->stack_flags);
   m->p_align = bed->stack_align;
   m->p_flags_valid = 1;
   m->p_align_valid = m->p_align != 0;
   if (info->stacksize > 0)
     {
       m->p_size = info->stacksize;
       m->p_size_valid = 1;
     }

   *pm = m;
   pm = &m->next;
 }

      if (info != 
# 5003 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0) 
# 5003 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      && info->relro)
 {
   for (m = mfirst; m != 
# 5005 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                        ((void *)0)
# 5005 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                            ; m = m->next)
     {
       if (m->p_type == 1
    && m->count != 0
    && m->sections[0]->vma >= info->relro_start
    && m->sections[0]->vma < info->relro_end)
  {
    i = m->count;
    while (--i != (unsigned) -1)
      if ((m->sections[i]->flags & (0x002 | 0x100))
   == (0x002 | 0x100))
        break;

    if (i != (unsigned) -1)
      break;
  }
     }


   if (m != 
# 5024 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 5024 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     {
       amt = sizeof (struct elf_segment_map);
       m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
       if (m == 
# 5028 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 5028 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   )
  goto error_return;
       m->next = 
# 5030 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 5030 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    ;
       m->p_type = (0x60000000 + 0x474e552);
       *pm = m;
       pm = &m->next;
     }
 }

      free (sections);
      (((abfd) -> tdata.elf_obj_data) -> o->seg_map) = mfirst;
    }

  if (!elf_modify_segment_map (abfd, info, no_user_phdrs))
    return 0;

  for (count = 0, m = (((abfd) -> tdata.elf_obj_data) -> o->seg_map); m != 
# 5044 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                              ((void *)0)
# 5044 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                  ; m = m->next)
    ++count;
  (((abfd) -> tdata.elf_obj_data) -> o->program_header_size) = count * bed->s->sizeof_phdr;

  return 1;

 error_return:
  if (sections != 
# 5051 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 5051 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
    free (sections);
  return 0;
}



static int
elf_sort_sections (const void *arg1, const void *arg2)
{
  const asection *sec1 = *(const asection **) arg1;
  const asection *sec2 = *(const asection **) arg2;
  bfd_size_type size1, size2;



  if (sec1->lma < sec2->lma)
    return -1;
  else if (sec1->lma > sec2->lma)
    return 1;



  if (sec1->vma < sec2->vma)
    return -1;
  else if (sec1->vma > sec2->vma)
    return 1;





  if ((((sec1)->flags & (0x002 | 0x400)) == 0))
    {
      if ((((sec2)->flags & (0x002 | 0x400)) == 0))
 {


   if (sec1->target_index - sec2->target_index != 0)
     return sec1->target_index - sec2->target_index;
 }
      else
 return 1;
    }
  else if ((((sec2)->flags & (0x002 | 0x400)) == 0))
    return -1;






  size1 = (sec1->flags & 0x002) ? sec1->size : 0;
  size2 = (sec2->flags & 0x002) ? sec2->size : 0;

  if (size1 < size2)
    return -1;
  if (size1 > size2)
    return 1;

  return sec1->target_index - sec2->target_index;
}
# 5137 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
static file_ptr
vma_page_aligned_bias (bfd_vma vma, ufile_ptr off, bfd_vma maxpagesize)
{

  if (maxpagesize == 0)
    maxpagesize = 1;
  return ((vma - off) % maxpagesize);
}

static void
print_segment_map (const struct elf_segment_map *m)
{
  unsigned int j;
  const char *pt = get_segment_type (m->p_type);
  char buf[32];

  if (pt == 
# 5153 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 5153 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
    {
      if (m->p_type >= 0x70000000 && m->p_type <= 0x7FFFFFFF)
 sprintf (buf, "LOPROC+%7.7x",
   (unsigned int) (m->p_type - 0x70000000));
      else if (m->p_type >= 0x60000000 && m->p_type <= 0x6fffffff)
 sprintf (buf, "LOOS+%7.7x",
   (unsigned int) (m->p_type - 0x60000000));
      else
 snprintf (buf, sizeof (buf), "%8.8x",
    (unsigned int) m->p_type);
      pt = buf;
    }
  fflush (
# 5166 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
         stdout
# 5166 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               );
  fprintf (
# 5167 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          stderr
# 5167 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                , "%s:", pt);
  for (j = 0; j < m->count; j++)
    fprintf (
# 5169 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            stderr
# 5169 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  , " %s", m->sections [j]->name);
  putc ('\n',
# 5170 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            stderr
# 5170 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  );
  fflush (
# 5171 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
         stderr
# 5171 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               );
}

static bfd_boolean
write_zeros (bfd *abfd, file_ptr pos, bfd_size_type len)
{
  void *buf;
  bfd_boolean ret;

  if (bfd_seek (abfd, pos, 
# 5180 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          0
# 5180 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  ) != 0)
    return 0;
  buf = bfd_zmalloc (len);
  if (buf == 
# 5183 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 5183 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
    return 0;
  ret = bfd_bwrite (buf, len, abfd) == len;
  free (buf);
  return ret;
}





static bfd_boolean
assign_file_positions_for_load_sections (bfd *abfd,
      struct bfd_link_info *link_info)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  struct elf_segment_map *m;
  Elf_Internal_Phdr *phdrs;
  Elf_Internal_Phdr *p;
  file_ptr off;
  bfd_size_type maxpagesize;
  unsigned int pt_load_count = 0;
  unsigned int alloc;
  unsigned int i, j;
  bfd_vma header_pad = 0;

  if (link_info == 
# 5209 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
      
# 5210 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     && !_bfd_elf_map_sections_to_segments (abfd, link_info))
    return 0;

  alloc = 0;
  for (m = (((abfd) -> tdata.elf_obj_data) -> o->seg_map); m != 
# 5214 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                   ((void *)0)
# 5214 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                       ; m = m->next)
    {
      ++alloc;
      if (m->header_size)
 header_pad = m->header_size;
    }

  if (alloc)
    {
      (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phoff = bed->s->sizeof_ehdr;
      (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phentsize = bed->s->sizeof_phdr;
    }
  else
    {

      (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phoff = 0;
      (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phentsize = 0;
    }

  (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum = alloc;

  if ((((abfd) -> tdata.elf_obj_data) -> o->program_header_size) == (bfd_size_type) -1)
    (((abfd) -> tdata.elf_obj_data) -> o->program_header_size) = alloc * bed->s->sizeof_phdr;
  else
    do { if (!((((abfd) -> tdata.elf_obj_data) -> o->program_header_size) >= alloc * bed->s->sizeof_phdr)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",5238); } while (0)
                                 ;

  if (alloc == 0)
    {
      (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos) = bed->s->sizeof_ehdr;
      return 1;
    }
# 5256 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  do { if (!((((abfd) -> tdata.elf_obj_data) -> o->program_header_size) % bed->s->sizeof_phdr == 0)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",5256); } while (0)
            ;
  phdrs = (Elf_Internal_Phdr *)
     bfd_zalloc2 (abfd,
                  ((((abfd) -> tdata.elf_obj_data) -> o->program_header_size) / bed->s->sizeof_phdr),
                  sizeof (Elf_Internal_Phdr));
  ((abfd) -> tdata.elf_obj_data)->phdr = phdrs;
  if (phdrs == 
# 5263 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 5263 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  )
    return 0;

  maxpagesize = 1;
  if ((abfd->flags & 0x100) != 0)
    maxpagesize = bed->maxpagesize;

  off = bed->s->sizeof_ehdr;
  off += alloc * bed->s->sizeof_phdr;
  if (header_pad < (bfd_vma) off)
    header_pad = 0;
  else
    header_pad -= off;
  off += header_pad;

  for (m = (((abfd) -> tdata.elf_obj_data) -> o->seg_map), p = phdrs, j = 0;
       m != 
# 5279 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 5279 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               ;
       m = m->next, p++, j++)
    {
      asection **secpp;
      bfd_vma off_adjust;
      bfd_boolean no_contents;






      if (m->count > 1
   && !((((abfd) -> tdata.elf_obj_data) -> elf_header)->e_type == 4
        && m->p_type == 4))
 qsort (m->sections, (size_t) m->count, sizeof (asection *),
        elf_sort_sections);






      p->p_type = m->p_type;
      p->p_flags = m->p_flags;

      if (m->count == 0)
 p->p_vaddr = 0;
      else
 p->p_vaddr = m->sections[0]->vma - m->p_vaddr_offset;

      if (m->p_paddr_valid)
 p->p_paddr = m->p_paddr;
      else if (m->count == 0)
 p->p_paddr = 0;
      else
 p->p_paddr = m->sections[0]->lma - m->p_vaddr_offset;

      if (p->p_type == 1
   && (abfd->flags & 0x100) != 0)
 {
# 5328 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   if (m->p_align_valid)
     maxpagesize = m->p_align;

   p->p_align = maxpagesize;
   pt_load_count += 1;
 }
      else if (m->p_align_valid)
 p->p_align = m->p_align;
      else if (m->count == 0)
 p->p_align = 1 << bed->s->log_file_align;
      else
 p->p_align = 0;

      no_contents = 0;
      off_adjust = 0;
      if (p->p_type == 1
   && m->count > 0)
 {
   bfd_size_type align;
   unsigned int align_power = 0;

   if (m->p_align_valid)
     align = p->p_align;
   else
     {
       for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
  {
    unsigned int secalign;

    secalign = ((void) abfd, (*secpp)->alignment_power);
    if (secalign > align_power)
      align_power = secalign;
  }
       align = (bfd_size_type) 1 << align_power;
       if (align < maxpagesize)
  align = maxpagesize;
     }

   for (i = 0; i < m->count; i++)
     if ((m->sections[i]->flags & (0x002 | 0x100)) == 0)



       (((struct bfd_elf_section_data*)(m->sections[i])->used_by_bfd)->this_hdr.sh_type) = 8;



   no_contents = 1;
   for (i = 0; i < m->count; i++)
     if ((((struct bfd_elf_section_data*)(m->sections[i])->used_by_bfd)->this_hdr.sh_type) != 8)
       {
  no_contents = 0;
  break;
       }

   off_adjust = vma_page_aligned_bias (p->p_vaddr, off, align);




   if (pt_load_count > 1
       && bed->no_page_alias
       && (off & (maxpagesize - 1)) != 0
       && (off & -maxpagesize) == ((off + off_adjust) & -maxpagesize))
     off_adjust += maxpagesize;
   off += off_adjust;
   if (no_contents)
     {
# 5404 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     }
   else
     off_adjust = 0;
 }


      else if (p->p_type == 2
        && m->count > 1
        && strcmp (m->sections[0]->name, ".dynamic") != 0)
 {
   _bfd_error_handler
     (dgettext ("bfd", "%B: The first section in the PT_DYNAMIC segment" " is not the .dynamic section")
                                       ,
      abfd);
   bfd_set_error (bfd_error_bad_value);
   return 0;
 }

      else if (p->p_type == 4)
 for (i = 0; i < m->count; i++)
   (((struct bfd_elf_section_data*)(m->sections[i])->used_by_bfd)->this_hdr.sh_type) = 7;

      p->p_offset = 0;
      p->p_filesz = 0;
      p->p_memsz = 0;

      if (m->includes_filehdr)
 {
   if (!m->p_flags_valid)
     p->p_flags |= (1 << 2);
   p->p_filesz = bed->s->sizeof_ehdr;
   p->p_memsz = bed->s->sizeof_ehdr;
   if (m->count > 0)
     {
       if (p->p_vaddr < (bfd_vma) off
    || (!m->p_paddr_valid
        && p->p_paddr < (bfd_vma) off))
  {
    _bfd_error_handler
      (dgettext ("bfd", "%B: Not enough room for program headers," " try linking with -N")
                                ,
       abfd);
    bfd_set_error (bfd_error_bad_value);
    return 0;
  }

       p->p_vaddr -= off;
       if (!m->p_paddr_valid)
  p->p_paddr -= off;
     }
 }

      if (m->includes_phdrs)
 {
   if (!m->p_flags_valid)
     p->p_flags |= (1 << 2);

   if (!m->includes_filehdr)
     {
       p->p_offset = bed->s->sizeof_ehdr;

       if (m->count > 0)
  {
    p->p_vaddr -= off - p->p_offset;
    if (!m->p_paddr_valid)
      p->p_paddr -= off - p->p_offset;
  }
     }

   p->p_filesz += alloc * bed->s->sizeof_phdr;
   p->p_memsz += alloc * bed->s->sizeof_phdr;
   if (m->count)
     {
       p->p_filesz += header_pad;
       p->p_memsz += header_pad;
     }
 }

      if (p->p_type == 1
   || (p->p_type == 4 && ((abfd)->format) == bfd_core))
 {
   if (!m->includes_filehdr && !m->includes_phdrs)
     p->p_offset = off;
   else
     {
       file_ptr adjust;

       adjust = off - (p->p_offset + p->p_filesz);
       if (!no_contents)
  p->p_filesz += adjust;
       p->p_memsz += adjust;
     }
 }






      for (i = 0, secpp = m->sections; i < m->count; i++, secpp++)
 {
   asection *sec;
   bfd_size_type align;
   Elf_Internal_Shdr *this_hdr;

   sec = *secpp;
   this_hdr = &((struct bfd_elf_section_data*)(sec)->used_by_bfd)->this_hdr;
   align = (bfd_size_type) 1 << ((void) abfd, (sec)->alignment_power);

   if ((p->p_type == 1
        || p->p_type == 7)
       && (this_hdr->sh_type != 8
    || ((this_hdr->sh_flags & (1 << 1)) != 0
        && ((this_hdr->sh_flags & (1 << 10)) == 0
     || p->p_type == 7))))
     {
       bfd_vma p_start = p->p_paddr;
       bfd_vma p_end = p_start + p->p_memsz;
       bfd_vma s_start = sec->lma;
       bfd_vma adjust = s_start - p_end;

       if (adjust != 0
    && (s_start < p_end
        || p_end < p_start))
  {
    _bfd_error_handler

      (dgettext ("bfd", "%B: section %A lma %#Lx adjusted to %#Lx"),
       abfd, sec, s_start, p_end);
    adjust = 0;
    sec->lma = p_end;
  }
       p->p_memsz += adjust;

       if (this_hdr->sh_type != 8)
  {
    if (p->p_filesz + adjust < p->p_memsz)
      {



        adjust = p->p_memsz - p->p_filesz;
        if (!write_zeros (abfd, off, adjust))
   return 0;
      }
    off += adjust;
    p->p_filesz += adjust;
  }
     }

   if (p->p_type == 4 && ((abfd)->format) == bfd_core)
     {


       if (i == 0)
  {
    this_hdr->sh_offset = sec->filepos = off;
    off += this_hdr->sh_size;
    p->p_filesz = this_hdr->sh_size;
    p->p_memsz = 0;
    p->p_align = 1;
  }
       else
  {

    sec->filepos = 0;
    sec->size = 0;
    sec->flags = 0;
    continue;
  }
     }
   else
     {
       if (p->p_type == 1)
  {
    this_hdr->sh_offset = sec->filepos = off;
    if (this_hdr->sh_type != 8)
      off += this_hdr->sh_size;
  }
       else if (this_hdr->sh_type == 8
         && (this_hdr->sh_flags & (1 << 10)) != 0
         && this_hdr->sh_offset == 0)
  {







    bfd_vma adjust = vma_page_aligned_bias (this_hdr->sh_addr,
         off, align);
    this_hdr->sh_offset = sec->filepos = off + adjust;
  }

       if (this_hdr->sh_type != 8)
  {
    p->p_filesz += this_hdr->sh_size;



    if ((this_hdr->sh_flags & (1 << 1)) != 0)
      p->p_memsz += this_hdr->sh_size;
  }
       else if ((this_hdr->sh_flags & (1 << 1)) != 0)
  {
    if (p->p_type == 7)
      p->p_memsz += this_hdr->sh_size;



    else if ((this_hdr->sh_flags & (1 << 10)) == 0)
      p->p_memsz += this_hdr->sh_size;
  }

       if (align > p->p_align
    && !m->p_align_valid
    && (p->p_type != 1
        || (abfd->flags & 0x100) == 0))
  p->p_align = align;
     }

   if (!m->p_flags_valid)
     {
       p->p_flags |= (1 << 2);
       if ((this_hdr->sh_flags & (1 << 2)) != 0)
  p->p_flags |= (1 << 0);
       if ((this_hdr->sh_flags & (1 << 0)) != 0)
  p->p_flags |= (1 << 1);
     }
 }

      off -= off_adjust;



      if (p->p_type == 1 && ((abfd)->format) != bfd_core)
 {
   bfd_boolean check_vma = 1;

   for (i = 1; i < m->count; i++)
     if (m->sections[i]->vma == m->sections[i - 1]->vma
  && ((((&(((struct bfd_elf_section_data*)(m->sections[i])->used_by_bfd) ->this_hdr))->sh_flags & (1 << 10)) != 0 && (&(((struct bfd_elf_section_data*)(m->sections[i])->used_by_bfd) ->this_hdr))->sh_type == 8 && (p)->p_type != 7) ? 0 : (&(((struct bfd_elf_section_data*)(m->sections[i])->used_by_bfd) ->this_hdr))->sh_size)
                           != 0
  && ((((&(((struct bfd_elf_section_data*)(m->sections[i - 1])->used_by_bfd) ->this_hdr))->sh_flags & (1 << 10)) != 0 && (&(((struct bfd_elf_section_data*)(m->sections[i - 1])->used_by_bfd) ->this_hdr))->sh_type == 8 && (p)->p_type != 7) ? 0 : (&(((struct bfd_elf_section_data*)(m->sections[i - 1])->used_by_bfd) ->this_hdr))->sh_size)
                           != 0)
       {

  check_vma = 0;
  break;
       }

   for (i = 0; i < m->count; i++)
     {
       Elf_Internal_Shdr *this_hdr;
       asection *sec;

       sec = m->sections[i];
       this_hdr = &(((struct bfd_elf_section_data*)(sec)->used_by_bfd)->this_hdr);
       if (!(( ((((this_hdr)->sh_flags & (1 << 10)) != 0) && ((p)->p_type == 7 || (p)->p_type == (0x60000000 + 0x474e552) || (p)->p_type == 1)) || (((this_hdr)->sh_flags & (1 << 10)) == 0 && (p)->p_type != 7 && (p)->p_type != 6)) && !(((this_hdr)->sh_flags & (1 << 1)) == 0 && ((p)->p_type == 1 || (p)->p_type == 2 || (p)->p_type == (0x60000000 + 0x474e550) || (p)->p_type == (0x60000000 + 0x474e552) || (p)->p_type == (0x60000000 + 0x474e551))) && ((this_hdr)->sh_type == 8 || ((bfd_vma) (this_hdr)->sh_offset >= (p)->p_offset && (!(0) || ((this_hdr)->sh_offset - (p)->p_offset <= (p)->p_filesz - 1)) && (((this_hdr)->sh_offset - (p)->p_offset + ((((this_hdr)->sh_flags & (1 << 10)) != 0 && (this_hdr)->sh_type == 8 && (p)->p_type != 7) ? 0 : (this_hdr)->sh_size)) <= (p)->p_filesz))) && (!(check_vma) || ((this_hdr)->sh_flags & (1 << 1)) == 0 || ((this_hdr)->sh_addr >= (p)->p_vaddr && (!(0) || ((this_hdr)->sh_addr - (p)->p_vaddr <= (p)->p_memsz - 1)) && (((this_hdr)->sh_addr - (p)->p_vaddr + ((((this_hdr)->sh_flags & (1 << 10)) != 0 && (this_hdr)->sh_type == 8 && (p)->p_type != 7) ? 0 : (this_hdr)->sh_size)) <= (p)->p_memsz))) && ((p)->p_type != 2 || (this_hdr)->sh_size != 0 || (p)->p_memsz == 0 || (((this_hdr)->sh_type == 8 || ((bfd_vma) (this_hdr)->sh_offset > (p)->p_offset && ((this_hdr)->sh_offset - (p)->p_offset < (p)->p_filesz))) && (((this_hdr)->sh_flags & (1 << 1)) == 0 || ((this_hdr)->sh_addr > (p)->p_vaddr && ((this_hdr)->sh_addr - (p)->p_vaddr < (p)->p_memsz))))))
    && !(((this_hdr)->sh_flags & (1 << 10)) != 0 && (this_hdr)->sh_type == 8 && (p)->p_type != 7))
  {
    _bfd_error_handler

      (dgettext ("bfd", "%B: section `%A' can't be allocated in segment %d"),
       abfd, sec, j);
    print_segment_map (m);
  }
     }
 }
    }

  (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos) = off;
  return 1;
}



static bfd_boolean
assign_file_positions_for_non_load_sections (bfd *abfd,
          struct bfd_link_info *link_info)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  Elf_Internal_Shdr **i_shdrpp;
  Elf_Internal_Shdr **hdrpp, **end_hdrpp;
  Elf_Internal_Phdr *phdrs;
  Elf_Internal_Phdr *p;
  struct elf_segment_map *m;
  struct elf_segment_map *hdrs_segment;
  bfd_vma filehdr_vaddr, filehdr_paddr;
  bfd_vma phdrs_vaddr, phdrs_paddr;
  file_ptr off;
  unsigned int count;

  i_shdrpp = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr);
  end_hdrpp = i_shdrpp + (((abfd) -> tdata.elf_obj_data) -> num_elf_sections);
  off = (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos);
  for (hdrpp = i_shdrpp + 1; hdrpp < end_hdrpp; hdrpp++)
    {
      Elf_Internal_Shdr *hdr;

      hdr = *hdrpp;
      if (hdr->bfd_section != 
# 5706 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             ((void *)0)
   
# 5707 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  && (hdr->bfd_section->filepos != 0
       || (hdr->sh_type == 8
    && hdr->contents == 
# 5709 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                       ((void *)0)
# 5709 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                           )))
 do { if (!(hdr->sh_offset == hdr->bfd_section->filepos)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",5710); } while (0);
      else if ((hdr->sh_flags & (1 << 1)) != 0)
 {
   if (hdr->sh_size != 0)
     _bfd_error_handler

       (dgettext ("bfd", "%B: warning: allocated section `%s' not in segment"),
        abfd,
        (hdr->bfd_section == 
# 5718 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                            ((void *)0)
  
# 5719 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
 ? "*unknown*"
  : hdr->bfd_section->name));

   if ((abfd->flags & 0x100) != 0 && hdr->sh_size != 0)
     off += vma_page_aligned_bias (hdr->sh_addr, off,
       bed->maxpagesize);
   else
     off += vma_page_aligned_bias (hdr->sh_addr, off,
       hdr->sh_addralign);
   off = _bfd_elf_assign_file_position_for_section (hdr, off,
          0);
 }
      else if (((hdr->sh_type == 9 || hdr->sh_type == 4)
  && hdr->bfd_section == 
# 5732 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                        ((void *)0)
# 5732 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                            )
        || (hdr->bfd_section != 
# 5733 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
     
# 5734 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
    && (hdr->bfd_section->flags & 0x8000000))

        || hdr == i_shdrpp[(((abfd) -> tdata.elf_obj_data) -> symtab_section)]
        || ((((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list) != 
# 5737 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                           ((void *)0)
     
# 5738 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
    && hdr == i_shdrpp[(((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list)->ndx])
        || hdr == i_shdrpp[(((abfd) -> tdata.elf_obj_data) -> o->strtab_section)]
        || hdr == i_shdrpp[(((abfd) -> tdata.elf_obj_data) -> o->shstrtab_section)])
 hdr->sh_offset = -1;
      else
 off = _bfd_elf_assign_file_position_for_section (hdr, off, 1);
    }



  count = 0;
  filehdr_vaddr = 0;
  filehdr_paddr = 0;
  phdrs_vaddr = bed->maxpagesize + bed->s->sizeof_ehdr;
  phdrs_paddr = 0;
  hdrs_segment = 
# 5753 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 5753 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    ;
  phdrs = ((abfd) -> tdata.elf_obj_data)->phdr;
  for (m = (((abfd) -> tdata.elf_obj_data) -> o->seg_map), p = phdrs; m != 
# 5755 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                              ((void *)0)
# 5755 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                  ; m = m->next, p++)
    {
      ++count;
      if (p->p_type != 1)
 continue;

      if (m->includes_filehdr)
 {
   filehdr_vaddr = p->p_vaddr;
   filehdr_paddr = p->p_paddr;
 }
      if (m->includes_phdrs)
 {
   phdrs_vaddr = p->p_vaddr;
   phdrs_paddr = p->p_paddr;
   if (m->includes_filehdr)
     {
       hdrs_segment = m;
       phdrs_vaddr += bed->s->sizeof_ehdr;
       phdrs_paddr += bed->s->sizeof_ehdr;
     }
 }
    }

  if (hdrs_segment != 
# 5779 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0) 
# 5779 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          && link_info != 
# 5779 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                          ((void *)0)
# 5779 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                              )
    {




      struct elf_link_hash_entry *hash
 = ((struct elf_link_hash_entry *) bfd_link_hash_lookup (&(((struct elf_link_hash_table *) ((link_info)->hash)))->root, ("__ehdr_start"), (0), (0), (1)))
                       ;

      if (hash != 
# 5789 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
   
# 5790 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  && (hash->root.type == bfd_link_hash_new
       || hash->root.type == bfd_link_hash_undefined
       || hash->root.type == bfd_link_hash_undefweak
       || hash->root.type == bfd_link_hash_common))
 {
   asection *s = 
# 5795 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 5795 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    ;
   if (hdrs_segment->count != 0)

     s = hdrs_segment->sections[0];
   else

     for (m = (((abfd) -> tdata.elf_obj_data) -> o->seg_map); m != 
# 5801 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                      ((void *)0)
# 5801 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                          ; m = m->next)
       if (m->count != 0)
  {
    s = m->sections[0];
    break;
  }

   if (s != 
# 5808 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 5808 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
     {
       hash->root.u.def.value = filehdr_vaddr - s->vma;
       hash->root.u.def.section = s;
     }
   else
     {
       hash->root.u.def.value = filehdr_vaddr;
       hash->root.u.def.section = (&_bfd_std_section[2]);
     }

   hash->root.type = bfd_link_hash_defined;
   hash->def_regular = 1;
   hash->non_elf = 0;
 }
    }

  for (m = (((abfd) -> tdata.elf_obj_data) -> o->seg_map), p = phdrs; m != 
# 5825 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                              ((void *)0)
# 5825 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                  ; m = m->next, p++)
    {
      if (p->p_type == (0x60000000 + 0x474e552))
 {
   const Elf_Internal_Phdr *lp;
   struct elf_segment_map *lm;

   if (link_info != 
# 5832 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
# 5832 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                       )
     {


       for (lm = (((abfd) -> tdata.elf_obj_data) -> o->seg_map), lp = phdrs;
     lm != 
# 5837 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 5837 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;
     lm = lm->next, lp++)
  {
    if (lp->p_type == 1
        && lp->p_vaddr < link_info->relro_end
        && lm->count != 0
        && lm->sections[0]->vma >= link_info->relro_start)
      break;
  }

       do { if (!(lm != 
# 5847 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
      ((void *)0)
# 5847 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",5847); } while (0);
     }
   else
     {


       for (lp = phdrs; lp < phdrs + count; ++lp)
  {
    if (lp->p_type == 1
        && lp->p_paddr == p->p_paddr)
      break;
  }
     }

   if (lp < phdrs + count)
     {
       p->p_vaddr = lp->p_vaddr;
       p->p_paddr = lp->p_paddr;
       p->p_offset = lp->p_offset;
       if (link_info != 
# 5866 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                       ((void *)0)
# 5866 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                           )
  p->p_filesz = link_info->relro_end - lp->p_vaddr;
       else if (m->p_size_valid)
  p->p_filesz = m->p_size;
       else
  _bfd_abort ("/doner/binutils/binutils-7a31b38/bfd/elf.c", 5871, __PRETTY_FUNCTION__);
       p->p_memsz = p->p_filesz;





       if (!m->p_align_valid)
  p->p_align = 1;
       if (!m->p_flags_valid)
  p->p_flags = (1 << 2);
     }
   else
     {
       memset (p, 0, sizeof *p);
       p->p_type = 0;
     }
 }
      else if (p->p_type == (0x60000000 + 0x474e551))
 {
   if (m->p_size_valid)
     p->p_memsz = m->p_size;
 }
      else if (m->count != 0)
 {
   unsigned int i;

   if (p->p_type != 1
       && (p->p_type != 4
    || ((abfd)->format) != bfd_core))
     {


       if (p->p_type == 6)
  {
    m->count = 0;
    continue;
  }

       if (m->includes_filehdr || m->includes_phdrs)
  {

    _bfd_error_handler
      (dgettext ("bfd", "%B: error: non-load segment %d includes file header " "and/or program header")
                                 ,
       abfd, (int) (p - phdrs));
    return 0;
  }

       p->p_filesz = 0;
       p->p_offset = m->sections[0]->filepos;
       for (i = m->count; i-- != 0;)
  {
    asection *sect = m->sections[i];
    Elf_Internal_Shdr *hdr = &((struct bfd_elf_section_data*)(sect)->used_by_bfd)->this_hdr;
    if (hdr->sh_type != 8)
      {
        p->p_filesz = (sect->filepos - m->sections[0]->filepos
         + hdr->sh_size);
        break;
      }
  }
     }
 }
      else if (m->includes_filehdr)
 {
   p->p_vaddr = filehdr_vaddr;
   if (! m->p_paddr_valid)
     p->p_paddr = filehdr_paddr;
 }
      else if (m->includes_phdrs)
 {
   p->p_vaddr = phdrs_vaddr;
   if (! m->p_paddr_valid)
     p->p_paddr = phdrs_paddr;
 }
    }

  (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos) = off;

  return 1;
}

static elf_section_list *
find_section_in_list (unsigned int i, elf_section_list * list)
{
  for (;list != 
# 5957 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 5957 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   ; list = list->next)
    if (list->ndx == i)
      break;
  return list;
}
# 5977 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
static bfd_boolean
assign_file_positions_except_relocs (bfd *abfd,
         struct bfd_link_info *link_info)
{
  struct elf_obj_tdata *tdata = ((abfd) -> tdata.elf_obj_data);
  Elf_Internal_Ehdr *i_ehdrp = (((abfd) -> tdata.elf_obj_data) -> elf_header);
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  if ((abfd->flags & (0x02 | 0x40)) == 0
      && ((abfd)->format) != bfd_core)
    {
      Elf_Internal_Shdr ** const i_shdrpp = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr);
      unsigned int num_sec = (((abfd) -> tdata.elf_obj_data) -> num_elf_sections);
      Elf_Internal_Shdr **hdrpp;
      unsigned int i;
      file_ptr off;


      off = i_ehdrp->e_ehsize;




      for (i = 1, hdrpp = i_shdrpp + 1; i < num_sec; i++, hdrpp++)
 {
   Elf_Internal_Shdr *hdr;

   hdr = *hdrpp;
   if (((hdr->sh_type == 9 || hdr->sh_type == 4)
        && hdr->bfd_section == 
# 6006 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                              ((void *)0)
# 6006 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  )
       || (hdr->bfd_section != 
# 6007 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                              ((void *)0)
    
# 6008 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   && (hdr->bfd_section->flags & 0x8000000))

       || i == (((abfd) -> tdata.elf_obj_data) -> symtab_section)
       || ((((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list) != 
# 6011 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                          ((void *)0)
    
# 6012 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   && hdr == i_shdrpp[(((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list)->ndx])
       || i == (((abfd) -> tdata.elf_obj_data) -> o->strtab_section)
       || i == (((abfd) -> tdata.elf_obj_data) -> o->shstrtab_section))
     {
       hdr->sh_offset = -1;
     }
   else
     off = _bfd_elf_assign_file_position_for_section (hdr, off, 1);
 }

      (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos) = off;
    }
  else
    {
      unsigned int alloc;



      if (!assign_file_positions_for_load_sections (abfd, link_info))
 return 0;


      if (!assign_file_positions_for_non_load_sections (abfd, link_info))
 return 0;

      if (bed->elf_backend_modify_program_headers != 
# 6037 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                    ((void *)0)
# 6037 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                        )
 {
   if (!(*bed->elf_backend_modify_program_headers) (abfd, link_info))
     return 0;
 }


      if (link_info != 
# 6044 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0) 
# 6044 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                           && ((link_info)->type == type_pie))
 {
   unsigned int num_segments = (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum;
   Elf_Internal_Phdr *segment = ((abfd) -> tdata.elf_obj_data)->phdr;
   Elf_Internal_Phdr *end_segment = &segment[num_segments];


   bfd_vma p_vaddr = (bfd_vma) -1;
   for (; segment < end_segment; segment++)
     if (segment->p_type == 1 && p_vaddr > segment->p_vaddr)
       p_vaddr = segment->p_vaddr;



   if (p_vaddr)
     i_ehdrp->e_type = 2;
 }


      alloc = (((abfd) -> tdata.elf_obj_data) -> o->program_header_size) / bed->s->sizeof_phdr;


      if (alloc == 0)
 return 1;
# 6080 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      if (alloc > 1
   && tdata->phdr[0].p_type == 6
   && ! bed->elf_backend_allow_non_load_phdr (abfd, tdata->phdr, alloc)
   && tdata->phdr[1].p_type == 1
   && (tdata->phdr[1].p_vaddr > tdata->phdr[0].p_vaddr
       || (tdata->phdr[1].p_vaddr + tdata->phdr[1].p_memsz)
       < (tdata->phdr[0].p_vaddr + tdata->phdr[0].p_memsz)))
 {



   _bfd_error_handler (dgettext ("bfd", "%B: error: PHDR segment not covered by LOAD segment")
                                                     ,
         abfd);
   return 0;
 }

      if (bfd_seek (abfd, (bfd_signed_vma) bed->s->sizeof_ehdr, 
# 6097 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                               0
# 6097 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                       ) != 0
   || bed->s->write_out_phdrs (abfd, tdata->phdr, alloc) != 0)
 return 0;
    }

  return 1;
}

static bfd_boolean
prep_headers (bfd *abfd)
{
  Elf_Internal_Ehdr *i_ehdrp;
  struct elf_strtab_hash *shstrtab;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  i_ehdrp = (((abfd) -> tdata.elf_obj_data) -> elf_header);

  shstrtab = _bfd_elf_strtab_init ();
  if (shstrtab == 
# 6115 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 6115 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
    return 0;

  (((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr) = shstrtab;

  i_ehdrp->e_ident[0] = 0x7F;
  i_ehdrp->e_ident[1] = 'E';
  i_ehdrp->e_ident[2] = 'L';
  i_ehdrp->e_ident[3] = 'F';

  i_ehdrp->e_ident[4] = bed->s->elfclass;
  i_ehdrp->e_ident[5] =
    ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG) ? 2 : 1;
  i_ehdrp->e_ident[6] = bed->s->ev_current;

  if ((abfd->flags & 0x40) != 0)
    i_ehdrp->e_type = 3;
  else if ((abfd->flags & 0x02) != 0)
    i_ehdrp->e_type = 2;
  else if (((abfd)->format) == bfd_core)
    i_ehdrp->e_type = 4;
  else
    i_ehdrp->e_type = 1;

  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_unknown:
      i_ehdrp->e_machine = 0;
      break;
# 6153 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
    default:
      i_ehdrp->e_machine = bed->elf_machine_code;
    }

  i_ehdrp->e_version = bed->s->ev_current;
  i_ehdrp->e_ehsize = bed->s->sizeof_ehdr;


  i_ehdrp->e_phoff = 0;
  i_ehdrp->e_phentsize = 0;
  i_ehdrp->e_phnum = 0;


  i_ehdrp->e_entry = ((abfd)->start_address);
  i_ehdrp->e_shentsize = bed->s->sizeof_shdr;


  if (abfd->flags & 0x02)

    ;
  else
    {
      i_ehdrp->e_phentsize = 0;
      i_ehdrp->e_phoff = 0;
    }

  ((abfd) -> tdata.elf_obj_data)->symtab_hdr.sh_name =
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".symtab", 0);
  ((abfd) -> tdata.elf_obj_data)->strtab_hdr.sh_name =
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".strtab", 0);
  ((abfd) -> tdata.elf_obj_data)->shstrtab_hdr.sh_name =
    (unsigned int) _bfd_elf_strtab_add (shstrtab, ".shstrtab", 0);
  if (((abfd) -> tdata.elf_obj_data)->symtab_hdr.sh_name == (unsigned int) -1
      || ((abfd) -> tdata.elf_obj_data)->strtab_hdr.sh_name == (unsigned int) -1
      || ((abfd) -> tdata.elf_obj_data)->shstrtab_hdr.sh_name == (unsigned int) -1)
    return 0;

  return 1;
}




static bfd_boolean
_bfd_elf_assign_file_positions_for_non_load (bfd *abfd)
{
  file_ptr off;
  Elf_Internal_Shdr **shdrpp, **end_shdrpp;
  Elf_Internal_Shdr *shdrp;
  Elf_Internal_Ehdr *i_ehdrp;
  const struct elf_backend_data *bed;

  off = (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos);

  shdrpp = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr);
  end_shdrpp = shdrpp + (((abfd) -> tdata.elf_obj_data) -> num_elf_sections);
  for (shdrpp++; shdrpp < end_shdrpp; shdrpp++)
    {
      shdrp = *shdrpp;
      if (shdrp->sh_offset == -1)
 {
   asection *sec = shdrp->bfd_section;
   bfd_boolean is_rel = (shdrp->sh_type == 9
    || shdrp->sh_type == 4);
   if (is_rel
       || (sec != 
# 6218 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0) 
# 6218 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      && (sec->flags & 0x8000000)))
     {
       if (!is_rel)
  {
    const char *name = sec->name;
    struct bfd_elf_section_data *d;


    if (!bfd_compress_section (abfd, sec,
          shdrp->contents))
      return 0;

    if (sec->compress_status == 1
        && (abfd->flags & 0x20000) == 0)
      {


        char *new_name
   = convert_debug_to_zdebug (abfd, name);
        if (new_name == 
# 6237 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                       ((void *)0)
# 6237 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                           )
   return 0;
        name = new_name;
      }

    if (shdrp->sh_name != (unsigned int) -1)
      _bfd_abort ("/doner/binutils/binutils-7a31b38/bfd/elf.c", 6243, __PRETTY_FUNCTION__);
    shdrp->sh_name
      = (unsigned int) _bfd_elf_strtab_add ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr),
         name, 0);
    d = ((struct bfd_elf_section_data*)(sec)->used_by_bfd);


    if (d->rel.hdr
        && !_bfd_elf_set_reloc_sh_name (abfd,
            d->rel.hdr,
            name, 0))
      return 0;
    if (d->rela.hdr
        && !_bfd_elf_set_reloc_sh_name (abfd,
            d->rela.hdr,
            name, 1))
      return 0;


    shdrp->sh_size = sec->size;
    shdrp->contents = sec->contents;
    shdrp->bfd_section->contents = 
# 6264 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                  ((void *)0)
# 6264 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                      ;
  }
       off = _bfd_elf_assign_file_position_for_section (shdrp,
              off,
              1);
     }
 }
    }



  _bfd_elf_strtab_finalize ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr));
  shdrp = &((abfd) -> tdata.elf_obj_data)->shstrtab_hdr;
  shdrp->sh_size = _bfd_elf_strtab_size ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr));
  off = _bfd_elf_assign_file_position_for_section (shdrp, off, 1);


  i_ehdrp = (((abfd) -> tdata.elf_obj_data) -> elf_header);
  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  off = align_file_position (off, 1 << bed->s->log_file_align);
  i_ehdrp->e_shoff = off;
  off += i_ehdrp->e_shnum * i_ehdrp->e_shentsize;
  (((abfd) -> tdata.elf_obj_data) -> o->next_file_pos) = off;

  return 1;
}

bfd_boolean
_bfd_elf_write_object_contents (bfd *abfd)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  Elf_Internal_Shdr **i_shdrp;
  bfd_boolean failed;
  unsigned int count, num_sec;
  struct elf_obj_tdata *t;

  if (! abfd->output_has_begun
      && ! _bfd_elf_compute_section_file_positions (abfd, 
# 6301 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                         ((void *)0)
# 6301 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                             ))
    return 0;

  i_shdrp = (((abfd) -> tdata.elf_obj_data) -> elf_sect_ptr);

  failed = 0;
  bfd_map_over_sections (abfd, bed->s->write_relocs, &failed);
  if (failed)
    return 0;

  if (!_bfd_elf_assign_file_positions_for_non_load (abfd))
    return 0;


  num_sec = (((abfd) -> tdata.elf_obj_data) -> num_elf_sections);
  for (count = 1; count < num_sec; count++)
    {
      i_shdrp[count]->sh_name
 = _bfd_elf_strtab_offset ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr),
      i_shdrp[count]->sh_name);
      if (bed->elf_backend_section_processing)
 (*bed->elf_backend_section_processing) (abfd, i_shdrp[count]);
      if (i_shdrp[count]->contents)
 {
   bfd_size_type amt = i_shdrp[count]->sh_size;

   if (bfd_seek (abfd, i_shdrp[count]->sh_offset, 
# 6327 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                 0
# 6327 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                         ) != 0
       || bfd_bwrite (i_shdrp[count]->contents, amt, abfd) != amt)
     return 0;
 }
    }


  t = ((abfd) -> tdata.elf_obj_data);
  if ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr) != 
# 6335 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                            ((void *)0)
      
# 6336 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     && (bfd_seek (abfd, t->shstrtab_hdr.sh_offset, 
# 6336 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                    0
# 6336 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                            ) != 0
   || !_bfd_elf_strtab_emit (abfd, (((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr))))
    return 0;

  if (bed->elf_backend_final_write_processing)
    (*bed->elf_backend_final_write_processing) (abfd, (((abfd) -> tdata.elf_obj_data) -> o->linker));

  if (!bed->s->write_shdrs_and_ehdr (abfd))
    return 0;


  if (t->o->build_id.after_write_object_contents != 
# 6347 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                   ((void *)0)
# 6347 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                       )
    return (*t->o->build_id.after_write_object_contents) (abfd);

  return 1;
}

bfd_boolean
_bfd_elf_write_corefile_contents (bfd *abfd)
{

  return _bfd_elf_write_object_contents (abfd);
}



unsigned int
_bfd_elf_section_from_bfd_section (bfd *abfd, struct bfd_section *asect)
{
  const struct elf_backend_data *bed;
  unsigned int sec_index;

  if (((struct bfd_elf_section_data*)(asect)->used_by_bfd) != 
# 6368 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                 ((void *)0)
      
# 6369 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     && ((struct bfd_elf_section_data*)(asect)->used_by_bfd)->this_idx != 0)
    return ((struct bfd_elf_section_data*)(asect)->used_by_bfd)->this_idx;

  if (((asect) == (&_bfd_std_section[2])))
    sec_index = (-0xFu);
  else if ((((asect)->flags & 0x1000) != 0))
    sec_index = (-0xEu);
  else if (((asect) == (&_bfd_std_section[1])))
    sec_index = 0;
  else
    sec_index = (-0x101u);

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  if (bed->elf_backend_section_from_bfd_section)
    {
      int retval = sec_index;

      if ((*bed->elf_backend_section_from_bfd_section) (abfd, asect, &retval))
 return retval;
    }

  if (sec_index == (-0x101u))
    bfd_set_error (bfd_error_nonrepresentable_section);

  return sec_index;
}




int
_bfd_elf_symbol_from_bfd_symbol (bfd *abfd, asymbol **asym_ptr_ptr)
{
  asymbol *asym_ptr = *asym_ptr_ptr;
  int idx;
  flagword flags = asym_ptr->flags;






  if (asym_ptr->udata.i == 0
      && (flags & (1 << 8))
      && asym_ptr->section)
    {
      asection *sec;
      int indx;

      sec = asym_ptr->section;
      if (sec->owner != abfd && sec->output_section != 
# 6419 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                      ((void *)0)
# 6419 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                          )
 sec = sec->output_section;
      if (sec->owner == abfd
   && (indx = sec->index) < (((abfd) -> tdata.elf_obj_data) -> o->num_section_syms)
   && (((abfd) -> tdata.elf_obj_data) -> o->section_syms)[indx] != 
# 6423 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                      ((void *)0)
# 6423 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                          )
 asym_ptr->udata.i = (((abfd) -> tdata.elf_obj_data) -> o->section_syms)[indx]->udata.i;
    }

  idx = asym_ptr->udata.i;

  if (idx == 0)
    {


      _bfd_error_handler

 (dgettext ("bfd", "%B: symbol `%s' required but not present"),
  abfd, ((asym_ptr)->name));
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }
# 6450 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  return idx;
}



static bfd_boolean
rewrite_elf_program_header (bfd *ibfd, bfd *obfd)
{
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *map;
  struct elf_segment_map *map_first;
  struct elf_segment_map **pointer_to_map;
  Elf_Internal_Phdr *segment;
  asection *section;
  unsigned int i;
  unsigned int num_segments;
  bfd_boolean phdr_included = 0;
  bfd_boolean p_paddr_valid;
  bfd_vma maxpagesize;
  struct elf_segment_map *phdr_adjust_seg = 
# 6469 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                           ((void *)0)
# 6469 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                               ;
  unsigned int phdr_adjust_num = 0;
  const struct elf_backend_data *bed;

  bed = ((const struct elf_backend_data *) ((ibfd)->xvec)->backend_data);
  iehdr = (((ibfd) -> tdata.elf_obj_data) -> elf_header);

  map_first = 
# 6476 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 6476 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 ;
  pointer_to_map = &map_first;

  num_segments = (((ibfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum;
  maxpagesize = ((const struct elf_backend_data *) ((obfd)->xvec)->backend_data)->maxpagesize;
# 6593 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  for (section = ibfd->sections; section != 
# 6593 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                           ((void *)0)
# 6593 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                               ; section = section->next)
    section->segment_mark = 0;





  p_paddr_valid = 0;
  for (i = 0, segment = ((ibfd) -> tdata.elf_obj_data)->phdr;
       i < num_segments;
       i++, segment++)
    if (segment->p_paddr != 0)
      {
 p_paddr_valid = 1;
 break;
      }





  for (i = 0, segment = ((ibfd) -> tdata.elf_obj_data)->phdr;
       i < num_segments;
       i++, segment++)
    {
      unsigned int j;
      Elf_Internal_Phdr *segment2;

      if (segment->p_type == 3)
 for (section = ibfd->sections; section; section = section->next)
   if ((segment->p_vaddr == 0 && segment->p_paddr == 0 && segment->p_memsz == 0 && segment->p_filesz > 0 && (section->flags & 0x100) != 0 && section->size > 0 && (bfd_vma) section->filepos >= segment->p_offset && ((bfd_vma) section->filepos + section->size <= segment->p_offset + segment->p_filesz)))
     {


       segment->p_vaddr = section->vma;
       break;
     }

      if (segment->p_type != 1)
 {

   if (segment->p_type == (0x60000000 + 0x474e552))
     segment->p_type = 0;
   continue;
 }


      for (j = 0, segment2 = ((ibfd) -> tdata.elf_obj_data)->phdr; j < i; j++, segment2++)
 {
   bfd_signed_vma extra_length;

   if (segment2->p_type != 1
       || !( !((segment->p_vaddr >= (segment2->p_vaddr + (segment2->p_memsz > segment2->p_filesz ? segment2->p_memsz : segment2->p_filesz))) || (segment2->p_vaddr >= (segment->p_vaddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz)))) && !((segment->p_paddr >= (segment2->p_paddr + (segment2->p_memsz > segment2->p_filesz ? segment2->p_memsz : segment2->p_filesz))) || (segment2->p_paddr >= (segment->p_paddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz))))))
     continue;


   if (segment2->p_vaddr < segment->p_vaddr)
     {


       extra_length = ((segment->p_vaddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz))
         - (segment2->p_vaddr + (segment2->p_memsz > segment2->p_filesz ? segment2->p_memsz : segment2->p_filesz)));

       if (extra_length > 0)
  {
    segment2->p_memsz += extra_length;
    segment2->p_filesz += extra_length;
  }

       segment->p_type = 0;


       i = 0;
       segment = ((ibfd) -> tdata.elf_obj_data)->phdr;
       break;
     }
   else
     {


       extra_length = ((segment2->p_vaddr + (segment2->p_memsz > segment2->p_filesz ? segment2->p_memsz : segment2->p_filesz))
         - (segment->p_vaddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz)));

       if (extra_length > 0)
  {
    segment->p_memsz += extra_length;
    segment->p_filesz += extra_length;
  }

       segment2->p_type = 0;
     }
 }
    }


  for (i = 0, segment = ((ibfd) -> tdata.elf_obj_data)->phdr;
       i < num_segments;
       i++, segment++)
    {
      unsigned int section_count;
      asection **sections;
      asection *output_section;
      unsigned int isec;
      bfd_vma matching_lma;
      bfd_vma suggested_lma;
      unsigned int j;
      bfd_size_type amt;
      asection *first_section;
      bfd_boolean first_matching_lma;
      bfd_boolean first_suggested_lma;

      if (segment->p_type == 0)
 continue;

      first_section = 
# 6707 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
# 6707 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                         ;

      for (section = ibfd->sections, section_count = 0;
    section != 
# 6710 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 6710 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  ;
    section = section->next)
 {


   if (((((segment->p_paddr ? (section->lma >= segment->p_paddr && (section->lma + (((section->flags & (0x100 | 0x400)) != 0x400 || segment->p_type == 7) ? section->size : 0) <= (segment->p_paddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz)))) : (section->vma >= segment->p_vaddr && (section->vma + (((section->flags & (0x100 | 0x400)) != 0x400 || segment->p_type == 7) ? section->size : 0) <= ((segment->p_vaddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz)))))) && (section->flags & 0x001) != 0) || (segment->p_type == 4 && (((struct bfd_elf_section_data*)(section)->used_by_bfd)->this_hdr.sh_type) == 7 && (bfd_vma) section->filepos >= segment->p_offset && ((bfd_vma) section->filepos + section->size <= segment->p_offset + segment->p_filesz))) && segment->p_type != (0x60000000 + 0x474e551) && (segment->p_type != 7 || (section->flags & 0x400)) && (segment->p_type == 1 || segment->p_type == 7 || (section->flags & 0x400) == 0) && (segment->p_type != 2 || (((section->flags & (0x100 | 0x400)) != 0x400 || segment->p_type == 7) ? section->size : 0) > 0 || (segment->p_paddr ? segment->p_paddr != section->lma : segment->p_vaddr != section->vma) || (strcmp (((void) ibfd, (section)->name), ".dynamic") == 0)) && !section->segment_mark))
     {
       if (first_section == 
# 6717 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                           ((void *)0)
# 6717 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                               )
  first_section = section;
       if (section->output_section != 
# 6719 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                     ((void *)0)
# 6719 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                         )
  ++section_count;
     }
 }



      amt = sizeof (struct elf_segment_map);
      amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
      if (map == 
# 6729 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 6729 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    )
 return 0;



      map->next = 
# 6734 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 6734 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     ;
      map->p_type = segment->p_type;
      map->p_flags = segment->p_flags;
      map->p_flags_valid = 1;




      if (!first_section || first_section->output_section != 
# 6742 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                            ((void *)0)
# 6742 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                )
 {
   map->p_paddr = segment->p_paddr;
   map->p_paddr_valid = p_paddr_valid;
 }



      map->includes_filehdr = (segment->p_offset == 0
          && segment->p_filesz >= iehdr->e_ehsize);
      map->includes_phdrs = 0;

      if (!phdr_included || segment->p_type != 1)
 {
   map->includes_phdrs =
     (segment->p_offset <= (bfd_vma) iehdr->e_phoff
      && (segment->p_offset + segment->p_filesz
   >= ((bfd_vma) iehdr->e_phoff
       + iehdr->e_phnum * iehdr->e_phentsize)));

   if (segment->p_type == 1 && map->includes_phdrs)
     phdr_included = 1;
 }

      if (section_count == 0)
 {







   if (segment->p_type == 1
       && (segment->p_filesz > 0 || segment->p_memsz == 0))

     _bfd_error_handler (dgettext ("bfd", "%B: warning: Empty loadable segment detected" " at vaddr=%#Lx, is this intentional?")
                                             ,
    ibfd, segment->p_vaddr);

   map->count = 0;
   *pointer_to_map = map;
   pointer_to_map = &map->next;

   continue;
 }
# 6817 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      sections = (asection **) bfd_malloc2 (section_count, sizeof (asection *));
      if (sections == 
# 6818 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
# 6818 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                         )
 return 0;







      isec = 0;
      matching_lma = 0;
      suggested_lma = 0;
      first_matching_lma = 1;
      first_suggested_lma = 1;

      for (section = first_section, j = 0;
    section != 
# 6834 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 6834 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  ;
    section = section->next)
 {
   if ((((((segment->p_paddr ? (section->lma >= segment->p_paddr && (section->lma + (((section->flags & (0x100 | 0x400)) != 0x400 || segment->p_type == 7) ? section->size : 0) <= (segment->p_paddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz)))) : (section->vma >= segment->p_vaddr && (section->vma + (((section->flags & (0x100 | 0x400)) != 0x400 || segment->p_type == 7) ? section->size : 0) <= ((segment->p_vaddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz)))))) && (section->flags & 0x001) != 0) || (segment->p_type == 4 && (((struct bfd_elf_section_data*)(section)->used_by_bfd)->this_hdr.sh_type) == 7 && (bfd_vma) section->filepos >= segment->p_offset && ((bfd_vma) section->filepos + section->size <= segment->p_offset + segment->p_filesz))) && segment->p_type != (0x60000000 + 0x474e551) && (segment->p_type != 7 || (section->flags & 0x400)) && (segment->p_type == 1 || segment->p_type == 7 || (section->flags & 0x400) == 0) && (segment->p_type != 2 || (((section->flags & (0x100 | 0x400)) != 0x400 || segment->p_type == 7) ? section->size : 0) > 0 || (segment->p_paddr ? segment->p_paddr != section->lma : segment->p_vaddr != section->vma) || (strcmp (((void) ibfd, (section)->name), ".dynamic") == 0)) && !section->segment_mark) && section->output_section != 
# 6837 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
      ((void *)0)
# 6837 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      ))
     {
       output_section = section->output_section;

       sections[j++] = section;





       if (!p_paddr_valid
    && segment->p_vaddr != 0
    && !bed->want_p_paddr_set_to_zero
    && isec == 0
    && output_section->lma != 0
    && output_section->vma == (segment->p_vaddr
          + (map->includes_filehdr
      ? iehdr->e_ehsize
      : 0)
          + (map->includes_phdrs
      ? (iehdr->e_phnum
         * iehdr->e_phentsize)
      : 0)))
  map->p_paddr = segment->p_vaddr;



       if ((output_section->lma >= map->p_paddr && (output_section->lma + (((output_section->flags & (0x100 | 0x400)) != 0x400 || segment->p_type == 7) ? output_section->size : 0) <= (map->p_paddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz))))
    || ((segment->p_type == 4 && (((struct bfd_elf_section_data*)(section)->used_by_bfd)->this_hdr.sh_type) == 7 && (bfd_vma) section->filepos >= segment->p_offset && ((bfd_vma) section->filepos + section->size <= segment->p_offset + segment->p_filesz)) && ((ibfd)->format) == bfd_core && section->vma == 0 && section->lma == 0)
    || (bed->want_p_paddr_set_to_zero
        && (output_section->vma >= segment->p_vaddr && (output_section->vma + (((output_section->flags & (0x100 | 0x400)) != 0x400 || segment->p_type == 7) ? output_section->size : 0) <= ((segment->p_vaddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz)))))))
  {
    if (first_matching_lma || output_section->lma < matching_lma)
      {
        matching_lma = output_section->lma;
        first_matching_lma = 0;
      }




    map->sections[isec++] = output_section;
  }
       else if (first_suggested_lma)
  {
    suggested_lma = output_section->lma;
    first_suggested_lma = 0;
  }

       if (j == section_count)
  break;
     }
 }

      do { if (!(j == section_count)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",6891); } while (0);



      if (isec == section_count)
 {




   map->count = section_count;
   *pointer_to_map = map;
   pointer_to_map = &map->next;

   if (p_paddr_valid
       && !bed->want_p_paddr_set_to_zero
       && matching_lma != map->p_paddr
       && !map->includes_filehdr
       && !map->includes_phdrs)



     map->p_vaddr_offset = matching_lma - map->p_paddr;

   free (sections);
   continue;
 }
      else
 {
   if (!first_matching_lma)
     {



       map->p_paddr = matching_lma;
     }
   else
     {



       map->p_paddr = suggested_lma;
     }



   if (map->includes_filehdr)
     {
       if (map->p_paddr >= iehdr->e_ehsize)
  map->p_paddr -= iehdr->e_ehsize;
       else
  {
    map->includes_filehdr = 0;
    map->includes_phdrs = 0;
  }
     }

   if (map->includes_phdrs)
     {
       if (map->p_paddr >= iehdr->e_phnum * iehdr->e_phentsize)
  {
    map->p_paddr -= iehdr->e_phnum * iehdr->e_phentsize;






    phdr_adjust_num = iehdr->e_phnum;
    phdr_adjust_seg = map;
  }
       else
  map->includes_phdrs = 0;
     }
 }
# 6974 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      isec = 0;
      do
 {
   map->count = 0;
   suggested_lma = 0;
   first_suggested_lma = 1;


   for (j = 0; j < section_count; j++)
     {
       section = sections[j];

       if (section == 
# 6986 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
# 6986 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                         )
  continue;

       output_section = section->output_section;

       do { if (!(output_section != 
# 6991 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
      ((void *)0)
# 6991 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",6991); } while (0);

       if ((output_section->lma >= map->p_paddr && (output_section->lma + (((output_section->flags & (0x100 | 0x400)) != 0x400 || segment->p_type == 7) ? output_section->size : 0) <= (map->p_paddr + (segment->p_memsz > segment->p_filesz ? segment->p_memsz : segment->p_filesz))))
    || ((segment->p_type == 4 && (((struct bfd_elf_section_data*)(section)->used_by_bfd)->this_hdr.sh_type) == 7 && (bfd_vma) section->filepos >= segment->p_offset && ((bfd_vma) section->filepos + section->size <= segment->p_offset + segment->p_filesz)) && ((ibfd)->format) == bfd_core && section->vma == 0 && section->lma == 0))
  {
    if (map->count == 0)
      {



        if (output_section->lma
     != (map->p_paddr
         + (map->includes_filehdr ? iehdr->e_ehsize : 0)
         + (map->includes_phdrs
     ? iehdr->e_phnum * iehdr->e_phentsize
     : 0)))
   _bfd_abort ("/doner/binutils/binutils-7a31b38/bfd/elf.c", 7007, __PRETTY_FUNCTION__);
      }
    else
      {
        asection *prev_sec;

        prev_sec = map->sections[map->count - 1];




        if ((((((bfd_vma) (prev_sec->lma + prev_sec->size) + (maxpagesize) - 1) >= (bfd_vma) (prev_sec->lma + prev_sec->size)) ? (((bfd_vma) (prev_sec->lma + prev_sec->size) + ((maxpagesize) - 1)) & ~ (bfd_vma) ((maxpagesize)-1)) : ~ (bfd_vma) 0)

      < ((((bfd_vma) (output_section->lma) + (maxpagesize) - 1) >= (bfd_vma) (output_section->lma)) ? (((bfd_vma) (output_section->lma) + ((maxpagesize) - 1)) & ~ (bfd_vma) ((maxpagesize)-1)) : ~ (bfd_vma) 0))
     || (prev_sec->lma + prev_sec->size
         > output_section->lma))
   {
     if (first_suggested_lma)
       {
         suggested_lma = output_section->lma;
         first_suggested_lma = 0;
       }

     continue;
   }
      }

    map->sections[map->count++] = output_section;
    ++isec;
    sections[j] = 
# 7036 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 7036 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     ;
    section->segment_mark = 1;
  }
       else if (first_suggested_lma)
  {
    suggested_lma = output_section->lma;
    first_suggested_lma = 0;
  }
     }

   do { if (!(map->count > 0)) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",7046); } while (0);


   *pointer_to_map = map;
   pointer_to_map = &map->next;

   if (isec < section_count)
     {



       amt = sizeof (struct elf_segment_map);
       amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
       map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
       if (map == 
# 7060 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 7060 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
  {
    free (sections);
    return 0;
  }




       map->next = 
# 7069 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 7069 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      ;
       map->p_type = segment->p_type;
       map->p_flags = segment->p_flags;
       map->p_flags_valid = 1;
       map->p_paddr = suggested_lma;
       map->p_paddr_valid = p_paddr_valid;
       map->includes_filehdr = 0;
       map->includes_phdrs = 0;
     }
 }
      while (isec < section_count);

      free (sections);
    }

  (((obfd) -> tdata.elf_obj_data) -> o->seg_map) = map_first;




  if (phdr_adjust_seg != 
# 7089 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                        ((void *)0)
# 7089 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                            )
    {
      unsigned int count;

      for (count = 0, map = map_first; map != 
# 7093 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                             ((void *)0)
# 7093 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                 ; map = map->next)
 count++;

      if (count > phdr_adjust_num)
 phdr_adjust_seg->p_paddr
   -= (count - phdr_adjust_num) * iehdr->e_phentsize;
    }
# 7112 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  return 1;
}



static bfd_boolean
copy_elf_program_header (bfd *ibfd, bfd *obfd)
{
  Elf_Internal_Ehdr *iehdr;
  struct elf_segment_map *map;
  struct elf_segment_map *map_first;
  struct elf_segment_map **pointer_to_map;
  Elf_Internal_Phdr *segment;
  unsigned int i;
  unsigned int num_segments;
  bfd_boolean phdr_included = 0;
  bfd_boolean p_paddr_valid;

  iehdr = (((ibfd) -> tdata.elf_obj_data) -> elf_header);

  map_first = 
# 7132 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 7132 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 ;
  pointer_to_map = &map_first;



  p_paddr_valid = 0;
  num_segments = (((ibfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum;
  for (i = 0, segment = ((ibfd) -> tdata.elf_obj_data)->phdr;
       i < num_segments;
       i++, segment++)
    if (segment->p_paddr != 0)
      {
 p_paddr_valid = 1;
 break;
      }

  for (i = 0, segment = ((ibfd) -> tdata.elf_obj_data)->phdr;
       i < num_segments;
       i++, segment++)
    {
      asection *section;
      unsigned int section_count;
      bfd_size_type amt;
      Elf_Internal_Shdr *this_hdr;
      asection *first_section = 
# 7156 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 7156 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   ;
      asection *lowest_section;


      for (section = ibfd->sections, section_count = 0;
    section != 
# 7161 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 7161 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  ;
    section = section->next)
 {
   this_hdr = &(((struct bfd_elf_section_data*)(section)->used_by_bfd)->this_hdr);
   if (((( ((((this_hdr)->sh_flags & (1 << 10)) != 0) && ((segment)->p_type == 7 || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == 1)) || (((this_hdr)->sh_flags & (1 << 10)) == 0 && (segment)->p_type != 7 && (segment)->p_type != 6)) && !(((this_hdr)->sh_flags & (1 << 1)) == 0 && ((segment)->p_type == 1 || (segment)->p_type == 2 || (segment)->p_type == (0x60000000 + 0x474e550) || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == (0x60000000 + 0x474e551))) && ((this_hdr)->sh_type == 8 || ((bfd_vma) (this_hdr)->sh_offset >= (segment)->p_offset && (!(0) || ((this_hdr)->sh_offset - (segment)->p_offset <= (segment)->p_filesz - 1)) && (((this_hdr)->sh_offset - (segment)->p_offset + ((((this_hdr)->sh_flags & (1 << 10)) != 0 && (this_hdr)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (this_hdr)->sh_size)) <= (segment)->p_filesz))) && (!(1) || ((this_hdr)->sh_flags & (1 << 1)) == 0 || ((this_hdr)->sh_addr >= (segment)->p_vaddr && (!(0) || ((this_hdr)->sh_addr - (segment)->p_vaddr <= (segment)->p_memsz - 1)) && (((this_hdr)->sh_addr - (segment)->p_vaddr + ((((this_hdr)->sh_flags & (1 << 10)) != 0 && (this_hdr)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (this_hdr)->sh_size)) <= (segment)->p_memsz))) && ((segment)->p_type != 2 || (this_hdr)->sh_size != 0 || (segment)->p_memsz == 0 || (((this_hdr)->sh_type == 8 || ((bfd_vma) (this_hdr)->sh_offset > (segment)->p_offset && ((this_hdr)->sh_offset - (segment)->p_offset < (segment)->p_filesz))) && (((this_hdr)->sh_flags & (1 << 1)) == 0 || ((this_hdr)->sh_addr > (segment)->p_vaddr && ((this_hdr)->sh_addr - (segment)->p_vaddr < (segment)->p_memsz))))))))
     {
       if (first_section == 
# 7167 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                           ((void *)0)
# 7167 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                               )
  first_section = section;
       section_count++;
     }
 }



      amt = sizeof (struct elf_segment_map);
      if (section_count != 0)
 amt += ((bfd_size_type) section_count - 1) * sizeof (asection *);
      map = (struct elf_segment_map *) bfd_zalloc (obfd, amt);
      if (map == 
# 7179 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 7179 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    )
 return 0;



      map->next = 
# 7184 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 7184 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     ;
      map->p_type = segment->p_type;
      map->p_flags = segment->p_flags;
      map->p_flags_valid = 1;
      map->p_paddr = segment->p_paddr;
      map->p_paddr_valid = p_paddr_valid;
      map->p_align = segment->p_align;
      map->p_align_valid = 1;
      map->p_vaddr_offset = 0;

      if (map->p_type == (0x60000000 + 0x474e552)
   || map->p_type == (0x60000000 + 0x474e551))
 {






   map->p_size = segment->p_memsz;
   map->p_size_valid = 1;
 }



      map->includes_filehdr = (segment->p_offset == 0
          && segment->p_filesz >= iehdr->e_ehsize);

      map->includes_phdrs = 0;
      if (! phdr_included || segment->p_type != 1)
 {
   map->includes_phdrs =
     (segment->p_offset <= (bfd_vma) iehdr->e_phoff
      && (segment->p_offset + segment->p_filesz
   >= ((bfd_vma) iehdr->e_phoff
       + iehdr->e_phnum * iehdr->e_phentsize)));

   if (segment->p_type == 1 && map->includes_phdrs)
     phdr_included = 1;
 }

      lowest_section = 
# 7225 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 7225 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          ;
      if (section_count != 0)
 {
   unsigned int isec = 0;

   for (section = first_section;
        section != 
# 7231 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 7231 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      ;
        section = section->next)
     {
       this_hdr = &(((struct bfd_elf_section_data*)(section)->used_by_bfd)->this_hdr);
       if (((( ((((this_hdr)->sh_flags & (1 << 10)) != 0) && ((segment)->p_type == 7 || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == 1)) || (((this_hdr)->sh_flags & (1 << 10)) == 0 && (segment)->p_type != 7 && (segment)->p_type != 6)) && !(((this_hdr)->sh_flags & (1 << 1)) == 0 && ((segment)->p_type == 1 || (segment)->p_type == 2 || (segment)->p_type == (0x60000000 + 0x474e550) || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == (0x60000000 + 0x474e551))) && ((this_hdr)->sh_type == 8 || ((bfd_vma) (this_hdr)->sh_offset >= (segment)->p_offset && (!(0) || ((this_hdr)->sh_offset - (segment)->p_offset <= (segment)->p_filesz - 1)) && (((this_hdr)->sh_offset - (segment)->p_offset + ((((this_hdr)->sh_flags & (1 << 10)) != 0 && (this_hdr)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (this_hdr)->sh_size)) <= (segment)->p_filesz))) && (!(1) || ((this_hdr)->sh_flags & (1 << 1)) == 0 || ((this_hdr)->sh_addr >= (segment)->p_vaddr && (!(0) || ((this_hdr)->sh_addr - (segment)->p_vaddr <= (segment)->p_memsz - 1)) && (((this_hdr)->sh_addr - (segment)->p_vaddr + ((((this_hdr)->sh_flags & (1 << 10)) != 0 && (this_hdr)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (this_hdr)->sh_size)) <= (segment)->p_memsz))) && ((segment)->p_type != 2 || (this_hdr)->sh_size != 0 || (segment)->p_memsz == 0 || (((this_hdr)->sh_type == 8 || ((bfd_vma) (this_hdr)->sh_offset > (segment)->p_offset && ((this_hdr)->sh_offset - (segment)->p_offset < (segment)->p_filesz))) && (((this_hdr)->sh_flags & (1 << 1)) == 0 || ((this_hdr)->sh_addr > (segment)->p_vaddr && ((this_hdr)->sh_addr - (segment)->p_vaddr < (segment)->p_memsz))))))))
  {
    map->sections[isec++] = section->output_section;
    if ((section->flags & 0x001) != 0)
      {
        bfd_vma seg_off;

        if (lowest_section == 
# 7242 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             ((void *)0)
     
# 7243 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
    || section->lma < lowest_section->lma)
   lowest_section = section;






        if ((section->flags & 0x002) != 0)
   seg_off = this_hdr->sh_offset - segment->p_offset;
        else
   seg_off = this_hdr->sh_addr - segment->p_vaddr;
        if (section->lma - segment->p_paddr != seg_off)
   map->p_paddr_valid = 0;
      }
    if (isec == section_count)
      break;
  }
     }
 }

      if (map->includes_filehdr && lowest_section != 
# 7264 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                    ((void *)0)
# 7264 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                        )

 map->header_size = lowest_section->vma - segment->p_vaddr;

      if (!map->includes_phdrs
   && !map->includes_filehdr
   && map->p_paddr_valid)

 map->p_vaddr_offset = ((lowest_section ? lowest_section->lma : 0)
          - segment->p_paddr);

      map->count = section_count;
      *pointer_to_map = map;
      pointer_to_map = &map->next;
    }

  (((obfd) -> tdata.elf_obj_data) -> o->seg_map) = map_first;
  return 1;
}




static bfd_boolean
copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (((ibfd)->xvec->flavour) != bfd_target_elf_flavour
      || ((obfd)->xvec->flavour) != bfd_target_elf_flavour)
    return 1;

  if (((ibfd) -> tdata.elf_obj_data)->phdr == 
# 7294 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 7294 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   )
    return 1;

  if (ibfd->xvec == obfd->xvec)
    {


      Elf_Internal_Phdr *segment;
      asection *section, *osec;
      unsigned int i, num_segments;
      Elf_Internal_Shdr *this_hdr;
      const struct elf_backend_data *bed;

      bed = ((const struct elf_backend_data *) ((ibfd)->xvec)->backend_data);


      if (bed->want_p_paddr_set_to_zero)
 goto rewrite;


      for (section = obfd->sections; section != 
# 7314 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                               ((void *)0)
# 7314 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                   ;
    section = section->next)
 section->segment_mark = 0;

      num_segments = (((ibfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum;
      for (i = 0, segment = ((ibfd) -> tdata.elf_obj_data)->phdr;
    i < num_segments;
    i++, segment++)
 {




   if (segment->p_paddr == 0
       && segment->p_memsz == 0
       && (segment->p_type == 3 || segment->p_type == 2))
     goto rewrite;

   for (section = ibfd->sections;
        section != 
# 7333 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 7333 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      ; section = section->next)
     {


       osec = section->output_section;
       if (osec)
  osec->segment_mark = 1;


       this_hdr = &(((struct bfd_elf_section_data*)(section)->used_by_bfd)->this_hdr);
       if (((( ((((this_hdr)->sh_flags & (1 << 10)) != 0) && ((segment)->p_type == 7 || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == 1)) || (((this_hdr)->sh_flags & (1 << 10)) == 0 && (segment)->p_type != 7 && (segment)->p_type != 6)) && !(((this_hdr)->sh_flags & (1 << 1)) == 0 && ((segment)->p_type == 1 || (segment)->p_type == 2 || (segment)->p_type == (0x60000000 + 0x474e550) || (segment)->p_type == (0x60000000 + 0x474e552) || (segment)->p_type == (0x60000000 + 0x474e551))) && ((this_hdr)->sh_type == 8 || ((bfd_vma) (this_hdr)->sh_offset >= (segment)->p_offset && (!(0) || ((this_hdr)->sh_offset - (segment)->p_offset <= (segment)->p_filesz - 1)) && (((this_hdr)->sh_offset - (segment)->p_offset + ((((this_hdr)->sh_flags & (1 << 10)) != 0 && (this_hdr)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (this_hdr)->sh_size)) <= (segment)->p_filesz))) && (!(1) || ((this_hdr)->sh_flags & (1 << 1)) == 0 || ((this_hdr)->sh_addr >= (segment)->p_vaddr && (!(0) || ((this_hdr)->sh_addr - (segment)->p_vaddr <= (segment)->p_memsz - 1)) && (((this_hdr)->sh_addr - (segment)->p_vaddr + ((((this_hdr)->sh_flags & (1 << 10)) != 0 && (this_hdr)->sh_type == 8 && (segment)->p_type != 7) ? 0 : (this_hdr)->sh_size)) <= (segment)->p_memsz))) && ((segment)->p_type != 2 || (this_hdr)->sh_size != 0 || (segment)->p_memsz == 0 || (((this_hdr)->sh_type == 8 || ((bfd_vma) (this_hdr)->sh_offset > (segment)->p_offset && ((this_hdr)->sh_offset - (segment)->p_offset < (segment)->p_filesz))) && (((this_hdr)->sh_flags & (1 << 1)) == 0 || ((this_hdr)->sh_addr > (segment)->p_vaddr && ((this_hdr)->sh_addr - (segment)->p_vaddr < (segment)->p_memsz))))))))
  {


    if (osec == 
# 7347 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
        
# 7348 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
       || section->flags != osec->flags
        || section->lma != osec->lma
        || section->vma != osec->vma
        || section->size != osec->size
        || section->rawsize != osec->rawsize
        || section->alignment_power != osec->alignment_power)
      goto rewrite;
  }
     }
 }



      for (section = obfd->sections; section != 
# 7361 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                               ((void *)0)
# 7361 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                   ;
    section = section->next)
 {
   if (!section->segment_mark)
     goto rewrite;
   else
     section->segment_mark = 0;
 }

      return copy_elf_program_header (ibfd, obfd);
    }

rewrite:
  if (ibfd->xvec == obfd->xvec)
    {


      Elf_Internal_Phdr *segment;
      unsigned int i;
      unsigned int num_segments = (((ibfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum;
      bfd_vma maxpagesize = 0;

      for (i = 0, segment = ((ibfd) -> tdata.elf_obj_data)->phdr;
    i < num_segments;
    i++, segment++)
 if (segment->p_type == 1
     && maxpagesize < segment->p_align)
   {

     if (segment->p_align > (bfd_vma) 1 << ((sizeof (bfd_vma) * 8) - 2))

       _bfd_error_handler (dgettext ("bfd", "%B: warning: segment alignment of %#Lx" " is too large")
                        ,
      ibfd, segment->p_align);
     else
       maxpagesize = segment->p_align;
   }

      if (maxpagesize != ((const struct elf_backend_data *) ((obfd)->xvec)->backend_data)->maxpagesize)
 bfd_emul_set_maxpagesize (((obfd)->xvec->name), maxpagesize);
    }

  return rewrite_elf_program_header (ibfd, obfd);
}



bfd_boolean
_bfd_elf_init_private_section_data (bfd *ibfd,
        asection *isec,
        bfd *obfd,
        asection *osec,
        struct bfd_link_info *link_info)

{
  Elf_Internal_Shdr *ihdr, *ohdr;
  bfd_boolean final_link = (link_info != 
# 7417 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                        ((void *)0)
       
# 7418 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && !((link_info)->type == type_relocatable));

  if (ibfd->xvec->flavour != bfd_target_elf_flavour
      || obfd->xvec->flavour != bfd_target_elf_flavour)
    return 1;

  do { if (!(((struct bfd_elf_section_data*)(osec)->used_by_bfd) != 
# 7424 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
 ((void *)0)
# 7424 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
 )) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",7424); } while (0);





  if ((((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr.sh_type) == 0
      && (osec->flags == isec->flags
   || (final_link
       && ((osec->flags ^ isec->flags)
    & ~(0x20000 | 0xc0000 | 0x004)) == 0)))
    (((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr.sh_type) = (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr.sh_type);


  (((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr.sh_flags) |= ((((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr.sh_flags)
          & (0x0FF00000 | 0xF0000000));


  if ((((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr.sh_flags) & 0x01000000)
    ((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr.sh_info
      = ((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr.sh_info;





  if ((link_info == 
# 7450 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0)
       
# 7451 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      || !link_info->resolve_section_groups)
      && ((((struct bfd_elf_section_data*)(isec)->used_by_bfd)->sec_group) == 
# 7452 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                 ((void *)0)
   
# 7453 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  || ((((struct bfd_elf_section_data*)(isec)->used_by_bfd)->sec_group)->flags & 0x100000) == 0))
    {
      if ((((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr.sh_flags) & (1 << 9))
 (((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr.sh_flags) |= (1 << 9);
      (((struct bfd_elf_section_data*)(osec)->used_by_bfd)->next_in_group) = (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->next_in_group);
      ((struct bfd_elf_section_data*)(osec)->used_by_bfd)->group = ((struct bfd_elf_section_data*)(isec)->used_by_bfd)->group;
    }


  if (!final_link && (ibfd->flags & 0x8000) == 0)
    (((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr.sh_flags) |= ((((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr.sh_flags)
     & (1 << 11));

  ihdr = &((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr;




  if ((ihdr->sh_flags & (1 << 7)) != 0)
    {
      ohdr = &((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr;
      ohdr->sh_flags |= (1 << 7);
      (((struct bfd_elf_section_data*)(osec)->used_by_bfd)->linked_to) = (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->linked_to);
    }

  osec->use_rela_p = isec->use_rela_p;

  return 1;
}




bfd_boolean
_bfd_elf_copy_private_section_data (bfd *ibfd,
        asection *isec,
        bfd *obfd,
        asection *osec)
{
  Elf_Internal_Shdr *ihdr, *ohdr;

  if (ibfd->xvec->flavour != bfd_target_elf_flavour
      || obfd->xvec->flavour != bfd_target_elf_flavour)
    return 1;

  ihdr = &((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr;
  ohdr = &((struct bfd_elf_section_data*)(osec)->used_by_bfd)->this_hdr;

  ohdr->sh_entsize = ihdr->sh_entsize;

  if (ihdr->sh_type == 2
      || ihdr->sh_type == 11
      || ihdr->sh_type == 0x6ffffffe
      || ihdr->sh_type == 0x6ffffffd)
    ohdr->sh_info = ihdr->sh_info;

  return _bfd_elf_init_private_section_data (ibfd, isec, obfd, osec,
          
# 7510 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
         ((void *)0)
# 7510 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
             );
}
# 7520 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
bfd_boolean
_bfd_elf_fixup_group_sections (bfd *ibfd, asection *discarded)
{
  asection *isec;

  for (isec = ibfd->sections; isec != 
# 7525 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                     ((void *)0)
# 7525 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                         ; isec = isec->next)
    if ((((struct bfd_elf_section_data*)(isec)->used_by_bfd)->this_hdr.sh_type) == 17)
      {
 asection *first = (((struct bfd_elf_section_data*)(isec)->used_by_bfd)->next_in_group);
 asection *s = first;
 bfd_size_type removed = 0;

 while (s != 
# 7532 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 7532 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
   {



     if (s->output_section != discarded
  && isec->output_section == discarded)
       {
  (((struct bfd_elf_section_data*)(s->output_section)->used_by_bfd)->this_hdr.sh_flags) &= ~(1 << 9);
  (((struct bfd_elf_section_data*)(s->output_section)->used_by_bfd)->group.name) = 
# 7541 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                      ((void *)0)
# 7541 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                          ;
       }


     else if (s->output_section == discarded
       && isec->output_section != discarded)
       removed += 4;
     s = (((struct bfd_elf_section_data*)(s)->used_by_bfd)->next_in_group);
     if (s == first)
       break;
   }
 if (removed != 0)
   {
     if (discarded != 
# 7554 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
# 7554 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                         )
       {




  if (isec->rawsize == 0)
    isec->rawsize = isec->size;
  isec->size = isec->rawsize - removed;
       }
     else
       {


  isec->output_section->size -= removed;
       }
   }
      }

  return 1;
}



bfd_boolean
_bfd_elf_copy_private_header_data (bfd *ibfd, bfd *obfd)
{
  if (((ibfd)->xvec->flavour) != bfd_target_elf_flavour
      || ((obfd)->xvec->flavour) != bfd_target_elf_flavour)
    return 1;






  if ((((obfd) -> tdata.elf_obj_data) -> o->seg_map) == 
# 7590 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                           ((void *)0) 
# 7590 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                && ((ibfd) -> tdata.elf_obj_data)->phdr != 
# 7590 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                             ((void *)0)
# 7590 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                 )
    {
      if (! copy_private_bfd_data (ibfd, obfd))
 return 0;
    }

  return _bfd_elf_fixup_group_sections (ibfd, 
# 7596 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                             ((void *)0)
# 7596 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                 );
}
# 7611 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
bfd_boolean
_bfd_elf_copy_private_symbol_data (bfd *ibfd,
       asymbol *isymarg,
       bfd *obfd,
       asymbol *osymarg)
{
  elf_symbol_type *isym, *osym;

  if (((ibfd)->xvec->flavour) != bfd_target_elf_flavour
      || ((obfd)->xvec->flavour) != bfd_target_elf_flavour)
    return 1;

  isym = (((isymarg)->the_bfd->xvec->flavour == bfd_target_elf_flavour && (isymarg)->the_bfd->tdata.elf_obj_data != 0) ? (elf_symbol_type *) (isymarg) : 0);
  osym = (((osymarg)->the_bfd->xvec->flavour == bfd_target_elf_flavour && (osymarg)->the_bfd->tdata.elf_obj_data != 0) ? (elf_symbol_type *) (osymarg) : 0);

  if (isym != 
# 7626 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
      
# 7627 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     && isym->internal_elf_sym.st_shndx != 0
      && osym != 
# 7628 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
      
# 7629 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
     && ((isym->symbol.section) == (&_bfd_std_section[2])))
    {
      unsigned int shndx;

      shndx = isym->internal_elf_sym.st_shndx;
      if (shndx == (((ibfd) -> tdata.elf_obj_data) -> symtab_section))
 shndx = ((-0xC1u) + 1);
      else if (shndx == (((ibfd) -> tdata.elf_obj_data) -> dynsymtab_section))
 shndx = ((-0xC1u) + 2);
      else if (shndx == (((ibfd) -> tdata.elf_obj_data) -> o->strtab_section))
 shndx = ((-0xC1u) + 3);
      else if (shndx == (((ibfd) -> tdata.elf_obj_data) -> o->shstrtab_section))
 shndx = ((-0xC1u) + 4);
      else if (find_section_in_list (shndx, (((ibfd) -> tdata.elf_obj_data) -> symtab_shndx_list)))
 shndx = ((-0xC1u) + 5);
      osym->internal_elf_sym.st_shndx = shndx;
    }

  return 1;
}



static bfd_boolean
swap_out_syms (bfd *abfd,
        struct elf_strtab_hash **sttp,
        int relocatable_p)
{
  const struct elf_backend_data *bed;
  int symcount;
  asymbol **syms;
  struct elf_strtab_hash *stt;
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *symtab_shndx_hdr;
  Elf_Internal_Shdr *symstrtab_hdr;
  struct elf_sym_strtab *symstrtab;
  bfd_byte *outbound_syms;
  bfd_byte *outbound_shndx;
  unsigned long outbound_syms_index;
  unsigned long outbound_shndx_index;
  int idx;
  unsigned int num_locals;
  bfd_size_type amt;
  bfd_boolean name_local_sections;

  if (!elf_map_symbols (abfd, &num_locals))
    return 0;


  stt = _bfd_elf_strtab_init ();
  if (stt == 
# 7679 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 7679 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
    return 0;

  bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  symcount = ((abfd)->symcount);
  symtab_hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;
  symtab_hdr->sh_type = 2;
  symtab_hdr->sh_entsize = bed->s->sizeof_sym;
  symtab_hdr->sh_size = symtab_hdr->sh_entsize * (symcount + 1);
  symtab_hdr->sh_info = num_locals + 1;
  symtab_hdr->sh_addralign = (bfd_vma) 1 << bed->s->log_file_align;

  symstrtab_hdr = &((abfd) -> tdata.elf_obj_data)->strtab_hdr;
  symstrtab_hdr->sh_type = 3;


  symstrtab = (struct elf_sym_strtab *) bfd_malloc ((symcount + 1)
          * sizeof (*symstrtab));
  if (symstrtab == 
# 7697 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 7697 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      )
    {
      _bfd_elf_strtab_free (stt);
      return 0;
    }

  outbound_syms = (bfd_byte *) bfd_alloc2 (abfd, 1 + symcount,
                                           bed->s->sizeof_sym);
  if (outbound_syms == 
# 7705 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 7705 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          )
    {
error_return:
      _bfd_elf_strtab_free (stt);
      free (symstrtab);
      return 0;
    }
  symtab_hdr->contents = outbound_syms;
  outbound_syms_index = 0;

  outbound_shndx = 
# 7715 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 7715 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      ;
  outbound_shndx_index = 0;

  if ((((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list))
    {
      symtab_shndx_hdr = & (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list)->hdr;
      if (symtab_shndx_hdr->sh_name != 0)
 {
   amt = (bfd_size_type) (1 + symcount) * sizeof (Elf_External_Sym_Shndx);
   outbound_shndx = (bfd_byte *)
     bfd_zalloc2 (abfd, 1 + symcount, sizeof (Elf_External_Sym_Shndx));
   if (outbound_shndx == 
# 7726 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                        ((void *)0)
# 7726 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                            )
     goto error_return;

   symtab_shndx_hdr->contents = outbound_shndx;
   symtab_shndx_hdr->sh_type = 18;
   symtab_shndx_hdr->sh_size = amt;
   symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);
   symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);
 }

    }


  {

    Elf_Internal_Sym sym;
    sym.st_name = 0;
    sym.st_value = 0;
    sym.st_size = 0;
    sym.st_info = 0;
    sym.st_other = 0;
    sym.st_shndx = 0;
    sym.st_target_internal = 0;
    symstrtab[0].sym = sym;
    symstrtab[0].dest_index = outbound_syms_index;
    symstrtab[0].destshndx_index = outbound_shndx_index;
    outbound_syms_index++;
    if (outbound_shndx != 
# 7753 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
# 7753 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                             )
      outbound_shndx_index++;
  }

  name_local_sections
    = (bed->elf_backend_name_local_section_symbols
       && bed->elf_backend_name_local_section_symbols (abfd));

  syms = ((abfd)->outsymbols);
  for (idx = 0; idx < symcount;)
    {
      Elf_Internal_Sym sym;
      bfd_vma value = syms[idx]->value;
      elf_symbol_type *type_ptr;
      flagword flags = syms[idx]->flags;
      int type;

      if (!name_local_sections
   && (flags & ((1 << 8) | (1 << 1))) == (1 << 8))
 {

   sym.st_name = (unsigned long) -1;
 }
      else
 {


   sym.st_name
     = (unsigned long) _bfd_elf_strtab_add (stt, syms[idx]->name,
         0);
   if (sym.st_name == (unsigned long) -1)
     goto error_return;
 }

      type_ptr = (((syms[idx])->the_bfd->xvec->flavour == bfd_target_elf_flavour && (syms[idx])->the_bfd->tdata.elf_obj_data != 0) ? (elf_symbol_type *) (syms[idx]) : 0);

      if ((flags & (1 << 8)) == 0
   && (((syms[idx]->section)->flags & 0x1000) != 0))
 {



   sym.st_size = value;
   if (type_ptr == 
# 7796 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
       
# 7797 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      || type_ptr->internal_elf_sym.st_value == 0)
     sym.st_value = value >= 16 ? 16 : (1 << bfd_log2 (value));
   else
     sym.st_value = type_ptr->internal_elf_sym.st_value;
   sym.st_shndx = _bfd_elf_section_from_bfd_section
     (abfd, syms[idx]->section);
 }
      else
 {
   asection *sec = syms[idx]->section;
   unsigned int shndx;

   if (sec->output_section)
     {
       value += sec->output_offset;
       sec = sec->output_section;
     }


   if (! relocatable_p)
     value += sec->vma;
   sym.st_value = value;
   sym.st_size = type_ptr ? type_ptr->internal_elf_sym.st_size : 0;

   if (((sec) == (&_bfd_std_section[2]))
       && type_ptr != 
# 7822 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
       
# 7823 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      && type_ptr->internal_elf_sym.st_shndx != 0)
     {



       shndx = type_ptr->internal_elf_sym.st_shndx;
       switch (shndx)
  {
  case ((-0xC1u) + 1):
    shndx = (((abfd) -> tdata.elf_obj_data) -> symtab_section);
    break;
  case ((-0xC1u) + 2):
    shndx = (((abfd) -> tdata.elf_obj_data) -> dynsymtab_section);
    break;
  case ((-0xC1u) + 3):
    shndx = (((abfd) -> tdata.elf_obj_data) -> o->strtab_section);
    break;
  case ((-0xC1u) + 4):
    shndx = (((abfd) -> tdata.elf_obj_data) -> o->shstrtab_section);
    break;
  case ((-0xC1u) + 5):
    if ((((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list))
      shndx = (((abfd) -> tdata.elf_obj_data) -> symtab_shndx_list)->ndx;
    break;
  default:
    shndx = (-0xFu);
    break;
  }
     }
   else
     {
       shndx = _bfd_elf_section_from_bfd_section (abfd, sec);

       if (shndx == (-0x101u))
  {
    asection *sec2;
# 7867 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
    sec2 = bfd_get_section_by_name (abfd, sec->name);
    if (sec2 != 
# 7868 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 7868 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   )
      shndx = _bfd_elf_section_from_bfd_section (abfd, sec2);
    if (shndx == (-0x101u))
      {

        _bfd_error_handler (dgettext ("bfd", "Unable to find equivalent output section for symbol '%s' from section '%s'")
                                                                            ,
       syms[idx]->name ? syms[idx]->name : "<Local sym>",
       sec->name);
        bfd_set_error (bfd_error_invalid_operation);
        goto error_return;
      }
  }
     }

   sym.st_shndx = shndx;
 }

      if ((flags & (1 << 18)) != 0)
 type = 6;
      else if ((flags & (1 << 22)) != 0)
 type = 10;
      else if ((flags & (1 << 3)) != 0)
 type = 2;
      else if ((flags & (1 << 16)) != 0)
 type = 1;
      else if ((flags & (1 << 19)) != 0)
 type = 8;
      else if ((flags & (1 << 20)) != 0)
 type = 9;
      else
 type = 0;

      if (syms[idx]->section->flags & 0x400)
 type = 6;


      if (type_ptr != 
# 7905 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
   
# 7906 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  && bed->elf_backend_get_symbol_type)
 type = ((*bed->elf_backend_get_symbol_type)
  (&type_ptr->internal_elf_sym, type));

      if (flags & (1 << 8))
 {
   if (flags & (1 << 1))
     sym.st_info = (((1) << 4) + ((3) & 0xF));
   else
     sym.st_info = (((0) << 4) + ((3) & 0xF));
 }
      else if ((((syms[idx]->section)->flags & 0x1000) != 0))
 {
   if (type != 6)
     {
       if ((abfd->flags & 0x40000))
  type = ((abfd->flags & 0x80000)
   ? 5 : 1);
       else
  type = ((flags & (1 << 6)) != 0
   ? 5 : 1);
     }
   sym.st_info = (((1) << 4) + ((type) & 0xF));
 }
      else if (((syms[idx]->section) == (&_bfd_std_section[1])))
 sym.st_info = (((((flags & (1 << 7)) ? 2 : 1)) << 4) + ((type) & 0xF))


            ;
      else if (flags & (1 << 14))
 sym.st_info = (((0) << 4) + ((4) & 0xF));
      else
 {
   int bind = 0;

   if (flags & (1 << 0))
     bind = 0;
   else if (flags & (1 << 23))
     bind = 10;
   else if (flags & (1 << 7))
     bind = 2;
   else if (flags & (1 << 1))
     bind = 1;

   sym.st_info = (((bind) << 4) + ((type) & 0xF));
 }

      if (type_ptr != 
# 7953 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
# 7953 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                         )
 {
   sym.st_other = type_ptr->internal_elf_sym.st_other;
   sym.st_target_internal
     = type_ptr->internal_elf_sym.st_target_internal;
 }
      else
 {
   sym.st_other = 0;
   sym.st_target_internal = 0;
 }

      idx++;
      symstrtab[idx].sym = sym;
      symstrtab[idx].dest_index = outbound_syms_index;
      symstrtab[idx].destshndx_index = outbound_shndx_index;

      outbound_syms_index++;
      if (outbound_shndx != 
# 7971 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                           ((void *)0)
# 7971 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                               )
 outbound_shndx_index++;
    }


  _bfd_elf_strtab_finalize (stt);


  for (idx = 0; idx <= symcount; idx++)
    {
      struct elf_sym_strtab *elfsym = &symstrtab[idx];
      if (elfsym->sym.st_name == (unsigned long) -1)
 elfsym->sym.st_name = 0;
      else
 elfsym->sym.st_name = _bfd_elf_strtab_offset (stt,
            elfsym->sym.st_name);
      bed->s->swap_symbol_out (abfd, &elfsym->sym,
          (outbound_syms
    + (elfsym->dest_index
       * bed->s->sizeof_sym)),
          (outbound_shndx
    + (elfsym->destshndx_index
       * sizeof (Elf_External_Sym_Shndx))));
    }
  free (symstrtab);

  *sttp = stt;
  symstrtab_hdr->sh_size = _bfd_elf_strtab_size (stt);
  symstrtab_hdr->sh_type = 3;
  symstrtab_hdr->sh_flags = bed->elf_strtab_flags;
  symstrtab_hdr->sh_addr = 0;
  symstrtab_hdr->sh_entsize = 0;
  symstrtab_hdr->sh_link = 0;
  symstrtab_hdr->sh_info = 0;
  symstrtab_hdr->sh_addralign = 1;

  return 1;
}







long
_bfd_elf_get_symtab_upper_bound (bfd *abfd)
{
  long symcount;
  long symtab_size;
  Elf_Internal_Shdr *hdr = &((abfd) -> tdata.elf_obj_data)->symtab_hdr;

  symcount = hdr->sh_size / ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->s->sizeof_sym;
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);

  return symtab_size;
}

long
_bfd_elf_get_dynamic_symtab_upper_bound (bfd *abfd)
{
  long symcount;
  long symtab_size;
  Elf_Internal_Shdr *hdr = &((abfd) -> tdata.elf_obj_data)->dynsymtab_hdr;

  if ((((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  symcount = hdr->sh_size / ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->s->sizeof_sym;
  symtab_size = (symcount + 1) * (sizeof (asymbol *));
  if (symcount > 0)
    symtab_size -= sizeof (asymbol *);

  return symtab_size;
}

long
_bfd_elf_get_reloc_upper_bound (bfd *abfd __attribute__ ((__unused__)),
    sec_ptr asect)
{
  return (asect->reloc_count + 1) * sizeof (arelent *);
}



long
_bfd_elf_canonicalize_reloc (bfd *abfd,
        sec_ptr section,
        arelent **relptr,
        asymbol **symbols)
{
  arelent *tblptr;
  unsigned int i;
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  if (! bed->s->slurp_reloc_table (abfd, section, symbols, 0))
    return -1;

  tblptr = section->relocation;
  for (i = 0; i < section->reloc_count; i++)
    *relptr++ = tblptr++;

  *relptr = 
# 8078 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 8078 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               ;

  return section->reloc_count;
}

long
_bfd_elf_canonicalize_symtab (bfd *abfd, asymbol **allocation)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, 0);

  if (symcount >= 0)
    ((abfd)->symcount) = symcount;
  return symcount;
}

long
_bfd_elf_canonicalize_dynamic_symtab (bfd *abfd,
          asymbol **allocation)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  long symcount = bed->s->slurp_symbol_table (abfd, allocation, 1);

  if (symcount >= 0)
    ((abfd)->dynsymcount) = symcount;
  return symcount;
}






long
_bfd_elf_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  long ret;
  asection *s;

  if ((((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  ret = sizeof (arelent *);
  for (s = abfd->sections; s != 
# 8124 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 8124 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   ; s = s->next)
    if (((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_link == (((abfd) -> tdata.elf_obj_data) -> dynsymtab_section)
 && (((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_type == 9
     || ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_type == 4))
      ret += ((s->size / ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize)
       * sizeof (arelent *));

  return ret;
}
# 8142 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
long
_bfd_elf_canonicalize_dynamic_reloc (bfd *abfd,
         arelent **storage,
         asymbol **syms)
{
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  asection *s;
  long ret;

  if ((((abfd) -> tdata.elf_obj_data) -> dynsymtab_section) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  slurp_relocs = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->s->slurp_reloc_table;
  ret = 0;
  for (s = abfd->sections; s != 
# 8159 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 8159 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   ; s = s->next)
    {
      if (((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_link == (((abfd) -> tdata.elf_obj_data) -> dynsymtab_section)
   && (((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_type == 9
       || ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_type == 4))
 {
   arelent *p;
   long count, i;

   if (! (*slurp_relocs) (abfd, s, syms, 1))
     return -1;
   count = s->size / ((struct bfd_elf_section_data*)(s)->used_by_bfd)->this_hdr.sh_entsize;
   p = s->relocation;
   for (i = 0; i < count; i++)
     *storage++ = p++;
   ret += count;
 }
    }

  *storage = 
# 8178 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 8178 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                ;

  return ret;
}



bfd_boolean
_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)
{
  bfd_byte *contents = 
# 8188 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 8188 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          ;
  unsigned int freeidx = 0;

  if ((((abfd) -> tdata.elf_obj_data) -> dynverref_section) != 0)
    {
      Elf_Internal_Shdr *hdr;
      Elf_External_Verneed *everneed;
      Elf_Internal_Verneed *iverneed;
      unsigned int i;
      bfd_byte *contents_end;

      hdr = &((abfd) -> tdata.elf_obj_data)->dynverref_hdr;

      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verneed))
 {
error_return_bad_verref:
   _bfd_error_handler
     (dgettext ("bfd", "%B: .gnu.version_r invalid entry"), abfd);
   bfd_set_error (bfd_error_bad_value);
error_return_verref:
   ((abfd) -> tdata.elf_obj_data)->verref = 
# 8208 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             ((void *)0)
# 8208 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                 ;
   ((abfd) -> tdata.elf_obj_data)->cverrefs = 0;
   goto error_return;
 }

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == 
# 8214 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
# 8214 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                         )
 goto error_return_verref;

      if (bfd_seek (abfd, hdr->sh_offset, 
# 8217 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                         0
# 8217 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                 ) != 0
   || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
 goto error_return_verref;

      ((abfd) -> tdata.elf_obj_data)->verref = (Elf_Internal_Verneed *)
 bfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));

      if (((abfd) -> tdata.elf_obj_data)->verref == 
# 8224 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                     ((void *)0)
# 8224 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                         )
 goto error_return_verref;

      do { if (!(sizeof (Elf_External_Verneed) == sizeof (Elf_External_Vernaux))) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",8227); } while (0)
                                     ;
      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);
      everneed = (Elf_External_Verneed *) contents;
      iverneed = ((abfd) -> tdata.elf_obj_data)->verref;
      for (i = 0; i < hdr->sh_info; i++, iverneed++)
 {
   Elf_External_Vernaux *evernaux;
   Elf_Internal_Vernaux *ivernaux;
   unsigned int j;

   _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);

   iverneed->vn_bfd = abfd;

   iverneed->vn_filename =
     bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
          iverneed->vn_file);
   if (iverneed->vn_filename == 
# 8245 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 8245 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   )
     goto error_return_bad_verref;

   if (iverneed->vn_cnt == 0)
     iverneed->vn_auxptr = 
# 8249 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          ((void *)0)
# 8249 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                              ;
   else
     {
       iverneed->vn_auxptr = (struct elf_internal_vernaux *)
                  bfd_alloc2 (abfd, iverneed->vn_cnt,
                              sizeof (Elf_Internal_Vernaux));
       if (iverneed->vn_auxptr == 
# 8255 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                 ((void *)0)
# 8255 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                     )
  goto error_return_verref;
     }

   if (iverneed->vn_aux
       > (size_t) (contents_end - (bfd_byte *) everneed))
     goto error_return_bad_verref;

   evernaux = ((Elf_External_Vernaux *)
        ((bfd_byte *) everneed + iverneed->vn_aux));
   ivernaux = iverneed->vn_auxptr;
   for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)
     {
       _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);

       ivernaux->vna_nodename =
  bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
       ivernaux->vna_name);
       if (ivernaux->vna_nodename == 
# 8273 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                    ((void *)0)
# 8273 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                        )
  goto error_return_bad_verref;

       if (ivernaux->vna_other > freeidx)
  freeidx = ivernaux->vna_other;

       ivernaux->vna_nextptr = 
# 8279 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                              ((void *)0)
# 8279 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  ;
       if (ivernaux->vna_next == 0)
  {
    iverneed->vn_cnt = j + 1;
    break;
  }
       if (j + 1 < iverneed->vn_cnt)
  ivernaux->vna_nextptr = ivernaux + 1;

       if (ivernaux->vna_next
    > (size_t) (contents_end - (bfd_byte *) evernaux))
  goto error_return_bad_verref;

       evernaux = ((Elf_External_Vernaux *)
     ((bfd_byte *) evernaux + ivernaux->vna_next));
     }

   iverneed->vn_nextref = 
# 8296 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
# 8296 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                             ;
   if (iverneed->vn_next == 0)
     break;
   if (i + 1 < hdr->sh_info)
     iverneed->vn_nextref = iverneed + 1;

   if (iverneed->vn_next
       > (size_t) (contents_end - (bfd_byte *) everneed))
     goto error_return_bad_verref;

   everneed = ((Elf_External_Verneed *)
        ((bfd_byte *) everneed + iverneed->vn_next));
 }
      ((abfd) -> tdata.elf_obj_data)->cverrefs = i;

      free (contents);
      contents = 
# 8312 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 8312 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    ;
    }

  if ((((abfd) -> tdata.elf_obj_data) -> dynverdef_section) != 0)
    {
      Elf_Internal_Shdr *hdr;
      Elf_External_Verdef *everdef;
      Elf_Internal_Verdef *iverdef;
      Elf_Internal_Verdef *iverdefarr;
      Elf_Internal_Verdef iverdefmem;
      unsigned int i;
      unsigned int maxidx;
      bfd_byte *contents_end_def, *contents_end_aux;

      hdr = &((abfd) -> tdata.elf_obj_data)->dynverdef_hdr;

      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))
 {
 error_return_bad_verdef:
   _bfd_error_handler
     (dgettext ("bfd", "%B: .gnu.version_d invalid entry"), abfd);
   bfd_set_error (bfd_error_bad_value);
 error_return_verdef:
   ((abfd) -> tdata.elf_obj_data)->verdef = 
# 8335 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             ((void *)0)
# 8335 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                 ;
   ((abfd) -> tdata.elf_obj_data)->cverdefs = 0;
   goto error_return;
 }

      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
      if (contents == 
# 8341 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                     ((void *)0)
# 8341 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                         )
 goto error_return_verdef;
      if (bfd_seek (abfd, hdr->sh_offset, 
# 8343 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                         0
# 8343 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                 ) != 0
   || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)
 goto error_return_verdef;

      do { if (!(sizeof (Elf_External_Verdef) >= sizeof (Elf_External_Verdaux))) bfd_assert("/doner/binutils/binutils-7a31b38/bfd/elf.c",8347); } while (0)
                                     ;
      contents_end_def = contents + hdr->sh_size
    - sizeof (Elf_External_Verdef);
      contents_end_aux = contents + hdr->sh_size
    - sizeof (Elf_External_Verdaux);




      everdef = (Elf_External_Verdef *) contents;
      maxidx = 0;
      for (i = 0; i < hdr->sh_info; ++i)
 {
   _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

   if ((iverdefmem.vd_ndx & ((unsigned) 0x7fff)) == 0)
     goto error_return_bad_verdef;
   if ((iverdefmem.vd_ndx & ((unsigned) 0x7fff)) > maxidx)
     maxidx = iverdefmem.vd_ndx & ((unsigned) 0x7fff);

   if (iverdefmem.vd_next == 0)
     break;

   if (iverdefmem.vd_next
       > (size_t) (contents_end_def - (bfd_byte *) everdef))
     goto error_return_bad_verdef;

   everdef = ((Elf_External_Verdef *)
       ((bfd_byte *) everdef + iverdefmem.vd_next));
 }

      if (default_imported_symver)
 {
   if (freeidx > maxidx)
     maxidx = ++freeidx;
   else
     freeidx = ++maxidx;
 }

      ((abfd) -> tdata.elf_obj_data)->verdef = (Elf_Internal_Verdef *)
 bfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));
      if (((abfd) -> tdata.elf_obj_data)->verdef == 
# 8389 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                     ((void *)0)
# 8389 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                         )
 goto error_return_verdef;

      ((abfd) -> tdata.elf_obj_data)->cverdefs = maxidx;

      everdef = (Elf_External_Verdef *) contents;
      iverdefarr = ((abfd) -> tdata.elf_obj_data)->verdef;
      for (i = 0; i < hdr->sh_info; i++)
 {
   Elf_External_Verdaux *everdaux;
   Elf_Internal_Verdaux *iverdaux;
   unsigned int j;

   _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);

   if ((iverdefmem.vd_ndx & 0x7fff) == 0)
     goto error_return_bad_verdef;

   iverdef = &iverdefarr[(iverdefmem.vd_ndx & 0x7fff) - 1];
   memcpy (iverdef, &iverdefmem, 
# 8408 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                __builtin_offsetof (
# 8408 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                Elf_Internal_Verdef
# 8408 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                , 
# 8408 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                vd_bfd
# 8408 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                )
# 8408 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                      );

   iverdef->vd_bfd = abfd;

   if (iverdef->vd_cnt == 0)
     iverdef->vd_auxptr = 
# 8413 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
# 8413 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                             ;
   else
     {
       iverdef->vd_auxptr = (struct elf_internal_verdaux *)
                  bfd_alloc2 (abfd, iverdef->vd_cnt,
                              sizeof (Elf_Internal_Verdaux));
       if (iverdef->vd_auxptr == 
# 8419 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                ((void *)0)
# 8419 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                    )
  goto error_return_verdef;
     }

   if (iverdef->vd_aux
       > (size_t) (contents_end_aux - (bfd_byte *) everdef))
     goto error_return_bad_verdef;

   everdaux = ((Elf_External_Verdaux *)
        ((bfd_byte *) everdef + iverdef->vd_aux));
   iverdaux = iverdef->vd_auxptr;
   for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)
     {
       _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);

       iverdaux->vda_nodename =
  bfd_elf_string_from_elf_section (abfd, hdr->sh_link,
       iverdaux->vda_name);
       if (iverdaux->vda_nodename == 
# 8437 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                    ((void *)0)
# 8437 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                        )
  goto error_return_bad_verdef;

       iverdaux->vda_nextptr = 
# 8440 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                              ((void *)0)
# 8440 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  ;
       if (iverdaux->vda_next == 0)
  {
    iverdef->vd_cnt = j + 1;
    break;
  }
       if (j + 1 < iverdef->vd_cnt)
  iverdaux->vda_nextptr = iverdaux + 1;

       if (iverdaux->vda_next
    > (size_t) (contents_end_aux - (bfd_byte *) everdaux))
  goto error_return_bad_verdef;

       everdaux = ((Elf_External_Verdaux *)
     ((bfd_byte *) everdaux + iverdaux->vda_next));
     }

   iverdef->vd_nodename = 
# 8457 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                         ((void *)0)
# 8457 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                             ;
   if (iverdef->vd_cnt)
     iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;

   iverdef->vd_nextdef = 
# 8461 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                        ((void *)0)
# 8461 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                            ;
   if (iverdef->vd_next == 0)
     break;
   if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)
     iverdef->vd_nextdef = iverdef + 1;

   everdef = ((Elf_External_Verdef *)
       ((bfd_byte *) everdef + iverdef->vd_next));
 }

      free (contents);
      contents = 
# 8472 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 8472 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    ;
    }
  else if (default_imported_symver)
    {
      if (freeidx < 3)
 freeidx = 3;
      else
 freeidx++;

      ((abfd) -> tdata.elf_obj_data)->verdef = (Elf_Internal_Verdef *)
          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));
      if (((abfd) -> tdata.elf_obj_data)->verdef == 
# 8483 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                     ((void *)0)
# 8483 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                         )
 goto error_return;

      ((abfd) -> tdata.elf_obj_data)->cverdefs = freeidx;
    }


  if (default_imported_symver)
    {
      Elf_Internal_Verdef *iverdef;
      Elf_Internal_Verdaux *iverdaux;

      iverdef = &((abfd) -> tdata.elf_obj_data)->verdef[freeidx - 1];

      iverdef->vd_version = 1;
      iverdef->vd_flags = 0;
      iverdef->vd_ndx = freeidx;
      iverdef->vd_cnt = 1;

      iverdef->vd_bfd = abfd;

      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);
      if (iverdef->vd_nodename == 
# 8505 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                 ((void *)0)
# 8505 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                     )
 goto error_return_verdef;
      iverdef->vd_nextdef = 
# 8507 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                           ((void *)0)
# 8507 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                               ;
      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)
       bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));
      if (iverdef->vd_auxptr == 
# 8510 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                               ((void *)0)
# 8510 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                   )
 goto error_return_verdef;

      iverdaux = iverdef->vd_auxptr;
      iverdaux->vda_nodename = iverdef->vd_nodename;
    }

  return 1;

 error_return:
  if (contents != 
# 8520 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 8520 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
    free (contents);
  return 0;
}

asymbol *
_bfd_elf_make_empty_symbol (bfd *abfd)
{
  elf_symbol_type *newsym;

  newsym = (elf_symbol_type *) bfd_zalloc (abfd, sizeof * newsym);
  if (!newsym)
    return 
# 8532 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 8532 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;
  newsym->symbol.the_bfd = abfd;
  return &newsym->symbol;
}

void
_bfd_elf_get_symbol_info (bfd *abfd __attribute__ ((__unused__)),
     asymbol *symbol,
     symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);
}





bfd_boolean
_bfd_elf_is_local_label_name (bfd *abfd __attribute__ ((__unused__)),
         const char *name)
{

  if (name[0] == '.' && name[1] == 'L')
    return 1;



  if (name[0] == '.' && name[1] == '.')
    return 1;







  if (name[0] == '_' && name[1] == '.' && name[2] == 'L' && name[3] == '_')
    return 1;
# 8581 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
  if (name[0] == 'L' && (_sch_istable[(name[1]) & 0xff] & (unsigned short)(_sch_isdigit)))
    {
      bfd_boolean ret = 0;
      const char * p;
      char c;

      for (p = name + 2; (c = *p); p++)
 {
   if (c == 1 || c == 2)
     {
       if (c == 1 && p == name + 2)

  return 1;






       ret = 1;
     }

   if (! (_sch_istable[(c) & 0xff] & (unsigned short)(_sch_isdigit)))
     {
       ret = 0;
       break;
     }
 }
      return ret;
    }

  return 0;
}

alent *
_bfd_elf_get_lineno (bfd *abfd __attribute__ ((__unused__)),
       asymbol *symbol __attribute__ ((__unused__)))
{
  _bfd_abort ("/doner/binutils/binutils-7a31b38/bfd/elf.c", 8619, __PRETTY_FUNCTION__);
  return 
# 8620 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
        ((void *)0)
# 8620 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
            ;
}

bfd_boolean
_bfd_elf_set_arch_mach (bfd *abfd,
   enum bfd_architecture arch,
   unsigned long machine)
{


  if (arch != ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->arch
      && arch != bfd_arch_unknown
      && ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->arch != bfd_arch_unknown)
    return 0;

  return bfd_default_set_arch_mach (abfd, arch, machine);
}




bfd_boolean
_bfd_elf_find_nearest_line (bfd *abfd,
       asymbol **symbols,
       asection *section,
       bfd_vma offset,
       const char **filename_ptr,
       const char **functionname_ptr,
       unsigned int *line_ptr,
       unsigned int *discriminator_ptr)
{
  bfd_boolean found;

  if (_bfd_dwarf2_find_nearest_line (abfd, symbols, 
# 8653 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                   ((void *)0)
# 8653 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                       , section, offset,
         filename_ptr, functionname_ptr,
         line_ptr, discriminator_ptr,
         dwarf_debug_sections, 0,
         &((abfd) -> tdata.elf_obj_data)->dwarf2_find_line_info)
      || _bfd_dwarf1_find_nearest_line (abfd, symbols, section, offset,
     filename_ptr, functionname_ptr,
     line_ptr))
    {
      if (!*functionname_ptr)
 _bfd_elf_find_function (abfd, symbols, section, offset,
    *filename_ptr ? 
# 8664 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                   ((void *)0) 
# 8664 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                        : filename_ptr,
    functionname_ptr);
      return 1;
    }

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
          &found, filename_ptr,
          functionname_ptr, line_ptr,
          &((abfd) -> tdata.elf_obj_data)->line_info))
    return 0;
  if (found && (*functionname_ptr || *line_ptr))
    return 1;

  if (symbols == 
# 8677 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 8677 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    )
    return 0;

  if (! _bfd_elf_find_function (abfd, symbols, section, offset,
    filename_ptr, functionname_ptr))
    return 0;

  *line_ptr = 0;
  return 1;
}



bfd_boolean
_bfd_elf_find_line (bfd *abfd, asymbol **symbols, asymbol *symbol,
      const char **filename_ptr, unsigned int *line_ptr)
{
  return _bfd_dwarf2_find_nearest_line (abfd, symbols, symbol, 
# 8694 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                              ((void *)0)
# 8694 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                  , 0,
     filename_ptr, 
# 8695 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 8695 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      , line_ptr, 
# 8695 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                  ((void *)0)
# 8695 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                      ,
     dwarf_debug_sections, 0,
     &((abfd) -> tdata.elf_obj_data)->dwarf2_find_line_info);
}







bfd_boolean
_bfd_elf_find_inliner_info (bfd *abfd,
       const char **filename_ptr,
       const char **functionname_ptr,
       unsigned int *line_ptr)
{
  bfd_boolean found;
  found = _bfd_dwarf2_find_inliner_info (abfd, filename_ptr,
      functionname_ptr, line_ptr,
      & ((abfd) -> tdata.elf_obj_data)->dwarf2_find_line_info);
  return found;
}

int
_bfd_elf_sizeof_headers (bfd *abfd, struct bfd_link_info *info)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  int ret = bed->s->sizeof_ehdr;

  if (!((info)->type == type_relocatable))
    {
      bfd_size_type phdr_size = (((abfd) -> tdata.elf_obj_data) -> o->program_header_size);

      if (phdr_size == (bfd_size_type) -1)
 {
   struct elf_segment_map *m;

   phdr_size = 0;
   for (m = (((abfd) -> tdata.elf_obj_data) -> o->seg_map); m != 
# 8734 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                    ((void *)0)
# 8734 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                        ; m = m->next)
     phdr_size += bed->s->sizeof_phdr;

   if (phdr_size == 0)
     phdr_size = get_program_header_size (abfd, info);
 }

      (((abfd) -> tdata.elf_obj_data) -> o->program_header_size) = phdr_size;
      ret += phdr_size;
    }

  return ret;
}

bfd_boolean
_bfd_elf_set_section_contents (bfd *abfd,
          sec_ptr section,
          const void *location,
          file_ptr offset,
          bfd_size_type count)
{
  Elf_Internal_Shdr *hdr;
  file_ptr pos;

  if (! abfd->output_has_begun
      && ! _bfd_elf_compute_section_file_positions (abfd, 
# 8759 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                         ((void *)0)
# 8759 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                             ))
    return 0;

  if (!count)
    return 1;

  hdr = &((struct bfd_elf_section_data*)(section)->used_by_bfd)->this_hdr;
  if (hdr->sh_offset == (file_ptr) -1)
    {

      unsigned char *contents = hdr->contents;
      if ((offset + count) > hdr->sh_size
   || (section->flags & 0x8000000) == 0
   || contents == 
# 8772 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 8772 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
 _bfd_abort ("/doner/binutils/binutils-7a31b38/bfd/elf.c", 8773, __PRETTY_FUNCTION__);
      memcpy (contents + offset, location, count);
      return 1;
    }
  pos = hdr->sh_offset + offset;
  if (bfd_seek (abfd, pos, 
# 8778 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                          0
# 8778 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                  ) != 0
      || bfd_bwrite (location, count, abfd) != count)
    return 0;

  return 1;
}

void
_bfd_elf_no_info_to_howto (bfd *abfd __attribute__ ((__unused__)),
      arelent *cache_ptr __attribute__ ((__unused__)),
      Elf_Internal_Rela *dst __attribute__ ((__unused__)))
{
  _bfd_abort ("/doner/binutils/binutils-7a31b38/bfd/elf.c", 8790, __PRETTY_FUNCTION__);
}



bfd_boolean
_bfd_elf_validate_reloc (bfd *abfd, arelent *areloc)
{


  if ((*areloc->sym_ptr_ptr)->the_bfd->xvec != abfd->xvec)
    {
      bfd_reloc_code_real_type code;
      reloc_howto_type *howto;




      if (areloc->howto->pc_relative)
 {
   switch (areloc->howto->bitsize)
     {
     case 8:
       code = BFD_RELOC_8_PCREL;
       break;
     case 12:
       code = BFD_RELOC_12_PCREL;
       break;
     case 16:
       code = BFD_RELOC_16_PCREL;
       break;
     case 24:
       code = BFD_RELOC_24_PCREL;
       break;
     case 32:
       code = BFD_RELOC_32_PCREL;
       break;
     case 64:
       code = BFD_RELOC_64_PCREL;
       break;
     default:
       goto fail;
     }

   howto = bfd_reloc_type_lookup (abfd, code);

   if (areloc->howto->pcrel_offset != howto->pcrel_offset)
     {
       if (howto->pcrel_offset)
  areloc->addend += areloc->address;
       else
  areloc->addend -= areloc->address;
     }
 }
      else
 {
   switch (areloc->howto->bitsize)
     {
     case 8:
       code = BFD_RELOC_8;
       break;
     case 14:
       code = BFD_RELOC_14;
       break;
     case 16:
       code = BFD_RELOC_16;
       break;
     case 26:
       code = BFD_RELOC_26;
       break;
     case 32:
       code = BFD_RELOC_32;
       break;
     case 64:
       code = BFD_RELOC_64;
       break;
     default:
       goto fail;
     }

   howto = bfd_reloc_type_lookup (abfd, code);
 }

      if (howto)
 areloc->howto = howto;
      else
 goto fail;
    }

  return 1;

 fail:
  _bfd_error_handler

    (dgettext ("bfd", "%B: unsupported relocation type %s"),
     abfd, areloc->howto->name);
  bfd_set_error (bfd_error_bad_value);
  return 0;
}

bfd_boolean
_bfd_elf_close_and_cleanup (bfd *abfd)
{
  struct elf_obj_tdata *tdata = ((abfd) -> tdata.elf_obj_data);
  if (((abfd)->format) == bfd_object && tdata != 
# 8894 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                     ((void *)0)
# 8894 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                         )
    {
      if (((abfd) -> tdata.elf_obj_data)->o != 
# 8896 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                ((void *)0) 
# 8896 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                     && (((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr) != 
# 8896 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                                               ((void *)0)
# 8896 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                                   )
 _bfd_elf_strtab_free ((((abfd) -> tdata.elf_obj_data) -> o->strtab_ptr));
      _bfd_dwarf2_cleanup_debug_info (abfd, &tdata->dwarf2_find_line_info);
    }

  return _bfd_archive_close_and_cleanup (abfd);
}






bfd_reloc_status_type
_bfd_elf_rel_vtable_reloc_fn
  (bfd *abfd __attribute__ ((__unused__)), arelent *re __attribute__ ((__unused__)),
   struct bfd_symbol *symbol __attribute__ ((__unused__)),
   void *data __attribute__ ((__unused__)), asection *is __attribute__ ((__unused__)),
   bfd *obfd __attribute__ ((__unused__)), char **errmsg __attribute__ ((__unused__)))
{
  return bfd_reloc_ok;
}
# 8933 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
static int
elfcore_make_pid (bfd *abfd)
{
  int pid;

  pid = ((abfd) -> tdata.elf_obj_data)->core->lwpid;
  if (pid == 0)
    pid = ((abfd) -> tdata.elf_obj_data)->core->pid;

  return pid;
}






static bfd_boolean
elfcore_maybe_make_sect (bfd *abfd, char *name, asection *sect)
{
  asection *sect2;

  if (bfd_get_section_by_name (abfd, name) != 
# 8955 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                             ((void *)0)
# 8955 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                                 )
    return 1;

  sect2 = bfd_make_section_with_flags (abfd, name, sect->flags);
  if (sect2 == 
# 8959 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
              ((void *)0)
# 8959 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                  )
    return 0;

  sect2->size = sect->size;
  sect2->filepos = sect->filepos;
  sect2->alignment_power = sect->alignment_power;
  return 1;
}
# 8975 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
bfd_boolean
_bfd_elfcore_make_pseudosection (bfd *abfd,
     char *name,
     size_t size,
     ufile_ptr filepos)
{
  char buf[100];
  char *threaded_name;
  size_t len;
  asection *sect;



  sprintf (buf, "%s/%d", name, elfcore_make_pid (abfd));
  len = strlen (buf) + 1;
  threaded_name = (char *) bfd_alloc (abfd, len);
  if (threaded_name == 
# 8991 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                      ((void *)0)
# 8991 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                          )
    return 0;
  memcpy (threaded_name, buf, len);

  sect = bfd_make_section_anyway_with_flags (abfd, threaded_name,
          0x100);
  if (sect == 
# 8997 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 8997 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 0;
  sect->size = size;
  sect->filepos = filepos;
  sect->alignment_power = 2;

  return elfcore_maybe_make_sect (abfd, name, sect);
}
# 9014 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
static bfd_boolean
elfcore_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  size_t size;
  int offset;

  if (note->descsz == sizeof (prstatus_t))
    {
      prstatus_t prstat;

      size = sizeof (prstat.pr_reg);
      offset = 
# 9025 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                __builtin_offsetof (
# 9025 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                prstatus_t
# 9025 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                , 
# 9025 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                pr_reg
# 9025 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                )
# 9025 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                             ;
      memcpy (&prstat, note->descdata, sizeof (prstat));



      if (((abfd) -> tdata.elf_obj_data)->core->signal == 0)
 ((abfd) -> tdata.elf_obj_data)->core->signal = prstat.pr_cursig;
      if (((abfd) -> tdata.elf_obj_data)->core->pid == 0)
 ((abfd) -> tdata.elf_obj_data)->core->pid = prstat.pr_pid;
# 9044 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      ((abfd) -> tdata.elf_obj_data)->core->lwpid = prstat.pr_pid;

    }

  else if (note->descsz == sizeof (prstatus32_t))
    {

      prstatus32_t prstat;

      size = sizeof (prstat.pr_reg);
      offset = 
# 9054 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                __builtin_offsetof (
# 9054 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                prstatus32_t
# 9054 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                , 
# 9054 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                pr_reg
# 9054 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                )
# 9054 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                               ;
      memcpy (&prstat, note->descdata, sizeof (prstat));



      if (((abfd) -> tdata.elf_obj_data)->core->signal == 0)
 ((abfd) -> tdata.elf_obj_data)->core->signal = prstat.pr_cursig;
      if (((abfd) -> tdata.elf_obj_data)->core->pid == 0)
 ((abfd) -> tdata.elf_obj_data)->core->pid = prstat.pr_pid;
# 9073 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
      ((abfd) -> tdata.elf_obj_data)->core->lwpid = prstat.pr_pid;

    }

  else
    {


      return 1;
    }


  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
       size, note->descpos + offset);
}



static bfd_boolean
elfcore_make_note_pseudosection (bfd *abfd,
     char *name,
     Elf_Internal_Note *note)
{
  return _bfd_elfcore_make_pseudosection (abfd, name,
       note->descsz, note->descpos);
}





static bfd_boolean
elfcore_grok_prfpreg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg2", note);
}





static bfd_boolean
elfcore_grok_prxfpreg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-xfp", note);
}





static bfd_boolean
elfcore_grok_xstatereg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-xstate", note);
}

static bfd_boolean
elfcore_grok_ppc_vmx (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-ppc-vmx", note);
}

static bfd_boolean
elfcore_grok_ppc_vsx (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-ppc-vsx", note);
}

static bfd_boolean
elfcore_grok_s390_high_gprs (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-high-gprs", note);
}

static bfd_boolean
elfcore_grok_s390_timer (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-timer", note);
}

static bfd_boolean
elfcore_grok_s390_todcmp (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-todcmp", note);
}

static bfd_boolean
elfcore_grok_s390_todpreg (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-todpreg", note);
}

static bfd_boolean
elfcore_grok_s390_ctrs (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-ctrs", note);
}

static bfd_boolean
elfcore_grok_s390_prefix (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-prefix", note);
}

static bfd_boolean
elfcore_grok_s390_last_break (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-last-break", note);
}

static bfd_boolean
elfcore_grok_s390_system_call (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-system-call", note);
}

static bfd_boolean
elfcore_grok_s390_tdb (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-tdb", note);
}

static bfd_boolean
elfcore_grok_s390_vxrs_low (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-vxrs-low", note);
}

static bfd_boolean
elfcore_grok_s390_vxrs_high (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-vxrs-high", note);
}

static bfd_boolean
elfcore_grok_s390_gs_cb (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-gs-cb", note);
}

static bfd_boolean
elfcore_grok_s390_gs_bc (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-s390-gs-bc", note);
}

static bfd_boolean
elfcore_grok_arm_vfp (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-arm-vfp", note);
}

static bfd_boolean
elfcore_grok_aarch_tls (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-aarch-tls", note);
}

static bfd_boolean
elfcore_grok_aarch_hw_break (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-aarch-hw-break", note);
}

static bfd_boolean
elfcore_grok_aarch_hw_watch (bfd *abfd, Elf_Internal_Note *note)
{
  return elfcore_make_note_pseudosection (abfd, ".reg-aarch-hw-watch", note);
}


typedef prpsinfo_t elfcore_psinfo_t;

typedef prpsinfo32_t elfcore_psinfo32_t;
# 9262 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
char *
_bfd_elfcore_strndup (bfd *abfd, char *start, size_t max)
{
  char *dups;
  char *end = (char *) memchr (start, '\0', max);
  size_t len;

  if (end == 
# 9269 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 9269 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
    len = max;
  else
    len = end - start;

  dups = (char *) bfd_alloc (abfd, len + 1);
  if (dups == 
# 9275 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 9275 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 
# 9276 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 9276 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              ;

  memcpy (dups, start, len);
  dups[len] = '\0';

  return dups;
}


static bfd_boolean
elfcore_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->descsz == sizeof (elfcore_psinfo_t))
    {
      elfcore_psinfo_t psinfo;

      memcpy (&psinfo, note->descdata, sizeof (psinfo));


      ((abfd) -> tdata.elf_obj_data)->core->pid = psinfo.pr_pid;

      ((abfd) -> tdata.elf_obj_data)->core->program
 = _bfd_elfcore_strndup (abfd, psinfo.pr_fname,
    sizeof (psinfo.pr_fname));

      ((abfd) -> tdata.elf_obj_data)->core->command
 = _bfd_elfcore_strndup (abfd, psinfo.pr_psargs,
    sizeof (psinfo.pr_psargs));
    }

  else if (note->descsz == sizeof (elfcore_psinfo32_t))
    {

      elfcore_psinfo32_t psinfo;

      memcpy (&psinfo, note->descdata, sizeof (psinfo));


      ((abfd) -> tdata.elf_obj_data)->core->pid = psinfo.pr_pid;

      ((abfd) -> tdata.elf_obj_data)->core->program
 = _bfd_elfcore_strndup (abfd, psinfo.pr_fname,
    sizeof (psinfo.pr_fname));

      ((abfd) -> tdata.elf_obj_data)->core->command
 = _bfd_elfcore_strndup (abfd, psinfo.pr_psargs,
    sizeof (psinfo.pr_psargs));
    }


  else
    {


      return 1;
    }





  {
    char *command = ((abfd) -> tdata.elf_obj_data)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return 1;
}
# 9468 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
static bfd_boolean
elfcore_grok_win32pstatus (bfd *abfd, Elf_Internal_Note *note)
{
  char buf[30];
  char *name;
  size_t len;
  asection *sect;
  int type;
  int is_active_thread;
  bfd_vma base_addr;

  if (note->descsz < 728)
    return 1;

  if (! (strncmp ((note->namedata), ("win32"), sizeof ("win32") - 1) == 0))
    return 1;

  type = ((*((abfd)->xvec->bfd_getx32)) (note->descdata));

  switch (type)
    {
    case 1 :


      ((abfd) -> tdata.elf_obj_data)->core->pid = ((*((abfd)->xvec->bfd_getx32)) (note->descdata + 8));

      ((abfd) -> tdata.elf_obj_data)->core->signal = ((*((abfd)->xvec->bfd_getx32)) (note->descdata + 12));
      break;

    case 2 :


      sprintf (buf, ".reg/%ld", (long) ((*((abfd)->xvec->bfd_getx32)) (note->descdata + 8)));

      len = strlen (buf) + 1;
      name = (char *) bfd_alloc (abfd, len);
      if (name == 
# 9504 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 9504 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
 return 0;

      memcpy (name, buf, len);

      sect = bfd_make_section_anyway_with_flags (abfd, name, 0x100);
      if (sect == 
# 9510 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 9510 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
 return 0;


      sect->size = 716;

      sect->filepos = note->descpos + 12;
      sect->alignment_power = 2;


      is_active_thread = ((*((abfd)->xvec->bfd_getx32)) (note->descdata + 8));

      if (is_active_thread)
 if (! elfcore_maybe_make_sect (abfd, ".reg", sect))
   return 0;
      break;

    case 3 :


      base_addr = ((*((abfd)->xvec->bfd_getx32)) (note->descdata + 4));
      sprintf (buf, ".module/%08lx", (unsigned long) base_addr);

      len = strlen (buf) + 1;
      name = (char *) bfd_alloc (abfd, len);
      if (name == 
# 9535 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 9535 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
 return 0;

      memcpy (name, buf, len);

      sect = bfd_make_section_anyway_with_flags (abfd, name, 0x100);

      if (sect == 
# 9542 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 9542 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
 return 0;

      sect->size = note->descsz;
      sect->filepos = note->descpos;
      sect->alignment_power = 2;
      break;

    default:
      return 1;
    }

  return 1;
}

static bfd_boolean
elfcore_grok_note (bfd *abfd, Elf_Internal_Note *note)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  switch (note->type)
    {
    default:
      return 1;

    case 1:
      if (bed->elf_backend_grok_prstatus)
 if ((*bed->elf_backend_grok_prstatus) (abfd, note))
   return 1;

      return elfcore_grok_prstatus (abfd, note);
# 9587 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
    case 2:
      return elfcore_grok_prfpreg (abfd, note);

    case 18:
      return elfcore_grok_win32pstatus (abfd, note);

    case 0x46e62b7f:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_prxfpreg (abfd, note);
      else
 return 1;

    case 0x202:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_xstatereg (abfd, note);
      else
 return 1;

    case 0x100:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_ppc_vmx (abfd, note);
      else
 return 1;

    case 0x102:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_ppc_vsx (abfd, note);
      else
        return 1;

    case 0x300:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_high_gprs (abfd, note);
      else
        return 1;

    case 0x301:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_timer (abfd, note);
      else
        return 1;

    case 0x302:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_todcmp (abfd, note);
      else
        return 1;

    case 0x303:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_todpreg (abfd, note);
      else
        return 1;

    case 0x304:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_ctrs (abfd, note);
      else
        return 1;

    case 0x305:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_prefix (abfd, note);
      else
        return 1;

    case 0x306:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_last_break (abfd, note);
      else
        return 1;

    case 0x307:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_system_call (abfd, note);
      else
        return 1;

    case 0x308:
      if (note->namesz == 6
          && strcmp (note->namedata, "LINUX") == 0)
        return elfcore_grok_s390_tdb (abfd, note);
      else
        return 1;

    case 0x309:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_s390_vxrs_low (abfd, note);
      else
 return 1;

    case 0x30a:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_s390_vxrs_high (abfd, note);
      else
 return 1;

    case 0x30b:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_s390_gs_bc (abfd, note);
      else
 return 1;

    case 0x30c:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_s390_gs_cb (abfd, note);
      else
 return 1;

    case 0x400:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_arm_vfp (abfd, note);
      else
 return 1;

    case 0x401:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_aarch_tls (abfd, note);
      else
 return 1;

    case 0x402:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_aarch_hw_break (abfd, note);
      else
 return 1;

    case 0x403:
      if (note->namesz == 6
   && strcmp (note->namedata, "LINUX") == 0)
 return elfcore_grok_aarch_hw_watch (abfd, note);
      else
 return 1;

    case 3:
    case 13:
      if (bed->elf_backend_grok_psinfo)
 if ((*bed->elf_backend_grok_psinfo) (abfd, note))
   return 1;

      return elfcore_grok_psinfo (abfd, note);




    case 6:
      {
 asection *sect = bfd_make_section_anyway_with_flags (abfd, ".auxv",
            0x100);

 if (sect == 
# 9756 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 9756 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
   return 0;
 sect->size = note->descsz;
 sect->filepos = note->descpos;
 sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

 return 1;
      }

    case 0x46494c45:
      return elfcore_make_note_pseudosection (abfd, ".note.linuxcore.file",
           note);

    case 0x53494749:
      return elfcore_make_note_pseudosection (abfd, ".note.linuxcore.siginfo",
           note);

    }
}

static bfd_boolean
elfobj_grok_gnu_build_id (bfd *abfd, Elf_Internal_Note *note)
{
  struct bfd_build_id* build_id;

  if (note->descsz == 0)
    return 0;

  build_id = bfd_alloc (abfd, sizeof (struct bfd_build_id) - 1 + note->descsz);
  if (build_id == 
# 9785 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 9785 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
    return 0;

  build_id->size = note->descsz;
  memcpy (build_id->data, note->descdata, note->descsz);
  abfd->build_id = build_id;

  return 1;
}

static bfd_boolean
elfobj_grok_gnu_note (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->type)
    {
    default:
      return 1;

    case 5:
      return _bfd_elf_parse_gnu_properties (abfd, note);

    case 3:
      return elfobj_grok_gnu_build_id (abfd, note);
    }
}

static bfd_boolean
elfobj_grok_stapsdt_note_1 (bfd *abfd, Elf_Internal_Note *note)
{
  struct sdt_note *cur =
    (struct sdt_note *) bfd_alloc (abfd, sizeof (struct sdt_note)
       + note->descsz);

  cur->next = (struct sdt_note *) (((abfd) -> tdata.elf_obj_data))->sdt_note_head;
  cur->size = (bfd_size_type) note->descsz;
  memcpy (cur->data, note->descdata, note->descsz);

  ((abfd) -> tdata.elf_obj_data)->sdt_note_head = cur;

  return 1;
}

static bfd_boolean
elfobj_grok_stapsdt_note (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->type)
    {
    case 3:
      return elfobj_grok_stapsdt_note_1 (abfd, note);

    default:
      return 1;
    }
}

static bfd_boolean
elfcore_grok_freebsd_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  size_t offset;

  switch ((((abfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[4])
    {
    case 1:
      if (note->descsz < 108)
 return 0;
      break;

    case 2:
      if (note->descsz < 120)
 return 0;
      break;

    default:
      return 0;
    }


  if (((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata)) != 1)
    return 0;
  offset = 4;


  if ((((abfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[4] == 1)
    offset += 4;
  else
    {
      offset += 4;
      offset += 8;
    }


  ((abfd) -> tdata.elf_obj_data)->core->program
    = _bfd_elfcore_strndup (abfd, note->descdata + offset, 17);
  offset += 17;


  ((abfd) -> tdata.elf_obj_data)->core->command
    = _bfd_elfcore_strndup (abfd, note->descdata + offset, 81);
  offset += 81;


  offset += 2;


  if (note->descsz < offset + 4)
    return 1;

  ((abfd) -> tdata.elf_obj_data)->core->pid
    = ((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata + offset));

  return 1;
}

static bfd_boolean
elfcore_grok_freebsd_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  size_t offset;
  size_t size;
  size_t min_size;



  switch ((((abfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[4])
    {
    case 1:
      offset = 4 + 4;
      min_size = offset + (4 * 2) + 4 + 4 + 4;
      break;

    case 2:
      offset = 4 + 4 + 8;
      min_size = offset + (8 * 2) + 4 + 4 + 4 + 4;
      break;

    default:
      return 0;
    }

  if (note->descsz < min_size)
    return 0;


  if (((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata)) != 1)
    return 0;



  if ((((abfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[4] == 1)
    {
      size = ((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata + offset));
      offset += 4 * 2;
    }
  else
    {
      size = ((*((abfd)->xvec->bfd_h_getx64)) ((bfd_byte *) note->descdata + offset));
      offset += 8 * 2;
    }


  offset += 4;


  if (((abfd) -> tdata.elf_obj_data)->core->signal == 0)
    ((abfd) -> tdata.elf_obj_data)->core->signal
      = ((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata + offset));
  offset += 4;


  ((abfd) -> tdata.elf_obj_data)->core->lwpid
      = ((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata + offset));
  offset += 4;


  if ((((abfd) -> tdata.elf_obj_data) -> elf_header)->e_ident[4] == 2)
    offset += 4;


  if ((note->descsz - offset) < size)
    return 0;


  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
       size, note->descpos + offset);
}

static bfd_boolean
elfcore_grok_freebsd_note (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->type)
    {
    case 1:
      return elfcore_grok_freebsd_prstatus (abfd, note);

    case 2:
      return elfcore_grok_prfpreg (abfd, note);

    case 3:
      return elfcore_grok_freebsd_psinfo (abfd, note);

    case 7:
      if (note->namesz == 8)
 return elfcore_make_note_pseudosection (abfd, ".thrmisc", note);
      else
 return 1;

    case 16:
      {
 asection *sect = bfd_make_section_anyway_with_flags (abfd, ".auxv",
            0x100);

 if (sect == 
# 9995 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 9995 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
   return 0;
 sect->size = note->descsz - 4;
 sect->filepos = note->descpos + 4;
 sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

 return 1;
      }

    case 0x202:
      if (note->namesz == 8)
 return elfcore_grok_xstatereg (abfd, note);
      else
 return 1;

    default:
      return 1;
    }
}

static bfd_boolean
elfcore_netbsd_get_lwpid (Elf_Internal_Note *note, int *lwpidp)
{
  char *cp;

  cp = strchr (note->namedata, '@');
  if (cp != 
# 10021 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
           ((void *)0)
# 10021 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
               )
    {
      *lwpidp = atoi(cp + 1);
      return 1;
    }
  return 0;
}

static bfd_boolean
elfcore_grok_netbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
{

  ((abfd) -> tdata.elf_obj_data)->core->signal
    = ((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata + 0x08));


  ((abfd) -> tdata.elf_obj_data)->core->pid
    = ((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata + 0x50));


  ((abfd) -> tdata.elf_obj_data)->core->command
    = _bfd_elfcore_strndup (abfd, note->descdata + 0x7c, 31);

  return elfcore_make_note_pseudosection (abfd, ".note.netbsdcore.procinfo",
       note);
}

static bfd_boolean
elfcore_grok_netbsd_note (bfd *abfd, Elf_Internal_Note *note)
{
  int lwp;

  if (elfcore_netbsd_get_lwpid (note, &lwp))
    ((abfd) -> tdata.elf_obj_data)->core->lwpid = lwp;

  if (note->type == 1)
    {





      return elfcore_grok_netbsd_procinfo (abfd, note);
    }






  if (note->type < 32)
    return 1;


  switch (bfd_get_arch (abfd))
    {



    case bfd_arch_alpha:
    case bfd_arch_sparc:
      switch (note->type)
 {
 case 32 +0:
   return elfcore_make_note_pseudosection (abfd, ".reg", note);

 case 32 +2:
   return elfcore_make_note_pseudosection (abfd, ".reg2", note);

 default:
   return 1;
 }




    default:
      switch (note->type)
 {
 case 32 +1:
   return elfcore_make_note_pseudosection (abfd, ".reg", note);

 case 32 +3:
   return elfcore_make_note_pseudosection (abfd, ".reg2", note);

 default:
   return 1;
 }
    }

}

static bfd_boolean
elfcore_grok_openbsd_procinfo (bfd *abfd, Elf_Internal_Note *note)
{

  ((abfd) -> tdata.elf_obj_data)->core->signal
    = ((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata + 0x08));


  ((abfd) -> tdata.elf_obj_data)->core->pid
    = ((*((abfd)->xvec->bfd_h_getx32)) ((bfd_byte *) note->descdata + 0x20));


  ((abfd) -> tdata.elf_obj_data)->core->command
    = _bfd_elfcore_strndup (abfd, note->descdata + 0x48, 31);

  return 1;
}

static bfd_boolean
elfcore_grok_openbsd_note (bfd *abfd, Elf_Internal_Note *note)
{
  if (note->type == 10)
    return elfcore_grok_openbsd_procinfo (abfd, note);

  if (note->type == 20)
    return elfcore_make_note_pseudosection (abfd, ".reg", note);

  if (note->type == 21)
    return elfcore_make_note_pseudosection (abfd, ".reg2", note);

  if (note->type == 22)
    return elfcore_make_note_pseudosection (abfd, ".reg-xfp", note);

  if (note->type == 11)
    {
      asection *sect = bfd_make_section_anyway_with_flags (abfd, ".auxv",
          0x100);

      if (sect == 
# 10151 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 10151 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
 return 0;
      sect->size = note->descsz;
      sect->filepos = note->descpos;
      sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

      return 1;
    }

  if (note->type == 23)
    {
      asection *sect = bfd_make_section_anyway_with_flags (abfd, ".wcookie",
          0x100);

      if (sect == 
# 10165 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                 ((void *)0)
# 10165 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                     )
 return 0;
      sect->size = note->descsz;
      sect->filepos = note->descpos;
      sect->alignment_power = 1 + bfd_get_arch_size (abfd) / 32;

      return 1;
    }

  return 1;
}

static bfd_boolean
elfcore_grok_nto_status (bfd *abfd, Elf_Internal_Note *note, long *tid)
{
  void *ddata = note->descdata;
  char buf[100];
  char *name;
  asection *sect;
  short sig;
  unsigned flags;


  ((abfd) -> tdata.elf_obj_data)->core->pid = ((*((abfd)->xvec->bfd_getx32)) ((bfd_byte *) ddata));


  *tid = ((*((abfd)->xvec->bfd_getx32)) ((bfd_byte *) ddata + 4));


  flags = ((*((abfd)->xvec->bfd_getx32)) ((bfd_byte *) ddata + 8));


  if ((sig = ((*((abfd)->xvec->bfd_getx16)) ((bfd_byte *) ddata + 14))) > 0)
    {
      ((abfd) -> tdata.elf_obj_data)->core->signal = sig;
      ((abfd) -> tdata.elf_obj_data)->core->lwpid = *tid;
    }




  if (flags & 0x00000080)
    ((abfd) -> tdata.elf_obj_data)->core->lwpid = *tid;


  sprintf (buf, ".qnx_core_status/%ld", *tid);

  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
  if (name == 
# 10213 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 10213 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 0;
  strcpy (name, buf);

  sect = bfd_make_section_anyway_with_flags (abfd, name, 0x100);
  if (sect == 
# 10218 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 10218 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 0;

  sect->size = note->descsz;
  sect->filepos = note->descpos;
  sect->alignment_power = 2;

  return (elfcore_maybe_make_sect (abfd, ".qnx_core_status", sect));
}

static bfd_boolean
elfcore_grok_nto_regs (bfd *abfd,
         Elf_Internal_Note *note,
         long tid,
         char *base)
{
  char buf[100];
  char *name;
  asection *sect;


  sprintf (buf, "%s/%ld", base, tid);

  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
  if (name == 
# 10242 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 10242 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 0;
  strcpy (name, buf);

  sect = bfd_make_section_anyway_with_flags (abfd, name, 0x100);
  if (sect == 
# 10247 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 10247 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 0;

  sect->size = note->descsz;
  sect->filepos = note->descpos;
  sect->alignment_power = 2;


  if (((abfd) -> tdata.elf_obj_data)->core->lwpid == tid)
    return elfcore_maybe_make_sect (abfd, base, sect);

  return 1;
}






static bfd_boolean
elfcore_grok_nto_note (bfd *abfd, Elf_Internal_Note *note)
{



  static long tid = 1;

  switch (note->type)
    {
    case 7:
      return elfcore_make_note_pseudosection (abfd, ".qnx_core_info", note);
    case 8:
      return elfcore_grok_nto_status (abfd, note, &tid);
    case 9:
      return elfcore_grok_nto_regs (abfd, note, tid, ".reg");
    case 10:
      return elfcore_grok_nto_regs (abfd, note, tid, ".reg2");
    default:
      return 1;
    }
}

static bfd_boolean
elfcore_grok_spu_note (bfd *abfd, Elf_Internal_Note *note)
{
  char *name;
  asection *sect;
  size_t len;


  len = note->namesz;
  name = (char *) bfd_alloc (abfd, len);
  if (name == 
# 10299 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 10299 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 0;
  memcpy (name, note->namedata, len);
  name[len - 1] = '\0';

  sect = bfd_make_section_anyway_with_flags (abfd, name, 0x100);
  if (sect == 
# 10305 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 10305 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    return 0;

  sect->size = note->descsz;
  sect->filepos = note->descpos;
  sect->alignment_power = 1;

  return 1;
}
# 10332 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
char *
elfcore_write_note (bfd *abfd,
      char *buf,
      int *bufsiz,
      const char *name,
      int type,
      const void *input,
      int size)
{
  Elf_External_Note *xnp;
  size_t namesz;
  size_t newspace;
  char *dest;

  namesz = 0;
  if (name != 
# 10347 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 10347 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    namesz = strlen (name) + 1;

  newspace = 12 + ((namesz + 3) & -4) + ((size + 3) & -4);

  buf = (char *) realloc (buf, *bufsiz + newspace);
  if (buf == 
# 10353 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 10353 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
    return buf;
  dest = buf + *bufsiz;
  *bufsiz += newspace;
  xnp = (Elf_External_Note *) dest;
  ((*((abfd)->xvec->bfd_h_putx32)) (namesz, xnp->namesz));
  ((*((abfd)->xvec->bfd_h_putx32)) (size, xnp->descsz));
  ((*((abfd)->xvec->bfd_h_putx32)) (type, xnp->type));
  dest = xnp->name;
  if (name != 
# 10362 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
             ((void *)0)
# 10362 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                 )
    {
      memcpy (dest, name, namesz);
      dest += namesz;
      while (namesz & 3)
 {
   *dest++ = '\0';
   ++namesz;
 }
    }
  memcpy (dest, input, size);
  dest += size;
  while (size & 3)
    {
      *dest++ = '\0';
      ++size;
    }
  return buf;
}

char *
elfcore_write_prpsinfo (bfd *abfd,
   char *buf,
   int *bufsiz,
   const char *fname,
   const char *psargs)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  if (bed->elf_backend_write_core_note != 
# 10391 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                         ((void *)0)
# 10391 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                             )
    {
      char *ret;
      ret = (*bed->elf_backend_write_core_note) (abfd, buf, bufsiz,
       3, fname, psargs);
      if (ret != 
# 10396 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 10396 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    )
 return ret;
    }



  if (bed->s->elfclass == 1)
    {




      prpsinfo32_t data;
      int note_type = 3;


      memset (&data, 0, sizeof (data));
      strncpy (data.pr_fname, fname, sizeof (data.pr_fname));
      strncpy (data.pr_psargs, psargs, sizeof (data.pr_psargs));
      return elfcore_write_note (abfd, buf, bufsiz,
     "CORE", note_type, &data, sizeof (data));
    }
  else

    {




      prpsinfo_t data;
      int note_type = 3;


      memset (&data, 0, sizeof (data));
      strncpy (data.pr_fname, fname, sizeof (data.pr_fname));
      strncpy (data.pr_psargs, psargs, sizeof (data.pr_psargs));
      return elfcore_write_note (abfd, buf, bufsiz,
     "CORE", note_type, &data, sizeof (data));
    }


  free (buf);
  return 
# 10438 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
        ((void *)0)
# 10438 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
            ;
}

char *
elfcore_write_linux_prpsinfo32
  (bfd *abfd, char *buf, int *bufsiz,
   const struct elf_internal_linux_prpsinfo *prpsinfo)
{
  struct elf_external_linux_prpsinfo32 data;

  swap_linux_prpsinfo32_out (abfd, prpsinfo, &data);
  return elfcore_write_note (abfd, buf, bufsiz, "CORE", 3,
        &data, sizeof (data));
}

char *
elfcore_write_linux_prpsinfo64
  (bfd *abfd, char *buf, int *bufsiz,
   const struct elf_internal_linux_prpsinfo *prpsinfo)
{
  struct elf_external_linux_prpsinfo64 data;

  swap_linux_prpsinfo64_out (abfd, prpsinfo, &data);
  return elfcore_write_note (abfd, buf, bufsiz,
        "CORE", 3, &data, sizeof (data));
}

char *
elfcore_write_prstatus (bfd *abfd,
   char *buf,
   int *bufsiz,
   long pid,
   int cursig,
   const void *gregs)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);

  if (bed->elf_backend_write_core_note != 
# 10475 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                                         ((void *)0)
# 10475 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                             )
    {
      char *ret;
      ret = (*bed->elf_backend_write_core_note) (abfd, buf, bufsiz,
       1,
       pid, cursig, gregs);
      if (ret != 
# 10481 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                ((void *)0)
# 10481 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                    )
 return ret;
    }



  if (bed->s->elfclass == 1)
    {
      prstatus32_t prstat;

      memset (&prstat, 0, sizeof (prstat));
      prstat.pr_pid = pid;
      prstat.pr_cursig = cursig;
      memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
      return elfcore_write_note (abfd, buf, bufsiz, "CORE",
     1, &prstat, sizeof (prstat));
    }
  else

    {
      prstatus_t prstat;

      memset (&prstat, 0, sizeof (prstat));
      prstat.pr_pid = pid;
      prstat.pr_cursig = cursig;
      memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
      return elfcore_write_note (abfd, buf, bufsiz, "CORE",
     1, &prstat, sizeof (prstat));
    }


  free (buf);
  return 
# 10513 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
        ((void *)0)
# 10513 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
            ;
}
# 10584 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
char *
elfcore_write_prfpreg (bfd *abfd,
         char *buf,
         int *bufsiz,
         const void *fpregs,
         int size)
{
  const char *note_name = "CORE";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 2, fpregs, size);
}

char *
elfcore_write_prxfpreg (bfd *abfd,
   char *buf,
   int *bufsiz,
   const void *xfpregs,
   int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x46e62b7f, xfpregs, size);
}

char *
elfcore_write_xstatereg (bfd *abfd, char *buf, int *bufsiz,
    const void *xfpregs, int size)
{
  char *note_name;
  if (((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->elf_osabi == 9)
    note_name = "FreeBSD";
  else
    note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x202, xfpregs, size);
}

char *
elfcore_write_ppc_vmx (bfd *abfd,
         char *buf,
         int *bufsiz,
         const void *ppc_vmx,
         int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x100, ppc_vmx, size);
}

char *
elfcore_write_ppc_vsx (bfd *abfd,
                       char *buf,
                       int *bufsiz,
                       const void *ppc_vsx,
                       int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x102, ppc_vsx, size);
}

static char *
elfcore_write_s390_high_gprs (bfd *abfd,
         char *buf,
         int *bufsiz,
         const void *s390_high_gprs,
         int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x300,
        s390_high_gprs, size);
}

char *
elfcore_write_s390_timer (bfd *abfd,
                          char *buf,
                          int *bufsiz,
                          const void *s390_timer,
                          int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x301, s390_timer, size);
}

char *
elfcore_write_s390_todcmp (bfd *abfd,
                           char *buf,
                           int *bufsiz,
                           const void *s390_todcmp,
                           int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x302, s390_todcmp, size);
}

char *
elfcore_write_s390_todpreg (bfd *abfd,
                            char *buf,
                            int *bufsiz,
                            const void *s390_todpreg,
                            int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x303, s390_todpreg, size);
}

char *
elfcore_write_s390_ctrs (bfd *abfd,
                         char *buf,
                         int *bufsiz,
                         const void *s390_ctrs,
                         int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x304, s390_ctrs, size);
}

char *
elfcore_write_s390_prefix (bfd *abfd,
                           char *buf,
                           int *bufsiz,
                           const void *s390_prefix,
                           int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x305, s390_prefix, size);
}

char *
elfcore_write_s390_last_break (bfd *abfd,
          char *buf,
          int *bufsiz,
          const void *s390_last_break,
          int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x306,
        s390_last_break, size);
}

char *
elfcore_write_s390_system_call (bfd *abfd,
    char *buf,
    int *bufsiz,
    const void *s390_system_call,
    int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x307,
        s390_system_call, size);
}

char *
elfcore_write_s390_tdb (bfd *abfd,
   char *buf,
   int *bufsiz,
   const void *s390_tdb,
   int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
                             note_name, 0x308, s390_tdb, size);
}

char *
elfcore_write_s390_vxrs_low (bfd *abfd,
        char *buf,
        int *bufsiz,
        const void *s390_vxrs_low,
        int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x309, s390_vxrs_low, size);
}

char *
elfcore_write_s390_vxrs_high (bfd *abfd,
        char *buf,
        int *bufsiz,
        const void *s390_vxrs_high,
        int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x30a,
        s390_vxrs_high, size);
}

char *
elfcore_write_s390_gs_cb (bfd *abfd,
     char *buf,
     int *bufsiz,
     const void *s390_gs_cb,
     int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x30b,
        s390_gs_cb, size);
}

char *
elfcore_write_s390_gs_bc (bfd *abfd,
     char *buf,
     int *bufsiz,
     const void *s390_gs_bc,
     int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x30c,
        s390_gs_bc, size);
}

char *
elfcore_write_arm_vfp (bfd *abfd,
         char *buf,
         int *bufsiz,
         const void *arm_vfp,
         int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x400, arm_vfp, size);
}

char *
elfcore_write_aarch_tls (bfd *abfd,
         char *buf,
         int *bufsiz,
         const void *aarch_tls,
         int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x401, aarch_tls, size);
}

char *
elfcore_write_aarch_hw_break (bfd *abfd,
       char *buf,
       int *bufsiz,
       const void *aarch_hw_break,
       int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x402, aarch_hw_break, size);
}

char *
elfcore_write_aarch_hw_watch (bfd *abfd,
       char *buf,
       int *bufsiz,
       const void *aarch_hw_watch,
       int size)
{
  char *note_name = "LINUX";
  return elfcore_write_note (abfd, buf, bufsiz,
        note_name, 0x403, aarch_hw_watch, size);
}

char *
elfcore_write_register_note (bfd *abfd,
        char *buf,
        int *bufsiz,
        const char *section,
        const void *data,
        int size)
{
  if (strcmp (section, ".reg2") == 0)
    return elfcore_write_prfpreg (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-xfp") == 0)
    return elfcore_write_prxfpreg (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-xstate") == 0)
    return elfcore_write_xstatereg (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-ppc-vmx") == 0)
    return elfcore_write_ppc_vmx (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-ppc-vsx") == 0)
    return elfcore_write_ppc_vsx (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-high-gprs") == 0)
    return elfcore_write_s390_high_gprs (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-timer") == 0)
    return elfcore_write_s390_timer (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-todcmp") == 0)
    return elfcore_write_s390_todcmp (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-todpreg") == 0)
    return elfcore_write_s390_todpreg (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-ctrs") == 0)
    return elfcore_write_s390_ctrs (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-prefix") == 0)
    return elfcore_write_s390_prefix (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-last-break") == 0)
    return elfcore_write_s390_last_break (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-system-call") == 0)
    return elfcore_write_s390_system_call (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-tdb") == 0)
    return elfcore_write_s390_tdb (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-vxrs-low") == 0)
    return elfcore_write_s390_vxrs_low (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-vxrs-high") == 0)
    return elfcore_write_s390_vxrs_high (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-gs-cb") == 0)
    return elfcore_write_s390_gs_cb (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-s390-gs-bc") == 0)
    return elfcore_write_s390_gs_bc (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-arm-vfp") == 0)
    return elfcore_write_arm_vfp (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-aarch-tls") == 0)
    return elfcore_write_aarch_tls (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-aarch-hw-break") == 0)
    return elfcore_write_aarch_hw_break (abfd, buf, bufsiz, data, size);
  if (strcmp (section, ".reg-aarch-hw-watch") == 0)
    return elfcore_write_aarch_hw_watch (abfd, buf, bufsiz, data, size);
  return 
# 10907 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
        ((void *)0)
# 10907 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
            ;
}

static bfd_boolean
elf_parse_notes (bfd *abfd, char *buf, size_t size, file_ptr offset)
{
  char *p;

  p = buf;
  while (p < buf + size)
    {

      Elf_External_Note *xnp = (Elf_External_Note *) p;
      Elf_Internal_Note in;

      if (
# 10922 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
         __builtin_offsetof (
# 10922 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
         Elf_External_Note
# 10922 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
         , 
# 10922 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
         name
# 10922 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
         ) 
# 10922 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                            > buf - p + size)
 return 0;

      in.type = ((*((abfd)->xvec->bfd_h_getx32)) (xnp->type));

      in.namesz = ((*((abfd)->xvec->bfd_h_getx32)) (xnp->namesz));
      in.namedata = xnp->name;
      if (in.namesz > buf - in.namedata + size)
 return 0;

      in.descsz = ((*((abfd)->xvec->bfd_h_getx32)) (xnp->descsz));
      in.descdata = in.namedata + ((((bfd_vma) (in.namesz) + (4) - 1) >= (bfd_vma) (in.namesz)) ? (((bfd_vma) (in.namesz) + ((4) - 1)) & ~ (bfd_vma) ((4)-1)) : ~ (bfd_vma) 0);
      in.descpos = offset + (in.descdata - buf);
      if (in.descsz != 0
   && (in.descdata >= buf + size
       || in.descsz > buf - in.descdata + size))
 return 0;

      switch (((abfd)->format))
        {
 default:
   return 1;

 case bfd_core:
   {

     struct
     {
       const char * string;
       size_t len;
       bfd_boolean (* func)(bfd *, Elf_Internal_Note *);
     }
     grokers[] =
     {
       {"", sizeof ("") - 1, elfcore_grok_note},
       {"FreeBSD", sizeof ("FreeBSD") - 1, elfcore_grok_freebsd_note},
       {"NetBSD-CORE", sizeof ("NetBSD-CORE") - 1, elfcore_grok_netbsd_note},
       {"OpenBSD", sizeof ("OpenBSD") - 1, elfcore_grok_openbsd_note},
       {"QNX", sizeof ("QNX") - 1, elfcore_grok_nto_note},
       {"SPU/", sizeof ("SPU/") - 1, elfcore_grok_spu_note}
     };

     int i;

     for (i = (sizeof (grokers) / sizeof ((grokers)[0])); i--;)
       {
  if (in.namesz >= grokers[i].len
      && strncmp (in.namedata, grokers[i].string,
    grokers[i].len) == 0)
    {
      if (! grokers[i].func (abfd, & in))
        return 0;
      break;
    }
       }
     break;
   }

 case bfd_object:
   if (in.namesz == sizeof "GNU" && strcmp (in.namedata, "GNU") == 0)
     {
       if (! elfobj_grok_gnu_note (abfd, &in))
  return 0;
     }
   else if (in.namesz == sizeof "stapsdt"
     && strcmp (in.namedata, "stapsdt") == 0)
     {
       if (! elfobj_grok_stapsdt_note (abfd, &in))
  return 0;
     }
   break;
 }

      p = in.descdata + ((((bfd_vma) (in.descsz) + (4) - 1) >= (bfd_vma) (in.descsz)) ? (((bfd_vma) (in.descsz) + ((4) - 1)) & ~ (bfd_vma) ((4)-1)) : ~ (bfd_vma) 0);
    }

  return 1;
}

static bfd_boolean
elf_read_notes (bfd *abfd, file_ptr offset, bfd_size_type size)
{
  char *buf;

  if (size == 0 || (size + 1) == 0)
    return 1;

  if (bfd_seek (abfd, offset, 
# 11009 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                             0
# 11009 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                                     ) != 0)
    return 0;

  buf = (char *) bfd_malloc (size + 1);
  if (buf == 
# 11013 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 11013 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
    return 0;



  buf[size] = 0;

  if (bfd_bread (buf, size, abfd) != size
      || !elf_parse_notes (abfd, buf, size, offset))
    {
      free (buf);
      return 0;
    }

  free (buf);
  return 1;
}







long
bfd_get_elf_phdr_upper_bound (bfd *abfd)
{
  if (abfd->xvec->flavour != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  return (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum * sizeof (Elf_Internal_Phdr);
}
# 11057 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
int
bfd_get_elf_phdrs (bfd *abfd, void *phdrs)
{
  int num_phdrs;

  if (abfd->xvec->flavour != bfd_target_elf_flavour)
    {
      bfd_set_error (bfd_error_wrong_format);
      return -1;
    }

  num_phdrs = (((abfd) -> tdata.elf_obj_data) -> elf_header)->e_phnum;
  memcpy (phdrs, ((abfd) -> tdata.elf_obj_data)->phdr,
   num_phdrs * sizeof (Elf_Internal_Phdr));

  return num_phdrs;
}

enum elf_reloc_type_class
_bfd_elf_reloc_type_class (const struct bfd_link_info *info __attribute__ ((__unused__)),
      const asection *rel_sec __attribute__ ((__unused__)),
      const Elf_Internal_Rela *rela __attribute__ ((__unused__)))
{
  return reloc_class_normal;
}




bfd_vma
_bfd_elf_rela_local_sym (bfd *abfd,
    Elf_Internal_Sym *sym,
    asection **psec,
    Elf_Internal_Rela *rel)
{
  asection *sec = *psec;
  bfd_vma relocation;

  relocation = (sec->output_section->vma
  + sec->output_offset
  + sym->st_value);
  if ((sec->flags & 0x800000)
      && ((sym->st_info) & 0xF) == 3
      && sec->sec_info_type == 2)
    {
      rel->r_addend =
 _bfd_merged_section_offset (abfd, psec,
        ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sec_info,
        sym->st_value + rel->r_addend);
      if (sec != *psec)
 {





   if ((sec->flags & 0x8000) != 0)
     sec->kept_section = *psec;
   sec = *psec;
 }
      rel->r_addend -= relocation;
      rel->r_addend += sec->output_section->vma + sec->output_offset;
    }
  return relocation;
}

bfd_vma
_bfd_elf_rel_local_sym (bfd *abfd,
   Elf_Internal_Sym *sym,
   asection **psec,
   bfd_vma addend)
{
  asection *sec = *psec;

  if (sec->sec_info_type != 2)
    return sym->st_value + addend;

  return _bfd_merged_section_offset (abfd, psec,
         ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sec_info,
         sym->st_value + addend);
}







bfd_vma
_bfd_elf_section_offset (bfd *abfd,
    struct bfd_link_info *info,
    asection *sec,
    bfd_vma offset)
{
  switch (sec->sec_info_type)
    {
    case 1:
      return _bfd_stab_section_offset (sec, ((struct bfd_elf_section_data*)(sec)->used_by_bfd)->sec_info,
           offset);
    case 3:
      return _bfd_elf_eh_frame_section_offset (abfd, info, sec, offset);

    default:
      if ((sec->flags & 0x4000000) != 0)
 {

   const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
   bfd_size_type address_size = bed->s->arch_size / 8;



   offset = (sec->size - address_size) / bfd_octets_per_byte (abfd) - offset;
 }
      return offset;
    }
}
# 11187 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
bfd *
bfd_elf_bfd_from_remote_memory
  (bfd *templ,
   bfd_vma ehdr_vma,
   bfd_size_type size,
   bfd_vma *loadbasep,
   int (*target_read_memory) (bfd_vma, bfd_byte *, bfd_size_type))
{
  return (*((const struct elf_backend_data *) ((templ)->xvec)->backend_data)->elf_backend_bfd_from_remote_memory)
    (templ, ehdr_vma, size, loadbasep, target_read_memory);
}

long
_bfd_elf_get_synthetic_symtab (bfd *abfd,
          long symcount __attribute__ ((__unused__)),
          asymbol **syms __attribute__ ((__unused__)),
          long dynsymcount,
          asymbol **dynsyms,
          asymbol **ret)
{
  const struct elf_backend_data *bed = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data);
  asection *relplt;
  asymbol *s;
  const char *relplt_name;
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  arelent *p;
  long count, i, n;
  size_t size;
  Elf_Internal_Shdr *hdr;
  char *names;
  asection *plt;

  *ret = 
# 11219 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
        ((void *)0)
# 11219 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
            ;

  if ((abfd->flags & (0x40 | 0x02)) == 0)
    return 0;

  if (dynsymcount <= 0)
    return 0;

  if (!bed->plt_sym_val)
    return 0;

  relplt_name = bed->relplt_name;
  if (relplt_name == 
# 11231 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                    ((void *)0)
# 11231 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                        )
    relplt_name = bed->rela_plts_and_copies_p ? ".rela.plt" : ".rel.plt";
  relplt = bfd_get_section_by_name (abfd, relplt_name);
  if (relplt == 
# 11234 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
               ((void *)0)
# 11234 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                   )
    return 0;

  hdr = &((struct bfd_elf_section_data*)(relplt)->used_by_bfd)->this_hdr;
  if (hdr->sh_link != (((abfd) -> tdata.elf_obj_data) -> dynsymtab_section)
      || (hdr->sh_type != 9 && hdr->sh_type != 4))
    return 0;

  plt = bfd_get_section_by_name (abfd, ".plt");
  if (plt == 
# 11243 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
            ((void *)0)
# 11243 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                )
    return 0;

  slurp_relocs = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->s->slurp_reloc_table;
  if (! (*slurp_relocs) (abfd, relplt, dynsyms, 1))
    return -1;

  count = relplt->size / hdr->sh_entsize;
  size = count * sizeof (asymbol);
  p = relplt->relocation;
  for (i = 0; i < count; i++, p += bed->s->int_rels_per_ext_rel)
    {
      size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@plt");
      if (p->addend != 0)
 {

   size += sizeof ("+0x") - 1 + 8 + 8 * (bed->s->elfclass == 2);



 }
    }

  s = *ret = (asymbol *) bfd_malloc (size);
  if (s == 
# 11267 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
          ((void *)0)
# 11267 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
              )
    return -1;

  names = (char *) (s + count);
  p = relplt->relocation;
  n = 0;
  for (i = 0; i < count; i++, p += bed->s->int_rels_per_ext_rel)
    {
      size_t len;
      bfd_vma addr;

      addr = bed->plt_sym_val (i, plt, p);
      if (addr == (bfd_vma) -1)
 continue;

      *s = **p->sym_ptr_ptr;


      if ((s->flags & (1 << 0)) == 0)
 s->flags |= (1 << 1);
      s->flags |= (1 << 21);
      s->section = plt;
      s->value = addr - plt->vma;
      s->name = names;
      s->udata.p = 
# 11291 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
                  ((void *)0)
# 11291 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
                      ;
      len = strlen ((*p->sym_ptr_ptr)->name);
      memcpy (names, (*p->sym_ptr_ptr)->name, len);
      names += len;
      if (p->addend != 0)
 {
   char buf[30], *a;

   memcpy (names, "+0x", sizeof ("+0x") - 1);
   names += sizeof ("+0x") - 1;
   bfd_sprintf_vma (abfd, buf, p->addend);
   for (a = buf; *a == '0'; ++a)
     ;
   len = strlen (a);
   memcpy (names, a, len);
   names += len;
 }
      memcpy (names, "@plt", sizeof ("@plt"));
      names += sizeof ("@plt");
      ++s, ++n;
    }

  return n;
}




static const asymbol lcomm_sym
  = { 0, "LARGE_COMMON", 0, (1 << 8), &_bfd_elf_large_com_section, { 0 }};
asection _bfd_elf_large_com_section
  = { "LARGE_COMMON", 0, 0, 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 0x1000, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &_bfd_elf_large_com_section, 0, 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 0, 0, 0, 0, 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 0, 0, 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 0, 0, 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0)
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   , (struct bfd_symbol *) &lcomm_sym, &_bfd_elf_large_com_section.symbol, { 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0) 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   }, { 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c" 3 4
   ((void *)0) 
# 11322 "/doner/binutils/binutils-7a31b38/bfd/elf.c"
   } }
                                         ;

void
_bfd_elf_post_process_headers (bfd * abfd,
          struct bfd_link_info * link_info __attribute__ ((__unused__)))
{
  Elf_Internal_Ehdr * i_ehdrp;

  i_ehdrp = (((abfd) -> tdata.elf_obj_data) -> elf_header);

  i_ehdrp->e_ident[7] = ((const struct elf_backend_data *) ((abfd)->xvec)->backend_data)->elf_osabi;




  if (i_ehdrp->e_ident[7] == 0
      && ((abfd) -> tdata.elf_obj_data)->has_gnu_symbols)
    i_ehdrp->e_ident[7] = 3;
}






bfd_boolean
_bfd_elf_is_function_type (unsigned int type)
{
  return (type == 2
   || type == 10);
}





bfd_size_type
_bfd_elf_maybe_function_sym (const asymbol *sym, asection *sec,
        bfd_vma *code_off)
{
  bfd_size_type size;

  if ((sym->flags & ((1 << 8) | (1 << 14) | (1 << 16)
       | (1 << 18) | (1 << 19) | (1 << 20))) != 0
      || sym->section != sec)
    return 0;

  *code_off = sym->value;
  size = 0;
  if (!(sym->flags & (1 << 21)))
    size = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;
  if (size == 0)
    size = 1;
  return size;
}
